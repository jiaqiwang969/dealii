// This file is automatically generated from corresponding .inst.in, do not edit.

#ifdef SPLIT_INSTANTIATIONS_COUNT
  #define SPLIT_INSTANTIATIONS_CHECK(C) (((C) % SPLIT_INSTANTIATIONS_COUNT) == SPLIT_INSTANTIATIONS_INDEX)
#else
  #define SPLIT_INSTANTIATIONS_CHECK(C) (1)
#endif

#if (SPLIT_INSTANTIATIONS_CHECK(0))
namespace GridGenerator
 {
#if  1  <=  1 
 template void
 hyper_rectangle< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const Point< 1 > &,
 const Point< 1 > &,
 const bool);

 template void
 hyper_cube< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const std::vector<unsigned int> &,
 const Point< 1 > &,
 const Point< 1 > &,
 const bool);

 template void
 subdivided_parallelepiped< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const Point< 1 > &,
 const std::array<Tensor<1,  1 >,  1 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 1 ,  1 > &,
 const std::vector<unsigned int> &,
 const Point< 1 > &,
 const Point< 1 > &,
 const std::vector<int> &);

 template void
 cheese< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 1 ,  1 > *> &,
 Triangulation< 1 ,  1 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 1 ,  1 >
 &triangulation_1,
 const Triangulation< 1 ,  1 >
 &triangulation_2,
 Triangulation< 1 ,  1 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 1 ,  1 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 1 ,  1 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 1 ,  1 >
 &triangulation_1,
 const Triangulation< 1 ,  1 >
 &triangulation_2,
 Triangulation< 1 ,  1 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 1 ,  1 >
 &input_triangulation,
 const std::set<
 Triangulation< 1 ,
  1 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 1 ,  1 > &result);

 template void
 general_cell(Triangulation< 1 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(1))
namespace GridGenerator
 {
#if  1  <=  2 
 template void
 hyper_rectangle< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const Point< 1 > &,
 const Point< 1 > &,
 const bool);

 template void
 hyper_cube< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const std::vector<unsigned int> &,
 const Point< 1 > &,
 const Point< 1 > &,
 const bool);

 template void
 subdivided_parallelepiped< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const Point< 2 > &,
 const std::array<Tensor<1,  2 >,  1 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 1 ,  2 > &,
 const std::vector<unsigned int> &,
 const Point< 1 > &,
 const Point< 1 > &,
 const std::vector<int> &);

 template void
 cheese< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 1 ,  2 > *> &,
 Triangulation< 1 ,  2 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 1 ,  2 >
 &triangulation_1,
 const Triangulation< 1 ,  2 >
 &triangulation_2,
 Triangulation< 1 ,  2 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 1 ,  2 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 1 ,  2 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 1 ,  2 >
 &triangulation_1,
 const Triangulation< 1 ,  2 >
 &triangulation_2,
 Triangulation< 1 ,  2 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 1 ,  2 >
 &input_triangulation,
 const std::set<
 Triangulation< 1 ,
  2 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 1 ,  2 > &result);

 template void
 general_cell(Triangulation< 1 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(2))
namespace GridGenerator
 {
#if  1  <=  3 
 template void
 hyper_rectangle< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const Point< 1 > &,
 const Point< 1 > &,
 const bool);

 template void
 hyper_cube< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const std::vector<unsigned int> &,
 const Point< 1 > &,
 const Point< 1 > &,
 const bool);

 template void
 subdivided_parallelepiped< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const Point< 3 > &,
 const std::array<Tensor<1,  3 >,  1 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 1 ,  3 > &,
 const std::vector<unsigned int> &,
 const Point< 1 > &,
 const Point< 1 > &,
 const std::vector<int> &);

 template void
 cheese< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 1 ,  3 > *> &,
 Triangulation< 1 ,  3 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 1 ,  3 >
 &triangulation_1,
 const Triangulation< 1 ,  3 >
 &triangulation_2,
 Triangulation< 1 ,  3 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 1 ,  3 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 1 ,  3 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 1 ,  3 >
 &triangulation_1,
 const Triangulation< 1 ,  3 >
 &triangulation_2,
 Triangulation< 1 ,  3 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 1 ,  3 >
 &input_triangulation,
 const std::set<
 Triangulation< 1 ,
  3 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 1 ,  3 > &result);

 template void
 general_cell(Triangulation< 1 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(3))
namespace GridGenerator
 {
#if  2  <=  1 
 template void
 hyper_rectangle< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const Point< 2 > &,
 const Point< 2 > &,
 const bool);

 template void
 hyper_cube< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const std::vector<unsigned int> &,
 const Point< 2 > &,
 const Point< 2 > &,
 const bool);

 template void
 subdivided_parallelepiped< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const Point< 1 > &,
 const std::array<Tensor<1,  1 >,  2 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 2 ,  1 > &,
 const std::vector<unsigned int> &,
 const Point< 2 > &,
 const Point< 2 > &,
 const std::vector<int> &);

 template void
 cheese< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 2 ,  1 > *> &,
 Triangulation< 2 ,  1 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 2 ,  1 >
 &triangulation_1,
 const Triangulation< 2 ,  1 >
 &triangulation_2,
 Triangulation< 2 ,  1 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 2 ,  1 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 2 ,  1 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 2 ,  1 >
 &triangulation_1,
 const Triangulation< 2 ,  1 >
 &triangulation_2,
 Triangulation< 2 ,  1 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 2 ,  1 >
 &input_triangulation,
 const std::set<
 Triangulation< 2 ,
  1 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 2 ,  1 > &result);

 template void
 general_cell(Triangulation< 2 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(4))
namespace GridGenerator
 {
#if  2  <=  2 
 template void
 hyper_rectangle< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const Point< 2 > &,
 const Point< 2 > &,
 const bool);

 template void
 hyper_cube< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const std::vector<unsigned int> &,
 const Point< 2 > &,
 const Point< 2 > &,
 const bool);

 template void
 subdivided_parallelepiped< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const Point< 2 > &,
 const std::array<Tensor<1,  2 >,  2 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 2 ,  2 > &,
 const std::vector<unsigned int> &,
 const Point< 2 > &,
 const Point< 2 > &,
 const std::vector<int> &);

 template void
 cheese< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 2 ,  2 > *> &,
 Triangulation< 2 ,  2 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 2 ,  2 >
 &triangulation_1,
 const Triangulation< 2 ,  2 >
 &triangulation_2,
 Triangulation< 2 ,  2 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 2 ,  2 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 2 ,  2 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 2 ,  2 >
 &triangulation_1,
 const Triangulation< 2 ,  2 >
 &triangulation_2,
 Triangulation< 2 ,  2 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 2 ,  2 >
 &input_triangulation,
 const std::set<
 Triangulation< 2 ,
  2 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 2 ,  2 > &result);

 template void
 general_cell(Triangulation< 2 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(5))
namespace GridGenerator
 {
#if  2  <=  3 
 template void
 hyper_rectangle< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const Point< 2 > &,
 const Point< 2 > &,
 const bool);

 template void
 hyper_cube< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const std::vector<unsigned int> &,
 const Point< 2 > &,
 const Point< 2 > &,
 const bool);

 template void
 subdivided_parallelepiped< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const Point< 3 > &,
 const std::array<Tensor<1,  3 >,  2 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 2 ,  3 > &,
 const std::vector<unsigned int> &,
 const Point< 2 > &,
 const Point< 2 > &,
 const std::vector<int> &);

 template void
 cheese< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 2 ,  3 > *> &,
 Triangulation< 2 ,  3 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 2 ,  3 >
 &triangulation_1,
 const Triangulation< 2 ,  3 >
 &triangulation_2,
 Triangulation< 2 ,  3 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 2 ,  3 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 2 ,  3 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 2 ,  3 >
 &triangulation_1,
 const Triangulation< 2 ,  3 >
 &triangulation_2,
 Triangulation< 2 ,  3 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 2 ,  3 >
 &input_triangulation,
 const std::set<
 Triangulation< 2 ,
  3 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 2 ,  3 > &result);

 template void
 general_cell(Triangulation< 2 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(6))
namespace GridGenerator
 {
#if  3  <=  1 
 template void
 hyper_rectangle< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const Point< 3 > &,
 const Point< 3 > &,
 const bool);

 template void
 hyper_cube< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const std::vector<unsigned int> &,
 const Point< 3 > &,
 const Point< 3 > &,
 const bool);

 template void
 subdivided_parallelepiped< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const Point< 1 > &,
 const std::array<Tensor<1,  1 >,  3 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 3 ,  1 > &,
 const std::vector<unsigned int> &,
 const Point< 3 > &,
 const Point< 3 > &,
 const std::vector<int> &);

 template void
 cheese< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 3 ,  1 > *> &,
 Triangulation< 3 ,  1 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 3 ,  1 >
 &triangulation_1,
 const Triangulation< 3 ,  1 >
 &triangulation_2,
 Triangulation< 3 ,  1 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 3 ,  1 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 3 ,  1 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 3 ,  1 >
 &triangulation_1,
 const Triangulation< 3 ,  1 >
 &triangulation_2,
 Triangulation< 3 ,  1 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 3 ,  1 >
 &input_triangulation,
 const std::set<
 Triangulation< 3 ,
  1 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 3 ,  1 > &result);

 template void
 general_cell(Triangulation< 3 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(7))
namespace GridGenerator
 {
#if  3  <=  2 
 template void
 hyper_rectangle< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const Point< 3 > &,
 const Point< 3 > &,
 const bool);

 template void
 hyper_cube< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const std::vector<unsigned int> &,
 const Point< 3 > &,
 const Point< 3 > &,
 const bool);

 template void
 subdivided_parallelepiped< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const Point< 2 > &,
 const std::array<Tensor<1,  2 >,  3 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 3 ,  2 > &,
 const std::vector<unsigned int> &,
 const Point< 3 > &,
 const Point< 3 > &,
 const std::vector<int> &);

 template void
 cheese< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 3 ,  2 > *> &,
 Triangulation< 3 ,  2 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 3 ,  2 >
 &triangulation_1,
 const Triangulation< 3 ,  2 >
 &triangulation_2,
 Triangulation< 3 ,  2 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 3 ,  2 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 3 ,  2 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 3 ,  2 >
 &triangulation_1,
 const Triangulation< 3 ,  2 >
 &triangulation_2,
 Triangulation< 3 ,  2 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 3 ,  2 >
 &input_triangulation,
 const std::set<
 Triangulation< 3 ,
  2 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 3 ,  2 > &result);

 template void
 general_cell(Triangulation< 3 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(8))
namespace GridGenerator
 {
#if  3  <=  3 
 template void
 hyper_rectangle< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const Point< 3 > &,
 const Point< 3 > &,
 const bool);

 template void
 hyper_cube< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const double,
 const double,
 const bool);

 template void
 subdivided_hyper_cube< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const unsigned int,
 const double,
 const double,
 const bool);


 template void
 subdivided_hyper_rectangle< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const std::vector<unsigned int> &,
 const Point< 3 > &,
 const Point< 3 > &,
 const bool);

 template void
 subdivided_parallelepiped< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const Point< 3 > &,
 const std::array<Tensor<1,  3 >,  3 >
 &,
 const std::vector<unsigned int> &,
 const bool colorize);

 template void
 hyper_cross< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const std::vector<unsigned int> &,
 const bool);

 template void
 subdivided_hyper_L(
 Triangulation< 3 ,  3 > &,
 const std::vector<unsigned int> &,
 const Point< 3 > &,
 const Point< 3 > &,
 const std::vector<int> &);

 template void
 cheese< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const std::vector<unsigned int> &);

 template void
 merge_triangulations(
 const std::vector<
 const Triangulation< 3 ,  3 > *> &,
 Triangulation< 3 ,  3 > &,
 const double,
 const bool);

 template void
 merge_triangulations(
 const Triangulation< 3 ,  3 >
 &triangulation_1,
 const Triangulation< 3 ,  3 >
 &triangulation_2,
 Triangulation< 3 ,  3 > &result,
 const double duplicated_vertex_tolerance,
 const bool copy_manifold_ids);

 template void
 replicate_triangulation(
 const Triangulation< 3 ,  3 > &input,
 const std::vector<unsigned int> & extents,
 Triangulation< 3 ,  3 > &result);

 template void
 create_union_triangulation(
 const Triangulation< 3 ,  3 >
 &triangulation_1,
 const Triangulation< 3 ,  3 >
 &triangulation_2,
 Triangulation< 3 ,  3 > &result);

 template void
 create_triangulation_with_removed_cells(
 const Triangulation< 3 ,  3 >
 &input_triangulation,
 const std::set<
 Triangulation< 3 ,
  3 >::active_cell_iterator>
 &cells_to_remove,
 Triangulation< 3 ,  3 > &result);

 template void
 general_cell(Triangulation< 3 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const bool);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(9))
#if  1  <=  1 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 1  - 1,
  1 >::cell_iterator,
  Triangulation < 1 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  1 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 1 ,  1 > &mesh,
  Triangulation < 1  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(10))
#if  1  <=  1 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 1  - 1,
  1 >::cell_iterator,
  parallel::shared::Triangulation < 1 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  1 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 1 ,  1 > &mesh,
  parallel::shared::Triangulation < 1  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(11))
#if  1  <=  1 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 1  - 1,
  1 >::cell_iterator,
  parallel::distributed::Triangulation < 1 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  1 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 1 ,  1 > &mesh,
  parallel::distributed::Triangulation < 1  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(12))
#if  1  <=  1 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 1  - 1,
  1 >::cell_iterator,
  DoFHandler < 1 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  1 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 1 ,  1 > &mesh,
  DoFHandler < 1  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(13))
#if  1  <=  2 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 1  - 1,
  2 >::cell_iterator,
  Triangulation < 1 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  1 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 1 ,  2 > &mesh,
  Triangulation < 1  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(14))
#if  1  <=  2 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 1  - 1,
  2 >::cell_iterator,
  parallel::shared::Triangulation < 1 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  1 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 1 ,  2 > &mesh,
  parallel::shared::Triangulation < 1  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(15))
#if  1  <=  2 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 1  - 1,
  2 >::cell_iterator,
  parallel::distributed::Triangulation < 1 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  1 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 1 ,  2 > &mesh,
  parallel::distributed::Triangulation < 1  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(16))
#if  1  <=  2 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 1  - 1,
  2 >::cell_iterator,
  DoFHandler < 1 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  1 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 1 ,  2 > &mesh,
  DoFHandler < 1  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(17))
#if  1  <=  3 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 1  - 1,
  3 >::cell_iterator,
  Triangulation < 1 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  1 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 1 ,  3 > &mesh,
  Triangulation < 1  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(18))
#if  1  <=  3 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 1  - 1,
  3 >::cell_iterator,
  parallel::shared::Triangulation < 1 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  1 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 1 ,  3 > &mesh,
  parallel::shared::Triangulation < 1  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(19))
#if  1  <=  3 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 1  - 1,
  3 >::cell_iterator,
  parallel::distributed::Triangulation < 1 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  1 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 1 ,  3 > &mesh,
  parallel::distributed::Triangulation < 1  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(20))
#if  1  <=  3 
 namespace GridGenerator
 {

# if  1  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 1  - 1,
  3 >::cell_iterator,
  DoFHandler < 1 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  1 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 1 ,  3 > &mesh,
  DoFHandler < 1  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(21))
#if  2  <=  1 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 2  - 1,
  1 >::cell_iterator,
  Triangulation < 2 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  2 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 2 ,  1 > &mesh,
  Triangulation < 2  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(22))
#if  2  <=  1 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 2  - 1,
  1 >::cell_iterator,
  parallel::shared::Triangulation < 2 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  2 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 2 ,  1 > &mesh,
  parallel::shared::Triangulation < 2  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(23))
#if  2  <=  1 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 2  - 1,
  1 >::cell_iterator,
  parallel::distributed::Triangulation < 2 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  2 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 2 ,  1 > &mesh,
  parallel::distributed::Triangulation < 2  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(24))
#if  2  <=  1 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 2  - 1,
  1 >::cell_iterator,
  DoFHandler < 2 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  2 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 2 ,  1 > &mesh,
  DoFHandler < 2  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(25))
#if  2  <=  2 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 2  - 1,
  2 >::cell_iterator,
  Triangulation < 2 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  2 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 2 ,  2 > &mesh,
  Triangulation < 2  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(26))
#if  2  <=  2 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 2  - 1,
  2 >::cell_iterator,
  parallel::shared::Triangulation < 2 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  2 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 2 ,  2 > &mesh,
  parallel::shared::Triangulation < 2  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(27))
#if  2  <=  2 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 2  - 1,
  2 >::cell_iterator,
  parallel::distributed::Triangulation < 2 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  2 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 2 ,  2 > &mesh,
  parallel::distributed::Triangulation < 2  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(28))
#if  2  <=  2 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 2  - 1,
  2 >::cell_iterator,
  DoFHandler < 2 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  2 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 2 ,  2 > &mesh,
  DoFHandler < 2  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(29))
#if  2  <=  3 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 2  - 1,
  3 >::cell_iterator,
  Triangulation < 2 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  2 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 2 ,  3 > &mesh,
  Triangulation < 2  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(30))
#if  2  <=  3 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 2  - 1,
  3 >::cell_iterator,
  parallel::shared::Triangulation < 2 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  2 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 2 ,  3 > &mesh,
  parallel::shared::Triangulation < 2  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(31))
#if  2  <=  3 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 2  - 1,
  3 >::cell_iterator,
  parallel::distributed::Triangulation < 2 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  2 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 2 ,  3 > &mesh,
  parallel::distributed::Triangulation < 2  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(32))
#if  2  <=  3 
 namespace GridGenerator
 {

# if  2  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 2  - 1,
  3 >::cell_iterator,
  DoFHandler < 2 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  2 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 2 ,  3 > &mesh,
  DoFHandler < 2  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(33))
#if  3  <=  1 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 3  - 1,
  1 >::cell_iterator,
  Triangulation < 3 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  3 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 3 ,  1 > &mesh,
  Triangulation < 3  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(34))
#if  3  <=  1 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 3  - 1,
  1 >::cell_iterator,
  parallel::shared::Triangulation < 3 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  3 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 3 ,  1 > &mesh,
  parallel::shared::Triangulation < 3  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(35))
#if  3  <=  1 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 3  - 1,
  1 >::cell_iterator,
  parallel::distributed::Triangulation < 3 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  3 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 3 ,  1 > &mesh,
  parallel::distributed::Triangulation < 3  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(36))
#if  3  <=  1 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 3  - 1,
  1 >::cell_iterator,
  DoFHandler < 3 ,  1 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  3 ,
  1 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 3 ,  1 > &mesh,
  DoFHandler < 3  - 1,  1 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(37))
#if  3  <=  2 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 3  - 1,
  2 >::cell_iterator,
  Triangulation < 3 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  3 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 3 ,  2 > &mesh,
  Triangulation < 3  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(38))
#if  3  <=  2 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 3  - 1,
  2 >::cell_iterator,
  parallel::shared::Triangulation < 3 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  3 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 3 ,  2 > &mesh,
  parallel::shared::Triangulation < 3  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(39))
#if  3  <=  2 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 3  - 1,
  2 >::cell_iterator,
  parallel::distributed::Triangulation < 3 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  3 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 3 ,  2 > &mesh,
  parallel::distributed::Triangulation < 3  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(40))
#if  3  <=  2 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 3  - 1,
  2 >::cell_iterator,
  DoFHandler < 3 ,  2 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  3 ,
  2 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 3 ,  2 > &mesh,
  DoFHandler < 3  - 1,  2 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(41))
#if  3  <=  3 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  Triangulation < 3  - 1,
  3 >::cell_iterator,
  Triangulation < 3 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< Triangulation ,
  3 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  Triangulation < 3 ,  3 > &mesh,
  Triangulation < 3  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(42))
#if  3  <=  3 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::shared::Triangulation < 3  - 1,
  3 >::cell_iterator,
  parallel::shared::Triangulation < 3 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::shared::Triangulation ,
  3 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::shared::Triangulation < 3 ,  3 > &mesh,
  parallel::shared::Triangulation < 3  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(43))
#if  3  <=  3 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  parallel::distributed::Triangulation < 3  - 1,
  3 >::cell_iterator,
  parallel::distributed::Triangulation < 3 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< parallel::distributed::Triangulation ,
  3 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  parallel::distributed::Triangulation < 3 ,  3 > &mesh,
  parallel::distributed::Triangulation < 3  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(44))
#if  3  <=  3 
 namespace GridGenerator
 {

# if  3  != 1
 template
# ifndef _MSC_VER
 std::map<
  DoFHandler < 3  - 1,
  3 >::cell_iterator,
  DoFHandler < 3 ,  3 >::face_iterator>
# else
 ExtractBoundaryMesh< DoFHandler ,
  3 ,
  3 >::return_type
# endif
 extract_boundary_mesh(
 const  DoFHandler < 3 ,  3 > &mesh,
  DoFHandler < 3  - 1,  3 >
 & boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(45))
namespace GridGenerator
 {

 template void
 subdivided_hyper_rectangle(Triangulation< 1 > &,
 const std::vector<std::vector<double>> &,
 const Point< 1 > &,
 const Point< 1 > &,
 const bool);

 template void
 simplex< 1 >(
 Triangulation< 1 ,  1 > &,
 const std::vector<Point< 1 >> &);

 template void
 parallelepiped< 1 >(
 Triangulation< 1 > &,
 const Point< 1 > (&)[ 1 ],
 const bool);

 template void
 subdivided_parallelepiped< 1 >(
 Triangulation< 1 > &,
 const unsigned int,
 const Point< 1 > (&)[ 1 ],
 const bool);

#ifndef _MSC_VER
 template void
 subdivided_parallelepiped< 1 >(
 Triangulation< 1 > &,
 const unsigned int (&)[ 1 ],
 const Point< 1 > (&)[ 1 ],
 const bool);
#else
 template void
 subdivided_parallelepiped< 1 >(
 Triangulation< 1 > &,
 const unsigned int *,
 const Point< 1 > (&)[ 1 ],
 const bool);
#endif

 template void
 concentric_hyper_shells(Triangulation< 1 > &,
 const Point< 1 > &,
 const double,
 const double,
 const unsigned int,
 const double,
 const unsigned int,
 const bool);

 template void
 eccentric_hyper_shell(Triangulation< 1 > &,
 const Point< 1 > &,
 const Point< 1 > &,
 const double,
 const double,
 const unsigned int);

#if  1  >= 2
 template void
 hyper_ball_balanced< 1 >(Triangulation< 1 > &,
 const Point< 1 > &,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(46))
namespace GridGenerator
 {

 template void
 subdivided_hyper_rectangle(Triangulation< 2 > &,
 const std::vector<std::vector<double>> &,
 const Point< 2 > &,
 const Point< 2 > &,
 const bool);

 template void
 simplex< 2 >(
 Triangulation< 2 ,  2 > &,
 const std::vector<Point< 2 >> &);

 template void
 parallelepiped< 2 >(
 Triangulation< 2 > &,
 const Point< 2 > (&)[ 2 ],
 const bool);

 template void
 subdivided_parallelepiped< 2 >(
 Triangulation< 2 > &,
 const unsigned int,
 const Point< 2 > (&)[ 2 ],
 const bool);

#ifndef _MSC_VER
 template void
 subdivided_parallelepiped< 2 >(
 Triangulation< 2 > &,
 const unsigned int (&)[ 2 ],
 const Point< 2 > (&)[ 2 ],
 const bool);
#else
 template void
 subdivided_parallelepiped< 2 >(
 Triangulation< 2 > &,
 const unsigned int *,
 const Point< 2 > (&)[ 2 ],
 const bool);
#endif

 template void
 concentric_hyper_shells(Triangulation< 2 > &,
 const Point< 2 > &,
 const double,
 const double,
 const unsigned int,
 const double,
 const unsigned int,
 const bool);

 template void
 eccentric_hyper_shell(Triangulation< 2 > &,
 const Point< 2 > &,
 const Point< 2 > &,
 const double,
 const double,
 const unsigned int);

#if  2  >= 2
 template void
 hyper_ball_balanced< 2 >(Triangulation< 2 > &,
 const Point< 2 > &,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(47))
namespace GridGenerator
 {

 template void
 subdivided_hyper_rectangle(Triangulation< 3 > &,
 const std::vector<std::vector<double>> &,
 const Point< 3 > &,
 const Point< 3 > &,
 const bool);

 template void
 simplex< 3 >(
 Triangulation< 3 ,  3 > &,
 const std::vector<Point< 3 >> &);

 template void
 parallelepiped< 3 >(
 Triangulation< 3 > &,
 const Point< 3 > (&)[ 3 ],
 const bool);

 template void
 subdivided_parallelepiped< 3 >(
 Triangulation< 3 > &,
 const unsigned int,
 const Point< 3 > (&)[ 3 ],
 const bool);

#ifndef _MSC_VER
 template void
 subdivided_parallelepiped< 3 >(
 Triangulation< 3 > &,
 const unsigned int (&)[ 3 ],
 const Point< 3 > (&)[ 3 ],
 const bool);
#else
 template void
 subdivided_parallelepiped< 3 >(
 Triangulation< 3 > &,
 const unsigned int *,
 const Point< 3 > (&)[ 3 ],
 const bool);
#endif

 template void
 concentric_hyper_shells(Triangulation< 3 > &,
 const Point< 3 > &,
 const double,
 const double,
 const unsigned int,
 const double,
 const unsigned int,
 const bool);

 template void
 eccentric_hyper_shell(Triangulation< 3 > &,
 const Point< 3 > &,
 const Point< 3 > &,
 const double,
 const double,
 const unsigned int);

#if  3  >= 2
 template void
 hyper_ball_balanced< 3 >(Triangulation< 3 > &,
 const Point< 3 > &,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(48))
namespace GridGenerator
 {

#if  1  >= 2
 template void hyper_sphere< 1 >(
 Triangulation< 1  - 1,  1 > &,
 const Point< 1 > &,
 double);
#endif

 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(49))
namespace GridGenerator
 {

#if  2  >= 2
 template void hyper_sphere< 2 >(
 Triangulation< 2  - 1,  2 > &,
 const Point< 2 > &,
 double);
#endif

 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(50))
namespace GridGenerator
 {

#if  3  >= 2
 template void hyper_sphere< 3 >(
 Triangulation< 3  - 1,  3 > &,
 const Point< 3 > &,
 double);
#endif

 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(51))
namespace GridGenerator
 {
#if ( 1  <=  1 ) && \
 ( 1  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  1 > &,
 Triangulation< 1 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(52))
namespace GridGenerator
 {
#if ( 1  <=  1 ) && \
 ( 1  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  1 > &,
 Triangulation< 1 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(53))
namespace GridGenerator
 {
#if ( 1  <=  1 ) && \
 ( 1  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  1 > &,
 Triangulation< 1 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(54))
namespace GridGenerator
 {
#if ( 1  <=  2 ) && \
 ( 1  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  2 > &,
 Triangulation< 1 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(55))
namespace GridGenerator
 {
#if ( 1  <=  2 ) && \
 ( 1  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  2 > &,
 Triangulation< 1 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(56))
namespace GridGenerator
 {
#if ( 1  <=  2 ) && \
 ( 1  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  2 > &,
 Triangulation< 1 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(57))
namespace GridGenerator
 {
#if ( 1  <=  3 ) && \
 ( 1  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  3 > &,
 Triangulation< 1 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(58))
namespace GridGenerator
 {
#if ( 1  <=  3 ) && \
 ( 1  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  3 > &,
 Triangulation< 1 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(59))
namespace GridGenerator
 {
#if ( 1  <=  3 ) && \
 ( 1  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 1 ,  3 > &,
 Triangulation< 1 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(60))
namespace GridGenerator
 {
#if ( 2  <=  1 ) && \
 ( 2  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  1 > &,
 Triangulation< 2 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(61))
namespace GridGenerator
 {
#if ( 2  <=  1 ) && \
 ( 2  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  1 > &,
 Triangulation< 2 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(62))
namespace GridGenerator
 {
#if ( 2  <=  1 ) && \
 ( 2  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  1 > &,
 Triangulation< 2 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(63))
namespace GridGenerator
 {
#if ( 2  <=  2 ) && \
 ( 2  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  2 > &,
 Triangulation< 2 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(64))
namespace GridGenerator
 {
#if ( 2  <=  2 ) && \
 ( 2  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  2 > &,
 Triangulation< 2 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(65))
namespace GridGenerator
 {
#if ( 2  <=  2 ) && \
 ( 2  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  2 > &,
 Triangulation< 2 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(66))
namespace GridGenerator
 {
#if ( 2  <=  3 ) && \
 ( 2  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  3 > &,
 Triangulation< 2 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(67))
namespace GridGenerator
 {
#if ( 2  <=  3 ) && \
 ( 2  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  3 > &,
 Triangulation< 2 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(68))
namespace GridGenerator
 {
#if ( 2  <=  3 ) && \
 ( 2  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 2 ,  3 > &,
 Triangulation< 2 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(69))
namespace GridGenerator
 {
#if ( 3  <=  1 ) && \
 ( 3  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  1 > &,
 Triangulation< 3 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(70))
namespace GridGenerator
 {
#if ( 3  <=  1 ) && \
 ( 3  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  1 > &,
 Triangulation< 3 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(71))
namespace GridGenerator
 {
#if ( 3  <=  1 ) && \
 ( 3  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  1 > &,
 Triangulation< 3 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(72))
namespace GridGenerator
 {
#if ( 3  <=  2 ) && \
 ( 3  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  2 > &,
 Triangulation< 3 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(73))
namespace GridGenerator
 {
#if ( 3  <=  2 ) && \
 ( 3  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  2 > &,
 Triangulation< 3 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(74))
namespace GridGenerator
 {
#if ( 3  <=  2 ) && \
 ( 3  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  2 > &,
 Triangulation< 3 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(75))
namespace GridGenerator
 {
#if ( 3  <=  3 ) && \
 ( 3  <=  1 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  3 > &,
 Triangulation< 3 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(76))
namespace GridGenerator
 {
#if ( 3  <=  3 ) && \
 ( 3  <=  2 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  3 > &,
 Triangulation< 3 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(77))
namespace GridGenerator
 {
#if ( 3  <=  3 ) && \
 ( 3  <=  3 )
 template void
 flatten_triangulation<>(
 const Triangulation< 3 ,  3 > &,
 Triangulation< 3 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(78))
namespace GridGenerator
 {
#if  1  <=  1 
 template void
 reference_cell< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 1 ,  1 > &,
 Triangulation< 1 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(79))
namespace GridGenerator
 {
#if  1  <=  2 
 template void
 reference_cell< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 1 ,  2 > &,
 Triangulation< 1 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(80))
namespace GridGenerator
 {
#if  1  <=  3 
 template void
 reference_cell< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 1 ,  3 > &,
 Triangulation< 1 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(81))
namespace GridGenerator
 {
#if  2  <=  1 
 template void
 reference_cell< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 2 ,  1 > &,
 Triangulation< 2 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(82))
namespace GridGenerator
 {
#if  2  <=  2 
 template void
 reference_cell< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 2 ,  2 > &,
 Triangulation< 2 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(83))
namespace GridGenerator
 {
#if  2  <=  3 
 template void
 reference_cell< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 2 ,  3 > &,
 Triangulation< 2 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(84))
namespace GridGenerator
 {
#if  3  <=  1 
 template void
 reference_cell< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 3 ,  1 > &,
 Triangulation< 3 ,  1 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(85))
namespace GridGenerator
 {
#if  3  <=  2 
 template void
 reference_cell< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 3 ,  2 > &,
 Triangulation< 3 ,  2 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(86))
namespace GridGenerator
 {
#if  3  <=  3 
 template void
 reference_cell< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const ReferenceCell &);

 template void
 convert_hypercube_to_simplex_mesh(
 const Triangulation< 3 ,  3 > &,
 Triangulation< 3 ,  3 > &);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(87))
template void GridGenerator::subdivided_hyper_rectangle_with_simplices(
 Triangulation< 1 > & tria,
 const std::vector<unsigned int> &repetitions,
 const Point< 1 > & p1,
 const Point< 1 > & p2,
 const bool colorize);

 template void GridGenerator::subdivided_hyper_cube_with_simplices(
 Triangulation< 1 > & tria,
 const unsigned int repetitions,
 const double p1,
 const double p2,
 const bool colorize);
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(88))
template void GridGenerator::subdivided_hyper_rectangle_with_simplices(
 Triangulation< 2 > & tria,
 const std::vector<unsigned int> &repetitions,
 const Point< 2 > & p1,
 const Point< 2 > & p2,
 const bool colorize);

 template void GridGenerator::subdivided_hyper_cube_with_simplices(
 Triangulation< 2 > & tria,
 const unsigned int repetitions,
 const double p1,
 const double p2,
 const bool colorize);
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(89))
template void GridGenerator::subdivided_hyper_rectangle_with_simplices(
 Triangulation< 3 > & tria,
 const std::vector<unsigned int> &repetitions,
 const Point< 3 > & p1,
 const Point< 3 > & p2,
 const bool colorize);

 template void GridGenerator::subdivided_hyper_cube_with_simplices(
 Triangulation< 3 > & tria,
 const unsigned int repetitions,
 const double p1,
 const double p2,
 const bool colorize);
 
#endif

#undef SPLIT_INSTANTIATIONS_CHECK
