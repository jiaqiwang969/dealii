// This file is automatically generated from corresponding .inst.in, do not edit.

#ifdef SPLIT_INSTANTIATIONS_COUNT
  #define SPLIT_INSTANTIATIONS_CHECK(C) (((C) % SPLIT_INSTANTIATIONS_COUNT) == SPLIT_INSTANTIATIONS_INDEX)
#else
  #define SPLIT_INSTANTIATIONS_CHECK(C) (1)
#endif

#if (SPLIT_INSTANTIATIONS_CHECK(0))
#if  1  <=  1 
 template class FE_Enriched< 1 ,  1 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 1 ,  1 >
 &dof_handler,
 const predicate_function< 1 ,  1 >
 &predicate_1,
 const predicate_function< 1 ,  1 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 1 ,  1 >
 &dof_handler,
 const std::vector<
 predicate_function< 1 ,  1 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 1 ,  1 > &dof_handler,
 const std::vector<
 predicate_function< 1 ,  1 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 1 ,
  1 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 1 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 1 > *(
 const typename Triangulation< 1 ,
  1 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 1 > *(
 const typename Triangulation<
  1 ,
  1 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 1 ,  1 >
 &fe_base,
 const FiniteElement< 1 ,  1 >
 &fe_enriched,
 const FE_Nothing< 1 ,  1 >
 &fe_nothing,
 hp::FECollection< 1 ,  1 >
 &fe_collection);
 }
 template struct Helper< 1 ,  1 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(1))
#if  1  <=  2 
 template class FE_Enriched< 1 ,  2 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 1 ,  2 >
 &dof_handler,
 const predicate_function< 1 ,  2 >
 &predicate_1,
 const predicate_function< 1 ,  2 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 1 ,  2 >
 &dof_handler,
 const std::vector<
 predicate_function< 1 ,  2 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 1 ,  2 > &dof_handler,
 const std::vector<
 predicate_function< 1 ,  2 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 1 ,
  2 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 2 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 2 > *(
 const typename Triangulation< 1 ,
  2 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 2 > *(
 const typename Triangulation<
  1 ,
  2 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 1 ,  2 >
 &fe_base,
 const FiniteElement< 1 ,  2 >
 &fe_enriched,
 const FE_Nothing< 1 ,  2 >
 &fe_nothing,
 hp::FECollection< 1 ,  2 >
 &fe_collection);
 }
 template struct Helper< 1 ,  2 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(2))
#if  1  <=  3 
 template class FE_Enriched< 1 ,  3 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 1 ,  3 >
 &dof_handler,
 const predicate_function< 1 ,  3 >
 &predicate_1,
 const predicate_function< 1 ,  3 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 1 ,  3 >
 &dof_handler,
 const std::vector<
 predicate_function< 1 ,  3 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 1 ,  3 > &dof_handler,
 const std::vector<
 predicate_function< 1 ,  3 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 1 ,
  3 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 3 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 3 > *(
 const typename Triangulation< 1 ,
  3 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 3 > *(
 const typename Triangulation<
  1 ,
  3 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 1 ,  3 >
 &fe_base,
 const FiniteElement< 1 ,  3 >
 &fe_enriched,
 const FE_Nothing< 1 ,  3 >
 &fe_nothing,
 hp::FECollection< 1 ,  3 >
 &fe_collection);
 }
 template struct Helper< 1 ,  3 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(3))
#if  2  <=  1 
 template class FE_Enriched< 2 ,  1 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 2 ,  1 >
 &dof_handler,
 const predicate_function< 2 ,  1 >
 &predicate_1,
 const predicate_function< 2 ,  1 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 2 ,  1 >
 &dof_handler,
 const std::vector<
 predicate_function< 2 ,  1 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 2 ,  1 > &dof_handler,
 const std::vector<
 predicate_function< 2 ,  1 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 2 ,
  1 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 1 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 1 > *(
 const typename Triangulation< 2 ,
  1 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 1 > *(
 const typename Triangulation<
  2 ,
  1 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 2 ,  1 >
 &fe_base,
 const FiniteElement< 2 ,  1 >
 &fe_enriched,
 const FE_Nothing< 2 ,  1 >
 &fe_nothing,
 hp::FECollection< 2 ,  1 >
 &fe_collection);
 }
 template struct Helper< 2 ,  1 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(4))
#if  2  <=  2 
 template class FE_Enriched< 2 ,  2 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 2 ,  2 >
 &dof_handler,
 const predicate_function< 2 ,  2 >
 &predicate_1,
 const predicate_function< 2 ,  2 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 2 ,  2 >
 &dof_handler,
 const std::vector<
 predicate_function< 2 ,  2 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 2 ,  2 > &dof_handler,
 const std::vector<
 predicate_function< 2 ,  2 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 2 ,
  2 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 2 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 2 > *(
 const typename Triangulation< 2 ,
  2 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 2 > *(
 const typename Triangulation<
  2 ,
  2 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 2 ,  2 >
 &fe_base,
 const FiniteElement< 2 ,  2 >
 &fe_enriched,
 const FE_Nothing< 2 ,  2 >
 &fe_nothing,
 hp::FECollection< 2 ,  2 >
 &fe_collection);
 }
 template struct Helper< 2 ,  2 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(5))
#if  2  <=  3 
 template class FE_Enriched< 2 ,  3 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 2 ,  3 >
 &dof_handler,
 const predicate_function< 2 ,  3 >
 &predicate_1,
 const predicate_function< 2 ,  3 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 2 ,  3 >
 &dof_handler,
 const std::vector<
 predicate_function< 2 ,  3 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 2 ,  3 > &dof_handler,
 const std::vector<
 predicate_function< 2 ,  3 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 2 ,
  3 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 3 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 3 > *(
 const typename Triangulation< 2 ,
  3 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 3 > *(
 const typename Triangulation<
  2 ,
  3 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 2 ,  3 >
 &fe_base,
 const FiniteElement< 2 ,  3 >
 &fe_enriched,
 const FE_Nothing< 2 ,  3 >
 &fe_nothing,
 hp::FECollection< 2 ,  3 >
 &fe_collection);
 }
 template struct Helper< 2 ,  3 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(6))
#if  3  <=  1 
 template class FE_Enriched< 3 ,  1 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 3 ,  1 >
 &dof_handler,
 const predicate_function< 3 ,  1 >
 &predicate_1,
 const predicate_function< 3 ,  1 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 3 ,  1 >
 &dof_handler,
 const std::vector<
 predicate_function< 3 ,  1 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 3 ,  1 > &dof_handler,
 const std::vector<
 predicate_function< 3 ,  1 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 3 ,
  1 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 1 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 1 > *(
 const typename Triangulation< 3 ,
  1 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 1 > *(
 const typename Triangulation<
  3 ,
  1 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 3 ,  1 >
 &fe_base,
 const FiniteElement< 3 ,  1 >
 &fe_enriched,
 const FE_Nothing< 3 ,  1 >
 &fe_nothing,
 hp::FECollection< 3 ,  1 >
 &fe_collection);
 }
 template struct Helper< 3 ,  1 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(7))
#if  3  <=  2 
 template class FE_Enriched< 3 ,  2 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 3 ,  2 >
 &dof_handler,
 const predicate_function< 3 ,  2 >
 &predicate_1,
 const predicate_function< 3 ,  2 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 3 ,  2 >
 &dof_handler,
 const std::vector<
 predicate_function< 3 ,  2 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 3 ,  2 > &dof_handler,
 const std::vector<
 predicate_function< 3 ,  2 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 3 ,
  2 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 2 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 2 > *(
 const typename Triangulation< 3 ,
  2 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 2 > *(
 const typename Triangulation<
  3 ,
  2 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 3 ,  2 >
 &fe_base,
 const FiniteElement< 3 ,  2 >
 &fe_enriched,
 const FE_Nothing< 3 ,  2 >
 &fe_nothing,
 hp::FECollection< 3 ,  2 >
 &fe_collection);
 }
 template struct Helper< 3 ,  2 >;
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(8))
#if  3  <=  3 
 template class FE_Enriched< 3 ,  3 >;

 namespace ColorEnriched
 {
 namespace internal
 {
 template bool
 find_connection_between_subdomains(
 const DoFHandler< 3 ,  3 >
 &dof_handler,
 const predicate_function< 3 ,  3 >
 &predicate_1,
 const predicate_function< 3 ,  3 >
 &predicate_2);


 template unsigned int
 color_predicates(
 const DoFHandler< 3 ,  3 >
 &dof_handler,
 const std::vector<
 predicate_function< 3 ,  3 >> &,
 std::vector<unsigned int> &);


 template void
 set_cellwise_color_set_and_fe_index(
 DoFHandler< 3 ,  3 > &dof_handler,
 const std::vector<
 predicate_function< 3 ,  3 >>
 & predicates,
 const std::vector<unsigned int> &predicate_colors,
 std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::set<unsigned int>> &fe_sets);


 template void
 make_colorwise_enrichment_functions< 3 ,
  3 >(
 const unsigned int n_colors,
 const std::vector<std::shared_ptr<Function< 3 >>>
 &enrichments,
 const std::map<unsigned int, std::map<unsigned int, unsigned int>>
 & cellwise_color_predicate_map,
 std::vector<std::function<const Function< 3 > *(
 const typename Triangulation< 3 ,
  3 >::cell_iterator
 &)>> &color_enrichments);


 template void
 make_fe_collection_from_colored_enrichments(
 const unsigned int n_colors,
 const std::vector<std::set<unsigned int>> &fe_sets,
 const std::vector<
 std::function<const Function< 3 > *(
 const typename Triangulation<
  3 ,
  3 >::cell_iterator &)>> &color_enrichments,
 const FiniteElement< 3 ,  3 >
 &fe_base,
 const FiniteElement< 3 ,  3 >
 &fe_enriched,
 const FE_Nothing< 3 ,  3 >
 &fe_nothing,
 hp::FECollection< 3 ,  3 >
 &fe_collection);
 }
 template struct Helper< 3 ,  3 >;
 }

#endif
 
#endif

#undef SPLIT_INSTANTIATIONS_CHECK
