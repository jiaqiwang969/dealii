完全独立。这种技术对于模拟流体与结构的相互作用问题特别有效，其中嵌入结构的配置是问题本身的一部分，人们要解决一个（可能是非线性）弹性问题，以确定[2.x.5814]的（与时间有关的）配置，以及[2.x.5815]的（可能是非线性）流动问题，加上流体和固体之间界面上的耦合条件。

在这个教程程序中，我们把事情弄得简单一些，我们假设嵌入式领域的配置是以两种可能的方式之一给出的。

- 作为一个变形映射[2.x.5816]，定义在[2.x.5817]的连续有限维空间上，对于任何一个点[2.x.5818]，代表其在[2.x.5820]的坐标[2.x.5819]。

- 作为[2.x.5822]的位移映射[2.x.5821]，代表任何一点[2.x.5823]的位移矢量，以使[2.x.5824]变形为其实际配置[2.x.5825]。

我们定义嵌入式参考域[2.x.5826] `embedded_grid`：在这个三角形上，我们构建一个有限维空间（`embedded_configuration_dh`），通过FE_Q对象的有限元系统（`embedded_configuration_fe`）描述变形或位移。这个有限维度空间仅用于插值用户提供的函数（`embedded_configuration_function`），代表[2.x.5827]（如果参数`use_displacement`被设置为[2.x.5828]或[2.x.5829]（如果参数`use_displacement`被设置为[2.x.5830

拉格朗日乘数[2.x.5831]和用户提供的函数[2.x.5832]是通过另一个有限维度空间`embedded_dh`和另一个有限元素`embedded_fe`定义的，使用相同的参考域。为了考虑到域的变形，MappingFEField或MappingQEulerian对象被初始化为`embedded_configuration`向量。

在嵌入空间中，一个标准的有限维空间`space_dh`被构建在嵌入网格`space_grid`上，使用有限元素`space_fe`，几乎逐字逐句地遵循步骤6中的方法。

我们用以下方法表示空间[2.x.5833]和[2.x.5834]的离散化

[1.x.2248] 和

[1.x.2249]，其中[2.x.5835]是`空间_dh`的尺寸，[2.x.5836]是`嵌入_dh`的尺寸。

一旦所有的有限维空间都被定义，上述问题的变异表述给我们留下了以下有限维方程组。

[1.x.2250]

其中

[1.x.2251]



虽然矩阵[2.x.5837]是[2.x.5838]上泊松问题的标准刚度矩阵，而向量[2.x.5839]是[2.x.5840]上带有强制项的有限元问题的标准右手向量。矩阵[2.x.5842]或其转置[2.x.5843]是非标准的，因为它们是两个不匹配的网格上的信息。

特别是，在计算[2.x.5844]的一个条目时出现的积分，是在[2.x.5845]上计算的。在有限元中，我们通常将这个积分分成来自用于离散化[2.x.5846]的三角形的所有单元的贡献，我们将[2.x.5847]上的积分转换为参考元素[2.x.5848]上的积分，其中[2.x.5849]是从[2.x.5850]到[2.x.5851]的映射，并且使用正交公式计算[2.x.5852]上的积分。

[1.x.2252]

计算这个和是不容易的，因为我们必须评估[2.x.5853] 。一般来说，如果[2.x.5854]和[2.x.5855]没有对齐，那么[2.x.5856]这个点相对于[2.x.5857]来说是完全任意的，除非我们想出一个办法，在[2.x.5859]上的任意点上插值[2.x.5858]的所有基函数，否则我们无法计算出矩阵[2.x.5860]的一个条目需要的积分。

要评估[2.x.5861]，需要采取以下步骤（如下图所示）。

- 对于[2.x.5863]中的一个给定单元[2.x.5862]，计算实点[2.x.5864]，其中[2.x.5865]是用于[2.x.5866]上的积分的正交点之一。

- 找到[2.x.5867]中[2.x.5868]所在的单元。我们将称这个元素为[2.x.5869] 。

- 为了评估基函数，使用映射[2.x.5870]的逆映射，将参考元素[2.x.5871]转换为元素[2.x.5872] : [2.x.5873] 。

<p align="center"> <img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png" alt=""> [2.x.5874]

上述三个步骤可以通过依次调用来计算。

- [2.x.5875] 后面是

- [2.x.5876] 然后我们

- 构建一个自定义的正交公式，包含参考单元格中的点，然后

- 构建一个FEValues对象，具有给定的正交公式，并以第一步中获得的单元格为初始化。

这就是deal.II函数[2.x.5877]在任意点上评估有限元场（而不仅仅是单个形状函数）时的做法；但在这种情况下，这将是低效的。

一个更好的解决方案是使用一个方便的包装器来对一个点的集合执行前三个步骤。  [2.x.5878]如果人们实际上对计算完整的耦合矩阵感兴趣，那么可以调用方法[2.x.5879]，该方法以有效的方式执行上述步骤，重复使用所有可能的数据结构，并将昂贵的步骤聚集在一起。这就是我们在本教程后面要使用的函数。

我们通过迭代求解器来解决最终的鞍点问题，应用于Schur补数[2.x.5880]（其构造例如在步骤20中描述），我们使用LinearOperator类构造[2.x.5881]。




[1.x.2253]

我们在这里解决的问题与步骤4相同，不同的是我们对一个嵌入域施加了一些约束 [2.x.5882] 。该教程是以独立于维度的方式编写的，在结果部分我们展示了如何改变`dim`和`spacedim`。

本教程是为`dim`等于1和`spacedim`等于2而编译的。如果你想在嵌入维度`spacedim`等于3的情况下运行程序，你很可能想改变[2.x.5883]的参考域，例如，你从文件中读到的东西，或者你后来变形为更有趣的封闭球体。

在默认情况下，[2.x.5884]的共维为1，本教程程序实现的是虚构边界法。事实证明，同样的技术也用在了变量沉浸式有限元方法中，上面定义的耦合算子[2.x.5885]在几乎所有这些非匹配方法中都是一样的。

嵌入域被假定包括在[2.x.5886]中，我们把它当作单位平方[2.x.5887]。虚域[2.x.5888]的定义可以通过参数文件修改，可以给出从参考区间[2.x.5889]到[2.x.5890]中的一条曲线的映射。

如果曲线是封闭的，那么结果将类似于在边界为[2.x.5891]的网格上运行同一问题。在非封闭的[2.x.5892]的情况下，程序也能愉快地运行，尽管在这些情况下，问题的数学表述更加困难，因为[2.x.5893]本身就有一个边界，相对于域[2.x.5894]来说是二维的。




[1.x.2254]

[2.x.5895] [2.x.5896] Glowinski, R., T.-W.Pan, T.I. Hesla, and D.D. Joseph.1999."分布式拉格朗日乘数/虚构域方法用于颗粒物流"。   International Journal of Multiphase Flow 25 (5).Pergamon: 755-94.

[2.x.5897] Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin。2008."关于沉浸边界法的超弹性公式"。应用力学和工程中的计算机方法197（25-28）。

[2.x.5898] Heltai, L., and F. Costanzo.2012."浸没式有限元方法的变量实现"。应用力学和工程中的计算机方法》229-232。  [2.x.5899]


examples/step-60/doc/results.dox



[1.x.2255]

运行该程序的目录中默认不包含参数文件。另一方面，这个程序想从一个叫parameters.prm的文件中读取它的参数 -- 因此，当你第一次执行它时，你会得到一个异常，即找不到这样的文件。

[1.x.2256]



然而，正如错误信息已经指出的那样，触发该异常的代码也将生成一个参数.prm文件，该文件仅仅包含该程序所关心的所有参数的默认值。通过对参数文件的检查，我们看到以下内容。

[1.x.2257]



如果你现在运行该程序，你将得到一个名为`used_parameters.prm`的文件，其中包含上述参数的简短版本（没有注释和文档），记录了所有用于运行你的程序的参数。

[1.x.2258]



首先创建`parameters.prm`文件（第一次运行程序），然后创建`used_parameters.prm`（每隔一段时间运行程序），其理由是你可能想让大多数参数保持默认值，而只修改其中的一小部分。

例如，你可以在这个教程程序中使用以下（完全有效的）参数文件。

[1.x.2259]



你会得到与下面测试案例1完全相同的结果。

[1.x.2260]

对于默认问题，[2.x.5900]在[2.x.5901]上的值被设置为常数[2.x.5902]：这就像在[2.x.5903]上施加了一个常数迪里希特边界条件，被视为[2.x.5904]在[2.x.5905]内的部分的边界。同样，在[2.x.5906]上，我们有零的迪里切特边界条件。


<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-60.1_no_grid.png" alt = "" width="500"> </div> </div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-60.1_grid.png" alt = "" width="500"> </div> </div></div>

程序的输出将如下所示。

[1.x.2261]



你可能会注意到，就CPU时间而言，组装耦合系统的成本是组装标准泊松系统的两倍，尽管矩阵更小。这是由于离散化的非匹配性造成的。这是否可以接受，取决于应用。

如果问题被设置在三维环境中，并且浸入式网格与时间有关，那么在每一步重新创建网格要比使用我们这里介绍的技术要昂贵得多。此外，你也许可以在一个均匀细化的正方形或立方体网格上创建一个非常快速和优化的求解器，并在你想进行计算的地方嵌入这里的技术。这就要求你只需要有一个领域的表面代表（一个更便宜和更容易制作的网格）。

为了玩一玩，我们要把虚构的领域以及我们强加给它的边界条件复杂化一点。

[1.x.2262]

如果我们使用以下参数文件。

[1.x.2263]



我们得到了一个看起来很 "花 "的域，在这里我们施加了一个线性边界条件 [2.x.5907] 。这个测试表明，该方法在从边界条件中恢复一个完全线性的函数方面实际上是相当准确的，即使网格没有对齐，我们也得到了一个相当好的结果。

用[2.x.5909]替换[2.x.5908]，即修改参数文件，使我们有

[1.x.2264]

生产右边的马鞍。

<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-60.3_grid.png" alt = "" width="500"> </div> </div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-60.4_grid.png" alt = "" width="500"> </div> </div></div>

[1.x.2265]

[1.x.2266]

[1.x.2267]

虽然目前的教程程序是为`spacedim`等于2而写的，但为了使程序在不同的尺寸组合中运行，你只需要做一些小的改动。

如果你想在`spacedim`等于3，`dim`等于2的情况下运行，那么你几乎肯定要进行以下修改。

- 使用不同的参考域来嵌入网格，也许可以从一个文件中读取它。不可能用一个正方形域的单一参数化来构造一个光滑的封闭表面，因此你很可能想用一个拓扑学上等同于球体边界的参考域。

- 用位移代替变形，将[2.x.5910]映射为[2.x.5911]。

[1.x.2268]

我们在其他教程中看到（例如在第5步和第54步）如何从输入文件中读取网格。这个教程程序的一个很好的概括是允许用户选择从参数文件本身读取网格，而不是在教程程序本身硬编码网格类型。

[1.x.2269]

目前，我们没有关于Schur补数的预处理程序。这对于二维问题来说是可以的，几百次迭代就可以把残差降低到机器的精度，但在三维问题上是行不通的。

在这里，一个好的预处理程序是什么并不明显。我们用舒尔补码解决的物理问题是将Dirichlet数据[2.x.5912]与Lagrange乘数[2.x.5913]的值联系起来。  [2.x.5914]可以解释为法线梯度的*跳跃，需要强加在[2.x.5915]上，跨越[2.x.5916]，以获得迪里切特数据[2.x.5917]。

所以[2.x.5918]是某种诺伊曼到迪里切特的映射，我们希望有一个迪里切特到诺伊曼映射的良好近似。一种可能性是使用[2.x.5919]上的问题的边界元素近似，并构建一个与[2.x.5920]相关的泊松问题的超星形算子的粗略近似，这正是迪里切特到诺依曼的映射。

[1.x.2270]

这里提出的简单代码可以作为更复杂问题的起点，要解决这些问题，需要在并行代码上运行，可能使用分布式网格（见步骤17、步骤40，以及[2.x.5921]和[2.x.5922]的文档）。

当并行使用非匹配网格时，会出现一个问题：为了计算矩阵[2.x.5923]，一个进程需要关于实空间同一部分的两个网格的信息，但是，当使用分布式网格时，这种信息可能无法获得，因为存储在特定处理器上的[2.x.5924]三角形的本地所有部分可能与存储在同一处理器上的[2.x.5925]三角形的本地所有部分不在同一地点。

可以实施各种策略来解决这个问题。

- 分布这两个网格，以便满足这个约束条件。

- 对现实空间中不满足约束的部分使用通信。

- 对嵌入空间使用分布式三角法，对模拟配置使用共享三角法。

后一种策略显然是最容易实现的，因为本教程程序中使用的大多数函数在并行情况下也能不变地工作。当然，我们可以使用反转策略（即有一个分布式嵌入三角法和一个共享嵌入三角法）。

然而，这种策略很可能会更加昂贵，因为根据定义，嵌入网格比嵌入网格要大，而且分配两个网格中最大的网格更有意义，保持最小的网格由所有处理器共享。


examples/step-61/doc/intro.dox

[2.x.5926]

[1.x.2271]

[1.x.2272]

[1.x.2273]

本教程程序介绍了泊松方程的 "弱加勒金 "有限元方法的实现。从某种意义上说，考虑这种方法的动机与步骤51中的动机相同：我们想考虑不连续的形状函数，但又需要解决这样一个事实：与通常的连续Galerkin方法相比，所产生的问题有更多的自由度（因为，例如，每个顶点携带的自由度与相邻单元一样多）。我们还必须解决这样一个事实：与连续Galerkin方法不同，[1.x.2274]一个单元上的自由度与它的每个面邻单元上的所有自由度相耦合。因此，从 "传统的 "非连续Galerkin方法得到的矩阵既大又相对密集。

step-51中的混合非连续Galerkin方法（HDG）和本教程中的弱Galerkin（WG）方法都是通过引入额外的自由度来解决耦合问题的，这些自由度的形状函数只存在于单元间的一个面上（即网格的 "骨架 "上），因此它们将相邻单元上的自由度相互 "隔离"：单元自由度只与同一单元上的其他单元自由度以及面自由度耦合，而与相邻单元上的单元自由度不耦合。因此，这些细胞自由度的形状函数的耦合确实正好耦合在一个细胞和定义在其面上的自由度上。

对于一个给定的方程，例如二阶泊松方程，HDG和WG方法的区别在于如何精确地制定连接所有这些不同形状函数的问题。事实上，对于某些WG和HDG的表述，有可能表明它们是等价的）。HDG的做法是用一阶方程系统重新表述二阶问题，然后在概念上把面的自由度看作是这个一阶系统的 "通量"。相比之下，WG方法保持二阶形式，并将面的自由度视为与主解变量相同的类型，只是限制在低维的面。为了方程的目的，在定义对其应用微分算子的含义时，人们需要以某种方式将这些形状函数 "扩展 "到单元的内部。与HDG相比，该方法的优势在于它不会因为将方程重写为一阶系统而导致未知数的增加，但它也不太容易实现。然而，正如我们在下文中所看到的，这种额外的努力并不可怕。




[1.x.2275]

弱加勒金有限元方法（WGFEMs）使用离散的弱函数来近似标量未知数，使用离散的弱梯度来近似经典梯度。该方法最初是由王俊平和叶秀在论文[1.x.2276][1.x.2277]中提出。与连续Galerkin方法相比，弱Galerkin方法满足重要的物理特性，即局部质量守恒和体法通量连续。它的结果是一个SPD线性系统，并且通过网格细化可以获得最佳收敛率。




[1.x.2278] 该程序使用弱加尔金有限元法求解泊松方程。

[1.x.2279]

其中[2.x.5927]是一个有界域。在流体流经多孔介质的背景下，[2.x.5928]是压力，[2.x.5929]是渗透性张量，[2.x.5930]是源项，[2.x.5931]代表Dirichlet和Neumann边界条件。我们可以引入一个通量，[2.x.5932]，对应于达西速度（以我们在步骤20中的方式），这个变量在下面的考虑中很重要。

在这个程序中，我们将考虑一个测试案例，即在单位平方域上的确切压力为[2.x.5933]，具有同质Dirichelet边界条件和[2.x.5934]身份矩阵。然后我们将计算压力、速度和通量的[2.x.5935]误差。




[1.x.2280]

上面的泊松方程有一个解[2.x.5936]，需要满足问题的弱表述。

[1.x.2281]

为所有测试函数 [2.x.5937] ，其中

[1.x.2282]

和

[1.x.2283]

在这里，我们以双线性形式进行了部分积分，我们在内部评估[2.x.5938]的梯度，在域的边界评估[2.x.5939]的值。所有这些都是很好的定义，因为我们假设解是在[2.x.5940]中，对它来说，取梯度和评估边界值是有效的操作。

弱Galerkin方法的想法是用一个[1.x.2284][2.x.5942]来近似精确的[2.x.5941]解。这个函数可能只在单元格之间的界面上不连续，由于我们也想沿着界面评估这个函数，我们不仅要规定它在单元格内部应该有什么值，还要规定它在界面上的值。我们通过说[2.x.5943]实际上是一个元组，[2.x.5944]，尽管它实际上只是一个单一的函数，它要么等于[2.x.5945]，要么等于[2.x.5946]，这取决于它是在位于细胞内部还是在细胞界面的某一点[2.x.5947]上被评估。

然后我们想把这个近似值简单地贴到上面的双线性表格中。这适用于我们必须在边界上评估测试函数[2.x.5948]的情况（我们只需取其界面部分[2.x.5949]），但我们必须小心处理梯度，因为它只在单元格内部定义。因此，泊松方程的弱Galerkin方案被定义为

[1.x.2285]

对于所有离散测试函数 [2.x.5950] ，其中

[1.x.2286]

和

[1.x.2287]

关键的一点是，在这里，我们用[1.x.2288]算子[2.x.5952]代替了梯度[2.x.5951]，这对于我们特殊定义的近似[2.x.5953]是有意义的。

那么问题是该算子如何工作。为此，让我们首先说说我们是如何看待压力的离散近似值[2.x.5954]的。如上所述，"函数"[2.x.5955]实际上由两部分组成：单元内部的值[2.x.5956]和界面上的[2.x.5957]。我们必须为这两部分定义离散的（有限维）函数空间；在这个程序中，我们将用FE_DGQ来表示[2.x.5958]作为细胞内部的空间（在每个细胞上定义，但一般沿界面是不连续的），用FE_FaceQ表示[2.x.5959]作为界面上的空间。

那么让我们只考虑一个单元（因为上面的积分都是逐个单元定义的，而且弱离散梯度是逐个单元定义的）。[2.x.5960]对[2.x.5961],[2.x.5962]的限制由一对[2.x.5963]组成。从本质上讲，我们可以认为[2.x.5964]是定义在[2.x.5965]上的某个函数，它近似于梯度；特别是，如果[2.x.5966]是一个可微函数的限制（对[2.x.5967]的内部和边界--这将使它在内部和边界之间连续），那么[2.x.5968] 将只是精确梯度[2.x.5969] 。但是，由于[2.x.5970]在[2.x.5971]的内部和边界之间不连续，我们需要一个更一般的定义；此外，我们不能处理任意函数，因此要求[2.x.5972]也在一个有限元空间中（由于梯度是一个矢量，必须是矢量值，而且由于弱梯度是在每个单元上单独定义的，因此在单元之间也将是不连续的）。

这样做的方法是以下列方式定义这个弱梯度算子[2.x.5973]（其中[2.x.5974]是单元格[2.x.5976]上阶为[2.x.5975]的矢量值Raviart-Thomas空间）。

[1.x.2289]

为所有测试函数 [2.x.5977] 。从本质上讲，这只是一个逐部积分公式的应用。换句话说，对于一个给定的[2.x.5978]，我们需要把[2.x.5979]看作是度数为[2.x.5980]的Raviart-Thomas函数，对于这个函数，左手边和右手边在所有测试函数中是相等的。

那么，需要说明的一个关键点是以下几点。通常的梯度[2.x.5981]是一个*本地*算子，它仅仅根据一个函数在某一点及其（无限小）邻域的值来计算导数，而弱离散梯度[2.x.5982]却没有这个特性。它取决于它所应用的函数在整个单元上的值，包括单元的边界。然而，两者都是线性算子，从上面[2.x.5983]的定义可以看出，这将允许我们在下面的讨论中通过矩阵来表示[2.x.5984]。

[2.x.5985] 值得指出的是，虽然弱的离散梯度是Raviart-Thomas空间[2.x.5986]在每个单元[2.x.5987]的一个元素，但它在单元之间是不连续的。另一方面，定义在整个网格上并由FE_RaviartThomas类实现的Raviart-Thomas空间[2.x.5988]代表在单元间界面上具有连续法线分量的函数。这意味着[1.x.2290], [2.x.5989]不在[2.x.5990]中，尽管它在[2.x.5991]中的每个单元上。   相反，它是在一个 "破碎的 "拉维-托马斯空间中，下面我们将用符号[2.x.5993]来表示。 这里的术语 "破碎 "指的是 "把东西打碎 "的过程，而不是表达 "没有功能 "的同义词。因此，人们可能会（理所当然地）争辩说，在弱加尔金文献中使用的符号有点误导，但这往往取决于使用某种符号的背景--在目前的背景下，对Raviart-Thomas空间或元素的提及总是被理解为对 "破碎 "空间的提及。

[2.x.5994] deal.II恰好有一个实现了这个破碎的Raviart-Thomas空间。FE_DGRT类。因此，在本教程中，我们将简单地一直使用FE_DGRT类，尽管在所有那些我们必须计算单元格本地矩阵和向量的地方，它没有任何区别。




[1.x.2291]

由于[2.x.5995]是有限元空间的一个元素，我们可以像往常一样在一个基础上展开它，也就是说，我们可以写出

[1.x.2292]

这里，由于[2.x.5996]有两个分量（内部分量和界面分量），对于基函数[2.x.5997]也必须如此，我们可以写成[2.x.5998] 。如果你按照步骤8、步骤20和[2.x.5999]"向量值问题文件模块 "中的描述，就不会感到奇怪，对于[2.x.6000]的某些值，[2.x.6001]将为零，而对于[2.x.6002]的其他值，[2.x.6003]将为零--也就是说，形状函数将是一种或另一种类型。然而，这在这里并不重要。重要的是，我们需要思考如何表示[2.x.6004]，因为当我们想实现双线性形式时，这显然是问题中会出现的东西

[1.x.2293]



关键的一点是，已知[2.x.6005]是 "破碎的 "Raviart-Thomas空间[2.x.6006]的一个成员。这意味着我们可以（在每个单元[2.x.6007]上分别表示

[1.x.2294]

其中，函数[2.x.6008]，以及[2.x.6009]是一个维数的矩阵

[1.x.2295]

弱离散梯度可以被表示为一个矩阵，这不应该是一个惊喜：它是一个从一个有限维空间到另一个有限维空间的线性算子。如果为这两个空间都选择基数，那么[1.x.2296]当然可以写成一个矩阵，将与算子的域空间的基数有关的扩展系数向量映射到与图像空间的基数有关的扩展系数向量）。)

利用这个扩展，我们可以很容易地使用上面的弱离散梯度的定义来定义矩阵要做什么。

[1.x.2297]

对于所有的测试功能 [2.x.6010] 。

这显然导致了一个线性系统，其形式为

[1.x.2298]

与

[1.x.2299]

因此

[1.x.2300]

(在这最后一步中，我们假设指数[2.x.6011]只涉及在单元[2.x.6012]上活动的自由度，从而确保空间[2.x.6013]上的质量矩阵是可逆的。)等价地，利用矩阵[2.x.6014]的对称性，我们可以看到

[1.x.2301]

另外值得指出的是，矩阵[2.x.6015]和[2.x.6016]当然不是正方形而是长方形。




[1.x.2302]

在解释了弱离散梯度是如何定义的之后，我们现在可以回到有关方程的线性系统应该如何组装的问题上。具体来说，利用上面显示的双线性形式[2.x.6017]的定义，我们就需要计算局部对全局矩阵的贡献元素。

[1.x.2303]

如上所述，我们可以用Raviart-Thomas基础在每个单元格上展开[2.x.6018]，同样，对于[2.x.6019]也是如此。

[1.x.2304]

通过重新排列和，可以得到以下表达式。

[1.x.2305]

因此，如果我们有每个单元格[2.x.6021]的矩阵[2.x.6020]，那么我们可以很容易地计算出单元格[2.x.6023]对矩阵[2.x.6024]的贡献[2.x.6022]，如下所示。

[1.x.2306]

在这里。

[1.x.2307]

这实际上只是单元[2.x.6025]上的质量矩阵，使用Raviart-Thomas基础并通过渗透性张量[2.x.6026]加权。这里的推导表明，弱加尔金法实际上只需要我们计算每个单元[2.x.6027]和[2.x.6028]的矩阵，然后再计算[2.x.6030]，这很容易计算出来。下面要显示的代码正是这样做的。

在计算出单元格[2.x.6031]对全局矩阵的贡献后，我们要做的就是将这些局部贡献 "分配 "到全局矩阵中。如何做到这一点，首先显示在步骤3和步骤4中。在目前的程序中，这将通过调用[2.x.6033]来促进。

一个线性系统当然也需要一个右手边。除了我们只需要对每个形状函数[2.x.6034]使用单元格内部部分外，这里没有与计算右手边有关的困难。




[1.x.2308][1.x.2309] 。

前面几节的讨论已经给了我们一个线性系统，我们可以求解数值压力[2.x.6036] 。我们可以用它来计算变量[2.x.6037]的近似值，如果这是我们要解决的模型，它对应于介质在多孔介质中的流动速度。这种步骤--从离散问题的解中计算一个派生量--通常被称为 "后处理"。

这里，我们不使用[2.x.6038]的精确梯度，而是使用[2.x.6039]的离散弱梯度来计算每个元素上的速度。如上所述，在每个元素上，数值压力[2.x.6040]的梯度可以用离散弱梯度[2.x.6041]来近似。

[1.x.2310]



在单元格[2.x.6042]上，数值速度[2.x.6043]可写为

[1.x.2311]

其中[2.x.6044]是上面的扩展矩阵，[2.x.6045]是[2.x.6046]空间在一个单元上的基函数。

不幸的是，[2.x.6047]可能不在[2.x.6048]空间中（当然，除非如果[2.x.6049]是常数乘以身份矩阵）。因此，为了在有限元程序中表示它，我们需要把它投射回我们可以处理的有限维空间。在这里，我们将使用[2.x.6050]投影法将其投影回（破碎的）[2.x.6051]空间。

我们将每个单元格 [2.x.6053] 上的投影定义为 [2.x.6052] 。对于任何 [2.x.6054] , [2.x.6055] 所以，与其说是上面的公式，不如说是 [2.x.6056] 单元上的数字速度变成了

[1.x.2312]

我们有以下系统来解决系数问题 [2.x.6057] 。

[1.x.2313]

在下面的实现中，元素为[2.x.6058]的矩阵被称为[2.x.6059] ，而元素为[2.x.6060]的矩阵被称为[2.x.6061]。

那么元素速度为

[1.x.2314]

其中[2.x.6062]在代码中被称为`细胞速度'。

利用这个通过 "后处理 "得到的速度，我们可以通过以下公式定义压力、速度和通量的[2.x.6063]误差。

[1.x.2315]

其中[2.x.6064]为元素的面积，[2.x.6065]为元素的面，[2.x.6066]为每个面的单位法向量。这些规范中的最后一条衡量了网格单元之间界面上速度向量的法向分量的精度。缩放因子[2.x.6067]的选择是为了随着网格大小的变化，缩放出界面集合的长度（或面积）的差异。

上面的第一个错误很容易用[2.x.6068]计算出来，其他的需要多做一些工作，在下面的代码中实现。


examples/step-61/doc/results.dox



[1.x.2316]

我们在运行程序时，右手边会产生解 [2.x.6069] ，并且在域 [2.x.6070] 中具有同质的迪里希特边界条件。此外，我们选择微分算子[2.x.6071]中的系数矩阵作为身份矩阵。我们使用[2.x.6072]、[2.x.6073]和[2.x.6074]元素组合测试这一设置，可以通过使用`main()`中`WGDarcyEquation`对象的适当构造参数来选择。然后我们将可视化单元内部和面上的压力值。随着网格的细化，压力、速度和流量的收敛率对于[2.x.6075]应该是1，对于[2.x.6076]是2，对于[2.x.6077]是3。




[1.x.2317][1.x.2318] 。

下面的数字显示了使用[2.x.6078]元素的内部压力和表面压力。网格分别细化了2倍（顶部）和4倍（底部）。(这个数字可以在`make_grid()`函数中调整)。当网格较粗时，可以看到面压[2.x.6079]整齐地位于两个相邻单元的内压[2.x.6080]的数值之间。

[2.x.6081]

从图中我们可以看出，随着网格的细化，最大和最小的压力值正在接近我们的预期值。由于网格是一个矩形网格，每个方向的单元数是偶数，所以我们有对称的解决方案。从右边的三维图中，我们可以看到在[2.x.6082]上，压力在单元的内部是一个常数，正如预期的那样。

[1.x.2319][1.x.2320] 。

我们用不同的细化网格（在 "make_grid() "函数中选择）运行代码，得到压力、速度和通量（如引言中定义的）的以下收敛率。

[2.x.6083]

我们可以看到，[2.x.6084]的收敛率在1左右。当然，这与我们的理论预期相符。




[1.x.2321][1.x.2322] 。

我们可以用下一个更高的多项式度数重复上面的实验。下面的数字是使用[2.x.6085]实现的内部压力和表面压力。网格被细化了4次。  与之前使用[2.x.6086]的数字相比，在每个单元上，解决方案不再是恒定的，因为我们现在使用双线性多项式来做近似。因此，在一个内部有4个压力值，在每个面上有2个压力值。

[2.x.6087]

与[2.x.6088]组合的相应图像相比，现在的解决方案大大增加了准确性，特别是在界面上如此接近于连续，以至于我们不再能够区分相邻单元上的界面压力[2.x.6089]和内部压力[2.x.6090]。

[1.x.2323][1.x.2324] 。

以下是我们使用[2.x.6091]元素组合得到的压力、速度和通量的收敛率。

[2.x.6092]

[2.x.6093]的收敛率在2左右，符合预期。




[1.x.2325][1.x.2326] 。

让我们再提高一个多项式等级。以下是使用[2.x.6094]实现的内部压力和表面压力，网格大小为[2.x.6095]（即5个全局网格细化步骤）。在程序中，我们在生成图形输出时使用`data_out_face.build_patches(fe.degree)`（参见[2.x.6096]的文档，这里意味着我们将每个2d单元内部分成4个子单元，以便提供更好的二次多项式的可视化。  [2.x.6097]




[1.x.2327][1.x.2328] 。

和以前一样，我们可以使用[2.x.6098]组合生成压力、速度和流量的[2.x.6099]误差的收敛数据。

[2.x.6100]

再一次，[2.x.6101]的收敛率符合预期，其数值在3左右。


examples/step-62/doc/intro.dox

[2.x.6102]

[1.x.2329][2.x.6103] 。




[2.x.6104] 作为这个程序的前提条件，你需要安装HDF5、复杂的PETSc和p4est库。在[1.x.2330]文件中描述了deal.II与这些附加库的安装情况。

[1.x.2331] 声子晶体是一种周期性的纳米结构，可以改变机械振动或[声子]的运动（https://en.wikipedia.org/wiki/Phonon）。声子结构可用于分散、引导和限制机械振动。这些结构在[量子信息](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)方面有潜在的应用，并已被用于研究[宏观量子现象](https://science.sciencemag.org/content/358/6360/203)。声子晶体通常是在[洁净室]中制造的(https://en.wikipedia.org/wiki/Cleanroom)。

在本教程中，我们展示了如何设计一个[声子超晶格空腔](https://doi.org/10.1103/PhysRevA.94.033813)，这是一种特殊类型的声子晶体，可用于限制机械振动。声子超晶格空腔是由两个[分布式布拉格反射器](https://en.wikipedia.org/wiki/Distributed_Bragg_reflector)、镜子和一个[2.x.6105]空腔组成，其中[2.x.6106]是声学波长。声学DBRs是周期性结构，其中一组具有对比物理特性（声速指数）的双层堆栈被重复[2.x.6107]次。超晶格空腔通常通过[分子束外延](https://en.wikipedia.org/wiki/Molecular-beam_epitaxy)在[砷化镓](https://en.wikipedia.org/wiki/Gallium_arsenide)晶片上生长。双层对应于砷化镓/砷化铝镜像对。如下图所示，镜像层（棕色和绿色）的厚度为[2.x.6108]，空腔（蓝色）的厚度为[2.x.6109] 。

[2.x.6110]

在本教程中，我们计算了[带隙](https://en.wikipedia.org/wiki/Band_gap)和声子超晶格空腔的机械共振，但这里介绍的代码可以很容易地用于设计和计算其他类型的[声子晶体](https://science.sciencemag.org/content/358/6360/203)。

该装置是一个波导，其中的波从左到右。本教程的模拟是在二维进行的，但代码是独立于维度的，可以很容易地用于三维模拟。波导的宽度等于域的[2.x.6111]维，波导的长度等于域的[2.x.6112]维。有两个取决于波导宽度的制度。

- 单一模式。在这种情况下，结构的宽度要比波长小得多。   这种情况可以用有限元法（我们在这里采取的方法）或用简单的半分析法[一维转移矩阵形式]（https://en.wikipedia.org/wiki/Transfer_matrix）来解决。

- 多模。在这种情况下，结构的宽度比波长大。   这种情况可以用有限元法或[散射矩阵形式主义]（https://doi.org/10.1103/PhysRevA.94.033813）来解决。   尽管我们在本教程中没有研究这种情况，但通过增加波导宽度参数（jupyter笔记本中的`dimension_y'），很容易达到多模制度。

本教程的模拟是在频域进行的。为了计算传输频谱，我们使用了时域[FDTD](https://meep.readthedocs.io/en/latest/Python_Tutorials/Resonant_Modes_and_Transmission_in_a_Waveguide_Cavity/)模拟中常用的一个[程序]。在结构的左侧产生一个特定频率的脉冲，在结构的右侧测量传输的能量。仿真运行了两次。首先，我们运行声子结构的模拟并测量传输能量。

[2.x.6113]

然后，我们运行没有声子结构的模拟，并测量传输的能量。我们使用没有结构的模拟来进行校准。

[2.x.6114]

传输系数相当于第一次模拟的能量除以校准能量。我们对每个频率步骤重复这一程序。




[1.x.2332] 我们在这里要模拟的是弹性波的传输。因此，对问题的正确描述使用了弹性方程，在时域中，弹性方程由以下几项给出

[1.x.2333]

其中刚度张量[2.x.6115]取决于空间坐标，应变是位移的对称梯度，由以下公式给出

[1.x.2334]



[完美匹配层（PML）](https://en.wikipedia.org/wiki/Perfectly_matched_layer)可以用来在边界处截断解决方案。PML是一种导致复杂坐标拉伸的变换。

本教程程序没有采用时域方法，而是通过对时间变量进行傅里叶变换，将上述方程转换为频域。频域中的弹性方程的内容如下

[1.x.2335]

其中系数[2.x.6116]说明了吸收情况。3D中有3个[2.x.6117]系数，2D中有2个。[2.x.6118]的虚部在PML外等于零。PML仅对精确的波浪方程是无反射的。当方程组被离散化时，PML就不再是无反射的了。只要介质是缓慢变化的，反射就可以变得任意小，见[绝热定理](https://doi.org/10.1103/PhysRevE.66.066608)。在代码中，已经使用了PML的二次开启。线性和立方开启也是[已知可行的](https://doi.org/10.1364/OE.16.011376)。这些方程可以扩展为

[1.x.2336]



[1.x.2337]

其中对重复指数（这里是[2.x.6119]，以及[2.x.6120]和[2.x.6121]）的求和一如既往地隐含着。请注意，应用PML的复数坐标拉伸后，应变不再是对称的。这组方程可以写成

[1.x.2338]



与应变一样，应力张量在PML内也不是对称的（[2.x.6122]）。事实上，PML内部的场不是物理的。介绍张量[2.x.6123]和[2.x.6124]是有用的。

[1.x.2339]



我们可以乘以[2.x.6125]并在[2.x.6126]域上进行积分，并进行部分积分。

[1.x.2340]

正是这组方程，我们要解决一组频率[2.x.6127]，以计算传输系数与频率的关系。这个线性系统变成

[1.x.2341]



[1.x.2342] 在本教程中，我们使用python [jupyter notebook](https://github.com/dealii/dealii/blob/master/examples/step-62/step-62.ipynb)来设置参数和运行模拟。首先，我们创建一个HDF5文件，在其中存储参数和模拟的结果。

每个模拟（位移和校准）都存储在一个单独的HDF5组中。

[1.x.2343]




examples/step-62/doc/results.dox



[1.x.2344]

[1.x.2345]

在[jupyter notebook](https://github.com/dealii/dealii/blob/master/examples/step-62/step-62.ipynb)中用以下代码分析了结果

[1.x.2346]



一个声腔的特点是[共振频率](https://en.wikipedia.org/wiki/Resonance)和[品质因子](https://en.wikipedia.org/wiki/Q_factor)。质量因子等于谐振器中储存的能量与每周期耗散的能量之间的比率，这大约相当于谐振频率与[半满宽度（FWHM）](https://en.wikipedia.org/wiki/Full_width_at_half_maximum)之间的比率。FWHM等于振动功率大于谐振频率的一半的带宽。

[1.x.2347]



机械共振[2.x.6128]的振幅的平方作为频率的函数有一个高斯形状

[1.x.2348]

其中[2.x.6129]是共振频率，[2.x.6130]是耗损率。我们在jupyter笔记本中使用前面的方程式来拟合机械共振。

鉴于我们所选择的参数值，人们可以通过分析来估计谐振频率。事实上，我们在这个程序中得到的结果证实了这一点：声子超晶格空腔在20GHz时表现出机械共振，质量系数为5046。下面的图片显示了在共振频率附近的传输振幅和相位与频率的关系。

[2.x.6131][2.x.6132] 。

上面的图片表明，周期性结构有其预期的效果：它实际上只让一个非常特定频率的波通过，而所有其他的波都被反射。当然，这正是人们建造这类设备的目的。但这并不十分容易。在实践中，实际上只有一个 "带隙"，也就是说，该设备只在一定的频率范围内阻止20GHz频率以外的波。事实上，要想知道这个被阻挡的 "间隙 "有多大，我们可以通过输入文件中的适当参数将频率范围扩大到16GHz。然后我们得到以下图像。

[2.x.6133]

这张图片表明的是，在18到22GHz左右的范围内，确实只有频率为20GHz的波被允许通过，但在这个范围之外，还有很多其他频率可以通过该设备。

[1.x.2349]

我们可以用Paraview或VisIt检查模态轮廓。正如我们所讨论的，在共振时，所有的机械能都被传递，运动的振幅在腔内被放大。可以看出，PML对于截断解决方案是非常有效的。下图显示了共振时的模式轮廓。

[2.x.6134]

另一方面，在共振之外，所有的机械能都被反射。下面的图片显示了19.75GHz时的轮廓。注意力脉冲和反射波在位置[2.x.6135]的干扰。

[2.x.6136]

[1.x.2350]

声波超晶格空腔在[量子光学机械学](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)中找到了应用。这里我们介绍了二维超晶格空腔的模拟，但这个代码也可以用来模拟 "现实世界 "的三维设备，如[微柱超晶格空腔](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.99.060101)，它是研究宏观量子现象的有希望的候选者。微柱超晶格空腔的20GHz模式本质上是一个机械谐波振荡器，与环境隔离得非常好。如果该装置在稀释冰箱中被冷却到20mK，那么该模式就会成为一个宏观的量子谐波振荡器。




[1.x.2351]

我们可以不在C++文件中设置参数，而是用一个Python脚本来设置参数，并将其保存在HDF5文件中，我们将使用该文件进行模拟。然后deal.II程序将从HDF5文件中读取参数。

[1.x.2352]



为了读取HDF5参数，我们必须使用[2.x.6137]标志。

[1.x.2353]




examples/step-63/doc/intro.dox

[2.x.6138]

[1.x.2354]

[2.x.6139]

[1.x.2355]

[1.x.2356]

该程序使用几何多网格（GMG）预处理程序来解决一个平流-扩散问题。在步骤16中讨论了该预处理程序的基本原理；这里我们讨论了非对称PDE所需的必要变化。此外，我们还介绍了块平滑的概念（与步骤16中的点平滑相比），并检查了加法和乘法平滑器的DoF重新编号的效果。

[1.x.2357] 平流-扩散方程由以下公式给出

[1.x.2358]

其中[2.x.6140] ，[2.x.6141]是[1.x.2359]，而[2.x.6142]是一个来源。有几个注意事项。

1.如果[2.x.6143]，这就是在步骤16（以及其他许多地方）解决的拉普拉斯方程。

2.如果[2.x.6144]，那么这就是步骤9中解决的静止平流方程。

3.人们可以为这个问题定义一个无尺寸的数字，称为[1.x.2360]。  [2.x.6145] ，其中[2.x.6146] 是领域的长度尺度。它描述了我们所考虑的那种方程的特点。如果[2.x.6147]，我们说问题是[1.x.2361]，否则如果[2.x.6148]我们将说问题是[1.x.2362]。

在本教程的讨论中，我们将关注以对流为主的流动。这是很复杂的情况。我们知道，对于扩散主导的问题，标准的Galerkin方法可以很好地工作，我们也知道简单的多网格方法，如步骤16中定义的方法是非常有效的。另一方面，对于平流主导的问题，标准Galerkin方法会导致振荡和不稳定的离散，而简单的求解器往往不是很有效。因此，本教程程序旨在解决这两个问题。




[1.x.2363]

使用标准的Galerkin有限元方法，对于合适的测试函数[2.x.6149]，PDE的离散弱形式将为

[1.x.2364]

其中

[1.x.2365]



不幸的是，用这种方法通常会得到震荡解。事实上，对于这种表述，可以显示出以下误差估计。

[1.x.2366]

如果精确解足够平滑，右边的下限可以按如下方式估计。

[1.x.2367]

其中[2.x.6150]是所用有限元的多项式程度。因此，我们得到的估计是

[1.x.2368]

换句话说，数值解会收敛。另一方面，鉴于上述[2.x.6151]的定义，我们不得不期待当[2.x.6152]时，即如果问题只有少量的扩散时，数值解会很差，而且误差很大。

为了解决这个问题，我们将考虑新的弱形式

[1.x.2369]

其中，对所有单元进行求和 [2.x.6153] ，对每个单元进行内积，[2.x.6154] 是定义在 [2.x.6155] 中的逐个单元的常数稳定参数。

从本质上讲，加入离散的强形式残差会增强双线性形式[2.x.6156]的矫捷性，从而增加离散解的稳定性。这种方法通常被称为[1.x.2370]或[1.x.2371]（流线上风/Petrov-Galerkin）。




[1.x.2372]

本教程的目标之一是从使用一个简单的（point-wise）高斯-赛德尔（SOR）平滑器开始扩展，该平滑器在步骤16（类PreconditionSOR）中用于多网格层次结构的每一层。术语 "point-wise "传统上用于求解器，表示每次在一个 "网格点 "求解；对于标量问题，这意味着使用一个求解器，每次更新线性系统的一个未知数，保持所有其他未知数固定不变；然后在问题中的所有未知数上进行迭代，一旦完成，从第一个未知数开始重新进行，直到这些 "扫频 "收敛。雅可比、高斯-赛德尔和SOR迭代都可以用这种方式解释。在多网格的背景下，人们不认为这些方法是 "求解器"，而是 "平滑器"。因此，人们对实际解决线性系统不感兴趣。为了使多网格方法发挥作用，只需去除残差的高频部分即可，因为这样可以将解限制在更粗的网格中。  因此，我们只需对所有未知数进行少量的、固定数量的 "扫频"。在本教程的代码中，这是由 "平滑步骤 "参数控制的。

但众所周知，这些方法在作为求解器时收敛得相当慢。虽然作为多网格平滑器，它们出乎意料地好，但它们也可以被改进。特别是，我们在这里也考虑 "基于单元的 "平滑器。这些方法一次解决一个单元上的所有未知数，保持所有其他未知数的固定；然后它们转到下一个单元，如此反复。我们可以把它们看作是雅可比（Jacobi）、高斯-赛德尔（Gauss-Seidel）或SOR的 "区块 "版本，但由于自由度是在多个单元中共享的，这些区块是重叠的，实际上这些方法最好在加法和乘法施瓦兹方法的框架内解释。

与step-16相比，我们的测试问题包含一个平流项。特别是在小的扩散常数[2.x.6157]下，信息会沿着给定的平流方向的流线进行传输。这意味着，如果平滑器允许信息在单一平滑器应用中沿下游方向传播，那么平滑器可能会更有效。如果我们想按照这些未知数（或未知数块）的列举顺序一次解决一个未知数（或未知数块），那么这个信息传播特性需要相应地重新排列自由度或单元（对于基于单元的平滑器），以便更上游的自由度被提前处理（指数较低），更下游的自由度被推迟处理（指数较大）。排序的影响将在结果部分可见。

现在让我们简单地定义一下本教程中使用的平滑器。关于更详细的介绍，我们参考 [2.x.6158] 和书籍 [2.x.6159] 和 [2.x.6160] 。施瓦兹预处理器需要一个分解

[1.x.2373]

的有限元空间 [2.x.6161] 。每个子问题 [2.x.6162] 也有一个基于双线性形式 [2.x.6164] 的 Ritz 投影 [2.x.6163] 。这个投影对每个子问题[2.x.6165]诱导出一个局部算子[2.x.6166] 。如果[2.x.6167]是对[2.x.6168]的正交投影，可以证明[2.x.6169] 。

有了这个，我们可以为算子[2.x.6170]定义一个[1.x.2374]为

[1.x.2375]

换句话说，我们将我们的解决方案投射到每个子问题中，应用子问题的逆向[2.x.6171]，并将所有[2.x.6172]的贡献加起来。

请注意，我们可以通过为每个自由度定义一个子问题[2.x.6173]，将逐点（一次一个未知数）的雅可比方法解释为加性施瓦兹方法。然后，[2.x.6174]成为与[2.x.6175]的对角线项的逆数相乘的方法。

对于本教程中使用的 "块状雅可比 "方法，我们为当前层次上的网格的每个单元定义一个子问题[2.x.6176]。注意，我们使用的是连续有限元，所以这些块是重叠的，因为两个单元之间的界面上的自由度都属于两个子问题。对子问题（在deal.II中它们被称为 "块"）进行操作的施瓦茨算子的逻辑在RelaxationBlock类中实现。块状雅可比 "方法是在RelaxationBlockJacobi类中实现的。该类的许多方面（例如如何定义块以及如何反转局部子问题[2.x.6177]）可以在平滑器数据中配置，详见[2.x.6178]和[2.x.6179]。

到目前为止，我们讨论了加法平滑器，其中更新可以独立应用，并且在单个平滑器应用中没有信息流动。A[1.x.2376]解决了这个问题，其定义为

[1.x.2377]

与上面不同的是，对子问题[2.x.6180]的更新是按顺序应用的。这意味着在颠倒子问题[2.x.6181]时得到的更新立即被用于[2.x.6182]。这在写出项目的时候就可以看到。

[1.x.2378]



当把子空间[2.x.6183]定义为整个自由度块时，这个方法在RelaxationBlockSOR类中实现，当你在本教程中选择 "块SOR "时使用。RelaxationBlockSOR类也是从RelaxationBlock派生的。因此，加法和乘法的施瓦兹方法都在一个统一的框架内实现。

最后，让我们注意到，标准的高斯-赛德尔（或SOR）方法可以被看作是一个乘法施瓦茨方法，每个DoF都有一个子问题。




[1.x.2379]

我们将考虑以下测试问题：[2.x.6184] ，即一个以原点为圆心的半径为0.3的正方形被移除。此外，我们使用[2.x.6185], [2.x.6186], [2.x.6187], 和迪里希特边界值

[1.x.2380]



下面的数字描述了有（左）和无（右）流线扩散的解决方案。在没有流线扩散的情况下，我们看到边界层周围有很大的振荡，这表明标准的Galerkin有限元方法对这个问题的不稳定性。

[2.x.6188]


examples/step-63/doc/results.dox



[1.x.2381]

[1.x.2382]

GMG的主要优势在于它是一种[2.x.6189]方法，也就是说，问题的复杂性随着问题的大小而线性增加。为了证明本教程中介绍的线性求解器实际上是[2.x.6190]，我们只需要证明GMRES求解的迭代次数在我们细化网格时保持大致不变。

以下每个表格都给出了GMRES的迭代次数，以减少初始残差的系数[2.x.6191] 。我们选择了足够数量的平滑步骤（基于该方法），以获得与网格大小无关的迭代数。从下面的表格可以看出，该方法确实是 [2.x.6192] 。

[1.x.2383]

逐点平滑器（"Jacobi "和 "SOR"）是按照每层的DoFs的编号顺序来应用的。我们可以使用DoFRenumbering命名空间来影响这一点。块平滑器的应用是基于我们在`setup_smoother()`中设置的顺序。我们可以直观地看到这个编号。下面的图片显示了在下游、随机和上游编号中的活动单元的编号（从左到右）。

[2.x.6193]

让我们从加性平滑器开始。下表显示了从GMRES获得收敛的必要迭代次数。

[2.x.6194]

我们看到，重新编号的DoF/单元对收敛速度没有影响。这是因为这些平滑器独立计算每个DoF（点平滑器）或单元（块平滑器）的操作，并将结果相加。由于我们可以将这些平滑器定义为矩阵之和的应用，而矩阵加法是交换性的，所以我们对不同组件进行加法的顺序不会影响最终结果。

另一方面，乘法平滑器的情况则不同。

[2.x.6195]

在这里，我们可以通过在平流方向上对DoFs/单元进行重新编号来加快收敛速度，同样，如果我们在相反的方向上进行重新编号，我们可以减缓收敛速度。这是因为平流主导的问题有一个定向的信息流（在平流方向），如果对DoFs/单元进行正确的重新编号，乘法就能够捕捉到这些信息。

然而，乘法的这一特点取决于[2.x.6196]的值。当我们增加[2.x.6197]，问题变得更加以扩散为主时，我们的信息在网格上的传播更加均匀，在平流方向上重新编号的优势就会减弱。相反，在[2.x.6198]的极端情况下（仅有平流），我们有一个一阶PDE，具有正确重编号的乘法成为有效的求解器。正确的下游编号可能导致方法只需要一次迭代，因为信息可以从流入边界向下游传播，而没有相反方向的信息传输。然而，请注意，在[2.x.6199]的情况下，必须对这种情况下的边界条件给予特别关注）。




[1.x.2384]

我们将把结果限制在使用下游重新编号的运行上。下面是对[2.x.6200]和[2.x.6201]元素的所有四个平滑器的交叉比较。

[2.x.6202]

我们看到，对于[2.x.6203]，两个乘法平滑器需要的平滑步骤和迭代次数的组合都比任何一个加法平滑器小。然而，当我们将度数增加到[2.x.6204]元素时，在平滑步骤和迭代次数方面，块平滑器有明显的优势。具体来说，块状SOR平滑器在度数上给出了恒定的迭代次数，而块状Jacobi平滑器的迭代次数只增加了约38%，而Jacobi和SOR的迭代次数分别为75%和183%。

[1.x.2385]

迭代次数并不能完全说明一个平滑器对另一个平滑器的最优性。很明显，我们必须检查迭代的成本。块状平滑器在这里处于不利地位，因为它们必须为每个单元构建和反转一个单元矩阵。下面是一个具有74,496个DoF的[2.x.6205]元素的求解时间的比较。

[2.x.6206]

需要最多迭代的平滑器（Jacobi）实际上需要最短的时间（大约是下一个最快方法的2/3）。这是因为应用雅可比平滑步骤所需要的只是乘以一个对角线矩阵，这是非常便宜的。另一方面，虽然SOR比块SOR需要超过3倍的迭代（每个迭代有3倍的平滑步骤），但时间大致相当，这意味着块SOR的一个平滑步骤比SOR的一个平滑步骤大约慢9倍。最后，Jacobi块的成本比SOR块高6倍，这在直觉上是有道理的，因为每种方法的1个步骤都有相同的成本（反转单元格矩阵并将其相加或相乘），而Jacobi块每次迭代的平滑步骤是3倍，迭代次数是2倍。




[1.x.2386]

还有几个重要的点需要提及。

<ol> [2.x.6207] 对于平行分布的网格，乘法不能在整个领域内执行。这是因为它们一次操作一个单元，而下游的单元只有在上游的单元已经完成后才能被处理。这在单个处理器上是没有问题的。处理器只是一个接一个地浏览单元的列表。然而，在并行的情况下，这将意味着一些处理器是空闲的，因为上游处理器还没有完成对当前处理器所拥有的上游单元的工作。一旦上游处理器完成工作，下游处理器就可以开始工作，但那时上游处理器已经没有工作了。换句话说，在这些平稳的步骤中，大部分时间，大多数处理器实际上是空闲的。这不是获得良好的并行可扩展性的方法!

我们可以使用一种混合方法，即在每个子域上应用乘法平滑器，但是当你增加子域的数量时，该方法接近于加法的行为。这是这些方法的一个主要缺点。  [2.x.6208]

[2.x.6209]目前对块平滑器的研究表明，很快我们将能够计算单元矩阵的逆，比目前在deal.II里面做的要便宜得多。这项研究是基于快速对角线化方法（可以追溯到20世纪60年代），在光谱界已经使用了大约20年（例如，见[1.x.2387]）。目前，人们正在努力将这些方法推广到DG，并使其更加强大。此外，人们似乎应该能够利用无矩阵的实现，以及在域的内部，单元矩阵往往看起来非常相似的事实，允许更少的矩阵逆计算。  [2.x.6210] [2.x.6211]。

结合1.和2.，我们有充分的理由期待像块状雅可比这样的方法在未来变得非常强大，尽管目前对这些例子来说它是相当缓慢的。




[1.x.2388]

[1.x.2389]

改变平滑步骤的数量和平滑器放松参数（在[2.x.6212]中设置在[2.x.6213]里面，只对点平滑器有必要），以便我们对一个[2.x.6214]元素保持一个恒定的迭代次数。

[1.x.2390]

增加/减少乘法的`.prm`文件中的参数 "Epsilon"，观察哪些数值的重编号不再影响收敛速度。

[1.x.2391]

这段代码被设置为可以在自适应细化的网格中正常工作（接口矩阵被创建和设置）。设计一个合适的细化标准或尝试KellyErrorEstimator类。


examples/step-64/doc/intro.dox

[2.x.6215]

[1.x.2392]




[1.x.2393]

这个例子展示了如何使用CUDA在GPU上实现超立方体上系数可变的亥姆霍兹方程的无矩阵方法。该线性系统将使用共轭梯度法进行求解，并通过MPI进行并行化。

在过去的几年里，一般的异构计算，特别是GPU，已经获得了很多的青睐。这是因为在给定的功率预算下，GPU比CPU提供更好的计算能力和内存带宽。在2019年初的架构中，对于PDE相关的任务，GPU的功率效率约为服务器CPU的2-3倍，宽[1.x.2394]。GPU也是机器学习中最受欢迎的架构。另一方面，GPU并不容易编程。这个程序探索了deal.II的能力，看看这样的程序可以如何有效地实现。

虽然我们试图让CPU和GPU的无矩阵类的接口尽可能接近，但还是有一些区别。当在GPU上使用无矩阵框架时，人们必须编写一些CUDA代码。然而，其数量相当少，而且CUDA的使用仅限于几个关键词。




[1.x.2395]

在这个例子中，我们考虑亥姆霍兹问题[1.x.2396] 。

其中[2.x.6216]是一个可变系数。

我们选择[2.x.6217]和[2.x.6218]作为域。由于系数是围绕原点对称的，但域却不是，我们最终会得到一个非对称的解决方案。

如果你在本教程中读到这里，你就会知道这个问题的弱式表述是怎样的，以及原则上是怎样为它组建线性系统的。当然，在这个程序中，我们实际上不会形成矩阵，而只是表示它与之相乘时的作用。




[1.x.2397]

GPU（我们从现在开始用 "设备 "一词来指代GPU）有自己的内存，与CPU（我们从现在开始用 "主机 "一词）可访问的内存分开。设备上的正常计算可以分为三个独立的步骤。

-# 数据从主机移到设备上。

-#计算是在设备上完成的。

-# 结果从设备移回主机。

数据移动可以由用户代码显式完成，也可以使用UVM（统一虚拟内存）自动完成。在deal.II中，只支持第一种方法。虽然这意味着用户有额外的负担，但这可以更好地控制数据移动，更重要的是可以避免在主机而不是设备上错误地运行重要的内核。

deal.II中的数据移动是使用[2.x.6219]完成的，这些向量可以被看作是主机上的缓冲区，用于存储从设备接收的数据或向设备发送数据。有两种类型的向量可以在设备上使用。

- [2.x.6220]，它类似于更常见的Vector<Number>，和

- [2.x.6221] [2.x.6222]这是一个普通的[2.x.6223]，我们已经指定了要使用哪个内存空间。

如果没有指定内存空间，默认为[2.x.6224]。

接下来，我们展示如何使用[2.x.6225]将数据移入/移出设备。

[1.x.2398]

这里使用的两个向量类都只在一台机器上工作，也就是说，一个内存空间在主机上，一个在设备上。

但在有些情况下，人们希望在一些机器上的多个MPI进程之间运行并行计算，而每个机器都配备了GPU。在这种情况下，人们希望使用[2.x.6226]，它是类似的，但`import()`阶段可能涉及MPI通信。

[1.x.2399]

`relevant_rw_vector`是一个存储向量所有元素的子集的对象。通常情况下，这些是[2.x.6227]"本地相关的DoF"，这意味着它们在不同的MPI进程之间是重叠的。因此，一台机器上存储在该向量中的元素可能与该机器上的GPU存储的元素不一致，需要MPI通信来导入它们。

在所有这些情况下，在导入矢量时，可以插入数值（使用[2.x.6228]或添加到矢量的先前内容中（使用[2.x.6229] ）。




[1.x.2400]

在设备上评估无矩阵算子所需的代码与主机上的代码非常相似。然而，也有一些区别，主要是Step-37中的`local_apply()`函数和正交点的循环都需要封装在自己的函数中。


examples/step-64/doc/results.dox



[1.x.2401]

由于本教程的主要目的是演示如何使用[2.x.6230]接口，而不是计算任何有用的东西本身，所以我们在这里只是显示预期的输出。

[1.x.2402]



在这里，我们可以做两个观察。首先，数值解的准则在收敛，大概是收敛到精确（但未知）解的准则。其次，每次细化网格时，迭代次数大约增加一倍。这与CG迭代次数随矩阵条件数的平方根增长的预期一致；而且我们知道二阶微分运算的矩阵条件数的增长方式是[2.x.6231] 。这当然是相当低效的，因为一个最佳解算器的迭代次数与问题的大小无关。但是要有这样一个求解器，就需要使用比我们在这里使用的身份矩阵更好的预处理。


[1.x.2403]

[1.x.2404]

目前，这个程序完全没有使用预处理程序。这主要是因为构建一个高效的无矩阵预处理程序是不容易的。  然而，只需要相应矩阵的对角线的简单选择是很好的选择，这些也可以用无矩阵的方式计算。另外，也许更好的是，我们可以扩展教程，使用类似步骤37的切比雪夫平滑器的多重网格。


examples/step-65/doc/intro.dox



[2.x.6232]

[1.x.2405]

[1.x.2406]

[1.x.2407]

本教程程序介绍了一个高级流形类--TransfiniteInterpolationManifold，以及如何解决其主要缺点--相对较高的成本。

[1.x.2408]

[1.x.2409]

在许多应用中，有限元网格必须能够表示一个相对复杂的几何体。在step-1、step-49和step-53教程程序中，已经介绍了deal.II库中可用的一些生成网格的技术。给定一个基础网格，deal.II能够通过将单元格均匀地或仅在计算域的选定部分细分为子单元来创建一个更细的网格。除了GridGenerator命名空间中的基本网格划分功能外，deal.II还提供了一些接口，可以使用命名空间GridIn的功能读入由（仅四边形和六边形）网格生成器生成的网格，例如在步骤5中演示。外部生成的网格的一个基本限制是，网格中生成的单元所提供的信息只包括顶点的位置和它们的连接性，而没有最初创建这个网格的网格生成器所提供的底层几何体的背景。一旦网格在deal.II中被细化，需要放置更多的点，这就成了问题。第54步教程程序显示了如何通过使用OpenCASCADE库方面的CAD曲面来克服这个限制，第53步通过在源代码内以编程方式提供同类信息。

在deal.II中，网格细化过程中新点的放置或高阶映射的定义由流形对象控制，详见[2.x.6233] "流形模块"。举个例子，考虑以下二维环形的情况（图片取自流形模块）。如果我们从10个单元的初始网格开始，在不附加任何流形的情况下全局细化网格三次，我们将得到以下网格。

[2.x.6234]

图片看起来是这样的，因为在默认情况下，deal.II只知道通过平均父单元的顶点位置来放置子单元的顶点。这就产生了一个多边形域，其面是原始（粗略的网格）单元的边缘。很明显，我们必须对三角形的边界面附加一个曲线描述，以便在网格细化时重现圆形，就像下图一样。

[2.x.6235]

这样就好多了。如果我们继续细化网格，至少现在的内外边界已经接近真实的圆了。然而，这幅图中的网格对于环形来说仍然不是最佳的，因为从一个单元到下一个单元的[1.x.2410]线在某些顶点上有扭结，人们宁愿使用下面的网格。

[2.x.6236]

在这最后一种（最佳）情况下，也是由[2.x.6237]产生的默认情况，曲线流形描述（在这种情况下是极地流形描述）不仅适用于边界面，而且适用于整个域。每当三角化要求一个新的点，例如，当它将一个单元细化为四个子单元时，边缘或单元的中点，它将沿着极坐标系统中各自的中点来放置它们。相比之下，上面那种只有边界受制于极地流形的情况，只有沿边界的中点会沿着曲线描述放置，而内部的中点会通过直角坐标系中周围点的合适平均值来计算（更多细节见[2.x.6238] "流形模块"）。

在这一点上，人们可能会认为曲线形的体积描述是一种方式。这一般来说是不会错的，尽管有时并不那么容易描述这到底应该如何工作。这里有几个例子。

- 想象一下，上面的网格实际上是一个圆盘，而不只是一个环。   在这种情况下，极地流形会在原点退化，不会产生合理的新点。事实上，为那些应该 "看起来是圆的 "但可能在原点或接近原点的东西定义流形描述是令人惊讶的非常困难的。

- 当人们试图将球形流形附加到整个体积上时，类似的事情也会发生在三维球的原点；在这种情况下，新流形点的计算会因异常而中止。

- CAD几何体通常只描述域的边界，就像我们在上面第二张图中只把流形附在边界上一样。同样地，Step-54只使用CAD几何体来生成表面网格（也许是因为这是解决相关问题所需要的），但是如果想解决那里描述的水或船周围空气中的问题，我们就需要有一个体积网格。那么问题来了，我们应该如何准确地描述域的内部应该发生什么。

这些简单的例子清楚地表明，对于许多有趣的情况，我们必须从对全体积的分析性曲率描述的愿望中退一步。将需要有[1.x.2411]种导致曲率也在内部的信息，但必须有可能做到这一点，而不需要实际写下描述那种几何的明确公式。

那么，如果我们不在内部做任何事情，只把表面描述为流形，会发生什么呢？有时，如上图所示的环，结果并不可怕。但有时却很糟糕。考虑一个环状体的情况（例如用[2.x.6239]生成的环状体，只在表面附加一个TorusManifold对象，内部单元和面没有附加流形，细化前有六个单元在环状方向。如果对网格进行一次细化，我们将得到如下的网格，图中显示的是网格的上半部分被剪切掉了。

[2.x.6240]

这显然是次优的。事实上，如果我们从少于上面显示的环形方向的六个单元开始，映射在某些区域实际上是倒置的，因为沿着内部单元放置的新点与边界相交，因为它们不是沿着环形方向的圆形。环形的简单情况仍然可以被固定下来，因为我们知道环形方向是沿着圆柱坐标系的，所以在曲面上附加一个TorusManifold，结合CylindricalManifold，在环形方向上有适当的周期性，应用于所有的内部实体，将产生一个高质量的网格，如下所示，现在有两个顶部的单元被隐藏起来。

[2.x.6241]

这个网格是相当不错的，但显然它与对体积的良好描述有关，而我们在其他情况下缺乏这种描述。实际上，在这种情况下也有一个不完美之处，因为我们可以看到域的内部的两个相邻单元的一些不自然的扭结，这些扭结被顶部的两个边界单元所隐藏，与下面的设置相反（由[2.x.6242]应用的默认流形并使用TransfiniteInterpolationManifold）。

[2.x.6243]

[1.x.2412]

为了找到一个更好的策略，让我们再看看二维圆盘（这也是沿环形方向旋转的环形实体的基础）。正如我们上面所学到的，我们只能将弯曲的极坐标描述应用于边界（或离原点足够远的单元的边缘），但最终必须过渡到对圆盘中心的直线描述。如果我们在单元的内部使用平坦的流形（也就是说，新的顶点是通过相邻的现有顶点的平均化而产生的），而极地流形只用于圆盘的边界，那么在进行四次全局细化之后，我们会得到以下网格。

[2.x.6244]

这并不是一个可怕的网格。同时，如果你知道最初的粗略网格是由中间的一个正方形和周围的四个盖子组成的，那么就不难看出这个网格的每一个细化步骤都是为了得到上面的图片。

虽然deal.II的三角测量类在创建新点时试图将信息从边界传播到内部，但这种算法的影响范围是有限的。

[2.x.6245]

上图突出了盘面上那些触及边界的单元，在当时只看一个单元的情况下，原则上可以考虑边界信息。显然，随着网格的细化，可以考虑到一些曲率的区域变得更加有限，因此在网格中形成了看似不规则的点。当计算最左边图片中任何一个边界单元的中心时，理想的位置是外圈和中间的单元之间的中点。这正是三角剖分类中第一个细化步骤所使用的内容。然而，对于第二次细化，所有的内部边缘以及内部单元格层只能根据平面流形描述来加点。

在这一点上，我们意识到需要什么来创建一个更好的网格。对于[1.x.2413]子单元中的[1.x.2414]新点，即在最左边的红色阴影层内创建的单元，我们要计算相对于各自粗单元覆盖区域内的曲率的插值。这可以通过在上图最左边面板的粗略网格的高亮单元中添加TransfiniteInterpolationManifold类来实现。该类遵守一般流形接口，即在其定义域内给定任何一组点，它可以计算符合流形的加权平均数（使用的公式将在一分钟后给出）。这些加权平均数在细化网格的时候，或者在给定单元上评估符合该流形的高阶映射（如MappingQGeneric或MappingC1）的时候都会用到。在圆盘粗网格的阴影单元上使用该流形（即不仅仅是最外层的单元），在经过四个全局步骤的细化后产生以下网格。

[2.x.6246]

这个网格的线条仍有一些扭结，但它们仅限于粗大的网格单元之间的面，而网格的其他部分则如人们所希望的那样平滑。事实上，给定一个直边的中心单元，这个表示法是最好的，因为所有的网格单元都遵循一个平滑的过渡，从内部的方形块的直边到边界的圆形。(我们可以做得更好一些，在中心的方形块中也允许一些曲率，随着中心的接近，这些曲率最终会消失)。




[1.x.2415]

在一个有一条曲线和三条直线的圆盘的简单情况下，我们可以明确写下如何实现形状的混合。为此，将物理单元（如顶部的单元）映射回参考坐标系[2.x.6247]是很有用的，在那里我们计算某些点之间的平均数。如果我们使用一个由四个顶点[2.x.6248]跨越的简单双线性地图，一个点[2.x.6249]的图像将是

[1.x.2416]



对于曲面的情况，我们要修改这个公式。对于圆盘粗略网格的顶部单元，我们可以假设点[2.x.6250]和[2.x.6251]位于下端的直线上，点[2.x.6252]和[2.x.6253]沿顶部由一个四分之一圆连接。然后我们将点[2.x.6254]映射为

[1.x.2417]

其中[2.x.6255]是一条曲线，用一个arclength参数[2.x.6257]来描述四分之一圆的[2.x.6256]坐标。这代表了单元格的直线下边缘和曲线上边缘之间的线性插值，也是上图的基础。

这个公式很容易被推广到所有四条边都由曲线而不是直线描述的情况。我们称这四个函数为[2.x.6258]或[2.x.6259]，在水平和垂直方向上，分别为四边形的左、右、下和上边缘的参数。然后，内插法为

[1.x.2418]



这个公式假设边界曲线与顶点[2.x.6261]，例如[2.x.6262]或[2.x.6263]匹配和重合。公式第二行的双线性插值的减法确保了在边界上完全遵循规定的曲线：沿着四条边中的每一条，我们需要减去在角上评估的两条相邻边的贡献，这时的贡献只是一个顶点位置。很容易检查出，如果四条曲线中的三条[2.x.6264]是直的，从而与双线性插值重合，那么上面的圆的公式就再现了。

这个公式被称为转折内插，由[1.x.2419]在1973年提出。尽管转义插值本质上只表示边界曲线的线性混合，但插值完全遵循每个实数[2.x.6265]或[2.x.6266]的边界曲线，也就是说，它插值的点数是无限的，这也是Gordon和Hall将这种插值的变体称为转义插值的最初动机。另一种解释是，无限插值从左右和上下线性插值，我们需要从中减去双线性插值，以确保在域的内部有一个单位重量。

无限插值很容易被推广到三个空间维度。在这种情况下，插值允许为一个三维单元的任何一个四边形混合6种不同的表面描述，为一个单元的线混合12种边缘描述。同样，为了确保地图的一致性，有必要减去边缘的贡献，再加上顶点的贡献，使曲线遵循规定的表面或边缘描述。在三维的情况下，也可以使用从曲线边缘到相邻面和相邻单元的转折插值。

在处理.II中的转置插值是通用的，因为它可以处理任意的曲线。它将以[2.x.6267]-维空间的原始坐标来评估曲线，但有一个（或两个，在三维的边缘情况下）坐标固定在[2.x.6268]或[2.x.6269]，以确保任何其他流形类，包括CAD文件（如果需要），都可以应用于开箱。无限插值是网格生成器的标准成分，因此在deal.II库中集成这一功能的主要优势是在自适应细化和粗化网格时启用，以及用于创建更高程度的映射，使用流形来插入网格顶点以外的额外点。

关于无限插值的最后一句话，我们提到在没有体积流形描述的情况下，deal.II中的网格细化策略也是基于无限插值的权重，在这个意义上是最优的。不同的是，默认算法一次只看到一个单元，因此将只对那些接触曲面流形的单元应用最优算法。相反，在整个[1.x.2420]个单元上使用转义映射（源于一个较粗的单元），可以用转义插值法，将信息从边界传播到远处的单元。




[1.x.2421]

一个具有无限流形描述的网格通常分两步建立。第一步是创建一个粗略的网格（或者从文件中读入），并在一些网格实体上附加一个曲面流形。对于上面的圆盘例子，我们将极坐标流形附加到沿外圆的面（这是由[2.x.6270]自动完成的）在我们开始细化网格之前，我们再为网格的所有内部单元和边缘分配一个TransfiniteInterpolationManifold，当然，这需要基于我们分配给这些实体的一些流形ID（除了边界上的圆以外的一切）。我们是否也给圆盘的内部正方形分配一个TransfiniteInterpolationManifold并不重要，因为对具有直边（或3D中的平坦面）的粗单元进行Transfinite插值，只是产生具有直边（平坦面）的细分子。

之后，当网格被细化或基于此网格建立高阶映射时，单元将查询底层流形对象的新点。这个过程需要一组周围的点，例如一个二维单元的四个顶点，以及一组对这些点的权重，用于定义一个新的点。对于一个单元格的中间点，四个顶点中的每一个都将得到0.25的权重。对于无限插值流形，建立加权和的过程需要一些严肃的工作。根据结构，我们要根据周围点的参考坐标[2.x.6271]和[2.x.6272]（或三维的[2.x.6273]）来组合这些点。然而，deal.II中流形类的接口并没有得到周围点的参考坐标（因为它们不是全局存储的），而只是物理坐标。因此，无限插值流形必须做的第一步是反转映射，并在无限插值的一个粗网格单元内找到参考坐标（例如，上述磁盘网格的四个阴影粗网格单元之一）。这种反演是通过牛顿迭代（或者说，基于有限差分的牛顿方案与布罗伊登方法相结合）完成的，并根据上述公式多次查询无限期插值。这些查询中的每一次都可能依次调用一个昂贵的流形，例如球的球形描述，并且本身就很昂贵。由于deal.II的Manifold接口类只提供了一组点，所以转置插值最初甚至不知道周围的点集属于哪个粗大的网格单元，需要根据一些启发式方法在几个单元中搜索。就[1.x.2422]而言，我们可以把无限插值的实现描述为基于[1.x.2423]的实现。三角形初始粗网格的每个单元都代表一个有自己参考空间的图表，而周围的流形提供了一种从图表空间（即参考单元）到物理空间的转换方式。粗网格单元的图表的集合是一个图集，像往常一样，在图集中查找东西时，人们做的第一件事就是找到正确的图表。

一旦找到周围点的参考坐标，参考坐标系中的新点将通过简单的加权和计算出来。最后，参考点被插入到无限插值的公式中，这就得到了所需的新点。

在许多情况下，曲面流形不仅在网格细化过程中使用，而且还用于确保计算域单元内边界的曲面表示。这对于保证复杂几何上的高阶多项式的高阶收敛性是必须的，但有时对于线性形状函数也需要一个精确的几何。这通常是通过对单元的多项式描述来实现的，如果表示曲面网格元素的多项式程度与数值解的多项式程度相同，则称为等参数概念。如果几何体的度数高于或低于解的度数，则分别称为超参数或次参数的几何体表示。在deal.II中，多项式表示的标准类是MappingQGeneric。例如，如果在三维中使用这个类的多项式度数[2.x.6274]，总共需要125个（即[2.x.6275]）点来进行内插。在这些点中，8个是单元的顶点，已经可以从网格中获得，但其他117个点需要由流形提供。如果使用无限插值流形，我们可以想象，通过回拉到一些尚未确定的粗略单元的参考坐标，然后在117个点中的每个点上进行后续的前推，是一个大量的工作，可能非常耗时。

更糟糕的是，许多程序的结构是这样的：对于同一个单元，映射被独立地查询了几次。它的主要用途是组装线性系统，即通过FEValues对象的`mapping`参数计算系统矩阵和右手边。然而，边界值的插值、数值误差的计算、输出的写入以及误差估计器的评估也必须涉及相同的映射，以确保对解向量的一致解释。因此，即使是解决一次的线性静止问题，也会多次评估映射的点。对于上面提到的三维案例，这意味着通过昂贵的算法多次计算每个单元的117个点。对于非线性或随时间变化的问题，情况更加紧迫，这些操作要反复进行。

由于通过无限插值进行流形描述的成本比对平流形的类似查询要高几百倍，所以只计算一次额外的点并在所有后续调用中使用这些点是有意义的。deal.II库提供的MappingQCache类正是为了这个目的。与系统矩阵所消耗的内存相比，这个缓存通常不会太大，在看这个教程程序的结果时就会明白。MappingQCache的用法很简单。一旦网格被设置好（或在细化过程中被改变），我们就调用[2.x.6276]，将所需的三角形以及所需的映射作为参数。然后，初始化会遍历网格的所有单元，并查询给定映射的附加点。这些点会被保存为单元的标识符，以便以后当映射计算一些与单元相关的量（如参考坐标和物理坐标之间的映射的Jacobian）时，它们可以被返回。

最后，我们提到，TransfiniteInterpolationManifold也使得网格的细化变得更加昂贵。在这种情况下，MappingQCache无济于事，因为它将计算随后不能再使用的点；目前在deal.II中不存在一个更有效的机制。然而，网格细化也包含许多其他昂贵的步骤，所以与其他计算相比，它并不是一个大问题。它在每个时间步长或非线性迭代中也最多只发生一次。

[1.x.2424]

在这个教程程序中，TransfiniteInterpolationManifold与MappingQCache的结合被举例说明。这个测试案例相对简单，占用了许多典型程序中涉及的解决阶段，例如步骤6的教程程序。作为一个几何体，我们选择了TransfiniteInterpolationManifold的一个使用原型，即涉及一个球形的设置，而这个球形又被一个立方体所包围。例如，这样的设置将用于嵌入背景介质中的球形包容物，如果该包容物具有不同的材料特性，需要通过元素界面来跟踪两种材料之间的界面。这里给出了一个可视化的网格。

[2.x.6277]

对于这种情况，我们要在域内的表面附加一个球形描述，并使用转折插值来平滑地切换到外部立方体的直线和球中心的立方体。

在该程序中，我们将遵循有限元程序的典型流程，从DoFHandler和稀疏模式的设置开始，组装一个线性系统来解决带有跳跃系数的泊松方程，用一个简单的迭代方法解决，用[2.x.6278]计算一些数值误差以及误差估计器。我们记录了每个部分的时间，并运行了两次代码。在第一次运行中，我们将一个MappingQGeneric对象分别交给程序的每个阶段，在这些阶段中，点被反复计算。在第二次运行中，我们用MappingQCache代替。


examples/step-65/doc/results.dox



[1.x.2425]

[1.x.2426]

如果我们用三度的多项式运行这个程序的三维版本，我们会得到以下程序输出。

[1.x.2427]



在讨论时序之前，我们看一下MappingQCache对象的内存消耗。我们的程序打印出它占用了23MB的内存。如果我们把这个数字与单个（解或右侧）向量的内存消耗联系起来，即1.5MB（即181,609个元素乘以每条8字节的双精度），或者与系统矩阵和稀疏模式所消耗的内存联系起来（274MB），我们就会发现，考虑到它的好处，这并不是一个过于沉重的数据结构。

在计时器方面，我们看到程序的整体运行时间明显改善了2.7倍。如果我们不考虑迭代求解器，它在两种情况下都是一样的（考虑到我们使用的简单预处理程序，以及稀疏矩阵-向量乘积对立方多项式的操作浪费的事实，它并不是最佳的），优势是几乎5倍。这对于一个线性静止问题来说是相当令人印象深刻的，而对于时间依赖性和非线性问题来说，成本的节省确实要突出得多，因为在这些问题上，会多次调用装配。如果我们研究一下各个组件，我们就会更清楚地了解发生了什么，以及为什么缓存会如此高效。在MappingQGeneric的情况下，基本上每一个涉及到映射的操作都需要至少5秒的时间来运行。规范的计算运行了两个[2.x.6279]函数，每个都需要5秒。(约束条件的计算比较便宜，因为它只在边界的单元格中评估映射，用于边界条件的插值)。如果我们将这5秒与填充MappingQCache的时间相比较，即5.2秒（对于所有单元，而不仅仅是活动单元），很明显，在MappingQGeneric的情况下，映射支持点的计算比其他一切都重要。也许最引人注目的结果是误差估计器的时间，标记为 "计算误差估计器"，其中MappingQGeneric的实现需要17.3秒，而MappingQCache的变体不到0.5秒。前者如此昂贵的原因（比如说，比装配贵三倍）是误差估计涉及到对面的量的评估，其中网格中的每个面都要求映射的额外点，而这些点又要经过非常昂贵的TransfiniteInterpolationManifold类。由于每个单元有六个面，这种情况比在装配中发生得更频繁。同样，MappingQCache很好地消除了重复评估，将所有涉及流形的昂贵步骤汇总到一个被重复使用的初始化调用中。


examples/step-66/doc/intro.dox

[2.x.6280]

[1.x.2428]


[1.x.2429]

[1.x.2430]

本教程程序的目的是演示如何在无矩阵框架内使用牛顿方法解决一个非线性问题。本教程结合了在步骤15、步骤16、步骤37、步骤48和其他中已经介绍的几种技术。




[1.x.2431]在单位圆[2.x.6281]上，我们考虑以下非线性椭圆边界值问题，受制于同质狄里奇边界条件。找到一个函数[2.x.6282]，使其成立。

[1.x.2432]

这个问题也被称为 [1.x.2433] ，是燃烧理论问题的一个典型例子，例如见 [2.x.6283] 。




[1.x.2434] 像往常一样，我们首先推导出这个问题的弱式公式，用一个光滑的测试函数[2.x.6284]乘以边界条件，在域[2.x.6285]上积分。通过部分积分，并将右边的项放到左边，就得到了弱式计算。找到一个函数[2.x.6286]，使其对所有测试函数[2.x.6287]都成立。

[1.x.2435]



选择拉格朗日有限元空间[2.x.6288]，它直接包含了同质Dirichlet边界条件，我们可以定义一个基[2.x.6289]，因此只需用这些基函数进行测试。因此离散的问题如下。找到[2.x.6290]，使得对所有[2.x.6291]都成立。

[1.x.2436]

由于每个有限元函数是基函数[2.x.6292]的线性组合，我们可以通过[2.x.6293]中由每个自由度（DOF）中的未知值组成的向量来确定有限元解决方案。因此，我们定义非线性函数[2.x.6294]代表离散非线性问题。

为了解决这个非线性问题，我们使用牛顿方法。因此，给定一个初始猜测[2.x.6295]，它已经满足了Dirichlet边界条件，我们通过连续应用以下方案确定一连串的牛顿步骤[2.x.6296]。

[1.x.2437]

因此，在每个牛顿步骤中，我们必须解决一个线性问题 [2.x.6297] ，其中系统矩阵 [2.x.6298] 由雅各布 [2.x.6299] 表示，右手 [2.x.6300] 由负残差 [2.x.6301] 表示。在这种情况下，解向量[2.x.6302]是[2.x.6303]的第1个牛顿步骤的牛顿更新。注意，我们假设初始猜测[2.x.6304]，它已经满足了问题公式中的迪里希特边界条件（事实上这也可能是一个不均匀的迪里希特边界条件），因此牛顿更新[2.x.6305]满足一个均匀的迪里希特条件。

到目前为止，我们只测试了基函数，然而，我们也可以将[2.x.6306]的任何函数表示为基函数的线性组合。在数学上，这意味着[2.x.6307]的每个元素都可以通过表示公式与向量[2.x.6308]相识别。  [2.x.6309] .因此，利用这一点我们可以给出离散雅各布和残差的表达式。

[1.x.2438]

与第15步相比，我们也可以形成与问题的强表述相对应的非线性函数的Frech{'e}t导数，并在之后将其离散化。然而，最终我们会得到相同的离散方程组。




[1.x.2439] 注意，系统矩阵，实际上是Jacobian，如何取决于前一个牛顿步骤 [2.x.6310] 。因此，我们需要告诉计算系统矩阵的函数关于最后一个牛顿步骤的解决方案。在一个经典的[2.x.6311]函数的实现中，我们将通过使用成员函数[2.x.6312]和[2.x.6313]从装配过程中的最后一个牛顿步骤中收集这些信息，然后[2.x.6314]函数看起来像。

[1.x.2440]



由于我们想在不存储矩阵的情况下解决这个问题，我们需要在使用之前告诉无矩阵算子这些信息。因此在派生类[2.x.6315]中，我们将实现一个名为[2.x.6316]的函数，它将在使用矩阵-向量实现之前处理最后一个牛顿步骤的信息。此外，我们想对线性求解器使用几何多网格（GMG）预处理，所以为了应用多级算子，我们需要将最后一个牛顿步骤也传递给这些算子。这是一项棘手的任务，因为包含最后一个牛顿步骤的向量必须被插值到三角形的所有层面。在代码中，这项任务将由函数[2.x.6317]完成。注意，与之前的案例有一个根本的区别，即我们设置并使用了一个几何多网格预处理程序，我们可以重复使用MGTransferMatrixFree对象来计算所有牛顿步。所以我们在这里可以通过定义一个类变量，使用已经设置好的MGTransferMatrixFree对象[2.x.6318]，并在[2.x.6319]函数中初始化，从而节省一些工作。

[1.x.2441]



评估非线性的函数与评估系数函数的步骤37的函数[2.x.6320]的工作方式基本相同。我们的想法是使用一个FEEvaluation对象来评估牛顿步骤，并将所有单元和所有正交点的表达式存储在一个表中。

[1.x.2442]






[1.x.2443] 正如在步骤37中所说，如果我们选择高阶有限元空间，无矩阵方法会变得更有效率。由于我们想在[2.x.6321]维的单位球上解决问题，最好有一个适当的边界近似来克服收敛问题。出于这个原因，我们使用MappingQGeneric类的等参数方法来恢复平滑边界以及内单元的映射。此外，为了得到一个好的三角形，我们使用了TransfiniteInterpolationManifold。


examples/step-66/doc/results.dox



[1.x.2444]

这个教程步骤的目的是演示用无矩阵框架解决一个非线性PDE。




[1.x.2445] 在两个进程上以释放模式运行程序，通过

[1.x.2446]

在控制台给出了以下输出

[1.x.2447]



我们在下图中展示了二维和三维问题的解决方案。

<div class="twocolumn" style="width: 80%; text-align: center;"> <div> <img src="https://www.dealii.org/images/steps/developer/step-66.solution-2d.png" alt="二维格尔凡德问题的解决方案。" width = "100%"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-66.solution-3d.png" alt="三维格尔凡德问题的解决方案。" width = "100%"> </div> </div>




[1.x.2448] 在上面的程序输出中，我们发现一些关于牛顿迭代的有趣信息。每个细化周期的终端输出显示了牛顿方法的详细诊断，首先显示了牛顿步骤的数量和每一步的残差规范 [2.x.6322] ，牛顿更新的规范 [2.x.6323] ，和CG迭代的数量 [2.x.6324] 。

我们观察到，对于所有的情况，牛顿方法大约在三到四步内收敛，这显示了牛顿方法的全步长的二次收敛 [2.x.6325] 。然而，请注意，对于一个选择不好的初始猜测[2.x.6326]，牛顿方法也会出现二次发散。通常情况下，如果你没有合适的初始猜测，你可以尝试几个阻尼的牛顿步骤，减少步长[2.x.6327]，直到牛顿步骤再次进入二次收敛域。这种阻尼和放松的牛顿步长确实需要一个更复杂的牛顿方法的实现，我们指定给你作为本教程的可能扩展。

此外，我们看到，随着连续的网格细化和DoF数量的增加，CG迭代的数量近乎恒定。这当然是由于几何多棱镜的预处理，而且与其他使用这种方法的教程中的观察结果相似，例如步骤16和步骤37。仅举一例，在三维案例中，经过五次细化后，我们有大约1470万个分布式DoFs的四阶拉格朗日有限元，但CG迭代的次数仍然少于10次。

此外，我们还应用了一个非常有用的优化，应该在此提及。在[2.x.6328]函数中，我们在将持有牛顿更新的向量作为输出向量传递给求解器之前，明确地重置了它。在这种情况下，我们为CG方法使用了一个零的起始值，这比之前的牛顿更新、[2.x.6329]的实际内容在重置之前更合适，因此减少了几步CG迭代的次数。




[1.x.2449] 有几个可能的扩展是关于本代码的小更新fo以及对Gelfand问题更深入的数值调查。

[1.x.2450] 除了步骤15中提到的牛顿迭代的步长控制版本外，我们还可以为牛顿迭代实施一个更灵活的停止标准。例如，我们可以取代残差的固定公差[2.x.6330]，并实现一个具有给定绝对和相对公差的混合误差控制，这样牛顿迭代就会成功，例如。

[1.x.2451]

对于有许多非线性系统需要解决的更高级的应用，例如，在时间依赖性问题的每个时间步骤，事实证明，没有必要在每一个牛顿步骤甚至每个时间步骤中重新设置和组装雅各布系数。相反，在牛顿迭代中可以使用前一个步骤中的现有的Jacobian。然后，只有在例如牛顿迭代收敛过慢的情况下，才会重新建立雅各布系数。这样的想法产生了一个[1.x.2452]。诚然，当使用无矩阵框架时，无论如何都会省略雅各布式的组装，但通过这种方式，可以尝试优化几何多网格预处理的重新组装。请记住，每次来自旧牛顿步骤的解决方案必须分布到所有层面，并且必须重新初始化多重网格预处理器。

[1.x.2453] 在step-37等人的结果部分，无矩阵框架在大量处理器上的并行可扩展性已经得到了非常令人印象深刻的证明。在我们这里考虑的非线性情况下，我们注意到瓶颈之一可能成为无矩阵雅可比算子及其多阶段算子在前一个牛顿步骤中的转移和评估，因为我们需要在每个步骤的所有阶段转移旧的解决方案。[2.x.6331]中的第一个并行可扩展性分析显示，当问题规模足够大时，有相当好的强可扩展性。然而，为了得到可靠的结果，还需要进行更详细的分析。此外，到目前为止，这个问题只用MPI来解决，没有使用线程的共享内存并行化的可能性。因此，对于这个例子，你可以尝试用MPI和线程的混合并行化，如步骤-48中所述。

[1.x.2454] 类似于步骤50和提到的步骤75的可能扩展，你可以说服自己哪个方法更快。

[1.x.2455] 我们可以考虑相应的特征值问题，这被称为布拉图问题。例如，如果我们定义一个固定的特征值 [2.x.6332] ，我们可以计算相应的离散特征函数。你会注意到，牛顿步骤的数量将随着[2.x.6333]的增加而增加。为了减少牛顿步数，你可以使用以下技巧：从某个[2.x.6334]开始，计算特征函数，增加[2.x.6335]，然后使用之前的解作为牛顿迭代的初始猜测。最后你可以画出[2.x.6336]在特征值[2.x.6337]上的正负值。对于进一步增加 [2.x.6338] 你观察到什么？


examples/step-67/doc/intro.dox



[2.x.6339]

[1.x.2456]

[1.x.2457]

[1.x.2458]

本教程程序使用显式时间积分器求解流体力学的欧拉方程，其无矩阵框架应用于空间的高阶非连续Galerkin离散化。关于欧拉系统的细节和另一种隐式方法，我们也参考了第33步教程程序。你可能还想看看第69步，看看解决这些方程的另一种方法。




[1.x.2459]

欧拉方程是一个守恒定律，描述了一个可压缩的无粘性气体的运动。

[1.x.2460]

其中解向量的[2.x.6340]分量为[2.x.6341] 。这里，[2.x.6342] 表示流体密度，[2.x.6343] 表示流体速度，[2.x.6344] 表示气体的能量密度。速度不直接求解，而是用变量[2.x.6345]，即线性动量（因为这是一个守恒量）。

欧拉通量函数是一个[2.x.6346]矩阵，定义为

[1.x.2461]

其中[2.x.6347]为[2.x.6348]身份矩阵，[2.x.6349]为外积；其组成部分分别表示质量、动量和能量通量。右手边的强制力由以下公式给出

[1.x.2462]

其中矢量[2.x.6350]表示重力的方向和大小。然而，它也可以表示作用于流体的任何其他单位质量的外力。例如，想想外部电场对带电粒子所施加的静电力）。

这三块方程，第二块涉及[2.x.6351]成分，描述了质量、动量和能量的守恒。压力不是一个解决方案的变量，但需要通过其他变量的 "闭合关系 "来表达；我们在此选择适合由两个原子组成的分子的气体的关系，在中等温度下，由[2.x.6352]和常数[2.x.6353]给出。




[1.x.2463]

对于空间离散化，我们使用高阶非连续加勒金（DG）离散化，使用的解扩展形式为

[1.x.2464]

这里，[2.x.6354]表示第[2.x.6355]个基函数，以矢量形式写出不同成分的独立形状函数，让[2.x.6356]分别通过密度、动量和能量变量。在这种形式下，空间依赖性包含在形状函数中，时间依赖性包含在未知系数中 [2.x.6357] 。与连续有限元方法中一些形状函数跨越元素边界不同，在DG方法中，形状函数是单个元素的局部，从一个元素到下一个元素是不连续的。从一个单元到其相邻单元的解的连接是由下面规定的数值通量来实现的。这允许一些额外的灵活性，例如，在数值方法中引入方向性，例如，上卷。

DG方法是解决传输特性问题的流行方法，因为它们结合了低分散误差和勉强解决的尺度上的可控耗散。这使得它们在流体动力学领域的模拟中特别有吸引力，因为在这个领域中，需要代表广泛的活动尺度，不充分解决的特征很容易干扰重要的良好解决的特征。此外，高阶DG方法非常适用于现代硬件的正确实施。同时，DG方法也不是万能的。特别是当解出现不连续（冲击）时，就像欧拉方程在某些流态下的典型情况一样，高阶DG方法容易出现振荡解，就像所有不使用通量或坡度限制器的高阶方法一样。这是[1.x.2465]的结果，即任何线性的总变差（TVD）方案（如基本的DG离散化）最多只能达到一阶精度。换句话说，由于DG方法的目标是高阶精度，因此它们不可能对出现冲击的解进行TVD。尽管有些人声称DG方法中的数值通量可以控制耗散，但除非问题中的[1.x.2466]冲击与单元边界对齐，否则这一点的价值有限。任何穿过单元内部的冲击都会因为高阶多项式而再次产生振荡分量。在有限元和DG界，存在许多不同的方法来处理冲击，例如在有问题的单元上引入人工扩散（使用基于解的模态分解等的有问题单元指标），在子网格上转换为耗散性低阶有限体积方法，或者增加一些限制程序。考虑到这种情况下的大量可能性，再加上相当大的实施努力，我们在这里不考虑带有明显冲击的欧拉方程系统，而是集中在带有波浪状现象的亚音速流动系统。对于一个能很好地处理冲击的方法（但每个未知数的成本较高），我们可以参考step-69教程程序。

对于DG公式的推导，我们将欧拉方程与测试函数[2.x.6358]相乘，并对单个单元进行积分[2.x.6359]，从而得到

[1.x.2467]



然后我们对第二项进行分项积分，将分歧从解槽移到测试函数槽，并产生一个元素边界上的积分。

[1.x.2468]

在表面积分中，我们用术语[2.x.6361]代替了术语[2.x.6360]，即数值通量。数字通量的作用是连接相邻元素上的解，并弱化解的连续性。这保证了PDE的全局耦合反映在离散化中，尽管单元上有独立的基函数。通过将数值通量定义为来自内部面两侧的解的函数[2.x.6362]和[2.x.6364]，包括与邻居的连接。我们要求的一个基本属性是，数值通量需要是[1.x.2469]。也就是说，我们希望所有的信息（即质量、动量和能量）在一个面上离开一个单元时，都能完整地进入邻近的单元，反之亦然。这可以表示为[2.x.6365]，也就是说，数值通量从任何一边都评估为相同的结果。结合数值通量与所考虑的面的单位外法向量相乘的事实，即从两边指向相反的方向，我们看到守恒被满足了。数值通量的另一个观点是作为一个单值的中间状态，从两边微弱地连接解决方案。

有大量的数值通量函数可用，也称为黎曼解算器。对于欧拉方程，存在所谓的精确黎曼求解器--意味着来自双方的状态以一种与欧拉方程沿线不连续的方式结合起来--以及近似黎曼求解器，它违反了一些物理特性，并依靠其他机制来使方案总体上准确。近似黎曼求解器的优点是计算起来比较便宜。大多数通量函数都起源于有限体积界，它们类似于单元（称为体积）内的多项式0度的DG方法。由于欧拉算子[2.x.6366]的体积积分对于恒定解和检验函数会消失，所以数值通量必须完全代表物理算子，这也解释了为什么该界有大量的研究。对于DG方法，一致性是由单元内的高阶多项式保证的，这使得数值通量不再是一个问题，通常只影响收敛率，例如，对于度数为[2.x.6367]的多项式，解是否收敛为[2.x.6368]或[2.x.6369]的准则。因此，数值通量可以被看作是一种机制，用于选择更有利的耗散/分散特性或关于离散化和线性化算子的极值特征，这影响到显式时间积分器中最大的可接受的时间步长。

在这个教程程序中，我们实现了两种通量的变体，可以通过程序中的开关来控制（当然，要使它们成为通过输入文件控制的运行时参数也很容易）。第一个通量是本地的Lax--Friedrichs通量

[1.x.2470]



在Lax--Friedrichs通量的原始定义中，使用了一个系数[2.x.6372]（对应于信息在界面两边移动的最大速度），说明两个状态之间的差异，[2.x.6373]被欧拉通量中的最大特征值惩罚，即[2.x.6374] ，其中[2.x.6375] 是音速。在下面的实现中，我们对惩罚项进行了一些修改，因为无论如何惩罚都是近似的。我们使用

[1.x.2471]

额外的因子[2.x.6376]降低了惩罚强度（这导致特征值的负实部减少，从而增加了可接受的时间步长）。使用和内的平方允许我们减少昂贵的平方根操作的数量，对于原始的Lax--Friedrichs定义是4个，现在只需要一个。这种简化导致参数[2.x.6377]的减少最多为2倍，因为[2.x.6378]，最后一个不等式来自杨氏不等式。

第二个数值通量是由Harten、Lax和van Leer提出的，称为HLL通量。它考虑到欧拉方程的不同传播方向，取决于声速。它利用一些中间状态 [2.x.6379] 和 [2.x.6380] 来定义两个分支 [2.x.6381] 和 [2.x.6382] 。从这些分支中，人们再定义出通量

[1.x.2472]

关于中间状态的定义 [2.x.6383] 和 [2.x.6384] ，已经提出了几个变种。最初提出的变体使用密度平均的速度定义， [2.x.6385] 。由于我们考虑的是没有冲击的欧拉方程，因此在本教程程序中，我们简单地使用算术平均值，[2.x.6386]和[2.x.6387]，与[2.x.6388]，而把其他变体留给可能的扩展。我们还注意到，HLL通量在文献中被扩展为所谓的HLLC通量，其中C代表表示接触不连续的能力。

在没有邻接状态[2.x.6389]的边界上，通常的做法是从边界条件中推导出合适的外部值（详见关于DG方法的一般文献）。在这个教程程序中，我们考虑三种类型的边界条件，即[1.x.2473]，其中所有分量都是规定的。

[1.x.2474]

[1.x.2475]，在这里我们不规定外部解，因为流场要离开域，而使用内部值；我们仍然需要规定能量，因为欧拉通量中还有一个传入特性。

[1.x.2476]

和[1.x.2477]，它们描述了无渗透配置。

[1.x.2478]



解的多项式展开最后被插入到弱形式，测试函数被基函数取代。这就得到了一个空间上离散、时间上连续的非线性系统，其未知系数的数量有限 [2.x.6390] , [2.x.6391] 。关于DG方法中多项式度数的选择，截至2019年，文献中并没有关于什么多项式度数最有效的共识，决定取决于问题。高阶多项式可以确保更好的收敛率，因此对于中等到高精确度要求的[1.x.2479]解来说，高阶多项式更有优势。同时，自由度所在的体积与表面的比率，随着高阶的增加而增加，这使得数值通量的影响变弱，通常会减少耗散。然而，在大多数情况下，解决方案是不平滑的，至少与可以承受的分辨率相比是不平滑的。例如，在不可压缩流体力学、可压缩流体力学以及与之相关的波浪传播课题中都是如此。在这个前渐进制度中，误差大约与数值分辨率成正比，而其他因素，如分散误差或耗散行为变得更加重要。非常高阶的方法往往被排除在外，因为它们带有根据未知数衡量的更多限制性的CFL条件，而且当涉及到表示复杂几何形状时，它们也不那么灵活。因此，2到6的多项式度数在实践中是最受欢迎的，例如见[2.x.6392]中的效率评估和其中引用的参考文献。

[1.x.2480]

为了进行时间离散化，我们稍微重新排列了弱的形式，并在所有单元上求和。

[1.x.2481]

其中[2.x.6393]贯穿了从1到[2.x.6394]的所有基函数。

我们现在用[2.x.6395]表示质量矩阵，其条目为[2.x.6396]，并用

[1.x.2482]

给定一个与全局未知数矢量和使用中的有限元相关的函数[2.x.6397]，对欧拉算子的右手边进行评估的算子。这个函数[2.x.6398]是明确随时间变化的，因为在边界上评估的数值通量将涉及边界某些部分的随时间变化的数据[2.x.6399]、[2.x.6400]和[2.x.6401]，取决于边界条件的分配。有了这个符号，我们可以把空间上的离散、时间上的连续系统紧凑地写为

[1.x.2483]

其中我们冒昧地用[2.x.6402]表示全局解矢量（除了相应的有限元函数外）。等价地，上述系统的形式为

[1.x.2484]



对于用高阶非连续Galerkin方法离散的双曲系统，该系统的显式时间积分非常流行。这是由于质量矩阵[2.x.6403]是块对角线的（每个块只对应于定义在同一单元上的同类变量），因此很容易倒置。在每个时间步长--或Runge-Kutta方案的阶段--我们只需要用给定的数据评估一次微分算子，然后应用质量矩阵的逆。另一方面，对于隐式时间步进，人们首先必须将方程线性化，然后迭代解决线性系统，这涉及到几个残差评估和至少十几个线性化算子的应用，正如在步骤33教程程序中所展示的那样。

当然，显式时间步长的简单性是有代价的，即由于所谓的Courant-Friedrichs-Lewy（CFL）条件而产生的条件稳定性。它指出，时间步长不能大于离散微分算子的最快信息传播速度。用更现代的术语来说，传播速度对应于离散算子的最大特征值，反过来又取决于网格大小、多项式程度[2.x.6404]和欧拉算子的物理学，即[2.x.6405]相对于[2.x.6406]的线性化的特征值。在这个程序中，我们设定的时间步长如下。

[1.x.2485]



在所有正交点和所有单元中取最大值。无量纲数[2.x.6407]表示库朗数，可以选择最大稳定数[2.x.6408]，其值取决于所选择的时间步进方法及其稳定性。用于多项式缩放的幂[2.x.6409]是启发式的，代表1到8之间的多项式度数最接近，例如，见[2.x.6410]。在更高的度数限制下，[2.x.6411]，[2.x.6412]的比例更准确，与通常用于内部惩罚方法的逆向估计有关。关于公式中使用的[1.x.2486]网格尺寸[2.x.6413]和[2.x.6414]，我们注意到对流传输是定向的。因此，一个合适的比例是使用速度方向的元素长度 [2.x.6415] 。下面的代码从参考单元到实际单元的雅各布系数的倒数得出这个比例，也就是说，我们近似于 [2.x.6416] 。相反，声波具有各向同性的特点，这就是为什么我们使用最小的特征尺寸，由[2.x.6417]的最小奇异值代表，用于声学缩放 [2.x.6418] 。最后，我们需要增加对流和声学限制，因为欧拉方程可以以速度传输信息 [2.x.6419] 。

在这个教程程序中，我们使用[1.x.2487]的一个特定变体，一般来说，它使用以下更新程序，从时间[2.x.6421]的状态[2.x.6420]到新时间[2.x.6422]的[2.x.6423] 。

[1.x.2488]

在[2.x.6424]、[2.x.6425]的阶段性方案中，向量[2.x.6426]是算子在某个中间状态下的评价，并通过某种线性组合用于定义阶段性结束值[2.x.6427]。该方案中的标量系数[2.x.6428]、[2.x.6429]和[2.x.6430]的定义，使得高阶方案满足某些条件，最基本的是[2.x.6431] 。参数通常以所谓的[1.x.2489]的形式收集，它收集了定义该方案的所有系数。对于一个五级方案，它看起来是这样的。

[1.x.2490]



在这个教程程序中，我们使用显式Runge--Kutta方法的一个子集，即所谓的低存储Runge--Kutta方法（LSRK），它假定了系数的额外结构。在参考文献[2.x.6432]所使用的变体中，假设使用的是Butcher tableaus的形式

[1.x.2491]

有了这样的定义，对 [2.x.6433] 的更新与中间值 [2.x.6434] 的信息共享存储。从[2.x.6435]和[2.x.6436]开始，每个[2.x.6437]阶段的更新都简化为

[1.x.2492]

除了连续更新的向量[2.x.6438]，这个方案只需要两个辅助向量，即保存微分算子的评估的向量[2.x.6439]，以及保存微分算子应用的右手边的向量[2.x.6440]。在后续阶段 [2.x.6441] ，值 [2.x.6442] 和 [2.x.6443] 可以使用相同的存储。

低存储量变体的主要优点是一方面减少了内存消耗（如果必须在内存中装入非常多的未知数，持有所有的[2.x.6444]来计算随后的更新，对于[2.x.6445]来说已经是一个极限，在5到8之间--记得我们使用的是显式方案，所以我们不需要存储任何通常比几个向量大很多的矩阵），另一方面是减少内存访问。在这个程序中，我们对后一个方面特别感兴趣。由于运算符评估的成本只是简单地从内存中流转输入和输出向量的一小部分，我们必须考虑向量更新的成本，而低存储的变体可以提供传统显式Runge--Kutta方法两倍的吞吐量，原因就在于此，例如，见[2.x.6446]中的分析。

除了参考文献[2.x.6447]中的三阶、四阶和五阶精度的三个变体外，我们还使用了一个四阶精度的七级变体，该变体是为声学设置而优化的[2.x.6448] 。声学问题是欧拉方程的亚音速制度的有趣方面之一，其中可压缩性导致了声波的传播；通常，人们使用围绕背景状态的线性化欧拉方程的进一步简化，或围绕固定框架的声波方程。




[1.x.2493]

这个程序中使用的主要成分是我们用来评估算子 [2.x.6449] 和反质量矩阵 [2.x.6450] 的快速无矩阵技术。实际上，[1.x.2494]这个术语有点名不副实，因为我们是在处理一个非线性算子，并没有将反过来可以用矩阵表示的算子线性化。然而，作为稀疏矩阵-向量乘积的替代品，积分的快速评估已经变得很流行，如步骤-37和步骤-59所示，为此我们在交易二中创造了这个基础设施[1.x.2495]。此外，反质量矩阵确实是以无矩阵的方式应用的，详见下文。

无矩阵基础设施使我们能够快速评估弱形式的积分。其成分是将解系数快速插值为正交点的值和导数，在正交点进行逐点运算（在这里我们实现了上述的微分算子），以及与所有测试函数相乘和对正交点求和。第一和第三部分利用了和因子化，并在步骤37的单元积分教程和步骤59的面积分教程中进行了广泛的讨论。唯一的区别是，我们现在处理的是一个[2.x.6451]分量的系统，而不是以前教程程序中的标量系统。在代码中，所有的变化是FEEvaluation和FEFaceEvaluation类的一个模板参数，即设置分量的数量。对向量的访问和以前一样，都由评价器透明地处理。我们还注意到，下面的代码中选择的带有单一评价器的变体并不是唯一的选择--我们也可以为单独的组件[2.x.6452]、[2.x.6453]和[2.x.6454]使用单独的评价器；鉴于我们对所有组件的处理是类似的（也反映在我们把方程作为一个矢量系统的方式），这里会更复杂。和以前一样，FEEvaluation类通过结合对几个单元（和面）的操作来提供显式的矢量化，涉及的数据类型称为VectorizedArray。由于这种类型的算术运算都是重载的，所以我们不必为它费心，除了通过函数接口对函数进行评估，我们需要同时为几个正交点的位置提供特殊的[1.x.2496]评估。

这个程序中更大的变化是在正交点的操作。在这里，多分量评估器为我们提供了之前没有讨论过的返回类型。[2.x.6455]将为第37步的拉普拉斯返回一个标量（更准确地说，由于跨单元的矢量化，是一个VectorizedArray类型），现在它返回的类型是`Tensor<1,dim+2,VectorizedArray<Number>'。同样，梯度类型现在是`张量<1,dim+2,张量<1,dim,矢量化数组<Number>>`，其中外部张量收集了欧拉系统的`dim+2'分量，内部张量是各个方向的偏导数。例如，欧拉系统的通量[2.x.6456]就属于这种类型。为了减少我们为拼出这些类型而写的代码量，我们尽可能使用C++的`自动'关键字。

从实施的角度来看，非线性并不是一个很大的困难。它是在我们表达欧拉弱形式的条款时自然引入的，例如以动量条款的形式 [2.x.6457] 。为了得到这个表达式，我们首先从动量变量 [2.x.6459] 推导出速度 [2.x.6458] 。鉴于[2.x.6460]和[2.x.6462]一样被表示为[2.x.6461]度的多项式，速度[2.x.6463]是参考坐标[2.x.6464]的一个有理表达。当我们进行乘法[2.x.6465]时，我们得到一个表达式，它是两个多项式的比值，分子中的多项式程度[2.x.6466]和分母中的多项式程度[2.x.6467]。结合测试函数的梯度，分子中的积分度为[2.x.6468]，分母中的积分度为[2.x.6469]，对于仿生单元，即平行四边形/平行四边形，已经有了积分。对于弧形单元，当积分乘以映射的雅各布系数时，会出现额外的多项式和有理表达式。在这一点上，人们通常需要放弃坚持精确的积分，而采取高斯（更确切地说，高斯-勒格伦德）正交提供的任何精度。这时的情况与拉普拉斯方程的情况类似，积分项包含非affince单元上的有理表达式，也只能进行近似积分。由于这些公式只对多项式进行精确积分，我们不得不以积分错误的形式忍受[1.x.2497]的影响。

虽然对于椭圆问题来说，不精确的积分通常是可以容忍的，但对于双曲问题来说，不精确的积分会引起一些令人头痛的效应，这种效应称为[1.x.2498]。这个术语来自于信号处理，表达了不适当的、过于粗糙的采样情况。就正交而言，不适当的采样意味着我们使用的正交点与准确采样变系数积分所需的点相比太少。在DG文献中已经表明，别离误差会在[1.x.2499]解析模拟的数值解中引入非物理性的振荡。别名主要影响到粗略的分辨率--而采用相同方案的更细的网格则工作良好--这一事实并不令人惊讶，因为分辨率高的模拟往往在一个单元的长度尺度上是平滑的（即，它们在较高的多项式程度上有小的系数，由于正交点太少而被遗漏，而在较低的多项式程度上的主要解贡献仍然被很好地捕获--这只是泰勒定理的一个结果）。为了解决这个问题，DG文献中提出了各种方法。一种技术是过滤，它可以抑制与高次多项式度数有关的解成分。由于所选择的节点基不是分层的，这就意味着要从节点基转化为分层基（例如，基于Legendre多项式的模态基），其中单元内的贡献是按多项式程度划分的。在这个基础上，我们可以将与高度数相关的求解系数乘以一个小数，保持低度数不变（以避免破坏一致性），然后再转换回节点基础。然而，过滤器会降低该方法的准确性。另一个在某种意义上更简单的策略是使用更多的正交点来更准确地捕捉非线性项。每个坐标方向使用超过[2.x.6470]个正交点有时被称为过度积分或一致积分。后者在不可压缩的Navier-Stokes方程中最为常见，其中[2.x.6471]非线性导致[2.x.6472]度的多项式积分（当同时考虑测试函数时），只要元素的几何形状是仿生的，每个方向的[2.x.6473]正交点就可以精确积分。在非多项式积分的欧拉方程的背景下，选择就不那么明确了。根据各种变量的变化，[2.x.6474]或[2.x.6475]点（分别精确积分度为[2.x.6476]或[2.x.6477]的多项式）都很常见。

为了反映程序中正交选择的这种可变性，我们把正交点的数量作为一个变量来指定，就像多项式的度数一样，并注意到人们会根据流量配置做出不同的选择。默认选择是[2.x.6478]点--比最小可能的[2.x.6479]点多一点。FEEvaluation和FEFaceEvaluation类允许通过模板参数无缝地改变点的数量，这样程序就不会因此而变得更复杂。




[1.x.2500]

最后一个要素是反质量矩阵的评估 [2.x.6480] 。在具有显式时间积分的DG方法中，质量矩阵是块状对角线，因此很容易反转--人们只需要反转对角线块。然而，考虑到无矩阵的积分评估在成本上更接近于只访问向量，即使应用块对角矩阵（例如通过LU因子数组）也会比评估[2.x.6481]贵几倍，仅仅是因为对于高阶有限元来说，仅仅存储和加载大小为`dofs_per_cell`x`dofs_per_cell`的矩阵是昂贵的。由于这显然是不可取的，部分社区已经转移到质量矩阵是对角线的基础，例如[1.x.2501]正交Legendre基础，使用分层多项式或高斯四分法点上的拉格朗日多项式（这只是利用Legendre信息的另一种方式）。虽然对角线属性对于变形元素来说是失效的，但通过采取对角线质量矩阵而忽略其余部分（质量包络的变种，尽管不是步骤-48中利用的具有额外积分误差的变种）所产生的误差已被证明不会改变离散化精度。高斯正交点中的拉格朗日基础有时也被称为同位设置，因为多项式的结点与正交点重合（="同位"），避免了一些内插操作。鉴于我们想在[2.x.6482]中对非线性项使用更多的正交点，然而，拼合属性就失去了。(更确切地说，在改变基础后，它仍然用于FEEvaluation和FEFaceEvaluation，见无矩阵论文 [2.x.6483] 。)

在这个教程程序中，我们使用拼合思想来应用反质量矩阵，但有一个小的转折。与其在高斯四分法的点上通过拉格朗日多项式使用配位，我们更倾向于在高斯-洛巴托点上使用传统的拉格朗日基础，因为那些使面积分的评估变得便宜。这是因为对于高斯-洛巴托点来说，一些节点点位于单元格的面上，而且不难证明，在任何给定的面上，唯一具有非零值的形状函数正是其节点点实际上位于该面上的那些。当然，我们也可以像步骤48那样使用高斯-洛巴托正交（有一些额外的积分误差），但我们不想牺牲精度，因为这些正交公式通常比一般的高斯正交公式的阶数低。相反，我们使用参考文献[2.x.6484]中描述的一个想法，其中提出为了应用反质量矩阵而改变基础。让我们用[2.x.6485]表示在正交点评价的形状函数矩阵，形状函数在矩阵的行中，正交点在列中。那么，单元格[2.x.6486]上的质量矩阵由以下公式给出

[1.x.2502]

这里，[2.x.6487]是以雅各布系数乘以正交权重（JxW）的行列式作为条目的对角矩阵。矩阵[2.x.6488]被构造为一维矩阵的克朗克积（张量积），例如，在三维中为

[1.x.2503]

这是基函数是一维形状函数的张量积，正交公式是一维正交公式的张量积的结果。对于多项式的数量等于正交点的数量的情况，[2.x.6489]中的所有矩阵都是方形的，同样，克朗克积中的[2.x.6490]的成分也是方形的。因此，人们可以对每个矩阵进行反转，形成整体的逆。

[1.x.2504]

这个公式的结构与用和因子化技术对积分进行正向评价的步骤完全相同（即交易.II的FEEvaluation和MatrixFree框架）。因此，我们可以利用相同的代码路径，采用不同的插值矩阵，[2.x.6491]而不是[2.x.6492] 。

类[2.x.6493]实现了这个操作。它从有限元中包含的基（在这里是FE_DGQ）改变为高斯正交点中的拉格朗日基。在这里，可以评估对角线质量矩阵的逆值，这只是`JxW`因子的逆值（即正交权重乘以从参考坐标到实坐标的雅各布系数）。一旦这样做了，我们就可以变回标准的节点高斯-洛巴托基础。

这种应用反质量矩阵的特殊方式的优点是成本类似于质量矩阵的正向应用，这比用超积分和面积分评估空间算子[2.x.6494]更便宜。(我们将在[1.x.2505]中用详细的时间信息证明这一点)。事实上，它是如此便宜，以至于在大多数现代架构上，它被读取源向量、读取对角线和写入目的向量的带宽所限制。用于结果部分的硬件可以使计算的速度至少比从内存流向量的速度快一倍。




[1.x.2506]

在这个教程程序中，我们实现了两个测试案例。第一个案例是限于两个空间维度的收敛性测试。它运行一个所谓的等熵涡旋，它通过一个背景流场进行传输。第二个案例使用了一个更令人兴奋的设置。我们从一个浸在通道中的圆柱体开始，使用[2.x.6495]函数。在这里，我们强加一个马赫数为[2.x.6496]的亚音速初始场，在[2.x.6497]方向上速度不变。在顶壁和底壁以及圆柱体上，我们施加了一个无穿透（即切向流动）的条件。与初始条件相比，这种设置迫使气流重新定向，从而导致大的声波从圆柱体上传播出去。在上游方向，波的传播速度较慢（因为它必须逆着迎面而来的气体移动），包括密度和压力的不连续。在下游方向，由于声音的传播和流体的流动方向相同，传输速度较快，这在一定程度上抹去了不连续性。一旦声波碰到上下壁，声音就会被反射回来，形成一些漂亮的形状，如下图[1.x.2507]所示。


examples/step-67/doc/results.dox



[1.x.2508]

[1.x.2509]

在一台有40个进程的机器上以默认设置运行该程序，会产生以下输出。

[1.x.2510]



程序输出显示，所有的误差都很小。这是由于我们使用了一个相对较细的[2.x.6498]单元的网格，用5度的多项式来求得一个平滑的解决方案。一个有趣的模式显示在时间步长上：虽然在时间5之前是0.0069，但在后来的时间里增加到0.0096。在时间5和6.5之间，一旦在声速之上有一些运动的旋涡（因此传播速度更快）离开计算域，步长就会增加。在这之后，气流只是在同一方向上是均匀的，与之前均匀速度被漩涡覆盖的状态相比，气体的最大速度有所下降。我们的时间步长公式认识到了这种影响。

最后一块输出显示了关于程序各个部分时间的详细信息；它通过显示最快和最慢的处理器所花费的时间以及平均时间将其分解开来--这在非常大的计算中通常很有用，可以发现是否有处理器持续过热（并因此节制其时钟速度）或因其他原因持续过慢。总结显示，在1.02秒内完成了1283个时间步骤（看所有MPI进程的平均时间），而11个文件的输出又花了0.96秒。将每个时间步数和五个Runge--Kutta阶段分解开来，每次评估的计算时间为0.16毫秒。这种高性能是无矩阵评估器的典型表现，也是显式时间积分对隐式求解器非常有竞争力的原因，特别是对于大规模模拟。程序运行结束时的计算时间细分显示，[2.x.6499]中的积分评估贡献了大约0.92秒，反质量矩阵的应用贡献了0.06秒。此外，对时间步长计算的运输速度的估计又贡献了0.05秒的计算时间。

如果我们再使用三个级别的全局细化和总共940万个DoF，最终的统计数据如下（对于修改后的Lax--Friedrichs通量，[2.x.6500] ，和同一系统的40个核心的双插槽Intel Xeon Gold 6230）。

[1.x.2511]



每个时间步长，求解器现在需要0.02秒，大约是147k未知数的小问题的25倍。鉴于该问题涉及64倍的未知数，计算时间的增加并不令人惊讶。由于我们也做了8倍的时间步数，计算时间在理论上应该增加512倍。实际增加的时间是205秒/1.02秒=202。这是因为由于通信开销的原因，小问题的规模不能充分利用40个核心。如果我们研究一下每个时间步长所做操作的细节，这一点就很清楚了。带有近邻通信的微分算子[2.x.6501]的评估时间从0.92秒到127秒，也就是说，它增加了138倍。另一方面，应用反质量矩阵和向量更新的成本，完全不需要在MPI进程之间通信，增加了1195倍。这一增长超过了理论上的512倍，因为对于较大的尺寸，操作受限于RAM内存的带宽，而对于较小的尺寸，所有的矢量都适合于CPU的缓存。数字显示，尽管使用了低存储量的Runge-Kutta积分器和合并矢量操作，但质量矩阵评估和矢量更新部分几乎消耗了Runge-Kutta阶段所花费的40%的时间。而且尽管对[2.x.6502]算子使用了过度积分。对于更简单的微分算子和更昂贵的时间积分器，花费在质量矩阵和矢量更新部分的比例也可以达到70%。如果我们以每秒处理的DoFs和Runge--Kutta阶段计算一个吞吐量数字，我们得到[1.x.2512]这个吞吐量数字非常高，因为简单地将一个向量复制到另一个向量的运行速度只有大约10,000 MDoFs/s。

如果我们进入下一个更大的规模，有3770万个DoF，总的模拟时间是2196秒，其中1978秒用于时间步进。L_h算子的运行时间增加了9.3倍（1179秒对127秒），反质量矩阵和向量更新增加了10.3倍（797秒对77.5秒）。运行时间非最佳增长的原因可以追溯到给定硬件上的缓存效应（有40MB的二级缓存和55MB的三级缓存）。虽然不是所有的相关数据都适合940万DoF的缓存（一个向量需要75MB，我们有三个向量加上MatrixFree中的一些额外数据），但还是有能力满足一个半向量的需求。考虑到现代的缓存比天真的最近使用的策略更复杂（在这种情况下，我们几乎没有重复使用，因为数据是以类似流的方式使用的），我们可以假设，在940万DoFs的情况下，确实有相当一部分数据可以从缓存中交付。在更大的情况下，即使有最佳的缓存，也只有不到10%的数据可以放入缓存中，而且会有相关的性能损失。




[1.x.2513]

对于修改后的Lax--Friedrichs通量和测量动量变量的误差，我们得到以下收敛表（密度和能量变量的速率非常相似）。

[2.x.6503]

如果我们改用Harten-Lax-van Leer通量，结果如下。  [2.x.6504]

表中显示，我们对两种数值通量都得到了最佳的[2.x.6505]收敛率。对于[2.x.6506]的Lax--Friedrichs通量，误差略小，但对于[2.x.6507]的情况则相反；在任何情况下，这个测试案例的差异都相对较小。

对于[2.x.6508]，我们在最细的网格上用两种通量达到了[2.x.6509]的舍入精度。还要注意的是，误差是绝对的，域长为[2.x.6510]，所以相对误差低于[2.x.6511]。HLL通量对于最高度数来说要好一些，这是由于Lax--Friedrichs通量的轻微不准确造成的。Lax--Friedrichs通量对离开域的解设置了一个Dirichlet条件，这导致了一个小的人工反射，这在Lax--Friedrichs通量中被凸显出来。除此之外，我们看到数值通量的影响很小，因为元素内部的多项式部分是引起反射的主要动力。当试图用高阶DG设置来接近更具挑战性的设置时，通量的有限影响也会产生影响。以第33步的参数和网格为例，一旦高质部分接近边界，我们就会在两种通量下得到振荡（这反过来会使密度为负值，并使解决方案爆炸），这与低阶有限体积情况不同（[2.x.6512]）。因此，任何导致溶液中出现冲击的情况都需要某种形式的限制性或人工耗散。对于另一种选择，请参见step-69教程程序。




[1.x.2520]

对于渠道中圆柱体周围的流动测试案例，我们需要将第一行代码改为

[1.x.2521]

这个测试案例从一个马赫数为0.31的恒定速度和恒定的初始密度的背景场开始；气流必须绕过一个圆柱体形式的障碍物。由于我们对圆柱体壁施加了一个无穿透的条件，最初迎面撞上圆柱体的气流必须重新排列，这就产生了一个大的声波。下面的图片显示了二维情况下5级全局细化时0.1、0.25、0.5和1.0（左上至右下）的压力，使用了102,400个单元，多项式程度为5，所有4个求解变量的自由度为1470万。我们清楚地看到，在时间0.1的第一个快照中，不连续现象在上游方向传播缓慢，在下游方向传播较快。在时间0.25，声波已经到达顶部和底部的墙壁并反射到内部。从下壁和上壁反射波的不同距离，我们可以看到以[2.x.6513]为代表的Sch&auml;fer-Turek试验案例的轻微不对称性，圆柱体上方的空间与下方相比要多一些。在后来的时间里，画面更加混乱，到处都是许多声波。

[2.x.6514]

下一张图片显示了在相同分辨率下，从通道入口向出口看，时间为1.0时的压力仰角图--在这里，我们可以看到大量的反射。在该图中，可以看到两种类型的波。较大振幅的波对应于初始不连续物撞击墙壁时发生的各种反射，而与元素大小相似的小振幅波则对应于数值伪影。它们起源于方案的有限分辨率，并在不连续面通过高阶多项式的元素时出现。这种效应可以通过提高分辨率来治愈。除了这种效应之外，丰富的波浪结构是高阶DG方法的传输精度的结果。

[2.x.6515]

通过2级全局细化，1,600个单元，网格及其在40个MPI进程上的划分情况如下。

[2.x.6516]

当我们在40个核心上运行具有4级全局细化的代码时，我们得到以下输出。

[1.x.2522]



这里显示的各种数量的规范是对背景场（即初始条件）的偏差[2.x.6517]、[2.x.6518]和[2.x.6519]。运行时间的分布总体上与之前的测试案例相似。唯一略有不同的是，与反质量矩阵和矢量更新相比，在[2.x.6520]中花费的时间比例较大。这是因为几何体是变形的，无矩阵框架需要从内存中加载额外的几何体阵列，这些阵列在仿生网格的情况下是被压缩的。

将全局细化的数量增加到5，输出就变成了。

[1.x.2523]



对性能的影响与分析性测试案例相似--理论上，计算时间应该增加8倍，但我们实际上看到时间步骤增加了11倍（219.5秒对2450秒）。这可以追溯到缓存，小的情况下大多适合缓存。一个有趣的效果，是典型的本地通信（积分[2.x.6521]）和全局通信（计算运输速度）混合的程序，有一些负载不平衡，可以通过查看分别遇到不同阶段的最小和最大时间的MPI等级来观察。级别0报告了 "rk时间步进总数 "部分的最快吞吐量。同时，对于 "计算传输速度 "部分，它似乎是最慢的，几乎比平均水平慢了2倍，与较快的等级相比几乎是4倍。由于后者涉及到全局通信，我们可以将这部分的缓慢归因于本地Runge--Kutta阶段在这个等级上推进得更快，需要等到其他处理器跟上。在这一点上，人们可以怀疑这种不平衡的原因。在所有的MPI进程中，单元格的数量几乎是相同的。然而，无矩阵框架在位于通道出口处的仿生和笛卡尔单元上速度更快，较低的MPI等级被分配到这些单元。另一方面，报告Runga--Kutta阶段最高运行时间的等级32拥有靠近圆柱体的弯曲单元，对于这些单元不可能有数据压缩。为了提高吞吐量，我们可以在划分[2.x.6522]对象时给不同的单元类型分配不同的权重，甚至可以测量几个时间步骤的运行时间，然后尝试重新平衡。

对于1470万DoFs的测试案例，在346000个Runge--Kutta阶段中，每个Runge--Kutta阶段的吞吐量可以计算到2085 MDoFs/s，比上面报告的2360 MDoFs/s的笛卡尔网格吞吐量略慢。

最后，如果我们增加一个额外的细化，我们会记录以下输出。

[1.x.2524]



rk时间步数总数 "部分对应的是2010 MDoFs/s的吞吐量。执行139k时间步长的总体运行时间是20k秒（5.7小时）或每秒7个时间步长--对于有近6000万个未知数来说还不错。通过在计算中添加更多的内核，可以实现更多的吞吐量。




[1.x.2525]

将通道测试案例切换到3D，并进行3次全局细化，输出结果是

[1.x.2526]



物理原理与二维情况类似，由于引力的作用，在Z方向有轻微的运动。在这种情况下，每个Runge-Kutta阶段的吞吐量为

[1.x.2527]



吞吐量低于二维，因为[2.x.6523]项的计算更加昂贵。这是由于 "度+2 "点的过度积分和较大比例的面积分（更差的体积-表面比率），以及更昂贵的通量计算。如果我们只考虑反质量矩阵和矢量更新部分，我们记录到等熵涡旋的二维案例的吞吐量为4857 MDoFs/s，有3770万个未知数，而三维案例的运行速度为4535 MDoFs/s。性能是相似的，因为这两种情况实际上都受到内存带宽的限制。

如果我们进行四级全局细化，我们需要增加进程的数量以在内存中容纳所有的东西--在这种情况下，计算需要大约350GB的RAM内存。另外，通过增加额外的资源，完成35k个时间步骤所需的时间也变得更容易忍受。因此，我们使用了6个节点，每个节点有40个核心，从而使计算有240个MPI进程。

[1.x.2528]

这个模拟有近20亿个未知数--确实是一个相当大的计算量，而每个时间步长仍然只需要大约1.5秒。




[1.x.2529]

这里介绍的代码可以直接扩展到自适应网格，给定适当的指标来设置细化标志。在声波方程的背景下，类似求解器的大规模适应性已经由[1.x.2530]实现。然而，在目前的情况下，自适应性的好处往往只限于靠近声波起源的早期时间和效果，因为波最终会反射和衍射。这就导致了到处都是陡峭的梯度，类似于湍流，以及或多或少的全局细化网格。

我们在结果部分没有讨论的另一个话题是不同时间积分方案的比较。该程序提供了四种低存储量的Runga--Kutta积分器的变体，每一种都有轻微不同的精度和稳定性行为。在这里实现的方案中，高阶方案提供了额外的精度，但在违反CFL条件之前，每级步长的效率略低。一个有趣的扩展是将这里提出的低存储变体与标准的Runge--Kutta积分器进行比较，或者使用与质量矩阵运算分开运行的矢量运算，并比较性能。




[1.x.2531]

正如介绍中提到的，本程序中采用的修改的Lax--Friedrichs通量和HLL通量只是文献中关于欧拉方程的大量数值通量中的两个变种。一个例子是HLLC通量（Harten-Lax-van Leer-Contact）通量，它增加了HLL通量或Roe通量中缺少的稀疏波效应。正如介绍中提到的，数值通量对高阶DG方案的影响是有争议的（与低阶离散的情况不同）。

为了提高求解器的稳定性，一个相关的改进是也要考虑空间积分项。上面使用的相当幼稚的实现方式的一个缺点是，原始欧拉方程的能量守恒（在没有冲击的情况下）只适用于离散化误差。如果解决方案的分辨率不足，离散化误差会引起数值能量的增加，并最终导致离散化的不稳定。这是因为欧拉方程中的项的不精确数值积分，其中包含有理非线性和弯曲单元的高阶内容。摆脱这种困境的方法是所谓的倾斜对称公式，见[2.x.6524]的一个简单变体。倾斜对称意味着在弱式中切换解[2.x.6525]和检验函数[2.x.6526]的作用，除了一些边界项外，产生原始量的精确负值。在离散设置中，挑战在于当积分只被近似计算时也要保持这种倾斜对称性（在连续情况下，倾斜对称性是部分积分的结果）。偏斜对称的数值方案平衡了保守形式的空间导数 [2.x.6527] 和对流形式的贡献 [2.x.6528] ，对于某些 [2.x.6529] 。准确的条款取决于方程和积分公式，在某些情况下可以通过特殊的倾斜对称有限差分方案来理解。

要想开始，有兴趣的读者可以看看https://github.com/kronbichler/advection_miniapp，其中用deal.II对一个简单的平流方程实现了倾斜对称的DG公式。

[1.x.2532]

正如介绍中提到的，欧拉方程的解随着马赫数的增加而产生冲击，这需要额外的机制来稳定方案，例如限制器的形式。除了实际实施限制器或人工粘性方法外，主要的挑战是如何平衡计算，因为在有问题的单元中限制震荡所涉及的额外计算会使它们比没有限制的普通DG单元更昂贵。此外，更好地应对不连续情况的额外数值通量也是一种选择。

对于超音速流动来说，有一个因素也是必要的，那就是适当的边界条件。与介绍中讨论的并在程序中实现的亚音速流出边界相反，所有的特性都是超音速流出边界的外在表现，所以我们不想规定任何外部数据。

[1.x.2533]



在代码中，我们将简单地添加额外的语句

[1.x.2534]

在 "local_apply_boundary_face() "函数中。

[1.x.2535]

当对欧拉解的兴趣主要在于声波的传播时，围绕一个背景状态，即一个给定的密度、速度和能量（或压力）场，将欧拉方程线性化，只计算针对这些场的变化，往往是合理的。这就是航空声学的广泛领域的设置。即使有时分辨率要求大大降低，但由于线性化引起了额外的条款，实施起来就变得有些复杂了。从代码的角度来看，在算子评估中，我们还需要为代码配备要线性化的状态。这一信息可以由分析函数（根据正交点的位置进行评估）或由类似于解决方案的矢量提供。基于该矢量，我们将创建一个额外的FEEvaluation对象，从中读取并提供正交点的场值。如果背景速度为零，密度为常数，线性化的欧拉方程进一步简化，可以等效地写成声波方程的形式。

在声音传播的背景下，一个挑战往往是边界条件的定义，因为计算域需要是有限的，而实际模拟往往跨越无限的（或至少大得多）物理域。传统的Dirichlet或Neumann边界条件会引起声波的反射，最终传播到感兴趣的区域，破坏了解决方案。因此，各种非反射边界条件或海绵层的变体，通常以[1.x.2536]的形式出现--其中解决方案被阻尼，没有反射

--是很常见的。




[1.x.2537]

如[2.x.6530]所述，本教程程序中的求解器也可以通过添加粘性项扩展到可压缩的Navier-Stokes方程。为了尽量保持这里获得的性能，尽管有额外的椭圆项的成本，例如通过内部惩罚方法，我们可以像步骤59的教程程序一样，将基础从FE_DGQ切换到FE_DGQHermite。




[1.x.2538]

在本教程中，我们使用了以面为中心的循环。在这里，单元和面的积分在不同的循环中处理，导致对结果向量的多次写入访问，这在现代硬件上是比较昂贵的，因为写入操作通常也会导致隐含的读操作。另一方面，以元素为中心的循环是在处理一个单元的同时直接处理其所有的2d面。虽然这种循环意味着通量必须计算两次（对于一个内部面的每一面），但结果向量只需访问一次的事实--以及由此产生的算法没有竞赛条件，因此完全适合共享内存的事实--已经带来了性能的提升。如果你对这些高级主题感兴趣，你可以看一下步骤76，在那里我们对本教程进行了修改，以便我们能够使用这些功能。


examples/step-68/doc/intro.dox

[2.x.6531]

[1.x.2539]

[1.x.2540]

[1.x.2541]

粒子在大量应用的数值模型中发挥着重要作用。粒子通常被用作无质量追踪器，以显示瞬时流动的动态。它们也可以作为更复杂的有限元模型的一部分发挥固有的作用，如颗粒在细胞中（PIC）方法[2.x.6532]，或者它们甚至可以用来模拟颗粒物质的运动，如离散元素法（DEM）[2.x.6533] 。在DEM的情况下，所产生的模型不再与有限元方法有关，而只是导致了一个描述颗粒运动和它们碰撞动态的常微分方程系统。所有这些模型都可以用deal.II的粒子处理能力来建立。

在本步骤中，我们使用粒子作为无质量的追踪器来说明涡流的动态。由于粒子是无质量追踪器，每个粒子[2.x.6534]的位置由以下常微分方程（ODE）描述。

[1.x.2542]



其中[2.x.6535]是粒子[2.x.6536]的位置，[2.x.6537]是其位置上的流速。在本步骤中，该ODE使用显式欧拉方法进行求解。由此产生的方案是。

[1.x.2543]



其中[2.x.6538]和[2.x.6539]分别是粒子[2.x.6540]在时间[2.x.6541]和[2.x.6542]的位置，其中[2.x.6543]是时间步骤。在本步骤中，粒子位置的速度以两种不同的方式获得。

- 通过在粒子的位置评估速度函数。

- 通过在背景三角图上评估速度函数，并使用有限元支持，在粒子的位置上进行插值。

第一种方法是不实际的，因为速度曲线一般是不知道的分析。第二种方法，基于在粒子位置的内插解，完全模仿了在现实的计算流体动力学模拟中的做法，这也是我们在步骤19中对粒子位置的有限元解进行评估的方式。在这一步中，我们说明了这两种策略。

我们注意到，通过使用四阶Runge-Kutta方法或其他适当的方案对粒子的运动进行时间积分，可以获得更大的精度。  实施一个更先进的时间积分方案将是这一步骤的直接延伸。

[1.x.2544]

在deal.II中，[2.x.6544]是非常简单和灵活的实体，可以用来建立PIC、DEM或任何类型的基于粒子的模型。粒子在现实空间中有一个位置，在它们所在的元素的参考空间中有一个位置，还有一个唯一的ID。在大多数情况下，包含粒子的模拟需要大量的粒子。因此，通过一个聚集所有粒子的实体来处理所有的粒子变得很有趣。在deal.II中，这是通过使用[2.x.6545]类来实现的。

默认情况下，粒子没有直径、质量或任何其他我们通常期望的物理粒子的物理属性。然而，通过ParticleHandler，粒子可以访问一个[2.x.6546]PropertyPool是一个数组，可以用来存储与粒子相关的任意数量的属性。因此，用户可以建立自己的粒子解算器，并将所需的属性归属于粒子（例如，质量、电荷、直径、温度等）。在本教程中，这被用来存储流体速度的值和粒子所属的过程ID。

[1.x.2545]

尽管本步骤不是计算密集型的，但包括许多粒子的模拟可能对计算要求很高，需要并行化。本步骤展示了deal.II对粒子的分布式并行能力。一般来说，在包括粒子的平行分布式模拟中，有三个主要挑战。

- 在分布式三角图上生成粒子。

- 在处理器之间交换离开本地域的粒子。

- 对模拟进行负载平衡，使每个处理器都有类似的计算负载。这些挑战及其在交易.II中的解决方案已经在[2.x.6547]中进行了更详细的讨论，但我们将在下面进行总结。

当然也有关于简单设置使用粒子的代码的问题。这些问题在第19步中已经基本解决了。一些更高级的技术也将在第70步中讨论。

[1.x.2546]

以可扩展的方式生成分布式粒子并不简单，因为在找到它们所在的单元之前，必须首先确定它们所属的处理器。 deal.II通过[2.x.6548]命名空间提供了许多生成粒子的能力。  其中一些粒子生成器只在本地拥有的子域上创建粒子。例如，[2.x.6549]在本地子域的每个单元内的相同参考位置创建粒子，[2.x.6550]使用全局定义的概率密度函数来确定本地生成粒子的数量和位置。

在其他情况下，如本步骤，粒子必须在单元格上的特定位置生成，而这些单元格可能只由处理器的一个子集拥有。在大多数这些情况下，粒子的插入是在非常有限的时间步长内完成的，因此，不构成计算成本的很大一部分。对于这些情况，deal.II提供了方便的[2.x.6551]，可以在全局范围内插入粒子，即使粒子不在启动创建粒子的调用的并行进程所拥有的单元中。生成器首先定位粒子位于哪个子域上，确定它们位于哪个单元中，并在处理器之间交换必要的信息，以确保生成的粒子具有正确的属性。因此，这种类型的粒子生成可能是通信密集型的。[2.x.6552]和[2.x.6553]分别使用三角法和相关DoFHandler或正交的点来生成粒子。用于生成粒子的三角形可以是用于背景网格的同一三角形，在这种情况下，这些函数与上一段中描述的[2.x.6554]函数非常相似。然而，用于生成粒子的三角法也可以与背景网格的三角法不同（不匹配），这对于生成特定形状的粒子（如本例），或者在两个不同的计算网格之间传输信息（如步骤-70）是很有用的。  此外，[2.x.6555]类提供了[2.x.6556]函数，可以从任意点的矢量和边界框的全局矢量中插入粒子。在本步骤中，我们在非匹配三角形上使用[2.x.6557]函数来插入位于圆盘形状位置的粒子。

[1.x.2547]

当粒子在平行分布式计算中移动时，它们可能会离开本地拥有的子域，需要转移到它们的新主人进程中。这种情况可能以两种非常不同的方式出现。首先，如果先前拥有的进程知道丢失的粒子的新主人（例如，因为粒子从一个处理器的本地拥有的单元移动到分布式三角形的相邻的幽灵单元），那么转移可以作为每个进程和新主人之间的点对点通信有效处理。每当粒子被分类到新单元时，这种转移就会自动发生。其次，以前的所有者可能不知道粒子被转移到哪个进程。在这种情况下，粒子被默认丢弃，因为全局搜索所有者的成本很高。步骤19显示了这样一个被丢弃的粒子仍然可以被收集、解释，并可能被用户重新插入。在本例中，我们通过在时间步长上施加一个CFL准则来防止第二种情况，以确保粒子最多会移动到本地进程的幽灵层，因此可以自动发送到邻近的进程。

[1.x.2548]

在使用粒子的并行分布式计算中出现的最后一个挑战是平衡计算负荷，即在网格上完成的工作，例如解决有限元问题，和在粒子上完成的工作，例如移动粒子或计算粒子之间或粒子与网格之间的力。默认情况下，例如在步骤40中，deal.II尽可能均匀地将背景网格分配给可用的进程，也就是说，它平衡每个进程上的单元数量。然而，如果一些单元拥有比其他单元多得多的粒子，或者一个单元的粒子比其他单元的粒子计算成本高得多，那么这个问题就不再有效地扩展了（关于我们认为的 "可扩展 "程序的讨论，见[2.x.6558]"这个词汇条"）。因此，我们必须应用一种 "负载平衡 "的形式，这意味着我们估计与每个单元及其粒子相关的计算负载。然后，重新划分网格就会考虑到这个综合的计算负荷，而不是单元数的简化假设 [2.x.6559] 。

在本节中，我们只讨论了分布式计算中针对粒子的挑战。粒子与有限元解决方案共享的并行挑战（并行输出，网格细化过程中的数据传输）可以用其他例子中已经讨论过的有限元问题的解决方案来解决。

[1.x.2549]

在本步骤中，我们使用粒子作为无质量的追踪器来说明一个特殊的涡流的动力学：Rayleigh--Kothe涡流。这种流动模式通常被用作界面跟踪方法（如流体体积法和水平集法）的复杂测试案例，因为它导致了流体的强烈旋转和伸长 [2.x.6560] 。

这个Rayleigh-Kothe涡流的流函数[2.x.6561]被定义为。

[1.x.2550]

其中[2.x.6562]为流动的一半周期。二维的速度曲线 ( [2.x.6563] ) 是 :

[1.x.2551]



速度曲线在下面的动画中得到说明。

[1.x.2552]



可以看出，由于项[2.x.6564]的存在，这个速度会周期性地逆转，材料在每一个长度为[2.x.6565]的周期后都会结束在其起始位置。我们将正好运行这个教程程序一个周期，并将最终的粒子位置与初始位置进行比较，以说明这一流动特性。这个例子使用测试案例产生了两个模型，它们对粒子的处理略有不同。第一个模型将精确的分析速度解作为每个粒子的速度。因此，在这个模型中，分配给粒子的速度没有错误，而在给定时间内，粒子位置与分析位置的任何偏差都是由于使用时间步进法不准确地求解粒子运动方程的错误造成的。在第二个模型中，分析速度场首先被内插到一个有限元矢量空间（以模拟速度是通过求解有限元问题得到的情况，与步骤19中每个粒子的ODE取决于有限元解的方式相同）。然后在粒子的位置上评估这个有限元 "解决方案"，以解决其运动方程。这两种情况之间的差异允许评估所选择的有限元空间是否足够精确，以所选择的粒子平流方案的最佳收敛率来平流粒子，这个问题在实践中对确定组合算法的精度很重要（例如，见[2.x.6566] ）。


examples/step-68/doc/results.dox



[1.x.2553]

运行该程序的目录中默认包含一个参数文件的例子。如果你没有在命令行中指定参数文件作为参数，程序将默认尝试读取文件 "参数.prm"，并执行代码。

在任何数量的核心上，模拟输出将看起来像。

[1.x.2554]



我们注意到，在默认情况下，模拟以分析速度运行粒子跟踪2000次，然后从头开始，以相同的时间运行速度插值的粒子跟踪。每隔10次迭代就会写出结果。

[1.x.2555]

下面的动画显示了粒子在被流场吸引时的轨迹。我们看到，在流动的整个过程中，粒子又回到了它们的初始配置，这是预料之中的事。

[1.x.2556]



[1.x.2557]

下面的动画显示了动态负载平衡的影响。我们清楚地看到，子域自我调整以平衡每个子域的粒子数量。然而，完美的负载平衡并没有达到，部分原因是由于背景网格的粗糙性。

[1.x.2558]






[1.x.2559]

这个程序强调了在deal.II中处理粒子的一些主要能力，特别是它们用于分布式并行模拟的能力。然而，这一步骤可以以多种方式进行扩展。

- 可以使用高阶时间积分（例如使用Runge-Kutta 4方法）来提高精度，或者在相同精度下允许更大的时间步长。

- 完整的运动方程（含惯性）可以为粒子求解。在这种情况下，粒子将需要有额外的属性，例如它们的质量，如步骤19，如果想考虑与流体的相互作用，还需要考虑它们的直径。

- 耦合到流动求解器。这一步可以直接与任何解决斯托克斯方程（第32步，第70步）或纳维-斯托克斯方程（例如第57步）的并行程序相耦合。

- 计算两个模型之间最终粒子位置的差异，可以量化内插误差对粒子运动的影响。


examples/step-69/doc/intro.dox

[1.x.2560]

[2.x.6567] [2.x.6568] 桑迪亚国家实验室是一个多任务实验室，由霍尼韦尔国际公司的全资子公司桑迪亚国家技术与工程解决方案有限公司根据合同DE-NA0003525为美国能源部国家核安全局管理和运营。本文件描述了客观的技术结果和分析。文件中可能表达的任何主观观点或意见，不一定代表美国能源部或美国政府的观点。[2.x.6569]

[2.x.6570] 本教程步骤实现了一个基于一阶精确[1.x.2561]的求解欧拉气体动力学方程[2.x.6571] 。因此，它主要为教育目的而提出。对于实际的研究计算，你可能要考虑探索相应的[1.x.2563]，它使用[1.x.2564]技术，以及强保稳（SSP）时间积分，见[2.x.6572] （[1.x.2565]）。

[2.x.6573]

[1.x.2566]

[1.x.2567]

本教程提出了一个用于求解可压缩欧拉方程的一阶方案，该方案基于三个要素：在有限元背景下对欧拉方程进行[1.x.2568]型离散化；基于局部波速的[1.x.2569]上限的图粘性稳定；以及显式时间步进。因此，本教程步骤中提出的观点和技术与步骤33中的观点和技术有很大的不同，后者主要是使用自动微分。从编程的角度来看，本教程将关注在大规模计算中发现的一些技术：混合线程-MPI并行化；自由度的有效局部编号；使用工作线程进行并发的后处理和结果的写出；以及检查点和重启。

应该注意的是，双曲守恒定律背景下的一阶方案需要太多的自由度来解决模拟流体的某些关键特征，因此，通常只能作为高阶方案的基本构建块 [2.x.6574] 。然而，我们希望读者在跳入完整的研究代码（如 [2.x.6575] 中讨论的二阶方案）之前，仍然认为教程步骤是一个很好的起点（特别是在编程技术方面）。


[1.x.2570]

[1.x.2571]

可压缩的欧拉气体动力学方程以保守的形式写成如下。

[1.x.2572]

其中[2.x.6576] ，和[2.x.6577] ，以及[2.x.6578] 是空间维度。我们说[2.x.6579]是状态，[2.x.6580]是系统的通量。在欧拉方程的情况下，状态由[2.x.6581]给出：其中[2.x.6582]表示密度，[2.x.6583]是动量，而[2.x.6584]是系统的总能量。系统的通量[2.x.6585]被定义为

[1.x.2573]

其中[2.x.6586]是身份矩阵，[2.x.6587]表示张量积。在这里，我们介绍了压力[2.x.6588]，一般来说，它是由一个封闭式的状态方程定义的。在本教程中，我们将讨论限制在多晶体理想气体的范畴内，对于这些气体，压力由以下公式给出

[1.x.2574]

其中因子[2.x.6589]表示[1.x.2575]。




[1.x.2576]

双曲守恒定律，如

[1.x.2577]

对解理论构成了重大挑战。一个明显的现象是，以变分形式重写方程并以解本身进行检验并不能导致能量估计，因为配对[2.x.6590]（理解为[2.x.6591]内积或对偶性配对）不能保证是非负的。在这种情况下，诸如能量稳定性或[2.x.6592]稳定性的概念（一般来说）是没有意义的。

历史上，为了加深对双曲守恒定律的理解而采取的最有成效的步骤是假设解被正式定义为[2.x.6593]，其中[2.x.6594]是抛物线正化的解

[1.x.2578]

这样的解决方案，被理解为在零粘度极限下恢复的解决方案，通常被称为[1.x.2579]。这是因为，从物理上看[2.x.6595]可以理解为与流体的粘度有关，也就是说，一个表示以不同速度运动的相邻气体粒子对彼此施加的摩擦力大小的量）。欧拉方程本身是在无摩擦的假设下得出的，但在物理上可以预期描述摩擦或粘度消失的极限情况。)这种解决方案的全球存在和唯一性是一个开放的问题。然而，我们至少知道，如果这种粘度解存在，它们必须满足[2.x.6596]对所有[2.x.6597]和[2.x.6598]的约束条件，其中

[1.x.2580]

这里，[2.x.6599]表示比熵值

[1.x.2581]

我们将把[2.x.6600]称为欧拉方程的不变量集。换句话说，状态[2.x.6601]服从密度的正性，内能的正性，以及比熵的局部最小原则。这个条件是精确（粘性）解所满足的一类点式稳定性约束的简化版本。我们所说的 "点 "是指该约束必须在域的每一点上得到满足，而不仅仅是在平均（积分，或高阶矩）意义上。

在数值逼近的背景下，违反这样的约束有可怕的后果：它几乎肯定会导致数值方案的灾难性失败，失去双曲性，以及总体上，失去（离散）问题的良好解决性。这也意味着我们已经计算了一些不能从物理上解释的东西。例如，我们该如何看待一个具有负密度的计算结果？下面我们将制定一个方案，确保[2.x.6602]的离散近似仍在[2.x.6603]中。




[1.x.2582]

在步骤9、步骤12、步骤33和步骤67之后，在这一点上，将欧拉方程的离散化建立在一个（半离散的）变分公式上看起来很诱人。

[1.x.2583]

这里，[2.x.6604]是一个适当的有限元空间，[2.x.6605]是一些线性稳定方法（可能辅以一些特殊的冲击捕捉技术，例如见[2.x.6606]的第五章和其中的参考文献）。在deal.II教程中描述的大多数随时间变化的离散化方法都是基于这样一种（半离散的）变量方法。从根本上说，从分析的角度来看，变分离散化被认为是为了提供某种全局（积分）稳定性的概念，也就是说，一种估计形式为

[1.x.2584]

成立，其中[2.x.6607]可以代表[2.x.6608]准则，或者更广泛地代表一些离散的（可能与网格有关）能量准则。自80年代中期以来，双曲守恒定律的变异离散化非常流行，特别是与SUPG型稳定化和/或上卷技术相结合（见[2.x.6609]和[2.x.6610]的早期工作）。它们已被证明是在亚音速无冲击系统和类似的良性情况下进行模拟的一些最佳方法。

<！--特别是，教程Step-67侧重于使用dG技术研究亚音速体系中的欧拉气体动力学方程。-->

然而，在跨音速和超音速阶段，以及冲击-流体力学应用中，使用变量方案可能是值得怀疑的。事实上，在写这篇文章的时候，大多数冲击-流体力学代码仍然是以有限体积方法为基础的。变分方案在这种极端状态下失败的主要原因是缺乏点状稳定性。这是因为[1.x.2585]对积分量（如矩积分）的约束一般来说对解的点定性没有影响。虽然其中一些问题可能会通过对正确的冲击捕捉方案的（永久）追逐而得到缓解，但类似有限差分的方案和有限体积方案在许多方面仍有优势。

因此，在这一教程步骤中，我们偏离了变分方案。我们将提出一个完全代数化的表述（具有拼合型方案的味道），该表述在点上保留了约束，即：。

[1.x.2586]

与有限差分/体积方案相反，本步骤实现的方案最大限度地利用了有限元软件的基础设施，在任何空间维度的任何网格上都能工作，并且理论上保证始终工作，没有例外。这说明deal.II的使用范围远远超出了希尔伯特空间中的变分方案，deal.II中的大量类、模块和命名空间都可以适用于这种目的。




[1.x.2587]

让[2.x.6611]为标量值的有限维空间，由基[2.x.6612]跨越，其中。  [2.x.6613]和[2.x.6614]是识别网格中每个标量自由度（DOF）的所有指数（非负整数）的集合。因此，标量有限元函数[2.x.6615]可以写成[2.x.6616]与[2.x.6617] 。我们引入矢量值近似空间的符号 [2.x.6618] 。设[2.x.6619] ，则可以写成[2.x.6620] ，其中[2.x.6621]和[2.x.6622]是标量值的形状函数。

[2.x.6623] 我们特意避免在我们的符号中使用矢量值的有限元空间。矢量值有限元空间对于PDE系统（如Navier-Stokes）的变分公式是自然的。在这种情况下，必须计算的相互作用描述了[1.x.2588]：通过对矢量值DoFHandler的适当重新编号（即用FESystem初始化），可以相对容易地计算块矩阵（为了推进解决方案而需要）。然而，在时间明确的搭配型方案（如有限差分和/或本教程中提出的方案）的背景下，必须计算的相互作用可以更好地描述为[1.x.2589]（不是在DOF之间）。此外，在我们的案例中，我们不解决线性方程，以推进解决方案。这使得在理论和/或实践中使用矢量值有限元空间的理由非常少。

我们将使用通常的拉格朗日有限元：让[2.x.6624]表示所有支持点的集合（见[2.x.6625]"本词汇条"），其中[2.x.6626] 。那么每个索引[2.x.6627]都能唯一识别一个支持点[2.x.6628]，以及一个标量值的形状函数[2.x.6629]。有了这个符号在手，我们可以将（显式时间步进）方案定义为。

[1.x.2590]

其中

  - [2.x.6630]是肿块质量矩阵

  - [2.x.6631]是时间步长。

  - [2.x.6632]（注意，[2.x.6633]）是一个矢量值矩阵，被用来在弱意义上近似通量的发散。

  - [2.x.6634]是包含与索引[2.x.6635]耦合的所有自由度的邻接列表。换句话说，[2.x.6636]包含行索引i的所有非零列索引。[2.x.6637]也将被称为 "模版"。

  - [2.x.6638]是针对与支持点[2.x.6641]相关的状态[2.x.6640]所评估的双曲系统的通量[2.x.6639]。

  - 如果[2.x.6642]是所谓的[1.x.2591]。图形粘度作为一个稳定项，它在某种程度上是[2.x.6644]的离散对应物，出现在上述的粘度解的概念中。我们将把[2.x.6645]的构造建立在最大局部波速[2.x.6646]的估计上，稍后将详细解释。

  - 粘度矩阵的对角线项被定义为 [2.x.6647] 。

  - [2.x.6648]是[2.x.6649]矩阵的归一化，它进入了近似黎曼求解器，我们用它来计算本地波速的近似值[2.x.6650]。这将在下文中进一步解释）。

[2.x.6651]的定义远非微不足道，我们将推迟精确的定义，以便首先关注一些算法和实现问题。我们注意到

  - [2.x.6652]和[2.x.6653]不随时间变化（只要我们保持离散化固定）。因此，将这些矩阵/向量在所谓的[1.x.2592]中组装一次，并在每个时间步长中重复使用是有意义的。它们是我们将称之为离线数据的一部分。

  - 在每个时间步骤中，我们必须评估[2.x.6654]和[2.x.6655]，这将构成大部分的计算成本。

考虑下面的伪代码，说明在一个新的时间[2.x.6656]计算解决方案[2.x.6657]的可能的直接策略，给定一个在时间[2.x.6659]的已知状态[2.x.6658] 。

[1.x.2593]



我们在此注意到，。

- 这种 "装配 "不需要任何形式的正交或单元环。

- 这里[2.x.6660]和[2.x.6661]是一个全局矩阵和一个全局向量，分别包含所有向量[2.x.6662]和所有状态[2.x.6663]。

- [2.x.6664]、[2.x.6665]和[2.x.6666]是假设的实现，它们要么收集（来自）全局矩阵和向量，要么写入（进入）。

- 如果我们假设一个二维空间的笛卡尔网格，一阶多项式空间 [2.x.6667] ，并且 [2.x.6668] 是一个内部节点（即 [2.x.6669] 不在域的边界上），那么。  [2.x.6670]应该包含九个状态矢量元素（即与形状函数[2.x.6671]相关的补丁/宏元素中的所有状态）。这是与通常基于单元的循环的主要区别之一，在这种循环中，收集功能（在deal.II的情况下编码为FEValuesBase<dim, spacedim>.get_function_values()）只收集本地单元（只是补丁的一个子集）的值。

实际执行将在一个关键方面偏离上述代码：时间步长[2.x.6672]必须根据CFL条件来选择

[1.x.2594]

其中[2.x.6673]是一个选定的常数。这就需要在实际执行上述更新之前，在一个单独的步骤中计算所有的[2.x.6674]。不过，核心原则没有改变：我们不是在单元格上循环，而是在稀疏图的所有边上循环。

[2.x.6675]在有限元界之外，在更广泛的CFD界，遇到这种全代数方案（即没有双线性形式，没有单元环，也没有正交）并不罕见。这类方案有丰富的应用历史，也被称为[1.x.2595]或[1.x.2596]有限元方案（例如，见[2.x.6676]的历史概述）。然而，需要强调的是，该方案的代数结构（在本教程中介绍）和节点循环并不只是一个性能上的噱头。实际上，这个方案的结构是出于理论上的需要：该方案的点稳定性证明取决于该方案的特定代数结构。此外，使用单元环不可能计算代数粘性[2.x.6677]，因为它们非线性地依赖于跨越多个单元的信息（叠加不成立：将不同单元的贡献相加不会导致正确结果）。

[1.x.2597]

在本教程步骤中考虑的例子中，我们使用了三种不同类型的边界条件：本质类边界条件（我们在域的左侧边界规定了一个状态），域的右侧边界的流出边界条件（也称为 "无 "边界条件），以及障碍物顶部、底部和表面的 "反射 "边界条件[2.x.6678]（也称为 "滑动 "边界条件）。我们不会过多地讨论基本的和 "无为 "的边界条件，因为它们的实现相对容易，读者可以直接从（有记录的）源代码中获取实现。在这部分介绍中，我们将只关注 "反射 "边界条件，这在某种程度上是比较棘手的。

[2.x.6679] 在写这篇文章的时候（2020年初），说双曲守恒定律系统的稳定边界条件的分析和实现都是一个开放的问题，这不是没有道理的。对于变分公式的情况，稳定的边界条件是那些导致良好的（胁迫的）双线性形式。但是对于一般的双曲守恒定律系统（以及本教程中所使用的代数式），胁迫性作为稳定性的一个概念没有适用性和/或意义。在本教程的步骤中，我们将使用不变集的保存作为我们主要的稳定性概念，它（至少）保证了离散问题的良好处理。

对于反射边界条件的情况，我们将按以下步骤进行。

- 对于每一个时间步骤的推进，完全不满足边界条件。

- 让[2.x.6680]成为我们想要强制执行反射边界条件的边界部分。在时间步骤结束时，我们在一个后处理步骤中强烈地执行反射边界条件，在这个步骤中我们执行投影[1.x.2598] 。

  去掉了[2.x.6681]的法线成分。这是一个有点天真的想法，它保留了PDE的一些基本属性，我们在下面解释。

这种方法通常被称为 "边界条件的明确处理"。经验丰富的有限元人可能会发现这种方法值得怀疑。毫无疑问，在求解抛物线或椭圆方程时，我们通常通过使它们成为近似空间的一部分来强制执行基本（类似于Dirichlet）边界条件 [2.x.6682] ，并将自然（例如Neumann）边界条件作为变分公式的一部分。我们也知道，边界条件的明确处理（在抛物线PDEs的背景下）几乎肯定会导致灾难性的后果。然而，在非线性双曲方程的背景下，我们有。

- 证明（对于反映边界条件的情况）边界条件的显式处理不仅是保守的，而且还能保证对所有[2.x.6684]的属性[2.x.6683]的保存（良好处理性）是比较容易的。这也许是使用显式执行边界条件的最重要原因。

- 就我们所知：我们不知道有任何数学结果证明，在使用边界条件直接执行到近似空间，或者使用Nitsche惩罚方法（例如广泛用于非连续Galerkin方案）的弱执行时，有可能保证所有[2.x.6685]的属性。此外，其中一些传统的想法导致了相当严格的时间步长约束。

- 有足够的数值证据表明，在CFL条件下，对类似于Dirichlet的边界条件的明确处理是稳定的，不会带来任何精度上的损失。

如果[2.x.6687]代表欧拉方程，在整个边界上反映边界条件（即[2.x.6688]），我们在空间和时间[2.x.6689]中进行积分，我们将得到

[1.x.2599]

请注意，动量不是一个守恒量（与墙的相互作用导致动量的增加/减少）：然而[2.x.6690]必须满足动量平衡。尽管我们不会在整个域中使用反射边界条件，但我们想知道我们对反射边界条件的实现与上述的守恒特性是一致的。特别是，如果我们在整个域中使用投影[2.x.6691]，可以保证以下离散质量平衡。

[1.x.2600]

其中[2.x.6692]是位于边界的节点上的压力。显然，[2.x.6693]是[2.x.6694]的离散对应物。身份[2.x.6695]的证明被省略了，但我们简要地提到，它取决于[2.x.6697]中提供的[1.x.2601][2.x.6696]的定义。我们还注意到，这种反映边界条件的执行方式与最初在 [2.x.6698] 中提出的方式不同。


examples/step-69/doc/results.dox

[1.x.2602]

[1.x.2603]

在释放模式下，用默认参数运行程序，在4核机器上（带超线程）大约需要1分钟。

[1.x.2604]



一个明显的事实是，程序花了三分之二的执行时间计算图形粘度d_ij，大约三分之一的执行时间用于执行更新，其中计算通量[2.x.6699]是昂贵的操作。预设的默认分辨率约为37k个网格点，相当于二维空间自由度约148k。解决方案的动画斯利安图看起来如下。

[2.x.6700]

很明显，一阶方法的37k个网格点远远不能满足解决任何流动特征的需要。作为比较，这里有一个使用二阶方法和大约9.5M网格点的 "参考 "计算（[1.x.2605]）。

[2.x.6701]

因此，我们给了一阶方法第二次机会，在一个小型计算服务器上用大约240万个网格点运行它。

[1.x.2606]



并有以下结果。

[2.x.6702]

这大大改善了，当然代价是在16个核心上运行了大约2小时的代码。




[1.x.2607]

[1.x.2608]

如上所述，这里展示的程序实际上只是一阶精确。上面的图片说明了这引入了多少扩散，以及该解决方案离真正解决我们所关心的特征还有多远。

这一点是可以解决的，但这将超出一个*教程*的内容。尽管如此，还是值得展示一下通过添加二阶方案可以实现的效果。例如，这里有一段用[1.x.2609]计算的视频，显示了（用不同的颜色方案）对应于上述情况的2d模拟。

[1.x.2610]



这个模拟是用解矢量的每个分量3800万个自由度（连续[2.x.6703]有限元素）完成的。对于这类模拟来说，解决方案的精致细节是显著的，包括在障碍物后面的亚声速区域。

人们还可以相对容易地进一步将其扩展到三维案例。

[1.x.2611]



然而，解决这个问题变得很昂贵。仿真是以每个部件18.17亿个自由度（连续[2.x.6704]有限元）进行的（总共90.9亿个空间自由度），在30,720个MPI等级上运行。该代码达到了平均每秒969万个网格点的吞吐量（每个CPU每秒0.04万个网格点）。前面和后面的墙显示了一个 "Schlieren图"：密度的梯度大小在一个从白色（低）到黑色（高）的指数级上。所有其他切面和障碍物表面都显示了白色（低）-黄色（中）-红色（高）尺度上的涡度大小。各个切割面的比例已经被调整，以获得更好的视觉效果）。


examples/step-7/doc/intro.dox

[1.x.2612]

[1.x.2613]

在这个程序中，我们将主要考虑两个方面。<ol> [2.x.6705] 验证程序的正确性和生成收敛表； [2.x.6706] 亥姆霍兹方程的非均质诺伊曼边界条件。  [2.x.6707] 除了这些主题，还将再次展示各种改进和技巧。




[1.x.2614]

可能从来没有一个非琐碎的有限元程序从一开始就能正常工作。因此有必要找到方法来验证计算出的解是否正确。通常，这是通过选择模拟的设置来完成的，我们知道准确的连续解，并评估连续解和计算的离散解之间的差异。如果这个差值以正确的收敛顺序收敛为零，这已经是正确性的一个很好的指示，尽管可能还有其他的误差源持续存在，而这些误差对总误差的贡献很小，或者是更高阶的。在有限元模拟的背景下，这种通过选择适当的右手边和边界条件来选择解决方案的技术通常被称为[1.x.2615]。

在这个例子中，我们不会去研究系统性软件验证的理论，这是一个非常复杂的问题。相反，我们将展示deal.II在这方面所能提供的工具。这基本上是围绕着一个单一的函数的功能，[2.x.6708]这个函数计算一个给定的连续函数和每个单元上不同规范的有限元场之间的差值。当然，像其他积分一样，我们只能用正交公式来评估这些规范；因此，选择正确的正交公式对准确评估误差至关重要。这一点对于[2.x.6709]规范尤其成立，我们只在正交点评估数值和精确解的最大偏差；那么就不应该尝试使用正交规则，其评估只发生在[超级收敛](https://en.wikipedia.org/wiki/Superconvergence)可能发生的点上，例如最低阶高斯正交公式的高斯点，对于该矩阵的装配中的积分是正确的（例如，对于线性元素，不要使用QGauss（2）正交公式）。事实上，这通常也是对其他规范的好建议：如果你的正交点偶然选择在由于超收敛而恰好误差特别小的位置，那么计算出来的误差看起来会比实际情况小得多，甚至可能表明收敛阶数更高。因此，我们将为这些误差准则的积分选择不同的正交公式，而不是线性系统的装配。

函数[2.x.6710]对三角形的每个单元[2.x.6711]进行所需规范的评估，并返回一个持有每个单元的这些值的向量。从局部值中，我们可以得到全局误差。例如，如果所有单元[2.x.6714]的元素为[2.x.6713]的向量[2.x.6712]包含本地[2.x.6715]规范[2.x.6716]，那么

[1.x.2616]

是全球 [2.x.6717] 误差 [2.x.6718] 。

在程序中，我们将展示如何评估和使用这些量，并且我们将监测它们在网格细化下的值。当然，我们必须选择手头的问题，使我们能够明确地说明解决方案及其导数，但由于我们要评估程序的正确性，这才是合理的。如果我们知道程序对一个（或者，如果想真正确定：许多）特别选择的右手边产生了正确的解决方案，我们可以相当有信心，它也将计算出我们不知道确切数值的问题的正确解决方案。

除了简单地计算这些数量之外，我们将展示如何从这个程序产生的数据中生成格式良好的表格，自动计算收敛率等。此外，我们还将比较不同的网格细化策略。




[1.x.2617]

本例程序的第二个完全不相关的主题是使用非均质边界条件。这些条件包括在使用边界积分的变异形式中，我们必须在组装右手边的矢量时进行数值评估。

在我们进入编程之前，让我们简单看看数学公式。我们在这里要解决的方程是亥姆霍兹方程，"带有漂亮的符号"。

[1.x.2618]

在[2.x.6719]与[2.x.6720]的正方形上，用迪里希特边界条件来增强。

[1.x.2619]

在边界[2.x.6721]的某些部分[2.x.6722]，以及诺伊曼条件

[1.x.2620]

对其余的[2.x.6723]。在我们特定的测试案例中，我们将使用[2.x.6724] 。 我们说这个方程有 "漂亮的符号"，因为算子[2.x.6725]与身份[2.x.6726]和[2.x.6727]是一个正定算子；[1.x.2621]是[2.x.6728]，由时间谐波过程建模产生。如果[2.x.6729]很大的话，该算子就不是正定的，这就导致了我们在这里不需要讨论的各种问题。如果[2.x.6730]恰好是[2.x.6731]的特征值之一，那么算子也可能不是可逆的--即方程没有唯一的解--)

因为我们想验证我们的数字解 [2.x.6732] 的收敛性，我们想要一个设置，以便我们知道精确的解 [2.x.6733] 。这就是 "人造解法 "的作用。为此，让我们选择一个函数

[1.x.2622]

其中指数的中心[2.x.6734]为[2.x.6735]，[2.x.6736]，和[2.x.6737]，半宽设为[2.x.6738]。然后，制造解的方法说：选择

[1.x.2623]

有了这个特殊的选择，我们就可以推断出原始问题的解恰好是[2.x.6739] 。换句话说，通过以特定的方式选择方程的右边和边界条件，我们已经为自己制造了一个我们知道其解决方案的问题。这使我们能够计算出我们的数字解决方案的误差。在下面的代码中，我们用[2.x.6741]类来表示[2.x.6740]，其他类将用于表示[2.x.6742]和[2.x.6743] 。

利用上述定义，我们可以陈述方程的弱表述，即：找到[2.x.6744]，以便

[1.x.2624]

为所有测试函数 [2.x.6745] 。边界项[2.x.6746]是通过部分积分和使用[2.x.6747]对[2.x.6748]和[2.x.6749]的方式出现的。因此，在离散公式中，我们用来建立全局矩阵和右侧向量的单元矩阵和向量看起来是这样的。

[1.x.2625]

由于域积分的生成已经在前面的例子中多次展示过，这里只对轮廓积分的生成感兴趣。它的工作原理如下：对于域积分，我们有一个[2.x.6751]类，它提供了形状值和梯度，以及雅各布行列式和其他信息，并指定了单元格中的正交点；同样，还有一个[2.x.6752]类，为单元格面上的积分执行这些任务。我们向它提供一个流形的正交公式，该流形的维数比域的维数少一，以及我们想在其上进行积分的单元格和其面的数量。然后，该类将计算该面的正交点的值、梯度、法向量、权重等，然后我们可以以与域积分相同的方式使用这些值。下面的程序显示了这样做的细节。




[1.x.2626]

除了上面概述的数学主题外，我们还想用这个程序来说明良好编程实践的一个方面，即命名空间的使用。在为deal.II库编程时，我们非常注意不要为类和全局函数使用过于通用的名称，例如[2.x.6753]等。此外，我们把所有的东西都放到了名字空间 [2.x.6754] 中。但当一个人写的应用程序不是为了给别人使用时，就不一定会注意这么多。如果你遵循步骤1到步骤6的编程风格，这些函数就会最终进入全局命名空间，不幸的是，很多其他的东西也在那里（基本上是C语言提供的所有东西，以及你通过头文件从操作系统得到的所有东西）。更糟糕的是，C语言的设计者在避免使用通用名称方面也不总是很小心；例如，符号<code>j1, jn</code>在C头文件中被定义（它们表示贝塞尔函数）。

为了避免不同函数或变量的名称相撞时产生的问题（经常出现混乱的错误信息），把你所做的一切放到[1.x.2627]中是一个好的做法。按照这种风格，我们将在程序的顶部打开一个名字空间[2.x.6755]，将deal.II名字空间导入其中，将本程序特有的一切（除了[2.x.6756]，它必须在全局名字空间中）放入其中，并且只在文件的底部关闭它。换句话说，这个程序的结构是这样的

[1.x.2628]

我们将在整个交易.II教程的剩余部分遵循这一方案。


examples/step-7/doc/results.dox



[1.x.2629]


该程序产生了两种输出。第一种是输出文件 [2.x.6757] , [2.x.6758] , 和 [2.x.6759] 。我们在此展示后者的三维视图。


[2.x.6760]





其次，该程序不仅将表格写入磁盘，而且在运行时也写入屏幕。输出结果如下（记得标为"[2.x.6761]"的列实际上显示的是错误的[2.x.6762][1.x.2630]规范，而不是完整的[2.x.6763]规范）。




[1.x.2631]




我们可以看到网格细化后的误差减少，对于进行全局细化的情况，也可以看到收敛率。可以清楚地看到Q1和Q2元素在[2.x.6764]半规范下的线性和二次收敛率，以及[2.x.6765]规范下的二次和三次收敛率。





最后，该程序还生成了LaTeX版本的表格（此处未显示），这些表格被写入一个文件中，以便可以复制粘贴到LaTeX文件中。




[1.x.2632]

我们上面展示的是如何在一些不同的规范中确定误差[2.x.6766]的大小。我们这样做主要是因为我们对测试我们的解决方案是否*融合感兴趣。但是从工程的角度来看，这个问题往往更实际：我的网格要做得多细才能使误差 "足够小"？换句话说，如果在上表中，[2.x.6767]的半规范已经减少到`4.121e-03`，这是否足以让我在蓝图上签字，宣布我们的数值模拟显示桥梁足够坚固？

在实践中，我们很少遇到这种情况，因为我通常不能在重要的情况下将数值解[2.x.6768]与精确解[2.x.6769]进行比较--如果我知道[2.x.6770]，我就不必计算[2.x.6771] 。但即使我可以，一般情况下要问的问题是。`4.121e-03`是什么？解决方案将有物理单位，例如公斤-米-平方，我在域上积分一个单位为上述平方的函数，然后取其平方根。因此，如果域是二维的，[2.x.6772]的单位是公斤-米-立方。那么问题来了。2.x.6773]的单位是kg-times-mubed小吗？这取决于你要模拟的是什么。如果你是一个天文学家，习惯于以太阳质量为单位的质量和以光年为单位的距离，那么是的，这是一个小得惊人的数字。但是如果你是做原子物理的，那就不是：这并不小，而且你的误差肯定也不够小；你需要一个更细的网格。

换句话说，当我们看这些数字的时候，我们通常需要与一个 "尺度 "进行比较。做到这一点的一个方法是，不看任何规范中的*绝对*误差[2.x.6774]，而是看*相对*误差[2.x.6775] 。如果这个比率是[2.x.6776]，那么你就知道，*平均而言，[2.x.6777]和[2.x.6778]之间的差异是0.001%--对于工程而言可能足够小。

我们如何计算[2.x.6779]？我们只需要在所有的单元格上做一个积分循环，在这些单元格上做正交点，然后把东西加起来，最后取平方根。但有一个更简单的方法经常使用。你可以调用

[1.x.2633]

来计算 [2.x.6780] 。另外，如果你特别懒，不喜欢创建`零_向量'，你可以使用，如果网格不是太粗，那么[2.x.6781] ，我们可以通过调用[2.x.6782]来计算。

[1.x.2634]

在这两种情况下，我们只需要像在程序中一样，通过调用以下命令将单元格准则的向量合并为一个全局准则

[1.x.2635]






[1.x.2636]

[1.x.2637]

继续运行具有高阶元素的程序（[2.x.6783] , [2.x.6784] , ...）。你会注意到，代码的几个部分的断言将被触发（例如，在为数据输出生成文件名时）。你可能必须解决这些问题，但要使程序正常工作应该不是很难

[1.x.2638]

Q1或Q2更好吗？自适应细化与全局细化又如何呢？比较它们的一个（有些不公平，但很典型）指标是看误差与未知数的关系。

要看到这一点，以对数风格创建一个图，未知数在[2.x.6785]轴上，[2.x.6786]误差在[2.x.6787]轴上。你可以为[2.x.6788]和[2.x.6789]添加参考线，并检查全局和适应性细化是否遵循这些。如果我们做一个（并非完全不合理的）假设，即对于一个好的线性求解器，计算工作量与未知数[2.x.6790]成正比，那么很明显，[2.x.6791]的误差减少比[2.x.6792]形式的减少要好得多：也就是说，与使用全局细化相比，自适应细化以更少的计算工作量给我们带来了期望的误差等级。这并不是一个特别令人惊讶的结论，但是值得在实践中检查这类假设。

当然，更公平的比较是在[2.x.6793]轴上绘制运行时间（先切换到发布模式！）而不是未知数的数量。如果你通过对每个细化步骤进行计时（例如，使用Timer类）来绘制运行时间与未知数数量的关系，你会发现线性求解器并不完美--其运行时间的增长速度超过了与线性系统大小成正比的速度--挑选一个更好的线性求解器可能适合这种比较。


examples/step-70/doc/intro.dox

[2.x.6794]

[1.x.2639]

[2.x.6795]




[1.x.2640]

[1.x.2641]

在本教程中，我们考虑了层流体系中的混合问题。这类问题出现在从化学工程到发电（如涡轮机械）等广泛的应用中。混合问题特别难以用数值来解决，因为它们通常涉及一个容器（有固定的边界，可能还有复杂的几何形状，如挡板），由域[2.x.6796]表示，和一个（或多个）浸入和旋转的叶轮（由域[2.x.6797]表示）。我们希望解决流动方程的域是两个域之间的（与时间有关的）差值，即。  [2.x.6798] .

对于旋转叶轮，使用任意拉格朗日欧拉公式（其中流体域--连同网格！）是不可能的，除非只考虑小时间（即小的流体域变形）。-- 是不可能的，除非只考虑小时间（即小的流域变形）。如果想跟踪叶轮多次旋转时的流动演变，所产生的变形网格就会过于扭曲而无用。

在这种情况下，一个可行的替代策略是使用非匹配方法（类似于我们在step-60中所做的），其中一个背景固定网格（可能在时间上进行局部细化以更好地捕捉实体运动）与一个旋转的、独立的网格相耦合。

为了保持步骤60中使用的相同符号，我们使用[2.x.6799]来表示[2.x.6800]中的域，代表流体和叶轮的容器，我们使用[2.x.6801]在[2.x.6802]来表示整个叶轮（当它的`spacedim`度量非负值时，也就是说，当我们可以把它表示为维数`dim`等于`spacedim`的网格时），薄叶轮的同维度表示，或者只是整个叶轮的边界。

域[2.x.6803]被嵌入到[2.x.6804]（[2.x.6805]）中，它是不匹配的：一般来说，它不与任何体积网格的特征对齐。我们在[2.x.6806]上求解一个偏微分方程，通过一些惩罚技术在嵌入域[2.x.6807]上强制执行一些问题的解决条件。在当前情况下，条件是流体在[2.x.6808]上各点的速度等于固体叶轮在该点的速度。

我们在此描述的技术在文献中使用了许多名称之一：[1.x.2642]和[1.x.2643]等。  其主要原理是两个网格的离散化保持完全独立。在本教程中，这种方法被用来求解由斯托克斯方程描述的粘性流体的运动，该流体被一个刚性的非变形叶轮搅动。

因此，[2.x.6809]中求解的方程是蠕动流的斯托克斯方程（即[2.x.6810]），并且在与叶轮相关的移动*嵌入域*[2.x.6811]上应用无滑动边界条件。然而，这个教程可以很容易地扩展到其他方程（例如，纳维-斯托克斯方程、线性弹性方程等）。它可以被看作是Step-60的一个自然扩展，它可以通过MPI使用分布式并行计算架构解决大型问题。

然而，与第60步相反，[2.x.6812]上的迪里希特边界条件是弱加的，而不是通过使用拉格朗日乘法器，而且我们集中处理两个完全分布的三角形的耦合（这种组合在第60步的实施中是不可能的）。

当人们想在嵌入域上执行条件时，有两种有趣的情况发生 [2.x.6813] 。

- 嵌入域[2.x.6814]的几何维度`dim`与域[2.x.6815]相同（`spacedim`），也就是说，[2.x.6816]的spacedim-维度不为零。在这种情况下，对[2.x.6817]施加Dirichlet边界的边界条件是通过体积惩罚完成的。如果施加的惩罚只取决于速度，这通常被称为[2.x.6818]惩罚，而如果惩罚同时取决于速度及其梯度，则是[2.x.6819]惩罚。2.x.6820] 惩罚的情况与Darcy型方法非常相似。对[2.x.6821]和[2.x.6822]两种惩罚方法都进行了广泛的分析（例如，见[2.x.6823]）。

- 嵌入域[2.x.6824]的内在维度`dim`小于[2.x.6825]的维度（`spacedim`），因此其spacedim维度为零；例如，它是一条嵌入二维域的曲线，或一个嵌入三维域的表面。当然，这在物理上是不可能的，但是如果金属片的厚度可以忽略不计的话，我们可以把在流体中运动的非常薄的金属片视为本质上的低维。在这种情况下，通过应用[1.x.2644]方法（见[2.x.6827]）对[2.x.6826]施加弱边界条件。

这两种方法都有非常相似的要求，并导致高度相似的公式。因此，我们几乎以同样的方式对待它们。

在本教程中，我们对[2.x.6828]的进一步细节不感兴趣：我们假设嵌入域的尺寸（`dim`）总是比嵌入域的尺寸[2.x.6829]（`spacedim`）小一或相等。

我们要解决以下微分问题：给定[2.x.6830]上的一个足够规则的函数[2.x.6831]，找到[2.x.6832]的解。

[1.x.2645]



这个方程，我们通过缩放时间单位的方式将其规范化，使粘度的数值为1，描述了缓慢的粘性流动，如蜂蜜或岩浆。本教程的主要目的是展示如何用惩罚方法，以弱的方式将速度场条件[2.x.6833]强加于非匹配的[2.x.6834]。关于斯托克斯问题的更广泛的讨论，包括体力、不同的边界条件和解决策略，可以在步骤22中找到。

让我们开始单独考虑整个域[2.x.6835]中的斯托克斯问题。我们寻找一个速度场[2.x.6836]和一个压力场[2.x.6837]，满足斯托克斯方程和[2.x.6838]上的同质边界条件。

斯托克斯方程的微弱形式首先通过将其写成矢量形式而得到

[1.x.2646]

从左边开始与一个矢量值测试函数[2.x.6839]形成点积，并在域[2.x.6840]上进行积分，得到以下一组方程。

[1.x.2647]

这对所有的测试函数都必须成立 [2.x.6841] 。


通过部分积分并利用[2.x.6842]的边界条件，我们得到以下变分问题。

[1.x.2648]



其中[2.x.6843]代表[2.x.6844]标量积。这也是步骤22中使用的变异形式。

这个变分公式没有考虑到嵌入域。与step-60相反，我们并不强行执行[2.x.6845]对[2.x.6846]的约束，而是通过惩罚项弱行执行这些约束。

对这种弱强加边界条件的分析取决于[2.x.6847]的spacedim-dimensional度量是正的（如果`dim`等于`spacedim`）或零（如果`dim`小于`spacedim`）。我们讨论这两种情况。




[1.x.2649]

在这种情况下，我们假设[2.x.6848]是实际叶轮的边界，即嵌入二维域的封闭曲线或三维域的封闭表面。这种方法的思路首先是考虑在[2.x.6849]上弱加迪里切特边界条件，遵循尼采方法。这是通过在流体域上使用以下修改后的公式来实现的，其中没有对[2.x.6850]上的测试函数施加强条件。

[1.x.2650]



过[2.x.6851]的积分是低维积分。可以证明（见[2.x.6852]），存在一个正的常数[2.x.6853]，所以如果[2.x.6854]，边界的弱强加将是一致和稳定的。在[2.x.6855]上的前两个附加积分（上式中的第二行）在通过部分积分后自然出现，此时我们不假设[2.x.6856]在[2.x.6857]上是零。

上述方程中的第三行包含两个项，是为了确保弱形式的一致性而添加的，还有一个稳定项，是为了强制执行边界条件，其误差与近似误差一致。一致性项和稳定项是用实际的边界数据添加到右手边的 [2.x.6858] 。

当[2.x.6859]满足[2.x.6861]上的条件[2.x.6860]时，[2.x.6862]上的所有一致性和稳定性积分都被抵消，就剩下斯托克斯流的通常弱形式，也就是说，上述表述是一致的。

我们注意到，可以使用另一种（非对称的）表述方式。

[1.x.2651]

注意第三行和第四行的第一项的不同符号。在这种情况下，稳定性和一致性条件成为[2.x.6863] 。在对称情况下，[2.x.6864]的值取决于[2.x.6865]，一般来说，它被选择为[2.x.6866]，[2.x.6867]是衡量被整合面的大小，[2.x.6868]是一个常数，以便[2.x.6869] 。这就像人们通常使用Nitsche惩罚方法来执行Dirichlet边界条件一样。

另一方面，非对称方法与非连续Galerkin方法的非对称内部惩罚方法（"NIPG "方法[2.x.6870]）的连续性的执行方式有关。即使非对称情况在稳定参数的可能选择方面似乎更有优势，我们还是选择了对称离散化，因为在这种情况下，可以证明对偶问题也是一致的，导致解决方案不仅能量准则以正确的顺序收敛，而且其[2.x.6871]准则也是如此。此外，得到的矩阵仍然是对称的。

上述表述是在假设领域被精确离散的情况下进行的。然而，如果叶轮的变形是一个刚体运动，就有可能人为地将斯托克斯问题的解扩展到螺旋桨本身，因为刚体运动也是斯托克斯问题的解。我们的想法是在[2.x.6872]内解决同样的问题，在[2.x.6873]上施加同样的边界条件，使用同样的惩罚技术，并用在[2.x.6875]上全局连续的测试函数[2.x.6874]来测试。

这导致了以下（中间）配方。

[1.x.2652]

其中跳跃项，用[2.x.6876]表示，是相对于法向量[2.x.6877]的一个固定方向计算的。2的因子出现在[2.x.6878]前面，因为我们看到[2.x.6879]的每一部分两次，一次来自流体内部，一次来自在其中移动的障碍物。对于[2.x.6880]上的所有其他积分，我们对[2.x.6881]的每一部分都访问了两次，但符号相反，因此得到的是跳跃项）。

这里我们注意到，与不连续的Galerkin方法不同，测试和试验函数在[2.x.6882]中是连续的。此外，如果[2.x.6883]不与单元边界对齐，所有的跳跃项也是零，因为一般来说，有限元函数空间在每个单元内都是平滑的，如果[2.x.6884]只在有限的几个点上切过一个单元与它的边界相交，除了稳定化的贡献外，[2.x.6885]上的所有贡献都可以从公式中忽略掉，导致以下变量公式的最终形式。

[1.x.2653]



在step-60中，约束条件的施加需要以拉格朗日乘数的形式增加新的变量。本教程程序不存在这种情况。使用Nitsche方法施加边界条件只修改了系统矩阵和右手边，没有增加额外的未知数。然而，嵌入域上的速度矢量[2.x.6886]不会与规定的速度[2.x.6887]完全匹配，而只是达到一个数值误差，这个误差与有限元方法的插值误差相同。此外，与第60步一样，我们仍然需要在不匹配的嵌入网格上进行积分，以构建对[2.x.6888]施加边界条件的必要边界项。




[1.x.2654]

在这种情况下，[2.x.6889]具有相同的尺寸，但被嵌入到[2.x.6890]中。我们可以把它看作是一个在流体中移动的厚物体。在[2.x.6891]惩罚的情况下，额外的惩罚项可以被解释为[2.x.6892]内的达西项，结果是。

[1.x.2655]



这里，对[2.x.6893]的积分只是对部分体积的积分。因此，[2.x.6894]的惩罚包括增加一个体积项，约束流体的速度与[2.x.6895]内刚体的速度保持一致。在这种情况下，[2.x.6896]必须被选择得足够大，以确保[2.x.6897]中的迪里希特边界条件得到充分尊重，但也不能太高，以保持系统矩阵的适当调节。

一个[2.x.6898]的惩罚可以用类似的方式构建，在惩罚中加入一个粘性成分，以阻尼[2.x.6899]内的速度梯度。

[1.x.2656]



请注意，[2.x.6900]的惩罚（`dim`等于`spacedim`）和Nitsche的惩罚（`dim`等于`spacedim-1`）导致了完全相同的数值实现，这要感谢deal.II的独立维度能力。




[1.x.2657]

在本教程中，嵌入网格[2.x.6901]和嵌入网格都是用[2.x.6902]来描述的。这两个三角形可以通过GridGenerator命名空间中的函数来建立，或者通过读取其他应用程序（例如GMSH，见步骤-49的讨论）产生的网格文件来建立。这比之前在第60步中的做法略微通用了一些。

无论是在 "dim=spacedim "还是 "dim<spacedim "的情况下，增加沉没边界法，只是在系统矩阵和系统的右手边引入了额外的项，这些项是在[2.x.6903]上积分的结果。这并没有改变必须解决的问题的变量数量。因此，挑战与必须进行的积分有关 [2.x.6904] 。

在有限元中，我们将这个积分分成来自用于离散化[2.x.6905]的所有单元的贡献，我们将[2.x.6906]上的积分转换为参考元素[2.x.6907]上的积分，其中[2.x.6908]是[2.x.6909]到[2.x.6910]的映射，并使用正交公式计算[2.x.6911]上的积分。比如说。

[1.x.2658]

计算这个和是不容易的，因为我们必须评估[2.x.6912] 。一般来说，如果[2.x.6913]和[2.x.6914]没有对齐，那么[2.x.6915]这个点相对于[2.x.6916]来说是完全任意的，除非我们想出一个办法，将[2.x.6917]的所有基函数插在[2.x.6918]上的一个任意点上，否则我们无法计算出需要的积分。


要评估[2.x.6919]，需要采取以下步骤（如下图所示）。

- 对于[2.x.6921]中的一个给定单元[2.x.6920]，计算实点[2.x.6922]，其中[2.x.6923]是用于[2.x.6924]上的积分的正交点之一。这是最容易的部分。  [2.x.6925]给了我们所有正交点的实空间位置。

- 找到[2.x.6926]中[2.x.6927]所在的单元。我们将称这个元素为[2.x.6928] 。

- 找到[2.x.6929]内[2.x.6930]的参考坐标。为此，我们需要将参考元素[2.x.6932]转换为元素[2.x.6933]：[2.x.6934]的映射[2.x.6931]的逆映射。

- 评估 [2.x.6935] 网格在此点 [2.x.6937] 的基函数 [2.x.6936] 。这也是比较简单的，使用FEValues。


<p align="center"> <img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png" alt=""> [2.x.6938]

在步骤60中，上述第二至第四步是通过依次调用来计算的。

- [2.x.6939] 后面是

- [2.x.6940] 然后我们

- 构建一个自定义的正交公式，包含参考单元格中的点，然后

- 构建一个FEValues对象，具有给定的正交公式，并以第一步中获得的单元格为初始化。

虽然这种方法对目前的情况是可行的，但它并不适合于使用分布式三角形的平行模拟。事实上，由于嵌入域[2.x.6941]单元上的正交点的位置与嵌入三角形的位置不一致，而且[2.x.6942]是不断移动的，这就要求代表[2.x.6943]的三角形被完整地存储在所有处理器中。随着处理器的数量和[2.x.6944]中单元格数量的增加，这将导致内存方面的严重瓶颈。因此，在这一步骤中寻求一种替代策略。




[1.x.2659]

请记住，对于惩罚法（[2.x.6945]或[2.x.6946]）和尼采法，我们要计算的是由正交近似的积分。也就是说，我们需要计算

[1.x.2660] 如果你跟随上面的讨论，那么你会记得 [2.x.6947] 和 [2.x.6948] 是定义在流体网格上的形状函数。唯一定义在实体网格上的东西是。  [2.x.6949] ，是实体单元上正交点的位置，是[2.x.6950]的一部分，[2.x.6951]是其雅各布系数的行列式，[2.x.6952]是相应的正交权值。

现在要认识到的重要部分是这样的。  [2.x.6953]是正交公式的一个属性，不随时间变化。此外，[2.x.6954]的雅各布矩阵本身随着固体障碍物在流体中的移动而变化，但由于固体被认为是非变形的（它只是平移和旋转，但不扩张），雅各布矩阵的行列式保持不变。因此，乘积[2.x.6955]（我们通常用`JxW`表示）在每个正交点上都保持不变。因此，我们唯一需要跟踪的是位置[2.x.6956]--但这些位置随着实体域的速度移动。

换句话说，我们实际上根本不需要保留实体网格。我们所需要的只是位置[2.x.6957]和相应的`JxW`值。由于这两个属性都是附着在实体材料上的点属性（或点向量），它们可以被理想化为一组不相连的无限小的 "粒子"，它们随着实体的运动携带所需的`JxW`信息。deal.II有能力以ParticleHandler类的形式在大规模并行计算中分配和存储这样一组粒子（关于实现的细节见[2.x.6958] ），我们将在本教程中使用这一功能。

因此，本步骤采取的方法如下。

- 为域名 [2.x.6960] 创建一个 [2.x.6959] 。

- 在[2.x.6961]上的正交点位置创建[2.x.6962] 。

- 调用[2.x.6963]函数，将粒子分配到各个处理器上，*遵循实体三角形*的做法。

- 将 "JxW "值作为一个 "属性 "附加到每个[2.x.6964]对象。

这种结构的生成相对来说比较昂贵，但是每次模拟必须只生成一次。一旦[2.x.6965]被生成，并且所需的信息被附加到粒子上，就可以利用粒子在ParticleHandler内按单元分组的事实，对[2.x.6966]进行积分，使我们能够。

- 在[2.x.6967]中至少包含一个粒子的所有单元格上循环操作

- 循环处理给定单元中的所有粒子

- 计算积分并填充全局矩阵。

由于[2.x.6968]可以管理粒子从一个处理器到另一个处理器的交换，嵌入的三角形可以通过位移粒子而被移动或变形。与这种位移相关的唯一约束是，颗粒的位移距离不应大于一个单元的大小。这是因为这是[2.x.6969]能够追踪离开当前单元的粒子现在所处的单元的极限。

一旦整个问题（斯托克斯问题和沉没边界施加）被集合起来，最后的鞍点问题由迭代求解器解决，应用于舒尔补数[2.x.6970]（其构造例如在步骤22中描述），我们使用LinearOperator类构造[2.x.6971]。




[1.x.2661]

我们在这里解决的问题是对斯托克斯流的时间可逆性的证明。这在科学教育实验中经常用泰勒-库伊特流和染料液滴来说明，在流体以周期性的方式位移后，染料液滴又恢复到原来的形状。

[1.x.2662]



在目前的问题中，一个非常粘稠的流体被一个叶轮的旋转所搅动，在二维中，叶轮被一个矩形网格所模拟。叶轮旋转了一定的圈数，之后流动被逆转，从而在相反的方向上进行相同圈数的旋转。我们回顾一下，由于斯托克斯方程是自交的，蠕动流是可逆的。因此，如果叶轮运动在相反的方向上被逆转，流体应该回到其原来的位置。在本例中，我们通过插入一圈被动示踪剂颗粒来说明这一点，这些颗粒被流体平移并返回到原来的位置，从而证明了流动的时间可逆性。




[1.x.2663]

本教程程序使用了一些关于对流体内部的非匹配界面施加速度条件的技术。要了解更多的背景材料，你可能要查阅以下参考资料。  [2.x.6972] , [2.x.6973] , [2.x.6974] , [2.x.6975] , [2.x.6976] 。


examples/step-70/doc/results.dox



[1.x.2664]

运行该程序的目录中包含一些样本参数文件，你可以用它们来重现本节介绍的结果。如果你没有在命令行中指定参数文件作为参数，程序将默认尝试读取文件"`parameters.prm`"，并执行二维版本的代码。正如在源代码的讨论中所解释的那样，如果你的文件名包含字符串 "23"，那么程序将运行一个三维问题，即共维度为1的沉入式实体。如果文件名包含字符串 "3"，它将运行一个三维问题，同维度的沉浸实体为零，否则它将运行一个二维问题，同维度的沉浸实体为零。

无论具体的参数文件名是什么，如果指定的文件不存在，当你执行程序时，你会得到一个异常，即找不到这样的文件。

[1.x.2665]



然而，正如错误信息已经指出的，触发异常的代码也将生成指定的文件（"`parameters.prm`"在这种情况下），该文件仅仅包含这个程序关心的所有参数的默认值（对于正确的尺寸和辅助尺寸，根据文件名中是否包含字符串 "23 "或 "3"）。通过检查默认参数文件，我们看到以下内容。

[1.x.2666]



如果你现在运行该程序，你会在参数`Output directory`（默认为当前目录）指定的目录下得到一个名为`parameters_22.prm`的文件，其中包含上述参数的简短版本（没有注释和文档），记录了所有用于运行程序的参数。

[1.x.2667]



首先创建 "parameters.prm "文件（程序第一次运行时），然后创建 "output/parameters_22.prm "文件（每次使用现有的输入文件运行程序时），这是因为你可能想把大多数参数保留为默认值，只修改其中的一小部分，同时仍然能够重现结果，检查特定模拟使用了哪些参数。一般来说，将用于模拟的参数文件与模拟输出一起保存起来是很好的科学做法，这样你就可以在以后的时间里重复相同的运行。

另一个原因是输入文件可能只包含那些与默认值不同的参数。例如，你可以在本教程程序中使用以下（完全有效的）参数文件。

[1.x.2668]

你将使用Q3/Q2 Taylor-Hood有限元运行程序，进行101步，使用Nitsche惩罚为`10`，并将所有其他参数保持为默认值。输出目录不仅包含了这些参数的记录，而且包含了仿真中使用的所有参数。你可以在生成的文件`parameters_22.prm`中查看所有其他参数。




[1.x.2669]

默认问题产生了一个同维度的零叶轮，由一个旋转的矩形网格组成，在一个方向上旋转半个时间单位，在相反方向上旋转半个时间单位，恒定的角速度等于[2.x.6977] 。因此，叶轮做了半个旋转，并返回到原来的位置。下面的动画显示了速度的大小，固体叶轮和示踪粒子的运动。


<p align="center"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-70.2d_tracing.gif" alt="" width="500"> </div> [2.x.6978]

在一个核心上，程序的输出将看起来像下面这样。

[1.x.2670]



你可能会注意到，组装耦合系统比组装斯托克斯部分更昂贵。这在很大程度上取决于用于应用Nitsche限制的高斯点（固体粒子）的数量。在目前的情况下，所使用的示踪粒子的数量相对较少。因此，跟踪它们的运动是相对便宜的。

下面的影片显示了解决方案随时间的演变。

[1.x.2671]



这部电影显示了灰色的旋转障碍物（实际上是用足够大的点绘制的固体粒子的叠加，使它们重叠），浅色的[1.x.2672]（包括在模拟过程中特定时间形成的角顶点），以及蓝色色调的示踪粒子。

模拟结果显示，在结束的时候，示踪剂颗粒已经在一定程度上回到了原来的位置，尽管它们已经被流场扭曲了。下面的图片比较了粒子在一个时间单位的流动后的初始和最终位置。

<p align="center"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-70.tracer_comparison.png" alt="" width="500"> </div> [2.x.6979]

在这种情况下，我们看到在叶轮扫过的体积之外的示踪剂颗粒已经非常接近它们的初始位置，而在扫过的体积内的示踪剂颗粒的变形略大。这种变形是非物理性的。它是由用于平移粒子的显式欧拉方案引起的数值误差、由虚构领域引起的精度损失以及最后由斯托克斯方程的离散化误差引起的。前两个错误是造成这种变形的主要原因，它们可以通过使用更细的网格和更小的时间步长来缓解。




[1.x.2673]

为了玩一玩，我们将虚构的领域复杂化（取自https://grabcad.com/library/lungstors-blower-1），并在三个空间维度上运行共维一模拟，使用以下"`参数_23.prm`"文件。

[1.x.2674]



在这种情况下，定时输出有点不同。

[1.x.2675]



现在，求解器在三维空间中占用了大部分的求解时间，就运行时间而言，粒子运动和Nitsche装配仍然相对不重要。




[1.x.2676]




[1.x.2677]

[1.x.2678]

目前的教程程序显示了流体和固体之间的单向耦合，其中固体运动是强加的（而不是求解的），并通过利用固体正交点的位置和权重在固体域中读取。

代码的结构已经允许人们通过利用读取实体网格正交点上流体速度值的可能性来实现双向耦合。为了提高MPI通信模式的效率，我们应该将正交点的所有权保持在实体处理器上，该处理器拥有创建这些正交点的单元。在目前的代码中，通过使用实体分区而不是初始流体分区来定义用于交换正交点信息的向量索引集就足够了。

这使得本教程程序中使用的技术与教程步骤-60中提出的技术相结合，以解决带有分布式拉格朗日乘数的流体结构交互问题，在[2.x.6980]对象上。

上面的时间显示，目前的预处理策略对Nitsche惩罚的效果并不好，如果我们想瞄准更大的问题，我们应该想出一个更好的预处理方法。此外，应该实施检查点重启策略，以允许较长的模拟被中断和恢复，例如在step-69教程中就是这样做的。


examples/step-71/doc/intro.dox

[2.x.6981]

[1.x.2679]




[1.x.2680]

本教程的目的很简单，就是介绍[自动](https://en.wikipedia.org/wiki/Automatic_differentiation)和[符号微分](https://en.wikipedia.org/wiki/Computer_algebra)（分别缩写为AD和SD）的基本原理。人们可以在源代码中描述一个函数[2.x.6982]，并自动获得导数[2.x.6983]（"Jacobian"）、[2.x.6984]（"Hessian"）等的表示方法，而无需编写额外的代码行。这样做对解决非线性或优化问题很有帮助，因为人们希望在代码中只描述非线性方程或目标函数，而不必同时提供它们的导数（这对解决非线性问题的牛顿方法或寻找最小化器是必要的）。

由于AD和SD工具在某种程度上独立于有限元和边界值问题，本教程将与你之前可能读过的其他教程不同。它将特别关注这些框架是如何工作的，以及它们背后的原理和思想，并放弃在有限元模拟的直接背景下看待它们。

事实上，我们将研究两组不同的问题，它们的复杂程度大不相同，但当框架正确时，有足够的相似性，同样的AD和SD框架可以被利用。通过这些例子，我们的目的是建立起对使用AD和SD工具所需步骤的理解，以及它们之间的区别，并希望能找出它们可以立即用于改进或简化现有代码的地方。

你想知道什么是AD和SD，这是可信的，首先。好吧，这个问题很容易回答，但如果没有上下文，就没有很好的洞察力。因此，我们不打算在这个介绍中涉及这个问题，而是将其推迟到第一个介绍性的例子中，在这个例子的展开过程中，我们将列出关键点。作为补充，我们应该提到，这两个框架的核心理论在[2.x.6985]模块中都有广泛的讨论，所以在此不需要重复。

由于我们必须挑选*个足够有趣的课题来研究，并确定AD和SD在哪里可以有效地使用，所以在教程的后半部分实现的主要问题是对一个耦合的构成法进行建模，特别是一个磁活性材料（具有滞后效应）。作为一种介绍的手段，在介绍的后面将介绍该类材料的一些基础理论。自然，这不是一个广泛受众感兴趣的领域（甚至不是一类材料）。因此，作者希望在前面表示，这个理论和任何后续的推导都不能被认为是本教程的重点。相反，请牢记从相对无害的构成法则描述中产生的问题的复杂性，以及我们可能（在边界值问题的背景下）需要从中推导出什么。我们将在一个有代表性的连续体点的水平上用这些构成法则进行一些计算（所以，仍然是在连续体力学的领域），并将产生一些基准结果，我们可以围绕这些结果对计算性能的主题进行最后讨论。

一旦我们有了可以建立进一步概念的基础，我们将看到如何在有限元（而不是连续体）水平上特别利用AD：这是在步骤-72和步骤-33中涉及的一个主题。但在此之前，让我们花点时间思考一下为什么我们可能要考虑使用这些工具，以及它们可能给你带来什么好处。




[1.x.2681]

使用AD或SD的主要驱动力通常是，有一些情况需要进行区分，而且这样做有足够的挑战性，使得使用外部工具来执行该特定任务的前景具有吸引力。对AD或SD最有用的情况进行广泛分类，包括（但可能不限于）以下情况。

- [1.x.2682]对于一类新的问题，你试图快速实现一个解决方案，并希望去除一些复杂的细节（在数学以及代码本身的组织结构方面）。你可能愿意证明任何额外的计算成本是合理的，这将被重组你的代码或修改问题中引入一些复杂的非线性的部分的敏捷性所抵消，只需最小的努力。

- [1.x.2683]很可能有些问题恰好有一个非线性，对线性化或手工制定有极大的挑战。   让一个在大多数情况下稳健、可靠和准确的工具来为你解决这个挑战，可能会减轻实现某些问题的痛苦。这方面的例子包括第15步，我们解决的非线性PDE的导数并不难推导，但足够繁琐，以至于人们在手工操作时必须注意，而且实现牛顿步骤的相应有限元公式所需的时间不仅仅是实现双线性形式一般所需的几行；第33步（我们实际使用AD）是一个更极端的例子。

- [1.x.2684] 对于表现出非线性响应的材料和模拟，准确而非近似的材料切线（机械工程师对材料定律的导数使用的术语）可能是收敛和发散行为之间的区别，特别是在高外部（或耦合）载荷下。   随着问题复杂性的增加，引入细微的（或者，也许不是那么细微的）错误的机会也在增加，这些错误会产生可预见的负面结果。   此外，通过验证实现是完全正确的，也有很多好处。例如，某些类别的问题已知会表现出不稳定性，因此，当你在非线性求解器（例如牛顿方法）中开始失去二次收敛时，那么这对研究者来说可能不是一个巨大的惊喜。然而，很难（如果不是不可能）区分以下两种收敛行为：一种是你接近不稳定的解时产生的收敛行为，另一种是你在材料或有限元线性化中出现了错误，并因此开始偏离最佳收敛路径。例如，拥有一种验证构成法线性化实现的正确性的方法，也许是你用来捕捉这种错误的唯一有意义的方法，假设你没有其他人来检查你的代码。   值得庆幸的是，通过一些战术性的编程，可以很直接地将代码结构化以便重复使用，这样你就可以在生产代码中使用相同的类，并直接在例如单元测试框架中验证它们。

这个教程程序将有两个部分。一部分，我们只是用一组简单的例子来介绍deal.II中自动和符号微分支持的基本思想；另一部分，我们将其应用于一个现实的但更复杂的案例。对于这后半部分，下一节将提供一些关于磁性机械材料的背景--如果你想了解的只是AD和SD的实际情况，你可以跳过这一节，但如果你对如何将AD和SD应用于具体的情况感兴趣，你可能想读完这一节。




[1.x.2685]

[1.x.2686]

作为介绍我们将用来为磁活性聚合物建模的磁-机械耦合材料法的前奏，我们将首先对这些构成法则必须认同的突出的热力学进行非常简洁的总结。这里总结的理论基础，由Truesdell和Toupin [2.x.6986] 以及Coleman和Noll [2.x.6987] 详细描述，并遵循Holzapfel [2.x.6988] 所提出的逻辑。

从热力学第一定律出发，并遵循一些技术假设，可以证明动能加内能率与外部来源提供给系统的功率之间的平衡是由以下关系给出的，即左边是一个（任意）体积[2.x.6989]的能量变化率，右边是作用于该体积的力的总和。

[1.x.2687]

这里[2.x.6990]代表总的时间导数，[2.x.6991]是在拉格朗日参考框架下测量的材料密度，[2.x.6992]是材料速度，[2.x.6993]是其加速度，[2.x.6994]是每单位参考体积的内能，[2.x.6995]是总皮拉应力张量，[2.x.6996]是变形梯度张量的时间速率，[2.x.6997]和[2.x.6998]分别是磁场向量和磁感应（或磁通密度）向量，[2.x.6999]和[2.x.7000]是电场向量和电位移向量，[2.x.7001]和[2.x.7002]代表参考热通向量和热源。材料微分算子[2.x.7003]，其中[2.x.7004]是材料位置向量。通过一些条款的重排，引用积分体积[2.x.7005]的任意性，总的内部能量密度率[2.x.7006]可以被确定为

[1.x.2688]

总的内能不仅包括由于机械变形（第一项）、热通量和热源（第四项和第五项）而产生的贡献，还包括由于储存在磁场和电场本身的内在能量（分别为第二项和第三项）。

热力学第二定律，也被称为熵不平等原则，告诉我们某些热力学过程是不可逆的。在考虑了总熵和熵输入的速度后，可以得出克劳修斯-杜姆不等式。在局部形式下（以及在物质配置中），其内容为

[1.x.2689]

量[2.x.7007]是绝对温度，[2.x.7008]代表每单位参考体积的熵值。

用它来代替热力学第一定律结果中的[2.x.7009]，我们现在有了这样的关系

[1.x.2690]

傅里叶定律告诉我们，热量从高温区域流向低温区域，根据这一定律，最后一项总是正的，可以忽略不计。这使得局部耗散的不等式变成了

[1.x.2691]

据推测[2.x.7010]，Legendre变换

[1.x.2692]

从中我们可以定义具有所述参数化的自由能密度函数[2.x.7011]，它存在并且有效。取此方程的材料速率并将其代入局部耗散不等式，结果是通用表达式

[1.x.2693]

在等温条件的假设下，并且电场不会以一种被认为是不可忽视的方式激发材料，那么这个耗散不等式就会简化为

[1.x.2694]



[1.x.2695]

当考虑到表现出机械耗散行为的材料时，可以证明这可以通过用代表内部变量的额外参数增加材料自由能密度函数的方式在耗散不等式中得到体现 [2.x.7012] 。因此，我们把它写成

[1.x.2696]

其中[2.x.7013]代表与第i个机械耗散（粘性）机制相关的内部变量（其作用类似于变形梯度的测量）。从它的参数化可以推断出，这些内部参数中的每一个都被认为是在时间中演变的。目前，自由能密度函数[2.x.7014]是以磁感应[2.x.7015]为参数的。这是自然的参数化，是所考虑的平衡法的结果。如果这样一类材料被纳入到有限元模型中，将确定需要采用某种磁问题的表述，即磁矢量势表述。这有它自己的一套挑战，所以在可能的情况下，更简单的磁标量势表述可能是首选。在这种情况下，磁性问题需要在磁场方面进行参数化 [2.x.7016] 。为了进行这种重新参数化，我们执行最后的Legendre变换

[1.x.2697]

同时，我们可以利用材料框架无所谓的原则，以便用对称的变形措施来表达能量密度函数。

[1.x.2698]

这两个转换的结果（撇开相当多的明确和隐藏的细节）使减少耗散不等式的最终表达式为

[1.x.2699]

注意右侧第二项的符号变化，以及时间导数向磁感应矢量的转移）。应力量[2.x.7017]被称为总Piola-Kirchhoff应力张量，其能量共轭物[2.x.7018]是右Cauchy-Green变形张量，[2.x.7019]是与`i`th机械耗散（粘性）机制相关的重新参数化内部变量。

对能量密度函数的材料速率进行扩展，并对各种项进行重排，得出的表达式是

[1.x.2700]

在这一点上，值得注意的是[偏导数](https://en.wikipedia.org/wiki/Partial_derivative) [2.x.7020] 的使用。这是一个重要的细节，对于本教程中的某个设计选择是很重要的。简单提醒一下这意味着什么，一个多变量函数的偏导返回该函数相对于其中一个变量的导数，而其他变量保持不变。

[1.x.2701]

更具体到耗散不等式所编码的内容（用非常普遍的自由能密度函数[2.x.7021]，其参数化尚待正式确定），如果输入变量之一是另一个变量的函数，它也被保持不变，链式规则不再传播，而计算总导数将意味着明智地使用链式规则。通过比较以下两个语句可以更好地理解这一点。

[1.x.2702]



回到问题的热力学，我们接下来利用数量的任意性 [2.x.7022] 和 [2.x.7023] ，通过应用科尔曼-诺尔程序 [2.x.7024] ， [2.x.7025] 。这导致了对动力学共轭量的识别

[1.x.2703]

(再次注意，在这个广义的设置中，使用偏导数来定义应力和磁感应)。从耗散功率中剩下的条款（即那些与机械耗散机制有关的条款）来看，如果假定它们是相互独立的，那么，对于每个机制`i`。

[1.x.2704]

这一约束必须通过适当选择自由能函数以及仔细考虑内部变量的演化规律来满足。

在构成模型中没有耗散机制的情况下（例如，如果要建模的材料是磁超弹性的），那么自由能密度函数[2.x.7026]减少到存储能量密度函数，总应力和磁感应可以被简化

[1.x.2705]

其中算子[2.x.7027]表示总导数操作。

为了完整起见，应力张量和磁感应的线性化在四阶总参考弹性张量[2.x.7028]、二阶磁静力张量[2.x.7029]和三阶总参考磁弹性耦合张量[2.x.7030]中得到体现。无论[2.x.7031]和[2.x.7032]的参数化如何，这些量都可以通过以下方式计算出来

[1.x.2706]

对于速率依赖性材料的情况，这扩展为

[1.x.2707]

而对于与速率无关的材料，其线性化为

[1.x.2708]

它们之间的微妙区别是在计算第一个导数时应用了偏导。我们稍后会看到这对这个具体应用中AD与SD的选择有什么影响。现在，我们将简单介绍在本教程中实现的两种具体材料。

[1.x.2709]

我们要考虑的第一种材料是受磁超弹性构成法支配的材料。这种材料对变形和浸泡在磁场中都有反应，但没有表现出时间或历史相关的行为（如通过粘性阻尼或磁滞的耗散，等等）。这种材料的*存储能量密度函数*只以（当前）场变量为参数，而不是它们的时间导数或过去的值。

我们将选择能量密度函数，它既能捕捉到由于变形和磁化而储存在材料中的能量，也能捕捉到储存在磁场本身的能量，它是

[1.x.2710]

与

[1.x.2711]

其中变量[2.x.7033]（[2.x.7034]是秩-2身份张量）代表空间维度，[2.x.7035]是变形梯度张量。为了给[2.x.7036]的各个组成部分提供一些简单的背景，前两个项与（超弹性）Neohookean材料的储能密度函数非常相似。这里使用的东西与Neohookean材料的唯一区别是弹性剪切模量被磁场敏感的饱和函数[2.x.7037]缩放（见[2.x.7038]，公式29）。这个函数实际上将导致材料在强磁场的存在下变硬。由于它受一个sigmoid型函数的支配，剪切模量将渐进地收敛于指定的饱和剪切模量。还可以证明，[2.x.7039]中的最后一项是磁场的储能密度函数（从第一原理中得出），由相对渗透率常数缩放。这个定义共同意味着材料是线性磁化的，也就是说，磁化矢量和磁场矢量是对齐的。(这在以电流形式陈述的磁能中当然不明显，但当磁感应和磁化从[2.x.7040]中导出，并且所有磁场都以[2.x.7041]的电流配置[2.x.7042]表示时，这种关联性就变得很清楚了)。至于磁感应、应力张量和各种材料切线的具体内容，我们将把这些内容推迟到教程正文中介绍，在那里定义了构成法的完整、无辅助的实施。

[1.x.2712]

我们将制定的第二个材料是一个具有单一耗散机制`i`的磁-粘弹性材料。我们将考虑的*自由能量密度函数*被定义为

[1.x.2713]

与

[1.x.2714]



[1.x.2715]

和进化法

[1.x.2716]

为内部粘性变量。我们已经选择了能量的磁弹性部分[2.x.7043]来匹配我们探索的第一个材料模型，所以这部分不需要进一步解释。至于粘性部分[2.x.7044]，自由能的这一部分（与粘性变形张量的演化规律一起）取自[2.x.7045]（由[2.x.7046]中描述的粘性饱和函数进行额外缩放）。它是在一个热力学上一致的框架中得出的，其核心是在微观层面上模拟聚合物链的运动。

要超越这一点，我们还需要考虑进化规律的时间离散化。选择隐式一阶逆向差分方案，那么

[1.x.2717]

其中上标[2.x.7047]表示该数量是在当前时间步长中提取的，[2.x.7048]表示在前一时间步长中提取的数量（即历史变量）。时间段大小[2.x.7049]是当前时间与上一时间段的差。将这些条款重新排列，使当前时间的所有内部变量量都在方程的左侧，我们可以得到

[1.x.2718]

匹配[2.x.7050]公式54。

[1.x.2719]

现在我们已经展示了所有这些关于热力学和磁力学理论以及构成模型的公式，让我们概述一下这个程序将对所有这些做什么。我们希望对我们制定的材料定律做一些*有意义的事情，因此将它们置于一些机械和磁载荷条件下是有意义的，这些条件在某种程度上代表了在应用或实验室环境中可能发现的一些条件。实现这一目标的方法之一是将这些构成法则嵌入到有限元模型中，以模拟一个设备。不过，在这个例子中，我们将保持简单（毕竟我们关注的是自动和符号微分概念），并将找到一种简明的方法，使用加载条件的分析表达式忠实地复制工业标准的流变学实验。

我们将重现的流变学实验，它理想化了一个用于表征磁活性聚合物的实验室实验，详见[2.x.7051]（以及[2.x.7052]，其中与真实世界的实验一起记录）。下面的图片提供了对问题设置的直观描述。

[2.x.7053]

假设正在测试的是不可压缩的介质，并且通过样品厚度的变形曲线是线性的，那么在样品内某个测量点[2.x.7054]的位移，用径向坐标表示，就是

[1.x.2720]

其中[2.x.7055]和[2.x.7056]是半径在

-- 的角度，[2.x.7057]是（恒定的）轴向变形，[2.x.7058]是每单位长度的随时间变化的扭转角，将使用固定振幅的正弦波重复振荡[2.x.7059]来规定。磁场是轴向排列的，即在[2.x.7060]方向。

这总结了我们在流变样品内任何一点上全面描述理想化载荷所需的一切。我们将以这样的方式设置问题，即我们在这个样品中 "挑选 "一个有代表性的点，并使其在恒定的轴向变形（默认为压缩载荷）和恒定的、轴向施加的磁场中受到谐波剪切变形。我们将记录该点的应力和磁感应强度，并将数据输出到文件中进行后处理。尽管对这个特定的问题来说没有必要，我们也将计算切线。尽管它们没有直接用于这个特定的工作，但这些二阶导数是在有限元模型中嵌入构成法所需要的（这项工作的一个可能的扩展）。因此，我们将利用这个机会，用辅助微分框架来检查我们的手工计算是否正确。

[1.x.2721]

除了已经提到的[2.x.7061]模块外，以下是一些更详细讨论的参考资料

- 磁力学，以及自动分化框架的某些方面。  [2.x.7062] , [2.x.7063] , 和

- 使用AD和/或SD实现有限元框架的自动化： [2.x.7064] , [2.x.7065] 。

[2.x.7066]


examples/step-71/doc/results.dox



[1.x.2722]

[1.x.2723]

第一个探索性的例子产生了以下输出。经核实，这三种实现方式产生的结果是相同的。

[1.x.2724]



[1.x.2725]

为了帮助总结虚拟实验本身的结果，下面是一些图表，显示了材料样品内选定位置的剪切应力，与剪切应变的关系。这些图表显示了在三种不同的磁载荷下的应力-应变曲线，以及（机械）载荷曲线的最后一个周期，当速率依赖型材料达到可重复（"稳态"）响应时。这些类型的图表通常被称为[Lissajous plots](https://en.wikipedia.org/wiki/Lissajous_curve)。粘弹性材料的曲线所呈现的椭圆面积提供了某种衡量材料耗散能量多少的方法，其椭圆度表明粘性反应相对于弹性反应的相位变化。

[2.x.7067]

看到磁弹性材料的反应有一个与加载曲线相匹配的卸载曲线并不奇怪--毕竟该材料是非耗散性的。但在这里可以清楚地注意到，随着施加磁场的增加，曲线的梯度是如何增加的。沿着这条曲线任何一点的切线都与瞬时剪切模量有关，由于能量密度函数的定义方式，我们预计剪切模量会随着磁场强度的增加而增加。我们观察到磁-粘弹性材料的行为大致相同。由加载-卸载曲线追踪的椭圆的主轴有一个斜率，随着施加更大的磁载荷而增加。同时，材料耗散的能量也越多。

至于代码输出，这是打印到控制台的与磁弹性材料进行的流变学实验有关的部分的内容。

[1.x.2726]



而这部分输出与用磁涡流材料进行的实验有关。

[1.x.2727]



计时器的输出也被发射到控制台，因此我们可以比较进行手工计算和辅助计算所需的时间，并对使用AD和SD框架的开销有一些了解。下面是使用AD框架的磁弹性实验的时间，基于Trilinos库的Sacado组件。

[1.x.2728]

关于使用自动微分进行的计算（作为提醒，这是使用Sacado库结合动态前向自动微分类型进行的两级微分），我们观察到辅助计算需要大约[2.x.7068]的时间来计算所需的数量。这看起来确实是一个相当大的开销，但是，正如介绍中提到的，这是否可以接受，完全是主观的，取决于环境的。在对导数进行必要的手工计算、验证其正确性、实现它们以及验证实现的正确性方面，你是否更看重计算机时间而不是人的时间？如果你开发的研究代码只在相对较少的实验中运行，你可能更看重自己的时间。如果你开发的是一个将在万核集群上反复运行数小时的生产代码，你的考虑可能就不同了。在任何情况下，AD方法的一个很好的特点是，当函数和类在标量类型上被模板化时，有 "滴入 "能力。这意味着开始使用它需要付出最小的努力。

相比之下，使用准时制（JIT）编译的符号代数实现的磁涡弹材料的时间表明，在初始化过程中付出一些不可忽视的代价，计算本身的执行效率要高得多。

[1.x.2729]

由于初始化阶段很可能只需要在每个线程中执行一次，这个初始的昂贵阶段可以通过重复使用一个[2.x.7069]实例来抵消。尽管与磁弹性构成法相比，磁弹性构成法有更多的条款需要计算，但它在执行动能变量和切线的计算方面仍然快了一个数量级。而与使用缓存方案的手工计算变量相比，计算时间几乎相等。因此，尽管使用符号框架需要在如何实现和操作符号表达方面进行范式转变，但它可以提供AD框架所缺乏的良好性能和灵活性。

在数据缓存这一点上，事实上，在用这种材料进行的数值实验中，与使用中间值的实现相比，磁涡流材料实现的数值缓存所增加的成本大约是[2.x.7070]，在`update_internal_data()`中花费的时间增加。下面是删除缓存数据结构时为 "手工计算 "变体提取的时间比较样本输出。

[1.x.2730]



通过一些小的调整，我们可以很容易地测试批量优化器的不同优化方案。因此，让我们比较一下与 "LLVM "批处理优化器设置相关的计算费用和其他方案。下面是 "lambda "优化方法的时间报告（保留了CSE的使用）。

[1.x.2731]

这里的主要观察结果是，与 "LLVM "方法相比，在 "辅助计算 "部分花费的时间要多一个数量级。

最后，我们将测试 "字典 "替换与CSE的结合情况。字典替换只是在本地CAS框架内进行了所有的评估，没有对底层数据结构进行任何转换。在这种情况下，只有使用缓存中间结果的CSE才能提供任何 "加速"。考虑到这一点，下面是这个选择的结果。

[1.x.2732]

不用说，与其他两种方法相比，这些结果花了相当多的时间来产生......字典 "替换方法也许只适用于简单的表达式，或者当调用的数量足够少的时候。

[1.x.2733]

也许你已经相信这些工具有一些优点，并能对你有直接的帮助或用途。现在明显的问题是要使用哪一个。特别是在连续点水平上，你将使用这些框架来计算构成法的导数，我们可以说以下几点。

- 自动区分可能提供了进入辅助区分世界的最简单的切入点。

- 考虑到一个构成框架的足够通用的实现，AD通常可以被用作内在标量类型的替代品，然后可以利用辅助类来计算一阶（以及可能的高阶）导数，只需付出最小的努力。

- 作为对上述观点的限定，"直接替换 "并不意味着你必须对这些数字所通过的算法不持争议态度。有可能在不经意间进行的操作，在进行区分时，会返回一个错误的结果。   所以这绝对是一个人应该注意的事情。   一个具体的例子。当计算一个张量的特征值时，如果该张量是对角线的，那么得到结果的捷径就是直接返回对角线条目（从输入张量中提取的）。就计算特征值本身而言，这是完全正确的，但是不通过算法来计算非对角线张量的特征值会产生意想不到的副作用，即特征值看起来（对AD框架而言）是完全相互脱钩的，它们的交叉敏感度没有被编码在返回的结果中。在进行微分时，导数张量的许多条目将被丢失。为了解决这个问题，我们必须确保使用标准的特征值求解算法，这样返回的特征值对彼此的敏感性就会在结果中得到编码。

- 涉及AD数字类型的计算可能很昂贵。随着微分运算顺序的增加，费用也会增加（有时相当可观）。这可能会被周围操作的计算复杂性所缓解（例如线性求解），但最终还是要看具体问题。

- AD被限制在只需要总导数的情况下。如果一个微分运算需要相对于自变量的偏导，那么使用它是不合适的。

- 每个AD库都有自己的怪癖（说起来很悲哀，但根据作者的经验，是真的），所以可能需要一些试验和错误来找到合适的库和选择AD号来满足你的目的。这些 "怪癖 "的原因往往归结于库背后的整体理念（数据结构、模板元编程的使用等）以及导数计算的数学实现（例如，使用对数函数改变基础的结果操作可能会限制输入值的域--当然，细节都是对用户隐藏的）。   此外，一个库可能比另一个库能更快地计算出所需的结果，所以在这方面进行一些初步探索可能是有益的。

- 符号微分（好吧，一般来说，使用CAS）提供了最灵活的框架，可以进行辅助计算。

- SD框架可以做AD框架能做的所有事情，还有一个好处是可以对何时进行某些操纵和操作进行低层次控制。

- 加速表达式的评估是可能的，与一些手工实现相比，有可能导致SD框架接近原生的性能（当然，这种比较取决于整个程序设计），但代价是初始优化调用。

- 巧妙地使用[2.x.7071]可以将优化依赖表达式的昂贵调用的费用降到最低。   对[2.x.7072]进行序列化的可能性，往往（但不总是）这种昂贵的调用可以做一次，然后在以后的模拟中重复使用。

- 例如，如果两个或更多的材料法只因其材料参数而不同，那么只要这些材料参数被认为是象征性的，就可以在它们之间共享一个批次优化器。这意味着你可以 "区分一次，在许多情况下评估"。

- SD框架可以部分地被用作标量类型的 "直接替换"，但人们（至少）必须在它周围增加一些框架来执行值替换步骤，将符号类型转换为它们的数字对应物。

- 在一些专门的算法中可能无法使用SD数字。   例如，如果一个算法的退出点或代码分支是基于（符号）输入参数应该采取的一些具体的数值，那么显然这是不可能的。我们要么重新实现专门针对SD数字类型的算法（有点不方便，但经常是可能的，因为[2.x.7073]类支持条件反射），要么必须使用创造性的手段来解决这个具体问题（例如，引入一个符号表达式来表示这个算法返回的结果，如果在要使用它的环境中是有意义的，也许可以将它声明为一个[符号函数]（https://dealii.org/developer/doxygen/deal.II/namespaceDifferentiation_1_1SD.html#a876041f6048705c7a8ad0855cdb1bd7a）。这以后可以用它的数值来替代，如果宣布为符号函数，那么它的递延导数也可以作为替代的结果纳入计算中。)

- 使用SD的最大缺点是，使用它需要一个范式的转变，人们必须以不同的方式来构建大多数问题，以便充分利用它。仔细考虑如何使用和重用数据结构也是让它有效工作的关键）。这可能意味着，人们需要对它进行一番玩耍，并建立起对典型操作顺序的理解，以及每一步在操作基础数据方面的具体作用。如果人们有时间和意愿这样做，那么使用这个工具的好处可能是巨大的。

[1.x.2734]

有几个合乎逻辑的方法可以扩展这个计划。

- 也许最明显的扩展是实施和测试其他构成模型。   这可能仍然属于磁-机械耦合问题的范畴，也许可以考虑替代能量函数的 "Neo-Hookean "型弹性部分，改变耗散能量的构成法则（及其相关的演化法则），或者包括磁滞效应或这些材料试图模拟的复合聚合物的损坏模型。

- 当然，所实现的模型可以被修改或完全替换为专注于物理学其他方面的模型，如电活性聚合物、生物力学材料、弹塑性介质等。

- 对粘弹性演化法实施不同的时间微调方案。

- 与其直接从能量密度函数推导出一切，不如使用[2.x.7074]直接线性化动力学量。   这将意味着只需要一个可微分的自动微分的数字类型，并且肯定会大大改善性能。   这种方法也为耗散材料提供了机会，比如这里考虑的磁涡弹材料，可以与AD结合起来实现。这是因为线性化调用了因变量相对于场变量的总导数，这正是AD框架所能提供的。

- 调查使用其他可自动微分的数字类型和框架（如ADOL-C）。由于每个AD库都有自己的实现，选择使用哪个库可能会导致性能的提高，在最不幸的情况下，计算也会更加稳定。至少可以说，对于deal.II支持的AD库，结果的准确性应该基本不受这个决定的影响。

- 在有限元模拟中嵌入这些构成法则中的一个。

如果不费吹灰之力，人们可以考虑重新编写非线性问题求解器，比如在步骤15中实现的使用AD或SD方法来计算牛顿矩阵的求解器。事实上，这在第72步中已经完成。


examples/step-72/doc/intro.dox

[2.x.7075]

[1.x.2735]




[1.x.2736]

[1.x.2737]

这个程序解决的问题与步骤15相同，即求解[最小表面方程](https://en.wikipedia.org/wiki/Minimal_surface) [1.x.2738]



我们在那里发现的问题（见[1.x.2739]部分）是，当想要使用牛顿迭代时，我们需要计算方程残差对解的导数[2.x.7076]（这里，因为右手边是零，残差只是左手边）。对于我们这里的方程来说，这很麻烦，但并非不可能 -- 但我们很容易想象出更复杂的方程，仅仅正确实现残差本身就是一个挑战，更不用说为计算雅各布矩阵所需的导数而这样做。我们将在这个程序中解决这个问题。使用在步骤-71中详细讨论的自动微分技术，我们将想出一个办法，我们只需要实现残差，就可以免费得到雅各布矩阵。

事实上，我们甚至可以更进一步。虽然在第15步中，我们只是把方程作为一个给定值，但最小表面方程实际上是最小化一个能量的产物。具体来说，最小曲面方程是对应于最小化能量的欧拉-拉格朗日方程[1.x.2740]

其中*能量密度*由[1.x.2741]给出。

这等于说，我们寻求找到能量函数变化的静止点[1.x.2742] 。

因为这是边界值问题的平衡解所在。

那么关键的一点是，也许，我们甚至不需要实现残差，但实现更简单的能量密度[2.x.7077]可能实际上已经足够了。

那么我们的目标是这样的。当使用牛顿迭代时，我们需要反复解决线性偏微分方程[1.x.2743]。

这样我们就可以计算出更新[1.x.2744]。

与牛顿步骤的解[2.x.7078]。正如步骤15所讨论的，我们可以用手计算导数[2.x.7079]，得到[1.x.2745]。



那么，这里就是这个计划的内容。它是关于可以帮助我们计算[2.x.7080]的技术，而不必明确地实现它，要么提供[2.x.7081]的实现，要么提供[2.x.7082] 的实现。更确切地说，我们将实现三种不同的方法，并在运行时间方面进行比较，但同时--也许更重要的是--实现这些方法需要多少人力。

- 第15步中使用的方法，形成雅各布矩阵。

- 从残差[2.x.7083]的实现中计算雅各布矩阵，使用自动微分法。

- 从能量函数[2.x.7084]的实现中计算残差和雅各布矩阵，也使用自动微分法。

对于这些方法中的第一个，与步骤15相比，没有任何概念上的变化。




[1.x.2746]

对于第二种方法，让我们概述一下我们将如何利用自动微分来计算残差向量的线性化。为此，让我们暂时改变一下符号，用[2.x.7085]表示的不是微分方程的残差，而实际上是*残差向量*，即*离散残差。我们这样做是因为当我们在给定的网格上对问题进行离散时，这就是我们*实际*做的事情。我们解决[2.x.7086]问题，其中[2.x.7087]是未知数的矢量。

更准确地说，残差的[2.x.7088]th分量由以下公式给出

[1.x.2747]

其中[2.x.7089] 。鉴于此，单元格[2.x.7090]的贡献是

[1.x.2748]

它的一阶泰勒展开为

[1.x.2749]

因此我们可以计算出[2.x.7091]单元格对雅各布矩阵[2.x.7092]的贡献为[2.x.7093] 。这里重要的一点是，在单元格[2.x.7094]上，我们可以表示为

[1.x.2750]

为了清楚起见，我们用[2.x.7095]和[2.x.7096]作为计数索引，以明确它们彼此之间以及与上述[2.x.7097]的区别。因为在这个公式中，[2.x.7098]只取决于系数[2.x.7099]，我们可以通过自动微分[2.x.7101]来计算导数[2.x.7100]作为一个矩阵。通过我们一直使用的相同论证，很明显[2.x.7102]实际上并不依赖于*所有*未知数[2.x.7103]，而只是依赖于[2.x.7104]是住在单元格[2.x.7105]的形状函数的那些未知数。] ，因此在实践中，我们将[2.x.7106]和[2.x.7107]限制为矢量和矩阵中对应于*本地*DoF指数的部分，然后从本地单元[2.x.7108]分布到全球对象。

使用所有这些实现，然后的方法将是在程序中实现[2.x.7109]，并让自动微分机械从中计算导数[2.x.7110]。




[1.x.2751]

对于装配过程的最终实现，我们将比残差高一个层次：我们的整个线性系统将直接由支配这个边界值问题的物理学的能量函数决定。我们可以利用这样一个事实：我们可以直接从局部贡献中计算出域中的总能量，即。

[1.x.2752]

在离散设置中，这意味着在每个有限元上我们有

[1.x.2753]

如果我们实现细胞能量，它取决于场解，我们可以计算它的第一个（离散）变化

[1.x.2754]

此后，它的第二个（离散）变化

[1.x.2755]

因此，从单元格对总能量函数的贡献来看，只要我们能够提供局部能量的实现，我们就可以期望为我们生成近似的残差和正切贡献 [2.x.7111] 。同样，由于本教程中使用的自动微分变量的设计，在实践中，这些对残差向量和正切矩阵贡献的近似值实际上是精确到机器精度的。


examples/step-72/doc/results.dox



[1.x.2756]

由于在步骤15中首先分析的问题的物理学没有变化，所以没有什么可报告的。它们之间唯一外显的区别是，在默认情况下，这个程序只运行9个网格细化步骤（相对于第15步，执行11个细化）。这可以从模拟状态中观察到，该状态出现在打印出正在使用的装配方法的标题文本和最终的时间。下面报告的所有时间都是在发布模式下获得的）。

[1.x.2757]



因此，我们感兴趣的是比较三种不同实现方式的装配过程需要多长时间，并把它放到更大的背景中。下面是手部线性化的输出结果（在2012年左右的四核八线程笔记本电脑上计算的结果--但我们真正感兴趣的只是不同实现方式之间的相对时间）。

[1.x.2758]

而对于使用萨卡多动态正向AD数字类型，以自动方式将残差线性化的实施。

[1.x.2759]

最后，对于直接从能量函数（使用嵌套的Sacado动态前向AD数）计算残差和其线性化的实现。

[1.x.2760]



很明显，交给自动分化框架执行的工作越多，在装配过程中花费的时间就越多。在所有细化步骤中累积起来，与无辅助装配相比，使用一级自动微分导致在装配阶段花费了[2.x.7112]的计算时间，而直接从能量函数推导时，装配离散线性系统花费了[2.x.7113]的时间。不足为奇的是，解决线性系统的总体时间保持不变。这意味着，随着在有限元水平上进行自动微分的次数的增加，花在求解阶段的时间与装配阶段的时间比例发生了明显的转变。对许多人来说，这可能意味着在生产代码中利用高阶微分（在有限元水平）会导致不可接受的开销，但在原型设计阶段，它可能仍然有用。因此，两者之间的一个很好的折衷办法是有限元残差的自动线性化，它以可衡量的、但也许不是不可接受的成本提供了很多便利。另外，我们可以考虑不在每一步中重新建立牛顿矩阵--这个主题在步骤77中有大量的深入探讨。

当然，在实践中，实际的开销在很大程度上取决于被评估的问题（例如，解决方案中有多少成分，被微分的函数的性质是什么，等等）。因此，这里提出的确切结果应该仅在这个标量问题的背景下进行解释，当涉及到其他问题时，用户肯定需要进行一些初步调查。




[1.x.2761]

与步骤-71一样，有几个与自动区分有关的项目可以进一步评估。

- 应调查其他AD框架的使用情况，并展望其他实施方式可能提供性能优势。

- 除了本教程中硬编码的数字类型外，还值得对AD数字类型进行评估。关于在有限元水平上采用的两次微分类型，混合微分模式（"RAD-FAD"）原则上应该比这里采用的单一模式（"FAD-FAD"）类型的计算效率更高。RAD-FAD类型没有被默认选择的原因是，在撰写本文时，在Sacado库中，它的实现仍然存在一些错误，导致内存泄漏。   这在[2.x.7114]模块中有所记载。

- 也许使用低精度类型（即 "浮动"）作为AD数字的标量类型可以减少装配时的计算费用。使用 "float "作为矩阵和残差的数据类型并不是不合理的，因为牛顿更新只是为了让我们更接近解决方案，而不是实际*到解决方案；因此，考虑使用降低精度的数据类型来计算这些更新，然后将这些更新累积到使用全 "双 "精度的解决方案向量中，是有意义的。

- 在装配过程中可能减少资源的另一个方法是将AD的实现作为一个构成模型。这类似于步骤71中采用的方法，并将自动微分的起点推到了计算链的上一级。这反过来意味着AD库跟踪的操作更少，从而降低了微分的成本（尽管我们会在每个单元的正交点进行微分）。

- 第77步是第15步的另一个变化，解决了问题的一个非常不同的部分：直线搜索以及是否有必要在每次非线性迭代中重新建立牛顿矩阵。鉴于上述结果表明，使用自动微分是有代价的，第77步的技术有可能在一定程度上抵消这些代价。因此，将目前的程序与第77步中的技术结合起来是相当有趣的。对于生产代码来说，这肯定是个好办法。


examples/step-74/doc/intro.dox

[2.x.7115]

[1.x.2762]


[1.x.2763]

[1.x.2764]

[1.x.2765] 在本教程中，我们展示了FEInterfaceValues类的用法，该类是为组装由不连续加尔金（DG）方法产生的面项而设计的。FEInterfaceValues类提供了一种简单的方法来获得形状函数的跳变和平均值以及跨单元面的解。本教程包括以下内容。<ol> [2.x.7116] 泊松方程的SIPG方法，在步骤39和步骤59中已经使用过。    [2.x.7117] 使用FEInterfaceValues组装面项，使用[2.x.7118]组装系统矩阵，这与步骤12类似。    [2.x.7119] 使用误差估计器进行自适应网格细化。    [2.x.7120] 两个测试案例：平滑函数的收敛测试和奇异解的适应性网格细化测试。  [2.x.7121]

[1.x.2766] 在这个例子中，我们考虑泊松方程

[1.x.2767]

受制于边界条件

[1.x.2768]

为了简单起见，我们假设扩散系数[2.x.7122]在这里是常数。注意，如果[2.x.7123]是不连续的，我们在计算单元面的跳跃项时需要考虑到这一点。

我们用[2.x.7124]表示网格，[2.x.7125]是一个网格单元。内部和边界面的集合分别用 [2.x.7126] 和 [2.x.7127] 表示。让[2.x.7128]和[2.x.7129]是共享一个面[2.x.7130]的两个单元，[2.x.7131]是[2.x.7132]的外法向量。那么跳跃算子由 "这里减去那里 "公式给出。

[1.x.2769]

和平均运算符为

[1.x.2770]

分别。请注意，当[2.x.7133]时，我们定义[2.x.7134]和[2.x.7135] 。使用SIPG的离散化由以下弱式给出（更多细节可以在[2.x.7136]和其中的参考文献中找到）。

[1.x.2771]






[1.x.2772] 惩罚参数定义为 [2.x.7137] ，其中 [2.x.7138] 是与细胞面相关的局部长度尺度；这里我们选择细胞在面的法线方向的长度近似值。  [2.x.7139] ，其中[2.x.7140]是与面相邻的两个单元[2.x.7141]，我们我们计算[2.x.7142] 。

在上述公式中，[2.x.7143] 是惩罚常数。为了确保离散矫捷性，惩罚常数必须足够大 [2.x.7144] 。对于文献中提出的哪些公式应该被使用，人们并没有真正达成共识。这与第47步的 "结果 "部分讨论的情况类似）。人们可以直接挑选一个大的常数，而其他选择可以是[2.x.7145]或[2.x.7146]的倍数。在这段代码中，我们遵循步骤39，使用[2.x.7147] 。




[1.x.2773] 在这个例子中，稍作修改，我们使用Karakashian和Pascal的误差估计器[2.x.7148] 。

[1.x.2774]

其中

[1.x.2775]

这里我们用[2.x.7149]代替[2.x.7150]来表示[2.x.7151]的跳跃项（[2.x.7152]和[2.x.7153]的第一个项）。

为了计算这个估计值，在每个单元格[2.x.7154]中，我们计算出

[1.x.2776]

那么每个单元的误差估计的平方是

[1.x.2777]

[2.x.7155]的系数是由于整体误差估计器只包括每个内部面一次，所以每个单元的估计器对它的计算是相邻两个单元的一半系数。注意，我们计算[2.x.7156]而不是[2.x.7157]以简化实现。然后，每个单元的误差估计方被存储在一个全局向量中，其[2.x.7158]准则等于[2.x.7159] 。

[1.x.2778] 在第一个测试问题中，我们使用二维的[2.x.7160]平滑制造的解决方案来进行收敛测试

[1.x.2779]

和[2.x.7161] 。我们针对制造的解决方案计算误差并评估收敛率。

在第二个测试中，我们在二维的L形域[2.x.7162]上选择[2.x.7163]。该解在极坐标中由[2.x.7164]给出，它在原点有一个奇点。构建了一个误差估计器来检测有大误差的区域，根据这个估计器来自适应地细化网格。


examples/step-74/doc/results.dox



[1.x.2780]

该程序的输出包括控制台输出和vtu格式的解决方案。

在第一个测试案例中，当你运行程序时，屏幕输出应该如下。

[1.x.2781]



当使用多项式度数为3的光滑情况时，收敛表会是这样的。  [2.x.7165]

理论上，对于多项式度数[2.x.7166]，[2.x.7167]规范和[2.x.7168]半规范的收敛顺序应该是[2.x.7169]和[2.x.7170]，分别。我们的数值结果与理论有很好的一致性。

在第二个测试案例中，当你运行该程序时，屏幕输出应该如下。

[1.x.2782]



下图提供了L型域上该测试案例的误差与自由度数的对数图。为了解释它，让[2.x.7171]为自由度数，那么在均匀细化的网格上，[2.x.7172]在二维中为[2.x.7173]阶。结合前面的理论结果，我们可以看到，如果解足够光滑，我们可以预期[2.x.7174]准则的误差为[2.x.7175]阶，[2.x.7176]半准则的误差为[2.x.7177] 。先验地，我们并不清楚在像我们用于第二个测试案例的自适应细化网格上是否会得到与[2.x.7178]的函数相同的行为，但我们当然可以希望。事实上，从图中我们看到，带有自适应网格细化的SIPG产生了渐进式的希望的结果。

[2.x.7179]

此外，我们观察到误差估计器的下降速度几乎与能量准则和[2.x.7180]半准则的误差相同，并且比[2.x.7181]的误差低一阶。这表明它有能力预测具有较大误差的区域。

虽然本教程侧重于实现，但step-59教程程序在计算时间上用无矩阵求解技术实现了一个高效的大规模求解器。需要注意的是，step-59教程目前不能用于包含悬空节点的网格，因为多网格界面矩阵不那么容易确定，但这仅仅是deal.II中一些界面的缺乏，没有什么根本性的问题。


examples/step-75/doc/intro.dox

[2.x.7182]

[1.x.2783]




[2.x.7183] 作为这个程序的先决条件，你需要安装p4est库和Trilinos库。在[1.x.2784]文件中描述了deal.II与这些附加库的安装情况。




[1.x.2785]

[1.x.2786]

在有限元背景下，更多的自由度通常会产生一个更精确的解决方案，但也需要更多的计算工作。

在以前的整个教程中，我们找到了通过将网格分辨率与解的复杂性进行局部调整来有效分配自由度的方法（自适应网格细化，步骤6）。如果我们不仅单独调整网格，而且还局部调整每个单元上相关有限元的多项式程度，这种方法就特别有效（hp-adaptation，第27步）。

此外，分配更多的进程同时运行你的程序有助于在更短的时间内解决计算工作量。根据你的机器的硬件结构，你的程序必须为所有进程都能访问相同的内存（共享内存，第18步），或者进程被托管在几个独立的节点上（分布式内存，第40步）这种情况做好准备。

在高性能计算部分，内存访问变成了当前超级计算机的瓶颈。我们可以通过使用MatrixFree方法（第37步）来计算矩阵-向量乘积的效果，从而完全避免存储矩阵。它们可以用于几何多网格方法（步骤50），也可以用于多项式多网格方法，以极大地加快方程组的求解速度。

本教程结合所有这些特点，介绍了如何解决一个简单的拉普拉斯问题的最先进的方法：在具有分布式内存的机器上利用hp-适应和无矩阵混合多网格方法。




[1.x.2787]

对于有限元的并行应用，我们将网格划分为子域（又称域分解），这些子域被分配给进程。这种划分发生在deal.II的活动单元上，如步骤40所示。在那里，每个单元都有相同的有限元和相同的自由度分配，以及大致相同的工作负荷。为了平衡所有进程的工作负荷，我们必须平衡所有参与进程上的单元数量。

在hp-adaptive方法中，情况不再如此：有限元类型可能因单元而异，因此自由度的数量也不同。匹配单元的数量并不能产生一个平衡的工作量。在无矩阵的情况下，可以假设工作量与每个过程的自由度数量成正比，因为在最好的情况下，只有源和目的向量需要被加载。

我们可以通过给每个单元分配权重来平衡工作量，这些权重与自由度的数量成正比，并平衡所有进程之间的所有权重之和。给每个单元分配单独的权重可以通过我们后面要使用的[2.x.7184]类来实现。




[1.x.2788]

使用hp-adaptive方法，我们不仅要决定哪些单元需要细化或粗化，而且还可以选择如何做：要么调整网格分辨率，要么调整有限元的多项式程度。

我们将再次根据当前解决方案的（后验）计算误差估计值来决定哪些单元需要调整，例如，使用KellyErrorEstimator。我们将同样决定如何用（事后）计算的平滑度估计值进行调整：大的多项式度数对解决方案的平滑部分效果最好，而细的网格分辨率对不规则部分是有利的。在第27步中，我们提出了一种基于傅里叶系数衰减的平滑度估计的计算方法。让我们利用这个机会，提出一种遵循相同思路的替代方法，但采用Legendre系数。

我们将简要介绍这种新技术的思路，但为了简单起见，将其描述限制在一维。假设[2.x.7185]是一个有限元函数，在单元格[2.x.7186]上定义为

[1.x.2789]

其中每个[2.x.7187]是一个形状函数。我们可以用Legendre多项式[2.x.7189]的基础等价表示[2.x.7188]为

[1.x.2790]

我们的目标是获得有限元系数[2.x.7190]和Legendre系数[2.x.7191]之间的映射。我们将通过把问题写成[2.x.7192]对[2.x.7193]在Legendre基础上的投影来实现这一目标。每个系数[2.x.7194]可以通过以下方式计算

[1.x.2791]

根据结构，Legendre多项式在[2.x.7195]上的内积下是正交的。此外，我们假设它们已经被归一化，所以它们的内积可以写成

[1.x.2792]

其中[2.x.7197]是克朗克三角洲，[2.x.7198]是[2.x.7199]到[2.x.7200]的映射的雅各布，（在本教程中）假定它是常数（即，映射必须是仿射的）。

因此，结合所有这些假设，在Legendre基础上表达[2.x.7201]的投影矩阵只是[2.x.7202] -- 即[2.x.7203]乘以身份矩阵。让[2.x.7204]成为从[2.x.7205]到其参考单元[2.x.7206]的映射。因此，投影系统中右侧的条目为：。

[1.x.2793]

回顾[2.x.7207]的形状函数表示，我们可以把它写成[2.x.7208]，其中[2.x.7209]是改变基础的矩阵，条目是

[1.x.2794]

所以[2.x.7210]的值可以写成[2.x.7211]独立于[2.x.7212]的[2.x.7213]，在转换为参考坐标后，将[2.x.7214]从前面因式分解。因此，把这一切放在一起，投影问题可以写为

[1.x.2795]

可以简单改写为

[1.x.2796]



在这一点上，我们需要强调的是，大多数有限元应用都使用非结构化网格，对于这些网格的映射几乎总是非affine的。换句话说：[2.x.7215]在整个单元中是恒定的这一假设对于一般的网格来说是不正确的。因此，[2.x.7216]的正确计算不仅要求我们为每一个单元计算相应的变换矩阵[2.x.7217]，而且还要求我们在可能具有任意和非常复杂的几何形状的单元[2.x.7218]上定义一组类Legendre正交函数。特别是第二部分，在计算上非常昂贵。目前FESeries变换类的实现依赖于具有恒定雅各布系数所带来的简化，以提高性能，因此只对仿射映射产生正确结果。变换只用于平滑度估计的目的，以决定适应的类型，这不是有限元程序的一个关键组成部分。除此之外，这种情况对本教程不构成问题，因为我们只使用方形的单元。

Eibner和Melenk [2.x.7219] 认为，当且仅当Legendre系数的绝对值随指数增加而衰减时，一个函数是解析的，即可以用幂级数表示 [2.x.7220] 。

[1.x.2797]

衰减率[2.x.7221]可以被解释为衡量该函数的平滑度。我们可以把它看成是转化系数的线性回归拟合的斜率。

[1.x.2798]



我们将对每个单元[2.x.7222]进行这种拟合，以获得对有限元近似的平滑度的局部估计。然后，衰减率[2.x.7223]作为hp-adaptation的决策指标。对于单元上的有限元[2.x.7224]的多项式程度[2.x.7225]，计算[2.x.7226]的系数被证明是估计平稳性的合理选择。你可以在 [2.x.7227] 中找到更详细和独立于维度的描述。

以上所有内容已经在[2.x.7228]类和[2.x.7229]命名空间中实现。有了误差估计和平滑度指标，我们就可以对单元格进行实际细化和粗化了。来自[2.x.7230]和[2.x.7231]命名空间的一些函数将在后面帮助我们完成这个任务。




[1.x.2799]

有限元矩阵通常是非常稀疏的。此外，hp-adaptive方法对应于每行非零项数量变化很大的矩阵。一些最先进的预处理程序，如Step-40中使用的代数多重网格（AMG），在这些情况下表现不佳。

因此，我们将依靠一个无矩阵的混合多网格预处理程序。Step-50已经证明了几何多网格方法与MatrixFree框架结合时的优越性。在hp-adaptive FEM上的应用需要一些额外的工作，因为一个单元的子代可能有不同的多项式程度。作为补救措施，我们首先对线性元素进行p松弛（类似于Mitchell[2.x.7232]），然后以常规方式进行h松弛。在最粗的层次上，我们应用代数多网格求解器。p-多栅、h-多栅和AMG的结合使求解器成为一个混合多栅求解器。

我们将通过使用MGTransferGlobalCoarsening，在现有的全局粗化基础设施的帮助下，创建一个具有上述特殊水平要求的自定义混合多网格预处理器。




[1.x.2800]

对于椭圆方程来说，每个再入角通常会引出一个奇点 [2.x.7233] 。我们可以利用这种情况对我们的HP决策算法进行测试：在所有要适应的单元上，我们倾向于在奇点附近采用精细的网格，而在其他情况下采用高的多项式程度。

作为在这些条件下要解决的最简单的椭圆问题，我们选择了L型域中的拉普拉斯方程，其再入角位于坐标系的原点。

为了能够确定实际的误差，我们制造一个有已知解的边界值问题。在上述领域，拉普拉斯方程的一个解是，在极坐标中，[2.x.7234] 。

[1.x.2801]



参见 [2.x.7235] 或 [2.x.7236] 。解决方案看起来如下。

<div style="text-align:center;"> <img src="https://www.dealii.org/images/steps/developer/step-75.solution.svg" alt="分析性解决方案。"> </div>

通过研究再入角附近的解决方案的梯度，即原点，奇异性变得很明显了。

[1.x.2802]



由于我们知道奇点的位置，我们希望我们的hp-decision算法在这个特定的区域内决定采用精细的网格分辨率，而在其他地方采用高多项式程度。

因此，让我们看看情况是否真的如此，以及hp-adaptation与纯h-adaptation相比表现如何。但首先让我们详细看看实际的代码。


examples/step-75/doc/results.dox



[1.x.2803]

当你在释放模式下，在四个进程上用给定的参数运行该程序时，你的终端输出应该是这样的。

[1.x.2804]



当用更多的进程运行代码时，你会注意到活动单元和自由度的数量有轻微的差异。这是由于求解器和预处理程序取决于问题的分区，这可能会导致最后一位数的解决方案的微小差异，并最终产生不同的适应行为。

此外，尽管有hp-adaptation，求解器的迭代次数在所有周期中都保持不变，这表明所提出的算法的稳健性，并有望在更大的问题规模和更多的进程中具有良好的可扩展性。

让我们看一下程序的图形输出。在给定参数配置的所有细化循环之后，实际离散的函数空间看起来如下，左边是其在12个进程上的分区，右边是有限元的多项式程度。在左图中，每种颜色代表一个独特的子域。在右图中，最浅的颜色对应于多项式的2度，最深的对应于6度。

<div class="twocolumn" style="width: 80%; text-align: center;"> <div> <img src="https://www.dealii.org/images/steps/developer/step-75.subdomains-07.svg" alt="七次细化后的分区。"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-75.fedegrees-07.svg" alt="七次细化后的局部近似度。"> </div> <div>




[1.x.2805]

[1.x.2806]

[1.x.2807]

deal.II库提供了多种策略来决定对单元格施加哪种类型的适应：要么调整网格分辨率，要么改变多项式程度。我们在本教程中只介绍了[1.x.2808]策略，而Step-27则演示了相同想法的[1.x.2809]等值。

有关这些策略的概述，请参见步骤27的 "扩展的可能性 "部分，或相应的文件的详细描述。

在这里，提到了另一个迄今为止还没有在任何教程中展示过的策略：基于[1.x.2810]的策略。这种方法在并行分布式应用中的使用比其他方法更棘手，所以我们将强调随之而来的挑战。我们需要有关细化标志的最终状态的信息，并且我们需要在细化的网格之间转移解决方案。对于前者，我们需要将[2.x.7237]函数附加到[2.x.7238]信号上，其方式是将[1.x.2811]的[2.x.7239]函数调用。在这个阶段，所有的细化标志和未来的FE指数都被终止设置，并且可以对误差进行可靠预测。然后，预测的误差需要借助于[2.x.7240]在细化网格之间进行转移。

试着在本教程中实现这些策略之一，并观察结果的微妙变化。你会注意到，所有的策略都能够识别出重心角附近的奇点，并且会在这些区域进行[2.x.7241]-精化，而在体域中更倾向于[2.x.7242]-精化。这些策略的详细比较见于 [2.x.7243] 。




[1.x.2812]

本教程只关注无矩阵策略。然而，所有的hp自适应算法在并行分布式背景下也可以使用基于矩阵的方法。

为了创建一个系统矩阵，你可以使用[2.x.7244]函数，或者使用类似于步骤27的[2.x.7245]函数。然后你可以像往常一样将系统矩阵传递给求解器。

你可以对基于矩阵和无矩阵的实现结果进行计时，量化速度提升，并说服自己哪种变体更快。




[1.x.2813]

为了简单起见，我们将自己限制在单一类型的粗网格求解器（带AMG的CG）、平滑器（带点Jacobi预处理的Chebyshev平滑器）以及多网格算法中的几何粗化方案（全局粗化）。请自由尝试替代方案并调查其性能和稳健性。


examples/step-76/doc/intro.dox



[2.x.7246]

[1.x.2814]

[1.x.2815]

[1.x.2816]

本教程程序求解流体力学的欧拉方程，使用显式时间积分器和无矩阵框架应用于空间的高阶非连续Galerkin离散化。这里使用的数值方法与step-67中使用的相同，但是，我们利用不同的高级MatrixFree技术来达到更高的吞吐量。

本教程的两个主要特点是。

- 使用MPI-3.0中的共享内存特性和

- 使用以单元为中心的循环，它只允许向全局向量写入一次，因此，是使用共享内存的理想选择。

我们在本教程中讨论的其他主题是模板参数VectorizedArrayType的用法和好处（而不是简单地使用VectorizedArray<Number>），以及向MatrixFree循环传递lambdas的可能性。

关于数字的细节，我们参考步骤-67的文件。我们在这里只集中讨论关键的差异。

[1.x.2817]

[1.x.2818]

存在许多基于线程的共享内存库，如TBB、OpenMP或TaskFlow。将这些库集成到现有的MPI程序中，就可以使用共享内存。然而，这些库对程序员来说有一定的开销，因为所有可并行的代码部分都必须根据所使用的库进行查找和转换，包括当一些第三方数值库，如迭代求解器包，只依赖MPI时的困难。

考虑到一个纯粹的MPI并行化的有限元应用，我们可以发现，使用共享内存的主要时间和内存优势来自于访问同一计算节点上的进程所拥有的解决方案矢量的部分，而不需要进行明确的复制和缓冲。因此，MPI-3.0提供了基于所谓窗口的共享内存功能，进程可以直接访问同一共享内存域中的邻居的数据。

[1.x.2819]

有几个相关的MPI-3.0命令值得详细讨论。一个新的MPI通信器[2.x.7247] ，由通信器[2.x.7248]的进程组成，这些进程可以访问相同的共享内存，可以通过以下方式创建。

[1.x.2820]



下面的代码片断显示了共享内存的简化分配例程，包括值类型 [2.x.7249] 和大小 [2.x.7250] ，以及如何查询属于同一共享内存域的进程的数据指针。

[1.x.2821]



一旦不再需要这些数据，窗口就必须被释放，这也释放了本地拥有的数据。

[1.x.2822]



[1.x.2823]

上一节提到的命令被整合到了[2.x.7251]中，如果为reinit()函数提供了可选的（第二个）通信器，那么这些命令就被用来分配共享内存。

例如，可以用一个分区器（包含全局通信器）和一个子通信器（包含同一计算节点上的进程）来设置一个向量。

[1.x.2824]



本地拥有的值和幽灵值可以像往常一样被处理。然而，现在用户也可以通过该函数读取共享内存邻居的值。

[1.x.2825]



[1.x.2826]

虽然[2.x.7252]提供了分配共享内存和以协调的方式访问相邻进程的共享内存值的选项，但它实际上并没有利用共享内存的使用本身的好处。

然而，MatrixFree的基础设施确实如此。

- 一方面，在无矩阵循环[2.x.7253][2.x.7254]和[2.x.7255]中，只有需要更新的幽灵值[2.x.7256]被[2.x.7257]更新。来自共享内存邻居的幽灵值可以被直接访问，这使得缓冲，即把值复制到矢量的幽灵区域可能是多余的。   为了处理可能的竞赛条件，在MatrixFree中进行了必要的同步。在数值必须被缓冲的情况下，数值被直接从邻近的共享内存进程中复制，绕过了基于 [2.x.7258] 和 [2.x.7259] 的更昂贵的MPI操作。

- 另一方面，像FEEvaluation和FEFaceEvaluation这样的类可以直接从共享内存中读取，所以在某些情况下确实不需要缓冲值。

为了能够使用MatrixFree的共享内存功能，MatrixFree必须通过提供用户创建的子通信器进行适当的配置。

[1.x.2827]






[1.x.2828]

[1.x.2829]

"以面为中心的循环"（简称FCL）在单独的循环中访问单元和面（内部和边界的）。因此，每个实体只被访问一次，单元之间的通量只被评估一次。如何在[2.x.7260]的帮助下，通过提供三个函数（一个用于细胞积分，一个用于内部，一个用于边界面）来执行以面为中心的循环，已经在步骤59和步骤67中提出。

与此相反，"以单元为中心的循环"（在hyper.deal发布的论文中简称CCL或ECL（代表以元素为中心的循环），处理一个单元并直接连续处理其所有面（即访问所有面两次）。在文献[2.x.7261]中，它们的好处对于现代CPU处理器架构来说已经很清楚了，尽管这种循环意味着通量必须被计算两次（对于内部面的每一面）。CCL有两个主要优点。

- 一方面，在CCL的情况下，解向量中的条目正好被写回主内存一次，而在FCL的情况下，尽管高速缓存有效地调度了单元和面环，但由于高速缓存容量的错过，至少有一次。

- 另一方面，由于解向量的每个条目只被访问一次，在CCL的情况下，访问解向量时不需要线程间的同步。在写入目标向量的过程中不存在竞赛条件，这使得CCL特别适用于共享内存并行化。

我们还应该注意到，尽管在CCL的情况下通量被计算了两次，但这并不自动转化为计算量的翻倍，因为已经内插到单元正交点的值可以用简单的一维内插法内插到一个面上。

[1.x.2830]

对于以单元为中心的循环实现，可以使用函数[2.x.7262]，用户可以向其传递一个应该在每个单元上执行的函数。

为了得出一个适当的函数，可以在[2.x.7263]中传递，原则上可以转换/合并以下三个函数，它们可以传递给[2.x.7264]。

[1.x.2831]



以下列方式进行。

[1.x.2832]



应该注意的是，FEFaceEvaluation现在是用两个数字初始化的，即单元号和本地面孔号。给出的例子只是强调了如何将以面为中心的循环转化为以单元为中心的循环，而且绝非高效，因为数据要从全局向量中多次读写，而且计算也是重复进行的。下面，我们将讨论针对这些问题的高级技术。

为了能够使用[2.x.7265]，必须启用[2.x.7266]的下列标志。

[1.x.2833]



特别是，这些标志使内部数据结构能够为所有单元格的面设置。

目前，deal.II中以单元为中心的循环只适用于均匀细化的网格，并且不应用任何约束条件（这是通常使用的DG的标准情况）。




[1.x.2834]

上面给出的例子已经使用了lambdas，它已经被提供给无矩阵循环。下面的简短例子介绍了如何在使用类和指向其方法之一的指针的版本和利用lambdas的变体之间转换函数。

在下面的代码中，一个类和它的一个方法的指针被传递给了[2.x.7267]，这个方法应该被解释为单元格积分。

[1.x.2835]



[1.x.2836]



然而，也可以通过lambda函数传递匿名函数，结果是一样的。

[1.x.2837]



[1.x.2838]

VectorizedArray<Number>类是实现deal.II中无矩阵算法的高节点级性能的一个关键组件。它是一个围绕Number类型的[2.x.7268]条目的短向量的包装类，并通过内在函数将算术操作映射到适当的单指令/多数据（SIMD）概念。向量的长度可以通过[2.x.7269]查询，其底层数字类型可以通过[2.x.7270]查询。

在默认情况下（[2.x.7271]），向量长度在库的编译时被设置为与给定的处理器架构所支持的最高值相匹配。然而，也可以指定第二个可选的模板参数，如[2.x.7272]明确控制特定指令集能力范围内的向量长度。下表列出了支持的向量长度的完整列表。

[2.x.7273]

这允许用户选择矢量长度/ISA，因此，在无矩阵算子评估中一次处理的单元数，可能会减少对缓存的压力，这对非常高的度数（和尺寸）来说是一个严重的问题。

减少填充通道数量的另一个可能的原因是为了简化调试：不用看例如8个单元，而是可以集中在一个单元上。

VectorizedArray的接口也能够被任何具有匹配接口的类型所替代。具体来说，这为deal.II准备了[2.x.7274]类，它计划成为C++23标准的一部分。下表比较了deal.II特定的SIMD类和相应的C++23类。


[2.x.7275]


examples/step-76/doc/results.dox



[1.x.2839]

在一台有40个进程的机器上以默认设置运行该程序，会产生以下输出。

[1.x.2840]



和以下视觉输出。

[2.x.7276]

作为参考，使用FCL的步骤-67的结果是。

[1.x.2841]



通过本教程中的修改，我们能够使Runge-Kutta阶段的速度提高27%。

[1.x.2842]

这些算法很容易扩展到更高的维度：高维的[1.x.2843]是hyper.deal库的一部分。以单元为中心的循环扩展到局部细化的网格则涉及更多。

[1.x.2844]

本教程中提出的求解器也可以通过增加粘性项来扩展到可压缩的Navier-Stokes方程，这也是步骤67中的建议。为了尽量保持这里获得的性能，尽管有额外的椭圆项的成本，例如通过内部惩罚方法，该教程建议将基础从FE_DGQ切换到FE_DGQHermite，就像步骤59的教程程序一样。这种转换背后的原因是，在FE_DGQ的情况下，需要相邻单元的所有值（即[2.x.7277]层），而在FE_DGQHermite的情况下，只需要2层，这使得后者明显更适合于高度数。额外的层一方面要在通量计算过程中从主内存加载，另一方面要进行通信。利用本教程介绍的共享内存能力，第二点可以在单个计算节点上消除，或者在混合环境下减少其影响。

[1.x.2845]

以单元为中心的循环可用于创建块状高斯-赛德尔预处理，在一个过程中是乘法的，在整个过程中是加法的。这些类型的预处理器在通量计算过程中使用，与雅可比型预处理器相反，已经从相邻的单元中更新了数值。下面的伪代码直观地说明了这在原则上是如何实现的。

[1.x.2846]



为此，我们可以利用MatrixFree的单元数据向量能力和VectorizedArray的基于范围的迭代能力。

请注意，在给定的例子中，我们处理[2.x.7278]个块，因为每个通道对应一个块。如果一个矢量寄存器处理的所有块都被更新了，我们就认为块被更新了。在笛卡尔网格的情况下，这是一个合理的方法，然而，对于一般的非结构化网格，这种保守的方法可能会导致预处理程序的效率下降。通过明确减少[2.x.7279]使用的通道数量来减少并行处理的单元可能会提高预处理器的质量，但代价是每次迭代可能会更昂贵。这种两难境地把我们引向另一种 "扩展的可能性"：元素内的矢量化。


examples/step-77/doc/intro.dox

[2.x.7280]

[1.x.2847][2.x.7281] 。

[1.x.2848]

[1.x.2849]

第15步程序解决了以下描述最小表面问题的非线性方程。

[1.x.2850]

step-15使用的是牛顿方法，牛顿方法的工作原理是反复求解一个更新[2.x.7282]的*线性化*问题--称为 "搜索方向"--计算 "步长"[2.x.7283]，然后将它们结合起来，通过以下方式计算出新的猜测解。

[1.x.2851]



在步骤15的讨论过程中，我们发现计算步长是很尴尬的，所以只是解决了简单的选择。总是选择[2.x.7284] 。这当然是没有效率的。我们知道，只有当我们最终能够选择[2.x.7285]时，我们才能实现牛顿的二次收敛率，尽管在最初的几次迭代中，我们可能不得不选择较小的步长，因为我们离使用这么长的步长还很遥远。

因此，本方案的目标之一是解决这一缺陷。由于行搜索算法的实现并不完全是微不足道的，因此人们无论如何都要做自己应该做的事。从外部库中导入复杂的功能。为此，我们将利用deal.II与大型非线性求解器包之一的接口，即[SUNDIALS](https://computing.llnl.gov/projects/sundials)套件的[KINSOL](https://computing.llnl.gov/projects/sundials/kinsol)子包。%SUNDIALS的核心是一个用于解决复杂的常微分方程（ODE）和微分代数方程（DAE）的软件包，deal.II接口允许通过SUNDIALS命名空间的类来实现。特别是[2.x.7286]和[2.x.7287]类。但是，由于这是用隐式方法解决ODE和DAE的一个重要步骤，%SUNDIALS也有一个非线性问题的求解器，叫做KINSOL，deal.II有一个接口，以[2.x.7288]类的形式与之连接。这就是我们将用于解决我们的问题的方法。

但是%SUNDIALS不仅仅是一个方便我们避免编写线搜索算法的方法。一般来说，非线性问题的解决是相当昂贵的，人们通常希望尽可能地节省计算时间。一个可以实现这个目标的方法是如下的。第15步中的算法将问题离散化，然后在每次迭代中求解形式为的线性系统

[1.x.2852]

其中[2.x.7289]是使用当前节点值矢量[2.x.7290]计算的残差矢量，[2.x.7291]是其导数（称为 "雅各布"），而[2.x.7292]是对应于上述函数[2.x.7293]的更新矢量。步骤15中已经彻底讨论了[2.x.7294]的构造，以及在每个牛顿迭代中解决线性系统的方法。因此，让我们关注一下非线性求解过程的另一个方面。计算[2.x.7295]是昂贵的，而组装矩阵[2.x.7296]更是如此。我们真的需要在每次迭代中都这样做吗？事实证明，在许多应用中，这实际上是没有必要的。即使我们用近似值[2.x.7298]代替[2.x.7297]，这些方法通常也能收敛，并解决了

[1.x.2853]

代替，然后更新

[1.x.2854]

这可能需要多一两个迭代，因为我们的更新[2.x.7299]并不像[2.x.7300]那样好，但它可能仍然是一个胜利，因为我们不必经常组装[2.x.7301]。

对于[2.x.7303]，我们希望得到什么样的近似值[2.x.7302]？理论上说，由于[2.x.7304]收敛于精确解[2.x.7305]，我们需要确保[2.x.7306]需要收敛于[2.x.7307] 。特别是，由于 [2.x.7308] ，有效的选择是 [2.x.7309] 。但是每一次，比如说，第五次迭代选择[2.x.7310]也是如此，对于其他的迭代，我们选择[2.x.7312]等于最后计算的[2.x.7313] 。这就是我们在这里要做的：我们将只是重新使用前一次迭代中的[2.x.7314]，这可能又是我们在之前的迭代中使用的，[2.x.7315] 。

如果对于带有[2.x.7316]的线性系统的求解，我们不只是要组装一个矩阵，还要计算一个好的预处理程序，那么这个方案就变得更加有趣。例如，如果我们要通过SparseDirectUMFPACK类使用稀疏LU分解，或者使用几何或代数多重网格。在这些情况下，我们也不必更新预处理程序，因为预处理程序的计算时间可能和当初组装矩阵的时间一样长，甚至更长。事实上，在这种心态下，我们也许应该考虑使用我们能想到的*好的前置条件器，尽管它们的构造通常相当昂贵。我们希望通过将其应用于不止一个线性求解，来摊销计算这个预处理程序的成本。

当然，最大的问题是。我们根据什么标准来决定我们是否可以摆脱基于先前计算的雅各布矩阵[2.x.7318]的近似[2.x.7319]步，或者我们是否需要--至少在这个迭代中--实际重新计算雅各布[2.x.7320]和相应的前置条件器？这就像行搜索的问题一样，需要大量的代码来监控整个算法的收敛性。我们*可以*自己实现这些东西，但我们可能*不应该*。KINSOL已经为我们做了这些。它将告诉我们的代码何时要 "更新 "雅各布矩阵。

如果我们要使用迭代求解器而不是上面提到的稀疏直接求解器，还有最后一个考虑。在求解更新[2.x.7323]时，不仅有可能用一些近似值[2.x.7321]代替[2.x.7322]，而且还可以问是否有必要求解线性系统

[1.x.2855]

准确度高。其思路是这样的。虽然我们目前的解决方案[2.x.7324]离[2.x.7325]还很远，但我们为什么要特别精确地解决这个线性系统？更新后的[2.x.7326]很可能仍然离精确的解决方案很远，那么为什么要花很多时间来解决这个线性系统的精确性？这就是 "Eisenstat-Walker技巧"[2.x.7327]等算法的基础思维，在该算法中，人们被赋予一个公差，在迭代[2.x.7328]中必须解决上述线性系统，该公差取决于整个非线性求解器的进展。像以前一样，我们可以尝试自己实现，但是KINSOL已经为我们提供了这种信息--尽管我们不会在这个程序中使用它，因为我们使用的是直接求解器，不需要求解器的容忍度，只是精确求解线性系统到舍入。

作为对所有这些考虑的总结，我们可以说以下几点。没有必要重新发明轮子。就像deal.II提供了大量的有限元功能一样，%SUNDIALS的KINSOL软件包提供了大量的非线性求解器功能，我们最好使用它。




[1.x.2856]

KINSOL，像许多类似的软件包一样，以一种相当抽象的方式工作。在其核心部分，它看到了一个非线性问题，其形式为

[1.x.2857]

并构建一个迭代序列 [2.x.7329] ，一般来说，迭代序列是与函数返回的向量相同长度的向量 [2.x.7330] 。要做到这一点，它需要从用户那里得到一些东西。

- 将一个给定的向量调整到正确大小的方法。

- 对于一个给定的向量[2.x.7331]，评估函数[2.x.7332]的一种方法。这个函数通常被称为 "剩余 "操作，因为目标当然是找到一个点[2.x.7333]，对于这个点[2.x.7334]；如果[2.x.7335]返回一个非零向量，那么这就是[1.x.2858]（即 "剩余"，或任何 "剩余"）。做到这一点的函数在本质上与步骤15中的右手边向量的计算相同，但有一个重要区别。   在那里，右手边表示的是残差的*负数，所以我们必须换一个符号。

- 计算矩阵[2.x.7336]的方法，如果这在当前迭代中是必要的，同时可能还有一个预处理程序或其他数据结构（例如，通过SparseDirectUMFPACK进行稀疏分解，如果我们选择用它来解决一个线性系统）。这个操作通常被称为 "设置 "操作。

- 用最后计算的任何矩阵[2.x.7338]来解决一个线性系统[2.x.7337]的方法。这个操作一般被称为 "求解 "操作。

所有这些操作都需要由[2.x.7339]对象提供给KINSOL，这些对象接受适当的参数集，通常返回一个表示成功（返回值为零）或失败（返回值为非零）的整数。具体来说，我们要访问的对象是[2.x.7340] [2.x.7341] [2.x.7342] 和 [2.x.7343] 成员变量。(详见这些变量的文档。)在我们的实现中，我们将使用[lambda functions](https://en.cppreference.com/w/cpp/language/lambda)来实现这些 "回调"，反过来可以调用成员函数；然后KINSOL将在其内部算法认为有用时调用这些回调。




[1.x.2859]

本教程程序的大部分代码与步骤15一样，我们将不作过多评论。实际上只有一个方面需要注意，即一方面给定一个向量[2.x.7345]，另一方面给定一个向量[2.x.7346]，如何计算[2.x.7347]。起初，这似乎很简单：我们只需使用`assemble_system()`函数，在一种情况下抛出所有处理矩阵的代码，在另一种情况下抛出右手边的向量。就这样。问题解决了。

但它并不那么简单。这是因为如果我们有非零的Dirichlet边界值，这两者并不独立，就像我们在这里做的那样。我们要解决的线性系统包含内部和边界自由度，当从那些真正 "自由 "的自由度中消除这些自由度时，使用例如[2.x.7348]，我们在组装右手边的向量时需要知道矩阵。

当然，这完全违背了原意。如果我们可以不组装矩阵，就不要*组装。我们解决这个问题的方法如下。

- 我们将解向量的起始猜测，[2.x.7349]，设定为边界自由度已经有了正确的值。

- 这意味着所有的更新都可以有这些自由度的零更新，我们可以建立残差向量[2.x.7350]和雅各布矩阵[2.x.7351]，对应于线性系统的解在这些向量分量中为零。对于这种特殊情况，矩阵和右手边向量的组装是独立的，可以分解成不同的函数。

这里有一个假设，即每当KINSOL要求用雅各布的（近似值）进行线性求解时，这将是为了更新[2.x.7352]（其边界值为零），其倍数将被添加到解决方案（其已经有正确的边界值）。  这可能不是真的，如果是的话，我们可能要重新考虑我们的方法。也就是说，事实证明，在实践中，这正是KINSOL在使用牛顿方法时的表现，因此我们的方法是成功的。


examples/step-77/doc/results.dox



[1.x.2860]

当运行该程序时，你得到的输出看起来像这样。

[1.x.2861]



通过查看第一个网格上的输出的前几行，应该最容易解释这种方式。

[1.x.2862]

现在的情况是这样的。

- 在第一次残差计算中，KINSOL计算残差以查看是否达到了所需的公差。答案是否定的，所以它要求用户程序计算雅各布矩阵（然后该函数还通过SparseDirectUMFPACK对矩阵进行因子化）。

- 然后KINSOL指示我们用这个矩阵和之前计算的残差向量来解决一个形式为[2.x.7353]的线性系统。

- 然后就是确定我们要在这个方向上走多远，也就是做线搜索。为此，KINSOL要求我们计算不同步长[2.x.7355]的残差向量[2.x.7354] 。对于上面的第一步，它在尝试了两次后找到了一个可接受的[2.x.7356]，第二次则需要尝试三次。

- 在找到一个合适的更新解[2.x.7357]之后，这个过程被重复，只是现在KINSOL对当前的雅各布矩阵很满意，没有指示我们重新建立矩阵和它的因式分解，而是要求我们用同一个矩阵解决一个线性系统。

在每个网格细化周期结束时，程序也会将解决方案写入VTU文件，它看起来如下。  [2.x.7358]


该计划的主要收获信息如下。

- 这个解和我们在步骤15中计算的解是一样的，也就是说，%SUNDIALS的KINSOL包的接口确实做了它们应该做的事。这不应该是一个惊喜，但重要的一点是，我们不必自己花时间去实现高级非线性求解器所依据的复杂算法。

- KINSOL能够避免各种操作，比如在实际上没有必要的时候重建雅各布矩阵。将上述输出中的线性求解次数与我们重建雅各布矩阵和计算其因式分解的次数相比较，应该可以清楚地看到，这在计算时间上带来了非常可观的节省，而我们却不需要实现复杂的算法来确定何时需要重建这些信息。

[1.x.2863]

[1.x.2864]

除了我们在这里考虑的小问题之外，稀疏的直接求解器需要太多的时间和内存--我们需要一个迭代求解器，就像我们在许多其他程序中使用的那样。然而，在目前的情况下，构建一个昂贵的预处理程序（例如，一个几何或代数多重网格方法）的权衡是不同的。由于我们可以在许多线性求解中重复使用同一个矩阵，我们也可以对预处理程序做同样的处理，与我们只在单一线性求解中使用预处理程序相比，在构建一个好的预处理程序上投入更多的工作更容易被证明，就像在许多其他情况下一样。

但迭代求解器也提供了其他机会。例如（正如在介绍中简要讨论的那样），只要我们离实际的解还很远，我们可能不需要在早期的非线性迭代中解到非常高的精度（小公差）。这就是那里提到的Eisenstat-Walker技巧的基础。

KINSOL提供了做线性解的函数，有一个需要达到的目标公差。我们在上面的程序中忽略了它，因为我们使用的直接求解器不需要公差，而是精确地求解线性系统（当然是四舍五入），但是迭代求解器可以利用这种信息--事实上也应该如此。


examples/step-78/doc/intro.dox

[1.x.2865]

[1.x.2866]

布莱克-斯科尔斯方程是一个偏微分方程，它有点不符合普通的方案。它描述了一个 "欧洲看涨 "股票期权的公平价格是多少。不用说得太详细，股票 "期权 "是一个人可以从银行购买的合同，它允许我，但不要求我，在未来某个固定的时间[2.x.7360]以固定的价格[2.x.7359]购买特定股票。那么，作为这种期权的买方要回答的问题是："我认为这样的合约值多少钱？"，或者作为卖方，"我需要为这个合约收取多少钱？"，这既是合约在时间[2.x.7361]前的函数，也是股票价格[2.x.7363]的函数。费舍尔-布莱克和迈伦-斯科尔斯在假设股票价格表现出随机的价格波动，具有一定的 "波动性"，再加上背景的指数价格上涨（可以认为是通货膨胀率，随着时间的推移，所有货币都会贬值）的情况下，得出了这种期权的公平价格[2.x.7364]的偏微分方程。由于他们的工作，布莱克和斯科尔斯在1997年获得了诺贝尔经济科学奖，这使得这是第一个处理有人获得诺贝尔奖的问题的教程程序 [2.x.7365] 。

该公式如下。

[1.x.2867]

其中

[1.x.2868]



我们应该这样解释这个方程，它是一个时间依赖的偏微分方程，一个 "空间 "变量 [2.x.7366] 是股票的价格，[2.x.7367] 是时间 [2.x.7368] 的期权价格，如果当时的股票价格是 [2.x.7369] 。

[1.x.2869]

在继续讨论其数值解法之前，这个方程中存在一些值得讨论的怪异现象。首先，"空间 "域[2.x.7370]是无界的，因此[2.x.7371]的值也可以是无界的。这是因为股票价格可能有一个实际的上限，但没有一个概念上的上限。那么边界条件[2.x.7372]作为[2.x.7373]可以解释如下。如果股票价格（今天或[2.x.7375]时）是[2.x.7376]，那么允许我以价格[2.x.7374]购买股票的期权的价值是多少？人们期望它是[2.x.7377]加上一些通货膨胀的调整，或者，如果我们真的真正考虑到[2.x.7378]的巨大价值，我们可以忽略[2.x.7379]，得出无限边界的边界值应该是上面所说的[2.x.7380]形式。

在实践中，对于我们使用有限元方法来解决这个问题，我们需要对[2.x.7381]进行约束。由于这个方程描述的是价格，而谈论价格为负值是没有意义的，我们将设定[2.x.7382]的下限为0。然后，对于上限，我们将选择一个非常大的数字，一个[2.x.7383]不太可能达到的数字。我们将称其为[2.x.7384]。所以，[2.x.7385] 。

第二，在截断域之后，我们需要问在这个现在的有限边界上我们应该摆出什么边界值。为了解决这个问题，我们使用 "看跌-看涨 "平价 [2.x.7386] 。一个 "拉动期权 "是指我们被允许，但不是必须，在未来的某个时间以价格 [2.x.7387] 向某人出售*股票 [2.x.7388] 。这说明

[1.x.2870]

其中[2.x.7389]是看涨期权的价值，而[2.x.7390]是看跌期权的价值。由于我们预计[2.x.7391]为[2.x.7392]，这说明

[1.x.2871]

而我们可以用这个作为我们的有限点的合理边界条件 [2.x.7393] 。

Block-Scholes 方程的第二个复杂之处在于，我们得到的是一个最终条件，而不是初始条件。这是因为我们知道期权在[2.x.7394]时的价值：如果[2.x.7395]时的股票价格是[2.x.7396]，那么我们就没有动力使用我们的期权买入价格[2.x.7397]，因为我们可以在公开市场上以更低的价格买入该股票。所以[2.x.7398]为[2.x.7399] 。另一方面，如果在[2.x.7400]时我们有[2.x.7401]，那么我们可以通过期权以[2.x.7402]的价格买入股票，并立即在市场上以[2.x.7403]的价格再次卖出，给我带来[2.x.7404]的利润。换句话说，[2.x.7405]换取[2.x.7406] 。因此，我们只知道在*结束时间*的[2.x.7407]的值，而不知道初始时间--事实上，找出当前时间的公平价格（传统上被认为是[2.x.7408]）是解决这些方程的关键所在。

这意味着这不是一个在时间上向前推进的方程，实际上是在时间上*向后推进的。因此，通过改变变量[2.x.7409]来反向解决这个问题是有意义的，现在[2.x.7410]表示打击时间[2.x.7411]之前的时间。

有了这一切，我们最终得到了以下问题。

[1.x.2872]



从概念上讲，这是一个变量[2.x.7412]的平流-扩散-反应问题：有一个二阶导数的扩散项，一个一阶导数的平流项，以及一个零阶反应项。我们可以预期这个问题在实践中会有一些宽容，因为对于现实中的系数值，它是扩散主导的。但是，由于问题中的平流项，我们将不得不小心地进行网格细化和时间步长的选择。还有一个问题是，扩散项是以非保守的形式写的，因此按部分积分并不明显。这将在下一节中讨论。

[1.x.2873]

我们将使用IMEX方法解决这个问题。特别是，我们首先用theta方法进行时间离散，随后将为平流和扩散项选择不同的theta值。让[2.x.7413]近似于[2.x.7414] 。

[1.x.2874]

这里，[2.x.7415]是时间步长。鉴于这种时间离散化，我们可以通过与测试函数相乘，然后通过部分积分来进行空间离散化。因为其中有一些有趣的细节，由于这个方程中的平流和非平流项，这个过程将被详细解释。

因此，我们首先用测试函数相乘，[2.x.7416] 。

[1.x.2875]




像往常一样，（1）变成[2.x.7417]，（4）变成[2.x.7418]，其中[2.x.7419]，我们不仅用[2.x.7420]表示函数[2.x.7421]，而且用离散化后的节点值向量表示。

有趣的部分来自于（2）和（3）。


对于（2），我们有。

[1.x.2876]



这里有两个积分，或多或少都是一样的，区别在于积分前面的系数略有不同，以及V的时间步骤不同。因此，考虑一般的积分，我们将用部分积分的方法来解决这个问题。

[1.x.2877]



因此，在加入常数并将[2.x.7422]换成[2.x.7423]（如适用）后，我们对（2）得出如下结论。

[1.x.2878]

但是，由于矩阵[2.x.7424]涉及一个平流项，我们将在那里选择[2.x.7425]--换句话说，我们使用显式欧拉方法来处理平流问题。相反，由于矩阵[2.x.7426]涉及扩散项，我们将在那里选择[2.x.7427]--即我们用二阶Crank-Nicolson方法处理扩散。

因此，我们得出以下结论。

[1.x.2879]



现在，要处理（3）。为此，我们将再次通过考虑上述的一般情况来进行。

[1.x.2880]



因此，在加入常数并将[2.x.7428]换成[2.x.7429]（如适用）后，我们对（3）得出如下结论。

[1.x.2881]

就像以前一样，我们将用[2.x.7430]来表示矩阵[2.x.7431]，用[2.x.7432]表示矩阵[2.x.7433] 。因此，我们对（3）得出以下结果。

[1.x.2882]



现在，把所有的东西放在一起，我们得到以下布莱克-斯科尔斯方程的离散形式。

[1.x.2883]

因此，我们总共有。

[1.x.2884]



像往常一样，我们可以把未知量写在左边，把已知量写在右边。这就导致了在每个时间步骤中必须解决的以下线性系统。

[1.x.2885]









[1.x.2886] 对于这个程序，我们将使用制造解决方案的方法（MMS）来测试它是否正确工作。这意味着，我们将选择我们的解决方案是类似于步骤7的某个函数。对于我们的案例，我们将使用。

[1.x.2887]

这意味着，利用我们的PDE，我们得出了以下问题。

[1.x.2888]

其中，[2.x.7434] 。这个设置现在有方程本身和[2.x.7435]处的边界条件的右手边，这是我们以前没有的，同时还有不符合实际情况的 "最终 "条件（或者，用[2.x.7436]-时间 "初始条件"）。我们将以这样的方式在代码中实现这一点，以便于交换 -- 上述变化的引入只是为了能够使用制造的解决方案。

如果程序工作正常，那么它应该产生（**）作为解决方案。这确实意味着我们需要在一定程度上修改我们的变异形式，以考虑到非零的右手边。

首先，我们定义如下。

[1.x.2889]

因此，我们得出了新的方程式。

[1.x.2890]



然后我们按上述方法解决这个方程。


examples/step-78/doc/results.dox



[1.x.2891]


下面是该程序的输出。

[1.x.2892]



更有趣的是收敛表的输出。它们被输出到控制台，以及一个LaTeX文件中。收敛表如上所示。在这里，你可以看到，相对于[2.x.7438]-norm，解决方案的收敛率为[2.x.7437]，相对于[2.x.7440]-norm，解决方案的收敛率为[2.x.7439]。


下面是解决方案的可视化。

<div style="text-align:center;"> <img src="https://www.dealii.org/images/steps/developer/step-78.mms-solution.png" alt="MMS问题的解决方案。"> </div>


examples/step-79/doc/intro.dox

[1.x.2893]

[1.x.2894]

弹性介质的拓扑优化是一种用于优化承受某种载荷的结构的技术。理想情况下，我们希望通过选择一个放置材料的区域[2.x.7441]，使置于结构上的最大应力最小化。换句话说。

[1.x.2895]



[1.x.2896]



[1.x.2897]



这里，[2.x.7442]是由外力[2.x.7443]引起的体内应力，为了简单起见，我们假设材料是线性弹性的，因此[2.x.7444]是应力-应变张量，[2.x.7445]是作为位移[2.x.7446]函数的小变形应变--关于线性弹性的详情，见步骤8 和步骤17。在上面的表述中，[2.x.7447]是我们愿意为构建物体提供的最大材料量。最后一个约束条件是与应力[2.x.7448]和力[2.x.7449]有关的偏微分方程，它只是稳态力平衡。

也就是说，上面的无穷大准则产生了一个问题：作为材料位置的函数，这个目标函数必然是不可微分的，使优化的前景相当暗淡。因此，取而代之的是，拓扑优化的一个常见方法是通过优化一个相关的问题来找到一个近似的解决方案：我们希望最小化应变能量。这是对物体因变形而储存的势能的衡量，同时也是对结构总变形的衡量。

[1.x.2898]



[1.x.2899]



[1.x.2900]



目标函数的值是用有限元方法计算的，其中的解决方案是位移。这被放置在一个非线性求解器的循环中，求解一个表示材料放置的向量。

[1.x.2901]

在实际操作中，我们只能建造材料在任何给定的点上要么存在，要么不存在的物体--也就是说，我们会有一个描述材料填充区域的指标函数[2.x.7450]，并且我们想通过优化问题找到这个指标。在这种情况下，优化问题变成了组合性的，而且解决起来非常昂贵。取而代之的是，我们使用一种叫做各向同性的固体材料与惩罚的方法，或SIMP。  [2.x.7451]

SIMP方法是基于一个想法，即允许材料存在于密度[2.x.7452]在0和1之间的位置。密度为0表明材料不存在，它不是结构的一部分，而密度为1表明材料存在。0和1之间的值并不反映我们在现实世界中可以创造的设计，但允许我们将组合问题变成一个连续问题。然后我们看一下密度值 [2.x.7453] ，约束条件是 [2.x.7454] 。最小值[2.x.7455]，通常选择在[2.x.7456]左右，避免了出现无限应变能量的可能性，但小到足以提供准确的结果。

这种 "密度 "对介质弹性的影响的直接应用是简单地将介质的刚度张量[2.x.7457]乘以给定的密度，即[2.x.7458] 。然而，这种方法经常给出密度值离0和1都很远的最佳解决方案。由于人们希望找到一个现实世界的解决方案，即材料要么存在，要么不存在，因此对这些介于两者之间的值进行惩罚。一个简单有效的方法是将刚度张量乘以密度，并将其提高到某个整数功率的惩罚参数 [2.x.7459] ，因此 [2.x.7460] 。这使得远离0或1的密度值变得不那么有效。已经证明，使用[2.x.7461]足够高，可以产生'黑白'的解决方案：也就是说，可以得到最佳的解决方案，其中材料在所有点上要么存在，要么不存在。

更多的材料应该总是提供一个具有较低应变能量的结构，因此不等式约束可以被看作是一个等式，其中使用的总体积是最大体积。

使用这种密度思想也使我们能够重新构建优化问题的体积约束。使用SIMP后，优化问题就变成了以下内容。

[1.x.2902]



[1.x.2903]



[1.x.2904]



[1.x.2905]

最后一个约束，即线性动量的平衡（我们将称之为弹性方程），给出了一种在给定密度[2.x.7462]和[2.x.7463]的情况下寻找[2.x.7464] 的方法。

[1.x.2906] 在与时间无关的极限中，弹性方程为

[1.x.2907]

在我们将关注的情况下，我们将假设介质具有线性材料响应，在这种情况下，我们有

[1.x.2908]

在我们下面要做的一切中，我们将始终把位移场[2.x.7465]视为唯一的解变量，而不是把[2.x.7466]和[2.x.7467]视为解变量（像在混合公式中那样）。

此外，我们将假设材料是线性各向同性的，在这种情况下，应力-应变张量可以用Lam&eacute;参数[2.x.7468]来表示，例如

[1.x.2909]

参见步骤8，了解这种转变的原理。

对目标函数进行分项积分，得到

[1.x.2910]

然后将线性弹性方程代入其中，可以得到

[1.x.2911]

因为我们假设没有身体的力量，这进一步简化为

[1.x.2912]

这就是我们从现在开始要考虑的治理方程的最终形式。

[1.x.2913]

通常情况下，拓扑优化问题的解决方案是依赖于网格的，因此问题是不成立的。这是因为随着网格的进一步细化，往往会形成分形结构。随着网格分辨率的提高，最优解通常会获得越来越小的结构。对于这个问题，有一些相互竞争的解决方法，但对于一阶优化来说，最流行的是灵敏度滤波器，而二阶优化方法则倾向于使用密度滤波器。

由于滤波器会影响应变能量的梯度和Hessian（即目标函数），所以滤波器的选择会对问题的解决产生影响。作为二阶方法的一部分，密度滤波器的工作原理是引入一个未经过滤的密度，我们称之为[2.x.7469] ，然后要求密度是未经过滤的密度的卷积。

[1.x.2914]

这里，[2.x.7470]是一个运算符，因此[2.x.7471]是[2.x.7472]在[2.x.7473]周围区域的某种平均值 -- 即，它是[2.x.7474]的平滑版本。

这可以防止棋盘效应；滤波器的半径允许用户为我们寻求的最佳结构定义一个有效的最小光束宽度。

<div style="text-align:center;"> <img src="https://www.dealii.org/images/steps/developer/step-79.checkerboard.png" alt="Checkerboarding occurring in an MBB Beam"> </div>

[1.x.2915]

现在的最小化问题是

[1.x.2916]



[1.x.2917]



[1.x.2918]



[1.x.2919]



[1.x.2920]



处理不等式约束的方法是，首先引入松弛变量，其次使用对数障碍来确保我们得到一个内点方法。惩罚参数将是[2.x.7475] ，下面的松弛变量是<ol> [2.x.7476] [2.x.7477] -对应于下限的松弛变量 [2.x.7478] [2.x.7479] [2.x.7480] -对应于上限的松弛变量。[2.x.7481] [2.x.7482] 现在得出以下问题。

[1.x.2921]



[1.x.2922]



[1.x.2923]



[1.x.2924]



[1.x.2925]



[1.x.2926]



有了这些变量，我们就可以按照通常的方法来解决限制性优化问题。我们引入一个拉格朗日，通过将约束条件乘以拉格朗日乘数，将目标函数和约束条件结合起来。具体来说，我们将使用以下符号表示各种约束条件的拉格朗日乘数。<ol> [2.x.7483] [2.x.7484] ：对应于弹性约束的拉格朗日乘数， [2.x.7485] [2.x.7486] [2.x.7487] ：对应于卷积过滤器约束的拉格朗日乘数， [2.x.7488] [2.x.7489] [2.x.7490] ：对应于下层松弛变量的拉格朗日乘数，以及 [2.x.7491] [2.x.7492] [2.x.7493] ：对应于上限松弛变量的拉格朗日乘数。  [2.x.7494] [2.x.7495] 有了这些变量，拉格朗日函数的内容如下。

[1.x.2927]



然后优化问题的解决方案需要满足所谓的[Karush-Kuhn-Tucker（KKT）条件]（https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions）。拉格朗日相对于其所有参数的导数需要等于零，而且由于我们有不等式约束，我们也有 "互补性 "条件。由于我们这里有一个无穷大的问题，这些条件都涉及到拉格朗日相对于某些测试函数的方向性导数--换句话说，所有这些条件都必须以弱形式表述，因为这通常是有限元方法的基础。

障碍法允许我们最初削弱典型的KKT条件所要求的 "补充松弛"。通常情况下，我们会要求[2.x.7496] ，但屏障公式给出的KKT条件是[2.x.7497] ，其中[2.x.7498] 是我们的屏障参数。作为障碍法的一部分，这个参数必须被驱动到接近0，以便对原始问题有一个良好的近似。

在下文中，让我们陈述所有这些条件，其中[2.x.7499]是一个测试函数，它与拉格朗日相对于[2.x.7500]函数的变异导数自然成对。为了简单起见，我们引入[2.x.7501]来表示边界上受力的部分，并使用诺伊曼边界条件。

<ol> [2.x.7502] 静止性。

[1.x.2928]



[1.x.2929]



[1.x.2930]

[2.x.7503] [2.x.7504] 原始的可行性。

[1.x.2931]



[1.x.2932]



[1.x.2933]



[1.x.2934]

[2.x.7505] [2.x.7506] 互补性松弛。

[1.x.2935]



[1.x.2936]

[2.x.7507] [2.x.7508] 双重可行性。

[1.x.2937]

[2.x.7509][2.x.7510] 。

[1.x.2938]

上面的优化条件除了复杂之外，还属于不容易解决的类型。它们通常是非线性的，而且有些关系也是不等式的。我们将使用牛顿方法计算搜索方向来解决非线性问题，并在下面讨论步长程序时再来讨论如何处理不等式问题。

牛顿方法应用于上述方程的结果是下面列出的方程组。其中，关于[2.x.7511]变量的变异导数在[2.x.7512]方向取值。

<ol> [2.x.7513] 静止性。这些方程确保我们在受约束时处于目标函数的临界点。

方程式1

[1.x.2939]



方程式2

[1.x.2940]



方程3

[1.x.2941]

[2.x.7514]

[2.x.7515] 原始可行性。这些方程保证了平等约束的满足。

方程4

[1.x.2942]



方程5

[1.x.2943]



方程6

[1.x.2944]



方程7

[1.x.2945]

[2.x.7516]

[2.x.7517] 互补松弛性。这些方程基本上确保了障碍的满足--在最终的解决方案中，我们需要 [2.x.7518] 。

方程8

[1.x.2946]



方程9

[1.x.2947]

[2.x.7519]

[2.x.7520] 双重可行性。松弛和松弛变量的拉格朗日乘数必须保持大于0。（这是唯一没有在[2.x.7521]函数中实现的部分）。

[1.x.2948]

[2.x.7522] [2.x.7523]




[1.x.2949]我们使用带有[2.x.7524]元素的四边形网格来离散位移和位移Lagrange乘数。分片常数[2.x.7525]元素被用来离散密度、未过滤密度、密度松弛变量以及松弛变量和过滤约束的乘数。

[1.x.2950]

虽然上面的大部分讨论都是按照传统的和众所周知的方法来解决非线性优化问题，但事实证明，这个问题在实践中其实是相当难解决的。特别是，它是相当非线性的，一个重要的问题不仅仅是像上面讨论的基于牛顿方法的搜索方向[2.x.7526]，而是人们需要花相当多的注意力在这个方向上要走多远。这通常被称为 "线搜索"，归结为如何选择步长[2.x.7527]的问题，以便我们以尽可能有效的方式从当前迭代[2.x.7528]移动到下一个迭代[2.x.7529]。众所周知，我们最终需要选择[2.x.7530]来实现牛顿方法的二次收敛；然而，在早期迭代中，采取如此长的步长实际上可能会使事情变得更糟，要么导致一个目标函数更差的点，要么在这个点上的约束条件的满足程度不如在[2.x.7531]时。

已经提出了非常复杂的算法来处理这个问题 [2.x.7532] [2.x.7533] 。在这里，我们实现了一个看门狗搜索算法 [2.x.7534] 。在讨论这个算法时，我们将使用向量[2.x.7535]来表示所有的原始变量--过滤和未过滤的密度、松弛变量和位移，并使用向量[2.x.7536]来表示所有的对偶向量。上述非线性方程组的（增量）解决方案现在将被称为[2.x.7537]和[2.x.7538]，而不是[2.x.7539] 。一个优点函数（后面有详细解释）在这里被称为[2.x.7540] 。

应用于具有给定障碍参数的子问题的看门狗算法以如下方式工作。首先，当前迭代被保存为 "看门狗 "状态，并记录看门狗状态的优点。然后采取一个最大的可行的牛顿步骤。如果功绩比第一步充分减少，则接受这个新步骤。如果不是，则采取另一个最大可行的牛顿步骤，并再次将功绩与看门狗的功绩进行比较。如果经过一定数量（通常在5到8之间）的牛顿步骤后，功绩没有充分减少，算法从看门狗状态或最后一次迭代中选择一个缩放的牛顿步骤，以保证功绩充分减少，该步骤被接受。一旦一个步骤被接受，就会测量KKT误差的规范，如果它足够小，就会减少障碍值。如果不够小，则将最后接受的步骤作为新的看门狗步骤，并重复这一过程。


以上，"最大可行步长 "是对牛顿步长在原始变量和对偶变量中的一个缩放，其公式为

[1.x.2951]



[1.x.2952]



以上，[2.x.7541]是任何步骤上允许的 "到边界的分数"。由于导数在边界附近变得条件不良，这种技术代表了[信任区域](https://en.wikipedia.org/wiki/Trust_region)，对于确保未来的良好近似是必要的。  [2.x.7542]被认为是[2.x.7543]，这允许随着障碍物变小而向边界靠近。未来，在实施减少障碍物的LOQO算法时，必须将其保持在0.8，因为障碍物参数可能变化很大。

另外，我们需要处理我们用来强制执行松弛变量的正性约束的对数障碍[2.x.7544]：在我们解决的最终优化问题的声明中，我们添加了术语

[1.x.2953]

问题是我们应该如何选择惩罚因子 [2.x.7545] 。与所有的惩罚方法一样，我们实际上只对极限[2.x.7546]感兴趣，因为这才是我们真正想要解决的问题，受松弛变量的正性约束。另一方面，我们需要选择足够大的[2.x.7547]来使问题在实践中可以解决。因此，实际的实现从较大的[2.x.7548]值开始，并随着外迭代的进行而逐渐减小它。

在这里实现的单调方法中，每当在当前的障碍参数下达到某种程度的收敛时，就会更新障碍参数。我们使用KKT条件的[2.x.7549]准则来检查每个障碍大小的收敛情况。要求是[2.x.7550]，其中[2.x.7551]是任何障碍大小的常数，[2.x.7552]是障碍参数。这迫使在以后的迭代中更好地收敛，这与[IPOPT](https://coin-or.github.io/Ipopt/)（一个用于大规模非线性优化的开源软件包）中的要求相同。

在这里，障碍值在较大的数值下是线性减少的，在较小的数值下是超线性的。在较大的数值下，它被乘以一个常数（大约0.6），而在较低的数值下，障碍值被提高到某个指数（大约1.2）的障碍值所取代。事实证明，这种方法能够有效地保持大障碍值下子问题的可解性，同时在较小的障碍值下仍然允许超线性收敛。在实践中，这看起来像以下情况。

[1.x.2954]



虽然在达到收敛时大步减少障碍物的大小被广泛使用，但最近的研究表明，通常使用每次迭代自适应更新障碍物的算法会更快，也就是说，我们在每次迭代结束时使用具体的标准来决定下一次迭代中的惩罚参数应该是什么，而不是使用独立于当前解决方案的减少因素。也就是说，这样的方法也比较复杂，我们在此不做介绍。

[1.x.2955]

上面概述的算法利用了 "优点函数"。功绩函数用于确定从[2.x.7553]到建议点[2.x.7554]的一步是否有利。在无约束的优化问题中，人们可以简单地用我们试图最小化的目标函数来检查，通常使用[沃尔夫和戈尔茨坦条件]（https://en.wikipedia.org/wiki/Wolfe_conditions）等条件。

在有约束的优化问题中，问题是如何平衡目标函数的减少和可能增加的对约束的违反。一个建议的步骤可能会使目标函数变小，但离满足约束条件的点集更远，或者相反。这种权衡通常通过使用结合这两个标准的优点函数来解决。

在这里，我们使用一个精确的[2.x.7555]功绩函数来测试步骤。

[1.x.2956]



这里，[2.x.7556]是一个惩罚参数。这个优点函数是精确的，意味着存在一些[2.x.7557]，以便对于任何[2.x.7558]，优点函数的最小值与原始问题的位置相同。这个惩罚参数被更新（根据Nocedal和Wright[2.x.7559]的建议），如下。

[1.x.2957]

其中[2.x.7560]是目标函数的Hessian，[2.x.7561]是我们的决策（原始）变量的矢量，[2.x.7562]是目标函数，[2.x.7563]是当前平等约束的误差。

我们使用这种方法的部分原因是在寻找右手边时已经计算了大部分必要的部分，而且使用精确的优点函数可以确保它在与整个问题相同的位置被最小化。最近的研究表明，人们可以用所谓的 "滤波方法 "代替优点函数，人们应该考虑使用这些方法，因为它们被证明是更有效的。


examples/step-79/doc/results.dox



[1.x.2958]

[1.x.2959]上面使用的算法是针对一个传统的拓扑优化问题进行测试的，这个问题叫做Messerschmitt-Bolkow-Blohm Beam（MBB Beam）。

这个问题考虑的是在一个6个单位宽、1个单位高的矩形上可以建立的最佳二维结构。底部的角在[2.x.7564]方向用零Dirichlet边界条件固定住，通过强制执行Neumann边界条件在梁的顶部中心施加一个向下的力。边界的其余部分被允许移动，并且没有施加任何外力，这采取了零诺伊曼边界条件的形式。从本质上讲，我们提出了以下问题。我们应该如何设计一座桥，使桥的左下角和右下角的点在滚轮上，允许这些点在水平方向上移动，但不允许在垂直方向上移动，从而使响应于中心的垂直力的位移最小。

虽然领域的总体积是6个单位，但结构允许有3个单位的材料。由于问题的对称性，可以在一个宽为3、高为1的矩形上提出，方法是将原域切成两半，并沿切边在[2.x.7565]方向使用零迪里希特边界条件。也就是说，解决方案的对称性是一个很好的指标，表明程序正在按预期工作，所以我们在整个领域上解决问题，如下图所示。  [2.x.7566]

<div style="text-align:center;"> <img src="https://www.dealii.org/images/steps/developer/step-79.mbbgeometry.png" alt="MBB问题域和边界条件"> </div>


使用上面讨论的程序，我们找到了MBB梁的最小体积，解决方案的各个组成部分看起来如下。

<div class="onecolumn" style="width: 80%; text-align: center;"> <div> <img src="https://www.dealii.org/images/steps/developer/step-79.filtereddensity.png" alt="过滤的密度溶液"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-79.unfiltereddensity.png" alt="未过滤的密度溶液"> </div> </div>


这些图片表明，我们在这里发现的情况与人们通常在关于该主题的其他出版物中看到的情况相一致 [2.x.7567] 。也许更有趣的是，结果看起来像一座桁架桥（除了我们在桁架的顶部施加负载，而不是像真正的桁架桥那样在底部施加负载，类似于 "桥面桁架 "桥），这表明几个世纪以来一直用于桥梁建设的设计确实是基于我们现在可以证明在某种意义上是最佳的想法。




[1.x.2960]

上面显示的结果花了大约75次迭代才找到，考虑到在每次迭代中解决大型线性系统的费用，这相当令人担忧。看一下演化过程，收敛确实有快速发生和缓慢发生的时候。我们认为这是由于在何时和如何减少边界值方面缺乏精确性，以及我们对优点函数的选择不够理想。在未来，用LOQO障碍更新代替单调还原，以及用马尔科夫滤波器代替优点函数，将大大减少必要的迭代次数。

障碍物的减少在收敛的中间阶段最为敏感，这是有问题的，因为我们似乎需要它快速减少，然后缓慢减少，然后又快速减少。

其次，这里使用的线性求解器只是基于SparseDirectUMFPACK类的稀疏直接求解器。这在小问题上效果还不错，但是上面详述的优化问题的表述有相当多的变量，因此线性问题不仅大，而且在许多行中有很多非零项，即使在总体上仍然比较粗糙的网格上。因此，解算器的时间在计算中占主导地位，需要采用更复杂的方法来解决线性系统。


examples/step-8/doc/intro.dox

[1.x.2961]

[1.x.2962]


在现实生活中，大多数偏微分方程实际上是方程组。相应地，解通常是矢量值的。deal.II库支持这样的问题（见[2.x.7568]模块中的大量文档），我们将表明这大多是相当简单的。唯一比较复杂的问题是在组装矩阵和右手边，但这些也很容易理解。

[2.x.7569]

在这个教程程序中，我们将想解决[1.x.2963]。它们是对拉普拉斯方程的扩展，有一个矢量值的解，描述了受力的刚体在每个空间方向的位移。当然，力也是矢量值的，意味着在每一个点上它都有一个方向和一个绝对值。

人们可以用多种方式来写弹性方程。以最明显的方式显示与拉普拉斯方程的对称性的是将其写成

[1.x.2964]

其中[2.x.7570]是每一点的矢量值位移，[2.x.7571]是力，[2.x.7572]是一个等级4的张量（即它有四个指数），编码应力-应变关系--本质上，它代表胡克斯定律中的[1.x.2965]，将位移与力联系起来。  在许多情况下，如果我们想要模拟的物体的变形是由不同的材料组成的，那么[2.x.7573]将取决于[2.x.7574]。

虽然上述方程的形式是正确的，但这并不是它们通常的推导方式。事实上，位移的梯度[2.x.7575]（一个矩阵）没有物理意义，而其对称版本。

[1.x.2966]

做，通常被称为 "应变"。(在这里和下文中，[2.x.7576] 。我们还将使用[1.x.2967]，即只要同一指数在方程式中出现两次，就意味着对该指数进行求和；但是，我们将不区分上下指数）。)有了这个应变的定义，弹性方程就读作

[1.x.2968]

你可以把它看作是拉普拉斯方程对矢量值问题的更自然的概括。(首先显示的形式等同于这种形式，因为张量[2.x.7577]具有某些对称性，即[2.x.7578] ，因此[2.x.7579] 。)

当然，我们也可以把这些方程写成组件形式。

[1.x.2969]



在许多情况下，我们知道所考虑的材料是各向同性的，在这种情况下，通过引入两个系数[2.x.7580]和[2.x.7581]，系数张量减少为

[1.x.2970]



然后，弹性方程可以用更简单的形式重写。

[1.x.2971]

而各自的双线性形式则是

[1.x.2972]

或将第一项写成成分之和。

[1.x.2973]



[2.x.7582]按照写法，如果位移很小，我们可以假设[1.x.2974]是有效的，上面的方程一般被认为是对三维物体位移的正确描述。在这种情况下，上面的指数[2.x.7583]都是在集合[2.x.7584]上运行的（或者，在C++源中，在[2.x.7585]上运行）。然而，按照目前的情况，程序是在2d中运行的，虽然上面的方程在这种情况下也有数学意义，但它们只能描述一个真正的二维实体。特别是，它们不是对[2.x.7586]方向上无限大的体的横截面的适当描述；这与其他许多二维方程相反，这些方程可以通过假设体在[2.x.7588]-方向上具有无限大的范围和解函数不依赖于[2.x.7589]坐标来获得。另一方面，也有二维弹性模型的方程；例如，见维基百科上的[1.x.2975]、[1.x.2976]和[1.x.2977]文章。

但让我们回到最初的问题上。我们如何为这样一个方程组装矩阵？在[2.x.7590]模块的文档中给出了一个很长的答案，其中有许多不同的选择。从历史上看，下面所示的解决方案是该库早期唯一可用的解决方案。事实证明，它也是最快的。另一方面，如果百分之几的计算时间并不重要，还有比下面讨论的更简单、更直观的方法来组装线性系统，但这些方法直到本教程首次编写后的几年才可用；如果你对它们感兴趣，可以看看 [2.x.7591] 模块。

让我们回到如何组装线性系统的问题上来。首先我们需要一些关于形状函数在矢量值有限元情况下如何工作的知识。基本上，这归结为以下几点：让[2.x.7592]为我们建立矢量元素的标量有限元素的形状函数的数量（例如，我们将对矢量值有限元素的每个分量使用双线性函数，所以标量有限元素是我们在以前的例子中已经使用过的[2.x.7593]元素，以及两个空间维度的[2.x.7594]）。此外，让[2.x.7595]为矢量元素的形状函数数量；在两个空间维度中，我们需要为矢量的每个分量提供[2.x.7596]个形状函数，因此[2.x.7597] 。那么，矢量元素的[2.x.7598]个形状函数的形式为

[1.x.2978]

其中[2.x.7599]是第[2.x.7600]个单位向量，[2.x.7601]是告诉我们[2.x.7602]的哪个分量是不为零的函数（对于每个向量形状函数，只有一个分量是不为零的，其他都是零）。  [2.x.7603]描述了形状函数的空间依赖性，它被认为是标量元素的第[2.x.7604]个形状函数。当然，虽然[2.x.7605]的范围是[2.x.7606]，但函数[2.x.7607]和[2.x.7608]的范围分别为[2.x.7609]（在二维）和[2.x.7610]。

例如（尽管这种形状函数的顺序不被保证，你也不应该依赖它），下面的布局可以被库使用。

[1.x.2979]

在这里

[1.x.2980]



[1.x.2981]



除了非常罕见的情况，你不需要知道标量元素的哪个形状函数[2.x.7611]属于矢量元素的一个形状函数[2.x.7612]。因此，让我们定义

[1.x.2982]

据此，我们可以将矢量形状函数写为

[1.x.2983]

现在你可以安全地忘记函数[2.x.7613]了，至少在这个例子程序的其余部分。

现在使用这个矢量形状函数，我们可以将离散的有限元解写为

[1.x.2984]

具有标量系数 [2.x.7614] 。如果我们定义一个模拟函数[2.x.7615]作为测试函数，我们可以将离散问题写成如下。找出系数[2.x.7616]，使得

[1.x.2985]



如果我们把双线性形式的定义和[2.x.7617]和[2.x.7618]的表示插入这个公式。

[1.x.2986]

我们注意到，在这里和下文中，指数[2.x.7619]在空间方向上运行，即[2.x.7620] ，而指数[2.x.7621]在自由度上运行。

因此，单元[2.x.7622]上的局部刚度矩阵有以下条目。

[1.x.2987]

其中[2.x.7623]现在是局部自由度，因此[2.x.7624] 。在这些公式中，我们总是取矢量形状函数[2.x.7625]的一些分量，当然，这些分量是如下给出的（见其定义）。

[1.x.2988]

与克朗克符号 [2.x.7626] 。由于这一点，我们可以删除一些对 [2.x.7627] 和 [2.x.7628] 的和。

[1.x.2989]



同样地，单元格[2.x.7629]对右侧向量的贡献是

[1.x.2990]



这就是我们要实现局部刚度矩阵和右手边向量的形式。

作为最后的说明：在第17步的例子程序中，我们将重新审视这里提出的弹性问题，并将展示如何在一个计算机集群上以%并行的方式解决这个问题。因此，所产生的程序将能够以更高的精度解决这个问题，而且如果需要的话，效率更高。此外，在第20步，[2.x.7630]"第21步"，以及其他一些后来的教程程序中，我们将重新审视一些矢量值问题，并展示一些技术，这些技术可能使实际通过上面显示的所有东西更简单，与[2.x.7631]等。


examples/step-8/doc/results.dox



[1.x.2991]


关于这个程序的结果，除了它们看起来很好之外，没有什么可说的。所有图片都是用VisIt从程序写入磁盘的输出文件中制作的。前两张图片显示了[2.x.7632]-和[2.x.7633]-位移的标量分量。

[2.x.7634]


你可以清楚地看到[2.x.7635]周围的位移[2.x.7636]和[2.x.7637]的来源，以及[2.x.7638]在原点的位移。

人们经常想做的是将位移显示为一个矢量场，也就是说，每一个点的矢量都说明了位移的方向和大小。不幸的是，这就有点麻烦了。为了理解为什么会这样，请记住，我们刚刚将我们的有限元定义为两个分量的集合（在[2.x.7639]维度）。我们没有说过这不仅仅是一个压力和一个浓度（两个标量），而是说这两个分量实际上是一个矢量值量的一部分，即位移。如果没有这方面的知识，DataOut类就会假定我们打印的所有单个变量都是独立的标量，然后VisIt和Paraview就会忠实地假定这确实是这样的。换句话说，一旦我们把数据写成标量，这些程序中就没有任何东西可以让我们把这两个标量字段粘贴到一起作为一个矢量字段。我们必须从根本上解决这个问题，即在 [2.x.7640] 。我们不会在这里这样做，而是让读者参考step-22程序，在那里我们展示了如何在一个更普遍的情况下这样做。话虽如此，我们还是忍不住要生成数据，以显示如果按照步骤22中讨论的方式实施，这将是什么样子。矢量场看起来是这样的（VisIt和Paraview随机选择几百个顶点来绘制矢量；从每个顶点绘制矢量会使图片无法阅读）。

[2.x.7641]


我们注意到，由于[2.x.7644]-和[2.x.7645]-力相对于这些轴是对称的，人们可能直观地期望解是关于[2.x.7642]-和[2.x.7643]-轴的对称。然而，作为矢量的力是不对称的，因此解决方案也不对称。


examples/step-9/doc/intro.dox

[1.x.2992]

[1.x.2993]


在这个例子中，我们的目的如下。<ol> [2.x.7646] 解决平流方程 [2.x.7647] ； [2.x.7648] 显示如果我们有一台多处理器机器，我们如何使用多线程来快速获得结果； [2.x.7649] 开发一个简单的细化准则。  [2.x.7650]虽然第二个目的在不参考代码的情况下很难进行一般性描述，但我们将在下文中讨论其他两个目的。然后将在程序中的相关地方详细介绍多线程的使用。然而，我们将遵循[2.x.7651]"多处理器访问共享内存的并行计算 "文件模块中详述的关于WorkStream方法的一般讨论。




[1.x.2994]

在本例程序中，我们要对平流方程的解进行数值近似计算

[1.x.2995]

其中[2.x.7652]是描述平流方向和速度的矢量场（如果[2.x.7653]，它可能取决于空间变量），[2.x.7654]是一个源函数，[2.x.7655]是解。该方程描述的物理过程是一个给定的流场[2.x.7656]，另一种物质随其流动，其密度或浓度由[2.x.7657]给出。该方程不包含这第二种物质在其载体物质内的扩散，但有源项。

很明显，在流入地，上述方程需要用边界条件来增加。

[1.x.2996]

其中[2.x.7658]描述了边界的流入部分，正式定义为

[1.x.2997]

和[2.x.7659]是点[2.x.7660]处的域的向外法线。这个定义非常直观，因为由于[2.x.7661]指向外侧，如果传输方向[2.x.7663]指向内侧，即在流入边界，那么与[2.x.7662]的标量乘积只能是负数。数学理论规定，我们不能在边界的流出部分提出任何边界条件。

不幸的是，上述方程不能以稳定的方式用标准的有限元方法进行求解。问题是，这个方程的解在垂直于传输方向上具有不充分的规则性：虽然它们沿 "风场"[2.x.7664]定义的流线是平滑的，但它们在垂直于这个方向上可能是不连续的。这很容易理解：方程[2.x.7665]的意思实质上就是[1.x.2998]。但该方程对垂直方向的导数没有影响，因此，如果[2.x.7666]在流入边界的某一点上不连续，那么这个不连续将简单地沿着从这个边界点开始的风场流线传输。这些不连续会导致数值不稳定，使标准的连续有限元离散化不可能获得稳定的解。

解决这一困难的标准方法是 [2.x.7667] "流线-上风Petrov-Galerkin" [2.x.7668] (SUPG)方法，有时也称为流线扩散法。对该方法的良好解释可以在 [2.x.7669] 中找到。从形式上看，这种方法取代了我们从强形式推导出微分方程的弱形式的步骤。我们不是用测试函数[2.x.7670]乘以方程并在域上积分，而是乘以[2.x.7671] ，其中[2.x.7672]是在（局部）网格宽度范围内选择的参数[2.x.7673]；通过设置[2.x.7674]通常可以获得良好的结果。 为什么这被称为 "流线扩散 "将在下面解释；目前，让我们简单地认为这是我们如何推导出稳定的离散公式。这里[2.x.7675]的值小到足以使我们不引入过度的扩散，但大到足以使所产生的问题得到良好的解决。

使用上面定义的测试函数，问题的初始弱形式将要求找到一个函数[2.x.7676]，以便对于所有测试函数[2.x.7677]，我们有

[1.x.2999]

然而，我们希望将流入的边界条件[2.x.7678]弱化到这个问题中，这可以通过要求除了上述方程之外，我们还有

[1.x.3000]

为所有住在边界上的测试函数[2.x.7679]，它们来自一个合适的测试空间。事实证明，一个合适的检验函数空间恰好是[2.x.7680]乘以我们已经用于域内微分方程的检验空间中的函数[2.x.7681]的踪迹。因此，我们要求对于所有测试函数[2.x.7682]，我们有

[1.x.3001]

在不试图进行论证的情况下（请再次参阅关于一般的有限元方法，特别是流线扩散方法的文献），我们可以将微分方程和边界值的方程结合在我们的稳定化问题的以下弱表述中：找到一个离散函数[2.x.7683]，使得对于所有离散测试函数[2.x.7684]，存在着

[1.x.3002]




人们会认为，这将导致一个系统矩阵被倒置，其形式为

[1.x.3003]

与基函数 [2.x.7685] 。  然而，这是每一个数值分析师至少会遇到一次的陷阱（包括作者）：我们在这里扩大了解决方案 [2.x.7686] ，但如果我们这样做，我们将不得不解决这个问题

[1.x.3004]

其中[2.x.7687]是膨胀系数的向量，也就是说，我们必须解决我们可能天真的预期的转置问题。

这是我们在步骤3的介绍中提出的一个观点。在那里，我们认为为了避免这种问题，应该养成总是与检验函数[1.x.3005]相乘的习惯，而不是从右边得到正确的矩阵。为了得到我们所需要的线性系统的形式，最好将弱式改写为

[1.x.3006]

然后得到

[1.x.3007]

作为系统矩阵。我们将在程序中组装这个矩阵。




[1.x.3008]

看一下上面提到的双线性形式，我们看到离散解必须满足一个方程，其中弱形式的左手边有一个域项，即

[1.x.3009]

或如果我们将其拆分，则形式为

[1.x.3010]

如果我们想看看这将对应于什么强的方程形式，我们需要对第二项进行积分。这就产生了下面的公式，为了简单起见，我们暂时不考虑边界项。

[1.x.3011]

让我们暂时假设风场[2.x.7688]是无发散的，即[2.x.7689] 。然后将乘积法则应用于右边方括号内项的导数，并利用发散-绿色，我们将得到以下结果。

[1.x.3012]

这意味着，方程的强势形式将是这样的

[1.x.3013]

现在要认识到的是，[2.x.7690]是[2.x.7691]方向的导数[2.x.7692] [2.x.7693] 。因此，如果我们用[2.x.7694]来表示（就像我们经常用[2.x.7695]来表示边界处法线方向的导数一样），那么方程的强形式是

[1.x.3014]

换句话说，测试函数的不寻常选择相当于在强形式中增加了一个项，它对应于风场方向的二阶（即扩散）微分算子[2.x.7696]，即 "流线方向"。更全面的说明还必须探讨测试函数对边界值的影响，以及为什么有必要对右手边也使用相同的测试函数，但上面的讨论可能会使人明白该方法的 "流线扩散 "名称的由来。




[1.x.3015]

"Galerkin方法 "是指通过将方程乘以测试函数[2.x.7697]（然后在[2.x.7698]上进行积分）来获得弱表述，其中函数[2.x.7699]与解[2.x.7700]来自同一空间（尽管可能具有不同的边界值）。但这并不是严格意义上的必要条件。我们也可以想象从不同的函数集中选择测试函数，只要这个不同的函数集具有与原始函数集 "同样多的维度"，这样我们最终就会有与自由度同样多的独立方程（在无限维的情况下，所有这些都需要适当地定义）。利用这种可能性的方法（即以不同的方式选择测试函数集和解决方案集）被称为 "Petrov-Galerkin "方法。在目前的情况下，测试函数的形式都是[2.x.7701]，其中[2.x.7702]是来自解集。




[1.x.3016]

[上风方法](https://en.wikipedia.org/wiki/Upwind_scheme)在推导平流方程的稳定方案方面有很长的历史。一般来说，这个想法是，我们不是在 "这里 "看一个函数，而是在 "上游 "或 "上风 "的一小段距离看它，也就是说，"这里 "的信息最初来自哪里。这可能意味着不考虑[2.x.7703]，而是像[2.x.7704]这样的。或者，等于是在整合后，我们可以评估[2.x.7705]，而考虑[2.x.7706]的下游部分。  [2.x.7707] .由于各种原因，这将是很麻烦的。首先，如果[2.x.7709]恰好在[2.x.7710]之外，我们将不得不定义[2.x.7708]应该是什么；其次，数值计算积分将更加困难，因为我们不再在同一正交点评估[2.x.7711]和[2.x.7712]。但由于我们假设[2.x.7713]很小，我们可以做一个泰勒扩展。

[1.x.3017]

这个测试函数的形式现在看起来应该很熟悉。




[1.x.3018]

由于产生的矩阵不再是对称正定的，我们不能使用通常的共轭梯度方法（在SolverCG类中实现）来解决这个系统。相反，我们使用GMRES（Generalized Minimum RESidual）方法（在SolverGMRES中实现），它适用于我们这里的那种问题。




[1.x.3019]

对于我们将在本教程程序中解决的问题，我们使用以下领域和函数（在[2.x.7714]空间维度）。

[1.x.3020]

对于[2.x.7715]，我们扩展了[2.x.7716]和[2.x.7717]，只是将上面显示的最后一个组件再重复一次。

说了这么多，下面的评论是有必要的。<ol> [2.x.7718] 平流场[2.x.7719]大致以对角线方向从左下角向右上角传输解决方案，但叠加了一个摆动结构。  [2.x.7720] 右手边在流入边界条件产生的场中加入了左下角的一个圆球，然后沿着这个圆球传输。  [2.x.7721] 流入边界条件施加了一个加权的正弦结构，该结构与流场一起被传输。由于[2.x.7722]在边界上，加权项从未变得非常大。  [2.x.7723]




[1.x.3021]

在以前所有的自适应细化的例子中，我们都使用了Kelly等人首先开发的误差估计器，它为每个单元[2.x.7724]分配了以下指标。

[1.x.3022]

其中[2.x.7725]表示跨越单元格[2.x.7727]的一个面的法向导数的跳变。可以证明，这个误差指标使用的是二阶导数的离散类似物，由单元大小的一个幂加权，这个幂是根据这里假定使用的线性元素调整的。

[1.x.3023]

其本身与能量准则中的误差大小有关。

在目前的情况下，这个误差指标的问题是，它假定精确的解拥有二阶导数。在某些情况下，这对于拉普拉斯问题的解来说已经是个问题了，尽管那里大多数问题允许在[2.x.7728]中求解。如果解只在[2.x.7729]中，那么二阶导数在域的某些部分（低维）是奇异的，在网格细化的情况下，误差指标不会减少。因此，该算法将不断细化这些部分周围的单元，即细化为点或线（在2d中）。

然而，对于目前的情况，解通常不在[2.x.7730]中（而且这种缺失的规律性并不是像拉普拉斯方程那样的特殊情况），所以上述的误差指标并不真正适用。因此，我们将开发一个基于梯度的离散近似的指标。尽管梯度经常不存在，但这是我们唯一可用的标准，至少在我们使用连续元素时是如此。首先，我们注意到，给定两个单元[2.x.7731]，[2.x.7732]，其中心由矢量[2.x.7733]连接，我们可以对一个函数[2.x.7734]的方向导数进行近似，如下所示。

[1.x.3024]

其中[2.x.7735]和[2.x.7736]表示[2.x.7737]在各自单元格中心的评价。现在我们将上述近似值乘以[2.x.7738]，并对[2.x.7740]的所有邻居[2.x.7739]求和。

[1.x.3025]

如果连接[2.x.7741]与邻居的向量[2.x.7742]横跨整个空间（即大致为：[2.x.7743]在所有方向都有邻居），那么左侧表达式中括号内的项形成一个正则矩阵，我们可以将其反转，得到[2.x.7744]对[2.x.7745]的梯度的近似。

[1.x.3026]

我们将用[2.x.7746]表示右手边的近似值，我们将使用以下数量作为细化标准。

[1.x.3027]

这是受以下（不严谨的）论证的启发。

[1.x.3028]




examples/step-9/doc/results.dox



[1.x.3029]


这个程序的结果并不特别引人注目。它们由控制台输出、一些网格文件和每个网格的解决方案组成。首先是控制台的输出。

[1.x.3030]



相当多的单元格被用在最精细的层面上，以解决解决方案的特征。下面是第四和第十个网格。<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-9-grid-3.png" alt="细化周期中的第四个网格，显示对特征的一些适应性。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-9-grid-9.png" alt="细化周期中的第十个网格，显示完全捕捉到波。" width="400" height="400"> </div> <div> 以及第四和第十的解决方案。<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-9-solution-3.png" alt="第四个解决方案，显示我们解决了大多数特征，但有些仍然没有解决，显得很模糊。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-9-solution-9.png" alt="第十个解决方案，显示完全解决的流动。" width="400" height="400"> </div> </div> 以及网格和解决方案都被放大。<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-9-solution-3-zoom.png" alt="第四个解决方案的细节，显示我们解决了大多数特征，但有些仍然没有解决，显得模糊不清。特别是，较大的单元格需要细化。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-9-solution-9-zoom.png" alt="第十个解决方案的细节，显示我们需要比第四个解决方案中存在的更多单元格。" width="400" height="400"> </div> </div>

解决方案是由那部分沿摆动的平流场从左、下边界传送到右上方的部分，以及由左下角的源所产生的部分，其结果也是沿传送的。上面显示的网格很好地适应了解决这些特征。图中的比较表明，即使我们使用的是高阶近似，我们仍然需要自适应的网格细化来完全解决摆动。


