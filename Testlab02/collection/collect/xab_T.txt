ls.




[1.x.1021]

在三维空间中运行具有显著雷利数的对流代码需要大量的计算；在整个地球模拟的情况下，需要一或几亿个未知数的数量。这显然不能用一台机器来完成（至少在2010年我们开始编写这段代码时不能）。因此，我们需要将其并行化。科学代码在计算机集群的多台机器上的并行化几乎总是使用消息传递接口（MPI）来完成。这个程序也不例外，它遵循了第17步和第18步程序的一般精神，尽管在实践中它更多地借用了第40步，在该步中我们首先介绍了当我们想[1.x.1022]分布所有计算时使用的类和策略，而第55步则展示了如何为[2.x.2822] "向量值问题"：包括，例如，将网格分割成若干部分，使每个处理器只存储自己的份额和一些幽灵单元，以及使用任何处理器都不可能有足够的内存在本地保存组合解向量的条目的策略。我们的目标是以合理的可扩展性在数百甚至数千台处理器上运行这段代码。

[2.x.2823] 即使它有一个较大的数字，步骤40在逻辑上是在当前程序之前。第55步的情况也是如此。在你试图理解我们在这里所做的事情之前，你可能会想看看这些程序。

MPI是一个相当笨拙的编程接口。它是一套半面向对象的函数，虽然人们用它在网络上发送数据，但需要明确地描述数据类型，因为MPI函数坚持以[2.x.2824]对象的形式获得数据的地址，而不是通过重载或模板自动推断数据类型。我们已经在第17步和第18步中看到，如何通过将所有必要的通信放到deal.II库中，或者在这些程序中放到PETSc中，来避免几乎所有的MPI。我们将在这里做一些类似的事情：就像第40步和第55步一样，deal.II和底层的p4est库负责分配网格所需的所有通信，而我们将让Trilinos库（以及命名空间TrilinosWrappers中的包装器）处理线性代数组件的并行化问题。我们已经在step-31中使用了Trilinos，在这里也会这样做，不同的是我们将使用它的%并行能力。

Trilinos由大量的包组成，实现了基本的%并行线性代数操作（Epetra包），不同的求解器和预处理包，以及对deal.II不太重要的东西（例如。deal.II的Trilinos接口封装了Trilinos提供的许多与PDE求解器相关的东西，并提供了封装类（在命名空间TrilinosWrappers中），使Trilinos的矩阵、向量、求解器和预处理器类看起来与deal.II自己对这些功能的实现非常相同。然而，与deal.II的类相比，如果我们给它们提供必要的信息，它们可以在%并行中使用。因此，有两个Trilinos类我们必须直接处理（而不是通过包装器），这两个类都是Trilinos的Epetra基本线性代数和工具类库的一部分。  [2.x.2825] [2.x.2826] Epetra_Comm类是MPI "通信器 "的抽象，也就是说，它描述了多少台机器和哪些机器可以相互通信。   每个分布式对象，如稀疏矩阵或矢量，我们可能想在不同的机器上存储部分，需要有一个通信器对象来知道有多少部分，在哪里可以找到它们，以及如何访问它们。

  在这个程序中，我们只真正使用了一个通信器对象--基于MPI变量[2.x.2827]--它包含了[1.x.1023]个一起工作的进程。在[2.x.2828]机器上启动一个进程，但只在其中的一个子集上存储向量，产生一个只包括这个子集的机器的通信器对象是完全合法的；不过，在这里确实没有令人信服的理由这样做。

[2.x.2829] IndexSet类用于描述一个向量的哪些元素或一个矩阵的哪些行应该驻留在作为通信器一部分的当前机器上。要创建这样一个对象，你需要知道（i）元素或行的总数，（ii）你想在本地存储的元素的索引。我们将在下面的[2.x.2830]函数中设置这些[2.x.2831]，然后把它交给我们创建的每个%parallel对象。

  与PETSc不同，Trilinos没有假设矢量的元素需要被分割成连续的小块。至少在原则上，我们可以在一个处理器上存储所有偶数索引的元素，在另一个处理器上存储所有奇数索引的元素。当然，这不是很有效率，但这是可能的。此外，这些分区的元素不一定是相互排斥的。这一点很重要，因为在对解决方案进行后处理时，我们需要访问所有本地相关的或至少是本地活跃的自由度（定义见[2.x.2832]上的模块，以及步骤40中的讨论）。那么Trilinos矢量认为哪些元素是本地拥有的，对我们来说并不重要。我们所关心的是，它在本地存储了我们所需要的那些元素。  [2.x.2833]

还有一些与将网格分布到若干处理器上有关的概念；在尝试理解这个程序之前，你可能想看一下[2.x.2834]模块和步骤40或步骤55。  程序的其余部分几乎完全不知道我们没有完全在本地存储所有对象的事实。有几个地方我们必须将所有单元的循环限制在本地拥有的单元上，或者我们需要区分只存储本地拥有的元素的向量和存储本地相关的所有元素的向量（见[2.x.2835]"这个词汇表条目"），但总的来说，使程序在%parallel中运行所需的大量繁重工作都很好地隐藏在这个程序赖以建立的库中。在任何情况下，当我们在程序代码中看到这些位置时，我们会对它们进行评论。




[1.x.1024]

使程序并行化的第二个策略是利用这样一个事实，即今天大多数计算机都有一个以上的处理器，它们都可以访问相同的内存。换句话说，在这个模型中，我们不需要明确地说哪块数据在哪里，我们需要的所有数据都可以直接访问，我们要做的就是在可用的处理器之间分割[1.x.1025]这些数据。然后，我们将把它与上述的MPI并行化结合起来，也就是说，我们将让一台机器上的所有处理器一起工作，例如，为这台机器实际 "拥有 "的单元汇集对全局矩阵的局部贡献，而不是为那些被其他机器拥有的单元。我们将把这种策略用于本程序中经常进行的四种操作：组装斯托克斯和温度矩阵，组装形成斯托克斯预处理的矩阵，以及组装温度系统的右手边。

所有这些操作基本上都是这样的：我们需要在[2.x.2836]等于我们机器在用于所有通信的通信器对象中的索引（即[2.x.2837] ，如上所述）的所有单元中循环。我们实际要使用的测试，简明扼要地描述了我们为什么要测试这个条件，是 [2.x.2838] 。在每一个这样的单元上，我们需要集合对全局矩阵或向量的局部贡献，然后我们必须将每个单元的贡献复制到全局矩阵或向量中。请注意，第一部分（循环）定义了一个必须发生的迭代器的范围。第二部分，本地贡献的组装是在这个步骤序列中花费大部分CPU时间的事情，也是一个可以在%并行中完成的典型例子：每个单元的贡献完全独立于所有其他单元的贡献。第三部分，复制到全局矩阵中，不能在%parallel中进行，因为我们正在修改一个对象，所以几个线程不能同时读取一个现有的矩阵元素，增加他们的贡献，并将总和写回内存而不产生[1.x.1026]危险。

deal.II有一个类，正是为这个工作流程而生的。WorkStream，首先在步骤9和步骤13中讨论。它的使用在[2.x.2839]模块中也有大量的记录（在[2.x.2840]"WorkStream类 "一节），我们不会在这里重复那里阐述的原理和详细说明，尽管你会想通读这个模块以了解从头开始的空间和每单元数据之间的区别。我只想说，我们需要以下条件。

- 迭代器的范围是我们要处理的那些单元格。这是由FilteredIterator类提供的，它的作用就像deal.II中的其他单元格迭代器一样，只是它跳过了所有不满足特定谓词（即，一个评估为真或假的标准）的单元。在我们的例子中，该谓词是一个单元格是否为本地所有。

- 一个为上面确定的每项任务在每个单元上做工作的函数，即集合对斯托克斯矩阵和预调节器、温度矩阵和温度右侧的局部贡献的函数。这些是下面代码中的[2.x.2841]、[2.x.2842]、[2.x.2843]和[2.x.2844]函数。这四个函数都可以有几个实例同时并行运行。

- 将前一个函数的结果复制到全局对象中的函数，并按顺序运行以避免竞赛条件。这些是[2.x.2845]、[2.x.2846]、[2.x.2847]、和[2.x.2848]函数。

我们将在实际代码中再评论一些要点，但总的来说，它们的结构应该从 [2.x.2849] 的讨论中清楚。

WorkStream的底层技术识别需要处理的 "任务"（例如，在一个单元上组装本地贡献），并将这些任务自动安排到可用的处理器上。WorkStream通过将迭代器范围分割成合适的小块，自动创建这些任务。

[2.x.2850] 在每个MPI进程中使用多个线程，只有当你在集群的每个节点上运行的MPI进程少于这台机器上的处理器核心时才有意义。否则，MPI已经让你的处理器很忙了，你不会从使用线程中获得任何额外的速度。例如，如果你的集群节点有8个内核，就像在写这篇文章的时候经常有的那样，如果你的批处理调度程序在每个节点上放8个MPI进程，那么使用线程并不能使程序更快。因此，你可能想在运行之前，要么配置你的deal.II不使用线程，要么将[2.x.2851]中的线程数设置为1（第三个参数），或者 "export DEAL_II_NUM_THREADS=1"。也就是说，在写这篇文章的时候，我们只用WorkStream类来组装（部分）线性系统，而程序的75%或更多的运行时间是在没有并行化的线性求解器中度过的&mdash;换句话说，我们最好的希望是将剩下的25%并行化。




[1.x.1027]

这个程序的设置稍微让人想起我们当初想解决的问题（见步骤31的介绍）：地幔的对流。因此，我们选择了以下数据，所有这些数据在程序中都是以米和秒为单位（国际单位制）出现的，即使我们在这里以其他单位列出它们。然而，我们注意到，这些选择基本上仍然只是示范性的，而不是要形成对地幔对流的完全现实的描述：为此，必须实现更多、更困难的物理学，而且目前这个程序中也缺少其他几个方面。我们将在结果部分再次讨论这个问题，但现在要说明的是，在写这篇文章时，提供真实的描述是正在开发的[1.x.1028]代码的一个目标。

作为提醒，让我们再次说明我们要解决的方程是这些。

[1.x.1029]

用边界条件和初始条件增强。然后我们必须选择以下数量的数据。  [2.x.2852] [2.x.2853] 域是一个环形（2D）或一个球壳（3D），其内外半径与地球的半径一致：地球的总半径为6371km，地幔从大约35km的深度开始（就在由[1.x.1031]和[1.x.1032]组成的固体地球[1.x.1030]之下）到2890km深度（[1.x.1033]开始）。因此半径为[2.x.2854] 。这个领域是使用[2.x.2855]函数方便地生成的。

   [2.x.2856] 在地壳和地幔的界面，温度在500到900摄氏度之间，而在其底部则是4000摄氏度左右（例如，见[1.x.1034]）。因此，在开尔文中，我们选择[2.x.2857] ，[2.x.2858]作为内外边缘的边界条件。

  除此以外，我们还必须为温度场指定一些初始条件。由于已经持续了40多亿年的对流，地球的真实温度场是相当复杂的--事实上，我们正是想通过这样的程序来探索这种温度分布的特性。因此，我们在这里并没有什么有用的东西可以提供，但是我们可以希望，如果我们从一些东西开始，让事情运行一段时间，确切的初始条件就不再那么重要了&mdash; 事实上，通过查看[1.x.1035]中显示的图片就可以看出。我们在这里使用的初始温度场是由[1.x.1036]给出半径的。

  其中[1.x.1037]

  这个复杂的函数本质上是内部和外部温度之间的线性轮廓的扰动。在2D中，函数[2.x.2859]看起来是这样的（我从[1.x.1038]得到的图片）。

   [2.x.2860]

  这个剖面的重点是，如果我们在[2.x.2863]的定义中使用[2.x.2861]而不是[2.x.2862]，那么它将只是一个线性内插。  [2.x.2864]在内部和外部边界具有与[2.x.2865]相同的函数值（分别为0和1），但它根据角度和3D中的[2.x.2866]值将温度曲线拉长一些，产生线性内插场的角度依赖性扰动。我们将在结果部分看到，这是一个完全不实际的温度场（尽管它将会产生有趣的图像），因为温度的平衡状态将是一个几乎恒定的温度，在内部和外部边界有边界层。

   [2.x.2867] 温度方程的右边包含了内部加热%的速率 [2.x.2868] 。地球确实通过几种机制自然升温：放射性衰变、化学分离（较重的元素沉到底部，较轻的元素升到顶部；逆流耗散的能量相当于这一分离过程中的势能损失）；随着地球内部固体核心的增长，液态金属结晶释放热量；以及流体运动时粘性摩擦产生的热量耗散。

  化学分离很难建模，因为它需要将地幔物质建模为多个相；它也是一个相对较小的效应。结晶热就更难了，因为它只限于温度和压力允许相变的区域，也就是一个不连续的过程。鉴于对这两种现象进行建模的困难，我们将忽略它们。

  另外两个很容易处理，考虑到我们对温度方程进行缩放的方式，可得出方程[1.x.1039]

  其中[2.x.2869]是[2.x.2870]中的辐射性加热，列举器中的第二项是粘性摩擦加热。  [2.x.2871] 是密度，[2.x.2872] 是比热。文献中提供了以下近似值。  [2.x.2873] .   其他参数将在本节的其他地方讨论。

  我们在这里忽略了一个内部热源，即绝热加热，这将导致一个令人惊讶的温度场。这一点将在下面的结果部分进行详细评论。

   [2.x.2874]对于速度，我们在内半径处选择[2.x.2875]作为边界条件（即流体粘在地心上），在外半径处选择[2.x.2876]（即流体沿地壳底部切向流动）。这两种情况在物理上都不过分正确：当然，在这两个边界上，流体可以切向流动，但它们会通过与界面另一侧的介质（分别是金属核心和地壳）摩擦而产生剪切应力。这样的情况可以用切向速度的罗宾式边界条件来模拟；在这两种情况下，法向（垂直）速度将为零，尽管即使这样也不完全正确，因为大陆板块也有垂直运动（例如，见[1.x.1040]的现象）。但是，对切向速度来说，另一侧的介质也在运动，这已经使事情变得更糟了，因此，在最简单的情况下，剪应力将与[1.x.1041]成正比，导致边界条件的形式为[1.x.1042]

  有一个比例常数 [2.x.2877] 。然而，我们没有走这条路，而是选择了零（棒）和切向流的边界条件。

  顺便提一下，我们也可以在内外边界都选择切向流动条件。然而，这有一个明显的缺点：它使速度不是唯一定义的。原因是所有对应于绕域中心旋转的固体体的速度场[2.x.2878]都满足[2.x.2879]，和[2.x.2880]。因此，如果[2.x.2881]满足方程和边界条件，那么[2.x.2882] 也满足。这当然不是一个我们想避免的好情况。解决这个问题的传统方法是在边界上选一个任意的点，通过选择速度在那里的所有分量为零，将其称为你的固定点。(在三维空间中，必须选择两个点。)由于这个程序开始时并不打算太现实，我们通过简单地固定整个内部边界的速度来避免这种复杂情况。

   [2.x.2883]根据第一顺序，重力矢量总是指向下方。对于像地球这样大的物体来说，问题只是："向上 "是什么地方。天真的答案当然是 "径向向内，向地球中心"。所以在地球表面，我们有[1.x.1043]

  其中[2.x.2884]刚好是地球表面的平均重力加速度。但是在地球内部，问题变得有点复杂：例如，在地球的（轨道）中心，你有物质在各个方向上同样用力拉扯，所以[2.x.2885] 。在这两者之间，净力的描述如下：让我们用[1.x.1044]来定义[1.x.1045] 。

  那么[2.x.2886] 。如果我们假设密度[2.x.2887]在整个地球上是恒定的，我们可以产生一个重力矢量的分析表达式（不要试图以某种方式整合上述方程--它导致了椭圆积分；一个更简单的方法是注意到[2.x.2888]并利用径向对称性在所有[2.x.2889]中解决这个偏微分方程）。   [1.x.1046]

  因子[2.x.2890]是指向径向内的单位矢量。当然，在这个问题中，我们只对与地球内部有关的分支感兴趣，即[2.x.2891]。因此，我们将只考虑表达式[1.x.1047] 。

  其中我们可以推断出最后一个表达式，因为我们知道地球在表面的重力（其中[2.x.2892] ）。

  我们可以通过整合[2.x.2893]的微分方程，在密度分布是径向对称的情况下，即[2.x.2894]，推导出一个更一般的表达。在这种情况下，我们将得到[1.x.1048] 。




  然而，这有两个问题。(i) 地球不是均匀的，即密度[2.x.2895]取决于[2.x.2896]；事实上它甚至不是一个只取决于半径[2.x.2897]的函数。因此，在现实中，重力并不总是随着我们的深入而减少：因为地心比地幔的密度大得多，重力实际上在地心地幔边界的[2.x.2898]左右达到峰值（见[1.x.1049]）。(ii) 密度，以及由此产生的重力矢量，在时间上甚至不是恒定的：毕竟，我们要解决的问题是与时间有关的热的、密度较小的物质的上涌和冷的密度大的物质的下涌。这就导致了重力矢量随空间和时间的变化而变化，并不总是直接指向下方。

  为了不使情况变得更加复杂，我们可以使用这样的近似值：在地幔的内部边界，重力是[2.x.2899]，在外部边界，重力是[2.x.2900]，在每种情况下都是径向向内的，在两者之间，重力随着离地球中心的径向距离而线性变化。也就是说，实际上稍微现实一点，假设（就像我们下面做的那样）地幔具有恒定的密度也不是那么难。在这种情况下，上面的方程可以被整合，我们得到一个[2.x.2901]的表达式，我们可以拟合常数以匹配地幔顶部和底部的重力，得到[1.x.1050]



   [2.x.2902]地幔的密度在空间上有变化，但变化幅度不大。  [2.x.2903]是参考温度[2.x.2904]开尔文时的密度的一个相对较好的平均值。

   [2.x.2905] 热膨胀系数[2.x.2906]也随深度变化（通过其对温度和压力的依赖）。在接近地表的地方，它似乎是[2.x.2907]，而在地心地幔边界，它可能更接近[2.x.2908]。作为一个合理的值，让我们选择[2.x.2909]。那么密度与温度的关系是[2.x.2910] 。

   [2.x.2911] 我们需要指定的第二个至最后一个参数是粘度 [2.x.2912] 。这是一个棘手的问题，因为在地幔典型的温度和压力下，岩石的流动非常缓慢，以至于在实验室里无法准确地确定粘度。那么我们如何知道地幔的粘度呢？最常用的方法是考虑在冰期和冰期之后，冰盾形成和消失的时间尺度比地幔流动的时间尺度短。因此，大陆在冰盾的附加重量下慢慢沉入地幔，而在冰盾再次消失后，它们又慢慢升起（这被称为[1.x.1051][1.x.1052]）。通过测量这种反弹的速度，我们可以推断出流向反弹的大陆板块下腾出的区域的物质的粘度。

  使用这种技术，发现[2.x.2913]附近的数值是最有可能的，尽管这上面的误差至少是一个数量级的。

  虽然我们将使用这个值，但我们不得不再次提醒，有许多物理原因可以假设这不是正确的值。首先，它确实应该取决于温度：较热的材料很可能比较冷的材料的粘性要小。然而，在现实中，情况甚至更为复杂。地幔中的大多数岩石随着温度和压力的变化而发生相变：根据温度和压力的不同，不同的晶体构型在热力学上比其他的更受青睐，即使地幔的化学成分是均匀的。例如，常见的地幔物质MgSiO<sub>3</sub>在整个地幔的大部分地区以其[1.x.1053]的形式存在，但在地幔下部，同样的物质只以[1.x.1054]的形式稳定。显然，为了计算现实的粘度，我们不仅需要知道地幔的确切化学成分和所有物质的粘度，而且还必须计算所有物质在每个正交点的热力学上最稳定的配置。在编写这个程序时，这不是一个可行的建议。

   [2.x.2914] 我们的最后一个材料参数是热扩散率[2.x.2915] ，其定义为[2.x.2916] ，其中[2.x.2917] 是热导率，[2.x.2918] 是密度，[2.x.2919] 是比热。对于这一点，文献表明，它从上地幔的[2.x.2920]左右增加到下地幔的[2.x.2921]左右，尽管确切的数值其实并不那么重要：通过对流的热传输比通过热传导的热传输要重要几个数量级。可能有兴趣知道的是，地幔中最丰富的材料--过氧化物，在超过大约120GPa的压力下似乎变得透明（例如，见J. Badro等人，《科学》305，383-386（2004年））；因此，在下地幔中，通过辐射传输的热传输可能比通过热传导更有效。

  鉴于这些考虑，让我们选择[2.x.2922]作为本方案的目的。  [2.x.2923]

所有这些方程数据都在程序中定义在[2.x.2924]命名空间。当运行时，该程序产生的长期最大速度大约为每年10-40厘米（见下面的结果部分），大约是物理上正确的数量级。我们将设定结束时间为10亿年。

[2.x.2925] 上述常数和材料参数的选择在很大程度上遵循了G.Schubert和D.L.Turcotte和P.Olson（剑桥，2001）的综合书籍《地球和行星的地幔对流，第一部分》。它包含了关于如何使程序更加真实的广泛讨论。




[1.x.1055]

与step-31相比，这个程序有一些值得注意的区别。

- [2.x.2926]命名空间要大得多，这反映了我们现在有更多的物理学需要处理的事实。也就是说，这些额外的物理细节大部分是在这个命名空间的函数中自成一体的，并没有扩散到程序的其他部分。

- 更明显的可见性是，我们把大量的参数放入由ParameterHandler类处理的输入文件中（例如，见步骤29，关于用这个类设置运行时参数文件的方法）。当人们想避免仅仅因为想玩弄一个参数而重新编译程序时，这往往是有意义的（例如，想想确定上面讨论的稳定常数的最佳值的参数研究），特别是考虑到重新编译当前规模的程序需要花费非同小可的时间。为了仅仅概述我们从固定值移入输入文件的参数种类，这里列出了一个典型的[2.x.2927]文件。   [1.x.1056]



- 很明显，有很多变化是与我们想在可能非常多的机器上运行我们的程序这一事实有关的。尽管人们可能会怀疑这需要我们完全重新构建我们的代码，但事实上并非如此（尽管在deal.II中实现大部分功能的类从实现的角度来看肯定非常不同，但这并没有反映在它们的公共接口中）。相反，这些变化大多是微妙的，主类的整体结构几乎没有变化。也就是说，魔鬼在细节中：正确地进行%并行计算，没有死锁，确保正确的数据在正确的地方可用（例如，见关于全分布式向量与有鬼魂元素的向量的讨论），以及避免瓶颈是很困难的，关于这个话题的讨论将出现在本程序中的很多地方。




[1.x.1057]

这是一个教程性的程序。这意味着至少它的大部分重点需要放在演示如何使用deal.II和相关的库上，而不是通过过度关注物理细节来稀释这个教学课程。尽管上面有关于物理参数选择的长篇大论，但程序中专门讨论这个问题的部分实际上是很短的，而且是自成一体的。

也就是说，第31步和目前的第32步都不是偶然出现的，而肯定是作为通向更全面的计划的路标，该计划将模拟地幔的对流。我们把这个代码称为[1.x.1058]（简称[1.x.1059]）；它的开发是由[1.x.1060]计划资助的，得到了美国国家科学基金会的支持。关于[1.x.1061]的更多信息可在其[1.x.1062]中找到。


examples/step-32/doc/results.dox



[1.x.1063]

当运行时，该程序以与step-31相同的方式模拟三维对流，尽管有一个完全不同的测试案例。




[1.x.1064]

然而，在我们讨论这个测试案例之前，让我们展示一下这个程序稍早的版本的一些结果，该版本正是在解决我们在第31步中使用的测试案例，只是我们现在以并行方式解决它，而且分辨率要高很多。我们展示这些结果主要是为了比较。

下面是两张图片，如果我们选择[2.x.2928]中的3d计算，以及设置[2.x.2929]和[2.x.2930]，则可以看到这种更高的分辨率。在所示的时间步骤中，网格有大约72,000和236,000个单元，分别为2,680,000和8,250,000个自由度，比我们在步骤31中的可用度多了一个数量级。

[2.x.2931]

计算是在德克萨斯A&amp;M大学Brazos集群的50个处理器的子集上完成的。




[1.x.1065]

接下来，我们将用目录中的参数文件运行step-32，但有一个变化：我们将最终时间增加到1e9。这里我们使用的是16个处理器。启动的命令是（注意，step-32.prm是默认的）。

<code> <pre> [2.x.2932] mpirun -np 16 ./step-32 活动单元的数量：12,288（在6层） 自由度的数量：186,624（99,840+36,864+49,920）。

时间步数0：t=0年

   重建斯托克斯预处理程序...    解决斯托克斯系统...41次迭代。    最大速度：60.4935厘米/年 时间步长：18166.9年 温度的17次CG迭代 温度范围：973 4273.16

活动单元的数量：15,921（在7层） 自由度的数量：252,723（136,640+47,763+68,320）。

时间步数0：t=0年

   重建斯托克斯预处理程序...    解决斯托克斯系统...50次迭代。    最大速度：60.3223厘米/年 时间步长：10557.6年 温度的19次CG迭代 温度范围：973 4273.16

活动单元的数量：19,926（在8层） 自由度的数量：321,246（174,312+59,778+87,156）。

时间步数0：t=0年

   重建斯托克斯预处理程序...    解决斯托克斯系统...50次迭代。    最大速度：57.8396厘米/年 时间步长：5453.78年 温度的18次CG迭代 温度范围：973 4273.16

时间步数1：t=5453.78年

   解决斯托克斯系统...49次迭代。    最大速度：59.0231厘米/年 时间步长：5345.86年 温度的18次CG迭代 温度范围：973 4273.16

时间步数2：t=10799.6年

   解决斯托克斯系统...24次迭代。    最大速度：60.2139厘米/年 时间步长：5241.51年 温度的17次CG迭代 温度范围：973 4273.16

[...]

时间步数100：t=272151年

   解决斯托克斯系统......21次迭代。    最大速度：161.546厘米/年 时间步长：1672.96年 温度的17次CG迭代 温度范围：973 4282.57

活动单元的数量：56,085（在8层） 自由度的数量：903,408（490,102+168,255+245,051）。




+---------------------------------------------+------------+------------+ | 从开始到现在，总的壁挂时间经过了115s构建斯托克斯预调节器 | 12 | 2.09s | 1.8% | 解算斯托克斯系统 | 103 | 90.4s | 79% | 解算温度系统 | 103 | 1.53s | 1.3% | 后处理 | 3 | 0.532s | 0.完善网格结构，第一部分 | 12 | 0.93s | 0.81% | 完善网格结构，第二部分 | 12 | 0.384s | 0.33% | 设置阻尼系统 | 13 | 2.96s | 2.6% | +---------------------------------+-----------+------------+------------+

[...]

+---------------------------------------------+------------+------------+ | 从开始到现在总共经过了多少壁挂时间 | 9.14e+04s | | | | 部分 | 调用次数 | 壁挂时间 | 占总数的百分比 | +---------------------------------+-----------+------------+------------+ | 组装斯托克斯系统 | 47045 | 2.05e+03s | 2.2% | 组装温度矩阵 | 4707 | 310s | 0.34% | 组装温度rhs | 47045 | 8.7e+03s | 9.4707 | 1.48e+03s | 1.6% | 解决斯托克斯系统 | 47045 | 7.34e+04s | 80% | 解决温度系统 | 47045 | 1.46e+03s | 1.6% | 后处理 | 1883 | 222s | 0.24% | | 完善网格结构，第一部分 | 4706 | 641s | 0.7% | 完善网格结构，第二部分 | 4706 | 259s | 0.28% | 设置阻尼系统 | 4707 | 1.86e+03s | 2% | +---------------------------------+-----------+------------+------------+ </pre> </code>

当时间达到输入文件中选择的10亿年时，模拟就会终止。  你可以从中推断出不同的最终时间的模拟需要多长时间（时间步长最终确定在20,000年左右，所以计算20亿年需要100,000个时间步长，给或给20%）。  从这里可以看出，我们把大部分的计算时间花在了组装线性系统和&mdash;首先&mdash;解决斯托克斯系统。


为了演示输出，我们在这里展示了每1250个时间步骤的输出。  [2.x.2933]

最后两张图片显示了网格以及16个子域和16个处理器的同一计算的网格划分情况。这个模拟的全部动态只有通过看动画才能看到，例如[1.x.1066]。由于其艺术质量和对岩浆羽流演变的迷人描述，这个图像非常值得观看。

如果你看电影，你会看到对流模式经历了几个阶段。首先，它摆脱了不稳定的温度分层，热物质被致密的冷物质覆盖。在这个巨大的驱动力被消除后，我们有了一种稳定的情况，几个小球开始从内圈的热边界层中分离出来并上升，几个冷指也从外部边界层中掉下来。在这一阶段，解决方案仍然大部分是对称的，反映了原始网格的12倍对称性。在最后一个阶段，流体进入剧烈的混沌搅拌，其中所有的对称性都消失了。这是一个随后继续主导流动的模式。

如果我们看一下模拟中作为时间函数的最大速度，也可以确定这些不同阶段。

[2.x.2934]

在这里，当温度分层不稳定时，速度（以厘米/年表示）在开始时变得非常大，达到几米/年的数量级）。然后平静下来，变成相对较小的数值，然后在混乱的搅动系统中再次回升。在那里，它保持在每年10-40厘米的范围内，完全在物理上预期的区域内。




[1.x.1067]

三维计算在计算上是非常昂贵的。此外，如上所述，有趣的行为只有在相当长的时间后才开始，需要更多的CPU时间，而不是在一个典型的集群上可用。因此，与其在这里展示一个完整的模拟，不如让我们简单地展示几张图片，我们使用这个程序的后续程序，称为[1.x.1068]（简称[1.x.1069]），该程序正在独立于deal.II开发，已经包括了下面讨论的一些扩展。下面两张图片显示了温度的等值线和领域（连同网格）在512个处理器上的划分。

<p align="center"> [2.x.2935]

[2.x.2936][2.x.2937] 。


[1.x.1070]

[1.x.1071]

这个程序有许多可以扩展的方向。正如在介绍的最后提到的，在本教程程序完成时，其中大部分正在[1.x.1072]（简称[1.x.1073]）代码中积极开发。具体来说，下面这些肯定是人们应该解决的话题，以使程序更加有用。

[2.x.2938] [2.x.2939] [1.x.1074] 我们在模拟中得到的温度场在一段时间后大多是恒定的，在内部和外部边界有边界层，冷和热物质的流线混合一切。然而，这并不符合我们的预期，即靠近地心的东西应该比靠近地表的东西更热。原因是我们使用的能量方程不包括一个描述绝热冷却和加热的术语：岩石，像气体一样，在你压缩它的时候会加热。因此，上升的物质以绝热方式冷却，而下沉的冷物质则以绝热方式加热。因此，正确的温度方程看起来有点像这样。   [1.x.1075]

  或者，扩大平流导数 [2.x.2940] : [1.x.1076] 。

  换句话说，随着岩石体积中压力的增加（[2.x.2941]），我们会得到一个额外的热源，反之亦然。

  压力的时间导数实施起来有点困难。如果有必要，我们可以利用导言中概述的事实进行近似，即压力可以分解为由于温差和由此产生的流动而产生的动态部分，以及仅由上层岩石的静压力产生的静态部分。由于后者要大得多，我们可以对[2.x.2942]进行近似处理，从而对[2.x.2943]进行处理。   换句话说，如果流体沿着重力方向（向下）运动，它将被压缩，因为在这种情况下[2.x.2944]我们得到一个正的热源。反之，如果流体逆着重力方向运动，它将被冷却。

[2.x.2945] [1.x.1077] 正如在上面的温度模型中已经暗示的那样，地幔岩石不是不可压缩的。相反，鉴于地幔中的巨大压力（在地核-地幔边界，压力约为140GPa，相当于大气压力的140万倍），岩石实际上确实被压缩到它在表面压力下的密度的1.5倍左右。对这一情况进行建模会遇到很多困难。首先，质量守恒方程不再是[2.x.2946]，而应该是[2.x.2947]，其中密度[2.x.2948]现在不再是空间常数，而是取决于温度和压力。一个后果是，该模型现在不再是线性的；线性化的斯托克斯方程也不再是对称的，需要我们重新考虑预处理程序，甚至可能是离散化。至于如何解决这个问题，我们在这里就不做详细介绍了。

[2.x.2949] [1.x.1078] 正如在不同地方已经暗示的那样，材料参数，如密度、粘度和各种热参数，在整个地幔中并不恒定。相反，它们非线性地依赖于压力和温度，在粘度的情况下，还依赖于应变率 [2.x.2950] 。对于复杂的模型，准确解决这些模型的唯一方法可能是在每个时间步骤中实际迭代出这种依赖关系，而不是简单地将系数冻结在从前一个（几个）时间步骤推算出来的数值上。

[2.x.2951] [1.x.1079] 在一些处理器上以2D运行这个程序可以在一两天内解决现实的模型。然而，在3d中，计算时间非常大，以至于会遇到两个典型问题。(i) 在大多数计算集群上，排队系统将单个作业的运行时间限制在2或3天；(ii) 在数百个处理器上运行几天，由于硬件故障、错误配置或断电而丢失计算结果是一种耻辱。这两个问题都可以通过定期保存程序的状态来解决，如果有必要，在这个时候重新启动程序。这种技术通常被称为[1.x.1080]，它要求将程序的整个状态写到一个永久的存储位置（例如硬盘）。考虑到这个程序的数据结构的复杂性，这并不是完全微不足道的（也可能涉及到写入数千兆字节或更多的数据），但可以通过意识到可以在两个时间步骤之间保存状态，其中基本上只包括网格和解向量；在重新启动期间，然后首先以之前的方式重新列举自由度，然后重新组装矩阵。然而，考虑到这里涉及的数据结构的分布性质，保存和恢复程序的状态并不简单。一个额外的复杂性是由以下事实引入的：人们可能希望在两次运行之间改变处理器的数量，例如，因为人们可能希望在一个比用于在中间时间预计算起始温度场的网格更精细的网格上继续计算。

[2.x.2952] [1.x.1081] 像这样的计算的重点不是简单地解决方程。相反，它通常是探索不同的物理模型，并将其与我们在地球表面可以测量到的东西进行比较，以发现哪些模型是现实的，哪些是与现实相矛盾的。为此，我们需要从我们的解决方案向量中计算出与我们可以观察到的东西有关的数量。例如，其中包括地球表面的热流，以及整个地幔的地震速度，因为这些影响到地震仪所记录的地震波。

[2.x.2953] [1.x.1082] 从上面的3D案例可以看出，3D的网格主要是沿着内部边界细化的。这是因为那里的边界层比领域中的任何其他过渡都要强，导致我们几乎只在那里细化，基本上没有沿着羽流的方向细化。我们当然需要更好的细化标准来跟踪我们真正感兴趣的部分，而不是这里使用的标准，即应用于温度的KellyErrorEstimator，能够做到。  [2.x.2954]


还有许多其他方法来扩展当前的程序。然而，与其在这里讨论它们，不如让我们指出更大的开放源代码ASPECT（见https://aspect.geodynamics.org/），它构成了step-32的进一步发展，并且已经包括了许多这样可能的扩展。


examples/step-33/doc/intro.dox

[2.x.2955]

[1.x.1083]

[2.x.2956] 程序使用[1.x.1084]线性求解器（这些可以在Trilinos的Aztec/Amesos包中找到）和一个自动微分包，Sacado，也是Trilinos的一部分。deal.II必须被配置为使用Trilinos。请参考[1.x.1085]文件以了解如何做到这一点。

[2.x.2957] 虽然这个程序很好地展示了自动微分的使用，但它并没有表达欧拉方程求解器的技术水平。对于这个方程有更快、更准确的方法，你应该看看步骤67和步骤69，看看这个方程如何更有效地得到解决。




[1.x.1086][1.x.1087] 。

[1.x.1088]

描述可压缩、无粘性气体运动的方程（所谓的气体动力学欧拉方程）是一个基本的守恒定律系统。在空间维度[2.x.2958]中，其内容为

[1.x.1089]

解[2.x.2959]包括[2.x.2960]流体密度，[2.x.2961]流速（因此[2.x.2962]是线性动量密度），和[2.x.2963]气体的能量密度。我们将上述方程式解释为 [2.x.2964] , [2.x.2965] 。

对于欧拉方程，通量矩阵[2.x.2966]（或通量函数系统）被定义为（这里显示的是情况[2.x.2967]）。

[1.x.1090]

我们将只选择重力的影响作为特定的右手边强制力，用以下方式描述

[1.x.1091]

其中[2.x.2968]表示重力矢量。有了这个，整个方程组就变成了：

[1.x.1092]

这些方程分别描述了动量、质量和能量的守恒。该系统被一个定义压力的关系所封闭。  [2.x.2969] .对于空气（主要是氮气和氧气）和其他双原子气体的成分，其比热比为 [2.x.2970] 。

这个问题显然属于矢量值问题的范畴。关于如何在deal.II中处理这些问题的一般概述可以在[2.x.2971]模块中找到。

[1.x.1093]

考虑到这是一个双曲问题，与步骤12中讨论的简单问题的风格相同，以通常的方式进行微调：我们选择一个有限元空间[2.x.2972]，并针对我们的（矢量值）测试函数[2.x.2973]积分我们的守恒法。  然后我们通过部分积分，用[1.x.1094]通量[2.x.2974]来近似边界通量。

[1.x.1095]

其中上标[2.x.2975]表示一个函数的内部轨迹，[2.x.2976]表示外部轨迹。扩散项[2.x.2977]是严格为了稳定而引入的，其中[2.x.2978]是网格大小，[2.x.2979]是一个参数，规定要增加多少扩散。

在边界上，我们必须说清楚外痕[2.x.2980]是什么。根据边界条件，我们规定以下两种情况。  [2.x.2981] [2.x.2982] 流入边界：[2.x.2983]被规定为理想值。  [2.x.2984] 超音速流出边界：[2.x.2985] [2.x.2986] 亚音速流出边界：[2.x.2987] 除了能量变量被修改为支持规定的压力[2.x.2988] ，即[2.x.2989] [2.x.2990] 反射边界：我们设定[2.x.2991] ，使[2.x.2992] 和[2.x.2993] 。  [2.x.2994]

关于这些问题的更多信息可以在Ralf Hartmann的博士论文中找到（"Adaptive Finite Element Methods for the Compressible Euler Equations"，博士论文，海德堡大学，2002）。

我们使用时间步长方案来替代上述方程中的时间导数。为了简单起见，我们将[2.x.2995]定义为时间步长[2.x.2996]的空间残差。

[1.x.1096]



因此，在每个时间步骤，我们的完全离散化是，应用于任何测试函数[2.x.2997]的残差等于零。

[1.x.1097]

其中[2.x.2998]和[2.x.2999] 。选择[2.x.3000]的结果是显式（正向）欧拉方案，[2.x.3001]是稳定的隐式（反向）欧拉方案，而[2.x.3002]是克拉克-尼克尔森方案。

在下面的实现中，我们选择Lax-Friedrichs通量的函数[2.x.3003]，即[2.x.3004]，其中[2.x.3005]是输入文件中指定的一个固定数字，或者[2.x.3006]是一个与网格有关的值。在后一种情况下，它被选为[2.x.3007]，[2.x.3008]是施加磁通量的面的直径，而[2.x.3009]是当前的时间步长。

有了这些选择，将残差等同于零就会产生一个非线性方程组 [2.x.3010] 。我们通过牛顿迭代来解决这个非线性系统（与步骤15中解释的方法相同），即通过迭代

[1.x.1098]

直到[2.x.3011]（残差）足够小。通过用有限元空间的节点基础而不是所有的[2.x.3012]进行测试，我们得出了一个[2.x.3013]的线性系统。

[1.x.1099]

一般来说，这个线性系统既不是对称的，也没有任何特定的确定性属性。我们将使用直接求解器或Trilinos的GMRES实现来解决它。从[1.x.1100]中可以看出，这种全隐式迭代收敛速度非常快（通常为3步），并具有牛顿方法所期望的二次收敛顺序。




[1.x.1101]

由于计算雅各布矩阵[2.x.3014]是一个可怕的野兽，我们使用一个自动微分包，Sacado，来做这个。  Sacado是[1.x.1102]框架内的一个包，提供了一个C++模板类[2.x.3015]（[2.x.3016]代表 "前向自动微分"），支持基本算术运算符和函数，如[2.x.3017]等。为了使用这个功能，人们声明一个这种类型的变量集合，然后将这个集合中的一些变量表示为自由度，其余的变量是独立变量的函数。  这些变量在算法中被使用，随着变量的使用，它们对自由度的敏感度被持续更新。

可以想象，对于整个雅各布矩阵来说，这可能是非常昂贵的：自变量的数量是[2.x.3018]，因变量是向量[2.x.3019]的元素。这两个向量很容易有几万个元素或更多。  然而，需要注意的是，并非[2.x.3020]的所有元素都依赖于[2.x.3021]的所有元素：事实上，[2.x.3022]中的一个条目只依赖于[2.x.3023]的一个元素，如果两个相应的形状函数重叠并以弱形式耦合。

具体来说，定义当前单元上的残差可能依赖的最小独立AD变量集是明智的：在每个元素上，我们定义那些对应于定义在这个单元上的自由度的独立变量（或者，如果我们必须计算单元之间的跳转项，则对应于定义在两个相邻单元上的自由度），而因变量是本地残差向量的元素。如果不这样做，即把[1.x.1103]和[2.x.3024]的元素定义为独立的，将导致大量零的计算非常昂贵：局部残差向量的元素几乎独立于解向量的所有元素，因此它们的导数为零；然而，试图计算这些零可以轻易地占用整个程序90%甚至更多的计算时间，正如这个程序首次编写几年后，一个学生无意中做的实验所示。


回到自动计算雅各布系数的问题上。作者将这种方法与手工编码的雅各布式并列使用，用于不可压缩的Navier-Stokes问题，发现Sacado方法与使用手工编码的雅各布式一样快，但无限简单，而且不容易出错。由于使用自动差分只需要编码残差[2.x.3025]，确保代码的正确性和维护代码变得非常简单--雅各布矩阵[2.x.3026]基本上是由计算残差[2.x.3027]的同一代码计算的。

说了这么多，这里有一个非常简单的例子，显示Sacado如何被使用。

[1.x.1104]



输出的是[2.x.3029]在[2.x.3030]的导数[2.x.3028] 。

应该注意的是，Sacado提供了更多的自动差分功能，而不是本程序中使用的小子集。  然而，理解上面的例子就足以理解Sacado在这个欧拉流程序中的使用。

[1.x.1105] 该程序使用Aztec迭代求解器或Amesos稀疏直接求解器，两者均由Trilinos包提供。  这个软件包本身就是为了用于并行程序而设计的，然而，它也可以像这里一样，轻松地用于串行程序。  Epetra软件包是基本的矢量/矩阵库，解算器是在此基础上建立的。  这个非常强大的包可以用来描述矢量的平行分布，并定义对这些矢量进行操作的稀疏矩阵。  请查看注释代码，了解更多关于这些求解器在例子中的使用细节。

[1.x.1106] 这个例子使用了一个特别的细化指标，该指标在冲击类问题中显示出一定的作用，在包括下坡流的例子中也是如此。  我们根据密度的平方梯度进行细化。悬空节点的处理是通过计算不同细化水平的单元的数值通量来实现的，而不是像迄今为止的所有其他教程程序那样使用AffineConstraints类。  通过这种方式，这个例子结合了连续和DG的方法论。它还简化了Jacobian的生成，因为我们不必通过用于计算自由度的自动微分来跟踪受限自由度。

[2.x.3031] 而这个程序是在2008年写的，我们不知道有什么出版物会真正使用这种方法。然而，A. Dedner、R. Kl&ouml;fkorn和M. Kr&auml;nkel最近的一篇论文（"Continuous Finite-Elements on Non-Conforming Grids Using Discontinuous Galerkin Stabilization", Proceedings of Finite Volumes for Complex Applications VII - Methods and Theoretical Aspects, Springer, 2014）接近。

此外，我们强制规定了细化水平的最大数量，以控制细化的程度。  根据作者的经验，对于与时间有关的问题的适应性，如果不注意的话，细化很容易导致仿真戛然而止，因为时间步长的限制，如果网格在领域的任何部分变得太细的话。  在这个例子中，细化的数量被限制，让用户指定在网格的任何地方出现的最大细化水平。  这样一来，细化就不会使模拟速度减慢到停滞不前。  当然，这纯粹是一种启发式的策略，如果作者的顾问听说了，作者可能会被永远放逐出有限元误差估计界。

[1.x.1107]

我们使用一个输入文件平台来驱动仿真。  通过这种方式，我们可以改变边界条件和其他重要的模拟属性，而不必重新编译。  关于格式的更多信息，请看[1.x.1108]，在那里我们更详细地描述了一个输入文件的例子。

在以前的例子程序中，我们通常对初始和边界条件进行硬编码。在这个程序中，我们改用表达式解析器类FunctionParser，这样我们就可以在输入文件中指定一个通用表达式，并在运行时对其进行解析&mdash；这样，我们就可以改变初始条件而不需要重新编译程序。因此，在下面的程序中不会声明名为InitialConditions或BoundaryConditions的类。




[1.x.1109]

这个程序的实现被分成三个基本部分。  [2.x.3032] [2.x.3033] [2.x.3034]类，封装了完全描述欧拉方程具体内容的一切。这包括通量矩阵[2.x.3035]、数值通量[2.x.3036]、右手边[2.x.3037]、边界条件、细化指标、输出的后处理，以及需要了解解向量和方程的各个组成部分的含义的类似事情。

   [2.x.3038] 一个命名空间，处理与运行时参数有关的一切。

   [2.x.3039] [2.x.3040] 处理时间步进、外部非线性和内部线性求解、组装线性系统以及驱动所有这些的顶层逻辑的类。  [2.x.3041]

这种方法的原因是它将程序中的各种问题分开：[2.x.3042]是以这样一种方式编写的，即相对简单地将其适用于不同的方程组。人们只需为其他双曲方程重新实现[2.x.3043]类的成员，或者用额外的方程来增加现有的方程（例如通过添加额外的变量，或者通过添加化学成分等）。然而，这种修改不会影响到时间步进，或者非线性求解器，如果正确的话，因此[2.x.3044]中的任何内容都不必修改。

同样，如果我们想改进线性或非线性求解器，或者改进时间步进方案（正如在[1.x.1110]的末尾所暗示的），那么这根本不需要对[2.x.3045]进行修改。


examples/step-33/doc/results.dox

[1.x.1111]

[1.x.1112]

我们用网格[2.x.3046]（该文件与本程序的源代码在同一目录下）和以下的输入牌（在同一目录下有[2.x.3047]）运行该问题。

[1.x.1113]



当我们运行该程序时，我们会得到以下的输出。

[1.x.1114]



这个输出报告了牛顿迭代的进度和时间步长。请注意，我们对牛顿迭代的实现确实显示了预期的二次收敛顺序：每一步的非线性残差的规范大致是上一步的规范的平方。这导致了我们在这里可以看到的非常快速的收敛。这种情况一直保持到[2.x.3048]时，这时非线性迭代报告缺乏收敛。

[1.x.1115]



我们可以通过查看解决方案的动画来找出原因和可能的补救措施。

运行这些计算的结果是一堆输出文件，我们可以将其传递给我们选择的可视化程序。当我们把它们整理成一个电影时，过去几个时间步骤的结果看起来是这样的。

[2.x.3049]

正如我们所看到的，当大质量的流体碰到左下角时，会发生一些振荡，导致迭代的发散。解决这个问题的一个懒办法是添加更多的粘性。如果我们将扩散功率设置为[2.x.3050]，而不是[2.x.3051]，模拟就能度过这一危机。那么，结果就会是这样。


[2.x.3052]

沉重的流体在重力作用下被拉下斜坡，在那里与滑雪屋相撞，并被抛向空中！希望每个人都能逃脱。  希望每个人都能逃过一劫!还有，我们可以看到由于人为的粘性，重质和轻质之间的界限很快就模糊了。

我们还可以直观地看到自适应细化网格的演变。

[2.x.3053]

根据上面讨论的启发式细化方案，自适应性跟随并先于流动模式。





[1.x.1116]

[1.x.1117]

[1.x.1118]

我们选择的数值方案在人工粘度小的时候不是特别稳定，而在人工粘度大的时候则过于扩散。此外，众所周知，还有一些更先进的技术来稳定解决方案，例如流线扩散、最小二乘法稳定条款、熵粘性。




[1.x.1119]

虽然作为非线性求解器的牛顿方法在时间步长足够小的情况下似乎效果很好，但线性求解器是可以改进的。例如，在目前的方案中，只要我们使用迭代求解器，每个牛顿步骤都要重新计算ILU；同样，对于直接求解器，每个步骤都要计算牛顿矩阵的LU分解。这显然是一种浪费：从一个牛顿步骤到另一个牛顿步骤，可能还有不同的时间步骤，牛顿矩阵不会发生根本性的变化：一个牛顿步骤的ILU或稀疏LU分解可能仍然是下一个牛顿或时间步骤的非常好的预处理。因此，避免重新计算将是减少计算时间的一个好办法。

我们可以更进一步：由于接近收敛时，牛顿矩阵只发生一点变化，我们也许可以定义一个准牛顿方案，即在每次牛顿迭代中我们只重新计算残差（即右手边的向量），并重新使用牛顿矩阵。由此产生的方案很可能不是二次收敛的，我们必须期望多做几次非线性迭代；然而，鉴于我们不必每次都花时间建立牛顿矩阵，由此产生的方案很可能更快。




[1.x.1120]

在[2.x.3054]函数中计算的残差为[2.x.3055]这意味着我们在一个牛顿迭代步骤中计算了两次空间残差：一次是关于当前解[2.x.3056]，另一次是关于最后一个时间步长的解[2.x.3057]，在一个时间步长的所有牛顿迭代中保持相同。在牛顿迭代过程中缓存残差[2.x.3058]的显式部分将节省大量的人力。




[1.x.1121]

最后，作为超越欧拉方程直接求解的一个方向，本程序非常努力地将所有专门针对欧拉方程的实现分离到一个类中（[2.x.3059]类），而将所有专门用于组装矩阵和向量、非线性和线性求解器以及一般顶层逻辑的实现分离到另一个类中（[2.x.3060]类）。

通过替换该类中通量矩阵和数值通量的定义，以及那里定义的其他各种部分，应该也可以将[2.x.3061]类应用于其他双曲守恒定律。


examples/step-34/doc/intro.dox

[2.x.3062]

[1.x.1122]

[2.x.3063]

[1.x.1123]

[1.x.1124]

[1.x.1125] 无粘性流体经过一个物体（例如空气经过飞机机翼，或空气或水经过螺旋桨）的不可压缩运动，通常由流体力学的欧拉方程来模拟。

[1.x.1126]其中流体密度[2.x.3064]和由外力引起的加速度[2.x.3065]是给定的，速度[2.x.3066]和压力[2.x.3067]是未知数。这里[2.x.3068]是一个封闭的有界区域，代表流体在其周围运动的体。

上述方程可以从纳维-斯托克斯方程推导出来，假设与压力梯度、惯性力和外力的影响相比，粘度造成的影响可以忽略不计。这是步骤22中讨论的斯托克斯方程的相反情况，斯托克斯方程是主导粘度的极限情况，即速度非常小，惯性力可以被忽略掉。另一方面，由于假定的不可压缩性，该方程不适合于非常高速的气体流动，在那里必须考虑到压缩性和气体的状态方程，导致气体动力学的欧拉方程，一个双曲系统。

在本教程程序中，我们将只考虑没有外力的静止流动。

[1.x.1127]


欧拉方程的解的唯一性通过添加边界条件得到保证

[1.x.1128]

这就是说，身体在我们的坐标系中是静止的，不具有渗透性，而流体在无限远处具有（恒定）速度[2.x.3069]。另一种观点是，我们的坐标系随着身体移动，而背景流体在无限远处处于静止状态。注意，我们将法线[2.x.3070]定义为域[2.x.3071]的[1.x.1129]法线，它与积分域的外法线相反。

对于静止和非静止的流动，求解过程从求解第二个方程中的速度开始，然后代入第一个方程，以找到压力。静止欧拉方程的求解通常是为了了解给定的（可能是复杂的）几何形状在系统上强制执行规定运动时的行为。

这个过程的第一步是将参照系从一个与身体一起运动的坐标系改变为一个身体在一个无限大的静止流体中运动的坐标系。这可以通过引入一个新的速度[2.x.3072]来表示，对于这个速度，我们发现同样的方程成立（因为[2.x.3073]），我们有边界条件

[1.x.1130]

如果我们假设流体是无旋转的，即[2.x.3074]中的[2.x.3075]，我们可以用标量函数的梯度来表示速度，从而也可以表示扰动速度。

[1.x.1131] ，因此上述欧拉方程的第二部分可以改写为未知数的同质拉普拉斯方程 [2.x.3076] 。

[1.x.1132]而动量方程还原为伯努利方程，该方程将压力 [2.x.3077] 表示为势的函数 [2.x.3078] 。

[1.x.1133]

因此，我们可以通过解决势的拉普拉斯方程来解决这个问题。  我们回顾一下，下列函数，称为拉普拉斯方程的基本解。

[1.x.1134]

在分布意义上满足方程的要求。

[1.x.1135]

其中导数是在变量[2.x.3079]中完成的。通过使用通常的格林同一性，我们的问题可以只写在边界上 [2.x.3080] 。我们回顾一下第二个格林同位数的一般定义。

[1.x.1136]

其中[2.x.3081]是[2.x.3082]的表面的法线，从积分域[2.x.3083]向外指向。

在我们的例子中，积分域是[2.x.3084]，其边界是[2.x.3085]，其中无穷大的 "边界 "被定义为

[1.x.1137]

在我们的程序中，法线被定义为[1.x.1138]到域[2.x.3086]，也就是说，它们实际上是[1.x.1139]到积分域，在定义各种积分时，需要注意法线的正确符号，即用[2.x.3088]代替[2.x.3087]。

如果我们把[2.x.3089]和[2.x.3090]分别与[2.x.3091]的解和拉普拉斯方程的基本解代入格林%同，只要[2.x.3092]被选在[2.x.3093]区域，就可以得到。

[1.x.1140]

其中法线现在指向[1.x.1141]的积分域。

请注意，在上述方程中，我们也有[2.x.3094]处的边界部分的积分。利用我们问题的边界条件，我们有[2.x.3095]在无限远处为零（这简化了右侧[2.x.3096]上的积分）。

左手边出现的[2.x.3097]上的积分可以通过观察[2.x.3098]来处理，这意味着[2.x.3099]在无穷远处必然是常数。我们把它的值定义为[2.x.3100] 。  要证明这一点是很容易的

[1.x.1142]

利用这一结果，我们可以利用所谓的单层和双层势能算子，只在边界上[2.x.3101]还原上述方程。

[1.x.1143]

(这些算子的名称来自于它们分别描述了[2.x.3102]中由于沿表面的单一薄片电荷和由于沿表面的双片电荷和反电荷而产生的电动势)。

在我们的例子中，我们知道边界上[2.x.3103]的纽曼值：[2.x.3104] 。因此。

[1.x.1144] 如果我们对上述方程的[2.x.3105]采取趋向于[2.x.3106]的极限，利用众所周知的单层和双层算子的特性，我们得到一个正好在[2.x.3109]的边界[2.x.3108]的方程。

[1.x.1145]

这就是我们要找的边界积分方程（BIE），其中量[2.x.3110]是点[2.x.3111]看到积分域[2.x.3112]的角度或实体角的分数。

特别是，在边界[2.x.3113]是可微的（即光滑）的点上，我们有[2.x.3115]，但在边界有角或边的点上，数值可能会更小或更大。

代入单层和双层运算符，我们得到。

[1.x.1146]为二维流动和

[1.x.1147]适用于三维流动，其中基本解的法向导数被写成了便于计算的形式。在任何一种情况下，[2.x.3116]都是完全在边界上提出的积分方程的解，因为[2.x.3117] 。

注意，点[2.x.3119]看到域[2.x.3120]的角度（在2D中）或实体角（在3D中）[2.x.3118]的分数可以用双层势本身定义。

[1.x.1148]

如果我们考虑到这样一个事实，即纯诺伊曼问题的解在一个任意常数[2.x.3121]以内都是已知的，这意味着，如果我们将诺伊曼数据设为零，那么任何常数[2.x.3122]都将是一个解。在边界积分方程中插入常数解和诺伊曼边界条件，我们有

[1.x.1149]

在[2.x.3123]上的积分是统一的，见上文，所以除以常数[2.x.3124]就得到了上面[2.x.3125]的明确表达。

虽然这个示例程序实际上只关注边界积分方程的求解，但在一个现实的设置中，我们仍然需要对速度进行求解。为此，请注意，我们刚刚计算了[2.x.3126]的所有[2.x.3127]。在下一步中，我们可以计算（如果我们愿意，可以分析）所有[2.x.3129]中的解[2.x.3128] 。为此，回顾一下，我们有

[1.x.1150]，现在我们有了右手边的所有东西（[2.x.3130]和[2.x.3131]是我们可以评估的积分，边界上的法线速度已经给出，边界上的[2.x.3132]我们刚刚计算了）。最后，我们就可以恢复速度为 [2.x.3133] 。

注意，对[2.x.3134]的上述公式的评估结果应该是零，因为狄拉克三角[2.x.3135]在域[2.x.3136]的积分根据定义总是零。

作为最后的测试，让我们验证这个速度是否确实满足静止流场的动量平衡方程，即对于某个（未知）压力[2.x.3139]和一个给定的常数[2.x.3140]，[2.x.3137]中是否[2.x.3138]。换句话说，我们想验证上面所说的伯努利定律确实成立。为了证明这一点，我们用这个方程的左手边等同于

[1.x.1151]

其中我们使用了[2.x.3141]是常数。我们想把这个表达式写成某个东西的梯度（记住[2.x.3142]是一个常数）。如果我们单独考虑方程的组成部分，下一步会更方便（对出现两次的指数求和是隐含的）。

[1.x.1152]

因为 [2.x.3143] 和 [2.x.3144] 。下一个。

[1.x.1153]

同样，最后一项消失了，因为[2.x.3145]是常数，我们可以将第一项和第三项合并为一项。

[1.x.1154]



我们现在只需要对最后一项再做一下按摩。使用乘积规则，我们得到

[1.x.1155]

这些项中的第一个是零（因为，同样，对[2.x.3146]的求和得到[2.x.3147]，它是零）。最后一项可以写成[2.x.3148]，它是理想的梯度形式。因此，我们现在可以最终说明

[1.x.1156]

或以矢量形式。

[1.x.1157]

或者换句话说。

[1.x.1158]

因为压力只确定到一个常数（它只在方程中出现一个梯度），一个同样有效的定义是

[1.x.1159]

这正是上面提到的伯努利定律。




[1.x.1160]

边界积分方程（BIE）的数值近似通常被称为边界元素法或面板法（后者主要用于计算流体力学界）。以下测试问题的目的是解决具有诺伊曼边界条件的拉普拉斯方程的积分表述，分别使用二维和三维空间的圆和球体，沿途说明了允许人们使用deal.II库处理边界元素问题几乎与有限元问题一样容易的特点。

为此，让[2.x.3149]成为流形[2.x.3150]的一个细分，如果[2.x.3152]则为[2.x.3151]线段，如果[2.x.3154]则为[2.x.3153] 四边形。我们将称每个单独的线段或四边形为[1.x.1161]或[1.x.1162]，与周围空间的维度[2.x.3155]无关。我们将有限维空间[2.x.3157]定义为

[1.x.1163]的基函数[2.x.3158]，我们将使用通常的FE_Q有限元，但这次它被定义在一个一维的流形上（我们通过使用第二个模板参数，通常默认为等于第一个；这里，我们将在一个[2.x.3160]维的空间中创建对象[2.x.3159]维单元）。一个[2.x.3161]的元素[2.x.3162]是由其系数的向量[2.x.3163]唯一识别的，也就是说。

[1.x.1164]，其中求和隐含在重复索引上。请注意，我们可以在这里使用不连续的元素&mdash；事实上，没有真正的理由使用连续的元素，因为积分表述并不意味着我们的试验函数有任何导数，所以连续性是不必要的，而且在文献中经常只使用片断常数元素。

[1.x.1165]

到目前为止，最常见的边界积分方程的近似方法是使用基于碰撞的边界元素方法。

这种方法要求在一些与系统未知数数量相等的定位点上评估边界积分方程。这些点的选择是一个微妙的问题，需要仔细研究。假设这些点暂时是已知的，并称它们为[2.x.3165]和[2.x.3166] 。

那么问题就变成了。给定基准点[2.x.3167]，在[2.x.3169]中找到一个函数[2.x.3168]，使得以下[2.x.3170]方程得到满足。

[1.x.1166]

其中数量[2.x.3171]是点[2.x.3172]看到域[2.x.3173]的（实体）角度的分数，如上所述，我们设定[2.x.3174]为零。  如果支持点[2.x.3175]选择得当，那么问题可以写成以下线性系统。

[1.x.1167]

其中

[1.x.1168]

从线性代数的角度来看，可能的最佳选择是使矩阵[2.x.3176]成为最对角线的主导。一个自然的选择是选择[2.x.3177]搭配点作为节点基函数[2.x.3178]的支持点。在这种情况下，[2.x.3179] ，因此，矩阵[2.x.3180]是对角线，其条目为

[1.x.1169]，其中我们使用了[2.x.3181]作为通常的拉格朗日元素。有了这样的选择，矩阵[2.x.3182]、[2.x.3183]和右手边[2.x.3184]的条目的计算需要对三角形[2.x.3186]元素的奇异积分进行评估。在这些情况下，所有的积分都是在参考简单域上进行的，也就是说，我们假设[2.x.3188]的每个元素[2.x.3187]可以表示为参考边界元素[2.x.3189]的线性（二维）或双线性（三维）变换，并且我们在从实数元素[2.x.3190]到参考元素[2.x.3191]的变量改变后执行积分。

[1.x.1170]

在二维空间，没有必要计算系统矩阵的对角线元素[2.x.3192]，因为即使分母在[2.x.3193]时归零，分子也总是零，因为[2.x.3194]和[2.x.3195]是正交的。]和[2.x.3195]是正交的（在我们对[2.x.3196]边界的多边形近似上），唯一的奇异积分出现在对[2.x.3197]的第i个元素的计算上。

[1.x.1171]

这可以通过QGaussLogR正交公式轻松处理。

同样，也可以使用QGaussOneOverR正交公式来进行三维空间的奇异积分。有兴趣的读者可以在其文档中找到关于这些正交规则如何工作的详细解释。

得到的矩阵[2.x.3199]是完整的。根据其大小，使用直接求解器或迭代求解器可能会很方便。为了这个例子代码的目的，我们选择只使用一个迭代求解器，而不提供任何预处理程序。

如果这是一个生产代码，而不是一个原理演示，有一些技术可以用来不存储完整的矩阵，而只存储那些大的和/或相关的条目。在边界元素方法的文献中，有大量的方法可以确定哪些元素是重要的，哪些是不重要的，从而使这些矩阵的表示方法明显稀疏，也有利于快速评估向量和矩阵之间的标量积。这不是本程序的目标，我们把它留给更复杂的实现。




[1.x.1172]

实现起来相当直接。在以前的教程程序中都没有用到的主要一点是，deal.II中的大多数类不仅在维度上有模板，而且实际上在我们提出微分方程的流形的维度以及这个流形嵌入的空间的维度上也有模板。默认情况下，第二个模板参数等于第一个，这意味着我们要在二维空间的一个二维区域上求解。在这种情况下，要使用的三角化类是[2.x.3200]，这相当于写成[2.x.3201]的方式。

然而，事实并非如此：在目前的例子中，我们想在球体表面求解，这是一个嵌入三维空间的二维流形。因此，正确的类将是[2.x.3202]，相应地，我们将使用[2.x.3203]作为DoF处理类，[2.x.3204]作为有限元。

关于如何处理生活在弯曲流形上的事物的一些进一步细节，可以在报告[1.x.1173][1.x.1174]中找到。此外，Step-38教程程序将我们在这里展示的内容扩展到了流形上提出的方程不是积分算子而实际上涉及导数的情况。




[1.x.1175]

我们要解决的测试案例是一个圆形（2D）或球形（3D）的障碍物。这些几何体的网格将从当前目录下的文件中读入，然后一个SphericalManifold类型的对象将被附加到三角形上，以允许网格细化，尊重离散的初始网格背后的连续几何。

对于一个半径为[2.x.3205]的球体，以[2.x.3206]的速度在[2.x.3207]方向平移，势为

[1.x.1176]

例如，见J. N. Newman, [1.x.1177], 1977, pp.对于单位速度和半径，并限制[2.x.3208]位于球体表面，[2.x.3209] 。在测试问题中，流量为[2.x.3210] ，因此在球体表面上适当的精确解是上述解与沿[2.x.3211]和[2.x.3212]轴的类似解的叠加，即[2.x.3213] 。


examples/step-34/doc/results.dox



[1.x.1178]

我们使用以下[2.x.3214]文件（也可以在所有其他源文件所在的目录中找到）运行该程序。

[1.x.1179]



当我们运行该程序时，屏幕上会打印出以下内容。

[1.x.1180]



从2d中的收敛表可以看出，如果我们选择足够精确的正交公式，那么我们得到的[2.x.3215]的误差应该正好是元素数量的倒数。用N段大小相等的圆近似产生一个有N个面的正多边形，其角度正好是[2.x.3216]，因此我们的误差应该正好是[2.x.3217] 。事实上，这是一个很好的指标，表明我们正在以适当的方式进行奇异积分。

势的近似[2.x.3218]的误差主要是由于域的近似。通过使用高阶映射可以得到更好的近似值。

如果我们修改main()函数，将fe_degree和mapping_degree设置为2，并提高参数文件中正交公式的顺序，我们得到以下二维模拟的收敛表

[1.x.1181]



和

[1.x.1182]



三维的情况下。我们可以看到，高阶映射的收敛结果要好得多，这主要是由于曲线几何的分辨率更高。请注意，在自由度相同的情况下，例如在三维模拟中Q1案例的第3步和Q2案例的第2步，误差大约低三个数量级。

运行这些计算的结果是一堆输出文件，我们可以将其传递给我们选择的可视化程序。输出文件有两种：边界元素表面的势，以及扩展到内外域的势。在二维的情况下，这两个文件的组合看起来像

[2.x.3219]

而在三维空间中，我们首先显示的是表面上的电位，同时还有一个等高线图。

[2.x.3220]

然后是潜力的外部等高线图，不透明度设置为25%。

[2.x.3221]


[1.x.1183]

[1.x.1184]

这是第一个考虑解决嵌入高维空间的曲面上定义的方程的教程程序。但这里讨论的方程相对简单，因为它只涉及一个积分算子，而不涉及在曲面上更难定义的导数。step-38教程程序考虑了这类问题并提供了必要的工具。

从实际角度来看，这里使用的边界元素方法（BEM）有两个瓶颈。首先是组装矩阵的成本是*二次方的未知数，即[2.x.3222]，其中[2.x.3223]是未知数的总数。通过查看`assemble_system()`函数可以看出这一点，它有这样的结构。

[1.x.1185]

这里，第一个循环走过了所有的单元格（一个系数[2.x.3224]），而内循环则贡献了另一个系数[2.x.3225] 。

这必须与*局部*微分算子的有限元方法进行对比。在那里，我们在所有单元上进行循环（[2.x.3226]的一个因子），并在每个单元上做一个与有多少单元或未知数无关的工作。这显然是一个瓶颈。

第二个瓶颈是系统矩阵是密集的（即是FullMatrix类型），因为每个自由度都与其他自由度相耦合。正如上面所指出的，仅仅*计算*这个带有[2.x.3227]非零项的矩阵必然需要至少[2.x.3228]次操作，但值得指出的是，仅仅做一个矩阵-向量乘积也需要这么多操作。如果用于解决线性系统的GMRES方法需要的迭代次数随着问题的大小而增长，就像通常的情况一样，那么解决线性系统需要的运算次数甚至比[2.x.3229]还要快。

"真实 "边界元素方法通过确定矩阵的哪些条目将是小的，因此可以被忽略的策略来解决这些问题（当然，代价是引入额外的误差）。这可以通过认识到矩阵项随着自由度[2.x.3230]和[2.x.3231]定义的位置之间的（物理）距离衰减而实现。这可以在快速多极法（FMM）等方法中得到利用，这些方法可以控制哪些矩阵项必须被存储和计算以达到一定的精度，并且--如果做得好的话--导致方法中线性系统的装配和求解都需要少于[2.x.3232]的操作。

实施这些方法显然为扩展目前的计划提供了机会。


examples/step-35/doc/intro.dox

[2.x.3233]

[1.x.1186]

[1.x.1187]

[1.x.1188]

[1.x.1189]

[1.x.1190] 本程序的目的是展示如何有效地解决不可压缩的时间依赖性纳维-斯托克斯方程。这些方程描述了粘性不可压缩流体的流动，读作

[1.x.1191]

其中[2.x.3234]表示流速，[2.x.3235]表示压力。这个方程组由初始条件来补充

[1.x.1192]

与[2.x.3236]足够光滑和螺线管，以及合适的边界条件。例如，一个可接受的边界条件，是

[1.x.1193]

也可以规定其他边界条件。在我们这里解决的测试案例中，边界被划分为两个不相交的子集[2.x.3237]，我们有

[1.x.1194]

和

[1.x.1195]

其中[2.x.3238]是外部单位法线。[2.x.3239]上的边界条件经常被用来模拟外流条件。

在以前的教程中（例如参见第20步和第22步），我们已经看到了如何使用Schur补数方法来解决与时间无关的斯托克斯方程。对于随时间变化的情况，在时间离散化之后，我们将得到一个类似于以下的系统

[1.x.1196]

其中[2.x.3240]是时间步长。虽然这个系统的结构与斯托克斯系统相似，因此可以用Schur补数的方法来解决，但事实证明，Schur补数的条件数与[2.x.3241]成正比。这使得该系统非常难解，也意味着对于纳维-斯托克斯方程来说，这不是一个有用的求解途径。

[1.x.1197]

[1.x.1198]

相反，我们需要想出一个不同的方法来解决与时间有关的纳维-斯托克斯方程。解决这些问题的困难来自于速度和压力是通过约束条件耦合在一起的事实

[1.x.1199]

对其而言，压力是拉格朗日乘数。投影方法旨在将这一约束与扩散（拉普拉斯）算子脱钩。

让我们简短地描述一下投影方法在半离散情况下的样子。我们的目标是获得一个速度[2.x.3242]和压力[2.x.3243]序列。我们还将得到一个辅助变量的序列[2.x.3244]。假设从初始条件和一阶方法的应用中我们已经找到了 [2.x.3245] 和 [2.x.3246] 。那么投影法包括以下步骤。  [2.x.3247] [2.x.3248] [1.x.1200] 。外推法。定义一下。   [1.x.1201]

   [2.x.3249] [1.x.1202]:扩散步骤。我们发现[2.x.3250]可以解决单一线性方程[1.x.1203]。



   [2.x.3251] [1.x.1204]:投影。找到能解决[1.x.1205]的[2.x.3252]。

   [2.x.3253] [1.x.1206]:压力校正。这里我们有两个选项。      [2.x.3254] [2.x.3255] [1.x.1207]。压力的更新方式是。       [1.x.1208]

       [2.x.3256] [1.x.1209]。在这种情况下，[1.x.1210] 。

     [2.x.3257][2.x.3258] 。

在不详细说明的情况下，让我们对我们刚刚描述的投影方法做一些说明。  [2.x.3259] [2.x.3260] 平流项[2.x.3261]被其[1.x.1211] [1.x.1212]取代。

  这与连续方程是一致的（因为[2.x.3262] ，尽管对于离散解来说，这在点上是不正确的），它需要保证时间步进方案的无条件稳定性。此外，为了使该术语线性化，我们使用[2.x.3263]的二阶外推[2.x.3264] 。    [2.x.3265] 投影步骤是亥姆霍兹分解的实现 [1.x.1213] 。

  其中[1.x.1214]

  和[1.x.1215]

  事实上，如果我们在[2.x.3266]上使用这种分解，我们可以得到[1.x.1216]

  与[2.x.3267] 。取这个方程的发散，我们得出了投影方程。    [2.x.3268] 上面概述的两种变体中更准确的是旋转变体。然而，下面的程序同时实现了两种变体。此外，根据作者的经验，如果粘度[2.x.3269]是可变的，应该使用标准形式。  [2.x.3270]


[2.x.3271] van Kan在[2.x.3272] [2.x.3273] J. van Kan, "A second-order accurate pressure-correction scheme for viscous incompressible flow", SIAM Journal on Scientific and Statistical Computing, Vol. 7, no.3, pp. 870-891, 1986 [2.x.3274] 并由Guermond在[2.x.3275] [2.x.3276] J.-L. Guermond分析。L. Guermond, "Un résultat de convergence d'ordre deux en temps pour l'approximation des équations de Navier-Stokes par une technique de projection incrémentale", ESAIM: Mathematical Modelling and Numer Analysis, vol. 33, no. 1, pp. 169-189, 1999 [2.x.3277] 。事实证明，这种技术受到运动压力的非物理边界条件的影响，导致收敛率降低。为了防止这种情况，Timmermans等人在[2.x.3279] [2.x.3280] L. Timmermans, P. Minev, and F. Van De Vosse, "An approximate projection scheme for incompressible flow using spectral elements", International Journal for Numerical Methods in Fluids, vol. 22, no. 7, pp.673-688, 1996 [2.x.3281] 旋转压力校正投影方法，使用运动压力的分歧校正。2.x.3282] [2.x.3283] J.-L. Guermond和J. Shen, "On the error estimates for the rotational pressure-correction projection methods", Mathematics of Computation, vol. 73, no. 248, pp.1719-1737, 2004 [2.x.3284] 对Stokes问题进行了全面分析。  [2.x.3285]

[1.x.1217]

[1.x.1218]为了获得该方法的完全离散设置，我们一如既往地需要一个变分公式。鉴于边界条件的性质，这里有一个微妙的问题。当我们把方程乘以一个合适的测试函数时，出现的一个项是

[1.x.1219]

如果我们，比如说，在整个边界上有迪里希特的边界条件，那么经过部分积分，我们将得到

[1.x.1220]

这种表述的优点之一是，它完全解耦了速度的各个组成部分。此外，它们都共享同一个系统矩阵。这可以在程序中加以利用。

然而，考虑到非标准的边界条件，为了能够考虑到这些条件，我们需要使用以下%的特征

[1.x.1221]

因此，当我们通过部分积分并考虑到边界条件时，我们可以得到

[1.x.1222]

这就是我们必须使用的形式。请注意，这是对速度分量的耦合。此外，为了强制执行压力的边界条件，我们需要重写

[1.x.1223]

其中[2.x.3286]中的边界积分在速度的边界条件下等于零，[2.x.3287]中的积分在压力的边界条件下等于零。

在简化的情况下，边界[2.x.3288]与坐标轴平行%，这在我们下面进行的测试案例中成立，实际上可以表明

[1.x.1224]

这个问题在文献中并不经常涉及。更多信息，读者可以参考，例如，[2.x.3289] [2.x.3290] J.-L. GUERMOND, L. QUARTAPELLE, On the approximation of the unsteady Navier-Stokes equations by finite element projection methods, Numer.Math., 80 (1998) 207-238 [2.x.3291] J.-L. GUERMOND, P. MINEV, J. SHEN, Error analysis of pressure-correction schemes for the Navier-Stokes equations with open boundary conditions, SIAM J. Numer.Anal., 43 1 (2005) 239-258.  [2.x.3292]




[1.x.1225]

[1.x.1226]

我们对投影方法的实现遵循[1.x.1227]上面的描述。然而，我们必须注意到，与其他大多数有多个解分量的问题不同，我们没有使用矢量值的有限元。相反，我们对速度和压力的分量分别使用单独的有限元，并对这些分量使用不同的[2.x.3293]'s。这样做的主要原因是，正如我们从方案的描述中看到的，速度和压力的[2.x.3294]分量是解耦的。因此，所有速度分量的方程看起来都是一样的，具有相同的系统矩阵，并能以%的速度平行求解。很明显，这种方法也有其缺点。例如，在集合矩阵和右手边时，我们需要保持几个[2.x.3295]s和迭代器的同步；获得矢量值函数的固有量（如发散）变得有点尴尬，以及其他。

[1.x.1228]

[1.x.1229]

我们在这个程序中使用的测试案例包括围绕一个方形障碍物的流动。其几何形状如下。

[2.x.3296]

与[2.x.3297]，使几何形状略微不对称。

我们在顶壁、底壁和障碍物上都施加了无滑动的边界条件。在左边，我们有流入的边界条件

[1.x.1230]

与[2.x.3298]，即流入的边界条件对应于这个配置的Poiseuille流。最后，在右边的垂直壁上，我们规定速度的垂直分量和压力都应该是零。最后的时间 [2.x.3299] 。


examples/step-35/doc/results.dox

[1.x.1231]

[1.x.1232]

[1.x.1233]

[1.x.1234]

我们用下面的[2.x.3300]来运行代码，它可以在与源代码相同的目录中找到。

[1.x.1235]



由于[2.x.3301]，除了程序当前工作的时间步数，我们没有得到任何形式的输出。如果我们把它设置为[2.x.3302]，我们就会得到关于程序正在做什么以及每个迭代过程要做多少步才能收敛等信息。

让我们绘制[2.x.3303]（即时间步长200、1000、2400、4000和5000）的所得结果，其中左栏显示涡度，右栏显示速度场。

[2.x.3304]

图像很好地显示了障碍物后面涡流链的发展和延伸，涡度的符号表明这是一个左转或右转的涡流。


[1.x.1236]

[1.x.1237]

我们可以将参数文件中的雷诺数 [2.x.3305] 改为 [2.x.3306] 。这样做，并在一定程度上减少时间步长，在时间[2.x.3307]时得到以下图像。

[2.x.3308]

对于这个较大的雷诺数，我们观察到不切实际的振荡，特别是涡度的振荡。离散化方案现在很难正确地解决流动问题，而流动应该仍然是层状的和有组织的。这些现象是典型的离散化方案，它们在溶解度不足的情况下缺乏稳健性，其中溶解度不足意味着用网格尺寸而不是几何体的物理尺寸计算的雷诺数很大。我们看一下放大的障碍物后面的区域，以及我们在那里的网格尺寸。


[2.x.3309]

我们可以通过在参数文件中多设置一个网格细化来重新运行模拟，从而轻松测试我们的假设。

[2.x.3310]

事实上，现在的涡度场看起来更加平滑了。虽然我们可以预期进一步细化网格也会抑制剩余的振荡，但我们应该采取措施在粗略分辨率的限制下获得一个强大的方案，如下所述。


[1.x.1238]

[1.x.1239]

这个程序可以在以下方向扩展。  [2.x.3311] [2.x.3312] 自适应网格细化。正如我们所看到的，我们在一个单一的固定网格上计算了所有的东西。   使用自适应网格细化可以导致精度的提高，同时不会明显增加计算时间。

   [2.x.3313] 自适应时间步长。虽然目前显然没有关于可变时间步长的投影方法的理论，但实践表明，它们的表现非常好。

   [2.x.3314] 高雷诺%数。正如我们从结果中看到的，增加雷诺数会大大改变离散化方案的行为。使用众所周知的稳定化技术，我们可以计算这个问题或其他许多问题中的流动，当雷诺数非常大，计算成本要求空间分辨率，而流动只能得到有限的解决，特别是对于三维湍流。

   [2.x.3315] 可变密度的不可压缩流。对于密度可变的不可压缩流的情况，有类似投影的方法。如果不同密度的流体混合在一起，例如淡水和盐水，或者酒精和水，这种流动就会发挥作用。

   [2.x.3316] 可压缩纳维-斯托克斯方程。这些方程适用于这样的情况：速度足够高，以至于流体变得可压缩，但速度不够快，以至于我们进入了一个粘度变得可以忽略的制度，纳维-斯托克斯方程需要被气体动力学的双曲欧拉方程取代。如果速度超过音速的三分之一，可压缩性就开始成为一个因素，所以它对几乎所有的地面交通工具来说都不是一个因素。另一方面，商业喷气式飞机的飞行速度约为音速的85%，机翼上的流动变得明显超音速，在这种情况下，可压缩的纳维尔-斯托克斯方程也不再适用。然而，在这两者之间的范围有重要的应用，如小型飞机或许多欧洲和东亚国家的快速列车。  [2.x.3317]


examples/step-36/doc/intro.dox

[2.x.3318]

[1.x.1240]

[1.x.1241]

[1.x.1242]

在这个例子中，我们要解决的问题是一个特征谱问题。特征值问题出现在广泛的问题背景中，例如在计算腔体中的电磁驻波、鼓膜的振动模式或湖泊和河口的振荡中。最神秘的应用之一可能是量子力学中静止或准静止波函数的计算。后一种应用是我们在此想研究的，尽管本方案中概述的一般技术当然同样适用于上述其他应用。

Eigenspectrum问题的一般形式是

[1.x.1243]

其中[2.x.3319]上的迪里切特边界条件也可以用诺伊曼或罗宾条件代替；[2.x.3320]是一个算子，一般也包含微分算子。

在适当的条件下，上述方程有一组解[2.x.3321] , [2.x.3322] ，其中[2.x.3323]可以是一个有限的或无限的集合（在后一种情况下，它可能是一个离散的或有时至少是部分连续的集合）。在这两种情况下，让我们注意到，我们要计算的不再只是一个单一的解决方案，而是一组解决方案（各种特征函数和相应的特征值）。从数字上寻找这类特征值问题的所有特征值（特征函数）的问题是一个艰巨的挑战。事实上，如果集合[2.x.3324]是无限的，这个挑战当然是难以解决的。  然而，大多数时候，我们实际上只对这些值（函数）的一小部分感兴趣；幸运的是，我们将在这个教程程序中使用的SLEPc库的接口允许我们选择特征谱的哪一部分和我们想要解决的多少个解决方案。

在这个程序中，我们使用的eigenspectrum求解器是由deal.II提供的类，围绕[1.x.1244]库的线性代数实现；SLEPc本身建立在[1.x.1245]库的线性代数内容之上。

[1.x.1246]

[1.x.1247]

静止的量子力学的基本方程是薛定谔方程，它模拟粒子在外部势中的运动 [2.x.3325] 。粒子由一个波函数[2.x.3326]描述，它满足一个（非维度化）形式的关系

[1.x.1248]

因此，这个粒子只能存在于一定数量的特征态中，这些特征态对应于作为该方程解的能量特征值[2.x.3327]。量子力学的正统（哥本哈根）解释认为，如果一个粒子具有能量[2.x.3328]，那么在位置[2.x.3329]找到它的概率与[2.x.3330]成正比，其中[2.x.3331]是对应于这个特征值的特征函数。

为了在数值上找到这个方程的解，即一组成对的特征值/特征函数，我们使用通常的有限元方法，将左边的方程与测试函数相乘，通过部分积分，在有限维空间中通过近似[2.x.3332]寻找解，其中[2.x.3333]是一个扩展系数的矢量。然后，我们立即得出以下方程，将连续特征值问题离散化：[1.x.1249] 在矩阵和矢量符号中，这个方程然后读作。[1.x.1250] 其中[2.x.3334]是由微分算子[2.x.3335]产生的刚度矩阵，而[2.x.3336]是质量矩阵。特征值问题的解决方案是一个特征谱 [2.x.3337] ，以及相关的特征函数 [2.x.3338] 。




[1.x.1251]

在这个程序中，我们对波函数[2.x.3339]使用了Dirichlet边界条件。从有限元代码的角度来看，这意味着只有内部的自由度是[1.x.1252]的实数度：边界上的自由度不是自由的，但毕竟是被迫有一个零值。另一方面，有限元方法的力量和简单性主要来自于我们只是在每个单元上做同样的事情，而不需要过多考虑一个单元在哪里，它是否在一个不太精细的单元上，因此有一个悬挂的节点，或者与边界相邻。所有这些检查都会使有限元线性系统的组装变得难以忍受，甚至更难阅读。

因此，当然，当你用DoFHandler对象分配自由度时，你并不关心你列举的一些自由度是否处于迪里切特边界。他们都会得到数字。我们只需要在以后应用边界值的时候照顾到这些自由度。有两种基本的方法（要么使用[2.x.3340][1.x.1253]装配线性系统，要么使用[2.x.3341][1.x.1254]装配；更多信息见[2.x.3342]"约束模块"），但两者的结果都一样：一个线性系统的总行数等于[1.x.1255]自由度的数量，包括那些位于边界的自由度。然而，受迪里希特条件约束的自由度与线性系统的其他部分分开，方法是将相应的行和列清零，在对角线上放一个正条目，并在右手边放相应的迪里希特值。

如果你暂时假设我们将自由度重新编号，使迪里切特边界上的所有自由度排在最后，那么我们在求解一个有右手边的常规PDE时得到的线性系统将是这样的。

[1.x.1256]

这里，下标[2.x.3343]和[2.x.3344]分别对应于内部和边界自由度。内部自由度满足线性系统[2.x.3345]，在内部产生正确的解，边界值由[2.x.3346]决定，其中[2.x.3347]是一个对角矩阵，由消除边界自由度的过程产生，[2.x.3348]是以这样的方式选择的：[2.x.3349]对每个边界自由度[2.x.3350]都有正确的边界值。 对于好奇的人来说，矩阵[2.x.3351]的条目是将修改后的局部贡献加入全局矩阵的结果，对于局部矩阵，如果非零，对角线元素被设置为其绝对值；否则，它们被设置为对角线的绝对值的平均值。这个过程保证了[2.x.3352]的条目是正的，并且大小与对角线的其他条目相当，确保所产生的矩阵不会因为涉及到大小迥异的矩阵条目的舍入而产生不合理的精度损失。最终出现在对角线上的实际数值是很难预测的，你应该把它们当作任意的、不可预测的，但却是正的。)

对于 "常规 "的线性系统，这一切都导致了正确的解决方案。另一方面，对于特征值问题，这就不那么简单了。在那里，消除边界值会影响到我们在当前教程程序中要解决的矩阵[2.x.3353]和[2.x.3354]。消除边界值后，我们就会得到一个可以这样划分的特征值问题。

[1.x.1257]

这种形式清楚地表明，有两组特征值：我们关心的那些，以及来自分离问题的虚假特征值。

[1.x.1258]

这些特征值是虚假的，因为它们是由一个只在边界节点上操作的特征值系统产生的--这些节点不是[1.x.1259]的实数度。当然，由于两个矩阵[2.x.3355]是对角线，我们可以准确地量化这些虚假的特征值：它们是[2.x.3356]（其中指数[2.x.3357]正好对应于受迪里切特边界值约束的自由度）。

那么，如何处理这些问题呢？第一部分是识别我们的特征值求解器何时找到其中一个。为此，程序通过计算所有受限自由度上表达式[2.x.3358]的最小和最大，计算并打印出这些特征值所在的区间。在下面的程序中，这已经足够了：我们发现这个区间位于我们感兴趣并计算的最小特征值和相应的特征函数的集合之外，所以这里我们不需要做什么。

另一方面，我们可能会发现我们在这个程序中计算的一个特征值恰好在这个区间内，在这种情况下，我们不会立即知道它是一个虚假的还是一个真正的特征值。在这种情况下，我们可以在计算完两个矩阵后简单地缩放其中一个矩阵的对角线元素，从而将它们从特征谱的感兴趣的频率上移开。这可以通过使用以下代码来完成，确保所有假的特征值都正好等于[2.x.3359] 。

[1.x.1260]

然而，这里没有采用这种策略，因为我们从程序中得到的虚假特征值恰好大于我们将计算的和感兴趣的最低的五个。




[1.x.1261]

下面的程序实质上只是步骤4的一个稍加修改的版本。有所不同的是以下几点。

[2.x.3360]

[2.x.3361] 主类（名为 [2.x.3362] ）现在不再有单一的解向量，而是有一整套我们想要计算的各种特征函数的向量。此外，[2.x.3363]函数对这里的一切都有顶层控制，它通过[2.x.3364]和[2.x.3365]同时初始化和最终确定SLEPc和PETSc的接口。[2.x.3366]

[2.x.3367] 我们在步骤17和步骤18中使用PETSc矩阵和向量，因为这是SLEPc特征值求解器所要求的。[2.x.3368]

[2.x.3369] 函数[2.x.3370]与教程中迄今为止所见的任何函数都完全不同，因为它不只是求解一个线性系统，而是实际求解特征值问题。它建立在SLEPc库上，更直接的是建立在类[2.x.3371]的deal.II SLEPc包装器上。

[2.x.3372] 我们使用ParameterHandler类来描述一些输入参数，如势的确切形式[2.x.3373] ，网格的全局细化步数，或我们要解决的特征值的数量。我们可以在这方面做得更多，但只限于在运行时选择一些实际的输入文件参数。为了看看在这方面可以做什么，看看[2.x.3374]"步骤-29 "和步骤-33。[2.x.3375]

[2.x.3376] 我们使用FunctionParser类使潜在 [2.x.3377] 的运行时参数，可以在输入文件中指定为公式。[2.x.3378]

[2.x.3379]

程序的其余部分以一种相当直接的方式从第4步开始。


examples/step-36/doc/results.dox



[1.x.1262]

[1.x.1263]

该问题的输入由一个输入文件[2.x.3380]设定参数，例如，该文件可以包含以下文本。

[1.x.1264]



这里，域内电势为零，我们知道特征值由[2.x.3381]给出，其中[2.x.3382] 。特征函数是正弦和余弦，在[2.x.3383]和[2.x.3384]方向的周期为[2.x.3385]和[2.x.3386]。这与我们的程序产生的输出相匹配。

[1.x.1265] 这些特征值正是对应于[2.x.3387]、[2.x.3388]和[2.x.3389]、[2.x.3390]和[2.x.3391]等对。相应的特征方程的可视化看起来是这样的。

[2.x.3392]

[1.x.1266]

在操场上玩几个游戏总是值得的!所以这里有几个建议。

[2.x.3393]

[2.x.3394]上面使用的势（称为[1.x.1267]，因为它是一个由无限高的墙包围的平坦势）很有趣，因为它允许有分析上已知的解决方案。然而，除此之外，它是相当无聊的。也就是说，通过在输入文件中设置不同的势来玩弄这个势是很容易的。例如，让我们假设我们想在2d中使用以下势。

[1.x.1268]

换句话说，在半径为0.75的圆的两个扇面中，电位为-100，在另外两个扇面中为-5，而在圆外为零。我们可以通过在输入文件中使用以下内容来实现这一点。

[1.x.1269]

此外，如果我们还将网格细化程度提高一级，我们会得到以下结果。

[1.x.1270]



输出文件还包含一个内插的势的版本，看起来像这样（注意，正如预期的那样，最低的几个特征模式的概率密度[2.x.3395]只有在势最低的地方才是显著的，即在势的内圈的右上角和左下角部分）。

[2.x.3396]

前五个特征函数现在是这样的。

[2.x.3397]

[2.x.3398]在我们对问题的推导中，我们假设粒子被限制在一个域[2.x.3399]中，并且在这个域的边界处，它的概率[2.x.3400]为零。这相当于解决所有[2.x.3401]上的特征值问题，并假设能量势只在[2.x.3402]区域内是有限的，而在区域外是无限的。比较容易的是，在[2.x.3403]的所有位置[2.x.3404]，[2.x.3405]。那么问题来了，如果我们的势不是这种形式的，即没有一个势是无限的有界域，会发生什么？在这种情况下，可能值得只考虑一个非常大的边界域，其中[2.x.3406]即使不是无限的，也至少是非常大的。在这样的情况下玩一玩，探索一下当我们使计算区域越来越大时，频谱和特征函数如何变化。

[2.x.3407] 如果我们研究简单的谐波振荡器问题[2.x.3408]会怎样？这个势正是上一段所讨论的形式，具有超球面对称性。人们可能想用一个大的外半径的球面域，来近似于全空间问题（例如，通过引用[2.x.3409]

[2.x.3410] 上面的图显示了波函数 [2.x.3411] ，但感兴趣的物理量实际上是粒子处于位置 [2.x.3412] 的概率密度。一些可视化程序可以从输入文件中的数据计算出衍生量，但我们也可以在创建输出文件时立即这样做。这样做的工具是DataPostprocessor类，可以和DataOut类一起使用。如何做到这一点的例子可以在步骤29和步骤33中找到。

[2.x.3414] 如果盒子里的粒子有%的内部自由度会怎样？例如，如果该粒子是一个自旋- [2.x.3415] 粒子？在这种情况下，我们可能要开始解决一个矢量值的问题，而不是。

[2.x.3416] 我们这里的deal.II库的实现使用PETScWrappers和SLEPcWrappers，适合在串行机器架构上运行。然而，对于更大的网格和更多的自由度，我们可能希望在并行架构上运行我们的应用程序。上述代码的并行实现在这里可能特别有用，因为广义的特征谱问题比前面大多数教程中考虑的标准问题的解决成本更高。幸运的是，修改上述程序使其符合MPI标准是一个相对简单的过程。关于如何做到这一点的简图可以在[2.x.3417]"step-17 "中找到。

deal.II有与其中之一ARPACK（见[1.x.1271]的设置说明）的接口，在ArpackSolver类中实现。下面是一个简短的、快速的概述，说明使用它需要改变什么，前提是你有一个工作的ARPACK安装，并且deal.II已经为它正确配置了（见deal.II [1.x.1272]文件）。

首先，为了使用ARPACK接口，我们可以回到使用标准的deal.II矩阵和向量，所以我们首先替换PETSc和SLEPc头文件

[1.x.1273]

与这些。

[1.x.1274]

ARPACK允许复杂的特征值，所以我们还需要

[1.x.1275]



其次，我们在主类中切换回deal.II矩阵和向量定义。

[1.x.1276]

并按照惯例对它们进行初始化 [2.x.3419] 。

[1.x.1277]



为了用ARPACK解决特征值问题，我们最后需要修改 [2.x.3420] 。

[1.x.1278]

请注意我们是如何使用精确分解（使用SparseDirectUMFPACK）作为ARPACK的预处理程序的。  [2.x.3421]


examples/step-37/doc/intro.dox

[2.x.3422]

[1.x.1279][1.x.1280] 。

[1.x.1281]

[1.x.1282]

这个例子展示了如何在超立方体上实现一个无矩阵的方法，即不明确存储矩阵元素的方法，用于具有可变系数的二阶泊松方程。该线性系统将用多网格方法求解，并使用MPI的大规模并行性。

无矩阵方法的主要动机是，在今天的处理器上，对主内存的访问（即对不适合缓存的对象）已经成为许多偏微分方程求解器的瓶颈。为了执行基于矩阵的矩阵-向量乘积，现代CPU花在等待数据从内存到达的时间远远多于实际进行浮点乘法和加法的时间。因此，如果我们可以通过重新计算矩阵元素来代替在内存中查找矩阵元素，或者更确切地说，这些条目所代表的运算符&mdash;，我们可能会在整体运行时间方面获胜，即使这需要大量的额外浮点运算。也就是说，用一个微不足道的实现来实现这一点是不够的，我们需要真正关注细节来获得性能。这个教程程序和上面提到的论文展示了如何实现这样一个方案，并演示了可以获得的速度提升。




[1.x.1283]

在这个例子中，我们考虑泊松问题[1.x.1284]，其中[2.x.3423]是一个可变系数。下面，我们将解释如何在不明确形成矩阵的情况下实现这个问题的矩阵-向量乘积。当然，对于其他方程也可以用类似的方法进行构造。

我们选择[2.x.3424]和[2.x.3425]作为域。由于系数是围绕原点对称的，但域却不是，我们最终会得到一个非对称的解决方案。




[1.x.1285]

为了找出我们如何编写一个执行矩阵-向量乘积的代码，但不需要存储矩阵元素，让我们先看看一个有限元矩阵[1.x.1286]是如何组装起来的。

[1.x.1287]

在这个公式中，矩阵[1.x.1288]<sub>cell,loc-glob</sub>是一个矩形矩阵，定义了从当前单元的局部自由度到全局自由度的索引映射。可以建立这个算子的信息通常被编码在[2.x.3426]变量中，并在deal.II中用于汇编调用填充矩阵。这里，[1.x.1289]<sub>cell</sub>表示与[1.x.1290]相关的单元矩阵。

如果我们要进行矩阵-向量乘积，因此我们可以使用

[1.x.1291]

其中[1.x.1292]<sub>cell</sub>是[1.x.1293]在各单元自由度处的值，而[1.x.1294]<sub>cell</sub>=[1.x.1295]<sub>cell</sub>[1.x.1296]<sub>cell</sub>相应为结果。因此，实现拉普拉斯的局部作用的一个天真尝试是使用以下代码。

[1.x.1297]



在这里，我们忽略了边界条件以及我们可能有的任何悬空节点，尽管使用AffineConstraints类来包括这两者都不是很困难。请注意，我们首先以通常的方式生成局部矩阵，作为每个局部矩阵项的所有正交点的总和。为了形成上述公式中表达的实际乘积，我们提取细胞相关自由度的[2.x.3427]的值（[1.x.1298]<sub>cell,loc-glob</sub>的作用），乘以局部矩阵（[1.x.1299]<sub>cell</sub>），最后把结果加到目标向量[2.x.3428]（[1.x.1300]<sub>cell,loc-glob</sub><sup>T</sup>的动作，加在所有元素上）。原则上不会比这更难。

虽然这段代码是完全正确的，但它非常慢。对于每个单元，我们生成一个局部矩阵，这需要三个嵌套循环，循环长度等于局部自由度的数量来计算。然后，乘法本身是由两个嵌套循环完成的，这意味着它要便宜得多。

改善这一点的一个方法是认识到，从概念上讲，局部矩阵可以被认为是三个矩阵的乘积。

[1.x.1301]

对于拉普拉斯算子的例子，[1.x.1302]*dim+[1.x.1303]的第1个元素<sub>cell</sub>是由[2.x.3429]给出。这个矩阵由[2.x.3430]行和[2.x.3431]列组成。矩阵[1.x.1305]<sub>cell</sub>是对角线，包含了[2.x.3432]的值（或者说，[2.x.3433]这些值中每一个的dim副本）。这种有限元矩阵的表示方法经常可以在工程文献中找到。

当单元格矩阵被应用于一个矢量时。

[1.x.1306]

这样就不会形成矩阵-矩阵乘积，而是每次用一个矩阵与一个矢量从右到左相乘，这样就只形成三个连续的矩阵-矢量乘积。这种方法去掉了局部矩阵计算中的三个嵌套循环，从而将一个单元格的工作复杂度从类似[2.x.3434]降低到[2.x.3435] 。对这种算法的解释是，我们首先将本地DoF上的值向量转换为正交点上的梯度向量。在第二个循环中，我们把这些梯度乘以积分权重和系数。第三次循环应用第二个梯度（转置形式），这样我们就得到了单元斗室上的（拉普拉斯）值矢量。

上述代码的瓶颈是对每一个[2.x.3436]的调用所做的操作，其花费的时间和其他步骤加起来差不多（至少如果网格是非结构化的；deal.II可以识别结构化网格上的梯度往往是不变的）。这当然不理想，我们希望能做得更好。reinit函数所做的是计算实空间的梯度，使用从实空间到参考单元的转换的Jacobian来转换参考单元上的梯度。这是为单元格上的每个基函数和每个正交点进行的。雅各布系数并不取决于基函数，但它在不同的正交点上通常是不同的。如果你只建立一次矩阵，就像我们在以前所有的教程程序中所做的那样，没有什么需要优化的，因为[2.x.3438]需要在每个单元上调用。在这个过程中，转换是在计算局部矩阵元素时应用的。

然而，在一个无矩阵的实现中，我们会经常计算这些积分，因为迭代求解器在求解过程中会多次应用矩阵。因此，我们需要考虑是否可以缓存一些在运算器应用中被重用的数据，也就是积分计算。另一方面，我们意识到我们不能缓存太多的数据，否则我们又回到了内存访问成为主导因素的情况。因此，我们不会在矩阵[1.x.1307]中存储转换后的梯度，因为一般来说，对于曲线网格的每个基函数和每个元素上的正交点，它们都是不同的。

诀窍是去掉雅各布变换的因素，首先只在参考单元上应用梯度。这个操作将本地道夫上的值向量插值到正交点上的（单位坐标）梯度向量。在这里，我们首先应用我们从梯度中分解出来的雅各布，然后应用正交点的权重，最后应用转置的雅各布来准备第三个循环，通过单元格上的梯度测试并对正交点求和。

让我们再次用矩阵的方式来写。让矩阵[1.x.1308]<sub>cell</sub>表示与单元有关的梯度矩阵，每一行包含正交点上的值。它由矩阵与矩阵的乘积构成[1.x.1309]，其中[1.x.1310]<sub>ref_cell</sub>表示参考单元的梯度，[1.x.1311]<sup>-T</sup><sub>cell</sub>表示从单位到实数单元的变换的反转置Jacobian（在变换的语言中，由[1.x.1312]<sup>-T</sup><sub>cell</sub>表示协变变换的操作）。[1.x.1313]<sup>-T</sup><sub>cell</sub>是块对角线的，块的大小等于问题的维度。每个对角线块都是雅各布变换，从参考单元到实际单元。

把事情放在一起，我们发现

[1.x.1314]

所以我们要计算积（从右边开始计算局部积）。

[1.x.1315]



[1.x.1316]



注意我们如何为参考单元梯度创建一个额外的FEValues对象，以及如何将其初始化为参考单元。然后，实际的导数数据是由反的、转置的Jacobian（deal.II将Jacobian矩阵从实单元到单位单元称为inverse_jacobian，因为正向转换是从单位单元到实单元）应用的。因子[2.x.3439]是块对角线超过正交的。在这种形式下，人们意识到可变系数（可能通过张量表示）和一般网格拓扑结构的雅各布变换对变换单元格导数的系数有类似的影响。

在这一点上，人们可能会想，为什么我们要分别存储矩阵[2.x.3440]和系数，而不是只存储完整的因子[2.x.3441] 。后者会使用更少的内存，因为张量是对称的，在三维中具有六个独立的值，而对于前者，我们需要九个条目用于反转雅各布系数，一个用于正交权重和雅各布行列式，一个用于系数，总共是11个双数。原因是前者允许通过一个共同的缓存数据框架来实现通用的微分算子，而后者则专门存储拉普拉斯的系数。如果应用需要，这种专门化可能会得到回报，值得考虑。请注意，deal.II中的实现足够聪明，可以检测笛卡尔或仿生几何，其中雅各布系数在整个单元中是恒定的，不需要为每个单元存储（实际上在不同的单元中也常常是相同的）。

从操作数的角度来看，最后的优化是利用基函数中的张量积结构，这是最为关键的。这是可能的，因为我们已经从[1.x.1317]<sub>ref_cell</sub>描述的参考单元操作中剔除了梯度，即对参考单元的完全规则的数据域进行插值操作。我们举例说明在两个空间维度上降低复杂度的过程，但是同样的技术也可以用在更高的维度上。在参考单元上，基函数是张量积形式的 [2.x.3442] 。矩阵[1.x.1318]<sub>ref_cell</sub>计算第一分量的部分具有[2.x.3443]的形式，其中[1.x.1319]<sub>grad,x</sub>和[1.x.1320]<sub>val,y</sub>包含所有一维正交点上所有一维基函数的评价。用含有属于基函数[2.x.3444]的系数的[1.x.1321]组成矩阵[1.x.1322]，我们得到[2.x.3445]。这就把计算这个乘积的复杂度从[2.x.3446]降低到[2.x.3447]，其中[1.x.1323]-1是有限元的度数（即，等价地，[1.x.1324]是每个坐标方向上的形状函数的数量），或者一般来说[2.x.3448]到[2.x.3449]。我们之所以用多项式度数来看复杂度，是因为我们希望能够到高度数，可能会增加多项式度数[1.x.1325]而不是网格分辨率。像这里使用的中等度数的好算法是独立于维度的多项式度数的线性算法，而不是基于矩阵的方案或通过FEValues的天真评价。在deal.II的实现中所使用的技术自20世纪80年代以来就已经在谱元界建立起来。

实现一个无矩阵和基于单元的有限元算子，与以前的教程程序中显示的通常的矩阵装配代码相比，需要一个有点不同的程序设计。做到这一点的数据结构是MatrixFree类和FEEvaluation类，前者收集所有数据并在所有单元上发出一个（并行）循环，后者利用张量积结构评估有限元基函数。

本教程中展示的无矩阵的矩阵-向量乘积的实现比使用稀疏矩阵的线性元素的矩阵-向量乘积要慢，但由于张量乘积结构降低了复杂度，并且在计算过程中减少了内存传输，所以对所有高阶元素来说速度更快。当在一个多核处理器上工作时，减少内存传输的影响特别有利，因为在这个处理器上有几个处理单元共享内存的访问。在这种情况下，一个受计算约束的算法将显示出几乎完美的并行加速（除了可能通过涡轮模式改变处理器的时钟频率，这取决于有多少个核心在工作），而一个受内存传输约束的算法可能无法实现类似的加速（即使工作是完全并行的，我们可以期待像稀疏矩阵-向量产品那样的完美缩放）。这种实现方式的另一个好处是，我们不必建立稀疏矩阵本身，这也可能是相当昂贵的，这取决于基础微分方程。此外，上述框架可以简单地推广到非线性运算，正如我们在步骤48中所展示的那样。




[1.x.1326]

上面，我们花了很大的力气来实现一个不实际存储矩阵元素的矩阵-向量积。然而，在许多用户代码中，人们想要的不仅仅是做一些矩阵-向量乘积&mdash；在求解线性系统时，人们希望尽可能少做这些操作。理论上，我们可以使用CG方法，而不需要预处理；然而，这对拉普拉斯的效率并不高。相反，预调节器是用来提高收敛速度的。不幸的是，大多数比较常用的预处理方法，如SSOR、ILU或代数多网格（AMG）不能在这里使用，因为它们的实现需要了解系统矩阵的元素。

一个解决方案是使用几何多网格方法，如步骤16所示。众所周知，它们的速度非常快，而且适合我们的目的，因为所有的成分，包括不同网格层之间的转移，都可以用与单元格集合相关的矩阵-向量产品来表示。我们需要做的就是找到一个基于矩阵-向量乘积而不是所有矩阵条目的平滑器。一个这样的候选方法是阻尼雅可比迭代，它需要访问矩阵对角线，但它在阻尼所有高频误差方面往往不够好。雅可比方法的特性可以通过所谓的切比雪夫迭代进行几次改进。切比雪夫迭代由矩阵-向量乘积的多项式表达式描述，其中的系数可以被选择来实现某些特性，在这种情况下，可以平滑误差的高频成分，这些误差与雅可比预处理矩阵的特征值相关。在零度时，具有最佳阻尼参数的雅可比方法被检索出来，而高阶修正被用来改善平滑特性。切比雪夫平滑法在多网格中的有效性已经被证明，例如在文章[1.x.1327][1.x.1328]中。这篇文章还指出了我们在这里利用的切比雪夫平滑器的另一个优势，即它们很容易并行化，而SOR/Gauss&ndash;Seidel平滑依赖于替换，对于这种替换，天真的并行化在矩阵的对角线子块上工作，从而降低了效率（更多细节见例如Y. Saad, Iterative Methods for Sparse Linear Systems, SIAM, 2nd edition, 2003, chapters 11 & 12）。

然后，在多网格框架中的实现就很简单了。本程序中的多网格实现与step-16类似，包括自适应性。




[1.x.1329]

FEEvaluation中的计算内核是以优化使用计算资源的方式来编写的。为了达到这个目的，他们不对双倍数据类型进行操作，而是对我们称之为VectorizedArray的东西进行操作（例如，查看[2.x.3450]的返回类型，对于标量元素是VectorizedArray，对于矢量有限元素是Tensor of VectorizedArray）。VectorizedArray是一个双数或浮点数的短阵列，其长度取决于使用的特定计算机系统。例如，基于x86-64的系统支持流式SIMD扩展（SSE），处理器的矢量单元可以通过一条CPU指令处理两个双数（或四个单精度浮点数）。较新的处理器（大约从2012年起）支持所谓的高级向量扩展（AVX），有256位操作数，可以分别使用四个双数和八个浮点数。矢量化是一个单指令/多数据（SIMD）的概念，也就是说，一条CPU指令被用来同时处理多个数据值。通常情况下，有限元程序不会明确使用矢量化，因为这个概念的好处只体现在算术密集型操作中。大部分典型的有限元工作负载都受到内存带宽的限制（对稀疏矩阵和向量的操作），在这种情况下，额外的计算能力是无用的。

不过，在幕后，优化的BLAS包可能严重依赖矢量化。另外，优化的编译器可能会自动将涉及标准代码的循环转化为更有效的矢量化形式（deal.II在矢量更新的常规循环中使用OpenMP SIMD pragmas）。然而，数据流必须非常有规律，才能让编译器产生高效的代码。例如，受益于矢量化的原型操作（矩阵-矩阵乘积）的自动矢量化在大多数编译器上都失败了（截至2012年初编写本教程并在2016年底更新时，gcc和英特尔编译器都无法为[2.x.3451]函数，甚至在更简单的情况下也不行，即矩阵边界是编译时常量而不是[2.x.3452]中的运行时常量。此外，有可能被一起处理的数据可能没有以连续的方式布置在内存中，或者没有对处理器需要的地址边界进行必要的对齐。或者编译器可能无法证明数据阵列在一次加载几个元素时不会重叠。

因此，在deal.II的无矩阵实现中，我们选择在最适合于有限元计算的层次上应用矢量化。所有单元的计算通常是完全相同的（除了从向量读写时使用的间接寻址中的索引），因此SIMD可以用来一次处理几个单元。在下面的所有内容中，你可以考虑用一个向量数组来保存几个单元的数据。记住，它与空间维度和元素数量无关，例如在Tensor或Point中。

请注意，矢量化取决于代码运行的CPU，以及代码的编译对象。为了给你的计算机生成最快的FEEvaluation内核，你应该用所谓的[1.x.1330]处理器变体编译deal.II。当使用gcc编译器时，可以通过在cmake构建设置中设置变量<tt>CMAKE_CXX_FLAGS</tt>为<tt>"-march=native"</tt>来启用它（在命令行中，指定<tt>-DCMAKE_CXX_FLAGS="-march=native"</tt>，更多信息见deal.II阅读手册）。其他编译器也有类似的选项。我们在本例的run()函数中输出当前的矢量化长度。




[1.x.1331]

如上所述，无矩阵框架中的所有组件都可以通过MPI使用领域分解轻松实现并行化。由于在deal.II中通过p4est（详见step-40）可以很容易地访问大规模的并行网格，而且基于单元格的循环与无矩阵评估[1.x.1332]需要在每个处理器上将网格分解成大小基本相同的块，因此编写一个使用分布式内存工作的并行程序所需的工作相对较少。虽然其他使用MPI的教程程序依赖于PETSc或Trilinos，但这个程序使用deal.II自己的并行向量设施。

deal.II并行向量类，[2.x.3453]持有解决方案的处理器本地部分以及重影自由度的数据字段，即由远程处理器拥有的自由度，但由当前处理器拥有的单元访问。在[2.x.3454]"术语表 "中，这些自由度被称为本地活动自由度。函数[2.x.3455]提供了一个设置这种设计的方法。请注意，悬挂节点可以与额外的重影自由度有关，这些自由度必须包括在分布式矢量中，但不属于[2.x.3456]"词汇表 "意义上的本地活动自由度。此外，分布式向量持有本地拥有但其他处理器需要的DoF的MPI元数据。这个向量类设计的一个好处是对重影项的访问方式。在向量的存储方案中，数据阵列延伸到解决方案的处理器本地部分之外，有更多的向量条目可用于重影自由度。这为所有本地活动自由度提供了一个连续的索引范围。(注意，索引范围取决于网格的具体配置。)由于无矩阵操作可以被认为是在做性能关键的线性代数，而性能关键的代码不能把时间浪费在做MPI全局到MPI局部的索引转换上，一个MPI等级的局部索引空间的可用性是很重要的。这里访问事物的方式是直接数组访问。这是通过[2.x.3457]提供的，但实际上很少需要，因为所有这些都发生在FEEvaluation的内部。

2.x.3458]的设计与我们之前在step-40和step-32中使用的[2.x.3459]和[2.x.3460]数据类型类似，但由于我们不需要这些库的其他并行功能，所以我们使用deal.II的[2.x.3461]类来代替在本教程程序中链接另一个大型库。还要注意的是，PETSc和Trilinos向量不提供对直接数组访问的幽灵条目的细粒度控制，因为它们抽象出了必要的实现细节。


examples/step-37/doc/results.dox



[1.x.1333]

[1.x.1334]

由于这个例子解决的是与步骤5相同的问题（除了不同的系数），所以对解决方案没有什么可说的。我们还是展示了一张图片，通过等高线和体积渲染来说明解决方案的大小。

[2.x.3462]

更有趣的是评估多网格求解器的某些方面。当我们在二维运行这个程序时，对于二次（[2.x.3463]）元素，我们得到以下输出（当在一个核心上以释放模式运行时）。

[1.x.1335]



如同步骤16，我们看到随着自由度的增加，CG的迭代次数保持不变。恒定的迭代次数（加上最佳的计算特性）意味着当问题大小在一个周期内翻两番时，计算时间大约翻了四倍。该代码在存储方面也非常有效。大约200-400万个自由度适合于1GB的内存，也见下面的MPI结果。一个有趣的事实是，尽管没有建立矩阵，但解决一个线性系统比设置要便宜（大约一半的时间花在[2.x.3464]和[2.x.3465]的调用上）。这表明这种方法的效率很高，但也表明deal.II数据结构的设置相当昂贵，设置成本必须在几个系统求解中摊销。

如果我们在三个空间维度上运行程序，就不会有太大变化。由于我们使用了均匀的网格细化，我们得到的元素数量是八倍，每个周期的自由度大约是八倍。

[1.x.1336]



既然如此简单，我们看看如果我们增加多项式的度数会发生什么。当在三维中选择度数为4，即在[2.x.3466]元素上，通过改变程序顶部的一行<code>const unsigned int degree_finite_element=4;</code>，我们得到以下程序输出。

[1.x.1337]



由于一定网格上的[2.x.3467]元素对应于一半网格大小的[2.x.3468]元素，我们可以比较第四周期使用四度多项式和第五周期使用二次多项式的运行时间，两者都是210万自由度。令人惊讶的效果是，尽管多用了一次线性迭代，[2.x.3469]元素的求解器实际上比四次方的情况略快。高阶多项式的速度与低阶多项式类似，甚至比低阶多项式更快，这是通过和分解进行无矩阵算子评估的主要优势之一，见[1.x.1338]。这与基于矩阵的方法有根本的不同，后者随着多项式度数的增加和耦合的密集，每个未知数的成本会越来越高。

此外，对于更高的订单，设置也变得更便宜，这是因为需要设置的元素更少。

最后，让我们看一下度数为8的时间，这相当于低阶方法的另一轮网格细化。

[1.x.1339]



在这里，初始化似乎比以前慢得多，这主要是由于矩阵对角线的计算，它实际上是在每个单元格上计算一个729 x 729的矩阵，扔掉除对角线以外的所有东西。然而，解算时间再次非常接近四次方的情况，这表明理论上预期的随着多项式程度的增加而出现的线性增长几乎完全被更好的计算特性和高阶方法在几个单元上的自由度份额较小而增加了评估的复杂性所抵消。

[1.x.1340]

为了了解无矩阵实现的能力，我们通过测量问题初始化的计算时间（分配DoF、设置和装配矩阵、设置多网格结构）以及无矩阵变体和基于稀疏矩阵的变体的实际求解时间，将上面的3D例子与基于稀疏矩阵的变体的性能进行比较。如上图所示，我们将预处理程序建立在浮点数上，将实际的矩阵和向量建立在双数上。测试在英特尔酷睿i7-5500U笔记本处理器（两个核心，支持[1.x.1341]，即用一条CPU指令就可以完成对双数的四次操作，这在FEEvaluation中被大量使用）、优化模式和两个MPI行列上运行。

[2.x.3471]

该表清楚地显示，无矩阵实现的求解速度是两倍以上，而在初始化成本方面，则是六倍以上。随着问题大小被放大8倍，我们注意到，时间通常也会上升8倍（因为求解器的迭代次数恒定为6次）。主要的偏差是在5k到36k自由度的稀疏矩阵中，时间增加了12倍。这是处理器中的（L3）缓存不能再容纳矩阵-向量乘积所需的所有数据的阈值，所有的矩阵元素必须从主内存中获取。

当然，这种情况不一定适用于所有情况，因为在有些问题上，对矩阵项的了解可以使解算器的效果好得多（如当系数的变化比上面的例子更强烈时）。此外，这也取决于计算机系统。目前的系统具有良好的内存性能，因此稀疏矩阵的性能相当好。尽管如此，对于本例中使用的[1.x.1342]<sub>2</sub>元素，无矩阵的实现已经给出了一个不错的速度。这一点对于时间依赖性或非线性问题尤其明显，在这些问题中，稀疏矩阵需要一次又一次地被重新组合，有了这个类，这就变得容易多了。当然，由于产品的复杂性更好，当元素的阶数增加时，该方法获得了越来越大的优势（无矩阵实现每个自由度的成本为4[1.x.1343]<sup>2</sup>[1.x.1344]，而稀疏矩阵为2[1.x.1345]，所以无论如何它在4阶以上的3d中会获胜）。

[1.x.1346]

正如介绍和代码中的注释所解释的，这个程序可以用MPI并行运行。事实证明，几何多栅方案工作得非常好，可以扩展到非常大的机器。据作者所知，这里显示的几何多网格结果是截至2016年底用deal.II完成的最大计算，在[1.x.1347]的多达147456个核心上运行。超过1000个核心的可扩展性的要素是，没有任何依赖于全局问题大小的数据结构被完整地保存在一个处理器上，并且通信不是太频繁，以避免遇到网络的延迟问题。  对于用迭代求解器求解的PDEs，通信延迟往往是限制因素，而不是网络的吞吐量。以SuperMUC系统为例，两个处理器之间的点对点延迟在1e-6到1e-5秒之间，取决于MPI网络中的距离。这一类的矩阵-向量产品与[2.x.3472]涉及几个点对点通信步骤，与每个核心上的计算交错进行。由此产生的矩阵-向量乘积的延迟约为1e-4秒。全局通信，例如一个[2.x.3473]操作，在MPI网络中的所有等级上累积每个等级的单一数字之和，其延迟为1e-4秒。这个程序中使用的多网格V型循环也是全局通信的一种形式。想一想发生在单个处理器上的粗略网格求解。在开始之前，它积累了来自所有处理器的贡献。当完成后，粗网格解决方案被转移到更细的层次，在那里越来越多的处理器帮助平滑，直到细网格。从本质上讲，这是在网络中的处理器上的一个树状模式，并由网格控制。相对于[2.x.3474]的操作，在还原中的树被优化为MPI网络中的实际链接，多网格V-cycle是根据网格的划分来做的。因此，我们不能期望有同样的优化效果。此外，多网格循环并不是简单地在细化树上走来走去，而是在做平滑的时候在每一层上进行通信。换句话说，多网格中的全局通信更具挑战性，与提供较少优化机会的网格有关。测得的V型周期的延迟在6e-3和2e-2秒之间，即与60至200次MPI_Allreduce操作相同。

下图显示了在[2.x.3475]元素上进行的缩放实验。沿着这条线，问题的大小保持不变，因为核的数量在增加。当内核数量增加一倍时，人们期望计算时间减少一半，灰色虚线表示。结果显示，在达到0.1秒左右的绝对时间之前，该实现显示了几乎理想的行为。解算器的公差已经被设定为解算器执行五次迭代。这种绘制数据的方式是该算法的[1.x.1348]。当我们走到非常大的核心数时，曲线会提前变平，这是因为SuperMUC中的通信网络，距离较远的处理器之间的通信会稍慢一些。

[2.x.3476]

此外，该图还包含了[1.x.1349]的结果，列出了当处理器内核和元素的数量都以相同的速度增加时，算法的表现。在这种情况下，我们期望计算时间保持不变。在算法上，CG的迭代次数恒定在5次，所以我们从这一点来看是好的。图中的线条是这样排列的：每个数据系列中的左上角点代表每个处理器的相同大小，即131,072个元素（或每个核心大约350万个自由度）。表示理想的强缩放的灰色线条相隔8个相同的系数。结果再次表明，缩放比例几乎是理想的。当从288个核到147456个核时，并行效率在75%左右，每个核的局部问题大小为75万自由度，在288个核上需要1.0秒，在2304个核上需要1.03秒，在18000个核上需要1.19秒，在147000个核上需要1.35秒。这些算法对处理器的利用率也达到了很高。在147k核心上最大的计算在SuperMUC上达到约1.7 PFLOPs/s，其中算术峰值为3.2 PFLOPs/s。对于一个迭代式PDE求解器来说，这是一个非常高的数字，而且通常只有密集线性代数才会达到显著的数字。稀疏线性代数被限制在这个数值的十分之一。

正如介绍中提到的，无矩阵方法减少了数据结构的内存消耗。除了由于更少的内存传输而带来的更高的性能外，该算法还允许非常大的问题被装入内存。下图显示了随着我们增加问题的大小，直到计算耗尽内存的上限时的计算时间。我们对1k核、8k核和65k核进行了计算，发现问题的大小几乎可以在两个数量级上进行理想的扩展。这张图中显示的最大的计算涉及2920亿（[2.x.3477]）个自由度。在147k核心的DG计算中，上述算法也被运行，涉及多达5490亿（2^39）个自由度。

[2.x.3478]

最后，我们注意到，在对上述大规模系统进行测试的同时，deal.II中的多网格算法也得到了改进。原始版本包含了基于MGSmootherPrecondition的次优代码，其中一些MPI_Allreduce命令（检查所有向量条目是否为零）在每一级的平滑操作上都要进行，这在65k核以上的系统中才变得明显。然而，下面的图片显示，改进已经在较小的规模上得到了回报，这里显示的是对[2.x.3479]元素在多达14336个内核上的计算。

[2.x.3480]




[1.x.1350]

正如代码中所解释的，这里介绍的算法是为运行在自适应细化的网格上准备的。如果只有部分网格被细化，多网格循环将以局部平滑的方式运行，并通过[2.x.3481]类对细化程度不同的界面施加迪里切条件进行平滑。由于自由度在层次上的分布方式，将层次单元的所有者与第一个下级活动单元的所有者联系起来，在MPI中不同的处理器之间可能存在不平衡，这限制了可扩展性，约为2到5倍。

[1.x.1351]

[1.x.1352]

如上所述，代码已经准备好用于局部自适应h-精简。对于泊松方程，可以采用KellyErrorEstimator类中实现的Kelly误差指标。然而，我们需要小心处理平行向量的鬼魂指数。为了评估误差指标中的跳跃项，每个MPI进程需要知道本地相关的DoF。然而[2.x.3482]函数只用一些本地相关的DoF来初始化向量。在向量中提供的鬼魂指数是一个严格的集合，只有那些在单元积分（包括约束解决）中被触及的指数。这种选择有性能上的原因，因为与矩阵-向量乘积相比，发送所有本地相关的自由度会过于昂贵。因此，原样的解决方案向量不适合KellyErrorEstimator类。诀窍是改变分区的幽灵部分，例如使用一个临时向量和[2.x.3483]，如下所示。

[1.x.1353]



[1.x.1354]

这个程序只用MPI来并行化。作为一种选择，MatrixFree循环也可以在混合模式下发出，例如通过在集群的节点上使用MPI并行化，在一个节点的共享内存区域内通过Intel TBB使用线程。要使用这一点，就需要在主函数的MPI_InitFinalize数据结构中同时设置线程数，并将[2.x.3484]设置为partition_color，以便真正并行地进行循环。这个用例将在步骤-48中讨论。

[1.x.1355]

所提出的程序假定了同质的Dirichlet边界条件。当进入非均质条件时，情况就有点复杂了。为了理解如何实现这样的设置，让我们首先回顾一下这些条件是如何在数学公式中出现的，以及它们是如何在基于矩阵的变体中实现的。从本质上讲，非均质Dirichlet条件将解决方案中的一些节点值设定为给定值，而不是通过变分原理来确定它们。

[1.x.1356]

其中[2.x.3485]表示解决方案的节点值，[2.x.3486]表示所有节点的集合。集合[2.x.3487]是受迪里希特边界条件约束的节点子集，其中解被强制等于[2.x.3488]作为迪里希特约束的节点点上的边界值插值[2.x.3489] 。然后我们把这个解的表示插入到弱的形式中，例如上面所示的拉普拉斯，并把已知量移到右边。

[1.x.1357]

在这个公式中，对所有的基函数[2.x.3490]与[2.x.3491]进行测试，这些基函数与迪里希特条件约束的节点没有关系。

在deal.II的实现中，右手边的积分[2.x.3492]已经包含在我们在每个单元格上组装的局部矩阵贡献中。当使用[2.x.3493]时，正如在步骤6和步骤7的教程程序中首次描述的那样，我们可以通过将本地矩阵的列[1.x.1359]和行[1.x.1360]相乘来说明不均匀约束的贡献[1.x.1358] 的局部矩阵根据积分[2.x.3494]乘以不均匀性，然后从全局右侧向量中的位置[1.x.1361]中减去所得，也见[2.x.3495] 模块。实质上，我们使用一些从方程左侧被消除的积分来最终确定右侧的贡献。当首先将所有条目写进左侧矩阵，然后通过[2.x.3496]消除矩阵的行和列时，也会涉及类似的数学。

原则上，属于受限自由度的成分可以从线性系统中剔除，因为它们不携带任何信息。实际上，在deal.II中，我们总是保持线性系统的大小不变，以避免处理两种不同的编号系统，并避免对两种不同的索引集产生混淆。为了确保在不向受限行添加任何东西时，线性系统不会变得奇异，我们再向矩阵对角线添加假条目，否则与真实条目无关。

在无矩阵方法中，我们需要采取不同的方法，因为[2.x.3497]LaplaceOperator类代表了[1.x.1362]算子的矩阵-向量乘积（最后一个公式的左手边）。  传递给[2.x.3498]的AffineConstraints对象是否包含不均匀约束并不重要，只要它代表一个[1.x.1363]算子，[2.x.3499]调用将只解决约束的同质部分。

在我们的无矩阵代码中，非均质条件的贡献最终会在右侧计算中与矩阵算子完全脱钩，并由上述不同的函数处理。因此，我们需要明确地生成进入右手边的数据，而不是使用矩阵装配的副产品。由于我们已经知道如何在一个向量上应用算子，我们可以尝试对一个向量使用这些设施，我们只设置Dirichlet值。

[1.x.1364]

或者说，如果我们已经将不均匀约束填充到AffineConstraints对象中。

[1.x.1365]



然后我们可以将向量[2.x.3500]传递给[2.x.3501][2.x.3502]函数，并将新的贡献添加到[2.x.3503]system_rhs向量中，在[2.x.3504]函数中被填充。然而，这个想法并不奏效，因为vmult()函数中使用的[2.x.3505]调用假定所有约束条件的值都是同质的（否则运算符就不是线性运算符，而是仿射运算符）。为了同时检索不均匀性的值，我们可以选择以下两种策略中的一种。

[1.x.1366]

FEEvaluation类有一个设施，正是为了解决这个要求。对于非均质的Dirichlet值，我们确实希望在从向量[2.x.3506]中读取数据时跳过隐含的均质（Dirichlet）约束。例如，我们可以扩展[2.x.3507][2.x.3508]函数来处理非均质的Dirichlet值，如下所示，假设Dirichlet值已经被插值到对象[2.x.3509] 中

[1.x.1367]



在这段代码中，我们用忽略所有约束的[2.x.3511]代替了用于暂定解向量的[2.x.3510]函数。由于这种设置，我们必须确保其他约束条件，例如通过悬挂节点，已经正确地分布到输入向量中，因为它们没有像[2.x.3512]那样被解决。 在循环内部，我们然后评估拉普拉斯，并用[2.x.3514]类中的[2.x.3513]重复二次导数调用，但符号调换，因为我们想根据上述公式减去右侧向量的迪里希条件的贡献。当我们调用[2.x.3515]时，我们将关于值槽和第一导数槽的两个参数设置为真，以说明在正交点的循环中加入的两个项。一旦右手边集合完毕，我们就继续求解同质问题的线性系统，比如说涉及到一个变量[2.x.3516]在求解之后，我们可以将[2.x.3517]加入到包含最终（非同质）解决方案的[2.x.3518]向量中。

请注意，拉普拉斯的负号与我们需要用来建立右手边的强制力的正号是一个更普遍的概念。我们所实施的只不过是牛顿的非线性方程方法，但应用于线性系统。我们在迪里切特边界条件方面使用了对变量[2.x.3519]的初始猜测，并计算了残差[2.x.3520] 。然后线性系统被解为 [2.x.3521] ，我们最后计算出 [2.x.3522] 。对于一个线性系统，我们显然在一次迭代后就能达到精确解。如果我们想将代码扩展到非线性问题，我们会将[2.x.3523]函数重新命名为一个更具描述性的名字，如[2.x.3524] assemble_residual()，计算残差的（弱）形式，而[2.x.3525]函数将得到残差相对于解变量的线性化。

[1.x.1368]

获得重新使用[2.x.3526][2.x.3527]函数的第二个替代方法是添加第二个LaplaceOperator，跳过Dirichlet约束。为了做到这一点，我们初始化第二个MatrixFree对象，它没有任何边界值约束。这个[2.x.3528]对象然后被传递给一个[2.x.3529]类实例[2.x.3530]inhomogeneous_operator，它只用于创建右手边。

[1.x.1369]



这种技术的更复杂的实现可以重新使用原始的MatrixFree对象。这可以通过用多个块初始化MatrixFree对象来实现，其中每个块对应于不同的AffineConstraints对象。这样做需要对LaplaceOperator类进行大量的修改，但是库中的[2.x.3531]类可以做到这一点。关于如何设置块的更多信息，请参见[2.x.3532]中关于块的讨论。


examples/step-38/doc/intro.dox

[2.x.3533]

[1.x.1370]

[1.x.1371]

[1.x.1372]

在这个例子中，我们展示了如何解决由四边形组成的一维曲面[2.x.3534]上的偏微分方程（PDE），即在三维的曲面或二维的直线上。我们重点讨论以下的椭圆二阶PDE

[1.x.1373]

它概括了我们以前在几个早期教程程序中解决的拉普拉斯方程。我们的实现是基于step-4的。step-34也可以解决低维曲面上的问题；但是，在那里我们只考虑不涉及解变量导数的积分方程，而在这里我们实际上要研究只在一个（可能是弯曲的）曲面上定义的函数的导数是什么意思。

为了定义上述算子，我们首先要介绍一些符号。让[2.x.3535]是一个由参考元素[2.x.3537]构成的曲面[2.x.3536]的参数化，即每个点[2.x.3538]诱导出一个点[2.x.3539] 。那么让

[1.x.1374]

表示相应的第一基本形式，其中[2.x.3540]是映射的导数（雅各布）。在下文中，[2.x.3541]将是整个表面[2.x.3542]，或者对有限元方法更方便的是任何面[2.x.3543]，其中[2.x.3544]是由四边形构成的[2.x.3545]的分区（三角化）。我们现在可以定义一个函数[2.x.3546]的切向梯度，即

[1.x.1375]

表面拉普拉斯(也叫拉普拉斯-贝特拉米算子)的定义是 [2.x.3547] 。请注意，在光滑表面上计算表面梯度的另一种方法 [2.x.3548] 是

[1.x.1376]

其中[2.x.3549]是[2.x.3550]在[2.x.3551]的管状邻域的 "平滑 "扩展，[2.x.3552]是[2.x.3553]的法线。由于[2.x.3554]，我们推导出

[1.x.1377]

值得一提的是，上述表达式中出现的术语[2.x.3555]是曲面的总曲率（主曲率之和）。

像往常一样，我们只对弱解感兴趣，为此我们可以使用[2.x.3556]有限元（而不是像强解那样要求[2.x.3557]的连续性）。因此，我们求助于弱的表述

[1.x.1378]

并利用分区[2.x.3558]的优势，进一步编写

[1.x.1379]

此外，上述表达式中的每个积分都是在参考元素[2.x.3559]中计算的，因此

[1.x.1380]

和

[1.x.1381]

最后，我们使用由点[2.x.3560]和权重[2.x.3561]定义的正交公式来评估上述积分，得到

[1.x.1382]

和

[1.x.1383]




幸运的是，deal.II已经有了所有的工具来计算上述表达式。事实上，它们与我们求解通常的拉普拉斯的方法几乎没有区别，只需要在FEValues类的构造函数中提供表面坐标映射。这个曲面描述给定，在二维曲面的情况下，两个例程[2.x.3562]和[2.x.3563]会返回

[1.x.1384]

这正好提供了我们的计算所需的术语。

在更广泛的意义上，表面有限元逼近的细节可以在[Dziuk, in Partial differential equations and calculus of variations 1357, Lecture Notes in Math., 1988], [Demlow, SIAM J. Numer. Anal. 47(2), 2009] 和 [Bonito, Nochetto, and Pauletti, SIAM J. Numer. Anal. 48(5), 2010] 中找到。




[1.x.1385]

一般来说，当你想在数值上测试一个算法的准确性和/或收敛性，你需要提供一个精确的解决方案。通常的技巧是选择一个我们希望成为解决方案的函数，然后对其应用微分算子，为右侧定义一个强制项。这就是我们在这个例子中所做的。在当前情况下，域的形式显然也是至关重要的。

我们为二维问题制作一个测试案例，为三维问题制作另一个测试案例。

[2.x.3564] [2.x.3565] 在2d中，让我们选择一个半圆作为域。在这个域上，我们选择函数[2.x.3566]作为解决方案。为了计算右手边，我们必须计算解函数的表面拉普拉斯。有（至少）两种方法可以做到这一点。第一种是使用[2.x.3567]的自然延伸（仍然用[2.x.3568]表示）在[2.x.3569]上投影掉上面描述的法向导数，即计算[1.x.1386] 。

  其中 [2.x.3570] 是 [2.x.3571] 的总曲率。   由于我们在单位圆上，[2.x.3572]和[2.x.3573]所以[1.x.1387]



  一个更简单的方法，至少对于目前二维空间的曲线的情况，是注意到我们可以用变换[2.x.3574]将区间[2.x.3575]映射到域[2.x.3576]。   在位置 [2.x.3577] 上，解的值是 [2.x.3578] 。   考虑到转换是保长的，即长度为[2.x.3579]的线段被映射到完全相同长度的曲线上，那么切向拉普拉斯就满足[1.x.1388] 。

  这当然和我们上面的结果是一样的。  [2.x.3580] [2.x.3581] 在三维中，域又是单位球表面的一半，即半球或圆顶。我们选择[2.x.3582]作为解决方案。我们可以用上面的方法计算方程的右边，[2.x.3583]，（用[2.x.3584]），得到一个笨拙而冗长的表达。你可以在源代码中找到完整的表达式。  [2.x.3585] [2.x.3586]。

在程序中，我们还将计算出解的[2.x.3587]半规范误差。由于解函数及其数值近似只在流形上定义，这个误差函数的明显定义是[2.x.3588] 。这就要求我们为函数[2.x.3590]（在步骤7中首次引入）提供[1.x.1389]梯度[2.x.3589]，我们将通过在下面的程序中实现函数[2.x.3591]来实现。




[1.x.1390]

如果你已经读完了第4步，并且理解了上面关于解和右边如何对应的讨论，你也会立即熟悉这个程序。事实上，只有两件事是有意义的。

- 我们生成三角计算域的网格的方式。

- 我们使用映射对象的方式来描述，我们解决偏微分方程的领域不是平面的，实际上是弯曲的。

在第10步和第11步中已经介绍了映射对象，正如那里所解释的，只要你对边界的样子有一个有效的描述，你通常不需要知道它们是如何工作的。从本质上讲，我们将简单地声明一个适当的MappingQ类型的对象，它将自动从三角图中获得边界描述。然后，该映射对象将被传递给适当的函数，我们将得到库中预定义的半圆或半球形的边界描述。

该程序的其余部分紧跟步骤4，至于计算误差，则是步骤7。这个程序的某些方面，特别是在Triangulation、DoFHandler和类似的类上使用两个模板参数，已经在步骤34中作了详细描述；你不妨也读一读这个教程程序。


examples/step-38/doc/results.dox



[1.x.1391]

当你运行该程序时，应在屏幕上打印出以下输出。

[1.x.1392]




通过在[2.x.3592]函数中玩弄全局细化的数量，可以增加或减少网格细化。例如，多做一次细化，只运行三维曲面问题，得到的输出结果如下。

[1.x.1393]



这就是我们所期望的：将网格尺寸缩小2倍，误差下降4倍（记住我们使用的是双二次元）。从一到五次细化的全部误差序列看起来是这样的，整齐地遵循理论上预测的模式。

[1.x.1394]



最后，该程序产生图形输出，我们可以将其可视化。下面是一个结果图。

[2.x.3593]

该程序也适用于2D中的1D曲线，而不仅仅是3D中的2D曲面。你可以通过改变[2.x.3594]中的模板参数来测试这一点，像这样。

[1.x.1395]

域是一条2D的曲线，我们可以通过使用第三维（和颜色）来表示函数[2.x.3595]的值来可视化解决方案。这样看起来就像这样（白色的曲线是域，彩色的曲线是被挤压到第三维的解决方案，清楚地显示了当曲线从域的一个象限移动到相邻的象限时符号的变化）。

[2.x.3596]


[1.x.1396]

[1.x.1397]

只有当表面比仅仅是一个半球体更有趣时，在表面上的计算才会变得有趣。为了达到这个目的，deal.II可以通过通常的GridIn类读取描述曲面的网格。或者，万一你有一个分析性的描述，一个简单的网格有时可以被拉伸和弯曲成我们感兴趣的形状。

让我们考虑一个相对简单的例子：我们把之前用过的半球体，在Z方向上拉伸10倍，然后把X和Y坐标拼一下。让我们先展示一下计算域和解决方案，然后再讨论下面的实现细节。

[2.x.3597]

[2.x.3598]

产生这种网格的方法是使用[2.x.3599]函数。它需要一个方法来转换每个单独的网格点到不同的位置。让我们在这里使用下面这个相当简单的函数（记住：在一个方向上拉伸，在另外两个方向上拼凑）。

[1.x.1398]



如果我们遵循[2.x.3600]函数，我们会像以前一样提取半球形表面网格，将其扭曲成我们想要的形状，并根据需要经常进行细化。但这并不像我们所希望的那样简单：细化需要我们有一个适当的流形对象附加到三角形上，描述细化时网格的新顶点应该位于何处。我相信可以通过简单地撤销上面的变换（重新得到球面），找到球面上新的点的位置，然后重新扭曲结果，以一种不太复杂的方式描述这个流形。但我是个懒人，既然这样做并不是真正的重点，我们还是让我们的生活变得简单一点：我们将提取半球体，根据需要对其进行细化，摆脱描述流形的对象，因为我们现在不再需要它，然后最后对网格进行扭曲。使用上面的函数，这将看起来如下。

[1.x.1399]



请注意，唯一必要的补充是标有星号的那一行。不过值得指出的是：由于我们将流形描述从表面网格中分离出来，所以当我们在程序的其余部分使用映射对象时，它不再有曲线边界描述可言。相反，它将不得不使用隐含的FlatManifold类，该类用于域的所有未明确指定不同流形对象的部分。因此，无论我们使用MappingQ(2)、MappingQ(15)还是MappingQ1，我们的网格的每个单元都将使用双线性近似进行映射。

撇开所有这些缺点不谈，得到的图片还是很好看的。与步骤38中的内容唯一不同的是，我们把右手边改为[2.x.3601]，把边界值（通过[2.x.3602]类）改为[2.x.3603] 。当然，我们现在已经不知道确切的解决方案，所以在[2.x.3604]末尾的误差计算将得到一个毫无意义的数字。


examples/step-39/doc/intro.dox

[1.x.1400]

在这个程序中，我们使用内部惩罚方法和Nitsche的弱边界条件来解决Poisson方程。我们在局部细化的网格上使用多网格方法，这些网格是用一个体块准则和一个基于单元和面残差的标准误差估计器生成的。所有的运算符都是用MeshWorker接口实现的。

像步骤12一样，离散化依赖于有限元空间，它在网格单元[2.x.3605]内是多项式的，但在单元之间没有连续性。由于这种函数在每个内部面[2.x.3606]上有两个值，每边一个，我们定义均值和跳跃算子如下：让[1.x.1401]<sub>1</sub>和[1.x.1402]<sub>2</sub>是共享一个面的两个单元，让函数的轨迹[1.x.1403]和外法向量[1.x.1404][1.x.1405]相应地被标记。然后，在这个面上，我们让

[1.x.1406]



注意，如果这样的表达式包含一个法向量，那么平均运算符就会变成一个跳跃。该问题的内部惩罚方法

[1.x.1407]

成为

[1.x.1408]



这里，[2.x.3607]是惩罚参数，其选择如下：对于[1.x.1409]单元格[1.x.1410]的一个面，计算数值

[1.x.1411]

其中[1.x.1412]是有限元函数的多项式程度，[2.x.3608]和[2.x.3609]表示相应对象的[2.x.3610]和[2.x.3611]维度的Hausdorff度量。如果面在边界上，选择[2.x.3612] 。对于一个内部的面，我们取这个面的两个值的平均值。

在我们的有限元程序中，我们区分了三种不同的积分，分别对应于上面的单元、内部面和边界面的总和。由于[2.x.3613]为我们组织了这些和，我们只需要实现对每个网格元素的积分。下面的MatrixIntegrator类有这三个函数用于公式的左边，RHSIntegrator类用于右边。

正如我们将在下面看到的，甚至误差估计也是相同的结构，因为它可以写成

[1.x.1413]



因此，下面用于组装矩阵、右手和误差估计的函数显示，这些循环都是通用的，可以用同样的方式进行编程。

这个程序与步骤12b有关，因为它使用MeshWorker和非连续Galerkin方法。在那里，我们解决的是一个平流问题，而这里是一个扩散问题。在这里，我们还使用了多网格预处理和一个理论上合理的误差估计器，见Karakashian和Pascal（2003）。Kanschat (2004)详细讨论了多层次方案。Hoppe, Kanschat, and Warburton (2009)讨论了自适应迭代及其收敛性（对于三角形网格）。


examples/step-39/doc/results.dox



[1.x.1414]

[1.x.1415] 首先，该程序产生通常的日志文件，在这里存储在<tt>deallog</tt>。它的内容是（省略了中间的步骤

[1.x.1416]



例如，该日志显示共轭梯度迭代步骤的数量恒定在大约15个。

[1.x.1417]

[2.x.3614] 使用perl脚本<tt>postprocess.pl</tt>，我们提取相关数据到<tt>output.dat</tt>，可以用<tt>gnuplot</tt>绘制图形。例如，上面的图是用gnuplot脚本<tt>plot_errors.gpl</tt>制作的，通过

[1.x.1418]



参考数据可以在<tt>output.reference.dat</tt>中找到。


examples/step-4/doc/intro.dox

[1.x.1419]

[1.x.1420]

[2.x.3615]

deal.II有一个独特的功能，我们称之为 "无维度编程"。你可能已经注意到，在前面的例子中，许多类的后缀都是角括号中的数字。这是为了表明，例如，二维和三维空间的三角形是不同的，但是相关的数据%类型。我们完全可以把它们称为[2.x.3616]而不是[2.x.3617]和[2.x.3618]来命名这两个类，但这有一个重要的缺点：假设你有一个功能完全相同的函数，但在2D或3D三角形上，取决于我们目前想在哪个维度上解方程（如果你不相信一个函数在所有维度上都做同样的事情是常见的情况，看看下面的代码就知道了，2D和3D之间几乎没有区别！）。我们将不得不把同一个函数写两次，一次在[2.x.3619]上工作，一次在[2.x.3620]上工作。这在编程中是一个不必要的障碍，并且导致了保持两个函数同步的麻烦（最好是），或者在两个版本不同步时难以发现错误（最坏的情况是；这可能是更常见的情况）。





这种障碍可以通过使用C++语言提供的一些模板魔法来规避：模板化的类和函数并不是真正的类或函数，而只是取决于一个尚未定义的数据类型参数或在定义时也未知的数值的一种模式。然而，如果你向它提供了所需的信息，编译器可以从这些模板中建立适当的类或函数。当然，模板的部分内容可以依赖于模板参数，它们将在编译时被解析为特定的模板参数。例如，考虑下面这段代码。

[1.x.1421]






在编译器看到这个函数的时候，它对[2.x.3621]的实际值并不了解。编译器唯一拥有的是一个模板，即蓝图，如果给定[2.x.3622]的特定值有一个未知的值，编译器暂时没有可以生成的代码。




然而，如果以后下来，编译器会遇到一些代码，例如，看起来像这样。

[1.x.1422]

那么编译器将推断出请求将函数[2.x.3624]替换为[2.x.3625]，并将上述模板编译为一个到处都用2替换了dim的函数，也就是说，它将编译该函数，就好像它被定义为

[1.x.1423]






然而，值得注意的是，函数[2.x.3626]也取决于维度，所以在这种情况下，编译器将调用函数[2.x.3627]，而如果dim是3，它将调用[2.x.3628]，这可能是（实际上是）一个完全无关的函数。




对成员变量也可以这样做。考虑一下下面的函数，它可能反过来调用上面的函数。

[1.x.1424]

这个函数有一个类型为 [2.x.3629] 的成员变量。同样，编译器在知道哪个维度之前不能编译这个函数。如果你像上面那样为一个特定的维度调用这个函数，编译器将使用模板，用调用的维度替换所有出现的dim，并编译它。如果你为不同的维度多次调用该函数，它将多次编译，每次都调用正确的[2.x.3630]函数，并为成员变量保留适当的内存量；注意，[2.x.3631]的大小可能，事实上也确实取决于空间维度。




deal.II库是围绕这个独立于维度的编程概念建立的，因此允许你以一种不需要区分空间维度的方式来编程。应该注意的是，只有在极少数的地方才有必要使用[2.x.3632]es来实际比较尺寸。然而，由于编译器必须为每个维度单独编译每个函数，即使在那里，它在编译时也知道[2.x.3633]的值，因此将能够优化掉[2.x.3634]语句和未使用的分支。




在这个例子程序中，我们将展示如何独立编程维度（事实上，这比你必须照顾到维度还要简单），我们将把上一个例子的拉普拉斯问题扩展到一个同时在两个和三个空间维度运行的程序。其他的扩展是使用非恒定的右手边函数和非零边界值。




[2.x.3635] 在使用模板时，C++强加了各种语法限制，有时让人有点难以理解为什么到底要这样写。一个典型的例子是，在很多地方都需要使用关键字[2.x.3636]。如果你已经不完全熟悉，那么在[1.x.1425]中链接的deal.II常见问题解答（FAQ）中解释了其中的几个困难。

<！--我们需要一个空行来正确结束上述块。


examples/step-4/doc/results.dox



[1.x.1426]


程序的输出看起来如下（迭代次数可能会有一到两次的变化，这取决于你的计算机，因为这通常取决于浮点运算的舍入精度，而这在不同的处理器之间是不同的）。

[1.x.1427]

很明显，在三个空间维度中，单元格的数量，因此也是自由度的数量要高得多。这里看不到的是，除了矩阵中更多的行和列之外，在三个空间维度中，矩阵的每一行也有明显更多的条目。这就导致了解方程组时需要付出更多的数值努力，当你实际运行程序时，你可以从两个求解步骤的运行时间中感受到这一点。




该程序产生两个文件。  [2.x.3637]和[2.x.3638]，可以用VisIt或Paraview程序查看（如果你没有这些程序，你可以很容易地在程序中改变输出格式，使你更容易查看）。解决方案的可视化是一门艺术，但它也可以很有趣，所以你应该玩一玩你最喜欢的可视化工具，熟悉它的功能。下面是我想出的2D解决方案。

<p align="center"> [2.x.3639] [2.x.3640] 。

( [2.x.3641] 图片显示了所考虑的问题的解决方案，是一个三维图。可以看出，该解在域的内部几乎是平的，而在边界附近有较高的曲率。当然，这是因为对于拉普拉斯方程来说，解的曲率等于右手边，而右手边被选为四次多项式，在内部几乎为零，只有在接近域的边界时才急剧上升；右手边函数的最大值在域的角落，在那里解的移动也最迅速。很高兴看到解沿着域的边界遵循理想的二次边界值。将计算出的解与分析出的解进行验证也是很有用的。关于这一技术的解释，请参见步骤7。

另一方面，尽管图片中没有明确显示网格线，但你可以看到它们在解决方案中的小疙瘩。这清楚地表明，解决方案还没有被计算到非常高的精度，为了得到更好的解决方案，我们可能必须在更细的网格上进行计算。

在三个空间维度上，可视化就比较困难了。左图显示了解决方案和它在域的表面上计算出来的网格。这很好，但它的缺点是完全掩盖了内部的情况。右图是通过显示解的恒定值的表面（如左上角的图例所示），试图将内部的情况也可视化。如果我们把各个表面弄得稍微透明一些，这样就有可能透过它们看到后面的东西，那么等值面图片看起来就最好了。

[2.x.3642]

[2.x.3643] 关于可视化的最后一句话：可视化的想法是给人以洞察力，这与显示信息是不同的。特别是，在一张图片上很容易显示过多的信息，但在显示更多的信息的同时，也使人们更难收集到洞察力。举个例子，我用来生成这些图片的程序，VisIt，默认情况下在每个轴上都有刻度线，在[2.x.3644]轴上贴上一个大胖标签 "X轴"，其他轴也是如此，在左上方显示提取数据的文件名，在右下方显示用户的名字以及时间和日期。这些在这里都不重要：轴同样容易辨认，因为左下方的三脚架仍然可见，而且我们从程序中知道域是[2.x.3645]，所以不需要刻度线。因此，我关掉了图片中所有不相干的东西：可视化的艺术在于把图片缩减到那些对看清自己想看的东西很重要的部分，而不是其他。




[1.x.1428]

[1.x.1429]


基本上，玩这个程序的可能性与前一个程序相同，只是它们现在也适用于3D情况。为了获得灵感，请阅读[1.x.1430]。


examples/step-40/doc/intro.dox

[2.x.3646]

[1.x.1431]




[2.x.3647] 作为这个程序的前提条件，你需要同时安装PETSc和p4est库。在[1.x.1432]文件中描述了deal.II与这两个附加库的安装。还要注意的是，为了正常工作，本程序需要访问实现代数多网格的Hypre预处理程序包；它可以作为PETSc的一部分安装，但必须在配置PETSc时明确启用；参见PETSc安装说明中的链接页面。


[1.x.1433]

[1.x.1434]

[2.x.3648]

鉴于今天的计算机，大多数有限元计算可以在一台机器上完成。因此，以前的大多数教程程序只显示了这一点，可能是在一些处理器之间进行分工，但这些处理器都可以访问相同的共享内存空间。也就是说，有些问题对于单台机器来说实在是太大了，在这种情况下，必须以适当的方式将问题分割给多台机器，每台机器都为整体贡献自己的一部分。在第17步和第18步中展示了一个简单的方法，我们展示了一个程序如何使用[1.x.1435]来并行组装线性系统，存储它，解决它，并计算误差估计。所有这些操作的扩展都是相对微不足道的（关于操作 "扩展 "的定义，见[2.x.3649]"本词汇表条目"），但是有一个明显的缺点：为了使这个实现适度简单，每个MPI处理器都必须保留自己的整个Triangulation和DoFHandler对象的副本。因此，虽然我们可以怀疑（有充分的理由）上面列出的操作可以扩展到成千上万的计算机和数十亿个单元和数十亿个自由度的问题规模，但在每一个最后的处理器上为这成千上万的计算机所解决的整个问题建立一个大的网格显然是不能扩展的：这将需要永远，也许更重要的是没有一台机器会有足够的内存来存储一个有十亿个单元的网格（至少在写这篇文章时没有）。在现实中，像第17步和第18步这样的程序不可能在超过100或200个处理器上运行，即使在那里，存储Triangulation和DoFHandler对象也会消耗每台机器上的绝大部分内存。

因此，我们需要以不同的方式来处理这个问题：为了扩展到非常大的问题，每个处理器只能存储自己的一小块三角形和DoFHandler对象。deal.II在[2.x.3650]命名空间和其中的类中实现了这样一个方案。它建立在一个外部库上，[1.x.1436]（对表达式[1.x.1437]的发挥，描述了将分层构造的网格作为四叉树或八叉树的森林进行并行存储）。你需要[1.x.1438]，但除此之外，它的所有工作原理都隐藏在deal.II的表面之下。

本质上，[2.x.3651]类和DoFHandler类中的代码所做的是分割全局网格，使每个处理器只存储其 "拥有 "的一小部分，以及围绕其拥有的单元的一层 "幽灵 "单元。在我们想要解决偏微分方程的领域的其余部分发生了什么，对每个处理器来说都是未知的，如果需要这些信息，只能通过与其他机器的交流来推断。这意味着我们还必须以不同于例如第17步和第18步的方式来思考问题：例如，没有一个处理器可以拥有用于后处理的整个解矢量，程序的每一部分都必须被并行化，因为没有一个处理器拥有顺序操作所需的所有信息。

在[2.x.3652]文档模块中描述了这种并行化如何发生的一般概述。在阅读本程序的源代码之前，你应该先阅读它，以获得一个顶层的概述。在[2.x.3653]"分布式计算论文 "中也提供了关于我们将在程序中使用的许多术语的简明讨论。也许值得一读，以了解本程序内部如何工作的背景信息。




[1.x.1439]

这个程序基本上重新解决了我们在步骤6中已经做的事情，即它解决了拉普拉斯方程

[1.x.1440]

当然不同的是，现在我们要在一个可能有十亿个单元，有十亿个左右自由度的网格上这样做。毫无疑问，对于这样一个简单的问题，这样做是完全愚蠢的，但毕竟一个教程程序的重点不是做一些有用的东西，而是展示如何使用deal.II来实现有用的程序。尽管如此，为了使事情至少有一点点有趣，我们选择右侧为一个不连续的函数。

[1.x.1441]

使得解沿着蜿蜒穿过域的正弦线有一个奇点。因此，网格的细化将集中在这条线上。你可以在下面结果部分的网格图中看到这一点。

与其在这里继续做冗长的介绍，不如让我们直接进入程序代码。如果你已经读完了步骤6和[2.x.3654]文档模块，大部分将要发生的事情你应该已经熟悉了。事实上，比较这两个程序，你会发现在%parallel中工作所需的额外努力几乎是微不足道的：这两个程序的代码行数差不多（尽管步骤6在处理系数和输出方面花费了更多的空间）。在任何情况下，下面的评论将只针对使step-40与step-6不同的事情，而且在[2.x.3655]文档模块中还没有涵盖。




[2.x.3656] 这个程序将能够在你想扔给它的多少个处理器上进行计算，以及你有多少内存和耐心来解决多大的问题。然而，[1.x.1442]有一个限制：未知数的数量不能超过可以用类型[2.x.3657]的对象存储的最大数量。默认情况下，这是<code>unsigned int</code>的别名，在今天大多数机器上是一个32位的整数，限制了你大约40亿（实际上，由于这个程序使用PETSc，你将被限制在一半，因为PETSc使用有符号整数）。然而，这可以在配置过程中改变为使用64位整数，见ReadMe文件。这将使问题的大小在短期内不太可能超过。


examples/step-40/doc/results.dox



[1.x.1443]

当你在单个处理器上或在几个本地MPI安装上运行该程序时，你应该得到这样的输出。

[1.x.1444]



确切的数字是不同的，这取决于我们使用多少个处理器；这是由于预处理程序取决于问题的分区，然后解决方案在最后几位上有所不同，因此，网格细化也略有不同。不过，这里最值得注意的是，迭代次数并不随问题的大小而增加。这保证了我们甚至可以有效地解决最大的问题。

当在足够多的机器上运行时（比如说几千台），这个程序可以相对容易地在不到一分钟的时间内解决有远超过10亿个未知数的问题。另一方面，这样的大问题已经不能被视觉化，所以我们也只在16个处理器上运行该程序。下面是一个网格，以及它在16个处理器上的划分，还有相应的解决方案。

[2.x.3658]

左边的网格仅有7,069个单元。当然，这个问题我们在单台处理器上使用step-6就已经很容易解决了，但是这个程序的重点是展示如何编写一个可以扩展到更多机器的程序。例如，这里有两张图，显示了如果我们采取越来越多的处理器，程序的大量部分的运行时间是如何在大约5200万和37500万自由度的问题上扩展的（这些和接下来的几张图取自[2.x.3659]"分布式计算论文 "的早期版本；显示在更大数量的处理器上运行数据的更新图，以及更多的解释可以在该论文的最终版本中找到）。

[2.x.3660]

可以清楚地看到，这个程序可以很好地扩展到非常多的处理器。关于我们认为的 "可扩展 "程序的讨论，见[2.x.3661]"本词汇表条目"）。曲线，特别是线性求解器，在图形的右端变得有点摇摆不定，因为每个处理器要做的事情太少，无法抵消通信成本（在上面两个例子中，每个处理器要解决的整个问题的部分，在使用4,096个处理器时，只有13,000和90,000个自由度；一个好的经验法则是，如果每个处理器至少有100,000个未知数，并行程序就会运行良好）。

虽然上面的强扩展图显示，如果我们采取越来越多的处理器，我们可以越来越快地解决一个固定大小的问题，但更有趣的问题可能是，问题可以变得多大，以便在一个特定大小的机器上仍然可以在合理的时间内解决它们。我们在下面两张256和4096处理器的图中展示了这一点。

[2.x.3662]

这些图显示的是，程序的所有部分都随着自由度数的增加而线性扩展。这一次，由于局部问题的规模太小，线条在左边摇摆不定。关于这些结果的更多讨论，我们参考了[2.x.3663]"分布式计算论文"。

那么，一个人能够解决的最大问题是多大？在写这个问题的时候，限制因素是程序使用[1.x.1445]中的BoomerAMG代数多网格方法作为预处理程序，不幸的是，它使用有符号的32位整数来索引%分布式矩阵的元素。这将问题的大小限制在[2.x.3664]个自由度。从上面的图中可以看出，可扩展性会超过这个数字，而且可以预期，给定超过上面显示的4096台机器也会进一步减少计算时间。也就是说，人们当然可以期待，这个限制最终会被hybre的开发者解除。

另一方面，这并不意味着deal.II不能解决更大的问题。事实上，step-37展示了如何解决不仅仅是一点点，而是大大超过我们在这里所展示的任何问题的问题。




[1.x.1446]

[1.x.1447]

从某种意义上说，这个程序是拉普拉斯方程的终极解算器：只要你有足够的处理器，它基本上可以把方程解到你想要的精度。由于拉普拉斯方程本身在这种精度水平上并不十分有趣，因此，更有趣的扩展可能性不在于这个程序，而在于它之后的内容。例如，本教程中的其他几个程序都有相当长的运行时间，特别是在3D中。因此，使用这里解释的技术来扩展其他程序以支持并行的分布式计算将是有趣的。我们在step-32教程程序中对step-31做了这样的处理，但同样的做法也适用于，例如，用于双曲时间相关问题的step-23和step-25，用于气体动力学的step-33，或用于纳维-斯托克斯方程的step-35。

也许同样有趣的是后处理的问题。如上所述，我们只展示了16个处理器的解决方案和网格的图片，因为4,096个处理器解决10亿个未知数会产生几10G的图形输出。目前，除非在至少几百个处理器上运行，否则没有任何程序能够以任何合理的方式将如此大量的数据可视化。然而，有一些方法，可视化程序直接与每个处理器上的求解器进行通信，每个可视化进程渲染这个处理器上的求解器所计算的场景部分。实现这样的接口将允许快速可视化那些在其他方面不适合用图形显示的东西。


examples/step-41/doc/intro.dox

[2.x.3665]

[1.x.1448]


[1.x.1449]

[1.x.1450]

这个例子是基于二维的拉普拉斯方程，涉及的问题是，如果一个膜被一些外力偏转，但也被一个障碍物所限制，会发生什么。换句话说，想想一个弹性膜在边界处被夹在一个矩形框架上（我们选择[2.x.3666]），由于重力作用而下垂。如果膜下有一个障碍物，阻止它达到平衡位置，如果重力是唯一存在的力，现在会发生什么？在目前的例子程序中，我们将考虑在膜下有一个楼梯的障碍物，重力推着膜。

这个问题通常被称为 "障碍问题"（也见[1.x.1451]），它的结果是一个变分不等式，而不是变成弱形式的变分方程。下面我们将从经典的表述中推导出它，但在我们继续讨论数学问题之前，让我们展示一下我们在这个教程程序中要考虑的问题的解决方式，以获得一些我们应该期待的直觉。

[2.x.3667]

在这里，在左边，我们看到膜的位移。下面的障碍物的形状是清晰可见的。在右边，我们叠加了膜的哪些部分与障碍物接触。我们以后会把这组点称为 "活动集"，以表明这里有一个不等式约束在活动。




[1.x.1452]

该问题的经典表述具有以下形式。

[1.x.1453]

与[2.x.3668] 。   [2.x.3669] 是一个标量值函数，表示膜的垂直位移。第一个方程被称为平衡条件，有一个区域密度的力 [2.x.3670] 。这里，我们将考虑这个力是重力。第二个方程被称为胡克定律，即应力[2.x.3671]与位移[2.x.3672]的梯度成正比（比例常数，通常用[2.x.3673]表示，这里被设定为1，但不失一般性；如果它是常数，它可以被放入右边的函数）。在边界，我们有零迪里希特条件。很明显，前两个方程可以结合起来，得到[2.x.3674] 。

直观地说，重力是向下作用的，所以[2.x.3675]是一个负函数（我们在这个程序中选择[2.x.3676]）。那么，第一个条件意味着作用在膜上的总力是重力加上一些正值：即障碍物在它们两个接触的地方对膜施加的向上的力。这个额外的力有多大？我们还不知道（我们也不知道它实际作用的 "位置"），但它必须是使膜不穿透障碍物的。

上面的第四个等式和最后一个不等式构成了障碍条件，它必须在整个领域的每一点都成立。这两个条件中的后者意味着膜必须在任何地方都高于障碍物[2.x.3677]。倒数第二个方程，通常被称为 "互补条件"，说的是在膜不与障碍物接触的地方（即那些[2.x.3678]的地方[2.x.3679]），那么[2.x.3680]在这些地方；换句话说，没有额外的力作用在那里，如预期的那样。另一方面，在[2.x.3681]的地方，我们可以有[2.x.3682]，也就是说，可以有额外的力（尽管不一定要有：膜有可能只是接触而不是压住障碍物）。




[1.x.1454]

获得障碍物问题的变量表述的一个明显方法是考虑总势能。

[1.x.1455]

我们必须找到以下最小化问题的解决方案[2.x.3683]。

[1.x.1456]

与可接受位移的凸集。

[1.x.1457]

这组数据照顾到了上述第三和第五个条件（边界值和互补条件）。

现在考虑[2.x.3685]的最小化器[2.x.3684]和任何其他函数[2.x.3686] 。那么函数

[1.x.1458]

在[2.x.3687]处取最小值（因为[2.x.3688]是能量函数[2.x.3689]的最小值），因此，对于[2.x.3691]的任何选择，[2.x.3690]。请注意，[2.x.3692] 因为[2.x.3693] 的凸性。如果我们计算[2.x.3694]，就可以得到我们要寻找的变异公式。

[1.x.1459]

[1.x.1460]



这是变分不等式的典型形式，不仅仅是[2.x.3695]出现在双线性形式中，实际上还有[2.x.3696] 。原因是这样的：如果[2.x.3697]不受约束，那么我们可以在[2.x.3699]中找到测试函数[2.x.3698]，从而使[2.x.3700]可以有任何符号。通过选择测试函数[2.x.3701]使[2.x.3702]，可以看出，只有当两边事实上相等时，不等式才能对[2.x.3703]和[2.x.3704]都成立，也就是说，我们得到一个变异的相等。

另一方面，如果[2.x.3705]，那么[2.x.3706]只允许测试函数[2.x.3707]，所以实际上[2.x.3708] 。这意味着我们不能像上面那样用[2.x.3709]和[2.x.3710]来测试这个方程，所以我们不能再得出两边实际上相等的结论。因此，这就模仿了我们上面讨论互补性条件的方式。




[1.x.1461]

上面的变分不等式在工作中是很尴尬的。因此，我们想把它重新表述为一个等价的鞍点问题。我们引入拉格朗日乘子[2.x.3711]和拉格朗日乘子[2.x.3712]、[2.x.3713]的凸锥[2.x.3714]、[2.x.3715]的对偶空间，其中[2.x.3716]表示[2.x.3717]和[2.x.3718] 之间的对偶性。直观地说，[2.x.3719]是所有 "非正函数 "的锥体，除了[2.x.3720]，所以也包含了除正函数之外的其他对象。这就产生了。

[1.x.1462]

[1.x.1463]

[1.x.1464]

[1.x.1465]

换句话说，我们可以把[2.x.3721]看作是障碍物对膜施加的额外正力的负数。上面陈述的第二行中的不等式似乎只有错误的符号，因为我们在[2.x.3723]的地方有[2.x.3722]，鉴于[2.x.3724]的定义。

Glowinski, Lions and Tr&eacute;moli&egrave;res.中阐述了这个鞍点问题[2.x.3725]的存在性和唯一性。Numerical Analysis of Variational Inequalities, North-Holland, 1981.




[1.x.1466]

有不同的方法来解决变量不等式。作为一种可能性，你可以把鞍点问题理解为一个带有不等式约束的凸二次方程序（QP）。

为了达到这个目的，让我们假设我们用相同的有限元空间来离散[2.x.3726]和[2.x.3727]，例如通常的[2.x.3728]空间。然后我们会得到方程

[1.x.1467]

其中[2.x.3729]是所选有限元空间上的质量矩阵，上面的指数[2.x.3730]是针对位于域内部的自由度集合[2.x.3731]中的所有自由度（我们在周边有迪里希条件）。然而，如果我们在组合产生这个质量矩阵的所有项时使用一个特殊的正交规则，即一个正交公式，其中正交点只位于定义了形状函数的插值点；因为除了一个形状函数外，所有的形状函数在这些位置都是零，所以我们得到一个对角线质量矩阵，具有

[1.x.1468]

为了定义[2.x.3732]，我们使用与[2.x.3733]相同的技术。换句话说，我们定义

[1.x.1469]

其中[2.x.3734]是[2.x.3735]的一个合适的近似值。然后，[2.x.3736]和[2.x.3737]定义中的积分由梯形规则近似。有了这个，上面的方程可以重述为

[1.x.1470]



现在我们为每个自由度[2.x.3738]定义函数

[1.x.1471]

在这个程序中，我们选择[2.x.3739]。这是一种惩罚参数，取决于问题本身，需要选择足够大的参数；例如，如果我们使用7个全局细化，使用当前程序对[2.x.3741]没有收敛作用）。)

经过一番挠头，人们可以说服自己，上面的不等式可以等效地改写为

[1.x.1472]

我们在这里将使用的原始-双重主动集策略是一个迭代方案，它基于这个条件来预测下一个主动集和非主动集[2.x.3742]和[2.x.3743]（即那些指数[2.x.3744]的互补集，对于这些指数[2.x.3745]要么等于要么不等于障碍物的值[2.x.3746] ）。关于这种方法的更深入的处理，见Hintermueller, Ito, Kunisch:The primal-dual active set strategy as a semismooth newton method, SIAM J. OPTIM., 2003, Vol.13, No.3, pp.865-888.

[1.x.1473]

初级-二级主动集方法的算法工作原理如下（注：[2.x.3747] ）。

1.初始化 [2.x.3748] 和 [2.x.3749] ，使 [2.x.3750] 和 [2.x.3751] 并设置 [2.x.3752] 。2.找出满足[1.x.1474]的原始-双数对[2.x.3753]。

请注意，第二个和第三个条件意味着正好[2.x.3754]个未知数是固定的，第一个条件产生了确定[2.x.3756]和[2.x.3757]所需的剩余[2.x.3755]个方程。3.3. 用[1.x.1475]定义新的活动和非活动集。

如果[2.x.3758]（然后，显然也是[2.x.3759]），则停止，否则设置[2.x.3760]并转到步骤（2）。

该方法被称为 "原始-双重"，因为它同时使用原始变量（位移[2.x.3761]）以及双重变量（拉格朗日乘数[2.x.3762]）来确定下一个活动集。

在本节的最后，让我们补充两点意见。首先，对于任何满足这些条件的原始-双重对[2.x.3763]，我们可以区分以下几种情况。

1.  [2.x.3764] (i active)。    [2.x.3765] 然后是[2.x.3766]和[2.x.3767]（渗透）或[2.x.3768]和[2.x.3769]（压载）。2.  [2.x.3770] (i不活动)。    [2.x.3771] 然后是[2.x.3772]和[2.x.3773]（无接触）或[2.x.3774]和[2.x.3775]（无压迫负荷）。

第二，上面的方法在直觉上似乎是正确的，也是有用的，但有点临时性的。然而，它可以通过以下方式简明地推导出来。为此，请注意，我们要解决的是非线性系统

[1.x.1476]

我们可以通过始终围绕前一个迭代进行线性化（即应用牛顿方法）来迭代解决，但为此我们需要对不可微分的函数[2.x.3776]进行线性化。也就是说，它是可微的，事实上我们有

[1.x.1477]



[1.x.1478]

这表明一个半光滑的牛顿步骤，其形式为

[1.x.1479]

其中，我们将矩阵 [2.x.3777] 以及向量以自然的方式分成行和列，其索引属于活动集 [2.x.3778] 或非活动集 [2.x.3779] 。

我们也可以通过设置[2.x.3781]和[2.x.3782]并将所有已知项带到右手边来解决我们感兴趣的变量，而不是求解更新[2.x.3780] 。这就得到了

[1.x.1480]

这些是上文描述基本算法时概述的方程式。

我们甚至可以进一步推动这一点。很容易看出，我们可以消除第三行和第三列，因为它意味着[2.x.3783] 。

[1.x.1481]

这表明，事实上我们只需要解决位于活动集上的拉格朗日乘数。通过考虑第二行，我们将通过以下方式恢复全部拉格朗日乘数向量

[1.x.1482]

由于第三行和[2.x.3784]是一个对角线矩阵的事实，我们能够直接计算出[2.x.3785]。因此，我们也可以把线性系统写成如下。

[1.x.1483]

幸运的是，这种形式很容易得出：我们只需建立通常的拉普拉斯线性系统即可

[1.x.1484]

然后让AffineConstraints类消除所有受限自由度，即[2.x.3786]，其方式与[2.x.3787]中的自由度是Dirichlet数据一样。结果线性系统（上面的第二个到最后一个）是对称和正定的，我们用CG方法和Trilinos的AMG预处理程序来解决它。




[1.x.1485]

本教程与第4步很相似。程序的总体结构遵循步骤4，但略有不同。

- 我们需要两个新的方法， [2.x.3788] 和 [2.x.3789] 。

- 我们需要新的成员变量来表示我们这里的约束。

- 我们改变求解器的预处理程序。


如果你想了解目前的计划，你可能想阅读一下步骤4。


examples/step-41/doc/results.dox



[1.x.1486]

运行该程序会产生这样的输出。

[1.x.1487]



一旦活动集不再变化，迭代就会结束（此时它有5399个受限自由度）。代数前提条件显然工作得很好，因为我们只需要4-6次CG迭代来解决线性系统（尽管这也与我们对线性求解器的精度要求不高有很大关系）。

更具启示性的是看一连串的图形输出文件（每三步显示一次，最左边一栏是迭代的编号）。

[2.x.3790]

图片显示，在第一步中，解决方案（在没有任何约束条件的情况下被计算出来的）是如此的弯曲，以至于几乎每一个内部点都必须被反弹到阶梯函数上，产生一个不连续的解决方案。在活动集迭代的过程中，这种不切实际的膜的形状被平滑掉了，与最下层阶梯的接触消失了，解决方案也稳定下来。

除此以外，程序还输出拉格朗日乘数的值。请记住，这些是接触力，所以在接触集上只应该是正的，而在接触集之外是零。另一方面，如果一个拉格朗日乘数在活动集上是负的，那么这个自由度必须从活动集上删除。下面的图片显示了迭代1、9和18中的乘数，我们用红色和棕色表示正值，蓝色表示负值。

[2.x.3791]

很容易看出，正值在接触集的内部很好地收敛为适度的值，在台阶的边缘有很大的向上的力，正如人们所期望的那样（以支持那里的膜的大曲率）；在活动集的边缘，乘数最初是负的，导致集合缩小，直到在迭代18，不再有负的乘数，算法已经收敛了。




[1.x.1488]

[1.x.1489]

与本教程的任何程序一样，有许多明显的扩展和实验的可能性。第一个很清楚：引入自适应性。接触问题是自适应网格的主要候选者，因为解决方案有沿着它不太规则的线（膜和障碍物之间建立接触的地方）和解决方案非常光滑的其他区域（或者，在目前的情况下，在它与障碍物接触的地方是恒定的）。在目前的程序中加入这一点应该不会造成太多困难，但要为此找到一个好的误差估计器并非易事。

一个更具挑战性的任务是扩展到3D。这里的问题不是简单地让一切都在三维中运行。相反，当一个三维物体变形并与一个障碍物接触时，障碍物并不像这里的情况那样在域内作为一个约束体的力量发挥作用。相反，接触力只作用于物体的边界。那么不等式就不在微分方程中，而实际上在（诺伊曼型）边界条件中，尽管这导致了一种类似的变分不等式。在数学上，这意味着拉格朗日乘数只存在于表面，当然，如果方便的话，它也可以通过零扩展到域中。在目前的程序中，人们不需要明确地形成和存储这个拉格朗日乘数。

对于三维案例来说，另一个有趣的问题是考虑有摩擦的接触问题。在几乎每个机械过程中，摩擦都有很大的影响。为了建模，我们必须考虑到接触面的切向应力。我们还必须注意到，摩擦给我们的问题增加了另一个非线性。

另一个不简单的修改是实现一个更复杂的构成法则，如非线性弹性或弹塑性材料行为。这里的困难在于如何处理通过非线性构成法产生的额外非线性。


examples/step-42/doc/intro.dox

[2.x.3792]

[1.x.1490][1.x.1491] 。




[1.x.1492]

[1.x.1493]

这个例子是第41步的延伸，考虑的是三维接触问题，具有各向同性硬化的弹塑性材料行为。换句话说，它考虑的是，如果把一个刚性的障碍物推到一个三维体上，它是如何变形的（接触问题），其中的变形受弹塑性材料法则（一种只能容纳一定最大应力的材料）的制约，随着变形的累积，该材料会硬化。为了说明我们打算做什么，在讨论太多细节之前，让我们只展示一张解决方案的图片（可变形体是一个立方体--实际上只显示了一半--，障碍物对应于一个汉字，将在下面讨论）。

[2.x.3793]


这个问题的描述意味着，与第41步相比，我们必须照顾到一个额外的非线性因素：材料行为。由于我们在这里考虑的是一个三维问题，我们还必须考虑到一个事实，即现在接触区是在可变形体的边界，而不是在内部。最后，与第41步相比，我们还必须在处理线性系统和不等式约束时处理悬空节点，因为我们希望使用自适应网格；在后一种情况下，我们将不得不处理优先考虑悬空节点的约束还是不等式的约束更重要。

由于在三维空间中很容易达到几百万个自由度，即使使用自适应网格细化，我们决定使用Trilinos和p4est来并行运行我们的代码，在步骤40的框架上进行并行化。并行化的其他指针可以在步骤32中找到。




[1.x.1494]

该问题的经典表述具有以下形式。

[1.x.1495]

这里，这些方程的第一个定义了应变[2.x.3794]和应力[2.x.3795]之间的关系，通过四阶顺应性张量[2.x.3796]；[2.x.3797]提供了应变的塑性成分，确保应力不超过屈服应力。我们将只考虑各向同性的材料，对于这些材料，[2.x.3798]可以用Lam&eacute;模量[2.x.3799]和[2.x.3800]表示，或者用体模量[2.x.3801]和[2.x.3802]表示。第二个方程是力的平衡；我们在此不考虑任何体力，并假定[2.x.3803] 。第三行的互补条件意味着，如果[2.x.3805]，则[2.x.3804]，但当且仅当[2.x.3807]，[2.x.3806]可能是一个非零张量，特别是在这种情况下，[2.x.3808]必须指向[2.x.3809]的方向。不等式[2.x.3810]是塑性材料只能支持有限的应力；换句话说，如果外力会导致[2.x.3812]的应力，那么它们就会产生塑性变形[2.x.3811]的反应。这种[1.x.1496]的典型形式是[2.x.3814]，其中[2.x.3815]是张量的偏离部分，[2.x.3816]表示弗罗本尼斯规范。

进一步的方程描述了[2.x.3817]上固定的零位移，在可能出现接触的表面[2.x.3818]上，障碍物施加的法向力[2.x.3819]是向内的（障碍物对我们的身体没有 "拉力"），切向分量为零[2.x.3820] 。最后一个条件又是一个互补条件，意味着在[2.x.3821]上，只有当身体与障碍物接触时，法向力才能非零；第二部分描述了障碍物和身体的不可穿透性。最后两个方程通常被称为Signorini接触条件。

大多数材料--尤其是金属--都有这样的特性，即它们在变形时表现出一定的硬化。换句话说，[2.x.3822]随着变形而增加。在实践中，导致硬化的不是弹性变形，而是塑性成分。有不同的构成法则来描述这些材料行为。最简单的称为线性各向同性硬化，由流动函数 [2.x.3823] 描述。




[1.x.1497]

一般来说，处理不等式是相当笨拙的。在这里，我们必须处理两个问题：塑性和接触问题。正如本页顶部提到的论文中详细描述的那样，我们至少可以重新表述塑性，使其看起来像一个非线性，然后我们可以用牛顿方法处理。这在数学上略显棘手，因为非线性不只是一些平滑的函数，而是在应力达到屈服应力的地方有结点；然而，对于这样的[1.x.1498]函数，可以证明牛顿方法仍然收敛。

在不涉及细节的情况下，我们也将摆脱作为独立变量的应力，而完全用位移来工作 [2.x.3824] 。最终，这种重构的目标是，我们希望最终得到一个对称的、正定的问题--比如一个线性化的弹性问题，其空间变量系数由塑性行为产生--需要在每个牛顿步骤中解决。我们希望如此，因为有高效和可扩展的方法来解决这样的线性系统，如用代数多重网格的CG预处理。这与我们继续使用包含位移和应力的混合公式所得到的类似于混合拉普拉斯的鞍点问题（见第20步）是相反的，第20步已经提示了构建良好的求解器和预处理器是多么困难。

说到这里，让我们简单陈述一下我们在重构后得到的问题（同样，细节可以在论文中找到）。找到一个位移[2.x.3825]，以便

[1.x.1499]

其中投影仪[2.x.3826]被定义为

[1.x.1500]

和空间[2.x.3827]是满足接触条件的所有位移的空间。

[1.x.1501]



在实际代码中，我们将使用缩写 [2.x.3828] 。

鉴于这种表述，我们将应用两种技术。

- 运行牛顿方法来迭代出投影仪的非线性。

- 为接触条件运行一个主动设置方法，方法与我们在步骤41中所做的基本相同。

一个严格的方法是在我们迭代牛顿方法到收敛时保持活动集的固定（或者也许反过来：在进入下一个牛顿迭代之前找到最终的活动集）。在实践中，事实证明，每个活动集迭代只做一个牛顿步骤就足够了，所以我们将同时迭代它们。我们还将每隔一段时间细化一下网格。




[1.x.1502]

如前所述，我们将通过应用牛顿方法来处理算子[2.x.3829]的非线性，尽管该算子在严格意义上是不可微的。然而，它满足了[1.x.1503]的可微条件，这就足以使牛顿方法发挥作用。由此产生的方法被称为[1.x.1504]，听起来令人印象深刻，但实际上只是一个牛顿方法应用于一个具有适当选择的 "导数 "的半光滑函数。

在目前的情况下，我们将通过在每个迭代[2.x.3830]中求解以下方程来运行我们的迭代（仍然是不等式，但是线性化）。

[1.x.1505]

其中，等级4张量[2.x.3831]由以下公式给出

[1.x.1506]

这个张量是[2.x.3832]围绕[2.x.3833]的（形式）线性化。对于我们这里考虑的线性各向同性材料，投影仪的体积和剪切分量由以下公式给出

[1.x.1507]

其中[2.x.3834]和[2.x.3835]分别是等级为2和4的认同张量。

请注意，这个问题对应于线性弹性接触问题，其中[2.x.3836]扮演弹性张量的角色 [2.x.3837] 。事实上，如果材料在某一点上没有塑性，那么[2.x.3838] 。然而，在材料具有塑性的地方，[2.x.3839]是一个空间变化的函数。在任何情况下，我们必须解决牛顿迭代的系统[2.x.3840]使我们更接近重写我们问题的目标，使我们能够使用众所周知的椭圆系统的求解器和预处理器。

作为对牛顿方法的最后说明，让我们提一下，正如牛顿方法常见的那样，我们需要通过控制步长来使其全球化。换句话说，虽然上面的系统求解的是[2.x.3841]，但最后的迭代结果将是

[1.x.1508]

其中右边括号中的差值扮演了传统牛顿方向的角色，[2.x.3842] 。我们将用标准的直线搜索来确定[2.x.3843]。




[1.x.1509]

这个要在每个牛顿步骤中解决的线性化问题基本上与步骤41一样。唯一的区别在于接触区是在边界而不是在域中。但这没有进一步的后果，所以我们参考步骤41的文件，唯一的提示是[2.x.3844]这次包含了接触边界的所有顶点[2.x.3845]。和那里一样，我们需要做的是保持一个自由度子集的固定，导致额外的约束，可以写成一个鞍点问题。然而，正如论文中所讨论的，通过以适当的方式写这些约束，消除自由度之间的耦合，我们最终会得到一组节点，这些节点基本上只是附加了Dirichlet值。




[1.x.1510]

上述算法结合了阻尼半光滑牛顿法（我们用于非线性构成法）和半光滑牛顿法用于接触。它的工作原理如下。<ol> [2.x.3846] 初始化活动和非活动集[2.x.3847]和[2.x.3848]，使[2.x.3849]和[2.x.3850]和集[2.x.3851] 。这里，[2.x.3852]是位于可能发生接触的域的表面的所有自由度的集合。  起始值[2.x.3853]满足我们的障碍条件，也就是说，我们将初始零位移投射到可行位移集合上。

  [2.x.3854] 组装牛顿矩阵 [2.x.3855] 和右侧 [2.x.3856] 。  这些对应于线性化的牛顿步骤，暂时忽略了接触不等式。

  [2.x.3857] 找到满足[1.x.1511]的原始-双数对[2.x.3858] 。

如同步骤-41，我们可以通过消除第一个方程中[2.x.3859]的那些自由度来获得这个问题的解决方案，并获得一个线性系统[2.x.3860] 。




  [2.x.3861] 通过应用直线搜索和计算[2.x.3863]和[2.x.3864]的线性组合来减弱[2.x.3862]的牛顿迭代。这需要找到一个[2.x.3865]，以便[1.x.1512]。

满足[1.x.1513]与[2.x.3866]，除了(i)元素[2.x.3867]，我们设置[2.x.3868]，和(ii)对应于悬挂节点的元素，我们以通常方式消除。

  [2.x.3869] 通过[1.x.1514]定义新的活动和非活动集。

[1.x.1515]



  [2.x.3870]项目[2.x.3871]，使其满足接触不等式，[1.x.1516] 。

这里，[2.x.3872]是[2.x.3873]中的活性成分对间隙[1.x.1517]的投影。

其中[2.x.3874]是[1.x.1518]，表示障碍物与身体未位移配置的距离。

  [2.x.3875] 如果[2.x.3876]和[2.x.3877]则停止，否则设置[2.x.3878]并转到步骤（1）。这一步确保我们只有在找到正确的活动集和塑性已经迭代到足够的精度时才停止迭代。  [2.x.3879]

在这个算法的第3步中，矩阵[2.x.3880], [2.x.3881]描述了位移和拉格朗日乘数（接触力）的基数的耦合，在我们的情况下它不是二次的，因为[2.x.3882]只定义在[2.x.3883]，即可能发生接触的面。如文中所示，我们可以选择[2.x.3884]是一个每行只有一个条目的矩阵，（另见H&uuml;eber, Wohlmuth:A primal-dual active set strategy for non-linear multibody contact problems, Comput.Method Appl. Mech.Engrg.194, 2005, pp.3147-3166）。)矢量[2.x.3885]是由间隙[2.x.3886]的合适近似值定义的。

[1.x.1519]






[1.x.1520]

由于我们的程序是在三维空间中运行的，所以程序执行的计算很昂贵。因此，使用自适应网格细化是在可接受的运行时间内的一个重要步骤。为了使我们的生活更轻松，我们简单地选择已经在deal.II中实现的KellyErrorEstimator。我们把包含位移[2.x.3888]的解向量交给它。正如我们将在结果中看到的，它产生了一个相当合理的接触区和塑性的自适应网格。




[1.x.1521]

本教程实质上是步骤40和步骤41的混合体，但我们没有使用PETSc，而是让Trilinos库来处理线性代数的并行化问题（就像步骤32一样）。由于我们试图解决一个类似于步骤41的问题，我们将使用同样的方法，但现在是并行的。

一个困难是处理来自Dirichlet条件的约束，悬挂节点和由接触产生的不平等条件。为此，我们创建了三个AffineConstraints类型的对象，它们描述了各种约束条件，我们将在每次迭代中适当地组合它们。

与第41步相比，该计划有一些新的课程。

[2.x.3889] [2.x.3890] [2.x.3891] 描述材料的塑性行为。

[2.x.3892] [2.x.3893]描述一个球体，作为被推入可变形弹性体的障碍物。   是用这个还是下一个类来描述障碍物，由输入参数文件决定。

[2.x.3894] [2.x.3895]（和一个辅助类）是一个允许我们从一个文件中读入障碍物的类。在我们将在结果部分展示的例子中，这个文件将是[2.x.3896]，并对应于显示力或力量的中文、日文或韩文符号的数据（见http://www.orientaloutpost.com/："这个词可用于激励--它也可以指力量/运动/推进/力。它可以是任何使你继续前进的内部或外部事物。这是用中文表达动机的最安全方式。如果你的听众是日本人，请看另一个关于动机的条目。这是日语和韩语中的一个词，但它的意思是 "动力 "或 "动能"（没有你可能正在寻找的动机的意思）"）。实质上，我们将假装有一个印章（即对应于平底障碍物的面具，没有中间高度的碎片），我们把它压在身体里。有关的符号看起来如下（也可参见本节顶部的图片，了解最终结果是怎样的）。

   [2.x.3897] [2.x.3898]。

除此以外，让我们只对以下方面进行评论。  [2.x.3899] [2.x.3900] 程序允许你通过参数文件从两个不同的粗略网格中进行选择。这些是立方体[2.x.3901]或半球体，其开放面朝向正[2.x.3902]方向。

[2.x.3903]在这两种情况下，我们将假设可能与障碍物接触的边界部分具有边界指标一的惯例。对于这两种网格，我们假定这是一个自由表面，即身体要么在那里接触，要么没有力作用在它身上。对于半球体，弯曲部分的边界指标为零，我们在那里施加零位移。对于盒子，我们沿底部施加零位移，但允许沿边的垂直位移（尽管没有水平位移）。  [2.x.3904]


examples/step-42/doc/results.dox



[1.x.1522]

包含这个程序的目录还包含一些输入参数文件，可以用来创建各种不同的模拟。例如，用[2.x.3905]参数文件（用球作为障碍物，用盒子作为领域）在16个核心上运行该程序会产生这样的输出。

[1.x.1523]



每个周期结束时的表格显示了最近一次网格细化周期的计算时间（这些数字当然是针对产生该输出的机器而言的）和程序不同部分的调用次数，如装配或计算残差。上面的一些数字可以通过将解决方案从一个网格转移到下一个网格来改善，我们在这里没有行使这个选项。当然，你也可以通过使用更多的处理器来使程序运行得更快，特别是在后期的细化周期中：附带的论文显示，至少有1000个内核的良好扩展性。

在一个典型的运行中，你可以看到，对于每一个细化步骤，活动集--接触点--首先被迭代出来。之后，牛顿方法只需要解决塑性问题。对于更细的网格，在最后4或5次牛顿迭代中可以看到二次收敛。

我们不会在这里详细讨论每个输入文件的情况。相反，让我们只展示解决方案的图片（如果单元格的正交点为零，塑性不等式处于活动状态，则域的左半部分被省略）。

[2.x.3906]

图中显示了适应性细化以及细胞在与球接触过程中的塑化程度。请记住，我们考虑每个正交点的应力偏差部分的规范，以查看是否有弹性或塑性行为。蓝色意味着这个单元只包含弹性正交点，与所有正交点都被塑化的红色单元相反。在顶面的中间--网格最细的地方--非常仔细地看可以看到由障碍物引起的凹陷。这是[2.x.3907]函数的结果。然而，由于我们在这里考虑的障碍物的压痕非常小，所以很难辨别这种效果；我们可以玩玩将网格的顶点按计算出的位移的倍数进行位移。

关于使用该程序可以获得的结果的进一步讨论，见本页面最上方提到的出版物。


[1.x.1524]

[1.x.1525]

像往常一样，有多种可能性来扩展这个程序。从算法的角度来看，这个程序在写作时已经达到了我们所能达到的程度，使用了接触不等式、塑性非线性和线性求解器的最佳可用算法。然而，就更现实的情况而言，人们希望用这个程序做一些事情。  [2.x.3908] [2.x.3909] 将程序从静态扩展到准静态情况，也许可以通过选择后向欧拉模式来实现时间离散化。一些理论结果可以在Jörg Frohne的博士论文中找到，[1.x.1526]，德国锡根大学，2011。

[2.x.3910]考虑有摩擦力的接触问题也将是一个有趣的进步。在几乎每个机械过程中，摩擦都有很大的影响。  为了模拟这种情况，我们必须考虑到接触面的切向应力。摩擦也给我们的问题增加了另一个不等式，因为只要切向应力不超过某个极限，身体和障碍物通常会粘在一起，超过这个极限，两个身体就会互相滑过。

[2.x.3911] 如果我们已经模拟了摩擦性接触，下一步要考虑的是接触区的发热。由两个物体之间的摩擦引起的热量会提高可变形物体的温度，并导致一些材料参数的变化。

[2.x.3912] 对于接触以及塑性，实施更精确的、与问题相适应的误差估计器可能是有意义的。  [2.x.3913]


examples/step-43/doc/intro.dox

[2.x.3914]

[1.x.1527]


[1.x.1528][1.x.1529] 。

多孔介质中的多相流模拟是一个无处不在的问题，我们以前在步骤20和步骤21中已经以某种形式解决了这个问题。然而，正如在那里很容易看到的那样，它面临两个主要困难：数值精度和效率。第一个问题在第20步的静止求解器中很容易看到：使用最低阶的Raviart-Thomas元素不可能产生高度精确的解决方案。我们需要更精确的方法。第二个原因从时间相关的步骤-21中可以看出：该程序慢得令人发指，没有希望在合理的时间范围内得到高度准确的三维解。

在这个项目中，为了克服这两个问题，有五个方面我们正在努力改进，以实现高性能的模拟器。

[2.x.3915] [2.x.3916] 高阶空间离散 [2.x.3917] 自适应网格细化 [2.x.3918] 自适应时间步进 [2.x.3919] 运算器分割 [2.x.3920] 高效求解器和预处理 [2.x.3921]

这个计划的大部分灵感来自第31步，但这里讨论的几个技术是原创的。




[1.x.1530]

我们考虑的是两相不相溶的不可压缩流体的流动。毛细管和重力效应被忽略了，粘性效应被假定为主导。这种流动的管理方程与步骤21中使用的方程相同，为

[1.x.1531]

其中[2.x.3922]是第二（润湿）相的饱和度（体积分数在零和一之间），[2.x.3923]是压力，[2.x.3924]是渗透率张量，[2.x.3925]是总流动性，[2.x.3926]是孔隙度，[2.x.3927]是湿润相的分流量，[2.x.3928]是源项，[2.x.3929]是总速度。总流动性、润湿相的部分流量和总速度分别由以下公式给出

[1.x.1532]

其中下标[2.x.3930]分别代表湿润和非湿润阶段。

为方便起见，饱和度方程中的孔隙度[2.x.3931]可被视为时间变量的比例系数，被设定为1。根据相对渗透率[2.x.3932]和[2.x.3933]对饱和度的依赖性的常用规定，我们用

[1.x.1533]



上面的多孔介质方程由饱和度的初始条件和压力的边界条件来补充。由于饱和度和压力梯度唯一地决定了速度，所以速度的边界条件是没有必要的。由于流动方程不包含时间导数，因此不需要速度和压力变量的初始条件。流场将边界分为流入或流出部分。具体来说。

[1.x.1534]

我们通过在流入边界上施加饱和变量的边界值，得出一个完整的模型 [2.x.3934] 。




[1.x.1535]

从第21步可以看出，一旦我们知道了流量变量，求解速度和压力的流量方程是程序中花费时间远大于饱和度变量的（明确）更新步骤的部分。另一方面，压力和速度对饱和度的依赖性很弱，因此可以考虑每隔几步只求解压力和速度，而每步更新饱和度。如果我们能找到一个关于何时需要更新流量变量的标准，我们把这种拆分称为 "自适应算子拆分 "方案。

在这里，我们使用以下后验标准来决定何时重新计算压力和速度变量（详细的推导和描述可以在[Chueh, Djilali and Bangerth 2011]中找到）。

[1.x.1536]

其中括号内的上标表示定义任何数量的饱和时间步数，[2.x.3935]代表我们实际计算压力和速度的最后一步。如果[2.x.3936]超过某个阈值，我们就重新计算流量变量；否则，我们在时间步骤[2.x.3937]中跳过这个计算，只将饱和变量向前移动一个时间步骤。

简而言之，该算法允许我们执行若干长度为[2.x.3938]的饱和时间步长，直到上述标准告诉我们重新计算速度和压力变量，导致一个长度为

[1.x.1537]

我们根据Courant-Friedrichs-Lewy（CFL）限制来选择（微型）步骤的长度，标准是

[1.x.1538]

我们已经证实，对于下面讨论的饱和方程的有限元和时间步长方案的选择是稳定的（[2.x.3939]表示单元[2.x.3940]的直径）。其结果是一个方案，微观和宏观的时间步长都不统一，两者都是自适应选择。

[1.x.1539] 利用这种时间离散化，我们从IMPES方法中得到每个时间步骤的以下方程组（见步骤21）。

[1.x.1540]




利用[2.x.3941]这一事实，时间离散的饱和度方程变为

[1.x.1541]



[1.x.1542]

通过将定义总速度的方程[2.x.3942]和用源项表示其发散的方程分别与测试函数[2.x.3943]和[2.x.3944]相乘，然后根据需要进行分项积分，问题的弱形式为。找出[2.x.3945]，以便对所有测试函数[2.x.3946]而言，存在

[1.x.1543]

这里，[2.x.3947]代表[2.x.3948]的单位外向法向量，压力[2.x.3949]可以在边界[2.x.3950]的开放部分弱化规定，而在那些规定了速度的部分（例如具有[2.x.3951]的不渗透边界，该术语完全消失了，因为[2.x.3952] 。

我们使用连续有限元来离散速度和压力方程。具体来说，我们使用混合有限元来确保同时对矢量变量（如流体速度）和标量变量（如压力）进行高阶逼近。对于鞍点问题，公认的是需要满足所谓的Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件[Brezzi 1991, Chen 2005]以确保压力-速度系统的稳定性。在本工作中，通过使用比压力高一阶的速度元素，即[2.x.3953]和[2.x.3954]来满足这些稳定性条件，其中[2.x.3955]，[2.x.3956]是空间维度，[2.x.3957]表示每个变量的张量积Lagrange多项式的空间[2.x.3958]。

[1.x.1544]为饱和方程选择的[2.x.3959]元素在没有上卷或其他类型的稳定化的情况下不会导致稳定的离散化，并且在数值解中会出现虚假的震荡。添加一个人工扩散项是消除这些振荡的一种方法[Chen 2005]。另一方面，添加过多的扩散项会在解中涂抹出尖锐的锋面，并且会出现网格定向困难[Chen 2005]。为了避免这些影响，我们使用了由[Guermond和Pasquetti 2008]提出并在[Chueh, Djilali, Bangerth 2011]和[Kronbichler, Heister and Bangerth, 2011]以及步骤31中验证的人工扩散项。

这种方法修改了饱和度方程的（离散）弱形式，改为

[1.x.1545]

其中[2.x.3960]是人工扩散参数，[2.x.3961]是域的边界上适当选择的数值通量（我们为此选择明显的全上风通量）。

根据[Guermond and Pasquetti 2008]（以及[Chueh, Djilali and Bangerth 2011]中的详细说明），我们将参数作为一个片状常数函数，设置在直径为[2.x.3962]的每个单元上，为

[1.x.1546]

其中[2.x.3964]为稳定化指数，[2.x.3965]为用户定义的无量纲稳定化常数。按照[Guermond和Pasquetti 2008]以及步骤31的实现，速度和饱和度全局归一化常数[2.x.3966]和残差[2.x.3967]分别为

[1.x.1547]

和

[1.x.1548]

其中[2.x.3968]是用户定义的第二个无维常数，[2.x.3969]是域的直径，[2.x.3970]是整个计算域中目前饱和值的范围[2.x.3971] 。

这种稳定方案与更简单的方案，如有限体积（或不连续Galerkin）方法或流线型上风Petrov Galerkin（SUPG）离散法相比有很多优点。特别是，人工扩散项主要作用于不连续点附近，因为在饱和度平稳的地区，残差很小。因此，它提供了一个更高的精度。另一方面，它是非线性的，因为 [2.x.3972] 取决于饱和度 [2.x.3973] 。我们通过明确处理所有的非线性项来避免这一困难，这导致了以下时间步长的完全离散问题 [2.x.3974] 。

[1.x.1549]

其中[2.x.3975]是从[2.x.3976]和[2.x.3977]线性外推到当前时间[2.x.3978]的速度，如果[2.x.3979]，而[2.x.3980]是[2.x.3981]，如果[2.x.3982] 。因此，该方程在[2.x.3983]中是线性的，所需要的是用饱和空间上的质量矩阵来解决。

由于饱和度的Dirichlet边界条件只施加在流入边界上，所以上述方程左边的第三个项需要进一步分成两部分。

[1.x.1550]

其中[2.x.3984]和[2.x.3985]分别代表流入和流出的边界。我们使用上风公式选择数值，即[2.x.3986]和[2.x.3987]对应于从当前单元中提取的数值，而[2.x.3988]和[2.x.3989]的数值是来自邻近的边界[2.x.3990]。




[1.x.1551]

适应性地选择网格以解决尖锐的饱和前沿是我们算法中实现效率的一个基本要素。在这里，我们使用[Chueh, Djilali and Bangerth 2011]中使用的相同的冲击型细化方法来选择那些应该被细化或粗化的单元。三角形的每个单元[2.x.3991]的细化指标是通过以下方式计算的

[1.x.1552]

其中[2.x.3992]是在[2.x.3993]单元的中心评价的离散饱和变量的梯度。这种方法类似于可压缩流动问题中经常使用的方法，即用密度梯度来表示细化。也就是说，正如我们将在[1.x.1553]的结尾处讨论的那样，这被证明不是一个非常有用的标准，因为它基本上到处都导致细化。我们在这里只是为了说明问题而展示它。




[1.x.1554]

按照上面讨论的治理方程的离散化，我们得到一个时间步长为[2.x.3995]的线性方程组，形式如下。

[1.x.1555]

其中各个矩阵和向量的定义如下，使用形状函数[2.x.3996]表示速度，[2.x.3997]表示压力和饱和度。

[1.x.1556]

和[2.x.3998]在稳定传输方程的定义中给出。

如果我们把左上角的[2.x.3999]板块的矩阵视为一个板块，那么上面的线性系统是块状三角形形式。因此，我们可以首先求解速度和压力（除非我们决定用[2.x.4000]来代替速度），然后再求解饱和度变量。其中第一个步骤要求我们解决

[1.x.1557]

我们对这个线性系统采用广义最小残差（GMRES）方法[Saad和Schultz 1986]。速度-压力系统的理想预处理方法是

[1.x.1558]

其中[2.x.4001]是系统的Schur补充[Zhang 2005]。这个预处理程序是最优的，因为

[1.x.1559]

对其而言，可以证明GMRES在两次迭代中收敛。

然而，我们当然不能指望使用速度质量矩阵和Schur补数的精确求逆。因此，我们采用[Silvester and Wathen 1994]最初为斯托克斯系统提出的方法。将其适用于当前的方程组，得到预处理程序

[1.x.1560]

其中蒂尔德表示精确逆矩阵的近似值。特别是，由于[2.x.4002]是一个稀疏的对称和正定矩阵，我们为[2.x.4003]选择了这个矩阵的稀疏不完全Cholesky分解的单一应用[Golub和Van Loan 1996]。我们注意到，对应于非混合形式的多孔介质流动算子的舒尔补，[2.x.4004]和[2.x.4005]应该是实际舒尔补矩阵[2.x.4006]的良好近似。由于这两个矩阵又都是对称和正定的，所以我们用[2.x.4007]的不完全Cholesky分解来表示[2.x.4008]。需要注意的是，[2.x.4009]需要用Dirichlet边界条件建立，以确保其可逆性。

一旦有了速度[2.x.4010]，我们就可以把[2.x.4011]和[2.x.4012]组合起来，用以下方法解决饱和度的问题

[1.x.1561]

其中质量矩阵[2.x.4013]用共轭梯度法求解，再一次使用不完全的Cholesky分解作为预处理。

[1.x.1562]

[2.x.4014] 这里讨论的实现使用并扩展了这个库的步骤21、步骤31和步骤33教程的部分程序。特别是，如果你想了解它是如何工作的，请参考step-21关于数学问题的讨论，以及step-31，大部分的实现都来自于此。我们将不讨论在步骤31中已经讨论过的实现的各个方面。

我们展示了一些两相流方程的数值结果，这些方程通过适当的初始和边界条件，结合两种不同的渗透率模型的选择而得到增强。在所考虑的问题中，没有内部源项（[2.x.4015]）。如上所述，定量的数值结果在[Chueh, Djilali and Bangerth 2011]中提出。

为了简单起见，我们选择了[2.x.4016]，尽管所有的方法（以及我们的实现）在一般的非结构化网格上都应该同样工作。

初始条件只需要饱和变量，我们选择[2.x.4017]，即多孔介质最初是由非湿润（80%）和湿润（20%）相的混合物填充。这与步骤21中的初始条件不同，在该步骤中我们采用了[2.x.4018]，但由于复杂的数学原因，在那里的长篇评论中提到，目前使用基于熵的人工扩散项的方法在不对方法进行额外修改的情况下不能收敛到这个初始条件的粘度解。因此，我们在目前的计划中选择了这个修改过的版本。

此外，我们在边界上规定了一个线性压力。

[1.x.1563]

压力和饱和度唯一地决定了速度，而速度决定了一个边界段是流入还是流出的边界。在边界的流入部分，[2.x.4019]，我们规定

[1.x.1564]

换句话说，该领域被来自左边的湿润相淹没。对于边界的流出部分，不需要饱和的边界条件。

所有用于二维/三维案例的数值和物理参数都列在下表中。

[2.x.4020]




[1.x.1565]


<ol> [2.x.4021] CC Chueh, N Djilali and W Bangerth.  [2.x.4022] 三维异质多孔介质中两相流的h-适应性算子分割方法。  [2.x.4023] SIAM科学计算杂志，第35卷（2013），第B149-B175页

[2.x.4024] M. Kronbichler, T. Heister, and W. Bangerth [2.x.4025] 通过现代数值方法进行高精度地幔对流模拟。  [2.x.4026] Geophysics Journal International, vol. 191 (2012), pp.

[2.x.4027] F Brezzi和M Fortin。  [2.x.4028] [1.x.1566].  [2.x.4029] Springer-Verlag, 1991.

[2.x.4030] Z陈。  [2.x.4031] [1.x.1567].  [2.x.4032] Springer, 2005.

[2.x.4033] JL Guermond和R Pasquetti.  [2.x.4034] 基于熵的非线性粘度的守恒定律的傅里叶近似。  [2.x.4035] [1.x.1568], 346(13-14): 801-806, 2008.

[2.x.4036] CC Chueh, M Secanell, W Bangerth, and N Djilali.  [2.x.4037] 异质多孔介质中瞬态两相流的多级自适应模拟。  [2.x.4038] [1.x.1569], 39:1585-1596, 2010.

[2.x.4039] Y Saad和MH Schultz。  [2.x.4040] Gmres:用于解决非对称线性系统的广义最小残差算法。  [2.x.4041] [1.x.1570], 7(3):856-869, 1986.

[2.x.4042] F张。  [2.x.4043] [1.x.1571].  [2.x.4044] Springer, 2005.

[2.x.4045] D Silvester和A Wathen。  [2.x.4046] 稳定的斯托克斯系统的快速迭代解第二部分：使用一般的块状先决条件。  [2.x.4047] [1.x.1572], 31(5):1352-1367, 1994.

[2.x.4048] GH Golub和CF van Loan。  [2.x.4049] [1.x.1573].  [2.x.4050] 第三版，约翰霍普金斯大学，1996年。

[2.x.4051] SE Buckley和MC Leverett。  [2.x.4052] 沙子中流体位移的机制。  [2.x.4053] [1.x.1574], 146:107-116, 1942.

[2.x.4054]


examples/step-43/doc/results.dox



[1.x.1575]


这个程序的输出与第21步的输出其实没有什么不同：毕竟它解决的是同一个问题。更重要的是定量指标，如解决方案的准确性以及计算所需的时间。这些在本页顶部列出的两份出版物中都有详细记载，我们在此不再重复。

也就是说，如果没有几张好的照片，任何教程程序都是不完整的，所以这里有一些三维运行的输出。

[2.x.4055]


[1.x.1576]

[1.x.1577]

人们对这个程序的主要反对意见是它仍然太慢了：在合理的细网格上的三维计算实在是太昂贵了，无法以合理的快速周转来进行常规计算。这与我们写step-31时的情况相似，这个程序从它那里得到了很多灵感。解决办法也是类似的，因为它也在那里。我们需要以类似于从第31步衍生出第32步的方式来并行化这个程序。事实上，步骤32中使用的所有技术也可以转移到这个程序中，使程序立即在几十或几百个处理器上运行。

一个不同的方向是使该程序与许多其他多孔介质的应用更加相关。具体来说，一个途径是去找多孔介质流动模拟器的主要用户，即石油工业。在那里，该领域的应用以多相流（即超过我们这里的两相）为主，以及它们之间可能发生的反应（或任何其他相的质量交换方式，如通过溶解和从油相中冒出的气体）。此外，气体的存在往往会导致流体的可压缩性效应。这些效应通常共同组成了广泛使用的 "黑油模型"。在考虑储层中石油的控制性燃烧以提高压力和温度时，多相之间的真正反应也在油藏模型中发挥作用。不过，这些问题要复杂得多，留待今后的项目研究。

最后，从数学的角度来看，我们得出了在某一时间步长重新计算速度/压力解的标准，其前提是我们要把在当前时间步长会得到的解与上次实际解这个系统时计算的解进行比较。然而，在程序中，每当我们没有重新计算解决方案时，我们并不只是使用之前计算的解决方案，而是从之前两次求解系统的结果中推算出来。因此，该标准被悲观地表述为：我们真正应该比较的是在当前时间步长得到的解与外推的解。在这方面重述该定理是一个练习。

也有其他方法可以扩展这个程序的数学基础；例如，人们可以说，我们关心的不是速度，而实际上是饱和度。因此，人们可能会问，我们在这里用来决定[2.x.4056]是否需要重新计算的标准是否合适；例如，人们可能会提出，决定一个错误的速度场事实上是否会影响饱和方程的解（以及影响的程度）也很重要。这自然会导致敏感性分析。

从算法的角度来看，我们在这里使用了一个工程中经常使用的细化标准，即通过查看解的梯度。然而，如果你检查解决方案，你会发现它几乎在所有地方都迅速导致细化，甚至在明显没有必要的区域：因此经常使用并不需要暗示它是一个有用的标准开始。另一方面，用一个不同的、更好的标准来取代这个标准应该不是很困难。例如，许多其他程序中使用的KellyErrorEstimator类当然也应该适用于当前的问题。


examples/step-44/doc/intro.dox

[2.x.4057]

[1.x.1578]

[2.x.4058]

[1.x.1579]

[1.x.1580]

本教程的主题是非线性固体力学。经典的单场方法（例如见步骤18）不能正确描述准不可压缩材料的响应。响应过于僵硬；这种现象被称为锁定。锁定问题可以通过各种替代策略来规避。其中一个策略是三场公式。在这里，它被用来模拟各向同性连续体的三维、完全非线性（几何和材料）响应。材料响应被近似为超弹性。此外，所采用的三场公式对准不可压缩和可压缩材料都有效。

本报告的目的是为使用deal.II处理非线性固体力学的问题提供基础。线性问题在步骤8中得到了解决。在第18步中部分考虑了几何非线性问题的非标准的、超弹性的形式：使用了线性化构成关系的速率形式，问题域随着运动的进行而变化。围绕非线性运动学的重要概念在理论和实施中都没有。然而，第18步确实描述了许多关键概念，以便在deal.II的框架内实现弹性。

我们从非线性运动学的速成课程开始。为了简单起见，我们将注意力限制在准静态问题上。此后，我们介绍了各种关键的应力测量，并描述了构成模型。然后，在解释用于管理材料的类的结构之前，我们详细描述了三场公式。然后介绍了例子问题的设置。

[2.x.4059] 本教程是针对三维空间的弹性问题而开发的（并在介绍中进行了描述）。  虽然空间维度可以在main()例程中改变，但需要注意的是。  一般来说，二维弹性问题只是作为三维问题的理想化而存在。  也就是说，它们要么是平面应变，要么是平面应力。  这些选择中的任何一个的假设都需要被一致地施加。  更多信息请参见步骤8的说明。

[1.x.1581]

这里实施的三场公式是由Simo等人（1985）开创的，被称为混合雅各布-压力公式。重要的相关贡献包括Simo和Taylor（1991）以及Miehe（1994）的贡献。这里采用的符号在很大程度上借鉴了Holzapfel（2001）对非线性固体力学理论方面的出色概述。Hughes (2000)对与不可压缩弹性（小应变时）有关的问题作了很好的概述。

<ol> [2.x.4060] J.C. Simo, R.L. Taylor and K.S. Pister (1985), Variational and projection methods for the volume constraint in finite deformation elasto-plasticity, [2.x.4061] Computer Methods in Applied Mechanics and Engineering [2.x.4062] , <strong> 51</strong>, 1-3, 177-208. 		DOI: [1.x.1582]; [2.x.4063] J.C. Simo and R.L. Taylor (1991), Quasi-incompressible finite elasticity in principal stretches.Continuum basis and numerical algorithms, [2.x.4064] Computer Methods in Applied Mechanics and Engineering [2.x.4065] , <strong> 85 </strong>, 3, 273-310. 		DOI: [1.x.1583]; [2.x.4066] C. Miehe (1994), Aspects of the formulation and finite element implementation of large strain isotropic elasticity [2.x.4067] International Journal for Numerical Methods in Engineering [2.x.4068] <strong> 37 /strong>, 12, 1981-2004. 		DOI: [1.x.1584]; [2.x.4069] G.A. Holzapfel (2001), Nonlinear Solid Mechanics.A Continuum Approach for Engineering, John Wiley & Sons. 		ISBN: 0-471-82304-X; [2.x.4070] T.J.R. Hughes (2000), The Finite Element Method:线性静态和动态有限元分析》，多佛。 		ISBN: 978-0486411811 [2.x.4071].

<ol> [2.x.4072] J-P. V. Pelteret, D. Davydov, A. McBride, D. K. Vu, and P. Steinmann (2016), 在一个耦合问题中使用这种三场公式的例子记录在<ol> [2.x.4072] J-P.V. Pelteret, D. Davydov, A. McBride, D. K. Vu, and P. Steinmann (2016), Computational electro-and magneto-elasticity for quasi-incompressible media immersed in free space, [2.x.4073] International Journal for Numerical Methods in Engineering [2.x.4074] 。 		DOI: [1.x.1585] [2.x.4075] 。

[1.x.1586]

我们可以把四阶张量看作是将二阶张量（矩阵）映射到自己身上的线性算子，其方式与矩阵将向量映射到向量上一样。有各种四阶单位张量，在即将到来的介绍中会用到。四阶单位张量[2.x.4076]和[2.x.4077]定义如下

[1.x.1587]

注意 [2.x.4078] 。此外，我们通过以下方式定义对称和偏斜对称的四阶单位张量

[1.x.1588]

以致于

[1.x.1589]

identity_tensor()返回的四阶 [2.x.4079] 是 [2.x.4080] 。




[1.x.1590]

让时间域表示为[2.x.4081] ，其中[2.x.4082]和[2.x.4083]是总的问题持续时间。考虑一个连续体，在时间[2.x.4085]占据参考配置[2.x.4084]。参考配置中的%粒子由位置矢量[2.x.4086]识别。身体在后来的时间[2.x.4087]的配置被称为当前配置，表示为[2.x.4088]，粒子由矢量[2.x.4089]识别。参考配置和当前配置之间的非线性映射，表示为 [2.x.4090] ，作用如下。

[1.x.1591]

粒子的位移的材料描述被定义为

[1.x.1592]



变形梯度[2.x.4091]被定义为运动的材料梯度。

[1.x.1593]

变形梯度[2.x.4092]的行列式在参考配置和当前配置中映射出相应的体积元素，分别表示为[2.x.4093]和[2.x.4094] ，为

[1.x.1594]



就空间和材料坐标而言，变形的两个重要度量是左和右Cauchy-Green张量，分别表示为[2.x.4095]和[2.x.4096] 。它们都是对称的和正定的。

格林-拉格朗日应变张量的定义为

[1.x.1595]

如果假定变形为无限小，那么右边的第二项就可以忽略，[2.x.4097]（线性化的应变张量）是应变张量的唯一组成部分。从问题的设置来看，这个假设在步骤18中是不成立的，这使得在该教程程序中使用线性化的[2.x.4098]作为应变度量值得怀疑。

为了处理材料在受到体积和剪切型变形时表现出的不同响应，我们考虑将变形梯度[2.x.4099]和左Cauchy-Green张量[2.x.4100]分解为体积变化（体积）和体积保持（等效）部分。

[1.x.1596]

显然，[2.x.4101] 。

空间速度场被表示为[2.x.4102] 。空间速度场相对于空间坐标的导数给出空间速度梯度 [2.x.4103] ，即

[1.x.1597]

其中[2.x.4104] 。




[1.x.1598]

考奇应力定理将作用在当前构型[2.x.4105]的无穷小表面元素上的考奇牵引力[2.x.4106]等同于考奇应力张量[2.x.4107]（一个空间量）与表面的外向单位法线[2.x.4108]的积，即

[1.x.1599]

Cauchy应力是对称的。同样，作用于参考构型[2.x.4109]中的无穷小表面元素的第一皮奥拉-基尔霍夫牵引力[2.x.4110]是第一皮奥拉-基尔霍夫应力张量[2.x.4111]（两点张量）与表面的外向单位法线[2.x.4112]的乘积，为

[1.x.1600]

Cauchy牵引力[2.x.4113]和第一个Piola-Kirchhoff牵引力[2.x.4114]的关系为

[1.x.1601]

这可以用[1.x.1602]来证明。

第一个Piola-Kirchhoff应力张量与Cauchy应力的关系为

[1.x.1603]

进一步的重要应力测量是（空间）基尔霍夫应力 [2.x.4115] 和（参考）第二Piola-Kirchhoff应力 [2.x.4116] 。




[1.x.1604]

前推和后拉运算符允许人们在材料和空间设置之间转换各种措施。这里使用的应力测量是逆变的，而应变测量是协变的。

二阶协变张量[2.x.4117]的前推和后拉操作分别由以下方法给出。

[1.x.1605]



二阶禁忌张量[2.x.4118]的前推和后拉操作分别由以下方法给出。

[1.x.1606]

例如 [2.x.4119] 。




[1.x.1607]

超弹性材料的响应受亥姆霍兹自由能函数[2.x.4120]的制约，该函数作为应力的势能。例如，如果Helmholtz自由能取决于右Cauchy-Green张量[2.x.4121]，那么各向同性的超弹性响应为

[1.x.1608]

如果亥姆霍兹自由能取决于左Cauchy-Green张量[2.x.4122]，那么各向同性的超弹性响应为

[1.x.1609]



根据变形梯度的乘法分解，亥姆霍兹自由能可以分解为

[1.x.1610]

同样，基尔霍夫应力可以分解为体积部分和等效部分[2.x.4123]，其中。

[1.x.1611]

其中[2.x.4124]是压力响应。  [2.x.4125]是投影张量，它提供了欧拉环境下的偏差算子。虚构的基尔霍夫应力张量[2.x.4126]被定义为

[1.x.1612]






[2.x.4127] 上述定义的压力响应与固体力学中广泛使用的压力定义不同，即[2.x.4128] 。这里[2.x.4129]是静水压力。我们在本教程中使用压力响应（尽管我们把它称为压力）。

[1.x.1613]

与可压缩[1.x.1614]相对应的亥姆霍兹自由能由以下公式给出

[1.x.1615]

其中[2.x.4130]是体积模量（[2.x.4131]和[2.x.4132]是Lam&eacute; 参数）和[2.x.4133] 。函数[2.x.4134]被要求是严格凸的，并满足[2.x.4135]等条件，进一步的细节见Holzapfel（2001）。在这项工作中 [2.x.4136] .

不可压缩性对所有运动施加了等效约束 [2.x.4137] 。对应于不可压缩的新胡克材料的亥姆霍兹自由能由以下公式给出

[1.x.1616]

其中 [2.x.4139] 。因此，通过从可压缩自由能中去除体积分量并执行 [2.x.4140] 得到不可压缩响应。




[1.x.1617]

我们将使用Newton-Raphson策略来解决非线性边界值问题。因此，我们将需要将构成关系线性化。

材料描述中的四阶弹性张量定义为

[1.x.1618]

空间描述[2.x.4141]中的四阶弹性张量由[2.x.4142]的推演得到，为

[1.x.1619]

四阶弹性张量（对于超弹性材料）同时拥有主要和次要的对称性。

四阶空间弹性张量可以写成以下解耦形式。

[1.x.1620]

其中

[1.x.1621]

其中空间描述中的虚构弹性张量[2.x.4143]被定义为

[1.x.1622]



[1.x.1623]

系统的总势能[2.x.4144]是内部和外部势能之和，分别表示为[2.x.4145]和[2.x.4146] 。我们希望通过最小化势能找到平衡配置。

如上所述，我们采用了三场的表述。我们用[2.x.4147]表示主要未知数的集合。独立运动学变量[2.x.4148]作为对[2.x.4149]的约束进入公式，由拉格朗日乘数[2.x.4150]（压力，我们将看到）强制执行。

这里使用的三场变分原理由以下公式给出

[1.x.1624]

其中外部电势的定义为

[1.x.1625]

当前配置[2.x.4151]的边界由两部分组成：[2.x.4152] ，其中[2.x.4153] 。规定的Cauchy牵引力，表示为 [2.x.4154] ，被应用于 [2.x.4155] ，而运动被规定在边界的其余部分 [2.x.4156] 。每单位电流体积的体力表示为 [2.x.4157] 。




势的静止性如下

[1.x.1626]

对于所有虚拟位移[2.x.4158]，受[2.x.4159]对[2.x.4160]的约束，以及所有虚拟压力[2.x.4161]和虚拟膨胀[2.x.4162]。

人们应该注意到，在三个场的表述中[2.x.4163]，体积基尔霍夫应力的定义和随后的体积正切与超弹性材料一节中给出的一般形式略有不同，其中[2.x.4164]。这是因为压力[2.x.4165]现在是一个主要的场，而不是一个构成性的派生量。我们需要仔细区分主要场和从构成关系中得到的场。

[2.x.4166] 虽然变量都是用空间量来表示的，但积分的领域是初始配置。这种方法被称为 [2.x.4167] 总拉格朗日公式 [2.x.4168] 。在步骤18中给出的方法，其积分域是当前配置，可以称为 [2.x.4169] 更新的拉格朗日公式 [2.x.4170] 。这两种方法的各种优点在文献中被广泛讨论。然而，应该指出的是，它们是等同的。


与残留物相对应的欧拉-拉格朗日方程为：。

[1.x.1627]

第一个方程是空间设置中的（准静态）平衡方程。第二个是约束条件 [2.x.4171] 。第三个是压力的定义 [2.x.4172] 。

[2.x.4173]下面的简化单场推导（[2.x.4174]是唯一的主变量）使我们清楚地知道如何将积分的极限转化为参考域。

[1.x.1628]

其中[2.x.4175] 。

我们将使用迭代牛顿-拉弗森方法来解决非线性剩余方程 [2.x.4176] 。为了简单起见，我们假设死荷载，即荷载不因变形而改变。

在 [2.x.4177] 的已知状态和 [2.x.4178] 的当前未知状态之间的数量变化被表示为 [2.x.4179] 。在当前迭代[2.x.4180]的数量值表示为 [2.x.4181] 。迭代 [2.x.4182] 和 [2.x.4183] 之间的增量变化被表示为 [2.x.4184] 。

假设系统的状态在某个迭代中是已知的 [2.x.4185] 。用牛顿-拉弗森方法求解的非线性治理方程的线性化近似值是：找到 [2.x.4186] ，以便

[1.x.1629]

然后设置 [2.x.4187] 。切线由以下公式给出

[1.x.1630]

因此。

[1.x.1631]

其中

[1.x.1632]



注意，以下条款被称为几何应力和材料对切线矩阵的贡献。

[1.x.1633]






[1.x.1634]

这里使用的三场公式对准不可压缩材料是有效的，即在[2.x.4188]（其中[2.x.4189]是[1.x.1635]）的地方，要很好地选择[2.x.4190]和[2.x.4191]的插值场。通常情况下，选择[2.x.4192]。这里[2.x.4193]是FE_DGPMonomial类。一个流行的选择是[2.x.4194]，它被称为平均扩张法（见Hughes（2000）的直观讨论）。这个代码可以容纳[2.x.4195]的表述。不连续的近似允许[2.x.4196]和[2.x.4197]被浓缩出来，并恢复了基于位移的经典方法。

对于完全不可压缩的材料[2.x.4198]和三场公式仍将表现出锁定行为。这可以通过在自由能中引入一个额外的约束条件来克服，其形式为 [2.x.4199] 。这里[2.x.4200]是一个拉格朗日乘数，用于强制执行等时约束条件。进一步的细节见Miehe (1994)。

线性化的问题可以写成

[1.x.1636]

其中

[1.x.1637]



在配方中没有压力和膨胀（主要）变量的导数存在。因此，压力和膨胀的不连续有限元插值产生了[2.x.4201]、[2.x.4202]和[2.x.4203]的块对角矩阵。因此，我们可以很容易地表达每个单元上的场[2.x.4204]和[2.x.4205]，只需倒置一个局部矩阵并乘以局部右手。然后我们可以将结果插入其余的方程中，并恢复一个经典的基于位移的方法。为了在元素水平上凝结出压力和膨胀的贡献，我们需要以下结果。

[1.x.1638]

因此

[1.x.1639]

其中

[1.x.1640]

请注意，由于[2.x.4206]和[2.x.4207]选择的是元素层面的不连续，所有需要反转的矩阵都是在元素层面定义的。

构建各种贡献的程序如下。

- 构建 [2.x.4208] 。

- 形成 [2.x.4209] 的元素，并存储在 [2.x.4210] 中的 [2.x.4211] 。

- 形成[2.x.4212]并添加到[2.x.4213]，得到[2.x.4214]。

- 修改后的系统矩阵被称为 [2.x.4215] 。   也就是[1.x.1641] 。






[1.x.1642]

一个好的面向对象的材料类的设计将有利于本教程扩展到广泛的材料类型。在本教程中，我们只有一个名为Material_Compressible_Neo_Hook_Three_Field的材料类。理想情况下，这个类会派生自超弹性材料（HyperelasticMaterial），而超弹性材料会派生自基类Material。这里使用的三场性质的表述也使问题复杂化。

三场公式的亥姆霍兹自由能函数为 [2.x.4216] 。Kirchhoff应力的等效部分[2.x.4217]与使用超弹性材料的单场公式得到的相同。然而，自由能的体积部分现在是一个主要变量的函数 [2.x.4218] 。因此，对于三场公式来说，基尔霍夫应力[2.x.4219]的体积部分的构成反应（和正切）并不像单场公式那样由超弹性构成法给出。我们可以将术语[2.x.4220]标记为体积基尔霍夫应力，但压力[2.x.4221]不是由自由能得出的；它是一个主场。

为了有一个灵活的方法，我们决定Material_Compressible_Neo_Hook_Three_Field仍然能够计算并返回一个体积Kirchhoff应力和正切。为了做到这一点，我们选择在与正交点相关的Material_Compressible_Neo_Hook_Three_Field类中存储插值的主域[2.x.4222]和[2.x.4223]。这个决定应该在以后的阶段，当教程扩展到考虑其他材料时，再重新审视。




[1.x.1643]

这里考虑的数值例子是一个压缩下的几乎不可压缩的块。这个基准问题取自

- S. Reese, P. Wriggers, B.D. Reddy (2000), A new locking-free brick element technique for large deformation problems in elasticity, [2.x.4224] Computers and Structures [2.x.4225] , <strong> 75</strong>, 291-304.   DOI:[1.x.1644]。

  [2.x.4226]

该材料是具有[1.x.1645][2.x.4227]和[2.x.4228]的准不可压缩的新胡克式。对于这样一个材料特性的选择，传统的单场[2.x.4229]方法将锁定。也就是说，响应会过于僵硬。初始和最终配置显示在上面的图片中。利用对称性，我们只求解四分之一的几何体（即一个尺寸为[2.x.4230]的立方体）。域的上表面的内四分之一受到[2.x.4231]的载荷。


examples/step-44/doc/results.dox



[1.x.1646]

首先，我们提出了一系列3维结果与文献中的结果的比较（见Reese等人(2000)），以证明该程序按预期工作。

我们首先比较了[2.x.4232]和[2.x.4233]公式的网格细化的收敛性，如下图所总结的。块的上表面的中点的垂直位移被用来评估收敛性。对于不同的载荷参数[2.x.4234]值，两种方案都表现出良好的收敛特性。这些结果与文献中的结果一致。低阶公式通常高估了低层次细化的位移，而高阶插值方案则低估了位移，但程度较轻。这个基准，以及其他一系列没有在这里显示的基准，使我们相信代码在正常工作。

[2.x.4235]


下面是运行该问题产生的典型屏幕输出。所展示的特殊情况是[2.x.4236]公式的情况。很明显，使用Newton-Raphson方法，可以得到二次收敛的解决方案。在所有的时间步长中，解的收敛是在5个牛顿增量内实现的。收敛后的位移的[2.x.4237]-norm比几何尺度小几个数量级。

[1.x.1647]






使用定时器类，我们可以分辨出代码的哪些部分需要最高的计算费用。对于一个有大量自由度的案例（即高度精细化），下面给出了定时器的典型输出。本教程中的大部分代码都是基于Step-18和其他文章中描述、讨论和演示的优化而开发的。超过93%的时间花在线性求解器上，很明显，对于大型三维问题，可能有必要投资一个更好的求解器。SSOR预处理程序不是多线程的，但对于这类实体问题是有效的。研究使用另一种求解器，如通过Trilinos库提供的求解器，可能是有益的。




[1.x.1648]




然后我们用ParaView对两种情况的结果进行了可视化。第一个是最粗的网格和最低阶插值方法。  [2.x.4238] .第二种是在细化网格上使用[2.x.4239]公式。位移的垂直分量、压力[2.x.4240]和扩张[2.x.4241]场显示如下。


对于第一种情况，很明显，粗略的空间离散化加上大位移导致了低质量的解决方案（加载比为[2.x.4242]）。此外，元素之间的压力差非常大。元素上的恒定压力场意味着大的压力梯度没有被捕获。然而，应该注意的是，即使在这种离散性差的情况下，在标准[2.x.4243]位移公式中会出现的锁定现象也不会出现。块体顶面的跟踪节点的最终垂直位移仍在收敛解的12.5%以内。压力解决方案是非常粗略的，在相邻的单元之间有很大的跳跃。很明显，离施加的牵引力最近的体积经历了压缩，而域的外延则处于膨胀状态。膨胀解场和压力场明显相关，正的膨胀表示正压区域，负的表示压缩区域。正如介绍中所讨论的，压缩性压力有一个负号，而扩张性压力有一个正号。这源于体积应变能量函数的定义，与压力的物理现实的解释相反。


[2.x.4244]

结合空间细化和高阶插值方案，产生了高质量的解决方案。三个网格细化加上[2.x.4245]公式产生的结果清楚地抓住了问题的力学原理。牵引面的变形得到了很好的解决。我们现在可以观察到所施加的牵引力的实际范围，最大的力被施加在表面的中心点，导致最大的压缩。尽管领域中出现了很高的应变，特别是在施加牵引力的区域的边界，但解决方案仍然是准确的。压力场被捕捉到的细节比以前多得多。压缩和膨胀区域之间有明显的区别和过渡，压力场的线性近似允许在子元素尺度上对压力进行精细的可视化。然而，应该注意的是，压力场仍然是不连续的，可以在一个连续的网格上进行平滑处理，以达到后期处理的目的。




[2.x.4246]

这一简要的分析结果表明，三场公式能够有效地规避高度不可压缩介质的体积锁定。混合配方能够准确模拟近乎不可压缩的块体在压缩状态下的位移。命令行输出显示，在极度压缩下的体积变化导致泊松比为0.4999的体积变化小于0.01%。

在运行时间方面，对于类似的自由度数量，[2.x.4247]公式往往比[2.x.4248]的计算成本更高（通过为低阶插值增加一个额外的网格细化级别产生）。下图显示了在一台4核（8线程）机器上连续运行的一批测试的情况。高阶方法计算时间的增加可能是由于高阶元素所需的带宽增加。如前所述，使用更好的求解器和预处理程序可以减轻使用高阶公式的费用。据观察，对于给定的问题，与单线程的SSOR预处理程序相比，使用多线程的Jacobi预处理程序可以减少72%的计算运行时间（在最坏的情况下是具有大量自由度的高阶公式）。然而，根据作者的经验，雅可比预处理方法可能不适合某些涉及替代构成模型的有限应变问题。


[2.x.4249]


最后，下面展示了两个不同级别的网格细化的2维问题的位移解决方案的结果。很明显，由于二维模拟的额外约束，所产生的位移场虽然在质量上相似，但与三维模拟的情况不同。


[2.x.4250]

[1.x.1649]

[1.x.1650]

这项工作有许多明显的延伸。

- 首先，可以在自由能函数中加入一个额外的约束条件，以便在材料中强制执行高度的不可压缩性。一个额外的拉格朗日乘数将被引入，但这可以最容易地使用增强的拉格朗日乘数的原则来处理。这在 [2.x.4251] Simo和Taylor (1991) [2.x.4252] 中得到了证明。

- 这个模型中使用的构成关系是比较基本的。将材料类分成两个独立的类，一个处理体积响应，另一个处理等温线响应，并产生一个通用的材料类（即具有抽象的虚拟函数，派生类必须实现），允许增加更复杂的材料模型，这可能是有益的。这些模型可以包括其他超弹性材料、塑性和粘弹性材料以及其他材料。

- 该程序是为解决单节点多核机器上的问题而开发的。只要稍加努力，该程序就可以通过使用Petsc或Trilinos扩展到大规模的计算环境，使用的技术与step-40中演示的类似。这主要涉及对设置、装配、[2.x.4253]和线性求解器例程的修改。

- 由于该程序假定为准静态平衡，为了研究惯性效应很重要的问题，例如涉及冲击的问题，有必要进行扩展以包括动态效应。

- 对于高度非线性问题，负载和解的限制程序可能是必要的。可以增加一个线搜索算法，将步长限制在牛顿增量内，以确保最佳收敛性。也可能需要使用负载限制方法，如Riks方法，来解决涉及几何不稳定性的不稳定问题，如屈曲和快穿。

- 许多物理问题涉及接触。有可能将物体间的摩擦或无摩擦接触的影响纳入这个程序。这将涉及到在自由能函数中增加一个额外的项，因此需要增加装配程序。我们还需要管理接触问题（检测和应力计算）本身。在自由能函数中增加惩罚项的一个替代方法是使用主动集方法，如步骤41中使用的方法。

- 使用LinearOperators的完整缩减程序已经被编码到线性求解器例程中。这也可以通过应用schur_complement()操作符来实现，以更自动化的方式缩减一个或多个字段。

- 最后，自适应网格细化，如步骤6和步骤18所示，可以提供额外的求解精度。


examples/step-45/doc/intro.dox

[2.x.4254]

［1.x.1651］ ［1.x.1652］

[1.x.1653]

在这个例子中，我们介绍了如何在deal.II中使用周期性边界条件。周期性边界条件是代数约束，通常出现在一个大域的代表性区域的计算中，这些区域在一个或多个方向上重复。

一个例子是模拟光子晶体的电子结构，因为它们有一个类似格子的结构，因此，往往只需要在格子的一个盒子上进行实际计算。为了能够以这种方式进行，我们必须假设该模型可以周期性地扩展到其他盒子上；这要求解决方案具有周期性结构。

[1.x.1654]

[1.x.1655]

deal.II提供了一些高水平的入口来施加周期性边界条件。应用周期性边界条件的一般方法包括三个步骤（也见[2.x.4255]"关于周期性边界条件的词汇表条目"）。

-# 创建一个网格

-# 识别边界不同部分的那些面对，在这些面对上的解应该是对称的，使用[2.x.4256] 。

-# 使用[2.x.4257]将周期性信息添加到网格中。

-# 使用[2.x.4258]添加周期性约束。

第二和第三步对于使用[2.x.4259]类的平行网格是必要的，以确保位于域的对面但由周期性面连接的单元是鬼层的一部分，如果它们中的一个存储在本地处理器上。如果三角结构不是[2.x.4260]类，这些步骤就没有必要。

第一步包括收集匹配的周期性面，并将它们存储在[2.x.4261]的[2.x.4262]中，这是通过函数[2.x.4263]来完成的，例如可以这样调用。

[1.x.1656]



这个调用在周期性边界上的容器dof_handler的所有面进行循环，其边界指标分别为[2.x.4264] 和 [2.x.4265]。(你可以在创建粗略网格后手工分配这些边界指标，见[2.x.4266] "边界指标"。另外，如果你指定了 "着色 "标志，你也可以让命名空间GridGenerator中的许多函数来做这件事；在这种情况下，这些函数会给边界的不同部分分配不同的边界指标，细节通常在这些函数的文档中详细说明）。)

具体来说，如果[2.x.4267]是两个面[2.x.4268]的顶点，那么上面的函数调用将匹配成对的面（和道夫），使得[2.x.4269]和[2.x.4270]之间的差异在除方向之外的每个分量中都消失，并将产生的对与相关数据存储在[2.x.4271]中（关于匹配过程的详细信息，见[2.x.4272]）。

例如，考虑彩色单位方块[2.x.4273]，其边界指标0在左边，1在右边，2在下面，3在上面的面。参见[2.x.4274]的文件，了解这个关于如何分配边界指标的惯例）。然后。

[1.x.1657]

将产生周期性约束，使[2.x.4275]为所有[2.x.4276]。

如果我们转而考虑由[2.x.4277], [2.x.4278], [2.x.4279], [2.x.4280]的凸壳给出的平行四边形，我们可以通过指定一个[2.x.4282]来实现约束[2.x.4281] 。

[1.x.1658]

或

[1.x.1659]

在这里，边界指标0和1的分配也是源于[2.x.4283]的文件。

由此产生的[2.x.4284]可以在[2.x.4285]中使用，用于为AffineConstraints对象填充周期性约束。

[1.x.1660]



除了这个高水平的接口外，还有结合这两个步骤的[2.x.4286]的变体（见[2.x.4287]的变体）可用。

如果需要更多的灵活性，也有一个与[2.x.4288]的低级接口。该低级变体允许直接指定两个应被约束的面。

[1.x.1661]

在这里，我们需要使用[2.x.4289][2.x.4290]和[2.x.4291]来指定两个面的方向。 要想了解更详细的描述，请看[2.x.4292]的文档。除了自我解释的[2.x.4293]和[2.x.4294]之外，其余的参数与高级接口相同。


[1.x.1662]

[1.x.1663]

在下文中，我们将展示如何在一个更复杂的例子中使用上述函数。任务是对斯托克斯流的速度分量实施旋转的周期性约束。

在由[2.x.4295]定义的四分之一圆上，我们要解决斯托克斯问题

[1.x.1664]

其中边界[2.x.4296]被定义为[2.x.4297] 。对于边界的其余部分，我们将使用周期性边界条件，即

[1.x.1665]



网格将由[2.x.4298]生成，该文件还记录了如果其`colorize'参数设置为`true'，它是如何为其各种边界分配边界指标的。


examples/step-45/doc/results.dox



[1.x.1666]

创建的输出结果并不十分令人惊讶。我们只是看到，相对于左、下边界而言，解决方案是周期性的。

[2.x.4299]

如果没有周期性约束，我们最终会得到以下解决方案。

[2.x.4300]


examples/step-46/doc/intro.dox

[2.x.4301]

[1.x.1667]


[1.x.1668]

[1.x.1669]

这个程序处理的是在领域的不同部分耦合不同物理学的问题。具体来说，让我们考虑以下情况，即把斯托克斯流体与弹性固体耦合起来（这两个问题以前在步骤22和步骤8中分别讨论过，你可能想在那里阅读一下各个方程式）。

- 在[2.x.4303]的[2.x.4302]部分，我们有一个流动的流体，满足与时间无关的斯托克斯方程（以涉及应变张量的形式）。   [1.x.1670]

  这里，[2.x.4304]分别是流体的速度和压力。   我们规定了部分外部边界上的速度，[1.x.1671] 。

  而我们假设外部边界的其余部分为自由流动条件，[1.x.1672]



- 域的其余部分，[2.x.4305]被一个固体占据，其变形场[2.x.4306]满足弹性方程，[1.x.1673]。

  其中[2.x.4307]是等级4的弹性张量（我们将使用一个特别简单的形式，假设固体是各向异性的）。   它在对沿固体边界流动的流体所施加的力的反应中发生变形。我们假设这种变形非常小，以至于它对流体没有反馈作用，也就是说，这种耦合只是在一个方向。为了简单起见，我们将假设固体的外部边界是被夹紧的，即[1.x.1674] 。



- 作为小位移假设的结果，我们将对流体和固体之间的界面提出以下边界条件：首先，我们对流体没有滑移的边界条件，[1.x.1675] 。

  其次，固体上的力（牵引力）等于来自流体的法向应力，[1.x.1676] 。

  其中[2.x.4308]是[2.x.4309]上的法向量，从固体指向流体。

我们通过遵循我们通常的规则，即从左边乘以一个测试函数并在域上进行积分，得到这个问题的弱表述。那么它看起来像这样。找到[2.x.4310]，使得

[1.x.1677]

为所有测试函数[2.x.4311]；第一、第二和第三行分别对应于流体、固体和界面贡献。请注意，[2.x.4312]只是上述空间的一个子空间，以适应各种迪里切特边界条件。

当然，只要有两个Triangulation和两个DoFHandler对象，两个子域各一个，就可以实现这种耦合。另一方面，如果有一个知道整个问题离散化的单一DoFHandler对象，那么deal.II的使用就简单多了。

这个程序是关于如何实现这一点的。请注意，我们的目标并不是要提出一个特别有用的物理模型（一个现实的流固交互模型必须考虑到固体的有限变形和它对流体的影响）：这毕竟只是一个旨在演示技术的教程程序，而不是为了解决实际问题。此外，我们将假设子域之间的界面与粗略的网格单元面对齐。




[1.x.1678]

在讨论更多细节之前，让我们先说明一下：这是一个有多个解变量的问题；为此，你可能想先阅读一下[2.x.4313]文档模块，它介绍了我们处理有多个解变量问题的基本哲学框架。但回到手头的问题上。

在deal.II中实现这类问题的基本思路如下：在问题表述中，速度和压力变量[2.x.4314]只存在于流体子域[2.x.4315]中。但我们假设将它们以零点扩展到整个域[2.x.4316]（在一般情况下，这意味着它们沿[2.x.4317]将是不连续的）。那么，什么是这些变量的适当函数空间呢？我们知道，在[2.x.4318]上我们应该要求[2.x.4319]，所以对于[2.x.4320]到整个域的扩展，下面出现了一组有用的函数空间。

[1.x.1679]

(由于这对目前的讨论并不重要，我们从函数空间的选择中省略了边界值的问题；这个问题也影响到我们是否可以为压力选择[2.x.4321]或者我们是否必须为压力选择空间[2.x.4322]。不过，这些问题都与下面的讨论无关)。

请注意，这些确实是一个具有明显规范的线性函数空间。由于在实践中不可能发生混淆，因此我们今后将再次省略省略号，以表示一个函数对整个域的扩展，并简单地用[2.x.4323]来指代原始函数和扩展函数。

对于离散化，我们需要[2.x.4324]的有限维子空间[2.x.4325] 。对于斯托克斯，我们从步骤22中知道，适当的选择是[2.x.4326]，但这只适用于流体占据的那部分域。对于扩展场，让我们使用以下定义在三角形上的子空间 [2.x.4327] 。

[1.x.1680]

换句话说，在[2.x.4328]上，我们选择了通常的离散空间，但我们保留了由零扩展的（不连续的）。要说明的是，我们现在需要一个描述在单元上为零的函数的有限元空间&mdash;而这正是FE_Nothing类的用武之地：它描述了一个常数为零的函数的有限维函数空间。这个奇特的线性向量空间的一个特殊属性是它没有自由度：它不仅仅是有限维度的，它实际上是零维的，因此对于这种类型的对象，[2.x.4329]将返回零。为了下面的讨论，让我们给这个空间一个合适的符号。

[1.x.1681]

符号[2.x.4330]提醒了这个空间的函数为零的事实。很明显，我们选择[2.x.4331] 。

对于我们用来描述弹性方程的变量，上面的整个讨论都可以重复。在这里，对于扩展变量，我们有

[1.x.1682]

而我们通常会使用这样的一个有限元空间

[1.x.1683]

的多项式程度 [2.x.4332] 。

因此，总结起来，我们要在以下空间寻找一个离散的矢量值解[2.x.4333]。

[1.x.1684]






[1.x.1685]

那么，我们如何实现这种事情呢？首先，我们意识到，离散空间[2.x.4334]本质上需要两个不同的有限元。首先，在流体子域上，我们需要元素[2.x.4335]，这在deal.II中很容易通过以下方式实现

[1.x.1686]

其中[2.x.4336]实现了永远为零的函数的空间。其次，在实体子域上，我们需要元素[2.x.4337]，我们用以下方法得到它

[1.x.1687]



下一步是，我们将这两个元素中的每一个都与占据两个子域的细胞联系起来。为此，我们认识到，从某种意义上说，这两个元素只是彼此的变化，因为它们具有相同数量的向量分量，但具有不同的多项式度数&mdash；这很像人们在[2.x.4338]有限元方法中的做法，这也正是我们在这里要做的：我们将（ab）使用hp-namespace的类和设施，将不同的元素分配给不同的单元。换句话说，我们将使用[2.x.4339]中的两个有限元与一个适当的[2.x.4340]集成，使用[2.x.4341]对象，而我们的DoFHandler将处于[1.x.1688]模式下。你不妨看一下步骤27，了解所有这些概念的概况。

在继续描述测试案例之前，让我们先澄清一下[1.x.1689]这种将函数以零为单位扩展到整个领域，然后将问题映射到hp-framework上的方法是有意义的。

- 它使事情变得统一。在所有单元格中，向量分量的数量是相同的（这里是[2.x.4342]）。这使得各种事情都成为可能，因为统一的描述允许代码的重复使用。例如，计算每个向量分量的自由度[2.x.4343]按分量对自由度进行排序[2.x.4344]，随后将矩阵和向量分割成块，以及其他许多函数都能一如既往地工作，而不需要为它们添加特殊的逻辑来描述某些变量只存在于部分领域的情况。因此，在像现在这样的程序中，你已经有了各种工具，这些工具最初并不是为多物理场情况编写的，但在目前的背景下却能正常工作。

- 它可以方便地进行图形化输出。我们支持的所有图形输出格式都要求输出中的每个字段都定义在网格的所有节点上。但是考虑到现在所有的解决方案组件都存在于各个地方，我们现有的DataOut例程可以像以前一样工作，并产生适合于可视化的图形输出--这些字段将简单地被扩展为0，如果不需要，可视化程序可以很容易地过滤掉这个值。

- 基本上没有成本。FE_Nothing的技巧并没有给整个问题增加任何自由度，我们也不需要处理属于这些分量的形状函数&mdash；FE_Nothing没有自由度，也没有形状函数，它所做的只是占用了矢量分量。




[1.x.1690]

更具体地说，在该方案中，我们必须解决以下几点。

- 实现双线性形式，特别是处理界面项，在矩阵和稀疏模式中都是如此。

- 在边界的外部和内部部分实施迪里希特边界条件 [2.x.4345] 。




[1.x.1691]

让我们首先讨论实现双线性形式，在离散水平上，我们记得它是

[1.x.1692]

鉴于我们已经将场扩展为零，原则上我们可以将子域上的积分写成整个域[2.x.4346]，尽管在决定对哪些项进行积分之前，首先询问一个单元是弹性区域还是流体区域的一部分，这没有什么额外的努力。实际上，对这些项进行积分并不十分困难；对于斯托克斯方程，相关步骤已在步骤22中显示，而对于弹性方程，我们基本上采取[2.x.4347]模块中的形式（而不是步骤8中的形式）。

更值得关注的是界面术语。

[1.x.1693]

基于我们假设界面[2.x.4348]与细胞边界重合，这实际上可以写成一组面积分。如果我们用提取器符号[2.x.4349]表示形状函数[2.x.4350]的速度、压力和位移分量，那么上述项就会产生对全局矩阵项[2.x.4351]的如下贡献。

[1.x.1694]

虽然不是很明显，但这个术语带来了一点复杂的问题：虽然[2.x.4352]和[2.x.4353]是在界面的实体一侧评估的（它们分别是位移和对[2.x.4354]的法向量的测试函数，我们需要在界面的流体一侧评估[2.x.4355]，因为它们对应于流体施加的应力/力。换句话说，在我们的实现中，我们将需要界面两边的FEFaceValue对象。让事情变得更糟糕的是，我们可能还必须处理这样一个事实，即一方或另一方可能被细化，使我们需要在一个面的部分区域进行整合。请看下面的实现，如何处理这个问题。

作为一个额外的复杂问题，由这个术语产生的矩阵条目需要以某种方式添加到矩阵的稀疏模式中。这是DoFTools命名空间中各种函数的领域，比如[2.x.4356]和[2.x.4357]本质上，这些函数所做的是模拟系统矩阵装配过程中发生的事情：每当装配将非零条目写入全局矩阵，DoFTools中的函数将添加一个条目到稀疏模式中。因此，我们可以这样做：让[2.x.4358]将所有由常规的逐个单元积分产生的条目添加到稀疏性模式中，然后用手做同样的事情，即由接口项产生的条目。如果你看一下下面的程序中界面积分的实现，那么如何做应该是显而易见的，最多只需要不超过100行的代码。

但我们是懒人：界面项是沿一个面耦合两个相邻单元的自由度，这正是人们在非连续Galerkin方案中要做的事情，函数[2.x.4359]就是为此而写。与通常的[2.x.4360]相比，这是一个矩阵条目的超集，它还将添加所有计算来自所有面的两侧自由度的耦合项的条目。不幸的是，对于这个函数的最简单版本，这是一个相当大的超集。例如，考虑下面这个有两个单元和一个[2.x.4361]有限元的网格。

[1.x.1695]

这里，由[2.x.4362]产生的稀疏模式将只有在一个单元上耦合的自由度的条目。然而，它不会有稀疏模式条目[2.x.4363] 。然而，由[2.x.4364]生成的稀疏模式将有这些条目：它假定你想为一个双线性形式建立一个稀疏模式，该形式将[1.x.1696]自由度从相邻的单元上耦合起来。这不是我们想要的：我们的界面项只作用于一小部分单元，我们当然不需要两个相邻流体单元或两个相邻固体单元之间的所有额外耦合。此外，我们使用高阶元素的事实意味着我们确实会产生比实际需要多得多的条目：在最粗的网格上，在2D中，44,207个非零条目而不是16,635个[2.x.4365]，导致我们后来建立的矩阵中出现大量的零（当然，16,635是不够的，因为它们不包括界面条目）。这个比例在3D中会更糟糕。

所以极度懒惰是有代价的：矩阵中的条目太多。但我们可以适度偷懒：有一个[2.x.4366]的变体，允许我们指定有限元的哪些矢量分量与哪些其他分量耦合，既可以用单元术语，也可以用面术语。对于实体子域中的单元，我们将所有位移相互耦合；对于流体单元，所有速度与所有速度和压力耦合，但压力不与自身耦合。由于没有一个单元同时拥有两组变量，因此没有必要区分这两种单元，所以我们可以这样写掩码。

[1.x.1697]

在这里，我们使用了这样一个事实：有限元的第一个[2.x.4367]分量是速度，然后是压力，最后是[2.x.4368]位移。(我们也可以说，速度/压力也与位移耦合，因为没有一个单元同时拥有两组变量)。另一方面，界面条款需要一个像这样的掩码。

[1.x.1698]

换句话说，所有的位移测试函数（组件[2.x.4369]）与界面另一侧的所有速度和压力形状函数耦合。这并不完全正确，尽管很接近：事实上，界面的确切形式仅指那些在共同界面上确实为非零的压力位移形状函数，这对所有形状函数来说并不正确；另一方面，它确实耦合了所有速度（因为积分涉及速度形状函数的梯度，这些梯度在单元的所有面上均为非零）。然而，我们在上面建立的掩码，并不具备这些微妙的能力。尽管如此，通过这些掩码，我们设法将稀疏模式的条目数降低到21028个&mdash；目前来说已经足够了。




[1.x.1699]

第二个困难是，虽然我们知道如何在外部边界上强制执行速度或应力为零（使用[2.x.4370]调用适当的分量掩码，并为固体和流体外部边界设置不同的边界指标），但现在我们还需要在内部界面上的速度为零，即[2.x.4371] 。在写这篇文章时，deal.II中没有处理这部分的函数，但用手实现并不特别困难：基本上，我们只需要在所有单元上循环，如果它是一个流体单元，而它的邻居是一个固体单元，然后添加约束，确保这个面上的速度自由度为零。在处理相邻的固体单元被细化的情况下，有必要进行一些处理，产生以下代码。

[1.x.1700]



调用[2.x.4372]告诉AffineConstraints为自由度[2.x.4373]启动一个新的约束，其形式为[2.x.4374] 。通常情况下，我们会将单个系数[2.x.4375]设置为非零值（使用[2.x.4376]或将[2.x.4377]设置为非零值（使用[2.x.4378]像上面那样什么都不做，虽然看起来很有趣，但只是让约束成为[2.x.4379]，这正是我们在当前情况下需要的。对[2.x.4380]的调用确保了我们只将速度分量的边界值设置为零，而不是压力分量。

请注意，在有些情况下，这可能会产生不正确的结果：特别是，一旦我们找到当前流体单元的一个实体邻接子，我们就会假设共同面上的所有邻接子都在实体子域。但事实并非如此，例如，考虑以下的网格。

[1.x.1701]



在这种情况下，我们将把左单元右面的所有速度自由度设置为零，这对该面的顶部自由度来说是不正确的。也就是说，只有当流体和固体子域不与一组完整的粗网格单元重合时才会发生这种情况&mdash;但这与本介绍第一节末尾所述的假设是矛盾的。




[1.x.1702]

我们将考虑以下情况作为一个测试案例。

[2.x.4381]

正如本文顶部所讨论的，我们需要在一些地方假设一个单元完全处于域的流体部分或固体部分，此外，一个不活动单元的所有子域也属于同一个子域。如果粗略网格已经将网格细分为实体和流体粗略网格单元，这一点肯定可以得到保证；考虑到上面概述的几何形状，我们可以通过使用[2.x.4382]粗略网格，方便地提供[2.x.4383]函数来实现。

底部的固定边界意味着[2.x.4384]，我们也为顶部的流动规定了迪里希特条件，因此我们在左边得到流入，在右边得到流出。在左边和右边的边界，没有对流动施加明确的边界条件，产生隐性的无应力条件 [2.x.4385] 。上面已经讨论了两个域之间的界面条件。

为了简单起见，我们选择材料参数为[2.x.4386] 。在下面的结果部分，我们还将展示一个可以从同一程序中获得的三维模拟。边界条件和几何形状的定义几乎与上面的2d情况类似。




[1.x.1703]

在程序中，我们需要一种方法来识别一个细胞处于域的哪一部分。有许多不同的方法可以做到这一点。一个典型的方法是使用每个单元的[2.x.4387]"subdomain_id "标签，尽管这个字段在%并行计算中具有特殊意义。另一种方法是[2.x.4388]"material_id "字段，也是每个单元格都有的。它有一个额外的优点，就是在网格细化时，它可以从母体继承到子体；换句话说，我们在创建网格时设置一次材料ID，即使经过几次细化循环，它对所有活动单元都是正确的。因此，我们采用这种方法：我们定义一个[2.x.4389]，用符号名称来表示材料ID的数字，并使用它们来识别单元在域的哪一部分。

其次，我们使用一个在[1.x.1704]模式下运行的DoFHandler类型的对象。该类需要知道哪些单元将使用斯托克斯有限元，哪些使用弹性有限元。因此，在每个细化周期的开始，我们必须走过所有的单元，并将（在hp-parlance中）活动FE索引设置为任何适合当前情况的索引。虽然我们可以使用符号名称来表示材料ID，但主动FE索引实际上是一个数字，经常用于索引对象的集合（例如[2.x.4390]和[2.x.4391]类型），这意味着主动FE索引实际上对于领域的流体部分必须是0，对于弹性部分必须是1。




[1.x.1705]

这个程序主要是为了展示如何处理领域内不同部分的不同物理现象，以及如何在deal.II中实现这样的模型。因此，我们不会费力想出一个好的求解器：我们只是使用SparseDirectUMFPACK类，它总是有效的，即使不是最佳的复杂性。然而，我们将在[1.x.1706]部分对可能的其他求解器进行评论。




[1.x.1707]

这个程序的一个比较棘手的方面是如何估计误差。因为它几乎适用于任何程序，所以我们想使用KellyErrorEstimator，在这里我们也可以用下面这样的代码相对容易地做到。

[1.x.1708]

这就为每个单元提供了两套误差指标。然后我们会以某种方式将它们合并成一个用于网格细化，例如使用类似下面的方法（注意，我们将两个向量中的平方误差指标归一化，因为误差量的物理单位在当前情况下并不匹配，导致两个子域之间的误差指标可能存在数量级的差异）。

[1.x.1709]

(在代码中，我们实际上以4:1的比例权衡误差指标，以支持在斯托克斯子域上计算的误差指标，因为细化在其他方面严重偏向弹性子域，但这只是一个技术问题。因素4已经被启发式地确定为相当好的工作。)

虽然这个原则是合理的，但它并不完全像预期的那样工作。原因是KellyErrorEstimator类是通过整合每个单元面周围的解的梯度跳跃来计算误差指标。这个跳跃在解不连续和扩展为零的地方可能非常大；它也不会随着网格的细化而变小。KellyErrorEstimator类不能忽视这个接口，因为它基本上只看到[1.x.1710]模式下的DoFHandler，其中元素类型从一个单元改变到另一个单元&mdash；正是[1.x.1711]模式所设计的东西，当前程序中的接口看起来与步骤27中的接口没有什么不同，例如，当然也没有更合理的。尽管如此，最终的结果是，在两个子域之间的界面两侧都有一层单元，其误差指标大得不合理。因此，大部分的网格细化工作都集中在界面上。

如果我们有一个真正理解问题的细化指标，并且在积分跳跃项时简单地忽略子域之间的界面，这显然就不会发生。另一方面，这个程序是关于展示如何表示我们在不同子域有不同物理学的问题，而不是关于KellyErrorEstimator的特殊性，因此我们诉诸于被称为 "启发式 "的大锤子：我们简单地把界面上的单元格的误差指标设置为零。这就切断了误差指标中的尖峰。乍看之下，人们也会认为它阻止了网格在界面上的细化，但是相邻的单元只能有一级细化的要求，仍然会导致一个合理的细化网格。

虽然这显然是一个次优的解决方案，但它目前是可行的，并为未来的改进留下了空间。


examples/step-46/doc/results.dox

[1.x.1712]

[1.x.1713]

[1.x.1714]


当运行该程序时，你应该得到如下输出。

[1.x.1715]



结果很容易被可视化。

[2.x.4392]

这些图很容易解释：当水流在固体直立部分的左边向下、右边向上时，它产生的压力在左边高，在右边低，这些力量使固体的垂直部分向右弯曲。




[1.x.1716]

通过将[2.x.4393]类中的维度改为3，我们也可以运行同样的问题3D。你会得到如下的输出。

[1.x.1717]

你会发现，最大的瓶颈是求解器。SparseDirectUmfpack在2016年的工作站上解决这个问题的最后一次迭代需要将近5个小时和大约80GB的内存（倒数第二次迭代只用了16分钟）。显然，这里需要一个更好的求解器，这个话题在下面讨论。

结果也可以被可视化，并产生良好的图片。这里有一张，显示了速度的矢量图（橙色），实体位移（蓝色），以及实体区域的阴影。

<p align="center"> [2.x.4395] [2.x.4396] 。

除了缺乏一个好的求解器之外，网格也有点不平衡：网格细化严重偏向于流体子域（在2D中，情况恰恰相反，促使我们对流体误差指标的权重更高）。显然，如果想继续做更多的三维计算，对两个子域中误差指标的相对重要性进行一些调整是很重要的。


[1.x.1718]

[1.x.1719]

[1.x.1720]

改进程序的一个明显的地方是使用一个更复杂的求解器&mdash；特别是一个能很好地扩展并能解决现实的三维问题的求解器。这在这里其实不难实现，因为从流体到固体的单向耦合。为此，假设我们将自由度重新排序，首先是所有的速度和压力自由度，然后是所有的位移（使用[2.x.4397]很容易实现），那么系统矩阵可以被分成以下的块状形式。

[1.x.1721]

其中[2.x.4398]是速度和压力的斯托克斯矩阵（它可以进一步细分为[2.x.4399]矩阵，如步骤22，尽管这对目前的目的不重要），[2.x.4400]是位移的弹性方程的结果，[2.x.4401]是来自界面条件的矩阵。现在注意到，这个矩阵

[1.x.1722]

是[2.x.4402]的逆数。应用这个矩阵只需要与[2.x.4403]和[2.x.4404]各解一次，因为

[1.x.1723]

可以计算为[2.x.4405]，然后是[2.x.4406] 。

因此，人们可以预期，

[1.x.1724]

如果 [2.x.4407] ，将是一个好的预处理程序。

这意味着，我们只需要为斯托克斯和弹性方程分别提供良好的预处理。这些都是众所周知的：对于斯托克斯，我们可以使用step-22的结果部分所讨论的预处理程序；对于弹性，一个好的预处理程序将是一个几何或代数多重网格的单一V形周期。然而，还有更多的开放性问题。对于由两个子调节器构建的 "优化 "求解器块-三角调节器，经常出现的一点是，在为子调节器选择参数时，在单独解决两个问题时效果好的值，在组合成多物理学调节器时可能不是最佳值。  特别是，当单独解决固体或流体力学问题时，在收敛所需的迭代次数和每次迭代应用预调节器的成本之间进行平衡，可能导致人们为斯托克斯问题选择昂贵的预调节器，为弹性问题选择便宜的预调节器（或者反之）。  然而，当结合在一起时，还有一个额外的约束，即你希望两个子预处理程序以大致相同的速度收敛，否则便宜的预处理程序可能会增加全局的迭代次数，而昂贵的预处理程序则会增加每迭代的成本。例如，虽然单一的AMG V型循环本身是一个很好的弹性方法，但当结合到一个多物理问题时，可能会有动力使用一个完整的W型循环或多个循环来帮助降低总求解时间。




[1.x.1725]

正如介绍中提到的，我们在这个程序中使用的细化指标是相当临时的。一个更好的会明白，解的梯度在界面上的跳跃并不是错误的指示，而是可以预期的，并且在积分跳跃项的时候忽略界面。然而，这并不是KellyErrorEstimator类所做的。另一个更大的问题是，这种估计器首先是否是一个好的策略：例如，如果我们想在位移的某个特定方面（例如实体右上角的位移）有最大的准确性，那么将流体和实体的误差指标放大到相同的程度是否合适？也许有必要用比固体更高的精度来解决流体问题，因为流体的解决方案直接影响到固体的解决方案？也许正好相反？

因此，改进该程序的一个明显的可能性是实施一个更好的细化标准。关于这个话题有一些文献；各种可能的起点之一是Thomas Wick的论文 "Adaptive finite elements for monolithic fluid-structure interaction on a prolongated domain:应用于心脏瓣膜模拟"，2011年机械学计算机方法会议论文集（CMM-2011），2011年5月9-12日，波兰华沙。




[1.x.1726]

上面的结果纯粹是定性的，因为没有证据表明我们的方案实际上是收敛的。因此，一个显而易见的事情是增加一些量化的措施来检查该方案至少收敛到[1.x.1727]。例如，我们可以为每个细化周期输出实体的右上角突出到流体子域的部分的偏移。或者我们可以计算出流体对实体施加的净力向量或扭矩。




[1.x.1728]

在现实中，大多数流体结构的相互作用问题是这样的：固体的运动确实影响了流体的流动。例如，空气在气箔周围的作用力导致它弯曲并改变其形状。同样地，一面旗帜在风中飘动，完全改变了它的形状。

这种双向耦合的问题通常在任意拉格朗日欧拉（ALE）框架下处理，其中固体的位移以某种平滑的方式扩展到流体领域，而不是像我们在这里所做的那样以零为单位。然后，扩展的位移场被用来对我们计算流体流动的网格进行变形。此外，界面上流体的边界条件不再是速度为零；相反，在一个时间相关的程序中，流体速度必须等于沿界面的位移的时间导数。


examples/step-47/doc/intro.dox

[2.x.4408]

[1.x.1729]

[1.x.1730]

[1.x.1731]

这个程序处理的是[1.x.1732]。

[1.x.1733]

这个方程出现在薄结构的建模中，如体育场的屋顶。当然，这些物体在现实中是三维的，其横向范围与垂直厚度的长宽比很大，但人们通常可以通过对内力在垂直方向上的变化作出假设，将这些结构非常准确地建模为二维的。这些假设导致了上面的方程式。

该模型通常有两种不同的类型，取决于施加什么样的边界条件。第一种情况。

[1.x.1734]

对应于连接到高度为[2.x.4409]的墙顶的薄结构的边缘，这样作用在结构上的弯曲力为[2.x.4410]；在大多数物理情况下，我们会有[2.x.4411]，对应于结构只是坐在墙顶。

在边界值的第二种可能情况下，我们将有

[1.x.1735]

这相当于一个 "钳制 "的结构，对于这个结构来说，非零的[2.x.4412]意味着对水平面有一定的角度。

就像拉普拉斯方程的迪里希特和诺依曼边界条件一样，当然有可能在边界的一部分有一种边界条件，而在其余部分有另一种。




[1.x.1736]

该方程的基本问题是它的解有四个导数。在我们在步骤3、步骤4和其他几个教程中处理的拉普拉斯方程的情况下，人们乘以一个测试函数，进行积分，通过部分积分，最后在测试函数和试验函数上只得到一个导数--对于全局连续的函数，人们可以做到这一点，但在单元之间的界面上可能有结点。导数可能不在界面上定义，但那是在一个较低维的流形上（所以不在积分值中显示出来）。

但是对于双调子方程，如果按照同样的程序，在整个领域（即所有单元的联盟）上使用积分，最终会在测试函数和试验函数上各产生两个导数。如果使用通常的片状多项式函数，并在单元格界面上有结点，那么第一个导数将产生一个不连续的梯度，第二个导数在界面上有delta函数--但由于测试函数和试验函数的第二个导数都产生一个delta函数，我们将尝试对两个delta函数的乘积进行积分。例如，在1d中，[2.x.4413]是通常的片状线性 "帽子函数"，我们会得到这样的积分

[1.x.1737]

其中[2.x.4414]是定义形状函数[2.x.4415]的节点位置，[2.x.4416]是网格大小（假设为均匀）。问题是，积分中的delta函数是用以下关系定义的

[1.x.1738]

但这只有在以下情况下才行得通：(i) [2.x.4417]实际上在[2.x.4418]处定义良好，(ii) 它是有限的。另一方面，以下形式的积分

[1.x.1739]

是没有意义的。类似的推理也可以适用于2D和3D的情况。

换句话说。这种试图在整个领域内进行整合，然后再按部分进行整合的方法不可能成功。

历史上，数值分析家试图通过发明 "C<sup>1</sup>连续 "的有限元来解决这个问题，也就是说，使用的形状函数不仅是连续的，而且还有连续的一导数。这是诸如阿吉里斯元素、克拉夫-托歇尔元素和其他元素的领域，这些元素都是在20世纪60年代末开发的。从二十一世纪的角度来看，它们的结构只能说是怪异的。如果想使用一般的网格，它们的实现也是非常麻烦的。因此，它们在很大程度上已经失去了作用，deal.II目前不包含这些形状函数的实现。




[1.x.1740]

那么，如何解决此类问题呢？这在一定程度上取决于边界条件。如果有第一组边界条件，即，如果方程是

[1.x.1741]

那么下面的诀窍就能起作用（至少如果域是凸的，见下文）。正如我们通过引入第二个变量从常规拉普拉斯方程中得到步骤20的混合拉普拉斯方程一样，我们可以在这里引入一个变量[2.x.4419]，然后可以用下面的 "混合 "系统代替上面的方程。

[1.x.1742]

换句话说，我们最终得到的实质上是[2.x.4420]的两个耦合的拉普拉斯方程组，每个方程组都有迪里希勒型边界条件。我们知道如何解决这样的问题，使用第20步或第22步的技术为这个系统构造良好的求解器和预处理器应该不是很困难。所以这种情况很容易处理。

[2.x.4421]值得指出的是，这只适用于边界有角的域，如果该域也是凸的--换句话说，如果没有重入角。   这听起来是一个相当随意的条件，但考虑到以下两个事实，它是有意义的。原始双调方程的解必须满足 [2.x.4422] 。另一方面，上面的混合系统重述表明，[2.x.4423]和[2.x.4424]都满足[2.x.4425]，因为这两个变量只解决一个泊松方程。换句话说，如果我们想确保混合问题的解[2.x.4426]也是原来的偏谐方程的解，那么我们需要能够以某种方式保证[2.x.4427]的解实际上比只是[2.x.4428]更光滑。这一点可以作如下论证。对于凸域，[1.x.1743]意味着，如果右侧[2.x.4429]，那么[2.x.4430]如果域是凸的并且边界足够光滑。(如果域的边界足够光滑，也可以保证这一点--但边界没有角的域在现实生活中不是很实用。)   我们知道[2.x.4431]，因为它解决了方程[2.x.4432]，但我们仍然留下了边界凸性的条件；我们可以证明多边形的凸域足以保证在这种情况下[2.x.4433]（光滑的有界凸域将导致[2.x.4434]，但我们不需要这么多规则）。另一方面，如果域不是凸的，我们就不能保证混合系统的解在[2.x.4435]中，因此可能会得到一个不能等于原始偏谐方程的解。

更复杂的情况是，如果我们有 "钳制 "的边界条件，也就是说，如果方程看起来像这样。

[1.x.1744]

混合系统的相同技巧在这里不起作用，因为我们最终会对[2.x.4436]采用[1.x.1745]的迪里切特和诺伊曼边界条件，但对[2.x.4437]则没有。


在20世纪90年代和21世纪初，这一难题的解决方案随着非连续Galerkin方法的出现而到来。与使用[1.x.1746]形状函数处理拉普拉斯方程，通过惩罚不连续的大小来获得每个形状函数上有一个导数的方程的方案一样，我们可以使用一个使用[1.x.1747]（但不是[2.x.4438]连续）形状函数的方案，惩罚导数的跳跃来获得每个形状函数上有两个导数的方案。与拉普拉斯方程的内部惩罚（IP）方法相类似，这种用于双调方程的方案通常被称为[2.x.4439]IP（或C0IP）方法，因为它使用[2.x.4440]（连续但不连续可微）形状函数与内部惩罚公式。




[1.x.1748]

我们以Susanne Brenner和Li-Yeng Sung在 "C [2.x.4442] 多边形域上线性四阶边界值问题的内部惩罚方法"[2.x.4443]中提出的[2.x.4441]IP方法为基础，该方法是针对具有 "钳制 "边界条件的双谐波方程而提出的。

如前所述，这种方法依赖于使用[2.x.4444]拉格朗日有限元，其中[2.x.4445]的连续性要求被放宽，并被内部惩罚技术所取代。为了推导这个方法，我们考虑一个[2.x.4446]形状函数[2.x.4447]，它在[2.x.4448]上消失。我们引入符号[2.x.4449]作为[2.x.4450]的所有面的集合，[2.x.4451]作为边界面的集合，[2.x.4452]作为内部面的集合，供下面进一步使用。由于[2.x.4453]的高阶导数在每个界面[2.x.4454]上有两个值（由两个单元[2.x.4455]共享），我们通过在[2.x.4456]上定义以下单值函数来应对这一不连续性。

[1.x.1749]

为[2.x.4457]（即为梯度和二阶导数矩阵），其中[2.x.4458]表示从[2.x.4460]指向[2.x.4461]的一个单位向量法线。在文献中，这些函数分别被称为 "跳跃 "和 "平均 "操作。

为了得到[2.x.4462]IP的近似值[2.x.4463]，我们将双调方程乘以[2.x.4464]，然后对[2.x.4465]进行积分。如上所述，我们不能用这些形状函数对[2.x.4466]的所有部分进行积分，但我们可以对每个单元进行积分，因为这些形状函数只是每个单元的多项式。因此，我们首先在每个网格单元[2.x.4467]上使用下面的分项积分公式。

[1.x.1750]

在这一点上，我们有两个选择。我们可以再一次整合域项的[2.x.4468]，得到

[1.x.1751]

由于各种原因，这被证明是一个对我们的目的没有用处的变体。

相反，我们要做的是认识到[2.x.4469] ，我们可以将这些操作重新排序为[2.x.4470]，其中我们通常写成[2.x.4471]，表示这是第二导数的 "黑森 "矩阵。通过这样的重新排序，我们现在可以整合发散，而不是梯度算子，我们得到以下结果。

[1.x.1752]

这里，冒号表示对其左边和右边的矩阵的指数进行双缩，即两个张量之间的标量乘积。两个向量[2.x.4472]的外积可以得到矩阵[2.x.4473] 。

然后，我们对所有单元格[2.x.4474]进行求和，并考虑到这意味着每个内部面在求和中出现两次。因此，如果我们把所有的东西分成细胞内部的积分之和和细胞界面的单独之和，我们就可以使用上面定义的跳跃和平均运算符。还有两个步骤。首先，由于我们的形状函数是连续的，形状函数的梯度可能是不连续的，但连续性保证了实际上只有梯度的法向分量是不连续的，而切向分量是连续的。其次，当网格大小为零时，产生的离散公式并不稳定，为了得到一个稳定的公式，收敛到正确的解，我们需要增加以下条款。

[1.x.1753]

然后，在进行出现的取消后，我们得出以下双调子方程的C0IP表述：找到[2.x.4475]，使[2.x.4476]对[2.x.4477]和

[1.x.1754]

其中

[1.x.1755]

和

[1.x.1756]

这里，[2.x.4478]是惩罚参数，它既弱化了边界条件的执行

[1.x.1757]

在边界界面[2.x.4479]上，也确保在极限[2.x.4480]中，[2.x.4481]收敛为[2.x.4482]连续函数。  [2.x.4483]被选择为足够大以保证方法的稳定性。我们将在下面的程序中讨论我们的选择。




[1.x.1758] 在多边形域上，双调方程的弱解[2.x.4484]存在于[2.x.4485]中，其中[2.x.4486]是由[2.x.4487]的角的内角决定。例如，只要[2.x.4488]是凸的，[2.x.4489]；[2.x.4490]可能小于1，如果域有重心角，但如果所有内角之一接近[2.x.4493]，[2.x.4491]就接近于[2.x.4492] 。

现在假设[2.x.4494]IP解[2.x.4495]被[2.x.4496]形状函数近似，其程度为多项式[2.x.4497] 。然后，上面概述的离散化产生了下面讨论的收敛率。


[1.x.1759]

理想情况下，我们希望测量 "能量准则"[2.x.4498]中的收敛性。然而，这并不可行，因为同样地，离散解[2.x.4499]并没有两个（弱）导数。相反，我们可以定义一个离散的（[2.x.4500] IP）半规范，"等同于 "能量规范，如下所示。

[1.x.1760]



在这个半规范中，上面提到的论文中的理论得出，我们可以期望

[1.x.1761]

我们知道，拉普拉斯方程的通常离散化的收敛率是真实的，这与我们所期望的差不多。

当然，只有在精确解足够平滑的情况下，这才是真的。事实上，如果[2.x.4501]有[2.x.4502]，[2.x.4503]其中[2.x.4504]，那么[2.x.4505]IP方法的收敛率是[2.x.4506]。换句话说，只有当解平滑到[2.x.4507]时，才能期待最佳收敛率；这只有在以下情况下才会发生：(i) 域是凸的，边界足够平滑，(ii) [2.x.4508] 。当然，在实践中，解决方案是什么就是什么（与我们选择的多项式程度无关），那么最后一个条件可以等同于说，如果[2.x.4509]不大，那么选择[2.x.4510]大肯定没有意义。换句话说，[2.x.4511]唯一合理的选择是[2.x.4512]，因为更大的多项式度数不会导致更高的收敛阶数。

就本程序而言，我们有点懒得实际实现这个等价的语义规则--尽管这并不难，而且会成为一个很好的练习。相反，我们将简单地在程序中检查 "坏的"[2.x.4513]语义规则是什么？

[1.x.1762]

产量。从理论的角度来看，这个准则的收敛率当然不可能比[1.x.1763]的收敛率高，因为它只包含了必要条件的一个子集，但至少可以想象到它会更好。还有一种情况是，即使程序中存在一个错误，我们也能得到最佳收敛率，而这个错误只会在[2.x.4515]中出现的额外条款中显示出次优的收敛率。但是，人们可能希望，如果我们在破碎规范和下面讨论的规范中得到最优速率，那么这个程序确实是正确的。结果部分将证明，我们在所有显示的规范中都得到了最优率。


[1.x.1764]

在 [2.x.4516] -norm中的最佳收敛率是 [2.x.4517] 提供的 [2.x.4518] 。更多细节可以在 [2.x.4519] 的定理4.6中找到。

下面的程序中默认的是选择[2.x.4520]。在这种情况下，该定理并不适用，事实上，人们只能得到[2.x.4521]而不是[2.x.4522]，我们将在结果部分展示。


[1.x.1765]

鉴于我们在最好的情况下对相当于[2.x.4524]半规范的规范期待[2.x.4523]，对[2.x.4526]规范期待[2.x.4525]，人们可能会问在[2.x.4527]半规范中会发生什么，它介于其他两种规范之间。一个合理的猜测是，我们应该期待[2.x.4528] 。可能在某个地方有一篇论文证明了这一点，但我们在下面也验证了这个猜想在实验上是真实的。




[1.x.1766]

我们注意到，对于具有其他边界条件的偏谐方程--例如，对于第一组边界条件即[2.x.4530]和[2.x.4531]上的[2.x.4532]--的IP方法的推导，可以通过对[2.x.4533]和[2.x.4534]的适当修改得到，这些修改在书中的章节[2.x.4535]中描述。




[1.x.1767]

剩下要描述的最后一步是这个程序的求解内容。像往常一样，三角函数是一个既好又坏的选择，因为它不在我们可能寻求解决方案的任何多项式空间中，同时又比实际解决方案通常更平滑（这里，它在[2.x.4536]中，而实际解决方案在凸多边形域上通常只在[2.x.4537]左右，如果域不是凸的，则在[2.x.4538]和[2.x.4539]之间）。但是，由于我们没有办法用相对简单的公式来描述现实问题的解决方案，所以我们就用下面的方法，在单位平方的域上[2.x.4540] 。

[1.x.1768]

因此，我们需要选择以下条件作为边界条件。

[1.x.1769]

右手边很容易计算为

[1.x.1770]

该程序有[2.x.4541]和[2.x.4542]类来编码这一信息。


examples/step-47/doc/results.dox



[1.x.1771]

我们用介绍中讨论的右手边和边界值运行程序。这些将产生域[2.x.4544]上的解[2.x.4543]。我们用[2.x.4545]、[2.x.4546]和[2.x.4547]元素来测试这个设置，我们可以通过`main()`函数中的`fe_degree`变量来改变。通过网格细化，[2.x.4548]的收敛率、[2.x.4549]的近似值率和[2.x.4550]的近似值收敛率对于[2.x.4551]应该分别为2、2、1（如介绍中所述，[2.x.4553]的规范为次优）；对于[2.x.4554]为4、3、2；而对于[2.x.4555]为5、4、3。

从文献来看，并不立即清楚惩罚参数[2.x.4556]应该是什么。例如，[2.x.4557]指出它需要大于1，并选择[2.x.4558] 。FEniCS/Dolphin教程选择它为[2.x.4559] ，见https://fenicsproject.org/docs/dolfin/1.6.0/python/demo/documented/biharmonic/python/documentation.html 。  [2.x.4560]使用的[2.x.4561]值大于Kirchhoff板的元素所属的边数（见他们的第4.2节）。这表明也许[2.x.4562], [2.x.4563], 太小了；另一方面，[2.x.4564]的值也是合理的，其中[2.x.4565]是多项式的度数。通过与拉普拉斯方程的不连续Galerkin公式相比较，人们期望最后一个选择是可行的（例如，见步骤39和步骤74的讨论），而且它在这里也将证明是可行的。但是我们应该检查[2.x.4566]的哪个值是正确的，下面我们将这样做；改变[2.x.4567]在`assemble_system()`中定义的两个`face_worker`和`boundary_worker`函数中很容易。




[1.x.1772][1.x.1773][1.x.1774]

我们用不同的细化网格运行代码，得到以下收敛率。

[2.x.4568] 我们可以看到，[2.x.4569]的收敛率在2左右，[2.x.4570] -seminorm收敛率在2左右，[2.x.4571] -seminorm收敛率在1左右。后两者与理论上的预期收敛率相符；对于前者，我们没有定理，但鉴于介绍中的评论，对于它是次优的也不奇怪。




[1.x.1775][1.x.1776][1.x.1777]


[2.x.4572] 我们可以看到，[2.x.4573] 收敛率在4左右，[2.x.4574] -seminorm 收敛率在3左右，[2.x.4575] -seminorm 收敛率在2左右。当然，这符合我们的理论预期。




[1.x.1778][1.x.1779][1.x.1780]

[2.x.4576] 我们可以看到，[2.x.4577] norm收敛率在5左右，[2.x.4578] -seminorm收敛率在4左右，而[2.x.4579] -seminorm收敛率在3左右。在最细的网格上，[2.x.4580]规范收敛率比我们的理论预期小得多，因为线性求解器由于舍入而成为限制因素。当然在这种情况下，[2.x.4581]误差也已经非常小了。




[1.x.1781][1.x.1782][1.x.1783]

为了与上述结果进行比较，现在让我们也考虑一下我们简单地选择[2.x.4582]的情况。

[2.x.4583] 虽然[2.x.4584]规范的收敛率[2.x.4585]或多或少符合理论预期，但[2.x.4586] -seminorm和[2.x.4587] -seminorm似乎并没有像预期那样收敛。比较[2.x.4588]和[2.x.4589]的结果，很明显，[2.x.4590]是一个更好的惩罚。鉴于[2.x.4591]对于[2.x.4592]元素来说已经太小了，如果用[2.x.4593]元素重复实验，结果更加令人失望，这可能就不奇怪了。我们再次只得到2、1、0的收敛率--也就是说，不比[2.x.4594]元素好（尽管误差的大小更小）。然而，也许令人惊讶的是，当使用[2.x.4595]元素时，人们获得了或多或少的预期收敛顺序。无论如何，这种不确定性表明，[2.x.4596]充其量是一个有风险的选择，最坏的情况是一个不可靠的选择，我们应该选择[2.x.4597]更大。




[1.x.1784][1.x.1785][1.x.1786]

由于[2.x.4598]显然太小了，人们可能猜想[2.x.4599]实际上可能效果更好。下面是在这种情况下得到的结果。

[2.x.4600] 在这种情况下，收敛率或多或少符合理论预期，但与[2.x.4601]的结果相比，变化更大。同样，我们可以对[2.x.4602]和[2.x.4603]元素重复这种实验。在这两种情况下，我们会发现我们获得了大致的预期收敛率。那么，更感兴趣的可能是比较误差的绝对大小。在上表中，对于[2.x.4604]情况，最细网格上的误差在[2.x.4605]和[2.x.4606]情况下是相当的，而对于[2.x.4607]，[2.x.4608]的误差要比[2.x.4609]的大很多。对于[2.x.4610]的情况也是如此。




[1.x.1787]

关于应该使用哪种 "合理 "的惩罚参数的结论是，[2.x.4611]产生了预期的结果。因此，它是目前编写的代码所使用的。




[1.x.1788]

这个方案有一些明显的扩展，会有意义。

- 该程序使用一个正方形域和一个均匀的网格。真正的问题不是这样的，我们应该验证在其他形状的域上的收敛性，特别是在弯曲的边界上。人们也可能对使用自适应网格细化来解决规则性较差的区域感兴趣。

- 从更多的理论角度来看，上面的收敛结果只使用了 "破损的"[2.x.4612]半规范[2.x.4613]，而不是 "等同的 "规范[2.x.4614] 。这足以让我们相信，这个程序并没有从根本上被破坏。然而，测量我们有理论结果的实际规范的误差可能是有趣的。例如，使用FEInterfaceValues类与[2.x.4615]结合，实现这一补充应该不会太困难，其精神与我们用于组装线性系统的精神相同。


  [1.x.1789]

  类似于实施中所涉及的 "夹持 "边界条件，我们将推导出[2.x.4616]IP有限元方案，用于简单支撑板。   [1.x.1790]

  我们用测试函数[2.x.4617]乘以双调方程，并对[2.x.4618]进行积分，得到。   [1.x.1791]



  将所有单元格[2.x.4619]相加，因为[2.x.4620]的法线方向在两条单元格共享的每条内边上指向相反的方向，[2.x.4621]在[2.x.4622]上，[1.x.1792]

  并通过细胞界面上的跳跃定义，[1.x.1793] 。

  我们将域的内部面和边界面分开，[1.x.1794] 。

  其中[2.x.4623]是内部面的集合。   这使我们得出[1.x.1795]。



  为了使离散问题对称化和稳定化，我们加入了对称化和稳定化项。   我们最终得到双调方程的[2.x.4624]IP有限元方案：找到[2.x.4625]，使[2.x.4626]上的[2.x.4627]和[1.x.1796]

  其中[1.x.1797]

  和[1.x.1798]

  这个边界案例的实现与 "钳制 "版本类似，只是在系统组装时不再需要`边界_工人'，并且根据配方改变右手边。


examples/step-48/doc/intro.dox



[1.x.1799][1.x.1800]

[1.x.1801]

[1.x.1802]

这个程序演示了如何使用基于单元的有限元算子与MatrixFree类的实现，这是在step-37中首次介绍的，用于解决非线性偏微分方程。此外，我们再看一下无矩阵框架内对约束条件的处理。最后，我们将使用显式时间步进方法来解决问题，并介绍高斯-洛巴托有限元，在这种情况下非常方便，因为它们的质量矩阵可以准确地被对角线矩阵所接近，因此是可逆的。这一特性的两个成分是：首先，根据Gauss-Lobatto正交规则的点分布，对Lagrange多项式的结点进行分布。其次，正交是用同样的Gauss-Lobatto正交规则完成的。在这个公式中，只要[2.x.4628]，积分[2.x.4629]就会变成零，因为在定义拉格朗日多项式的点中，正好有一个函数[2.x.4630]是一，其他都是零。此外，拉格朗日多项式的节点的Gauss-Lobatto分布将节点向元素边界聚集。这就为高阶离散化方法提供了条件良好的多项式基础。事实上，具有等距节点的FE_Q元素的条件数随着度数的增加而呈指数级增长，这破坏了约5级以上的任何好处。由于这个原因，高斯-洛巴托点是FE_Q元素的默认分布（但在度数为1和2时，这些点相当于等距点）。

[1.x.1803]

作为一个例子，我们选择解决正弦-戈登孤子方程

[1.x.1804]

在步骤25中已经介绍过。作为一种简单的显式时间积分方法，我们选择使用方程的二阶表述的跃迁蛙方案。通过这个时间步长，该方案以弱的形式读取

[1.x.1805]其中[1.x.1806]表示一个测试函数，索引[1.x.1807]代表时间步数。

对于空间离散化，我们选择FE_Q元素，其基函数定义为插值高斯-洛巴托正交规则的支持点。此外，当我们计算基函数的积分以形成质量矩阵和上述方程右边的算子时，我们使用高斯-洛巴托正交规则，其支持点与有限元的节点点相同，以评估积分。由于有限元是拉格朗日的，这将产生方程左侧的对角线质量矩阵，使每个时间步长的线性系统的解变得微不足道。

使用这个正交规则，对于[1.x.1808]th阶有限元，我们使用[1.x.1809]th阶精确公式来评估积分。由于在计算质量矩阵时，两个[1.x.1810]阶基函数的乘积在每个方向上给出了一个具有多项式程度[1.x.1811]的函数，所以积分的计算并不精确。  然而，在具有仿生元素形状的网格上，整体收敛特性不受正交误差的干扰，L2误差与[1.x.1812]成正比。但是请注意，当积分不再是多项式时，一些三维设置的L2误差[1.x.1813]甚至[1.x.1814]的次优收敛率的阶次减少已被报道[1.x.1815]在变形（非affine）元素形状的波方程上。

除了在使用显式时间步进时我们可以避免用这种类型的元素来解决线性系统外，它们还具有另外两个优点。当我们使用和-因子化方法来评估有限元算子时（参见步骤37），我们必须在正交点评估函数。在Gauss-Lobatto元素的情况下，正交点和有限元的节点点重合，这种操作是微不足道的，因为正交点的函数值是由其一维系数给出的。这样一来，与一般的高斯正交相比，有限元算子评估的算术工作减少了大约两倍。

总结一下讨论，通过使用正确的有限元和正交规则组合，我们最终得到一个方案，我们只需要计算对应于上述公式的右手边向量，然后在每个时间步骤中乘以对角线质量矩阵的逆。当然，在实践中，我们提取对角线元素，只在程序开始时反转一次。

[1.x.1816]

在[2.x.4631]中处理约束的通常方法是使用AffineConstraints类，该类建立了一个稀疏矩阵，存储关于哪些自由度（DoF）被约束以及如何被约束的信息。这种格式使用了不必要的大量内存，因为没有那么多不同类型的约束：例如，在每个单元上使用线性有限元时，悬挂节点的情况下，大多数约束具有[2.x.4632]的形式，其中系数[2.x.4633]总是相同，只有[2.x.4634]不同。虽然存储这些多余的信息在一般情况下不是问题，因为在矩阵和右手边的装配过程中只需要一次，但在无矩阵的方法中，它成为一个瓶颈，因为在那里，每次我们应用算子时都要访问这些信息，而算子评估的其余部分是如此之快。因此，MatrixFree使用一个我们称为[2.x.4635]的变量来收集不同约束的权重，而不是AffineConstraints对象。然后，只需要存储网格中每个约束的标识符而不是所有的权重。此外，约束不是在前后处理步骤中应用的，而是在我们评估有限元算子时应用的。因此，约束信息被嵌入到变量[2.x.4636]中，用于从全局矢量中提取单元信息。如果一个DoF被约束，[2.x.4637]变量包含它被约束的DoF的全局索引。然后，我们手头还有另一个变量[2.x.4638]，对于每个单元，持有被约束的DoF的局部指数以及约束类型的标识符。幸运的是，你不会在示例程序中看到这些数据结构，因为类[2.x.4639]会在没有用户互动的情况下处理这些约束。

在存在悬空节点的情况下，通过Gauss-Lobatto正交/节点点程序在元素层面获得的对角线质量矩阵并不能直接转化为对角线全局质量矩阵，因为遵循行和列的约束也会增加非对角线的条目。正如在[1.x.1817]中所解释的，在一个矢量上插值约束，保持质量矩阵的对角线形状，与方程一致，直到与正交误差相同大小的误差。在下面的程序中，我们将简单地组装质量矩阵的对角线，就像它是一个矢量一样，以实现这种近似。




[1.x.1818]

MatrixFree类可以在三个层次上进行并行化。分布式节点集群上的MPI并行化，由线程积木库安排的线程并行化，以及最后通过SIMD数据类型在两个（或更多）单元的批次上工作的矢量化（有时称为跨元素或外部矢量化）。正如我们在第37步中已经讨论过的，通过使用特定于你的系统的指令集，你将得到最好的性能，例如，使用cmake变量<tt>-DCMAKE_CXX_FLAGS="-march=native"</tt>。MPI并行化已经在步骤37中被利用了。这里，我们额外考虑用TBB进行线程并行化。这相当简单，因为我们需要做的就是告诉MatrixFree对象的初始化，我们想通过变量[2.x.4640]来使用线程并行方案。 在设置过程中，建立了一个类似于[2.x.4641]中描述的依赖图，这允许安排[2.x.4642]函数在单元块上的工作，而没有几个线程访问同一个向量索引。相对于WorkStream循环，还应用了一些额外的巧妙技巧来避免[1.x.1819]中描述的全局同步。

请注意，这个程序是为分布式三角测量[2.x.4643]而设计的，它要求deal.II配置[1.x.1820]，如[1.x.1821]文件中所述。然而，也支持非分布式三角法，在这种情况下，计算将以串行方式运行。

[1.x.1822]

在我们的例子中，我们选择初始值为[1.x.1823]，并在时间区间[-10,10]内解决方程。常数被选择为[2.x.4644]和[1.x.1824]。如步骤25所述，在一维中[1.x.1825]作为[1.x.1826]的函数是正弦-戈登方程的精确解。然而，对于更高的维度，情况并非如此。


examples/step-48/doc/results.dox



[1.x.1827]

[1.x.1828]

为了证明使用MatrixFree类而不是标准的[2.x.4645]汇编例程来评估旧时间步长的信息的好处，我们研究了代码在非自适应网格上的一个简单串行运行。由于很多时间花在评估正弦函数上，我们不仅显示了完整的正弦-戈登方程的数字，还显示了波浪方程（正弦-戈登方程中跳过的正弦项）的数字。我们同时使用二阶和四阶元素。结果总结在下表中。

[2.x.4646]

很明显，无矩阵代码远远超过了deal.II中的标准汇编程序。在三维和四阶元素中，一个运算符的评估速度也几乎是稀疏矩阵-向量乘积的十倍。

[1.x.1829]

我们从一个具有12个核心/24个线程的工作站（一个英特尔至强E5-2687W v4 CPU运行在3.2 GHz，启用了超线程）上获得的程序输出开始，以发布模式运行程序。

[1.x.1830]



在3D中，各自的输出看起来像

[1.x.1831]



一个自由度超过一百万的时间步长需要0.008秒（注意，在求解线性系统时，我们需要许多处理器来达到这样的数字）。

如果我们用一个纯粹的MPI并行化取代线程并行化，时间就会变成。

[1.x.1832]



我们观察到输出的急剧加速（这是有道理的，因为输出的大部分代码没有通过线程并行化，而对于MPI则是如此），但低于我们从并行性中期望的12的理论系数。更有趣的是，当从纯线程变量切换到纯MPI变量时，计算也变得更快。这是MatrixFree框架的一个一般观察结果（截至2019年更新此数据）。主要原因是，为实现并行执行而做出的关于冲突单元批处理工作的决定过于悲观：虽然它们确保在不同的线程上不会同时进行相邻单元的工作，但这种保守的设置意味着在相邻单元被触及时，相邻单元的数据也会从缓存中被驱逐。此外，对于给定的具有17592个单元的网格，目前的方案无法为所有24个线程提供一个恒定的负载。

目前的程序还允许将MPI并行化与线程并行化混合起来。在有多个节点的集群上运行程序时，这是最有利的，使用MPI进行节点间并行化，使用线程进行节点内并行化。在上面使用的工作站上，我们可以在超线程区域运行线程（即为12个MPI行列中的每一个使用2个线程）。将MPI与线程混合的一个重要设置是确保将任务适当地分到CPU上。在许多集群上，放置是通过`mpirun/mpiexec`环境自动进行的，或者可以有手动设置。在这里，我们简单地报告了程序的普通版本的运行时间（注意到当适当的分档完成后，事情可以向仅有MPI的程序的时间改进）。

[1.x.1833]






[1.x.1834]

这个程序中有几处可以改进，使其更加有效（除了步骤25中讨论的改进边界条件和物理东西）。

[2.x.4647] [2.x.4648] [1.x.1835] 从上面平波方程和正弦-戈登方程的比较中可以明显看出，正弦项的评估在有限元算子应用的总时间中占主导地位。这有几个原因。首先，VectorizedArray场的deal.II正弦计算没有被矢量化（与算子应用的其他部分相反）。这可以通过将正弦计算交给一个具有矢量化正弦计算的库来解决，比如英特尔的数学内核库（MKL）。通过使用MKL中的函数[2.x.4649]，该程序在二维中使用了一半的计算时间，在三维中使用了40%的时间。另一方面，正弦计算在结构上要比其他本地操作中的加法和乘法等简单算术操作复杂得多。

   [2.x.4650] [1.x.1836] 虽然该实现允许空间部分的任意顺序（通过调整有限元的程度），但时间步进方案是一个标准的二阶跃迁方案。由于波的传播问题的解通常是非常平滑的，所以误差很可能被时间步进部分所支配。当然，这可以通过使用较小的时间步长（在固定的空间分辨率下）来解决，但如果使用高阶时间步长也会更有效率。虽然对于一阶系统来说，这样做是很简单的（使用一些高阶的Runge&ndash;Kutta方案，可能结合像[1.x.1837]那样的自适应时间步长选择），但对于二阶公式来说，这更具挑战性。至少在有限差分社区，人们通常使用PDE来寻找改善时间误差的空间修正项。

[2.x.4651]


examples/step-49/doc/intro.dox

[1.x.1838]

[1.x.1839]

[1.x.1840] 本教程是步骤1的扩展，演示了几种获得比那里显示的更多的网格的方法。

[2.x.4652] 本教程也可作为Jupyter Python笔记本，使用deal.II python接口。该笔记本与原始的C++程序在同一目录下提供。

生成复杂的几何图形是一项具有挑战性的任务，特别是在三个空间维度。我们将讨论几种方法，但这个清单并不详尽。此外，没有一种方法适合所有的问题。

这个例子程序显示了一些为计算而创建和修改网格的方法，并以与我们在步骤1中相同的方式将它们输出为[2.x.4653]文件。没有做其他的计算或自适应细化；我们的想法是，你可以在其他更多的模拟器中使用这里的技术作为构建模块。请注意，这个例子程序并没有展示本介绍中讨论的所有生成网格的方法。




[1.x.1841]

当你使用自适应网格细化时，你肯定希望初始网格尽可能地粗大。因为只要你有内存和CPU时间，你就可以用自适应细化技术把它做得越细越好。然而，这就要求你不要把网格单元浪费在域的某些地方，因为这些单元是没有价值的。因此，你不希望从一个太细的网格开始，因为这已经占用了你的单元预算的很大一部分，而且你无法粗化初始网格中的单元。

也就是说，你的网格需要充分捕捉给定的几何体。




[1.x.1842]

有几种方法来创建一个初始网格。网格可以通过多种方式进行修改或组合，这一点将在后面讨论。

[1.x.1843]

生成网格的最简单方法是使用命名空间GridGenerator中的函数，这在步骤1中已经讨论过了。  有许多不同的辅助函数可用，包括[2.x.4654] [2.x.4655] [2.x.4656] 和 [2.x.4657] 。




[1.x.1844]

如果GridGenerator命名空间中没有适合你想做的事情，你总是可以在你的程序中 "手工 "创建一个三角图。为此，你需要一个带有坐标的顶点列表和一个引用这些顶点的单元格列表。你可以在步骤14的函数<tt>create_coarse_grid()</tt>中找到一个例子。GridGenerator中的所有函数都以这种方式实现。

我们很乐意接受更多的功能加入到GridGenerator中。因此，如果你最终写了一个可能对更多人有用的函数，请将其贡献出来。




[1.x.1845]

GridIn类可以从磁盘的文件中读取许多不同的网格格式。如何做到这一点，在步骤5中有解释，在本例中可以看到函数[2.x.4658]，见下面的代码。

网格可以由不同的工具生成，如[1.x.1846]、[1.x.1847]和[1.x.1848]。更多信息见GridIn的文档。问题是，deal.II需要的网格只由四边形和六面体组成--四面体的网格无法工作（这意味着不能直接使用tetgen等工具）。

我们将描述一个使用%Gmsh的可能工作流程。%Gmsh是我们所知道的最小和最快速设置的开源工具。它可以生成非结构化的二维四面体网格。在三维中，它可以挤压二维网格以获得六面体网格；将非结构化几何体三维网格化为六面体是可能的，尽管这些网格的质量有一些问题，意味着这些网格有时只能在交易中工作。

在%Gmsh中，一个网格的基本描述是基于文本的[2.x.4659]文件，其格式可以包含计算、循环、变量等。这种格式在允许描述复杂的几何图形方面是相当灵活的。然后，网格是由表面表示法生成的，表面表示法是由线条循环列表建立的，线条循环列表又是由点建立的。[2.x.4660] 脚本可以用手写和编辑，也可以通过在%Gmsh内用图形创建对象来自动生成。在许多情况下，最好是把这两种方法结合起来。如果你想用手写的话，可以在 "几何 "选项卡下按 "重载 "来轻松地重新加载文件，并在gmsh的图形用户界面上看到效果。

本教程包含一个例子[2.x.4661]文件，描述一个内部有两个物体被切割出来的盒子。这就是[2.x.4662]在%Gmsh中的样子（显示边界指标以及下面要讨论的网格）。

[2.x.4663]

你可能想用文本编辑器打开[2.x.4664]文件（它与<tt>step-49.cc</tt>源文件位于同一目录），看看它是如何结构的。你可以看到域的边界是如何由一些线组成的，后来我们把几条线组合成 "物理线"（或 "物理面"），列出逻辑线的编号。"物理 "对象是携带边界指标信息的对象（见[2.x.4665]"本词汇表条目"）。

[2.x.4666] 这个文件包含 "物理线 "和 "物理面 "是很重要的。它们提供了在deal.II中使用的边界指标和材料ID。没有这些物理实体，任何东西都不会被导入deal.II中。

deal.II的GridIn类可以读取%Gmsh编写的[2.x.4667]格式，该格式包含为[2.x.4668]描述的几何体创建的网格，通过运行指令

[1.x.1849]



在命令行中，或者在加载文件后点击%Gmsh中的 "Mesh "和 "2D"。  现在这是从[2.x.4670]文件中读取的网格，并由deal.II再次保存为图像（见当前程序的[2.x.4671]功能）。

[2.x.4672]

[2.x.4673] %Gmsh有许多其他接口，人们可以通过这些接口来描述几何图形。特别是，它能够与Python和Julia等脚本语言连接，但也可以用C++编写脚本。这些接口很有用，如果人们不只是想为一个单一的几何体生成网格（在这种情况下，图形界面或者在简单的情况下，手写的".geo "文件可能是最简单的方法），而是想对几何体进行参数化研究，为此需要为某些参数不同的几何体生成许多网格。另一种情况是，如果已经有一个CAD几何体，只需要一个网格；事实上，这可以在deal.II中使用[2.x.4674]函数来完成。




[1.x.1850]

在以上述方式获得一个（或几个）网格后，在将其用于有限元计算之前，有许多方法可以对其进行操作。




[1.x.1851]

GridTools命名空间包含了一系列的小函数，用于以各种方式转换给定的网格。函数 [2.x.4675] [2.x.4676] [2.x.4677] 的用法相当明显，所以我们在此不讨论这些函数。

函数[2.x.4678]允许你使用平滑函数对给定网格的顶点进行变换。在step-38的结果部分也给出了它的使用实例，但让我们在这里展示一个更简单的例子。在当前程序的函数[2.x.4679]中，我们用正弦曲线对网格的y坐标进行扰动。

[2.x.4680]

同样地，我们可以用公式 [2.x.4681] 将一个有规律的细化单位方格转换为y方向的墙体适应网格。这在本教程的 [2.x.4682] 中完成。  [2.x.4683]

最后，函数[2.x.4684]允许你将网格中的顶点（可选择忽略边界节点）随机移动。这在[2.x.4685]中进行了演示，其结果如下。

[2.x.4686]

这个函数主要是为了否定在研究常规网格收敛时得到的一些超收敛效应，以及抑制deal.II中的一些优化，这些优化可以利用单元格形状相似的事实。超级收敛是指如果一个网格具有某些对称性--例如，如果进入一个顶点的边对这个顶点是对称的，并且如果对一个单元的所有顶点都是这样的话

归根结底，这是由于如果对误差进行泰勒扩展，对称性导致了这样一个事实，即预期的扩展的下一个项恰好是零，而误差的阶数是由*第二个下*项决定的。一个扭曲的网格没有这些对称性，因此误差反映了在*任何*种网格上解方程时将会看到的情况，而不是显示只反映特定情况的东西)。




[1.x.1852]

该函数[2.x.4687]允许你将两个给定的三角形对象合并为一个。  要做到这一点，共享边或面的顶点必须完全匹配。  排列两个网格可以用 [2.x.4688] 和 [2.x.4689] 来实现。 在本教程的函数 [2.x.4690] 中，我们合并了一个带圆孔的正方形（用 [2.x.4691] 生成）和一个矩形（用 [2.x.4692] 生成）。 函数 [2.x.4693] 允许你指定重复的数量和角的位置，所以这里不需要手动移动三角网格。你应该以图形方式检查网格，以确保单元格排布正确，并且在合并后的三角图中不存在未配对的节点。

这些是输入网格和输出网格。

[2.x.4694]




[1.x.1853]

函数 [2.x.4695] 展示了在现有网格中挑选个别顶点并移动它们的能力。请注意，这有可能产生退化的或倒置的单元，你不应该期望使用这样的网格会产生任何有用的东西。在这里，我们通过向上移动顶部顶点来创建一个不完全居中的圆柱形孔的盒子。

[2.x.4696]

关于如何做到这一点的确切方法，见下面的代码。




[1.x.1854]

如果你需要一个可以通过挤压给定的2D网格（可以通过上述任何一种方式创建）来创建的3D网格，你可以使用函数 [2.x.4697] 参见本教程中的 [2.x.4698] 函数为例。请注意，对于这个特殊的情况，所给的结果也可以用3D版本的[2.x.4699]来实现。主要的用法是一个2D网格，例如用%Gmsh生成，如上所述从[2.x.4700]文件中读入。这是grid_4()的输出。

[2.x.4701]




[1.x.1855]

使用上面讨论的方法创建一个粗略的网格只是第一步。当你有了它，它通常可以作为进一步细化网格的基础。这并不困难，事实上，如果你的几何体只由直面组成，那就没有其他事情可做。然而，如果你有一个更复杂的几何体，情况往往就不是这样了，除了创建网格之外，还有更多的步骤是必须的。我们将在下面的[1.x.1856]中详细介绍这些步骤。


examples/step-49/doc/results.dox



[1.x.1857]

该程序产生一系列[2.x.4702]的三角形文件。这些方法已在上文讨论。




[1.x.1858]

正如介绍中提到的，使用这里讨论的方法创建一个粗略的网格只是第一步。为了细化网格，Triangulation需要知道在边、面和单元格的中点上放置新的顶点。默认情况下，这些新的点会被放置在周围点的算术平均值上，但如果你需要的是粗略网格没有充分解决的弯曲边界，这并不是你想要的。例如，对于这个网格，中心孔应该是圆形的。

[2.x.4703]

如果你只是简单地细化它，三角测量类就不能知道你是想让孔变成圆形还是八角形。默认的做法是沿着现有的直线放置新的点。经过两个网格细化步骤后，这将产生以下的网格，这不是我们想要的。

[2.x.4704]

需要发生的是，你告诉三角函数，你实际上是想使用一个弯曲的几何体。做到这一点的方法需要三个步骤。

- 创建一个描述所需几何图形的对象。这个对象将在细化三角图以获得新的点位置时被查询。如果在系统组装过程中使用了MappingQ或MappingQGeneric这样的高阶映射，它也将被用来计算形状函数值。   在deal.II中，Manifold类和继承自它的类（如PolarManifold和FlatManifold）执行这些计算。

- 通知Triangulation对象使用哪个Manifold类。默认情况下，Triangulation使用FlatManifold来进行所有的几何计算，它假定所有的单元格边缘都是直线，所有的四边形都是平的。你可以通过调用[2.x.4705]函数将Manifold类附加到Triangulation上，该函数将[2.x.4706]与Manifold对象关联。关于这方面的更多信息，请参见[2.x.4707]"关于这个主题的词汇表条目"。

- 最后，你必须用正确的[2.x.4708]标记单元和单元面。例如，你可以通过以下方式得到一个在直角坐标中带有弯曲单元的环形扇面（但在极坐标中是矩形）。   [1.x.1859]

  现在，当网格被细化时，所有的单元格分割计算都将在极坐标中进行。

GridGenerator命名空间中的所有函数，如果创建的网格中的某些单元应该是弯曲的，也会将正确的Manifold对象附加到所提供的Triangulation上：也就是说，对于这些函数，我们默认会得到正确的行为。然而，对于手工生成的网格，情况要有趣得多。

为了更详细地说明这个过程，让我们考虑一个由Yuhan Zhou创建的例子，作为2013年德克萨斯A&amp;M大学的一个学期项目的一部分。目标是生成（和使用）一个描述微观结构的电气设备的几何体。在一个CAD程序中，这个几何体看起来像这样。

[2.x.4709]

在下文中，我们将引导你完成为这个几何体创建网格的整个过程，包括通过展示可能出错的一些常见陷阱。

实现这一目标的第一步是创建一个粗略的网格，通过为每个截面创建一个2D粗略的网格，将它们挤压到第三个方向，然后将它们粘在一起。下面的代码使用之前描述的技术来完成这个工作。

[1.x.1860]



这就形成了以下的网格。

<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.8.png" alt="" width="400" height="355">

这个网格具有正确的一般形状，但是顶部的单元现在是多边形的：它们的边缘不再是沿着圆的，我们没有非常准确地表示原始几何形状。下一步是教给域的顶部部分，它应该是弯曲的。换句话说，所有在顶部边界单元上进行的计算都应该以圆柱坐标而不是笛卡尔坐标进行。我们可以通过创建一个CylindricalManifold对象并将其与上面的单元格相关联来做到这一点 [2.x.4710] 。这样，当我们细化上面的单元时，我们将沿着同心圆而不是直线来放置新的点。

在deal.II中，我们用继承自Manifold的类来描述所有的几何体。默认的几何图形是笛卡尔的，在FlatManifold类中实现。顾名思义，Manifold及其继承类提供了一种用微分几何的思想和术语来描述曲线和曲线单元的一般方法：例如，CylindricalManifold继承自ChartManifold，它通过回拉和前推来描述几何体。一般来说，人们应该认为Triangulation类描述了一个域的拓扑结构（当然，除了存储顶点的位置之外），而Manifold类描述了一个域的几何结构（例如，一对顶点是否位于圆弧或直线上）。Triangulation将通过对与该单元相关的Manifold进行计算来细化单元，而不管该单元是否在边界上。换句话说：Manifold类不需要任何关于Triangulation边界实际位置的信息：由Triangulation来查询正确的Manifold，以便对单元格进行计算。大多数的Manifold函数（例如，[2.x.4711]）对域本身一无所知，只是假设给它的点是沿着测地线的。在这种情况下，在下面构建的CylindricalManifold中，测地线是沿正交于[2.x.4712]轴的圆弧，以直线[2.x.4713]为中心。

由于领域的三个顶部部分都使用相同的测地线，我们将把所有中心在[2.x.4714]线以上的单元格标记为圆柱形的性质。

[1.x.1861]



通过这段代码，我们得到一个看起来像这样的网格。

<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.9.png" alt="" width="400" height="355">

这一变化修复了边界，但产生了一个新的问题：与圆柱体轴线相邻的单元格严重扭曲。我们应该使用笛卡尔坐标对这些中心单元进行计算以避免这个问题。沿着中心线的单元格都有一个面接触到线[2.x.4715]，所以，为了实现这一点，我们回去把这些单元格上的[2.x.4716]s改写为0（这是默认的）。

[1.x.1862]



这给了我们以下的网格。

<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.10.png" alt="" width="400" height="355">

这给了我们一个很好的网格，每个圆心的单元仍然是笛卡尔的，而边界周围的单元是沿着圆的。如果我们再细化两次，我们可以真正看到边界拟合网格的良好细节。

<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.11.png" alt="" width="400" height="355">




[1.x.1863]

[1.x.1864]

为本教程中描述的以某种形式生成的网格分配不同的边界ID，以应用不同的边界条件，通常是很有用的。

例如，你可能想对这个程序中第一个网格的右边边界应用不同的边界条件。要做到这一点，遍历单元格和它们的面，确定正确的面（例如使用`cell->center()`来查询单元格中心的坐标，就像我们在步骤1中做的那样，或者使用`cell->face(f)->get_boundary_id()`来查询该单元格第[2.x.4717]个面的当前边界指标）。然后你可以使用`cell->face(f)->set_boundary_id()`来设置边界指标为不同的内容。你可以回顾一下步骤1，看看网格的迭代是如何进行的。

[1.x.1865]

在流形上的计算，就像在step-38中做的那样，需要一个嵌入到高维空间的曲面网格。虽然有些网格可以用GridGenerator命名空间来构建或者从文件中加载，但有时从体积网格中提取一个表面网格也是很有用的。

使用函数 [2.x.4718] 来提取网格的表面元素。在一个三维网格上使用这个函数（一个`三角网格<3,3>`，例如从`grid_4()`），这将返回一个`三角网格<2,3>`，你可以在步骤38中使用。  也可以尝试提取一个`三角网格<2,2>`的边界网格。


<!--

本教程可能的扩展。

- 用于收敛研究的非结构化网格数据库

- 如何删除或禁用网格内的一个单元格

-->


examples/step-5/doc/intro.dox

[1.x.1866]

[1.x.1867]

[2.x.4719]

这个例子并没有显示出革命性的新东西，但它显示了许多比以前的例子更小的改进，也显示了许多通常可以在有限元程序中发现的小东西。其中包括。  [2.x.4720] [2.x.4721] 在连续细化的网格上进行计算。至少在数学科学中，在一个层次的网格上计算解是很常见的，以便对解的精度有一个感觉；如果你在一个网格上只有一个解，你通常无法猜测解的精度。此外，deal.II被设计用来支持自适应算法，其中在连续细化的网格上的迭代求解是算法的核心。虽然在这个例子中没有使用自适应网格，但这里为它们奠定了基础。    [2.x.4722] 在实际应用中，领域经常被自动网格生成器细分为三角形。为了使用它们，从文件中读取粗大的网格是很重要的。在这个例子中，我们将读取一个UCD（非结构化单元数据）格式的粗网格。当这个程序在2000年左右首次编写时，UCD格式是AVS Explorer所使用的--这个程序在当时被合理地广泛使用，但现在已经不再重要了。尽管如此，该文件格式仍然存在，并且仍然被一些程序所理解）。    [2.x.4723] 有限元程序通常会使用大量的计算时间，所以有时需要进行一些优化。我们将展示其中的一些。    [2.x.4724] 另一方面，有限元程序往往是相当复杂的，所以调试是一个重要方面。我们通过使用断言来支持安全编程，断言在调试模式下检查参数和%内部状态的有效性，但在优化模式下被删除。( [2.x.4725] [2.x.4726] 关于数学方面，我们展示了如何支持椭圆算子中的可变系数，以及如何对线性方程组使用预处理迭代求解器。  [2.x.4727]

这里要解决的方程式如下。

[1.x.1868]

如果[2.x.4728]是一个恒定的系数，这就只是泊松方程了。然而，如果它确实是空间可变的，它就是一个更复杂的方程（通常被称为 "扩展泊松方程"）。根据变量[2.x.4729]所指的内容，它可以模拟各种情况，具有广泛的适用性。

- 如果[2.x.4730]是电动势，那么[2.x.4731]是介质中的电流，系数[2.x.4732]是介质在任何特定点的电导率。在这种情况下，方程的右侧将是电源密度，通常为零或由局部的、类似德尔塔的函数组成）。

- 如果[2.x.4733]是薄膜的垂直挠度，那么[2.x.4734]将是对局部刚度的测量。这就是让我们解释下面结果部分所显示的图像的解释。

由于拉普拉斯/泊松方程出现在如此多的场合中，因此除了上面列出的两种解释外，还有许多其他解释。

当组装这个方程的线性系统时，我们需要弱的形式，这里的内容如下。

[1.x.1869]

[2.x.4735]函数中的实现紧随其后。


examples/step-5/doc/results.dox



[1.x.1870]


下面是控制台的输出。

[1.x.1871]






在每个周期中，单元格的数量翻了两番，CG迭代的数量大约翻了一番。另外，在每个周期中，程序写出一个VTU格式的输出图形文件。它们被描述为以下内容。

[2.x.4736]




由于系数的可变性（那里的曲率减少的程度与系数增加的程度相同），溶液的顶部区域被压扁了。溶液的梯度沿着界面是不连续的，尽管这在上面的图片中不是很明显。我们将在下一个例子中更详细地研究这个问题。

图片还显示，这个程序计算出来的解在非常粗的网格上其实是相当错误的（它的大小是错误的）。这是因为没有任何数值方法能保证粗大网格上的解是特别准确的--但我们知道解[1.x.1872]是精确的解，事实上你可以看到从一个网格到下一个网格的解似乎在最后不再有太大的变化。


examples/step-50/doc/intro.dox

[2.x.4737]

[1.x.1873]

[2.x.4738]

[2.x.4739] 作为这个程序的前提条件，你需要同时安装p4est和PETSc或Trilinos库。在[1.x.1874]文件中描述了deal.II和这些附加库的安装情况。


[1.x.1875]

[1.x.1876]


这个例子显示了deal.II中的多级函数在并行、分布式网格上的应用，并给出了几何和代数多栅方法的比较。代数多网格(AMG)的前置条件与step-40中使用的相同。考虑了两种几何多网格（GMG）预处理方法：一种是类似于步骤16的基于矩阵的版本（但用于并行计算），另一种是步骤37中讨论的无矩阵版本。我们的目标是找出哪种方法能够为大型并行计算提供最佳解算器。

本教程是基于 [2.x.4740] 中的一个数值例子。关于deal.II中多网格实现的详细背景，请参见该出版物。我们将在下面的文字中总结一些结果。

代数多网格方法显然是最容易用deal.II实现的，因为诸如[2.x.4741]和[2.x.4742]这样的类本质上是黑盒子预处理程序，即使是并行计算，也只需要几行就能设置好。另一方面，几何多网格方法需要对整个代码库进行修改 -- 不是很多，但必须知道自己在做什么。

这个程序的结果将显示，代数和几何多网格方法的性能大致相当[1.x.1877]，而无矩阵的几何多网格方法对于这里所考虑的问题要好很多。另一个结论是，当每个处理器的未知数小于20,000个时，基于矩阵的几何多网格方法真的不能很好地扩展。




[1.x.1878]

我们考虑变系数拉普拉斯的弱表述

[1.x.1879]

在域[2.x.4743]（二维的L形域和三维的Fichera角）上，如果[2.x.4745]，则[2.x.4746]。换句话说，[2.x.4747]是沿着域的边缘或面跑到重入角的小，这在下图中会看到。

边界条件在整个边界上是[2.x.4748]，右手边是[2.x.4749] 。我们使用连续[2.x.4750]元素来表示离散的有限元空间[2.x.4751]，并使用基于残差的、单元的后验误差估计器[2.x.4752]，来自[2.x.4753]的

[1.x.1880]

来适应性地细化网格。(这是KellyErrorEstimator类中使用的Kelly误差估计器的概括，KellyErrorEstimator类驱动大多数其他教程程序中的网格细化。)下图显示了二维的求解和细化： [2.x.4754] 在三维中，求解看起来类似（见下文）。在左边你可以看到解决方案，在右边我们显示了靠近域中心的[2.x.4755]的切片，显示了自适应细化的网格。  [2.x.4756]在二维和三维中，你都可以看到自适应细化拾取了角部奇点和粘度跳跃的内部奇点，而沿分离两个粘度的线的界面（正确地）没有被细化，因为它被充分地解决。这是因为由系数跳跃导致的解决方案中的扭结与细胞界面对齐。




[1.x.1881]

如上所述，这个程序的目的是展示代数和几何多网格方法在这个问题上的应用，并做到并行计算。使算法扩展到大型并行机器的一个重要组成部分是确保每个处理器都有相同的工作量。更准确地说，重要的是没有一小部分处理器比其他处理器有更多的工作，因为如果是这样的话，很大一部分处理器会闲置，等待小部分处理器完成。相反，一小部分处理器的工作大大超过[1.x.1882]并不是问题，因为大多数处理器继续生产，只有一小部分处理器在完成工作后闲置。)

对于活跃的网格，我们使用[2.x.4757]类，正如在步骤40中所做的那样，它使用外部库[1.x.1883]中的功能在处理器之间分配活跃单元。对于多级层次结构中的非活动单元，deal.II实现了我们所说的 "第一子规则"，对于层次结构中的每个单元，我们递归地将一个单元的父级分配给第一个子单元的所有者。下面的数字给出了这样一个分布的例子。这里的左图表示使用空间填充曲线划分的二维网格样本的活动单元（这也是p4est用来划分单元的方法）；中间的图片给出了活动网格的树状表示；右图给出了单元的多级层次结构。颜色和数字代表不同的处理器。树上的圆形节点是非活动单元，使用 "长子规则 "进行分配。

[2.x.4758]

在这个例子中，屏幕上的输出包括一个 "分区效率 "的值，这个值由[2.x.4759]给出，将用[2.x.4760]表示，量化了多网格层次结构中每一层没有完美的工作平衡所产生的开销。这种不平衡在上面的例子中很明显：虽然[2.x.4761]层在三个处理器的四个单元中尽可能的平衡，但粗略的[2.x.4762]层只有一个处理器有工作，而[2.x.4763]层只有两个处理器有工作，其中一个处理器的工作是另一个的三倍。

对于定义[2.x.4764]，需要注意的是，由于我们使用局部平滑来定义多网格层次（参见[2.x.4765]"多网格论文 "中对局部平滑的描述），一个单元的细化水平对应于该单元的多网格水平。现在，让[2.x.4766]为[2.x.4767]层的单元数（包括活动和非活动单元），[2.x.4768]为进程[2.x.4769]所拥有的子集。我们还将用[2.x.4770]表示处理器的总数量。假设任何一个处理器的工作量与该处理器拥有的单元格数量成正比，每个处理器的最佳工作量为

[1.x.1884]

接下来，假设每一层的工作都是同步的（即在V型循环的每一层，在进入下一层之前，所有的处理器都必须完成工作），每一层的极限工作由以下公式给出

[1.x.1885]

和总的并行复杂性

[1.x.1886]

然后我们将[2.x.4771]定义为最佳分区与当前分区的并行复杂度之比

[1.x.1887]

对于上面的例子分布，我们有

[1.x.1888]

这个值[2.x.4772][2.x.4773]代表了我们对GMG方法（vmults、assembly等）所期望的时间增加的因素，因为与完全负载平衡的工作负载相比，网格分区的不平衡。我们将在下面的结果部分报告一连串的网格，并与观察到的减速进行比较，因为我们的处理器数量越来越大（通常，负载不平衡也会变大）。

这些考虑在[2.x.4774]中得到了更详细的考虑，其中包含了对分区效率模型和不平衡对GMG V周期时间的影响的全面讨论。总之，[2.x.4775]的值高度依赖于所使用的局部网格细化程度，对于全局细化的网格有一个最佳值[2.x.4776]。通常对于自适应细化的网格，用于分配单个网格的处理器数量对[2.x.4777]有负面影响，但只到一个平移点，即处理器数量增加时，不平衡度保持相对稳定，进一步细化对[2.x.4778]的影响很小。最后，[2.x.4779]被证明可以准确地表示出对V型周期的计时所预期的并行扩展的减慢。

应该注意的是，在多级网格之间有可能存在一些异步工作，特别是纯粹的近邻MPI通信，而且可以构建一个自适应网格，由于异步工作 "掩盖 "了不平衡，效率模型将远远高估V-周期的减慢（假设各级同步）。然而，对于大多数现实的自适应网格来说，预期这种异步工作只会掩盖非常小的一部分不平衡，效率模型会很好地描述减速。




[1.x.1889]

上面的考虑表明，我们必须期待在deal.II中实现的几何多网格算法的可扩展性有一定的限制，因为即使在网格的最细层是完全负载平衡的情况下，较粗层也可能不是。同时，较粗层的权重较小（[2.x.4780]对[2.x.4781]的贡献较小），因为较粗层的单元较少，因此，对整体运行时间的贡献不如较细层。换句话说，较粗层次的不平衡可能不会导致大局的影响。

代数多网格方法当然是基于一种完全不同的方法来创建层次结构的。特别是，他们纯粹是在分析系统矩阵的基础上创建这些层次，并且在作为[2.x.4782]和[2.x.4783]类基础的hypre和ML/MueLu包中都实现了非常复杂的算法，以确保问题在每个层次上都得到良好的负载平衡。在某种意义上，这些算法比几何多网格方法更简单，因为它们只处理矩阵本身，而不是所有的网格、邻居、父母和其他几何实体的内涵。同时，为了使代数多网格方法能够扩展到非常大的问题，人们也做了很多工作，包括将在某一层次上工作的处理器数量减少到所有处理器的一个子集，如果不这样的话，处理器花在计算上的时间会比花在通信上的时间少。(人们可能会注意到，在几何多网格算法中也有可能实现这些相同的想法，在这些算法中，人们有目的地将一些处理器闲置在较粗的层次上，以减少通信量。只是目前deal.II没有这样做。)

然而，这些并不是我们在这里通常需要担心的问题。在大多数情况下，我们使用代数多网格方法作为黑箱方法。




[1.x.1890]

如上所述，这个程序可以使用三种不同的方式来求解线性系统：基于矩阵的几何多网格（"MB"），无矩阵几何多网格（"MF"）和代数多网格（"AMG"）。这个程序所在的目录有后缀为".prm "的输入文件，适用于所有这三种选项，以及2D和3D。

你可以按以下方式执行该程序

[1.x.1891]

而这将从给定的输入文件（这里是`mg_mb_2d.prm`）中获取运行时参数。

该程序的目的是要并行运行，你可以使用诸如以下的命令来实现这一点

[1.x.1892]

如果你想，比如说，在四个处理器上运行。也就是说，如果你有多少个处理器，程序也可以在`-np 28672`下运行）。


examples/step-50/doc/results.dox



[1.x.1893]

当你使用以下命令运行该程序时

[1.x.1894]

屏幕输出应该如下。

[1.x.1895]

在这里，"solve() "函数的时间被分成三部分：设置多网格预处理程序，执行单一的多网格V型循环，以及CG求解器。被计时的V型循环对整个求解来说是不必要的，只是为了让人们了解AMG和GMG的不同成本。还应注意的是，当使用AMG求解器时，"工作量不平衡 "不包括在输出中，因为不需要粗网格的层次结构。

本节中的所有结果都是在英特尔至强铂金8280（Cascade Lake）节点上收集的，这些节点有56个内核，每个节点有192GB，支持AVX-512指令，允许对8个双倍数进行矢量化（矢量化仅用于无矩阵计算）。代码是用gcc 7.1.0和intel-mpi 17.0.3编译的。Trilinos 12.10.1被用于基于矩阵的GMG/AMG计算。

然后我们可以通过调用step-50目录下的输入文件来收集各种信息。使用这些文件，并调整网格细化步骤的数量，我们可以得出程序的扩展性如何的信息。

下表给出了该程序在高达256M自由度和7168个处理器上的弱比例计时。(回顾一下，在增加处理器数量的同时，弱缩放保持每个处理器的自由度数量不变；也就是说，它考虑的是越来越大的问题。)这里，[2.x.4784]是介绍中的分区效率（也等于1.0/工作量不平衡），"Setup "是设置、设置多重网格、装配和装配多重网格的组合，"Prec "是预处理程序的设置。理想情况下，在每个问题大小上，各个求解器的所有时间都保持不变，但由于分区效率从最大问题大小到最小问题大小从0.371下降到0.161，我们期望看到GMG的时间大约增加[2.x.4785]倍。事实上，这与我们实际得到的情况非常接近。

[2.x.4786]

另一方面，最后一组列中的代数多网格相对来说不受网格层次不平衡度增加的影响（因为它不使用网格层次），时间的增长反而是由文献中记载的其他因素驱动的（最明显的是，代数多网格方法的某些部分的算法复杂度似乎是[2.x.4787]，而不是几何多网格的[2.x.4788]）。

上表的短处是，无矩阵的几何多网格方法似乎是解决这个方程的最快方法，即使不是以很大的优势。另一方面，基于矩阵的方法始终是最差的。

下图提供了每种方法的强大扩展结果，也就是说，我们在越来越多的处理器上解决同一个问题。具体来说，我们考虑在56至28672个处理器上，经过16个网格细化周期（32M DoFs）和19个周期（256M DoFs）后的问题。

[2.x.4789]

虽然基于矩阵的GMG求解器和AMG的规模相似，求解时间也相似（至少在每个处理器有大量未知数的情况下--比如说，几万个），但无矩阵的GMG求解器的规模要好得多，在较粗的网格上，只用八分之一的处理器就能解决较细的问题，与AMG求解器的时间大致相当。反之，在相同数量的处理器上，它可以用大约八分之一的时间解决同样的问题。




[1.x.1896]

[1.x.1897]

有限元度目前是硬编码为2，见主类的模板参数。这很容易改变。为了测试，最好是切换到一个有参考解的测试问题。这样，你可以比较错误率。

[1.x.1898]

一个更有趣的例子是涉及到一个更复杂的粗大的网格（见步骤49的启发）。这种情况下的问题是，网格层次的最粗层实际上是相当大的，我们必须考虑如何有效地解决粗层问题。这对代数多网格方法来说不是一个问题，因为它们只是继续建立越来越粗的矩阵层次，而不管它们的几何来源）。

在这里的程序中，我们只是简单地用共轭梯度法解决粗级问题，没有任何预处理程序。如果粗略问题真的很小，这是可以接受的--例如，如果粗略网格有一个单元，那么粗略网格问题在2d中有一个[2.x.4790]矩阵，在3d中有一个[2.x.4791]矩阵；对于我们在当前程序的[2.x.4792]形域上使用的粗略网格，这些大小在2d中是[2.x.4793]，在3d中有[2.x.4794]。但如果粗略的网格由数百或数千个单元组成，这种方法将不再起作用，并可能开始主导每个V型单元的整体运行时间。一个常见的方法是使用代数多网格预处理程序来解决粗网格问题；然而，这将需要组装粗矩阵（即使是无矩阵版本）作为AMG实现的输入。


examples/step-51/doc/intro.dox

[2.x.4795]

[1.x.1899]

[1.x.1900]

[1.x.1901]

本教程程序介绍了对流-扩散方程的可混合的不连续Galkerin方法的实现。

[1.x.1902]

反对使用非连续Galerkin元素的一个常见论点是，在隐式系统中必须解决大量的全局耦合自由度。  这是因为，与连续有限元不同，在典型的非连续元中，每个顶点有一个自由度[1.x.1903]，而不是只有一个，对边和面也是如此。  作为未知数增长速度的例子，请考虑FE_DGPMonomial基础：每个标量解分量都由度数为[2.x.4796]的多项式表示，每个元素有[2.x.4797]个自由度。通常，一个元素的所有自由度都与相邻元素的所有自由度相耦合。  由此产生的离散方程会很快产生非常大的线性系统，特别是对于2或3维的方程系统。

[1.x.1904]为了减轻解决这种大型线性系统的计算成本，Cockburn和同事们引入了可混合的非连续Galerkin（HDG）方法（见Nguyen和Peraire最近发表的HDG概述文章中的参考资料[2.x.4798]）。

HDG方法通过使用Dirichlet-to-Neumann映射对数学问题进行表述来实现这一目标。  偏微分方程首先被写成一阶系统，然后每个场通过DG方法进行离散。  在这一点上，网格骨架上的单值 "跟踪 "值，即元素面，被视为独立的未知量。这就产生了离散公式中的未知数，这些未知数分为两类。

- 面的未知数，只与面的两边的单元格未知数耦合。

- 单元未知数只与同一单元内定义的单元和面未知数相耦合。最重要的是，一个单元格的内部自由度不会与另一个单元格的任何内部自由度相耦合。

然后，Dirichlet-to-Neumann地图的概念允许以下解决程序。<ol> [2.x.4799] 使用局部元素内部数据来强制执行三角形骨架上的Neumann条件。  然后，全局问题是求解轨迹值，这是唯一全局耦合的未知数。    [2.x.4800] 使用已知的骨架值作为Dirichlet数据来求解局部元素级的解决方案。  这被称为 "局部求解器"，是一个[1.x.1905]逐个元素的求解过程。  [2.x.4801]

[1.x.1906]上述程序也有线性代数的解释--被称为[1.x.1907]--被Guyan在连续有限元的背景下[2.x.4802]，以及被Fraeijs de Veubeke用于混合方法[2.x.4803]，用来减少全局线性系统的大小。在后一种情况下（混合公式），系统的减少是通过使用不连续的通量，结合引入一个额外的辅助变量[1.x.1908]来实现的，该变量在每个元素的边界上近似于未知数的轨迹。这个过程被称为混合化，并且通过类比，这也是为什么Cockburn、Gopalakrishnan和Lazarov在2009年引入的局部非连续Galerkin方法[2.x.4804]，以及随后由他们的合作者开发，最终被称为[1.x.1909]（HDG）方法的原因。

让我们把与HDG问题相关的完整线性系统写成一个块状系统，离散DG（单元内部）变量[2.x.4805]为第一块，骨架（面）变量[2.x.4806]为第二块。

[1.x.1910]

我们现在的目的是用类似于步骤20的舒尔补码方法来消除[2.x.4807]块，这导致了以下两个步骤。

[1.x.1911]

关键是[2.x.4808]的存在不是问题，因为[2.x.4809]是一个块对角线矩阵，每个块对应一个单元，因此足够容易反转。与其他单元的耦合是由骨架变量上的矩阵[2.x.4810]和[2.x.4811]引入的。[2.x.4812]的块对角性以及[2.x.4813]和[2.x.4814]的结构使我们能够逐元反转矩阵[2.x.4815]（迪里希特问题的局部解），并从[2.x.4817]中减去[2.x.4816]。因此，迪里切特到诺曼映射概念的步骤对应于<ol> [2.x.4818] 构建舒尔补码矩阵[2.x.4819]和右手边[2.x.4820] [1.x.1912]并以通常的方式将贡献插入全局跟踪矩阵，[2.x.4821]求解舒尔互补系统[2.x.4822]，[2.x.4823]使用第二个方程求解[2.x.4824]，给出[2.x.4825] 。  [2.x.4826]




[1.x.1913] 对传统DG方法的另一个批评是，近似通量的收敛是次优的。  局部HDG解可以被证明是收敛的[2.x.4827] ，即以最优顺序收敛。  此外，还可以利用超级收敛特性对新的近似解进行后处理，使其以 [2.x.4828] 的速率收敛。




[1.x.1914]

可混合的非连续Galerkin方法只是解决非连续Galerkin方法的问题的一种方法。另一个想法是所谓的 "弱Galerkin "方法。它在步骤61中进行了探讨。




[1.x.1915]

本例中使用的HDG公式取自[2.x.4829][1.x.1916][1.x.1917][1.x.1918]。

我们考虑域[2.x.4830]上的对流-扩散方程，该方程具有迪里切特边界[2.x.4831]和诺伊曼边界[2.x.4832] 。

[1.x.1919]



引入辅助变量[2.x.4833]，将上述方程改写为一阶系统。

[1.x.1920]



我们将这些方程乘以权重函数[2.x.4834]，并对每个元素[2.x.4835]进行分项积分，得到。

[1.x.1921]



带帽子的术语表示数值轨迹（通常也被称为数值通量）。  它们是对元素边界上的内部值的近似。  为了确保守恒，这些项在任何给定的元素边上都必须是单值的[2.x.4836]，尽管对于不连续的形状函数，当然可能有多个值来自界面附近的单元。我们通过使用以下形式的跟踪来消除数字跟踪[2.x.4837]。

[1.x.1922]



变量[2.x.4838]作为一个额外的自变量被引入，是我们最终建立一个全局耦合线性系统的变量。如上所述，它被定义在元素面上，并且在面与面的交汇处（2D中的顶点，3D中的边缘和顶点）不连续。数值跟踪函数中出现的[2.x.4839]和[2.x.4840]的值被认为是限制在边界[2.x.4841]的单元内部解。

局部稳定参数[2.x.4842]对HDG解决方案的稳定性和准确性有影响；进一步的讨论见文献。据报道，稳定参数为1是给出最佳结果的选择。趋向于无穷大的稳定参数[2.x.4843]禁止解在元素边界上的跳跃，使HDG解接近连续有限元素的近似值。在下面的程序中，我们选择稳定参数为

[1.x.1923]

其中我们设定扩散[2.x.4844]和扩散长度尺度为[2.x.4845] 。

HDG方法中的轨迹/骨架变量在元素面上是单值的。  因此，它们必须强烈地代表[2.x.4846]上的迪里希特数据。  这意味着

[1.x.1924]

其中等号实际上是指边界函数[2.x.4847]对脸部变量空间的[2.x.4848]投射（例如脸部的线性函数）。然后，这个约束被应用于骨架变量[2.x.4849]，使用非均质约束的方法[2.x.4850]。

将三角结构中所有元素的贡献相加，强制执行数值通量的法线分量，并对由[2.x.4851]加权的方程进行分项积分，我们得出问题的最终形式：找到[2.x.4852]，以便

[1.x.1925]



未知数[2.x.4853]被称为局部变量；它们被表示为标准的DG变量。  未知数[2.x.4854]是骨架变量，在网格的一维表面（面）上有支持。

我们用符号[2.x.4855]表示所有单元的积分之和，[2.x.4856]表示所有单元的所有面的积分，也就是说，内部面被访问两次，一次来自每侧，并有相应的法向量。当结合共享一个面的两个元素的贡献时，上述方程产生了DG方法中熟悉的条款，解在单元格边界上有跳跃性。

在上述方程中，标量变量 [2.x.4857] 的空间 [2.x.4858] 被定义为在每个单元上为张量积多项式 [2.x.4859] 且在元素边界上不连续的函数空间 [2.x.4860] ，即由 [2.x.4861] 描述的空间。梯度或通量变量的空间 [2.x.4862] 是一个矢量元素空间，其中每个分量是局部多项式且不连续 [2.x.4863] 。在下面的代码中，我们将这两个局部部分收集在一个FESystem中，其中第一个[2.x.4864]dim组件表示梯度部分，最后一个标量组件对应标量变量。对于骨架部分[2.x.4865]，我们定义了一个由住在元素面上的不连续张量乘积多项式组成的空间，在deal.II中由FE_FaceQ类实现。这个空间在其他方面与FE_DGQ相似，即解函数在两个相邻的面之间不连续，也可参见下面的结果部分进行说明。

在上面给出的弱形式中，我们可以注意到以下的耦合模式。<ol> [2.x.4866] 矩阵[2.x.4867] 由局部-局部耦合项组成。  当局部加权函数[2.x.4868]与局部求解项[2.x.4869]相乘时就会产生这些耦合项。因为这些元素是不连续的，[2.x.4870]是块对角线。    [2.x.4871] 矩阵[2.x.4872]代表局部面的耦合。  这些是具有加权函数[2.x.4873]的条款，乘以骨架变量[2.x.4874] 。    [2.x.4875] 矩阵[2.x.4876]代表面-本地耦合，它涉及加权函数[2.x.4877]乘以本地解[2.x.4878] 。    [2.x.4879] 矩阵 [2.x.4880] 是面-面耦合；条款涉及 [2.x.4881] 和 [2.x.4882] 。  [2.x.4883]

[1.x.1926]

HDG方法的一个特点是，它们通常允许构建一个丰富的解决方案，以提高精度。这种后处理方法以逐个元素的方式获取HDG解决方案，并将其结合起来，从而在使用度数为[2.x.4885]的多项式时可以获得[2.x.4884]的精度。要做到这一点，有两个必要的成分。<ol> [2.x.4886] 计算的解梯度 [2.x.4887] 以最佳速度收敛，即 [2.x.4888] 。    [2.x.4889] 解的标量部分的单元平均数，[2.x.4890] ，以[2.x.4891] 的速度超级收敛。  [2.x.4892]

我们现在引入一个新的变量[2.x.4893]，我们通过在约束条件[2.x.4896]下对单元格[2.x.4895]的表达式进行最小化来找到它。这个约束是必要的，因为最小化函数并不能确定[2.x.4897]的常数部分。这就转化为以下方程组。

[1.x.1927]



由于我们在第二组方程中用度数为[2.x.4898]的张量积多项式空间中的整组基函数进行测试，这是一个过度确定的系统，方程比未知数多一个。我们在下面的代码中通过省略其中一个方程来解决这个问题（因为拉普拉斯的行在代表一个常数函数时是线性依赖的）。正如我们将在下面看到的，这种形式的后处理给出了所需的超级收敛结果，速率为[2.x.4899] 。  应该指出的是，在构建[2.x.4900]时有一定的自由度，这种从梯度中提取信息的最小化方法不是唯一的方法。特别是，这里定义的后处理方案在任何意义上都不满足对流-扩散方程。作为替代方案，上面引用的Nguyen、Peraire和Cockburn的论文提出了另一个有点复杂的对流-扩散公式，该公式也可以将通量变量后处理为[2.x.4901]-符合的变体，并且在扩散较小时更好地表示局部对流-扩散算子。我们把更复杂的后处理的实现作为一个可能的扩展留给感兴趣的读者。

请注意，对于矢量值的问题，后处理的工作原理是类似的。我们只需为每个向量分量的平均值分别设置约束，并将梯度作为主要信息来源。

[1.x.1928]

在这个教程程序中，我们考虑的测试案例与步骤7中的几乎相同。计算域是[2.x.4902]，精确的解决方案与步骤7中的解决方案相对应，除了一个缩放比例。我们使用以下源中心[2.x.4903]作为指数[2.x.4904] [2.x.4905] 1D：[2.x.4906] , [2.x.4907] 2D：[2.x.4908] , [2.x.4909] 3D：[2.x.4910] 。  [2.x.4911]

有了精确的解决方案，我们就可以选择右手边的强制力和诺伊曼边界条件，从而得到这个解决方案（制造的解决方案技术）。在这个例子中，我们选择扩散等于1，对流为

[1.x.1929] 注意，对流是无发散的， [2.x.4912] 。

[1.x.1930]

除了实现上述方程，下面的实现还提供了以下功能。  [2.x.4913] [2.x.4914] WorkStream来并行化本地求解器。在步骤9中已经详细介绍了Workstream。    [2.x.4915] 从跟踪中重构本地DG解。    [2.x.4916] 对解进行后处理以实现超融合。    [2.x.4917] 用于直接输出全局骨架解的DataOutFaces。  [2.x.4918]


examples/step-51/doc/results.dox



[1.x.1931]

[1.x.1932]

我们首先看一下程序在二维运行时产生的输出。在下面的四张图片中，我们展示了多项式度数[2.x.4919]和程序的周期2、3、4和8的解决方案。在图中，我们将从内部数据（DG部分）产生的数据与骨架部分（[2.x.4920]）叠加到同一图中。我们不得不生成两个不同的数据集，因为单元格和面孔代表不同的几何实体，它们的组合（在同一个文件中）在VTK输出的deal.II中不被支持。

这些图像显示了HDG的明显特征：细胞的解决方案（彩色的表面）在细胞之间是不连续的。骨架变量上的解位于面的位置，并将局部部分联系起来。骨架解决方案在面与面之间的顶点上是不连续的，尽管它的值沿着同一坐标方向的线相当接近。骨架解可以被解释为两边之间的橡胶弹簧，它可以平衡解的跳跃（或者说，通量[2.x.4921]）。从左上角的图片可以看出，大体解经常出现过冲和欠冲，而骨架变量确实是对精确解更好的近似；这解释了为什么我们可以通过后处理步骤得到更好的解。

随着网格的细化，单元之间的跳跃变得很小（我们代表一个平滑的解决方案），骨架解决方案接近内部部分。对于第8周期，两个变量没有明显的区别。我们还看到边界条件是如何弱化实施的，内部变量并不完全满足边界条件。在下部和左侧边界，我们设置了诺伊曼边界条件，而在右侧和顶部边界，我们设置了迪里希特条件。

[2.x.4922]

接下来，我们看一下后处理的解决方案，还是在周期2、3、4和8。这是一个不连续的解决方案，局部由二阶多项式描述。虽然在第二周期的网格上，解决方案看起来不是很好，但在第三和第四周期，它看起来好得多。正如下面的收敛表所示，我们发现它也更快地收敛到了分析解。

[2.x.4923]

最后，我们看一下[2.x.4924]在第二周期的解。尽管网格较粗，只有64个单元，但经过后处理的解在质量上与第8周期4,096个单元的线性解（未经过后处理）相似。这清楚地表明了高阶方法对于平滑解的优越性。

[2.x.4925]

[1.x.1933]

当程序运行时，它还会输出各自的步骤和收敛表的信息，并在最后输出各部分的误差。在2D中，收敛表看起来如下。

[1.x.1934]




我们可以看到网格细化后的误差减少，对于进行全局细化的情况，也可以看到收敛率。在[2.x.4926]准则下，标量变量和梯度变量的Q1元素的二次收敛率很明显，在[2.x.4927]准则下，后处理的标量变量的三次收敛率也是如此。注意HDG解决方案的这一明显特征。在典型的连续有限元中，阶[2.x.4928]的解的梯度收敛率只有[2.x.4929]，与实际解的[2.x.4930]相反。即使有限元的超收敛结果也是可用的（例如Zienkiewicz和Zhu首次提出的超收敛补丁恢复），但这些通常只限于结构化网格和其他特殊情况。对于Q3 HDG变量，标量变量和梯度在四阶收敛，后处理的标量变量在五阶收敛。

在3D中观察到相同的收敛率。

[1.x.1935]



[1.x.1936]

[1.x.1937]

收敛表验证了介绍中所述的预期收敛率。现在，我们想在本教程的问题上展示一下HDG方法与普通有限元（连续Galkerin）方法相比的计算效率的快速比较。当然，与连续有限元相比，HDG方法对于传输为主的问题的稳定性方面在实践中也很重要，这是在平滑分析解的问题上看不到的方面。在下面的图片中，我们比较了[2.x.4931]误差作为自由度数的函数（左）和线性求解器中花费的计算时间（右），连续有限元（CG）和本教程中介绍的混合非连续Galerkin方法的两个空间维度。相对于教程中我们只使用无条件的BiCGStab，下面的数字中显示的时间使用了[2.x.4932]中的Trilinos代数多网格预处理器 对于HDG部分，为了利用最细级别的矩阵中的块结构，我们使用了ChunkSparseMatrix周围的跟踪变量的包装器。

[2.x.4933]

图中的结果显示，HDG方法在[2.x.4934]时比连续有限元慢，对立方体元素的速度差不多，对六阶元素的速度更快。然而，我们在上面已经看到，HDG方法实际上产生的解比原始变量所表示的更准确。因此，在下面两幅图中，我们转而显示HDG的后处理解的误差（例如用[2.x.4935]表示）。现在我们看到，对于[2.x.4936]和[2.x.4937]，在相同的工作量下，HDG有明显的优势，而对于[2.x.4938]，质量也差不多。

[2.x.4939]

由于HDG方法实际产生的结果收敛为[2.x.4940]，我们应该将其与具有相同渐进收敛行为的连续Galerkin解决方案进行比较，即程度为[2.x.4941]的FE_Q。如果我们这样做，我们会得到下面的收敛曲线。我们看到，用二阶多项式的CG又明显优于用线型的HDG。然而，HDG对高阶的优势依然存在。

[2.x.4942]

这些结果与一般的DG方法的特性是一致的。最佳性能通常不是在线性元素上实现的，而是在更高的阶数上，通常在[2.x.4943]左右。这是因为不连续解的体积-表面效应，有太多的解存在于表面，因此当元素为线性时，会出现重复工作。换句话说，尽管DG方法专注于不连续（因此看起来精度不高）的解的表示，但在相对高的阶数上使用时往往是最有效的。

[1.x.1938]

我们现在展示了同样的三维数字：第一行显示了自由度数和计算时间与标量变量[2.x.4944]中的[2.x.4945]误差的关系，在[2.x.4946]阶的CG和HDG，第二行显示了后处理的HDG方案，而不是原始方案，第三行比较了后处理的HDG方案与阶[2.x.4947]的CG。在三维中，体积-表面效应使得HDG的成本更高，对于线型来说，CG的解决方案显然比HDG更好。对于立方体，HDG和CG的质量相似，而HDG对于六阶多项式又更有效率。我们也可以使用FE_DGP和FE_FaceP的组合来代替（FE_DGQ, FE_FaceQ），它们不使用[2.x.4948]度的张量积多项式，而是[1.x.1939]度的Legendre多项式。在给定的网格尺寸下，FE_FaceP的骨架变量的自由度较少，但求解质量（误差与自由度数量的关系）与FE_FaceQ的结果非常相似。

[2.x.4950]

关于效率比较的最后一点说明。我们试图使用通用的稀疏矩阵结构和类似的求解器（两者的最佳AMG预处理器，没有对任何一个AMG参数进行特别的调整），在一个玩具的例子上，对两种方法的成本与精度进行公平的描述。然而，应该注意的是，连续有限元的几何多网格（GMG）对于[2.x.4951]和[2.x.4952]来说，大约快了四到五个系数。截至2019年，HDG的最优复杂度迭代求解器仍在研究界开发中。另外，还有其他方面的CG的实现，如步骤37所示的快速无矩阵方法，使高阶连续元素更具竞争力。同样，本教程的作者也不清楚是否可以对HDG做出类似的改进。我们参考[1.x.1940]，了解最近的效率评估。




[1.x.1941]

正如在介绍中已经提到的，一种可能性是实施文献中讨论的另一种后处理技术。

第二项没有做得很好的是与这个程序的性能有关，这当然是实际应用中的一个问题（也要权衡(H)DG方法对传输为主的问题有更好的解决质量）。让我们来看看这个教程程序的计算时间和各个部分的份额。

[2.x.4953]

从表中可以看出，解算器和汇编调用在程序的运行时间中占主导地位。这也清楚地表明，在哪些方面的改进是最有意义的。

<ol> [2.x.4954] 更好的线性求解器。我们使用的是BiCGStab迭代求解器，没有预处理程序，迭代次数随着问题大小的增加而增加（Q1元素和全局细化的迭代次数在小尺寸时从35次开始，但在最大尺寸时增加到701次）。为了做得更好，例如可以使用Trilinos的代数多网格预处理程序，或者像[1.x.1942]中讨论的一些更高级的变体。对于以扩散为主的问题，比如目前的问题，只要我们不与MPI并行工作，就可以设计这样一个求解器，在最细的层次上使用更高效的ChunkSparseMatrix的矩阵-向量积。对于MPI并行化的计算，可以使用一个标准[2.x.4955]。

   [2.x.4956] 通过预先组装那些不从一个单元改变到另一个单元的部件（那些既不包含可变系数也不包含依赖映射的项）来加快组装速度。  [2.x.4957]


examples/step-52/doc/intro.dox

[2.x.4958]

[1.x.1943]

[2.x.4959] 为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接解算器。请参考[1.x.1944]中的说明如何做到这一点。

[1.x.1945]

[1.x.1946]

这个程序展示了如何使用Runge-Kutta方法来解决一个随时间变化的问题。它解决了首先在步骤26中讨论的热方程的一个小变化，但是由于这个程序的目的只是演示使用更高级的方法与deal.II的时间步进算法对接，所以只解决了一个均匀细化网格上的简单问题。




[1.x.1947]

在这个例子中，我们求解中子输运方程的单组时间依赖性扩散近似（关于时间依赖性多组扩散，见步骤28）。这是一个关于中子如何在高散射介质中移动的模型，因此它是时间依赖性扩散方程的一个变体--它只是步骤26中讨论的热方程的一个不同名称，加上一些额外的条款。我们假设介质是不可逆的，因此，中子通量满足以下方程。

[1.x.1948]

通过适当的边界条件增强。这里，[2.x.4960]是中子的速度（为简单起见，我们假设它等于1，这可以通过简单地缩放时间变量来实现），[2.x.4961]是扩散系数，[2.x.4962]是吸收截面，[2.x.4963]是一个源。因为我们只对时间依赖性感兴趣，我们假设[2.x.4964]和[2.x.4965]是常数。

由于这个程序只打算演示如何使用先进的时间步进算法，我们将只寻找相对简单问题的解。具体来说，我们要在一个正方形域[2.x.4966]上寻找一个解，其形式为

[1.x.1949]

通过使用二次有限元，我们可以在任何特定时间精确地表示这个函数，所有的误差都是由于时间离散化造成的。我们这样做是因为这样就很容易观察到我们将要考虑的各种时间步进方案的收敛顺序，而不需要将空间和时间误差分开。

我们施加以下边界条件：对[2.x.4967]和[2.x.4968]施加同质的迪里希特条件，对[2.x.4969]和[2.x.4970]施加同质的纽曼条件。我们选择源项，以便相应的解决方案实际上是上述的形式。

[1.x.1950]

因为解是时间上的正弦，我们知道精确解满足[2.x.4971] 。因此，时间[2.x.4972]的误差只是数值解的规范，即[2.x.4973]，而且特别容易评估。在代码中，我们评估[2.x.4974]的节点值的规范，而不是相关空间函数的[2.x.4976]规范，因为前者的计算更简单；然而，在均匀网格上，这两者只是由一个常数相关，因此我们可以用其中一个观察时间收敛顺序。




[1.x.1951]

在deal.II中实现的Runge-Kutta方法假定要解决的方程可以写成。

[1.x.1952]

另一方面，当使用有限元时，离散化的时间导数总是导致左手边存在一个质量矩阵。这可以很容易地看出，如果上述方程中的解向量[2.x.4977]实际上是节点系数的向量[2.x.4978]，其形式为变量

[1.x.1953]

用空间形状函数[2.x.4979]，然后乘以一个形式的方程

[1.x.1954]

通过测试函数，对[2.x.4980]进行积分，代入[2.x.4981]并将测试函数限制在上面的[2.x.4982]，那么这个空间离散方程的形式为

[1.x.1955]

其中[2.x.4983]是质量矩阵，[2.x.4984]是[2.x.4985]的空间离散版本（其中[2.x.4986]通常是出现空间导数的地方，但鉴于我们只考虑时间导数，这一点目前并不太关心）。换句话说，这种形式符合上面的一般方案，如果我们写成

[1.x.1956]



Runk-Kutta方法是一种时间步进方案，通过特定的一步法对[2.x.4987]进行近似。它们通常被写成以下形式

[1.x.1957]

其中对于上面的右手边的形式

[1.x.1958]

这里[2.x.4988], [2.x.4989], 和[2.x.4990]是已知的系数，确定你要使用的特定Runge-Kutta方案，[2.x.4991]是使用的时间步长。Runge-Kutta类的不同时间步长方法在级数[2.x.4992]和系数[2.x.4993]、[2.x.4994]和[2.x.4995]上有所不同，但由于可以查找这些系数的表格值，所以很容易实施。这些表格通常被称为Butcher tableaus）。

在编写本教程时，deal.II中实现的方法可分为三类。<ol> [2.x.4996] 显式Runge-Kutta；为了使一个方法成为显式，必须在上述定义[2.x.4997]的公式中，[2.x.4998]不出现在右侧。换句话说，这些方法必须满足 [2.x.4999] 。  [2.x.5000] 嵌入式（或自适应）Runge-Kutta；我们将在下面讨论其特性。  [2.x.5001] 隐式Runge-Kutta；这类方法需要解决可能是非线性系统的上述阶段[2.x.5002]，即它们至少有[2.x.5003] 个阶段[2.x.5004] 。  [2.x.5005] 许多众所周知的时间步进方案，人们通常不会将其与Runge或Kutta的名字联系起来，事实上，它们也可以用这些类别来表达。它们往往代表这些系列的最低阶成员。




[1.x.1959]

这些方法，只需要一个函数来评估[2.x.5006]，但不需要（作为隐式方法）来解决涉及[2.x.5007]的[2.x.5008]的方程。与所有显式时间步长方法一样，当选择的时间步长过大时，它们会变得不稳定。

这一类众所周知的方法包括正向欧拉、三阶Runge-Kutta和四阶Runge-Kutta（通常缩写为RK4）。




[1.x.1960]

这些方法同时使用低阶和高阶方法来估计误差，并决定是否需要缩短时间步长或可以增加。术语 "嵌入 "是指低阶方法不需要对函数[2.x.5009]进行额外的评估，而是重复使用那些必须为高阶方法计算的数据。换句话说，它基本上是免费的，而我们得到的误差估计是使用高阶方法的副产品。

这类方法包括Heun-Euler、Bogacki-Shampine、Dormand-Prince（在Matlab中为ode45，通常缩写为RK45，表示这里使用的低阶和高阶方法分别为4阶和5阶Runge-Kutta方法），Fehlberg和Cash-Karp。

在撰写本文时，只有嵌入式的显式方法得到了实现。




[1.x.1961]

隐式方法要求在每个（子）时间步中解决[2.x.5010]形式的[2.x.5011]的（可能是非线性）系统。在内部，这是用牛顿式方法完成的，因此，它们要求用户提供能够评估[2.x.5012]和[2.x.5013]或等价的[2.x.5014]的函数。

这个算子的特殊形式来自于这样一个事实，即每一个牛顿步骤都需要解一个形式的方程

[1.x.1962]

对于一些（给定的）[2.x.5015] 。无论时间步长如何，隐式方法总是稳定的，但过大的时间步长当然会影响到解的[1.x.1963]，即使数值解仍然稳定且有界。

这类方法包括后退欧拉法、隐式中点法、Crank-Nicolson法和两阶段SDIRK法（"单对角隐式Runge-Kutta "的简称，这个术语是用来表示定义时间步进方法的对角线元素[2.x.5016]都是相等的；这个特性使得牛顿矩阵[2.x.5017]可以在各阶段之间重复使用，因为[2.x.5018]每次都是相同的）。




[1.x.1964]

通过扩大我们的模型问题的解决方案，一如既往地使用形状函数[2.x.5019]并写出

[1.x.1965]

我们立即得到扩散方程的空间离散化版本为

[1.x.1966]

其中

[1.x.1967]

参见第24步和第26步以了解我们如何到达这里。由于当前问题所选择的边界条件，边界项是没有必要的。为了使用Runge-Kutta方法，我们将其改写如下。

[1.x.1968]

在代码中，我们将需要能够评估这个函数[2.x.5020]以及它的导数。

[1.x.1969]






[1.x.1970]

为了简化问题，域是二维的，网格是均匀细化的（不需要调整网格，因为我们使用的是二次有限元，而且精确解是二次的）。从二维域到三维域并不是很有挑战性。然而，如果你打算解决更复杂的问题，必须对网格进行调整（例如在步骤26中），那么就必须记住以下问题。

<ol> [2.x.5021] 在改变网格时，你需要将解投影到新的网格上。当然，从每个时间步长的开始到结束，所使用的网格应该是相同的，这个问题的出现是因为Runge-Kutta方法在每个时间步长内使用了多次方程求值。  [2.x.5022] 每次改变网格时，你都需要更新质量矩阵和它的逆值。  [2.x.5023] 这些步骤的技术可以通过查看步骤26轻易获得。


examples/step-52/doc/results.dox



[1.x.1971]

这个程序的重点不在于显示特定的结果，而在于显示它是如何做到的。这一点我们已经通过讨论上面的代码证明过了。因此，该程序的输出相对较少，只包括控制台输出和用于可视化的VTU格式的解决方案。

控制台输出既包含错误，也包含对某些方法所执行的步骤数量。

[1.x.1972]



正如预期的那样，高阶方法给出了（更）准确的解决方案。我们还看到，（相当不准确的）Heun-Euler方法增加了时间步数，以满足公差要求。另一方面，其他嵌入式方法使用的时间步数比规定的要少得多。


examples/step-53/doc/intro.dox

[2.x.5024]

[1.x.1973]

[2.x.5025] 这个程序阐述了几何学的概念和实现它的类。这些类被归入[2.x.5026]"三角形的流形描述 "的文档模块。其他信息见那里。

[2.x.5027] 本教程也可作为Jupyter Python笔记本，使用deal.II python接口。该笔记本与原始的C++程序在同一目录下可用。渲染的笔记本也可以在[1.x.1974]上查看。


[1.x.1975]

[1.x.1976]

现实问题的偏微分方程往往是在具有复杂几何形状的域上提出的。为了提供几个例子，请考虑这些情况。

- 在有限元方法的两个可以说是最重要的工业应用中，空气动力学和更普遍的流体动力学是其中之一。今天，计算机模拟被用于每架飞机、汽车、火车和船舶的设计。在这些情况下，提出偏微分方程的领域是飞机周围的空气，包括机翼、襟翼和发动机；汽车周围的空气，包括车轮、轮井、后视镜，在赛车的情况下，还有各种空气动力设备；火车周围的空气，包括车轮和车厢之间的空隙。在船舶的情况下，该领域是指有船舵和螺旋桨的船舶周围的水。

- 有限元方法的两大应用中的另一个是结构工程，其领域是桥梁、飞机机舱和机翼，以及其他通常形状复杂的固体物体。

- 有限元建模也经常被用来描述地震波的产生和传播。在这些情况下，人们需要准确地表示地壳中断层的几何形状。由于断层相交，有一定的倾角，而且往往不完全是直线，所以域经常是非常复杂的。我们可以举出更多复杂几何形状的例子，在这些例子中，我们要提出和解决一个偏微分方程。这表明，"真实 "世界比我们在这之前的几乎所有教程中所展示的要复杂得多。

因此，这个程序致力于展示如何用具体的应用来处理复杂的几何图形。特别是，它所展示的是我们如何使网格符合我们想要解决的领域。另一方面，该程序没有展示的是如何为一个领域创建一个粗的。获得粗网格的过程被称为 "网格生成"，有许多高质量的程序在这方面做得比我们做得更好。然而，deal.II确实有能力读取由网格生成器生成的多种格式的网格，然后使其适合给定的形状，可以通过变形网格或多次细化网格直至适合。从http://www.dealii.org/ 引用的deal.II常见问题页面提供了网格生成器的资源。




[1.x.1977]

让我们假设你有一个复杂的领域，并且你已经有一个粗略的网格，在某种程度上代表了这个领域的一般特征。那么在两种情况下，有必要向deal.II程序描述你的几何形状的细节。

- 网格细化。每当一个单元被细化时，有必要在三角网中引入新的顶点。在最简单的情况下，我们假设构成三角网的对象是直线段、双线性表面或三线性体。然后，下一个顶点被简单地放在旧顶点的中间。然而，对于弯曲的边界，或者如果我们想解决一个嵌入高维空间的弯曲的低维流形上的PDE，这是不充分的，因为它将不尊重实际的几何。因此，我们将不得不告诉Triangulation在哪里放置新的点。

- 积分。当使用高阶有限元方法时，经常需要使用边界的曲线近似来计算积分，即把单元的每个边缘或面描述为曲线，而不是直线段或双线性补丁。当然，在积分边界条款时也是如此（例如，不均匀的诺伊曼边界条件）。为了整合的目的，各种Mapping类提供了从参考单元到实际单元的转换。

在这两种情况下，我们需要一种方法来提供关于单个单元、其面和边的域的几何信息。这就是Manifold类开始发挥作用的地方。Manifold是一个抽象的基类，它只定义了一个接口，Triangulation和Mapping类可以通过这个接口查询领域的几何信息。从概念上讲，Manifold看待世界的方式与数学分支学科几何学看待世界的方式并无二致：域本质上只是一个点的集合，以某种方式配备了点之间的距离概念，这样我们就可以在其他一些点的 "中间 "获得一个点。

deal.II提供了一些实现Manifold所提供的接口的类，用于各种常见的几何形状。另一方面，在这个程序中，我们将只考虑一种非常常见的、简单得多的情况，即我们要解决的域的（一部分）可以通过转换一个简单得多的域（我们将称之为 "参考域"）来描述的情况。在数学语言中，这意味着该（部分）域是一个[1.x.1978]。图表由一个平滑函数描述，该函数从较简单的域映射到图表（"向前推 "函数）及其逆向（"向后拉 "函数）。如果域作为一个整体不是一个图表（例如，球体的表面），那么它通常可以被描述为一个图表的集合（例如，北半球和南半球各自是一个图表），然后域可以被描述为一个[1.x.1979]。

如果一个域可以被分解成一个图集，那么我们需要做的就是为每个图集提供回拉和推送函数。在deal.II中，这意味着提供一个从ChartManifold派生的类，而这正是我们在这个程序中要做的。




[1.x.1980]

为了说明如何在deal.II中使用图表描述几何形状，我们将考虑一个源于[1.x.1981]的应用的案例，使用D. Sarah Stamps提供的数据集。在具体应用中，我们对描述[1.x.1982]下的地幔流动感兴趣，这是一个两个大陆板块漂移的区域。不拐弯抹角，我们想要描述的几何形状看起来是这样的。

[2.x.5028]

特别是，虽然你在这里看不到，但顶部的表面不仅仅是由高程着色，实际上，它是按照正确的地形变形的。虽然实际的应用在这里并不重要，但几何学是相关的。我们感兴趣的领域是地球的一部分，范围从表面到500公里的深度，从格林威治子午线以东26度到35度，从赤道以北5度到南10度。

这种对几何学的描述建议从一个盒子[2.x.5029]开始（以度、度数和米为单位），并提供一个地图[2.x.5030]，以便[2.x.5031]其中[2.x.5032]是我们寻求的领域。  然后，[2.x.5033]是一个图表，[2.x.5034]是回拉运算符，[2.x.5035]是前推运算符。如果我们需要一个点[2.x.5036]是其他点[2.x.5037]的 "平均值"，那么ChartManifold类首先应用回拉得到[2.x.5038]，将其平均到一个点[2.x.5039]，然后计算出[2.x.5040]。

因此，我们这里的目标是实现一个描述[2.x.5041]和[2.x.5042]的类。如果地球是一个球体，那么这并不困难：如果我们用[2.x.5043]表示[2.x.5044]的点（即经度向东计算，纬度向北计算，海拔相对于零深度），那么

[1.x.1983]

提供直角坐标系中的坐标，其中[2.x.5045]是球体的半径。然而，地球不是一个球体。

<ol> [2.x.5046]它在两极是扁平的，在赤道是较大的：半主轴比半副轴长约22公里。我们将使用[1.x.1984]的地球形状参考标准来说明这一点。在WGS 84中，用于从经度、纬度和海拔获得直角坐标位置的公式是

[1.x.1985]

  其中 [2.x.5047] ，而半径和椭圆度由 [2.x.5048] 给出。在这个公式中，我们假设正弦和余弦的参数是以度数而不是弧度来计算的（尽管我们将不得不在代码中改变这个假设）。

[2.x.5049] 它的地形是山脉和山谷的形式。我们将使用真实的地形数据来说明这一点（见下文对这些数据来源的描述）。使用这个数据集，我们可以在地球表面的经纬度网格上查找高程。从方框[2.x.5050]开始，我们将首先在垂直方向上拉伸它，然后再把它交给WGS 84函数：如果[2.x.5051]是经度[2.x.5052]和纬度[2.x.5053]的高度，那么我们定义

[1.x.1986]

  使用这个函数，盒子[2.x.5054]的顶面被移到正确的地形上，底面保持原来的位置，中间的点被线性内插。  [2.x.5055]

利用这两个函数，我们就可以将整个推送函数[2.x.5056]定义为

[1.x.1987]

此外，我们将不得不定义这个函数的逆运算，即回拉运算，我们可以将其写为

[1.x.1988]

我们可以通过倒置上面的公式得到这个函数的一个分量。

[1.x.1989]

计算[2.x.5057]也是可能的，不过要笨拙得多。我们不会在这里展示这个公式，而是只提供程序中的实现。




[1.x.1990]

在这个程序中，我们需要解决一些问题。在最大范围内，我们需要编写一个实现ChartManifold接口的类。这涉及到一个函数[2.x.5058]，该函数在参考域[2.x.5059]中取一个点，并使用上面概述的函数[2.x.5060]将其转换为实空间，以及实现[2.x.5061]的反函数[2.x.5062] 。我们将在下面的[2.x.5063]类中这样做，该类本质上看起来像这样。

[1.x.1991]



上述转换有两个部分：WGS 84转换和地形转换。因此，[2.x.5064]类将有额外的（非虚拟）成员函数[2.x.5065]和[2.x.5066]来实现这两部分，以及相应的回拉函数。

WGS 84的转换函数并不特别有趣（尽管它们实现的公式令人印象深刻）。更有趣的部分是地形变换。回顾一下，为此我们需要评估高程函数[2.x.5067] 。当然，这没有公式。地球就是这样，人们能做的最好的事情就是从一些表格中查找海拔高度。事实上，这就是我们要做的。

我们使用的数据最初是由[1.x.1992]创建的，是从美国地质调查局（USGS）下载的，并由D. Sarah Stamps处理，他还编写了WGS 84转换函数的初始版本。这样处理过的地形数据被储存在一个文件[2.x.5068]中，解压后看起来是这样的。

[1.x.1993]

数据格式为[2.x.5069]，其中前两栏以赤道以北的度数和格林威治子午线以东的度数提供。最后一列是以WGS84零点以上的米数为单位。

在转换函数中，我们需要对给定的经度[2.x.5071]和纬度[2.x.5072]评估[2.x.5070] 。一般来说，这个数据点是不可用的，我们将不得不在相邻的数据点之间进行内插。编写这样一个插值程序并不特别困难，但它有点乏味，而且容易出错。幸运的是，我们可以以某种方式将这个数据集塞进一个现有的类中。  [2.x.5073] .不幸的是，这个类并不完全适合，所以我们需要绕过它。问题来自于我们初始化这个类的方式：在其最简单的形式下，它需要一个数值流，它假设在[2.x.5074]平面（或者，这里是[2.x.5075]平面）形成一个等距的网格。这就是它们在这里所做的，某种程度上：它们的顺序是纬度第一，经度第二；更尴尬的是，第一列从最大的数值开始往下数，而不是通常的其他方式。

现在，虽然教程程序是为了说明如何用deal.II编码，但它们不一定要满足与生产代码相同的质量标准。在生产代码中，我们会写一个函数来读取数据，并（i）自动确定第一列和第二列的外延，（ii）自动确定每个方向的数据点的数量，（iii）无论数据的排列顺序如何，都要进行插值，如果有必要的话，在读取和呈现给[2.x.5076]类之间切换顺序。

另一方面，辅导课程最好是短小精悍，展示关键点，而不是纠缠于不重要的方面，从而掩盖了我们真正想要展示的东西。因此，我们将允许自己有一点回旋余地。

- 由于这个程序只针对东非裂谷地区周围的特定几何形状，并且由于这正是数据文件所描述的区域，我们将在程序中硬编码有[2.x.5077]个数据。

- 我们将硬编码数据的边界 [2.x.5078] 。

- 我们将对[2.x.5079]类撒谎：该类将只看到这个数据文件最后一列的数据，我们将假装数据的排列方式是：在第一个坐标方向上有1139个数据点，这些数据点按[1.x.1994]的顺序排列，但在一个区间[2.x.5080]（不是否定的边界）。然后，当我们需要查询某个纬度[2.x.5081]的东西时，我们可以向内插表类索取[2.x.5082]的数值。有了这个小技巧，我们就可以避免在从文件中读取数据的时候切换顺序。

所有这些都需要一个本质上看起来像这样的类。

[1.x.1995]



注意[2.x.5083]函数如何否定了纬度。它还将我们在其他地方使用的格式[2.x.5084]转换为表格中使用的纬度-经度格式。最后，它的参数以弧度为单位，因为我们在程序中的其他地方也是这样做的，但随后将它们转换为用于表格查询的基于度的系统。正如你在下面的实现中所看到的，该函数还有几个（静态）成员函数，我们将在初始化[2.x.5085]成员变量时调用：该变量的类类型有一个构造函数，允许我们在构造时正确设置一切，而不是在以后填充数据，但这个构造函数需要一些不能就地构造的对象（至少在C++98中不能）。因此，我们要在初始化中传递的每个对象的构造都发生在一些静态成员函数中。

在讨论了我们要实施的事情的大体轮廓之后，让我们去看程序，并展示它在实践中是如何做的。


examples/step-53/doc/results.dox



[1.x.1996]

运行程序会产生一个网格文件[2.x.5086]，我们可以用任何可以读取VTU文件格式的常规可视化程序来进行可视化。如果只看网格本身，实际上很难看到任何不只是看起来像一块完全圆形的球体的东西（尽管如果修改程序，使其确实产生一个球体，并同时看它们，整体球体和WGS 84形状之间的差异是相当明显的）。很明显，地球实际上是一个相当平坦的地方。当然，我们已经从卫星图片中知道了这一点。然而，我们可以通过对细胞的体积进行着色来找出更多的东西。这既产生了沿顶面的轻微色调变化，也为可视化程序提供了应用其着色算法的东西（因为单元的顶面现在不再只是与球体的切线，而是倾斜的）。

[2.x.5087]

然而，至少就视觉化而言，这仍然不是太令人印象深刻。相反，让我们以一种可视化的方式，使我们显示出沿顶面的实际海拔。换句话说，我们想要一张这样的图片，有难以置信的细节。

[2.x.5088]

这张照片的放大显示了相当清楚的垂直位移（这里，从西-西北方向看裂谷上空，[1.x.1997]、[1.x.1998]和[1.x.1999]的三座山峰在[1.x.2000]、[1.x.2001]和向[1.x.2002]的巨大平坦处）。

[2.x.5089]


这些图片是经过三个小的修改后产生的。<ol> [2.x.5090] 在这两张图片中，第一张图片的顶面增加了第七个网格细化，第二张图片总共增加了九个。在第二张图片中，水平方向的网格大小约为1.5km，垂直方向的网格大小略低于1km。(这张图也是用一个更有分辨率的数据集制作的；但是，它太大了，不能作为教程的一部分分发)。

   [2.x.5091] 增加以下函数，在给定一个点[2.x.5092]时，通过将该点转换为参考WGS 84坐标并只保留深度变量来计算海拔高度（因此，该函数是[2.x.5093]函数的简化版本）。

[1.x.2003]



   [2.x.5094] 在[2.x.5095]函数的底部添加以下一块。

[1.x.2004]

[2.x.5096] 这最后一段代码首先在网格上创建一个[2.x.5097]有限元空间。然后使用[2.x.5098]对顶部边界的每个节点（边界指标为5的节点）进行高程函数的评估。我们在这里用ScalarFunctionFromFunctionObject类来包装对[2.x.5099]的调用，使一个普通的C++函数看起来像一个派生自Function类的对象，我们想在[2.x.5100]中使用。然后像往常一样用DataOut输出这个向量，并可以如上图所示进行可视化。




[1.x.2005]

如果你放大上图所示的网格并仔细观察，你会发现在悬空节点处，连接到悬空节点的两条小边与相邻单元的大边的位置不完全相同。这可以通过使用不同的表面描述来更清楚地显示出来，在这种描述中，我们放大了垂直地形以增强效果（由Alexander Grayver提供）。

[2.x.5102]

那么这里发生了什么？部分原因是，这只是视觉化的结果，但也有一个潜在的真正原因。

[2.x.5103] [2.x.5104] 当你使用任何一个常见的可视化程序对网格进行可视化时，它们真正显示的只是一组在三维空间中被绘制成直线的边缘。这是因为几乎所有用于可视化的数据文件格式都只将六面体单元描述为三维空间中八个顶点的集合，而不允许任何更复杂的描述。这就是为什么[2.x.5105]需要一个可以设置为大于1的参数的主要原因）。这些线性边缘可能是你进行实际计算的单元格的边缘，也可能不是，这取决于你在使用FEValues进行积分时使用何种映射。当然，在默认情况下，FEValues使用的是线性映射（即MappingQ1类的对象），在这种情况下，一个3D单元确实完全由其8个顶点描述，它所填充的体积是这些点之间的三线插值，从而产生了线性边缘。但是，你也可以使用三次方、三次立方、甚至更高阶的映射，在这些情况下，每个单元的体积将由二次方、三次方或高阶多项式曲线来限定。然而，你只能在可视化程序中看到这些带有线性边缘的曲线，因为如前所述，文件格式不允许描述细胞的真实几何形状。

   [2.x.5106] 也就是说，为了简单起见，让我们假设你确实在使用三线性映射，那么上面显示的图像就是你形成积分的单元的忠实代表。在这种情况下，一般来说，悬空节点上的小单元并不与大单元紧密贴合，而是留有间隙，或者可能与大单元相交。这是为什么呢？   因为当三角测量需要在它想要细化的边缘上增加一个新的顶点时，它会询问流形描述这个新的顶点应该在哪里，流形描述通过（在从ChartManifold派生的几何体的情况下）将线的相邻点拉回到参考域，平均它们的位置，并将这个新的位置推到真实域，从而适当地返回这样一个点。但是这个新的位置通常不是沿着相邻顶点之间的直线（在实空间），因此，形成精炼边缘的两条小直线并不完全位于形成悬挂节点的未精炼边的一条大直线上。  [2.x.5107]

如果你使用MappingQ类的高阶映射，情况会稍微复杂一些，但没有根本的不同。我们暂且采用二次映射（高阶映射也没有什么根本性的变化）。那么你需要把你所整合的单元格的每条边想象成一条二次曲线，尽管你实际上不会看到可视化程序以这种方式绘制。但请先想象一下。那么，MappingQ采用哪条二次曲线呢？它是经过边缘末端的两个顶点以及中间的一个点的二次曲线，它从流形中查询。在未精炼一侧的长边的情况下，这当然正是悬空节点的位置，所以描述长边的二次曲线确实经过了悬空节点，这与线性映射的情况不同。但是两条小边也是二次曲线；例如，左边的小边会经过长边的左顶点和悬挂节点，再加上它从流形中查询到的一个点。因为如前所述，流形沿左小边中途返回的点很少完全在描述长边的二次曲线上，二次短边通常不会与二次长边的左半边重合，右短边也是如此。换句话说，同样的，大单元格和它在悬挂节点上的小邻居的几何形状并不相依相偎。

这一切引出了两个问题：第一，这是否重要，第二，这是否可以解决。让我们在下文中讨论这些问题。

[2.x.5108] [2.x.5109] 这重要吗？几乎可以肯定的是，这取决于你所求解的方程。例如，众所周知，在复杂几何体上求解气体动力学的欧拉方程需要高度精确的边界描述，以确保衡量靠近边界的流动的量的收敛。另一方面，具有椭圆成分的方程（如拉普拉斯方程或斯托克斯方程）通常对这些问题比较宽容：无论如何都要做正交来近似积分，鉴于每个悬空节点的重叠或间隙的体积只有[2.x.5110]，进一步近似几何可能不会像人们担心的那样造成伤害。]，即使是线性映射，对于度数为[2.x.5112]的映射，也只有[2.x.5111]。 (你可以通过考虑到在2D中，间隙/重叠是一个三角形，底[2.x.5113]，高[2.x.5114]；在3D中，它是一个类似金字塔的结构，底面积[2.x.5115]，高[2.x.5116] 。类似的考虑也适用于高阶映射，其中空隙/重叠的高度为 [2.x.5117] .)换句话说，如果你使用线性元素的线性映射，你所积分的体积的误差已经与使用通常的高斯正交的积分误差处于同一水平。当然，对于更高阶的元素，人们将不得不选择匹配的映射对象。

  关于为什么不值得过分担心这个问题的另一个观点是，在数值分析界肯定没有人说这些问题是使用复杂几何体时需要注意的一个主要问题。如果从业者之间似乎并不经常讨论这个问题，如果有的话，那么它至少不是人们认定的一个普遍问题。

  这个问题与在弯曲的边界上有悬挂的节点没有什么不同，在这种情况下，边界的几何描述通常会将悬挂的节点拉到边界上，而大的边缘仍然是直的，使得相邻的小单元和大单元不能相互匹配。虽然这种行为从一开始就存在于deal.II中，在流形描述出现之前的15年，但在邮件列表的讨论或与同事的交谈中，它从未出现过。

   [2.x.5118] 能否修复？原则上是的，但这是一个复杂的问题。我们暂且假设我们只会使用MappingQ1类，也就是线性映射。在这种情况下，每当三角化类需要沿着一条将成为悬空节点的边建立一个新的顶点时，它就会直接取相邻顶点的平均值[1.x.2006]，也就是说，不问流形的描述。这样一来，该点就位于长直边上，两条短直边将与一条长直边匹配。只有当所有相邻的单元都被细化，并且该点不再是一个悬挂的节点时，我们才会用通过流形得到的坐标来替换它的坐标。这在实现上可能比较麻烦，但肯定是可行的。

  更复杂的问题出现了，因为人们可能想使用高阶的MappingQ对象。在这种情况下，Triangulation类可以自由选择悬挂节点的位置（因为长边的二次曲线可以选择通过悬挂节点的方式），但是MappingQ类在确定中边点的位置时，必须确保如果该边是相邻的较粗单元的长边的一半，那么中点不能从流形中获得，而必须沿着长二次边选择。对于立方体（和所有其他奇数）映射，这个问题又有点复杂了，因为人们通常安排立方体边沿着边的1/3和2/3点走，因此必然要通过悬挂的节点，但这可能是可以解决的。在任何情况下，即使如此，这也有两个问题。

  - 在细化三角函数时，三角函数类不可能知道将使用什么映射。事实上，在同一个程序中，一个三角函数在不同的情况下被使用的情况并不罕见。如果使用的映射决定了我们是否可以自由选择一个点，那么，三角剖分应该如何定位新的顶点？

  - 映射是纯粹的局部构造：它们只对孤立的单元起作用，而这正是有限元方法的重要特征之一。要问一条边的一个顶点是否是悬空节点，需要查询一个单元的邻域；此外，这样的查询不只是涉及到三维中一个单元的6个面的邻域，而是可能需要遍历与一条边相连的大量的其他单元。即使可以做到这一点，人们仍然需要根据邻域的样子做不同的事情，产生的代码可能非常复杂，难以维护，而且可能很慢。

  因此，至少在目前，这些想法都没有被实施。这导致了不连续的几何形状的不良后果，但是，正如上面所讨论的，这种影响在实际操作中似乎并不构成问题。

[2.x.5119]


examples/step-54/doc/intro.dox

[2.x.5120]

[1.x.2007]

[2.x.5121] 这个程序阐述了工业几何的概念，使用与OpenCASCADE库（http://www.opencascade.org）接口的工具，允许指定任意的IGES文件来描述你的几何形状的边界。

[2.x.5122]

[1.x.2008]

[1.x.2009]


在之前的一些教程中（第1步、第3步、第5步、第6步和第49步等），我们已经学会了如何使用deal.II中提供的网格细化方法。这些教程展示了如何利用这些工具为一次模拟产生一个精细的网格，如步骤3；或者从一个粗大的网格开始，在自适应细化的网格上进行一系列模拟，如步骤6的情况。无论采取哪种方法，网格细化都需要对计算域边界进行适当的几何描述，以便在每次细化时将新的网格节点放到边界面上。例如，第5步显示了如何创建一个圆形网格，将一个圆形流形对象自动附加到计算域上，从而使位于边界上的面被细化到圆形上。第53步显示了如何用一个由实验获得的数据定义的流形来做这件事。但是，至少就基本边界形状而言，deal.II实际上只提供了圆、球、盒和其他基本组合。在本教程中，我们将展示如何使用一组开发的类来导入任意的CAD几何图形，将它们分配到计算域的所需边界，并在这种复杂的形状上细化计算网格。




[1.x.2010]

在最常见的工业实践中，任意形状的物体的几何模型是通过计算机辅助设计（CAD）工具实现的。在过去的几十年里，CAD建模器的使用已经普及，因为它们可以为每个设计对象生成一个完整的虚拟模型，通过计算机可以在实物制作之前对其最精细的细节进行可视化、检查和分析。  从数学的角度来看，CAD建模人员的引擎是由分析几何学来代表的，特别是由参数化的曲线和曲面，如B-splines和NURBS，它们足够丰富，可以代表大多数的实际利益的表面。  一旦一个虚拟模型准备好了，所需物体的所有几何特征都被存储在文件中，这些文件实质上包含了构成该物体的参数化曲面和曲线的系数。根据用于定义几何模型的具体CAD工具，当然有几种不同的文件格式，可以组织CAD模型的信息。为了提供一个跨CAD工具交换数据的共同基础，美国国家标准局在1980年发布了初始图形交换代表（IGES）中性文件格式，在本例中使用。

[1.x.2011]

为了导入和查询CAD模型，deal.II库为CAD建模的OpenCASCADE开源库实现了一系列的包装函数。这些函数允许将IGES文件导入OpenCASCADE本地对象，并将其包裹在一系列Manifold类中。

一旦从IGES文件导入，模型就被存储在一个[2.x.5123]中，这是OpenCASCADE框架中定义的通用拓扑实体。从[2.x.5124]中，就可以访问构成它的所有子形状（如顶点、边和面），以及它们的几何描述。在deal.II框架中，组成一个形状的拓扑实体被用来创建一个相应的Manifold表示。在步骤6中，我们看到了如何使用[2.x.5125]来创建一个超球体，它自动将一个SphericalManifold附加到所有边界面。这保证了边界面在网格细化过程中保持在球体或圆上。CAD建模界面的功能被设计为保留相同的结构，允许用户使用导入的CAD形状建立一个投影仪对象，保持我们在其他教程程序中使用的相同程序，即把这种投影仪对象分配给粗略网格的单元、面或边。在每个细化周期，新的网格节点将通过将现有对象的中点投影到指定的几何体上而自动生成。

与球形或圆形边界不同，具有复杂几何形状的边界带来的问题是，在规定形状上细化后创建的新节点最好放在哪里。例如，PolarManifold将周围的点转换为极坐标，计算该坐标系中的平均值（对每个坐标单独计算），最后将点转换回直角坐标。

不过，在一个任意的复杂形状的情况下，一个合适的新节点的位置选择不可能那么容易确定。deal.II中的OpenCASCADE封装器提供了几个采用不同投影策略的投影仪类。第一个投影仪，在[2.x.5126]类中实现，只用于边缘细化。它的建立是给它分配一个维度为1的拓扑形状，或者是一个[2.x.5127]（这是一个复合形状，由几个连接的[2.x.5128]组成），并细化网格边缘，找到新的顶点作为点，将CAD曲线部分的曲线长度分成两个偶数部分，位于原始边缘的顶点之间。

[2.x.5129]


在[2.x.5130]类中实现了一个不同的投影策略。在构造时分配的[2.x.5131]可以是任意的（图形、面、边的集合或单个面或边都可以）。新的单元格节点首先通过对周围的点进行平均计算，方法与FlatManifold相同。在第二步中，所有的新节点将沿着形状的法线方向被投射到[2.x.5132]。如果没有法线投影，则选择最接近形状的点--通常位于形状的边界上--。  如果形状是由几个子形状组成的，则投影到每个子形状上，并选择最近的投影点。

[2.x.5133][2.x.5134] 。

正如我们即将体验到的，对于某些形状，将投影方向设置为CAD表面的法线，将不会导致合适质量的表面网格元素。这是因为CAD表面的法线方向原则上与网格需要新节点所在的方向无关。在这种情况下，[2.x.5135]类可以提供帮助。这个类的构造是指定一个[2.x.5136]（至少包含一个面）和一个方向，所有的投影将沿着这个方向进行。新的点将被计算出来，首先对周围的点进行平均化（就像FlatManifold的情况一样），然后沿着构造时使用的方向，在拓扑形状和通过所得到的点的线之间取得最近的交点。  这样一来，用户就可以对投影方向有更高的控制，以确保良好的网格质量。

[2.x.5137]


当然，后一种方法只有在表面的方向相当统一时才有效，这样就可以确定一个单一的投影方向。在表面方向接近投影方向的情况下，甚至有可能找不到方向性的投影。为了克服这些问题，[2.x.5138]类实现了第三个投影算法。[2.x.5139]类的建立是将一个[2.x.5140]（至少包含一个面）分配给构造函数，其工作方式与[2.x.5141]完全一样。但是，正如该类的名字所暗示的，[2.x.5142]试图想出一个合适的对要精化的网格元素的法线方向的估计，并将其用于新节点在CAD面上的投影。如果我们考虑二维空间中的网格边缘，其轴线方向是一个方向，沿着这个方向分割，以产生两个相同长度的新单元。我们在此将这一概念扩展到三维空间，并将所有新节点的投影方向近似于单元格的法线。

在下图中，受本教程中考虑的几何图形的启发，我们尝试比较所考虑的三种投影仪的行为。从左边可以看出，给定原始单元（蓝色），用法线投影找到的新点的位置不允许生成均匀的新元素（红色）。这种情况在进一步的细化步骤中会变得更糟。  由于我们考虑的几何体在某种程度上垂直于水平方向，以水平方向为投影方向的方向性投影（中心图像）在获得新的网格点方面做得相当好。然而，由于图片底部的表面几乎是水平的，我们可以预期在这些区域进行进一步细化步骤时，会出现问题。最后，右边的图片显示，位于单元轴上的节点将导致两个新单元具有相同的长度。当然，三维的情况会比这个简单的二维案例中描述的情况更复杂一些。然而，这个测试的结果证实，当考虑到任意形状的表面时，除非你有一个已知的更具体的方法，否则在测试的三种方法中，法线方向是最佳方法。


[2.x.5143]




[1.x.2012]

在这个程序中，我们将考虑为一个描述船头的真实几何体创建一个表面网格（这个几何体经常被用于CAD和网格生成的比较中，并且可以免费获得）。我们得到的表面网格可以用来解决边界元素方程，以模拟水在船舶周围的流动（类似于step-34的方式），但我们不会在这里尝试这样做。为了让你了解我们所考虑的几何形状，这里有一张图片。

[2.x.5144]

在程序中，我们从文件中读取几何体和粗略的网格，然后采用上面讨论的几个选项来放置新的顶点，进行一系列的网格细化步骤。


examples/step-54/doc/results.dox



[1.x.2013]

程序的执行会产生一系列的网格文件[2.x.5145]，我们可以用任何可以读取VTK文件格式的常用可视化程序来进行可视化。

下表说明了采用正常投影策略得到的结果。表中的前两行显示的是逐步细化的网格的侧视图，覆盖在精确几何体的非常精细的渲染上。深红色和浅红色的区域只是表示当前的网格或精细的几何体更接近观察者；这种区别没有任何特别深刻的意义。最后一排图片描述了第二排中相同网格的正视图（镜像到几何体的两边）。


[2.x.5146]

从图片中可以看出，正如我们所预料的那样，当应用于具有明显曲率变化的表面时，正常的细化策略无法产生良好的形状的元素。这在船体的球体上尤其明显，所有的新点都被放置在球体的上部，而下部则完全没有被解决。

下表的排列方式与上表相同，说明了采用方向性投影方法获得的结果，其中选择的投影方向是Y轴（在每幅图像的左下方用一个小的黄色箭头表示）。


[2.x.5147]

这些图像证实，用定向投影得到的网格质量明显高于沿表面法线投影得到的网格。然而，在球体底部观察到一些在Y方向上拉长的元素，那里的表面几乎与选择的投影方向平行。

最后的测试显示了使用面的法线投影的结果。

[2.x.5148]

图片证实了法线投影的方法导致网格在整个细化步骤中保持均匀的间隔。同时，这些网格很好地表现了原始的几何形状，甚至在灯泡的底部区域也是如此，这一点在使用定向投影仪或法线投影仪时并没有得到很好的恢复。


examples/step-55/doc/intro.dox

[2.x.5149]

[1.x.2014]




[2.x.5150] 作为这个程序的前提条件，你需要安装PETSc或Trilinos和p4est库。在[1.x.2015]文件中描述了deal.II与这些附加库的安装情况。

[1.x.2016]

[1.x.2017]

在第40步的基础上，本教程展示了如何使用MPI与PETSc或Trilinos进行线性代数，并行解决具有多个组件的线性PDEs。为此，我们返回到步骤22中讨论的斯托克斯方程。编写本教程的动机是在第40步（并行拉普拉斯）和第32步（针对时间相关问题的并行耦合斯托克斯与布西尼斯克）之间提供一个中间步骤（双关）。

本教程的学习成果是。

- 你能够并行地解决有多个变量的PDEs，并能将其应用于不同的问题。

- 你了解最佳预处理程序的概念，并能对某一特定问题进行检查。

- 你能够使用免费的计算机algreba系统SymPy（https://sympy.org）来构建制造的解决方案。

- 你可以为并行程序实现各种其他任务：错误计算、编写图形输出等。

- 你可以将矢量场、流线和矢量的轮廓可视化。

我们要解决的是满足斯托克斯方程的速度[2.x.5151]和压力[2.x.5152]，其内容为

[1.x.2018]






[1.x.2019]

请确保你阅读（甚至更好：尝试）步骤22中 "可能的扩展 "部分的 "块舒尔补码预处理 "所描述的内容。就像那里描述的那样，我们将使用Krylov方法和块状预处理程序来解决块状系统。

我们的目标是为线性系统构造一个非常简单的（也许是最简单的）最优预处理。如果预处理系统的迭代次数与网格大小无关，则该预处理程序被称为 "最优 "或 "最优复杂性"[2.x.5153] 。你可以把这个定义扩展到要求与使用的处理器数量无关（我们将在结果部分讨论这个问题），计算域和网格质量，测试案例本身，有限元空间的多项式程度，等等。

为什么恒定的迭代次数被认为是 "最佳 "的？假设离散化的PDE给出一个有N个未知数的线性系统。因为来自有限元离散化的矩阵是稀疏的，矩阵-向量乘积可以在O(N)时间内完成。先决条件的应用充其量也只能是O(N)（例如可以用多网格方法来做）。如果解决线性系统所需的迭代次数与[2.x.5154]无关（因此也与N无关），那么解决该系统的总成本将是O(N)。不可能战胜这个复杂度，因为即使是查看右手边的所有条目也已经需要O(N)的时间。更多信息见 [2.x.5155] ，第2.5章（多网格）。

这里描述的预处理程序甚至比步骤22中描述的更简单，通常需要更多的迭代，因此需要更多的时间来解决。在考虑预处理程序时，最优性并不是唯一重要的衡量标准。但是一个最优的、昂贵的预处理程序通常比一个更便宜的、非最优的预处理程序更可取。这是因为，最终，随着网格尺寸越来越小，线性问题越来越大，前者将最终击败后者。

[1.x.2020]

我们对线性系统进行预处理

[1.x.2021]



块状对角线预处理器

[1.x.2022]

其中[2.x.5156]是舒尔补。

对于[2.x.5157]的这种选择，假设我们准确地处理了[2.x.5158]和[2.x.5159]（这是一种 "理想化 "的情况），预处理的线性系统有三个独立于[2.x.5160]的特征值，因此是 "最优 "的。  见 [2.x.5161] 中的6.2.1节（特别是第292页）。作为比较，在第22步中使用理想版的上块三角预处理（也用于第56步）会使所有的特征值都等于1。

我们将使用[2.x.5162]中的逆运算的近似值，它（几乎）独立于[2.x.5163]。在这种情况下，我们可以再次证明，特征值是独立于[2.x.5164]的。对于Krylov方法，我们选择MINRES，它对分析很有吸引力（迭代次数被证明与[2.x.5165]无关，见上述书中第6.2.1章的其余部分），从计算的角度看很好（例如比GMRES更简单、更便宜），而且适用（矩阵和预处理器是对称的）。

对于近似，我们将使用压力空间中的质量矩阵的CG解来近似[2.x.5166] 的作用。请注意，质量矩阵在光谱上等同于[2.x.5167] 。我们可以预期CG迭代的数量与[2.x.5168]无关，即使使用ILU这样的简单预处理程序。

对于速度块[2.x.5169]的近似，我们将执行一个单一的AMG V-循环。在实践中，这种选择并不完全独立于[2.x.5170]，这可以解释迭代数的轻微增加。一个可能的解释是，最粗的层次将被精确解决，而最粗的矩阵的层次数和大小是不可预测的。




[1.x.2023]

我们将根据经典的Kovasznay问题构建一个制造的解决方案，见 [2.x.5171] 。这里是一个由x速度着色的解决方案的图像，包括速度的流线。

  [2.x.5172]

不过，我们在这里必须作弊，因为我们不是在解决非线性的纳维-斯托克斯方程，而是解决没有对流项的线性斯托克斯系统。因此，为了重现完全相同的解，我们用科瓦兹内问题的解来制造解的方法。这将有效地把对流项移到右手边 [2.x.5173] 。

右手边是用脚本 "reference.py "计算的，我们使用精确的解决方案来计算边界条件和误差。


examples/step-55/doc/results.dox



[1.x.2024]

正如上面的讨论所预期的那样，迭代次数与处理器的数量无关，只与[2.x.5174]有非常小的关系。

[2.x.5175]

[2.x.5176]

虽然PETSc的结果显示迭代次数不变，但使用Trilinos时，迭代次数增加。这可能是由于AMG预处理程序的不同设置造成的。出于性能方面的考虑，我们不允许在几千个未知数以下进行粗化。由于粗解器是精确求解（我们默认使用LU），层数的变化将影响V型循环的质量。因此，对于较小的问题规模，V型循环更接近于精确求解器。

[1.x.2025]

[1.x.2026]

[1.x.2027]

玩弄平滑器、平滑步骤和Trilinos AMG的其他属性，以实现最佳预处理。

[1.x.2028]

这一变化需要将外部求解器改为GMRES或BiCGStab，因为系统不再是对称的了。

你可以在对流项[2.x.5178]中规定精确的流动解，即[2.x.5177] 。如果你把右手边设置为零，这应该可以得到与原问题相同的解。

[1.x.2029]

到目前为止，这个教程程序在每一步都会对网格进行全局细化。将[2.x.5179]中的代码替换为如下内容

[1.x.2030]

使得探索自适应网格细化变得简单。


examples/step-56/doc/intro.dox

[1.x.2031]

[2.x.5180]

[1.x.2032]

[1.x.2033]

[1.x.2034]

本教程的目的是为斯托克斯方程创建一个高效的线性求解器，并将其与其他方法进行比较。  在这里，我们将使用带有几何多栅的FGMRES作为预处理速度块，我们将在结果部分显示，这比step-22中使用的线性求解器（包括 "可能的扩展 "中描述的方案）从根本上来说是一种更好的方法。  从根本上说，这是因为只有多网格才有可能得到[2.x.5181]的求解时间，其中[2.x.5182]是线性系统的未知数的数量。使用Timer类，我们收集一些统计数据来比较设置时间、求解时间和迭代次数。我们还计算了误差，以确保我们所实现的是正确的。

让 [2.x.5183] 和 [2.x.5184] 。斯托克斯方程的非维度形式如下。

[1.x.2035]



请注意，我们使用的是变形张量，而不是[2.x.5185]（关于两者之间的区别的详细描述可以在步骤22中找到，但总的来说，变形张量的物理性更强，也更昂贵）。

[1.x.2036]

离散方程的微弱形式自然导致了以下速度场和压力场的节点值的线性系统。

[1.x.2037]



我们的目标是比较几种解决方法。  虽然step-22使用 "Schur补足法 "分两步解决线性系统，但我们本着step-22的 "结果 "部分所概述的方法的精神，使用FMGRES和一个有效的预处理器一次性地攻击块系统。其思路如下：如果我们找到一个块状预处理程序[2.x.5186]，使矩阵的

[1.x.2038]



是简单的，那么使用该预处理的迭代求解器将在几次迭代后收敛。请注意，我们在这里做的是正确的预处理。  使用舒尔补码[2.x.5187]，我们发现

[1.x.2039]



是一个很好的选择。设[2.x.5188]是[2.x.5189]的近似值，[2.x.5190]是[2.x.5191]的近似值，我们看到

[1.x.2040]



由于[2.x.5192]的目的只是作为一个预处理程序，我们将在上式中使用右边的近似值。

正如步骤22所讨论的，[2.x.5193]，其中[2.x.5194]是压力质量矩阵，通过使用CG与ILU作为预处理程序近似求解，[2.x.5195]是通过多种方法之一得到的：使用CG和ILU作为预处理程序求解线性系统，仅仅使用ILU的一次应用，使用CG和GMG（步骤16中描述的几何多网格）作为预处理程序求解线性系统，或者仅仅执行GMG的一个V-循环。

作为比较，我们也在整个系统上使用直接求解器UMFPACK来比较我们的结果，而不是FGMRES。  如果你想使用直接求解器（如UMFPACK），系统需要是可逆的。为了避免恒定压力给定的一维无效空间，我们将第一个压力未知数固定为零。这对迭代求解器来说是没有必要的。




[1.x.2041]

测试问题是一个 "制造的解决方案"（详见步骤7），我们选择 [2.x.5196] 和 [2.x.5197] 。我们在域的整个边界上对速度应用迪里切特边界条件 [2.x.5198] 。为了执行边界条件，我们可以直接使用我们的参考解。

如果你在deal.II手册中查找创建一个从[2.x.5199]派生的类所需要的东西，你会发现这个类有许多[2.x.5200]函数，包括[2.x.5201] [2.x.5202] [2.x.5203] 等，所有这些都可以被重载。  deal.II的不同部分将需要这些特定函数中的不同部分。这在一开始会让人感到困惑，但幸运的是，你真正需要实现的只有[2.x.5204]。Function类中的其他虚拟函数在里面有默认的实现，会默认调用你对[2.x.5205]的实现。

注意，我们的参考解满足[2.x.5206] 。此外，压力被选择为平均值为零。  对于步骤7的 "制造解决方案的方法"，我们需要找到[2.x.5207]，以便。

[1.x.2042]



使用上面的参考解，我们得到。

[1.x.2043]



[1.x.2044]

因为我们在线性系统中没有强制要求平均压力为零，所以我们需要在求解后对解决方案进行后处理。为了做到这一点，我们使用[2.x.5208]函数来计算压力的平均值，以从压力中减去它。




[1.x.2045]

我们在这里实现几何多网格的方式只对速度变量（即上面描述的[2.x.5209]矩阵）进行执行，而不是压力。我们可以用不同的方法来实现这一点，包括将所有的粗网格操作视为作用于[2.x.5210]块系统，我们只考虑左上方的块。另外，我们也可以通过真正只考虑整个有限元离散化的速度部分的线性系统来实现。后者是我们在这里想要使用的方式。

为了实现这一点，我们需要能够提出这样的问题："我可以只拥有一个DoFHandler的一部分吗？"。在编写这个程序的时候，这是不可能的，所以为了满足我们的需求，我们只是为速度创建一个单独的、第二个DoFHandler。然后，我们只基于这个第二DoFHandler为多网格预处理程序建立线性系统，并简单地将第一块（整体）向量转移到整个第二DoFHandler的对应向量中。要做到这一点，我们必须保证两个DoFHandler对象中的（速度）自由度排序的[1.x.2046]是相同的。事实上，首先在两个对象上分配自由度，然后在两个对象上使用相同的DoFRenumbering操作序列，就可以做到这一点。




[1.x.2047]

第56步和第22步的主要区别是我们使用了块状求解器，而不是第22步中使用的Schur补码方法。这种方法的细节可以在步骤-22的 "可能的扩展 "部分的 "块状Schur补码预处理 "小节中找到。对于速度块的预处理，我们从[1.x.2048]中借用了一个叫做[2.x.5211]的类，该类可以选择求解[2.x.5212]的逆，或者只对其应用一个预处理扫频，这分别为我们提供了一种昂贵和便宜的方法。


examples/step-56/doc/results.dox



[1.x.2049]

[1.x.2050]

我们首先运行代码，确认有限元解以混合有限元问题的误差分析所预测的正确速率收敛。考虑到足够平滑的精确解[2.x.5213]和[2.x.5214]，Taylor-Hood元素[2.x.5215]的误差应该是

[1.x.2051]



例如见Ern/Guermond《有限元的理论与实践》，第4.2.5节第195页。这确实是我们观察到的，以[2.x.5216]元素为例（这就是代码中的做法，但在[2.x.5217]中很容易改变）。

[2.x.5218]

[1.x.2052]

让我们比较一下使用UMFPACK的直接求解方法和两种方法，其中我们选择[2.x.5219]和[2.x.5220]，用CG求解[2.x.5221]的线性系统。然后CG的预处理程序是ILU或GMG。下表总结了求解器的迭代、时序和虚拟内存（VM）的峰值使用。

[2.x.5222]

从表中可以看出。

1.UMFPACK使用了大量的内存，特别是在3D中。另外，UMFPACK的计时并不随问题的大小而变化。

2.因为我们对[2.x.5223]和[2.x.5224]使用内部求解器，ILU和GMG需要相同数量的外部迭代。

3.对于ILU来说，[2.x.5225]的（内部）迭代次数随着细化而增加，导致求解时间的线性扩展性较差。相比之下，[2.x.5226]的内部迭代次数在GMG中保持不变，导致求解时间几乎完美的缩放。

4.GMG需要比ILU多一点的内存来存储电平和接口矩阵。

[1.x.2053]

[1.x.2054]

用更高阶的稳定FE对进行实验，检查你是否观察到正确的收敛率。

[1.x.2055]

介绍中还概述了对整个系统进行预处理的另一种选择，即我们不选择上表中的[2.x.5227]，而是选择[2.x.5228]，只分别用GMG或ILU进行单一预处理的应用。

这实际上是在代码中实现的。目前，布尔值[2.x.5229]被设置为[2.x.5230] 上面提到的选项是通过设置为[2.x.5231]得到的。

你会发现，如果你用GMG这种方式，FGMRES的迭代次数在细化过程中保持不变。这意味着多重网格是最优的，并且与[2.x.5232]无关。


examples/step-57/doc/intro.dox

[2.x.5233]

[1.x.2056]

[2.x.5234]

[1.x.2057]

[1.x.2058]

[1.x.2059]

在本教程中，我们展示了如何用牛顿方法求解不可压缩的纳维尔-斯托克斯方程（NSE）。我们在这里考虑的流动被假定是稳定的。在一个域[2.x.5235]，[2.x.5236]，具有片状光滑边界[2.x.5237]，和一个给定的力场[2.x.5238]，我们寻求一个速度场[2.x.5239]和压力场[2.x.5240]，满足以下条件

[1.x.2060]



与步骤22中讨论的斯托克斯方程不同，由于对流项的存在，NSE是一个非线性方程组 [2.x.5241] 。计算数值解的第一步是将系统线性化，这将用牛顿方法完成。在步骤35中讨论了一个随时间变化的问题，其中系统是使用最后一个时间步骤的解来线性化的，没有必要进行非线性解。

[1.x.2061]

我们定义一个非线性函数，其根是NSE的解，即

[1.x.2062]



假设初始猜测足以保证牛顿迭代的收敛性，并表示[2.x.5242]，牛顿对向量函数的迭代可以定义为

[1.x.2063]



其中[2.x.5243]是步骤[2.x.5244]中的近似解，[2.x.5245]代表上一步的解，[2.x.5246]是在[2.x.5247]处评估的雅各布矩阵。类似的迭代可以在步骤15中找到。

牛顿迭代公式意味着新的解决方案是通过在旧的解决方案上增加一个更新项而得到的。我们不是评估雅各布矩阵并取其倒数，而是将更新项视为一个整体，即

[1.x.2064]



其中 [2.x.5248] 。

我们可以通过求解系统找到更新项

[1.x.2065]



这里，前一个方程的左边代表[2.x.5249]沿[2.x.5250]在[2.x.5251]的方向梯度。根据定义，方向性梯度由以下公式给出

[1.x.2066]



因此，我们得出了线性化系统。

[1.x.2067]



其中[2.x.5252]和[2.x.5253]是上一次迭代的解。此外，第二个方程的右边不是零，因为离散解不完全是无发散的（连续解是无发散的）。这里的右手边作为一个修正，导致速度的离散解沿着牛顿的迭代是无发散的。在这个线性系统中，唯一的未知数是更新项[2.x.5254]和[2.x.5255]，我们可以使用类似于步骤22中的策略（并以同样的方式推导出弱形式）。

现在，可以用牛顿迭代法来解决更新项。

<ol> [2.x.5256] 初始化。初始猜测 [2.x.5257] 和 [2.x.5258] ，公差 [2.x.5259] ; [2.x.5260] [2.x.5261] 线性求解计算更新项 [2.x.5262] 和 [2.x.5263] ; [2.x.5264] [2.x.5265] 更新近似。        [2.x.5266] 和 [2.x.5267] ; [2.x.5268] [2.x.5269] 检查残差规范。  [2.x.5270] : [2.x.5271] [2.x.5272] 如果 [2.x.5273] , 停止。[2.x.5274] [2.x.5275] 如果 [2.x.5276] ，回到步骤2。[2.x.5277] [2.x.5278] [2.x.5279] [2.x.5280]。

[1.x.2068]

初始猜测需要足够接近解决方案，牛顿方法才能收敛；因此，找到一个好的起始值对非线性求解器来说至关重要。

当粘度[2.x.5281]较大时，通过解决带有粘度[2.x.5282]的斯托克斯方程可以得到一个好的初始猜测。虽然这取决于问题，但对于这里考虑的测试问题，这对[2.x.5283]有效。

然而，如果粘度较小，对流项[2.x.5284]将占主导地位，如测试案例2的[2.x.5285]。  在这种情况下，我们使用延续法建立一系列的辅助NSE，其粘度接近于目标NSE中的粘度。相应地，我们创建了一个带有[2.x.5286]的序列，如果[2.x.5287]较小，我们接受两个具有粘度的NSE[2.x.5288]和[2.x.5289]的解是接近的。  然后，我们使用带有粘度的NSE的解[2.x.5291]作为带有[2.x.5292]的NSE的初始猜测。这可以被认为是一个从斯托克斯方程到我们要解决的NSE的阶梯。

也就是说，我们首先解决一个斯托克斯问题

[1.x.2069]



以获得最初的猜测，即

[1.x.2070]



这也是延续法的初始猜测。这里[2.x.5293]相对较大，这样带粘度的斯托克斯问题的解[2.x.5294]就可以作为牛顿迭代中NSE的初始猜测。

那么，对

[1.x.2071]



的初始猜测。

[1.x.2072]



这个过程是用实验确定的粘度序列[2.x.5295]来重复的，这样最终的解决方案可以作为牛顿迭代的起始猜测。

[1.x.2073]

在牛顿迭代的每一步，问题的结果是解决一个鞍点系统，其形式为

[1.x.2074]



这个系统矩阵的块状结构与步骤22中的相同。然而，左上角的矩阵[2.x.5296]不是对称的，因为有非线性项。我们可以不求解上述系统，而求解等效系统

[1.x.2075]



有一个参数 [2.x.5297] 和一个可逆矩阵 [2.x.5298] 。这里[2.x.5299]是Augmented Lagrangian项，详见[1]。

用[2.x.5300]表示新系统的系统矩阵，用[2.x.5301]表示右手边，我们用右预处理[2.x.5302]反复求解，即[2.x.5303] ，其中

[1.x.2076]



与[2.x.5304]，[2.x.5305]是相应的舒尔补数[2.x.5306] 。我们让[2.x.5307]其中[2.x.5308]是压力质量矩阵，那么[2.x.5309]可以近似为

[1.x.2077]



详见[1]。

我们将[2.x.5310]分解为

[1.x.2078]



这里需要两个非精确求解器分别用于[2.x.5311]和[2.x.5312]（见[1]）。由于压力质量矩阵是对称的和正定的，用ILU作为预处理程序的CG适合用于[2.x.5313]。为了简单起见，我们对 [2.x.5314] 使用直接求解器UMFPACK。最后一个成分是与 [2.x.5315] 的稀疏矩阵-向量乘积。我们不计算[2.x.5316]中增强拉格朗日项的矩阵乘积，而是集合Grad-Div稳定化[2.x.5317]，如[2]中所解释。

[1.x.2079]

我们使用盖子驱动的空腔流作为我们的测试案例，详情见[3]。计算域为单位平方，右手边为[2.x.5318] 。边界条件为

[1.x.2080]



在解决这个问题时，误差由非线性误差（来自牛顿迭代）和离散化误差（取决于网格大小）组成。非线性部分随着牛顿的每次迭代而减少，离散化误差随着网格的细化而减少。在这个例子中，粗网的解被转移到连续的细网中，并作为初始猜测使用。因此，非线性误差总是低于牛顿迭代的容忍度，离散化误差也随着每次网格细化而减少。

在循环中，我们涉及三个求解器：一个用于[2.x.5319]，一个用于[2.x.5320]和一个用于[2.x.5321] 。前两个求解器在预处理程序中被调用，外部求解器给我们提供了更新项。总体收敛性由非线性残差控制；由于牛顿方法不需要精确的雅各布，我们采用FGMRES，外侧线性求解器的相对公差仅为1e-4。事实上，我们对这个系统采用了截断的牛顿解法。如步骤22所述，内部线性求解也不需要做得非常精确。这里我们使用CG，压力质量矩阵的相对公差为1e-6。正如预期的那样，我们仍然看到非线性残差收敛到了1e-14。另外，我们使用一个简单的线搜索算法来实现牛顿方法的全球化。

腔体参考值[2.x.5322]和[2.x.5323]分别来自[4]和[5]，其中[2.x.5324]是雷诺数，可以定位在[8]。这里的粘度是由[2.x.5325]定义的。尽管我们仍然可以找到[2.x.5326]的解决方案，而且参考文献中也包含了用于比较的结果，但我们在这里的讨论仅限于[2.x.5327] 。这是因为从[2.x.5328]附近开始，解不再是静止的，而是变成了周期性的，详见[7]。

[1.x.2081] <醇>

   [2.x.5329] An Augmented Lagrangian-Based Approach to the Oseen Problem, M. Benzi and M. Olshanskii, SIAM J. SCI. COMPUT.COMPUT.2006 [2.x.5330] Efficient augmented Lagrangian-type preconditioning for the Oseen problem using Grad-Div stabilization, Timo Heister and Gerd Rapin [2.x.5331] http://www.cfd-online.com/Wiki/Lid-driven_cavity_problem [2.x.5332] High-Re solution for incompressible flow using the Navier-Stokes equations and a Multigrid Method, U. Ghia, K. N. Ghia, and C. T. Shin [2.x.5333] E. Erturk, T.C. Corke and C. Gokcol [2.x.5334] 三维不可压缩Navier-Stokes方程的隐式加权ENO方案，Yang等人，1998 [2.x.5335] 二维盖子驱动的空腔问题再探讨，C. Bruneau和M. Saad，2006 [2.x.5336] https://en.wikipedia.org/wiki/Reynolds_number [2.x.5337]


examples/step-57/doc/results.dox



[1.x.2082]

现在我们用上面讨论的方法来解决有粘度的纳维尔-斯托克斯方程 [2.x.5338] 和 [2.x.5339] 。

[1.x.2083]

在第一个测试案例中，粘度被设定为[2.x.5340] 。正如我们在介绍中所讨论的，初始猜测是相应斯托克斯问题的解。在下面的表格中，显示了每个网格上的牛顿迭代的残差。表中的数据表明，牛顿迭代的收敛性是四等的。

[2.x.5341]








下面的数字显示了生成网格的顺序。对于[2.x.5342]的情况，初始猜测是通过在[2.x.5343]网格上求解斯托克斯得到的，并且网格是自适应细化的。在不同的网格之间，粗网格的解被内插到细网格中，作为初始猜测使用。

[2.x.5344]

这张图片是用 [2.x.5345] 的盖子驱动的空腔的图形流线结果。  [2.x.5346]

然后将该方案与来自[4]的参考方案进行比较，参考方案的数据可以在文件 "ref_2d_ghia_u.txt "中找到。

[2.x.5347]

[1.x.2084]

牛顿迭代法需要一个良好的初始猜测。然而，当雷诺数很大时，非线性项占主导地位，因此，斯托克斯方程的解可能与精确解相去甚远。如果斯托克斯方程的解作为初始猜测，收敛性就会丧失。下图显示，非线性迭代被卡住了，在进一步的迭代中，残差不再减少。

[2.x.5348]

因此，初始猜测必须通过延续法获得，这在导言中已经讨论过了。这里延续法的步长是[2.x.5349]，是2000，初始网格的大小是[2.x.5350]。在得到一个初始猜测后，如前一个测试案例一样，对网格进行细化。下图显示，在每次细化时，牛顿迭代都有二次收敛性。为解决这个测试案例，共执行了52步牛顿迭代。

[2.x.5351]

我们还显示了每个网格上牛顿迭代的每一步的残差。表格中可以清楚地看到二次收敛的情况。

[2.x.5352]








生成的网格序列看起来像这样。  [2.x.5353] 我们将我们的解决方案与[5]的参考解决方案进行比较。  [2.x.5354] 下图是图形结果。  [2.x.5355]

此外，误差由非线性误差和离散化误差组成，前者随着我们进行牛顿迭代而减少，后者则取决于网格大小。这就是为什么我们必须细化网格并在下一个更细的网格上重复牛顿迭代。从上表中，我们可以看到每个网格上的残差（非线性误差）都低于1e-12，但下图向我们展示了随后更细的网格上的解决方案之间的差异。

[2.x.5356]

[1.x.2085]

[1.x.2086]

[1.x.2087]

比较目前实现的线性求解器和仅仅使用UMFPACK求解整个线性系统是很容易的。你需要去除包含常压的空域，这在第56步中完成。更有趣的是与其他先进的预处理程序如PCD的比较。事实证明，这里的预处理器是非常有竞争力的，在论文[2]中可以看到。

下表显示了我们的迭代方法（FGMRES）与直接求解器（UMFPACK）之间在粘度设置为1/400的情况下对整个系统的计时结果。尽管我们在迭代求解器中的速度块使用了相同的直接求解器，但它的速度要快得多，消耗的内存也少。这在三维中会更加明显。

[2.x.5357]




[1.x.2088]

该代码被设置为也可以在3D中运行。当然，参考值是不同的，例如，见[6]。在这个例子中，高分辨率的计算是无法做到的，因为速度块的直接求解器在三维中不能很好地工作。相反，需要一个基于代数或几何多网格的并行求解器。见下文。

[1.x.2089]

对于较大的计算，特别是三维计算，有必要实现MPI并行求解器和预处理器。一个好的起点是step-55，它对斯托克斯方程的速度块使用代数多重网格。另一个选择是看一下[1.x.2090]中的代码列表，其中已经包含了并行的纳维-斯托克斯求解器。


examples/step-58/doc/intro.dox

[2.x.5358]

[1.x.2091][1.x.2092] 。

[1.x.2093]

[1.x.2094]

一个函数[2.x.5359]和一个势[2.x.5360]的[1.x.2095]是量子力学和非线性光学中经常使用的一个模型。如果用适当的量来测量（以便[2.x.5361]），那么它的内容如下。

[1.x.2096]

如果没有电位，即[2.x.5362]，那么它可以用来描述光在光纤中的传播。如果[2.x.5363]，该方程有时也被称为[1.x.2097]，可用于模拟[1.x.2098]的时间依赖行为。

对于这个特定的辅导项目，我们对该方程的物理解释并不太关心。相反，我们想把它作为一个模型，让我们解释两个方面。

- 这是一个[1.x.2099]的[2.x.5364] 。我们以前在step-29中看到过复值方程，但那里选择了将方程分成实数和虚数部分，结果是解决了两个实值方程的系统。相比之下，这里的目标是展示如何解决我们保持一切为复数的问题。

- 这个方程是一个很好的模型问题，可以解释[1.x.2100]如何工作。这是因为它有一些具有根本不同性质的项：一方面，[2.x.5365]是一个常规的空间算子，其方式我们以前已经见过多次；另一方面，[2.x.5366]没有空间或时间导数，也就是说，它是一个纯粹的局部算子。事实证明，我们对这些项中的每一项都有有效的方法（特别是，我们对后者有分析解），而且我们可能最好对这些项进行不同的、单独的处理。我们将在下文中更详细地解释这一点。




[1.x.2101]

乍一看，这些方程似乎是抛物线，与热力方程相似（见步骤26），因为只有一个时间导数和两个空间导数。但这是一种误导。事实上，如果我们暂时假设势[2.x.5367]和[2.x.5368]，这不是正确的解释，更容易看出。那么我们就有这样的方程

[1.x.2102]

如果我们把解分成实部和虚部，[2.x.5369] ，与[2.x.5370] ，那么我们就可以按照步骤29中的方法，把一个方程分成实部和虚部。

[1.x.2103]

毫不奇怪，时间导数前面的因子[2.x.5371]耦合了方程的实部和虚部。如果我们想进一步理解这个方程，可以取其中一个方程的时间导数，例如

[1.x.2104]

在这里我们假设，至少在某种正式意义上，我们可以将空间和时间导数进行换算），然后将另一个方程插入其中。

[1.x.2105]

这个方程是双曲线的，与波浪方程的性质相似。如果你看一下本程序的 "结果 "部分的视频，这一点也会很明显）。此外，我们也可以得出[2.x.5372]的相同方程。因此，对于NLSE来说，一个更好的假设是把它看成是一个双曲的波传播方程，而不是像热方程那样的扩散方程。你可能会问，算子[2.x.5373]以正号出现，而在波浪方程中，[2.x.5374]有一个负号，这是否正确？这确实是正确的。在与测试函数相乘并通过部分积分后，我们希望得到一个正（半）定式。因此，从[2.x.5375]我们得到[2.x.5376] 。同样，经过两次积分，我们从[2.x.5377]得到[2.x.5378]的形式。在这两种情况下，我们都能得到所需的正号）。)

当然，真正的NLSE也有[2.x.5379]和[2.x.5380]等项。然而，这些是空间导数中的低阶项，虽然它们显然很重要，但它们并不改变方程的特征。

在任何情况下，本讨论的目的是要弄清楚什么时间步长方案可能适合于该方程。结论是，作为一个双曲类型的方程，我们需要选择一个满足CFL类型条件的时间步长。如果我们使用显式方法（我们不会这样做），我们将不得不研究与空间算子相对应的矩阵的特征值。如果你跟随视频讲座的讨论( [2.x.5381]，那么你会记得，模式是需要确保[2.x.5382]，其中[2.x.5383]是时间步长，[2.x.5384]是网格宽度，[2.x.5385]是时间和空间导数的顺序。无论你采取原始方程( [2.x.5386])还是只对实部或虚部进行重构，其结果是，如果我们要使用显式时间步进方法，我们需要选择[2.x.5387]。这是不可行的，原因与热方程的步骤26相同。它将产生不切实际的小的时间步长，甚至只对适度精细的网格。相反，我们必须使用隐式时间步进方法，然后可以选择一个更平衡的 [2.x.5388] 。事实上，我们将使用隐式的Crank-Nicolson方法，正如我们之前在步骤23中对常规波方程所做的那样。




[1.x.2106]

[2.x.5389]

如果我们把NLSE看作是一个普通微分方程，其中的右手边恰好有空间导数，即把它写成

[1.x.2107]

人们可能会想通过在时间间隔[2.x.5390]上对两边进行积分来 "正式求解"，并得到

[1.x.2108]

当然，这不是那么简单的：积分中的[2.x.5391]仍在按照微分方程随时间变化，所以我们不能直接评估积分（或通过正交轻松近似它），因为我们不知道[2.x.5392] 。但是我们可以把这个写成如下的独立贡献，这将使我们能够分别处理不同的项。

[1.x.2109]

现在可以将这个方程解读如下。对于每个时间间隔[2.x.5393]，溶液中的变化[2.x.5394]由三个贡献组成。

- 拉普拉斯算子的贡献。

- 势的贡献 [2.x.5395] 。

- 相 "项的贡献 [2.x.5396] 。

[1.x.2110]现在是一种近似技术，允许我们分别处理这些贡献中的每一个。(如果我们想的话。在实践中，我们将把前两个放在一起处理，而最后一个则分开处理。但这是一个细节，从概念上讲，我们可以以不同的方式处理所有这些贡献）。)为此，让我们介绍三个独立的 "解决方案"。

[1.x.2111]



这三个 "解决方案 "可以被认为是满足以下微分方程。

[1.x.2112]

换句话说，它们都是以[2.x.5398]为起点的轨迹[2.x.5397]，并且正好整合了三个条款中的一个条款的影响。在我们的时间区间内，这些条款中的每一项产生的增量是[2.x.5399]、[2.x.5400]和[2.x.5401]。

现在可以合理地假设（这是一个近似值！），由于所有三个有关的影响而产生的变化很好地近似于三个单独的增量的总和。

[1.x.2113]

这种直觉确实是正确的，尽管近似并不精确：精确的左手边和项[2.x.5402]之间的差异（即从[2.x.5404]到[2.x.5405]时，精确解[2.x.5403]的[1.x.2114]增量与右手边三部分组成的增量之间的差异），正比于[2.x.5406] 。换句话说，这种方法引入了一个大小为 [2.x.5407] 的误差。到目前为止，我们所做的一切都没有在时间或空间上离散化，所以[1.x.2115]的误差将是[2.x.5408]加上我们在近似积分时的任何误差（时间离散化误差）加上我们在近似[2.x.5409]的空间依赖时的任何误差（空间误差）。

在我们继续讨论运算符拆分之前，让我们谈谈为什么要走这条路？答案很简单。对于[2.x.5410]的一些独立方程，我们可能有办法比把所有东西放在一起并试图一次解决它们更有效。例如，在目前的情况下，特别相关的是。2.x.5411]的方程，即。

[1.x.2116]

或等价的。

[1.x.2117]

可以精确求解：方程的解法是

[1.x.2118]

这很容易看出，如果（i）你把这个解插入微分方程，（ii）意识到幅度[2.x.5412]是常数，即指数中的项[2.x.5413]实际上等于[2.x.5414] 。换句话说，[2.x.5415]的ODE的解只是改变了它的[1.x.2119]，但复值函数[2.x.5416]的[1.x.2120]保持不变。这使得计算[2.x.5417]特别方便：我们实际上不需要解决任何ODE，我们可以用手写下解。使用算子拆分方法，计算[2.x.5418]的方法都不必处理非线性项和所有相关的不愉快：只要我们允许自己使用算子拆分方法，就可以摆脱只解决[1.x.2121]问题。

其次，如果不同项所描述的不同物理效应具有不同的时间尺度，人们通常会使用算子拆分。例如，想象一下，我们确实有某种扩散方程的情况。扩散作用缓慢，但如果[2.x.5419]很大，那么[2.x.5420]项的 "相位旋转 "就会迅速发挥作用。如果我们把所有的东西放在一起处理，这将意味着必须采取相当小的时间步长。但是有了算子分割，我们可以对扩散采取大的时间步数[2.x.5421]，并且（假设我们没有分析解）使用具有许多小时间步数的ODE求解器来整合[2.x.5422]从[2.x.5423]到[2.x.5424]的 "相变 "方程。换句话说，算子分裂允许我们将慢速和快速的时间尺度解耦，并对它们进行不同的处理，方法根据每种情况进行调整。




[1.x.2122]

虽然上述方法允许并行计算三个贡献[2.x.5425]，但如果我们愿意，如果我们不让[2.x.5426]的轨迹全部从[2.x.5427]开始，而是让[2.x.5428]的轨迹从[2.x.5429]的[1.x.2123]开始，可以使该方法稍微准确和容易实现。]，而是让[2.x.5428]的轨迹从[2.x.5429]的轨迹的[1.x.2123]开始，即[2.x.5430]；同样，我们将从[2.x.5431]的轨迹的终点开始，即[2.x.5433]。这种方法就被称为 "Lie splitting"，其误差顺序与上面的方法相同，即分割误差为[2.x.5434] 。

运算符拆分的这种变化可以写成如下形式（仔细比较上面的初始条件）。

[1.x.2124]

显然，虽然上面的公式意味着我们应该以这种特定的顺序来解决这些问题，但首先解决轨迹3，然后是2，然后是1，或任何其他的排列组合也同样有效）。

那么这些方程的综合形式是

[1.x.2125]

从实际的角度来看，这样做的好处是我们需要保持较少的解向量。一旦[2.x.5435]被计算出来，我们就不再需要[2.x.5436]了；一旦[2.x.5437]被计算出来，我们就不再需要[2.x.5438]了。而一旦[2.x.5439]被计算出来，我们就可以直接称之为[2.x.5440]，因为如果你把第一个方程插入第二个方程，然后再插入第三个方程，你会看到[2.x.5441]的右边现在包含所有三个物理效应的贡献。

[1.x.2126]

(再与[2.x.5442]的 "精确 "计算进行比较：它只在我们如何在三个积分中的每一个中近似[2.x.5443]方面有所不同)。换句话说，Lie拆分的实现比上述原始方法要简单得多，因为数据处理要简单得多。




[1.x.2127]

如上所述，Lie拆分只有[2.x.5444]的准确性。如果我们使用一阶时间离散化，例如使用显式或隐式欧拉方法来解决[2.x.5445]的微分方程，这是可接受的。这是因为这些时间积分方法引入了与[2.x.5446]本身成正比的误差，因此分裂误差与我们无论如何都会引入的误差成正比，并不会削弱整体收敛顺序。

但我们通常希望使用高阶的方法--比如，[1.x.2128]或[1.x.2129]方法--因为这些方法通常不会比简单的欧拉方法更昂贵。如果我们使用[2.x.5447]的时间步长方法，但由于算子分裂又失去了精度，那就太可惜了。

这就是[1.x.2130]方法的用处。如果我们只有两部分，就更容易解释了，所以让我们把拉普拉斯算子和势的影响合二为一，把相位旋转合为第二个影响。事实上，这就是我们在代码中要做的事情，因为用拉普拉斯方程求解，不管有没有电势，代价都是一样的--所以我们把这两步合并起来）。上面的Lie拆分方法将做以下工作。它计算出以下两个ODE的解。

[1.x.2131]

然后使用近似值 [2.x.5448] 。换句话说，我们首先为物理效应一做一个完整的时间步骤，然后为物理效应二做一个完整的时间步骤。时间步数结束时的解只是分别由这些物理效应引起的增量的总和。

相比之下，[1.x.2132]（20世纪中期开始的数值分析领域的泰斗之一）发现，先对一个物理效应做一个半步，然后对另一个物理效应做一个完整的时间步骤，再对第一个物理效应做一个半步，这样更准确。哪个是哪个并不重要，但由于做相位旋转非常简单，我们将用这个效应做半步，然后只需要用拉普拉斯算子加势做一次空间解。这种算子拆分方法现在是[2.x.5449]准确的。写在公式里，这就产生了以下的步骤序列。

[1.x.2133]

如前所述，对于这个特殊的方程，第一和第三步可以精确计算，得出的结果是

[1.x.2134]



那么这就是我们在这个程序中要实现的事情。在每个时间步骤中，我们执行三个步骤，即

- 通过分析整合相位旋转方程的半个时间步长，更新每个节点的解值。

- 解决与[2.x.5450]的全步骤相对应的时空方程，即[2.x.5451]，初始条件等于上述第一个半步骤的解决方案。

- 通过对相位旋转方程再进行半个时间步长的分析积分，更新每个节点的解值。

这种结构将以明显的方式反映在程序的主时间循环中。




[1.x.2135]

从上面的讨论中可以看出，我们在每个时间步骤中要解决的唯一偏微分方程是

[1.x.2136]

这个方程是线性的。此外，我们只需要解决从[2.x.5452]到[2.x.5453]的问题，也就是说，正好是一个时间步骤。

为了做到这一点，我们将应用二阶精确的Crank-Nicolson方案，我们已经在其他一些时间相关的代码中使用过该方案（具体为：步骤23和步骤26）。它的内容如下。

[1.x.2137]

这里，"先前 "的解决方案[2.x.5454]（或这部分时间步长的 "初始条件"）是第一个阶段旋转半步的输出；当前步骤的输出将用[2.x.5455]表示。  [2.x.5456]是时间步骤的长度。人们可以争论[2.x.5457]和[2.x.5458]是生活在时间步长[2.x.5459]还是[2.x.5460]，以及它们的上指数应该是什么。这是一个没有实际影响的哲学讨论，人们可以把[2.x.5461]看作是[2.x.5462]，而把[2.x.5463]看作是[2.x.5464]，如果这有助于澄清问题的话--不过，[2.x.5465]也不能理解为"[2.x.5466]之后的三分之一时间步骤"，而更像是 "我们已经完成了时间步骤[2.x.5467]所需工作的三分之一。")

如果我们将整个方程与[2.x.5468]相乘，并将未知的[2.x.5469]项排序到左边，将已知的[2.x.5470]项排序到右边，那么我们得到以下（空间）偏微分方程，需要在每个时间步骤中解决。

[1.x.2138]






[1.x.2139]

如上所述，之前处理复值解的教程程序（即step-29）将解的实部和虚部分开。因此，它将一切都简化为实数运算。相比之下，我们在这里希望保持复值的东西。

第一部分是我们需要将离散的解决方案定义为[2.x.5471]，其中[2.x.5472]是通常的形状函数（是实值的），但在时间步长[2.x.5474]的扩展系数[2.x.5473]现在是复值的。这在deal.II中很容易做到：我们只需要用[2.x.5475]而不是Vector<double>来存储这些系数。

更感兴趣的是如何建立和解决线性系统。很明显，这只对上面讨论的斯特朗分割的第二步有必要，即上一小节的时间离散化。我们通过将[2.x.5476]直接替换为[2.x.5477]并乘以一个测试函数，得到完全离散的版本。

[1.x.2140]

或以更紧凑的方式书写。

[1.x.2141]

在这里，矩阵是以其明显的方式定义的。

[1.x.2142]

请注意，所有单独的矩阵实际上都是对称的、实值的，而且至少是正半无限的，尽管对于系统矩阵[2.x.5478]和右手边的相应矩阵[2.x.5479]来说显然不是这样的。




[1.x.2143]

[2.x.5480]

关于解决程序的唯一剩下的重要问题是如何解决复值线性系统

[1.x.2144]

矩阵[2.x.5481]，右手边很容易计算为已知矩阵与上一步骤解决方案的乘积。像往常一样，这归结于矩阵[2.x.5482]具有什么属性的问题。如果它是对称和正定的，那么我们可以使用共轭梯度法。

不幸的是，该矩阵唯一有用的属性是它是复数对称的，即[2.x.5483]，通过回顾[2.x.5484]都是对称的就很容易看出。然而，它不是[1.x.2145]，这就要求[2.x.5485]，其中的横杠表示复数共轭。

复杂的对称性可以被用于迭代求解器，正如快速的文献搜索所显示的。我们在这里不会试图变得太复杂（实际上是把这个问题留给下面的[1.x.2146]部分），而是简单地用好的老办法来解决没有属性的问题。一个直接的解算器。这不是最好的，特别是对于大问题，但对于一个教程程序来说，这已经足够了。幸运的是，SparseDirectUMFPACK类允许解决复杂值的问题。




[1.x.2147]

NLSE的初始条件通常被选择来代表特定的物理情况。这超出了本程序的范围，但只要说这些初始条件是（i）位于不同点的粒子的波函数的叠加，以及（ii）因为[2.x.5486]对应于一个粒子密度函数，积分

[1.x.2148]

对应于系统中粒子的数量。显然，如果要在物理上正确，如果系统是封闭的，[2.x.5487]最好是一个常数，或者如果有吸收性边界条件，[2.x.5488]最好是常数）。重要的一点是，我们应该选择初始条件，以使

[1.x.2149]

有道理。

我们在这里将使用的，主要是因为它能做出好的图形，是以下内容。

[1.x.2150]

其中[2.x.5489]是与（固定）位置[2.x.5490]的距离，[2.x.5491]的选择是为了使我们要加起来的每个高斯在[2.x.5492]中增加整数个粒子。我们通过确保以下几点来实现这一点

[1.x.2151]

是一个正整数。换句话说，我们需要选择[2.x.5493]作为一个整数倍的

[1.x.2152]

暂时假设[2.x.5494] -- 当然不是这样，但我们将忽略积分的微小差异。

因此，我们选择[2.x.5495]为所有，以及[2.x.5496] 。这个[2.x.5497]足够小，精确（无限）积分和[2.x.5498]上的积分之间的差异应该不会太引人注意。我们选择[2.x.5499]这四个点作为[2.x.5500]--也离[2.x.5501]的边界足够远，以保证我们的安全。

为了简单起见，我们在方形[2.x.5502]上提出问题。对于边界条件，我们将使用时间无关的诺依曼条件，其形式为

[1.x.2153]

这不是一个现实的边界条件选择，但对于我们想在这里展示的东西来说已经足够了。我们将在下面的[1.x.2154]部分进一步评论这个问题。

最后，我们选择[2.x.5503]，势为

[1.x.2155]

使用一个大的势可以确保波函数[2.x.5504]在半径为0.7的圆圈外保持很小。构成初始条件的所有高斯都在这个圆内，解决方案将主要在这个圆内振荡，有少量的能量辐射到外面。大势的使用也确保了非物理边界条件不会有太大的影响。


examples/step-58/doc/results.dox



[1.x.2156]

运行该代码的结果是屏幕输出如下。```活动单元的数量：4096 自由度的数量：16641

时间步数1在t=0 时间步数2在t=0.00390625 时间步数3在t=0.0078125 时间步数4在t=0.0117188 [...] ```运行程序也会产生大量的输出文件，我们将在下面进行可视化。




[1.x.2157]

该程序的`output_results()`函数生成的输出文件由若干变量组成。解（分为实部和虚部）、振幅和相位。如果我们将这四个字段可视化，在经过几个时间步骤后（准确地说，在时间[2.x.5505]，我们得到如下图像。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.re.png" alt="t=0.242时溶液的实部" width="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.im.png" alt="t=0时溶液的虚部。242" width="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.magnitude.png" alt="t=0.242时解决方案的振幅" width="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.phase.png" alt="t=0.242时解决方案的相位" width="400"> </div> <div>

虽然上面显示的解决方案的实部和虚部并不特别有趣（因为从物理角度来看，相位的全局偏移以及因此实部和虚部之间的平衡是没有意义的），但将解决方案的振幅[2.x.5506]和相位[2.x.5507]可视化，特别是它们的演变，则要有趣得多。这就导致了如下的图片。

这里显示的相图显然有一些缺陷。

- 首先，相位是一个 "循环量"，但色标对接近[2.x.5508]的值和接近[2.x.5509]的值使用的颜色根本不同。这是一个麻烦--我们需要的是一个 "循环色标"，对相位范围的两个极端使用相同的颜色。这样的颜色图存在，例如见[1.x.2158]或[1.x.2159]。问题是，笔者最喜欢的两个大的可视化软件包之一VisIt，并没有内置这些颜色图。无奈之下，我只好使用Paraview，因为它已经实现了上面帖子中提到的几种颜色地图。下图使用了`nic_Edge`地图，其中两个极端值都显示为黑色。

- 在相位缠绕的单元中存在一个问题。如果在单元格的某个评估点，相位值接近[2.x.5510]，而在另一个评估点，它接近[2.x.5511]，那么我们真正希望发生的是整个单元格的颜色接近极端值。但是，相反，可视化程序产生了一个线性插值，其中单元格内的值，即评估点之间的值，是在这两个值之间线性插值的，基本上涵盖了整个可能的相位值范围，因此，在一个单元格的过程中，从深红色到深绿色的整个彩虹色循环往复。解决这个问题的方法是将每个单元的相位值作为一个片断常数输出。因为对接近[2.x.5512]和[2.x.5513]的值进行平均，会产生一个与实际相位角无关的平均值，`ComplexPhase'类只是使用每个单元上遇到的*大相位角。

经过这些修改，现在的相位图看起来如下。

<p align="center"> <img src="https://www.dealii.org/images/steps/developer/step-58.phase-cyclic.png" alt="在t=0.242时解的相位，有一个循环的颜色图" width="400"> [2.x.5514]

最后，我们可以从中生成一部电影。准确地说，这个视频又使用了两个全局细化周期，时间步长是上面程序中使用的一半）。这几行字的作者用VisIt制作了这部电影，因为这是他比较熟悉的，并使用了一个黑客的颜色地图，也是循环的--尽管这个颜色地图缺乏上面链接中提到的写帖子的人所使用的所有技巧。然而，如果你看一下半径为0.7的圆以外的域的阴影部分，其中电势为零，它确实显示了解决方案作为一个波浪方程的特征--你可以看到每次一个凸点（显示振幅[2.x.5515]）撞到电势大的区域时：一个波从那里向外传播。看一下这个视频吧。

[1.x.2160]



那么，为什么我最终会在势能[2.x.5516]较大的区域进行遮蔽？在那个外部区域，解决方案是相对较小的。它也是相对平滑的。因此，在某种近似程度上，该区域的方程简化为

[1.x.2161]

或者说更容易阅读。

[1.x.2162]

在这个近似值有效的程度上（除其他外，它消除了你在视频中可以看到的行波），这个方程有一个解

[1.x.2163]

因为[2.x.5517]很大，这意味着相位*旋转得相当快*。如果你把注意力集中在域的半透明的外部，你就可以看到这一点。如果用与域的内部相同的方式给这个区域上色，这个快速闪烁的外部部分可能是迷幻的，但也分散了内部发生的事情；也很难真正看到在视频开始时很容易看到的辐射波。


[1.x.2164]

[1.x.2165]

[1.x.2166]

这里选择的解算器实在是太简单了。它的效率也不高。我们在这里所做的是在每个时间步骤中把矩阵交给一个稀疏的直接求解器，让它找到线性系统的解。但我们知道，我们可以做得更好。

- 首先，我们应该利用这样一个事实，即矩阵实际上并没有从时间步长到时间步长的变化。这是一个伪命题，因为我们在这里有恒定的边界值，而且我们不改变时间步长--这两个假设在实际应用中可能并不真实。但至少在这种情况下，只对矩阵进行一次因式分解（即计算一次[2.x.5518]和[2.x.5519]因子），然后在接下来的所有时间步骤中使用这些因子，直到矩阵[2.x.5520]发生变化，需要进行新的因式分解。SparseDirectUMFPACK类的接口允许这样做。

- 然而，最终，稀疏直接求解器只对相对较小的问题有效，比如说最多几十万个未知数。除此之外，我们需要迭代求解器，如共轭梯度法（用于对称和正定问题）或GMRES。我们已经在其他教程程序中使用了许多这样的方法。在所有情况下，它们都需要伴随着良好的预处理程序。对于目前的情况，原则上可以使用GMRES--一种不需要矩阵的任何特定属性的方法--但最好实施一种迭代方案，利用我们知道的这个问题的一个结构特征：矩阵是复数对称的（尽管不是赫米特）。




[1.x.2167]

为了能够用于实际的、现实的问题，非线性Schr&ouml;dinger方程的求解器需要利用对手头的问题有意义的边界条件。我们在这里将自己限制在简单的诺伊曼边界条件上--但这些条件实际上对问题没有意义。事实上，这些方程通常是在一个无限的域上提出的。但是，由于我们不能在无限域上进行计算，我们需要在某处截断它，而提出对这个人为的小域有意义的边界条件。广泛使用的方法是使用[1.x.2168]方法，它对应于一种特殊的衰减。在不同的背景下，它也用于步骤-62。




[1.x.2169]

最后，我们从经验和许多其他教程程序中知道，使用自适应细化网格是值得的，而不是这里使用的均匀网格。事实上，在这里增加这一点并不是很困难。step-26将是一个很好的指南，说明如何实现这一点。


examples/step-59/doc/intro.dox

[2.x.5521]

[1.x.2170]

[1.x.2171]

[1.x.2172]

无矩阵算子评估使高阶多项式基的离散化得到了非常有效的实现，这是由于一种叫做和因子化的方法。这个概念已经在step-37和step-48教程程序中介绍过。在这个教程程序中，我们将这些概念扩展到包括面积分的非连续Galerkin（DG）方案，这是一类高阶特别普遍的方法。

无矩阵评估的基本思想与连续元素的评估是一样的。迭代求解器或多网格平滑器中出现的矩阵-向量乘积不是由经典的稀疏矩阵核来实现的，而是通过对基础积分的实时评估来隐含地应用。对于用张量积正交规则集成的张量积形状函数，通过使用和-因子化技术，这种评估特别有效，它将最初涉及[2.x.5522]的插值操作与相关形状函数在[2.x.5524]度的[2.x.5525]维的张量积正交点分解为[2.x.5527]的一维操作，每个成本[2.x.5528]。在三维中，这将复杂度降低了[2.x.5529]的两个次方。当以每个自由度的复杂度来衡量时，复杂度是[2.x.5530]的多项式程度。由于DG中存在面积分，也由于对正交点的操作涉及更多的内存传输，这两者的规模为[2.x.5531]，观察到的复杂度通常是中等[2.x.5532]的常数。这意味着，以每秒自由度计算，高阶方法的评估吞吐量与低阶方法相同。

关于算法的更多信息可参见Martin Kronbichler和Katharina Kormann的预印本[2.x.5533] [1.x.2173]，arXiv:1711.03590。

[1.x.2174]

在本教程中，我们以无矩阵的DG框架为例，对拉普拉斯进行内部惩罚离散化，即与Step-39教程中使用的方案相同。拉普拉斯的离散化是由以下弱形式给出的

[1.x.2175]

其中[2.x.5534]表示数量[2.x.5535]从两个相关单元[2.x.5536]和[2.x.5537]的定向跳跃，[2.x.5538]是两边的平均值。

方程中的项代表分项积分后的单元积分，由于分项积分和插入平均通量而在元素界面产生的原始一致性项，为恢复基础矩阵的对称性而添加的邻接一致性项，以及系数为[2.x.5539]的惩罚项，其大小等于单元在面的法线方向的长度乘以[2.x.5540] ，见步骤39。惩罚项的选择是为了使逆向估计成立，并且最终的弱形式是强制性的，即在离散设置中是正定的。邻接一致性项和惩罚项涉及元素界面上的跳跃[2.x.5541]，这在解析解中消失了[2.x.5542] 。因此，这些项与原始PDE一致，保证了该方法可以保留最佳收敛顺序。

在下面的实现中，我们通过将法向量[2.x.5543]从跳跃项移到导数中来实现上面的弱形式，形成[1.x.2176]形式的导数。这使得在正交点上的实现稍微有效一些，因为我们只需要处理标量项而不是张量，而且在数学上是等价的。

对于边界条件，我们使用所谓的镜像原理，通过从内部解[2.x.5546]结合给定的边界数据进行外推来定义[1.x.2177]外部值[2.x.5545]，在迪里希特边界设置[2.x.5547]和[2.x.5548]，在纽曼边界设置[2.x.5549]和[2.x.5550]，对于给定的迪里希特值[2.x.5551]和纽曼值[2.x.5552] 。然后将这些表达式插入上述弱形式中。涉及已知量[2.x.5553]和[2.x.5554]的贡献最终被移到右手边，而未知值[2.x.555]被保留在左手边，对矩阵项的贡献与内部面类似。经过这些操作，得到了与步骤39中相同的弱形式。

[1.x.2178]

deal.II的无矩阵框架为实现上述离散化方程的作用提供了必要的基础设施。相对于我们在步骤37和步骤48中使用的[2.x.5556]，我们现在用[2.x.5557]建立一个代码，它需要三个函数指针，一个用于单元积分，一个用于内面积分，一个用于边界面积分（与步骤39教程程序中使用的MeshWorker的设计相类似）。在这三个函数中的每一个，我们都会在正交点上实现各自的条款。对于向量条目和正交点上的值和梯度之间的插值，我们使用FEEvaluation类来处理单元贡献，FEFaceEvaluation类来处理面的贡献。这些函数的基本用法已经在step-37教程程序中得到了广泛的讨论。

在[2.x.5558]中，所有内部面都正好被访问一次，所以必须确保计算来自测试函数[2.x.5559]和[2.x.5560]的贡献。考虑到两边的测试函数确实是独立的，上面的弱形式实际上意味着我们在用测试函数的法向导数进行测试时，向名为`phi_inner`和`phi_outer`的FEFaceEvaluation对象提交相同的贡献，而在用测试函数的值进行测试时，则提交相反符号的值，因为后者由于跳跃项而涉及相反符号。对于不同细化程度的单元之间的面，从细化的一侧进行整合，FEFaceEvaluation自动执行内插到粗略一侧的子面。因此，一个悬空的节点永远不会明确地出现在用户实现的弱形式中。

每个面被精确访问一次的事实也适用于用MPI并行化时不同处理器之间的子域边界的那些面，其中一个单元属于一个处理器，一个属于另一个。[2.x.5561]中的设置将面分成了两边，最终只报告了[2.x.5562]和[2.x.5563]中分别实际处理的面。注意，与步骤37中讨论的单元积分相类似，deal.II在几个面上应用矢量化，以使用SIMD，在我们称之为[1.x.2179]的东西上用一条指令工作。面的批次与单元的批次是独立的，尽管处理面的积分的时间与处理各自单元的积分的时间保持一致，以增加数据定位。

这个程序中的另一个新东西是，我们不再像[2.x.5564]或[2.x.5565]那样将向量访问从求值和积分步骤中分割出来，而是分别调用组合函数[2.x.5566]和[2.x.5567]。这对面积分很有用，因为根据面的评估内容，并非所有单元的向量项都必须首先被触及。例如，想想节点元素FE_DGQ的情况，节点点在元素表面。如果我们对面的形状函数值感兴趣，只有[2.x.5568]个自由度以非显著的方式对它们做出贡献（用更专业的方式来说，只有[2.x.5569]个形状函数在面有非零支持，并对[2.x.5570]个自由度返回真值。 当与单元的[2.x.5571]个自由度相比，这要少一个幂。

现在，我们当然不只对函数值感兴趣，而且对单元格上的导数也感兴趣。幸运的是，在deal.II中，有一个元素将这种减少访问的属性也扩展到面的导数上，即FE_DGQHermite元素。

[1.x.2180]

FE_DGQHermite元素属于FE_DGQ元素家族，即其形状函数是一维多项式的张量乘积，该元素是完全不连续的。与通常的FE_DGQ元素中的节点特征相反，FE_DGQHermite元素是一个基于Hermite-like概念的节点贡献和导数贡献的混合物。基本的多项式类是[2.x.5572]，可以总结为以下几点。对于三次多项式，我们用两个多项式来表示单位区间左端的函数值和第一次导数，[2.x.5573] ，用两个多项式来表示函数值和第一次导数以及单位区间的右端，[2.x.5574] 。在相反的两端，形状函数的值和一阶导数都是零，确保四个基础函数中只有两个对各自端部的值和导数有贡献。然而，我们偏离了经典的Hermite内插法，没有严格地为值和一导数指定一个自由度，而是允许一导数是第一和第二形状函数的线性组合。这样做是为了改善插值的调节。另外，当度数超过三时，我们以类似拉格朗日的方式在元素内部增加节点点，在[2.x.5575]和[2.x.5576]这两个点上结合双零。这些额外节点的位置是由一些雅可比多项式的零点决定的，在类的描述中解释过 [2.x.5577] 。

使用这个元素，我们只需要访问[2.x.5578]自由度来计算一个面的值和导数。检查是否满足Hermite属性是在[2.x.5579]和[2.x.5580]中透明地完成的，它们检查基础的类型，并尽可能地减少对数据的访问。显然，如果我们将[2.x.5581]与[2.x.5582]分开，这将是不可能的，因为我们需要读取的条目数量取决于导数的类型（只有值，一阶导数，等等），因此必须交给`read_dof_values()`。

这种优化不仅对计算面的积分有用，而且对MPI的鬼层交换也有用。在一个天真的交换中，如果一个单元的所有自由度由另一个处理器负责计算面的贡献，我们就需要把这个单元的所有自由度发送给另一个处理器。由于我们知道在用FEFaceEvaluation进行的评估中只有部分自由度被触及，所以自然只交换相关的自由度。[2.x.5583]函数在与[2.x.5584]结合时支持选定的数据交换。为了实现这一点，我们需要告诉循环我们要对脸部做什么样的评价，使用[2.x.5585]类型的参数，正如在下面[2.x.5586]的实现中可以看到。在这种情况下，数据交换的方式是如下的。矢量中的幽灵层数据仍然假装代表所有的自由度，这样，FEFaceEvaluation可以继续读取数值，就像单元格是本地拥有的一样。数据交换例程负责将数据打包和解包成这种格式的任务。虽然这听起来很复杂，但我们将在下面的结果部分显示，通过与不指定面孔上的数据访问的基线代码进行性能比较，这确实得到了回报。

[1.x.2181]

按照step-37程序的传统，我们再次用共轭梯度求解器内的几何多网格预处理器解决泊松问题。在这个教程程序中，我们没有计算对角线并使用基本的PreconditionChebyshev作为平滑器，而是选择了一种不同的策略。我们实现了一个块状Jacobi预处理程序，其中块状指的是一个单元上的所有自由度。我们没有在预处理程序中建立完整的单元格矩阵并应用它的LU因子化（或逆），这种操作将受到严重的内存带宽限制，因此相当缓慢；我们通过一种称为快速对角化法的特殊技术对块的逆进行近似处理。

该方法的思路是利用单元矩阵的结构。对于在笛卡尔网格上离散的恒定系数的拉普拉斯，单元矩阵[2.x.5587]可以写为

[1.x.2182]

在二维和

[1.x.2183]

在三维中。矩阵[2.x.5588]和[2.x.5589]表示一维拉普拉斯矩阵（包括与当前单元值[2.x.5590]和[2.x.5591]相关的单元和面项），[2.x.5592]和[2.x.5593]是质量矩阵。请注意，一旦单元上有非恒定系数或几何形状不再恒定，这种简单的张量乘积结构就会消失。我们提到，类似的设置也可以用来用这个最终的张量积形式的矩阵来替代计算的积分，这将把算子评估的操作减少到一半以下。然而，考虑到这只适用于直角坐标单元和恒定系数的情况，这是一个相当狭窄的情况，我们避免继续探讨这个想法。

有趣的是，由于1964年[1.x.2184]引入的方法，矩阵[2.x.5594]的精确逆值可以通过张量积找到。

[1.x.2185]

其中 [2.x.5595] 是给定张量方向上广义特征值问题的特征向量矩阵 [2.x.5596] 。

[1.x.2186]

和[2.x.5597]是代表广义特征值[2.x.5598]的对角矩阵。请注意，向量[2.x.5599]是这样的：它们同时对角化[2.x.5600]和[2.x.5601]，即[2.x.5602]和[2.x.5603] 。

deal.II库使用这个概念实现了一个类，叫做TensorProductMatrixSymmetricSum。

为了这个程序，我们坚持使用常数系数和直角坐标系网格，尽管基于张量积的近似版本对于更一般的网格仍然是可能的，而且算子评估本身当然是通用的。另外，我们也不关心自适应网格，因为多网格算法需要获得不同细化边缘的通量矩阵，如步骤39所解释的。然而，我们做的一件事是仍然将我们的块状Jacobi预处理包在PreconditionChebyshev里面。这个类使我们不必寻找适当的松弛参数（对于块-雅各比平滑器来说，二维的松弛参数约为0.7，三维的松弛参数约为0.5），而且通常比普通的雅各比平滑器提高了一些平滑效率，因为当设置切比雪夫多项式的度数为1或2时，它可以降低解的时间。

请注意，块状Jacobi平滑器有一个额外的好处：快速对角线化方法也可以解释为从FE_DGQHermite的Hermite-like多项式转变为一个单元拉普拉斯是对角线的基础。因此，它抵消了基础的影响，无论我们使用FE_DGQHermite还是FE_DGQ，都会得到相同的迭代次数。这与使用只有对角线的PreconditionChebyshev类（点Jacobi方案）相比，FE_DGQ和FE_DGQHermite确实表现不同，FE_DGQ需要的迭代次数比FE_DGQHermite少2-5次，尽管对类似Hermite的形状函数做了修改以确保良好的调节。


examples/step-59/doc/results.dox



[1.x.2187]

[1.x.2188]

与第37步一样，我们在运行时间方面评估多网格求解器。  在两个空间维度的8度元素中，一个可能的输出可能如下。

[1.x.2189]



与第37步一样，随着问题大小的增加，CG的迭代次数保持不变。迭代次数要高一些，这是因为我们使用的切比雪夫多项式的度数较低（步骤37中为2比5），而且内部惩罚离散化的特征值分布也比较大。尽管如此，13次迭代将残差减少了12个数量级，或者说每次迭代几乎是9个系数，这表明总体上是一种非常有效的方法。特别是，当使用12个核心时，我们可以在5秒内解决一个具有2100万自由度的系统，这是一个非常好的效率。当然，在二维中，我们很好地进入了8级多项式的四舍五入体系；事实上，大约83000个自由度或0.025秒就足以完全收敛这个（简单的）分析解。

如果我们在三个空间维度上运行程序，并没有太大的变化，只是我们现在用做更高的多项式度数和不断增加的网格大小来做一些更有用的事情，因为舍入误差只在最细的网格上获得。尽管如此，令人瞩目的是，我们可以在一台12核的机器上非常容易地解决一个具有三个周期的波浪的三维拉普拉斯问题，达到四舍五入的精度--对于24m DoFs的第二至最大的情况，总共使用约3.5GB的内存，花费不超过8秒。最大的案例使用了30GB的内存，有1.91亿个DoFs。

[1.x.2190]



[1.x.2191]

在介绍和代码中的评论中，多次提到用FEEvaluation和FEFaceEvaluation评估器可以非常有效地处理高阶。现在，我们想通过观察三维多网格求解器在不同多项式程度下的吞吐量来证实这些说法。我们收集的时间如下。我们首先在问题大小接近一千万的情况下运行求解器，如表前四行所示，并记录时间。然后，我们通过记录每秒解决的百万自由度数（MDoFs/s）来规范吞吐量，以便能够比较不同程度的效率，计算方法是自由度数除以求解器时间。

[2.x.5604]

我们清楚地看到每个DoF的效率最初是如何提高的，直到它达到多项式度数的最大值 [2.x.5605] 。这种效果是令人惊讶的，不仅是因为较高的多项式度数通常会产生一个好得多的解决方案，而且特别是当考虑到基于矩阵的方案时，在较高的度数下更密集的耦合会导致单调的吞吐量下降（在3D中是一个急剧的下降，[2.x.5606]比[2.x.5607]慢十倍以上！）。对于更高的度数，吞吐量减少了一些，这既是由于迭代次数的增加（从[2.x.5608]的12次增加到[2.x.5609]的19次），也是由于运算符评估的[2.x.5610]复杂性。尽管如此，对于更高的多项式度数，作为求解时间的效率仍然会更好，因为它们有更好的收敛率（至少对于像这个问题一样简单的问题）。对于[2.x.5611]，我们在100万个DoFs的情况下已经达到了舍入精度（求解时间不到一秒），而对于[2.x.5612]，我们需要2400万个DoFs和8秒钟。对于[2.x.5613]，误差约为[2.x.5614]的5700万个DoFs，因此，尽管花了16秒，但离舍入还很远。

请注意，上述数字有点悲观，因为它们包括切比雪夫平滑器计算特征值估计的时间，这大约是求解器时间的10%。如果系统被多次求解（例如在流体力学中很常见），这个特征值的成本只需支付一次，更快的时间就可以得到。

[1.x.2192]

最后，我们来看一下本教程程序中提出的一些特殊成分，即特别是FE_DGQHermite基础和[2.x.5615]的规格。 在下面的表格中，第三行显示了上面的优化求解器，第四行显示了只将[2.x.5616]设置为 "未指定 "而不是最优的 "网格"，最后一行是用基本的FE_DGQ元素代替FE_DGQHermite，其中MPI交换更加昂贵，由[2.x.5617]和[2.x.5618]完成的操作

[2.x.5619]

表中的数据显示，不使用[2.x.5620]对于较高的多项式度数来说，成本增加了10%左右。对于较低的度数，差异显然没有那么明显，因为体积与表面的比例更有利，需要交换的数据更少。如果只看矩阵-向量乘积，而不是这里显示的完整的多网格求解器，差异会更大，仅仅因为MPI通信，时间就会差20%左右。

对于[2.x.5621]和[2.x.5622]，类似Hermite的基函数显然没有真正得到回报（事实上，对于[2.x.5623]，多项式与FE_DGQ完全相同），其结果与FE_DGQ基函数相似。然而，对于从3开始的度数，我们看到FE_DGQHermite的优势越来越大，显示了这些基函数的有效性。

[1.x.2193]

正如介绍中提到的，快速对角线化方法与具有恒定系数的直角坐标网相联系。如果我们想解决可变系数的问题，我们就需要在平滑参数的设计上投入更多的时间，选择适当的泛函（例如，在最近的箱形元素上近似反演）。

另一种扩展程序的方式是包括对自适应网格的支持，对于这种支持，在不同细化水平的边缘进行接口操作是必要的，如步骤39所讨论的。


examples/step-6/doc/intro.dox

[1.x.2194]

[1.x.2195]

[2.x.5624]

这个程序最后是关于deal.II的主要特征之一：使用自适应（局部）细化网格。这个程序仍然是基于步骤4和步骤5的，而且，正如你将看到的，实际上不需要花太多的代码来实现自适应性。事实上，虽然我们做了大量的解释，但自适应网格可以被添加到一个现有的程序中，几乎不需要十几行额外的代码。该程序显示了这些行是什么，以及自适应网格细化（AMR）的另一个重要成分：一个标准，可以用来确定是否有必要细化一个单元，因为它上面的误差很大，是否可以粗化这个单元，因为它上面的误差特别小，或者我们是否应该让这个单元保持原样。我们将在下文中讨论所有这些问题。




[1.x.2196]

有许多方法可以自适应地细化网格。整个算法的基本结构总是相同的，由以下步骤的循环组成。

- 在当前网格上求解PDE。

- 用一些能说明误差的标准来估计每个单元格的误差。

- 把那些误差大的单元格标记为细化，把那些误差特别小的单元格标记为粗化，其余的就不用管了。

- 细化和粗化如此标记的单元，得到一个新的网格。

- 在新的网格上重复上述步骤，直到整体误差足够小。

由于一些可能被历史遗忘的原因（也许是这些函数过去是用FORTRAN语言实现的，这种语言并不关心某个东西是用小写字母还是大写字母拼写的，程序员经常习惯性地选择大写字母），上述循环在关于网格适应性的出版物中经常被称为SOLVE-ESTIMATE-MARK-REFINE循环（用这种拼法）。

然而，在这个结构之外，有多种方法可以实现这一点。从根本上说，它们的区别在于究竟如何从前一个网格中生成一个网格。

如果要使用三角形（deal.II没有这样做），那么就有两种基本的可能性。

- 最长边细化。在这个策略中，通过从最长边的中点到对面的顶点引入一条新的边，将一个标记为细化的三角形切成两段。当然，来自最长边的中点必须以某种方式通过*也*完善该边另一侧的单元格（如果有的话）来平衡。如果有问题的边也是相邻单元的最长边，那么我们可以直接运行一条新的边穿过相邻单元到对面的顶点；否则就需要一个稍微复杂的结构，在相邻单元的至少一条其他边上增加更多的新顶点，然后可能传播到相邻单元的邻居，直到算法终止。这很难用语言描述，而且因为deal.II不使用三角形，不值得在这里花时间。   但如果你很好奇，你可以随时在本介绍顶部显示的链接中观看视频讲座15。

- 红-绿细化。另一个选择是所谓的 "红绿细化"。   这种策略甚至更难描述（但在视频讲座中也讨论过），其优点是细化不会传播到我们想要细化的单元的近邻之外。然而，它的实施难度要大得多。

这些方法还有其他的变化，但重要的一点是，它们总是产生一个网格，其中两个单元的接触线是两个相邻单元的整个边缘。只要稍加努力，这种策略就可以很容易地适用于由四面体构成的三维网格。

这两种方法对2D的四边形和3D的六面体都不起作用，或者至少不容易。原因是要精化的四边形单元的四边形邻居所产生的过渡元素将是三角形，而我们不希望这样。因此，在deal.II中选择的适应性方法是使用网格，其中相邻的单元在细化水平上可能相差一个。这就导致在单元的界面上出现属于一方的节点，但在另一方是不平衡的。这些节点的通用术语是&ldquo;悬挂节点&rdquo;，这些网格在非常简单的情况下看起来是这样的。

[2.x.5625]

一个更复杂的二维网格看起来是这样的（并在下面的 "结果 "部分讨论）。

<img src="https://www.dealii.org/images/steps/developer/step_6_grid_5_ladutenko.svg" alt="第五个自适应细化的拉杜腾科网格：单元格沿着内圈聚拢。" width="300" height="300">

最后，这里展示了一个具有这种悬挂节点的三维网格（来自步骤-43）。

<img src="https://www.dealii.org/images/steps/developer/step-43.3d.mesh.png" alt="" width="300" height="300">

第一个和第三个网格当然是基于一个正方形和一个立方体，但正如第二个网格所显示的，这不是必要的。重要的一点是，我们可以独立于其邻居来细化一个网格（受制于一个单元只能比其邻居多细化一次的约束），但如果我们这样做，最终会出现这些&ldquo;悬空节点&rdquo;。




[1.x.2197]

现在你已经看到了这些自适应细化网格的样子，你应该问[1.x.2198]我们为什么要这样做。毕竟，我们从理论上知道，如果我们对网格进行全局细化，误差会下降到零，因为

[1.x.2199]

其中[2.x.5626]是独立于[2.x.5627]和[2.x.5628]的一些常数，[2.x.5629]是使用中的有限元的多项式程度，[2.x.5630]是最大单元的直径。那么，如果[1.x.2200]单元很重要，那么为什么我们要在域的某些部分将网格做得很细，而不是全部？

答案在于观察到上面的公式不是最佳的。事实上，一些更多的工作表明，以下是一个更好的估计（你应该与上述估计的平方进行比较）。

[1.x.2201]

(因为[2.x.5631]，如果你只是把网格大小从总和中拉出来，这个公式立即暗示了前一个公式)。这个公式所暗示的是，没有必要把[1.x.2202]单元格做得很小，而单元格真正只需要做小的[1.x.2203]!换句话说。网格实际上只需要在解有较大变化的地方做得很细，正如[2.x.5632]st导数所表明的。这是有直观意义的：例如，如果我们使用一个线性元素[2.x.5633]，那么即使网格很粗，那些解几乎是线性的地方（如[2.x.5634]所示的小地方）也会被很好地解决。只有那些二阶导数大的地方才会被大元素解决得很差，因此我们应该把网格做得很小。

当然，这个[1.x.2204]在实践中不是很有用，因为我们不知道问题的精确解[2.x.5635]，因此，我们不能计算[2.x.5636] 。但是，这也是通常采取的方法，我们可以只根据之前计算的离散解[2.x.5638]来计算[2.x.5637]的数值近似值。我们将在下面稍微详细地讨论这个问题。这将有助于我们确定哪些单元具有较大的[2.x.5639]st导数，然后这些单元将成为细化网格的候选单元。




[1.x.2205]

上面提到的使用三角形网格的方法，都是为了确保每个顶点都是所有相邻单元的顶点--也就是说，没有悬空节点。这就自动确保了我们能够以这样的方式定义形状函数，即它们是全局连续的（如果我们使用到目前为止在教程程序中一直使用的常见的[2.x.5640]拉格朗日有限元方法，如FE_Q类所代表的）。

另一方面，如果我们在有悬挂节点的网格上定义形状函数，我们最终可能得到不连续的形状函数。要看到这一点，请想一下上面的情况，即右上角的单元没有被细化，并考虑一下使用双线性有限元的情况。在这种情况下，与悬挂节点相关的形状函数是以明显的方式定义在与每个悬挂节点相邻的两个小单元上。但我们如何将它们扩展到相邻的大单元呢？显然，函数对大单元的扩展不能是双线性的，因为那样的话，它需要沿着大单元的每条边线性化，这意味着它在整条边上需要为零，因为它需要在大单元的两个顶点上为零。但从小单元一侧看，它在悬挂节点本身并不是零--所以它不是连续的。下面三幅图显示了沿着有关边缘的三个形状函数，当以通常的方式简单地根据它们相邻的单元格来定义时，这些形状函数变成了不连续的。

<div class="threecolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> [2.x.5641] </div> </div> <div class="parent"> <div class="img" align="center"> [2.x.5642] </div> </div> <div class="parent"> <div class="img" align="center"> [2.x.5643] </div> </div></div>


但我们确实希望有限元解是连续的，这样我们就有了&ldquo;符合要求的有限元方法&rdquo;，其中离散有限元空间是我们寻求拉普拉斯方程解的[2.x.5644]函数空间的一个适当子集。为了保证全局解在这些节点上也是连续的，我们必须对这些节点上的解的值提出一些额外的约束。诀窍是要认识到，虽然上面显示的形状函数是不连续的（因此它们的[1.x.2206]线性组合也是不连续的），但形状函数加起来为[2.x.5645]的线性组合可以是连续的[1.x.2207]。换句话说，系数[2.x.5646]不能任意选择，而必须满足某些约束条件，这样，函数[2.x.5647]实际上是连续的。这些约束条件在概念上相对容易理解，但在软件中的实现却很复杂，需要几千行的代码。另一方面，在用户代码中，在处理挂起的节点时，你只需要添加大约半打的行。

在下面的程序中，我们将展示如何从deal.II中获得这些约束，以及如何在线性方程组的求解中使用它们。在了解下面程序的细节之前，你可能想看看[2.x.5648]文件模块，它解释了这些约束如何计算以及deal.II中哪些类对它们起作用。




[1.x.2208]

悬挂节点约束的实践比我们上面概述的理论更简单。实际上，你只需要在step-4这样的程序中增加半打额外的代码，就可以使它在有悬挂节点的自适应网格中工作。有趣的是，这与你要解决的方程完全无关。这些约束的代数性质与方程无关，只取决于对有限元的选择。因此，处理这些约束的代码完全包含在deal.II库本身，你不需要担心细节问题。

你需要使其发挥作用的步骤基本上是这样的。

- 你必须创建一个AffineConstraints对象，（顾名思义）它将存储有限元空间的所有约束。在目前的情况下，这些约束是由于我们希望保持解空间的连续，甚至在有悬空节点的情况下。(下面我们还将简要地提到，我们还将把边界值放到这个对象中，但这是一个单独的问题)。

- 你必须使用函数[2.x.5649]来填充这个对象，以确保有限元空间的元素的连续性。

- 当你通过使用[2.x.5650]将矩阵和右手边的局部贡献复制到全局对象时，你必须使用这个对象。 到目前为止，我们已经自己完成了这个工作，但现在有了约束，这就是神奇的地方，我们将约束应用到线性系统中。这个函数所做的是确保位于悬空节点的自由度事实上不是真正的自由。相反，通过将它们的行和列设置为零，并在对角线上放置一些东西以确保矩阵保持可反转，它们实际上被从线性系统中消除了。   对于我们在这里解决的拉普拉斯方程来说，这个过程产生的矩阵仍然是对称和正定的，所以我们可以继续使用共轭梯度法来解决。

- 然后你像往常一样求解线性系统，但在这一步结束时，你需要确保位于悬挂节点上的 "自由度 "得到正确的（约束的）值，这样你随后可视化的或以其他方式评估的解决方案实际上是连续的。这可以通过在求解后立即调用[2.x.5651]来实现。

这四个步骤实际上是所有必要的--从用户的角度来看就是这么简单。事实上，在上面提到的函数调用中，你将运行几千行并不复杂的代码，这一点完全不重要。在用户代码中，实际上只有四个额外的步骤。




[1.x.2209]

下一个问题是，既然我们知道如何[1.x.2210]处理有这些悬挂节点的网格，那么我们如何[1.x.2211]它们。

一个简单的方法已经在步骤1中展示过了：如果你[1.x.2212]哪里需要细化网格，那么你可以手工创建一个。但是在现实中，我们并不知道这些。我们不知道PDE的解在前面（因为，如果我们知道，我们就不必使用有限元方法），因此，我们不知道哪里需要增加局部网格细化来更好地解决解有强烈变化的区域。但是上面的讨论表明，也许我们可以用一个网格上的离散解[2.x.5652]来估计导数[2.x.5653]，然后用这个来确定哪些单元太大，哪些已经足够小。然后，我们可以使用局部网格细化技术从当前的网格中生成一个新的网格。如果有必要，这个步骤会重复进行，直到我们对我们的数值解决方案感到满意--或者，更常见的是，直到我们耗尽了计算资源或耐心。

所以这正是我们要做的。局部细化网格是使用一个[1.x.2213]产生的，它可以估计拉普拉斯算子的数值解的能量误差。由于它是由Kelly和他的同事开发的，我们经常在库、文档和邮件列表中把它称为&ldquo;Kelly细化指标&rdquo;。实现它的类被称为KellyErrorEstimator，在该类的文档中可以找到大量的信息，这里不需要重复。然而，总结起来就是，该类计算出一个具有与[2.x.5654]"活动单元 "一样多的条目的向量，其中每个条目包含对该单元的误差估计。这个估计值然后被用来细化网格的单元：那些有大误差的单元将被标记为细化，那些有特别小估计值的单元将被标记为粗化。我们不需要用手去做这些。一旦我们获得了误差估计矢量，命名空间GridRefinement中的函数将为我们完成这一切。

值得注意的是，虽然Kelly误差估计器是为拉普拉斯方程开发的，但它已被证明是为广泛的方程生成局部细化网格的合适工具，甚至不限于只针对椭圆问题。尽管它对其他方程会产生非最优网格，但它往往是快速产生网格的好方法，能很好地适应解的特征，如大变化区域或不连续性。




[1.x.2214]

事实证明，人们可以把迪里希特边界条件看作是对自由度的另一种约束。这的确是一个特别简单的约束。如果[2.x.5655]是边界上的一个自由度，其位置为[2.x.5656]，那么在[2.x.5658]上施加边界条件[2.x.5657]就会产生约束[2.x.5659] 。

AffineConstraints类也可以处理这样的约束，这使得我们可以方便地让我们用于悬挂节点约束的同一个对象也处理这些Dirichlet边界条件。这样一来，我们就不需要在装配后应用边界条件（就像我们在前面的步骤中做的那样）。所有需要的是我们调用[2.x.5660]的变体，该变体在AffineConstraints对象中返回其信息，而不是我们在以前的教程程序中使用的[2.x.5661]。


[1.x.2215]


由于用于局部细化网格的概念非常重要，我们在这个例子中没有展示很多其他材料。最重要的例外是，我们展示了如何使用双二次元而不是之前所有例子中使用的双线性元素。事实上，使用高阶元素只需替换程序中的三行，即在本程序主类的构造函数中初始化[2.x.5662]成员变量，以及在两个地方使用适当的正交公式。程序的其他部分没有变化。

其他唯一的新东西是在[2.x.5663]函数中捕捉异常的方法，以便在程序因某种原因崩溃时输出一些信息。下面将详细讨论这个问题。


examples/step-6/doc/results.dox



[1.x.2216]


程序的输出看起来如下。

[1.x.2217]






正如预期的那样，在每个周期中，单元格的数量大约增加了一倍。度数略多于单元数的四倍；人们期望在无限网格的两个空间维度上的系数正好是四（因为自由度之间的间隔是单元宽度的一半：每个边缘有一个额外的自由度，每个单元的中间有一个），但由于网格的有限尺寸和由悬挂节点和局部细化引入的额外自由度，它大于这个系数。




程序在细化循环的每个周期都输出解决方案和网格。解决方案看起来如下。

[2.x.5664]

关注该程序如何得出最终的网格是很有趣的。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_0.svg" alt="初始网格：具有一个全局细化的五格圆形网格。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_1.svg" alt="第一个网格：具有两个全局细化的五格圆形网格。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_2.svg" alt="第二个网格：有一个自适应细化的五格圆形网格。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_3.svg" alt="第三个网格：有两个自适应细化的五格圆形网格，显示围绕内圆的聚类。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_4.svg" alt="第四个网格：具有三个自适应细化的五格圆形网格，显示了围绕内圈的聚类。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_5.svg" alt="第五个网格：具有四个自适应细化的五格圆形网格，显示了围绕内圈的聚类。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_6.svg" alt="第六个网格：具有五个自适应细化的五格圆形网格，显示了围绕内圈的聚类。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_7.svg" alt="最后一个网格：有六个自适应细化的五格圆形网格，显示大多数单元都聚集在内圆周围。" width="300" height="300"> </div> </div>


可以清楚地看到，在解有扭结的区域，也就是离中心0.5的径向距离的圆，被精炼得最多。此外，解非常光滑和几乎平坦的中心区域几乎完全没有被细化，但这是由于我们没有考虑到那里的系数很大的事实。外面的区域被任意细化，因为那里的二阶导数是恒定的，因此细化主要是基于单元的大小和它们与最佳方形的偏差。




[1.x.2218]

[1.x.2219]

[1.x.2220]


如果一个人要解决相当大的问题（比我们这里的问题大得多），有一件事总是值得一试的，那就是尝试不同的求解器或预处理器。在目前的情况下，线性系统是对称的和正定的，这使得CG算法几乎成了求解的典型选择。然而，我们在[2.x.5665]函数中使用的SSOR预处理器是可以争夺的。

在deal.II中，改变预处理程序是比较简单的。例如，通过改变现有的几行代码

[1.x.2221]

进入

[1.x.2222]

我们可以尝试SSOR的不同放松参数。通过使用

[1.x.2223]

我们可以使用Jacobi作为预处理程序。而通过使用

[1.x.2224]

我们可以使用一个简单的不完全LU分解，不需要任何阈值处理或加强对角线（要使用这个预处理程序，你还必须把头文件[2.x.5666]添加到文件顶部的包含列表中）。

使用这些不同的预处理程序，我们可以比较所需的CG迭代次数（可通过[2.x.5667]调用，见步骤4）以及所需的CPU时间（使用Timer类，例如在步骤28中讨论的），得到如下结果（左：迭代次数；右：CPU时间）。

[2.x.5668]

我们可以看到，在这个简单的问题上，所有的预处理程序的表现都差不多，迭代次数的增长是[2.x.5669]，由于每次迭代需要大约[2.x.5670]次操作，总的CPU时间增长是[2.x.5671]（对于几个最小的网格，CPU时间小到没有记录）。请注意，尽管它是最简单的方法，但对于这个问题，雅可比是最快的。

当有限元不是本程序构造函数中设定的双二次元，而是双线性的时候，情况会有一些变化。如果做此改变，结果如下。

[2.x.5672]

换句话说，虽然迭代次数和CPU时间的增加与以前一样，但Jacobi现在是需要迭代次数最多的方法；不过，由于它必须执行的操作很简单，所以它仍然是最快的方法。这并不是说Jacobi实际上是一个好的预处理方法--对于规模可观的问题来说，它绝对不是，其他方法会好得多--而实际上只是因为它的实现非常简单，可以补偿更多的迭代次数，所以它的速度很快。

从这里得到的信息并不是预处理程序的简单性总是最好的。虽然这对目前的问题可能是正确的，但一旦我们转向更复杂的问题（弹性或斯托克斯，例如第8步或第22步），就绝对不是这样了。其次，所有这些预处理程序仍然会导致迭代次数随着自由度数[2.x.5673]的增加而增加，例如[2.x.5674]；这反过来又会导致总工作量增加为[2.x.5675]，因为每次迭代都需要[2.x.5676]的工作。这种行为是不可取的：我们真的希望用[2.x.5677]个未知数解决线性系统，总工作量为[2.x.5678]个；有一类预处理程序可以实现这一点，即几何（step-16、step-37、step-39）或代数多网格（step-31、step-40和其他几个）预处理程序。然而，它们要比上述的预处理程序复杂得多。

最后，要带回家的最后一个信息是，当上面显示的数据产生时（2018年），有10万个未知数的线性系统在台式机上很容易在大约一秒钟内解决，使相对简单的2d问题的解决甚至达到非常高的精度，甚至在过去也不是一个大任务。当时，三维问题的情况完全不同，但即使是这样，在过去的时间里也发生了很大的变化--尽管在三维中解决高精度的问题仍然是一个挑战。




[1.x.2225]

如果你看一下上面的网格，你会发现即使域是单位盘，系数的跳动是沿着圆的，构成网格的单元也不能很好地跟踪这个几何体。原因在步骤1中已经暗示过了，在没有其他信息的情况下，Triangulation类只看到一堆粗略的网格单元，但当然不知道它们在一起看时可能代表什么样的几何形状。出于这个原因，我们需要告诉Triangulation在一个单元被细化时应该做什么：边缘中点和单元中点的新顶点应该位于哪里，以便子单元比父单元更好地代表所需的几何图形。

为了直观地了解三角计算对几何体的实际了解，仅仅输出顶点的位置和为每条边画一条直线是不够的；相反，我们必须将内部线和边界线都输出为多段线，使它们看起来是弯曲的。我们可以通过对[2.x.5679]的gnuplot部分做一个改变来做到这一点。

[1.x.2226]



在上面的代码中，我们已经对位于边界的面做了这个处理：由于我们使用了[2.x.5680]，它将一个SphericalManifold附着在域的边界上，所以这是自动发生的。为了使网格[1.x.2227]也能追踪到一个圆形域，我们需要更努力一些。首先，回顾一下我们的粗略网格由一个中心的方形单元和周围的四个单元组成。现在首先考虑一下，如果我们不仅将SphericalManifold对象连接到四个外部面，而且还连接到周边的四个单元以及它们的所有面，会发生什么。我们可以通过添加下面的片段来实现（测试一个单元的中心是否大于单元直径的一个小倍数，比如说十分之一，远离网格中心的单元直径，只对网格中心的正方形失效）。

[1.x.2228]



经过几个全局细化的步骤，这将导致以下类型的网格。


  <div class="onecolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_bad_grid_4.svg" alt="一些中央单元格几乎呈三角形的网格。" width="300" height="300"> </div> </div>

这不是一个好的网格：中心单元已经被细化，位于原始中心单元[1.x.2229]的四个角的子单元：随着网格细化的继续，它们都倾向于三角形。这意味着从参考单元到实际单元的转换的Jacobian矩阵对这些单元来说是退化的，由于有限元解的所有误差估计都包含Jacobian矩阵的反值，你会在这些单元上得到非常大的误差，而且随着网格细化的极限，收敛顺序的损失，因为这些角落的单元在网格细化下变得越来越差。

所以我们需要更聪明的东西。为此，考虑以下最初由Konstantin Ladutenko开发的解决方案。我们将使用以下代码。

[1.x.2230]



然后，这段代码生成了以下更好的网格序列。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_0_ladutenko.svg" alt="初始网格：带有一个全局细化的Ladutenko网格。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_1_ladutenko.svg" alt="第一个自适应细化的Ladutenko网格。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_2_ladutenko.svg" alt="第二个自适应细化的Ladutenko网格。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_3_ladutenko.svg" alt="第三个自适应细化Ladutenko网格。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_4_ladutenko.svg" alt="第四个自适应细化Ladutenko网格。细胞沿着内圈聚集。" width="300" height="300"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_6_grid_5_ladutenko.svg" alt="第五个自适应改进的拉杜腾科网格：细胞沿着内圈聚集。" width="300" height="300"> </div> </div>

创建好的网格，特别是使它们适合你想要的几何形状，本身就是一个复杂的话题。你可以在步骤49、步骤53和步骤54中找到更多关于这个问题的内容，以及其他涉及这个问题的教程程序。步骤65展示了另一个不那么手动的方法来实现一个很适合这里的问题的网格。关于弯曲域的信息也可以在[2.x.5681]"流形描述 "的文档模块中找到。

为什么选择一个跟踪内部界面的网格是有意义的？有很多原因，但最重要的原因是我们在双线性表格中实际整合的内容。从概念上讲，我们想把[2.x.5682]作为单元格[2.x.5683]对矩阵条目[2.x.5684]的贡献来整合。我们无法精确计算，只能求助于正交法。我们知道，如果积分是平滑的，正交是准确的。这是因为正交法实质上是计算积分的多项式近似值，与积分在正交点上重合，然后计算这个多项式下的体积，作为原始积分下体积的近似值。如果积分在一个单元上是平滑的，这个多项式插值是准确的，但如果积分在一个单元上是不连续的，它通常是相当不准确的。

因此，值得将细胞排列成这样的方式，使系数不连续的界面与细胞界面对齐。这样一来，系数在每个单元上都是恒定的，之后积分将是平滑的，其多项式近似和积分的正交近似都将是准确的。请注意，这样的排列方式在许多实际案例中很常见，因此deal.II提供了一些函数（如[2.x.5685]"material_id"）来帮助管理这种情况。请参考步骤28和步骤46，了解如何应用material ids的例子。

最后，让我们考虑一个在空间中具有平滑和非均匀分布的系数的情况。我们可以再一次重复上面关于用正交法表示这种函数的所有讨论。所以，为了准确地模拟它，有几个现成的选择：你可以减少单元格的大小，增加正交公式中使用的多项式的阶数，选择一个更合适的正交公式，或进行这些步骤的组合。关键是，用正交多项式提供系数的空间依赖性的最佳拟合将导致PDE的更精确的有限元解。

最后说明一下：前面几段的讨论表明，我们在这里有一种非常具体的方式来说明我们认为的好的网格--它应该与系数中的跳跃相一致。但人们也可以在一个更普遍的环境中提出这样的问题。给定一些具有光滑解和光滑系数的方程，我们能说一个好的网格是什么样子的吗？这个问题的答案在直觉上比数学上更容易表述。一个好的网格，其单元格大体上都像正方形（或立方体，在三维空间）。一个不好的网格会包含一些在某些方向上非常细长的单元，或者，更广泛地说，其中有一些单元的边缘既短又长。有很多方法可以给每个单元分配一个数字质量指数，以衡量该单元是 "好 "还是 "坏"；其中一些经常被选择，因为它们便宜且容易计算，而另一些则是基于收敛性证明中的内容。前者的一个例子是一个单元格的最长边与最短边的比率。在理想的情况下，这个比率是1；不好的单元格的值远远大于1。后者的例子是考虑从参考单元[2.x.5686]到实际单元[2.x.5687]的映射的梯度（"Jacobian"）；这个梯度是一个矩阵，进入误差估计的一个量是参考单元上所有点的最大值，即这个矩阵的最大和最小的特征值的比率。同样不难看出，如果单元格[2.x.5688]是[2.x.5689]的仿生图像，这个比率是恒定的，对于正方形和长方体来说是一个。

在实践中，将这种质量衡量标准可视化可能是很有趣的。函数[2.x.5690]提供了一种获得这种信息的方法。更好的是，可视化工具，如VisIt，通常允许你在可视化软件中对各种措施进行可视化；在VisIt的情况下，只需添加一个 "伪色 "图，并选择一个网格质量措施，而不是解决方案领域。




[1.x.2231]

从数学的角度来看，拉普拉斯方程的解决方案

[1.x.2232]

在光滑有界的凸域上，已知其本身是光滑的。确切的光滑程度，即解所处的函数空间，取决于域的边界到底有多光滑，以及右手边的光滑程度。边界处可能会失去解的某些规律性，但一般来说，在域的紧凑子集中，解的可微性比右手边多一倍。特别是如果右手边满足[2.x.5691]，那么[2.x.5692]，其中[2.x.5693]是[2.x.5694]的任何紧凑子集（[2.x.5695]是一个开放域，所以紧凑子集需要与[2.x.5696]保持一个正距离）。

然而，我们为目前的例子选择的情况是不同的：我们看的是一个具有非常数系数的方程 [2.x.5697] 。

[1.x.2233]

这里，如果[2.x.5698]不光滑，那么无论[2.x.5699]如何，解也不会光滑。特别是，我们希望在[2.x.5700]沿直线（或沿三维平面）不连续的地方，解会有一个结点。这很容易看出来：例如，如果[2.x.5701]是连续的，那么[2.x.5702]也需要是连续的。这意味着[2.x.5703]必须是可连续微分的（不存在扭结）。因此，如果[2.x.5704]有一个不连续，那么[2.x.5705]必须有一个相反的不连续，从而使两者完全抵消，它们的乘积得到一个没有不连续的函数。但是要使[2.x.5706]有一个不连续，[2.x.5707]必须有一个结点。当然，这正是当前例子中所发生的情况，在解的图片中也很容易观察到。

一般来说，如果系数[2.x.5708]沿着2D的直线或3D的平面是不连续的，那么解可能有一个结点，但解的梯度不会到无限大。这意味着，解至少还在[1.x.2234][2.x.5709]中（也就是说，大致上是在导数有界的函数空间中）。另一方面，我们知道，在最极端的情况下--即域有重入角，右手边只满足[2.x.5710]，或者系数[2.x.5711]只在[2.x.5712]中--我们所能期望的是，[2.x.5713]（即导数是可平方整除的函数的[1.x.2235]），是比[2.x.5714]大很多的空间 。要创造出解在空间[2.x.5715]中的案例并不十分困难，我们可以让[2.x.5716]变得像我们想要的那样小。这样的情况经常被用来测试自适应有限元方法，因为网格要解决导致解不再在[2.x.5717]中的奇异点。

人们为此使用的典型例子叫做[1.x.2236]（指[2.x.5718]），在常用的形式中，它的系数[2.x.5719]在平面的四个象限有不同的值（或在[2.x.5720]的八个象限有不同的值）。确切的规则性程度（上述索博列夫空间索引中的[2.x.5721]）取决于[2.x.5722]的值在原点处聚集，通过选择足够大的跳跃，可以使解的规则性尽可能地接近[2.x.5723] 。

为了实现这样的东西，可以用以下方法来代替系数函数（这里只显示2d情况）。

[1.x.2237]

(在结尾处添加[2.x.5724]，以确保在我们到达那个点时，要么抛出一个异常，要么程序中止。

--当然我们不应该这样做，但这是给自己上保险的好方法：我们都会犯错，因为有时没有想到所有的情况，例如检查[2.x.5725]是否小于和大于零，而不是大于或等于零，从而忘记了一些情况，否则会导致难以发现的错误。最后的[2.x.5726]只是为了避免编译器警告说函数没有在[2.x.5727]语句中结束 -- 编译器无法看到由于前面的[2.x.5728]语句，函数实际上永远不会到达那个点）。)

通过玩弄这种四个或更多的扇形聚集在一起，并且在这些扇形上的系数有不同的值的情况，我们可以构造出解在原点有奇异点的情况。我们还可以看到在这种情况下网格是如何被细化的。


examples/step-60/doc/intro.dox

[2.x.5729]

[1.x.2238]

[2.x.5730]




[1.x.2239]

[1.x.2240]


在本教程中，我们考虑两个域的情况，[2.x.5731]在[2.x.5732]和[2.x.5733]在[2.x.5734]，其中[2.x.5735]嵌入在[2.x.5736]（[2.x.5737] ）。我们想在[2.x.5738]上解决一个偏微分方程，对问题的解决*在嵌入域*[2.x.5739]上强制执行一些条件。

有两种有趣的情况。

- 嵌入域[2.x.5740]的几何维度`dim`与域[2.x.5741]相同（`spacedim`），也就是说，[2.x.5742]的spacedim维度不为零，或

- 嵌入域[2.x.5743]的内在维度`dim`小于[2.x.5744]的维度（`spacedim`），因此其spacedim维度为零；例如，它是一条嵌入二维域的曲线，或一个嵌入三维域的曲面。

在这两种情况下，定义限制算子[2.x.5745]为算子，给定[2.x.5746]上的一个连续函数，返回其在[2.x.5747]上的（连续）限制，即：。

[1.x.2241]

众所周知，当[2.x.5748]的内在维度与[2.x.5753]相同时，算子[2.x.5748]可以扩展为[2.x.5749]上的连续算子，将[2.x.5750]的函数映射为[2.x.5751]的函数。

同样的道理，在一个不太规则的范围空间（即[2.x.5754]）中，当[2.x.5755]的维度相对于[2.x.5756]少一个，并且[2.x.5757]没有边界。在这第二种情况下，算子[2.x.5758]也被称为*轨迹*算子，对于嵌入[2.x.5760]中的Lipschitz同维度曲线和曲面[2.x.5759]，它有很好的定义（阅读[1.x.2242]了解关于轨迹算子的进一步细节）。

同维度的情况要复杂一些，一般来说，不可能构造一个连续的跟踪算子，甚至不可能从[2.x.5761]到[2.x.5762]，当[2.x.5763]的维度在二维和三维中分别为零或一的时候。

在本教程中，我们对[2.x.5764]的进一步细节不感兴趣：我们认为扩展[2.x.5765]是理所当然的，假设嵌入域的尺寸（`dim`）总是比嵌入域的尺寸（`spacedim`）小一或相等。

我们要解决以下微分问题：给定[2.x.5767]上的一个足够规则的函数[2.x.5768]，找到[2.x.5769]的解。

[1.x.2243]



这是一个约束问题，我们正在寻找一个谐波函数[2.x.5770]，满足[2.x.5771]上的同质边界条件，受制于使用拉格朗日乘法器的约束[2.x.5772]。

这个问题有一个物理解释：谐波函数，即满足拉普拉斯方程的函数，可以被认为是边界值被规定的膜的位移。那么，目前的情况相当于找到一个膜的形状，对于这个膜来说，不仅边界上的位移，而且[2.x.5773]上的位移也是规定的。例如，如果[2.x.5774]是二维空间中的一条封闭曲线，那么这将是一个肥皂膜的模型，它被沿[2.x.5775]的一个线环以及沿[2.x.5776]的第二个线环固定住。在[2.x.5777]是整个区域的情况下，你可以把它看成是在障碍物上伸展的膜，其中[2.x.5778]是接触区域。如果接触面积不知道，我们就有一个不同的问题--称为 "障碍物问题"--在步骤41中进行建模）。

作为第一个例子，我们研究[2.x.5779]上的零迪里切特边界条件。如果我们在[2.x.5780]上应用零诺伊曼边界条件或两者的混合，同样的方程也适用。

通过引入两个无限维空间[2.x.5781]和[2.x.5782]，可以得出变分公式，分别用于解[2.x.5783]和拉格朗日乘子[2.x.5784]。

将第一个方程乘以[2.x.5785]，第二个方程乘以[2.x.5786]，在可能的情况下进行部分积分，并利用[2.x.5787]的边界条件，我们得到以下变量问题。

给出[2.x.5788]上的一个足够规则的函数[2.x.5789]，求[2.x.5790]的解

[1.x.2244]



其中[2.x.5791]和[2.x.5792]分别代表[2.x.5793]中的标量积和[2.x.5795]中的标量积 。

对变量公式的检查告诉我们，空间[2.x.5796]可以被认为是[2.x.5797]。空间[2.x.5798]，在同维度为零的情况下，应取为[2.x.5799]，而在同维度为一的情况下应取为[2.x.5800]。

因此函数[2.x.5801]应该在[2.x.5802]（对于同维度零的情况）或者[2.x.5803]（对于同维度一的情况）。这使得我们在[2.x.5805]中有一个拉格朗日乘数[2.x.5804]，它是[2.x.5806]或[2.x.5807]。

对于上述问题的离散化，有两种选择。可以选择匹配的离散化，即[2.x.5808]的三角化与[2.x.5809]的三角化一致，也可以选择以完全独立的方式离散化这两个域。

对于我们上面提出的简单问题，第一种选择显然更有意义：对[2.x.5810]使用一个单一的三角形就足够了，然后根据[2.x.5811]施加某些约束。在步骤40中研究了这种方法的一个例子，解决方案必须保持在一个障碍物之上，这是在[2.x.5812]上施加约束实现的。

为了解决更复杂的问题，例如域[2.x.5813]与时间有关的问题，第二个选项可能是一个更可行的解决方案。处理不对齐的网格本身就很复杂：为了说明如何做，我们研究一个简单的问题。

我们在此描述的技术在文献中使用了许多名称之一：[1.x.2245]、[1.x.2246]、[1.x.2247]等。其主要原理是，两个网格的离散化和两个有限元空间的离散化保持完整。