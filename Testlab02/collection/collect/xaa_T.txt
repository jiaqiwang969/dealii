examples/step-1/doc/intro.dox

[1.x.0]

[1.x.1]

[1.x.2]

由于这是第一个教程程序，让我们首先评论一下这个教程和deal.II的其他文档应该如何工作。deal.II的文档基本上有三个不同的层次。

- 该教程。这是一个程序集，展示了deal.II在实践中的应用。它通常不在单个参数的层面上讨论单个函数，而是希望给出事物如何共同工作的大画面。换句话说，它讨论的是 "概念"：什么是deal.II的构件，它们如何在有限元程序中一起使用。

- 该手册。这是deal.II中每一个类和每一个（成员）函数的文档。例如，如果你点击本页顶部的 "主页 "或 "类 "选项卡，你就可以看到。在这里你可以查到[2.x.0]的第二个参数是什么意思，这只是一个略显晦涩的例子。当你知道你要做什么，但忘记了函数到底是怎么命名的，它的参数是什么，或者它的返回值是什么时，你就需要这种级别的文档。请注意，当你读完教程并点击任何一个类或函数名称时，你也会进入手册，也就是说，当你需要对某个函数或类进行更详细的描述时，教程包含了大量进入手册的链接。另一方面，手册并不是学习deal.II的好地方，因为它只给你一个微观的观点，而没有告诉你一个函数是如何融入大局的。

- 模块。这些是一起工作或具有相关功能的类和函数组。如果你点击本页顶部的 "模块 "标签，你就会进入一个列出许多此类组的页面。每个模块都讨论了这些类的基本原理；例如，[2.x.1]模块讨论了与存储矩阵的稀疏模式有关的各种不同问题。这就是中级水平的文档：它们给你一个特定领域的概述。例如，当你想知道存在哪些有限元类时，你会看一下[2.x.2]模块。当然，这些模块也与手册（有时也与教程）有交叉链接；如果你点击一个类的名字，比如说三角法，如果你想了解更多关于这个类的背景，也会在类名的右上方得到一个指向这个类所属模块的链接。

让我们回到教程中来，因为你正在看的是它的第一个程序（或 "步骤"）。每个教程的程序都被细分为以下几个部分。<ol> [2.x.3] [1.x.3] 这是讨论程序的作用，包括数学模型，以及与以前的教程程序相比有哪些新的编程技术。    [2.x.4] [1.x.4] 广泛地记录了源代码的清单。在这里，我们经常记录个别行或代码块，并讨论它们做什么，如何做，以及为什么。评论中经常提到介绍，也就是说，你必须先了解[1.x.5]程序想要达到的目标（介绍中讨论的目标），然后才能了解[1.x.6]它想要达到的目标。    [2.x.5] [1.x.7] 程序的输出，包括注释和解释。这一部分也经常有一个小节，给出如何在不同方向上扩展程序的建议；在早期的程序中，这是为了给你提供小实验的方向，旨在使你熟悉deal.II，而在后来的程序中，更多的是关于如何使用更高级的数值技术。    [2.x.6] [1.x.8] 剥去所有注释的源代码。如果你想看到代码的 "全貌"，这很有用，因为程序的注释版本中间有很多文字，往往很难在屏幕上一次看到单个函数的全部代码。  [2.x.7]

教程不仅意味着是静态文档，而且你应该玩玩它们。为此，进入[2.x.8]目录（或任何你感兴趣的教程的编号），然后输入

[1.x.9]

第一条命令设置了描述本教程程序所依赖的包含文件、如何编译以及如何运行的文件。这条命令应该也能找到已安装的deal.II库，这些库是在你按照[1.x.10]文件中描述的方式编译和安装一切时产生的。如果这个命令不能找到deal.II库，那么你需要用命令提供安装的路径

[1.x.11]

而不是。

上述命令中的第二条将源代码编译成可执行文件，而最后一条则是执行它（严格来说，如果可执行文件还不存在，[2.x.9]也会编译代码，所以如果你想的话，你可以跳过第二条命令）。这就是运行代码和产生输出所需的全部内容，在教程程序的 "结果 "部分讨论。这个顺序需要在你想玩的所有教程目录中重复。

当学习这个库时，你需要玩玩它，看看会发生什么。为此，用你喜欢的编辑器打开[2.x.10]的源文件，并以某种方式进行修改，保存它并按上述方式运行它。在这个程序的结果部分的末尾给出了一些可能的修改建议，在那里我们还提供了一些其他有用信息的链接。




[1.x.12]

在关于deal.II和计算科学的[1.x.13]中也讨论和演示了这个和其他几个教程程序。特别是，你可以看到他为运行这个和其他程序所执行的步骤，你会对可以用来处理deal.II的工具有一个更好的了解。特别是，第2和第4讲概述了deal.II和任何有限元代码的构建模块。( [2.x.11]

如果你还不熟悉使用Linux和在命令行上运行东西，你可能会有兴趣观看讲座2.9和2.91。( [2.x.12]行和关于编译程序时发生的事情，分别。

请注意，deal.II正在积极开发，在开发过程中，我们偶尔会对这些视频讲座中仍然引用的函数或类进行重新命名或废弃。  例如，视频讲座5中的步骤1代码使用了一个HyperShellBoundary类，后来被SphericalManifold类取代。此外，从deal.II 9.0版本开始，[2.x.13]现在自动将SphericalManifold附加到Triangulation上。否则，讲座材料的其余部分都是相关的。

[1.x.14]

让我们回到步骤1，即当前的程序。在这第一个例子中，我们实际上并没有做很多事情，而是展示了两种技术：生成三角形对象的语法是什么，以及所有单元格上简单循环的一些元素。我们创建了两个网格，一个是有规律地细化的正方形（不是很刺激，但对于一些问题来说是常见的起始网格），还有一个是更多的几何尝试：一个环形域，向内边缘细化。通过这些，你将了解到每一个有限元程序都必须有的三样东西。一个用于网格的Triangulation类型的对象；对GridGenerator函数的调用以生成网格；以及涉及迭代器的所有单元的循环（迭代器是指针的泛化，在C++标准库中经常使用；在deal.II的背景下，[2.x.14]模块谈到了它们）。

该程序在其他方面足够小，不需要大量的介绍。

[2.x.15]




[1.x.15]

如果你正在阅读这个教程程序，很可能你有兴趣继续使用deal.II来完成你自己的项目。因此，你即将开始一个使用大规模科学计算库的编程练习。除非你已经是大规模编程方法的资深用户，否则这对你来说可能是一个新的领域；伴随着所有的新规则，比如你将不得不处理别人写的代码，你可能不得不考虑记录自己的代码，因为你可能在一年后不记得它到底在做什么（或者因为别人也会使用它），或者想出一些方法来测试你的程序是否在做正确的事情。这些都不是我们通常训练数学家、工程师或科学家的东西，但当你开始编写超过几百行的软件时，这些就很重要了。请记住。制作软件并不等同于仅仅编写代码。

为了使你在这一旅程中生活得更轻松，让我们指出一些资源，这些资源在你开始任何大规模的编程之前是值得浏览的。

- 在[1.x.16]中，有大量关于deal.II特定方面问题的答案，但也有一些更普遍的问题，如 "我如何调试科学计算代码？"或 "我能否训练自己写出错误更少的代码？"。

- 你将从成为一个更好的程序员中受益。为此，一个很好的资源是Steve McConnell的[Code Complete](https://en.wikipedia.org/wiki/Code_Complete) [2.x.16] 。这本书已经有几年的历史了，最后一版是在2004年出版的，但它作为良好的编程实践指南的吸引力丝毫不减，一些主要的开发者把它作为他们研究小组每一代成员的集体阅读项目。

- [1.x.17]，提供了处理软件的许多重要主题的介绍，如版本控制、make文件、测试等。它是专门为科学家和工程师编写的，而不是为计算机科学家编写的，并以简短的、实用的课程为重点。

- 1.x.18]有大量的资源（和有趣的博文），涵盖了编写科学软件的许多方面。

- [1.x.19]也有关于软件开发的资源，特别是用于并行计算。在该网站的 "活动 "部分有录制的教程和网络研讨会，涉及许多有趣的主题。

- 一篇关于[1.x.20]的文章，介绍了许多方法，通过这些方法，你可以确保你是一个高效的程序员，写出的程序可以正常工作。

作为一个一般性建议。如果你期望在未来花几天时间来编写软件，请帮你自己的忙，学习能够使你的生活更有效率的工具，特别是调试器和集成开发环境。( [2.x.17] 你会发现，通过提高工作效率，你很快就会把学习这些工具的时间拿回来几倍!上面提到的几个视频讲座展示了如何使用集成开发环境或调试器等工具。


examples/step-1/doc/results.dox



[1.x.21]

运行该程序会产生两个网格的图形（grid-1.svg和grid-2.svg）。你可以用大多数网络浏览器打开它们--在最简单的情况下，只要在文件系统资源管理器中打开当前目录，然后点击文件。如果你喜欢在命令行上工作，你可以用该文件调用你的网络浏览器。`firefox grid-1.svg`，`google-chrome grid-1.svg`，或者任何你的浏览器的名字。如果你这样做，这两个网格应该是这样的。

[2.x.18]

左边那个，嗯，不是很刺激。右边的是&mdash；至少是&mdash；非传统的。这些图片对每个单元的 "细化水平 "进行了颜色编码。一个粗略的网格单元要被细分多少次才能得到给定的单元。在左图中，这是无聊的，因为网格被全局细化了若干次，也就是说，[1.x.22]单元被细化的次数相同。

(虽然第二个网状结构完全是人为捏造的，当然在应用中也不太实用，但令大家惊讶的是，它已经进入了文献：见 [2.x.19] 。显然，它至少对某些事情是有好处的）。)




[1.x.23]

[1.x.24]

这个程序显然没有太多的功能，但特别是[2.x.20]函数有一堆你可以玩弄它的地方。例如，你可以修改我们决定细化哪些单元格的标准。一个例子是把条件改成这样。

[1.x.25]

这将细化所有单元中心的[2.x.21]坐标大于零的单元（我们通过解除引用[2.x.23]迭代器调用的[2.x.22]函数返回一个Point<2>对象；下标[2.x.24]将得到[2.x.25]坐标，下标[2.x.26]得到[2.x.27] 坐标）。通过查看TriaAccessor提供的函数，你也可以使用更复杂的标准进行细化。

一般来说，你能用`cell->something()`形式的操作做什么，在文档中有点困难，因为`cell`不是一个指针，而是一个迭代器。你可以在单元格上调用的函数可以在`TriaAccessor'类的文档中找到（它的函数也可以在单元格的面或更普遍的、出现在三角形中的各种几何对象上调用），以及`CellAccessor'（它增加了一些专门针对*单元格的函数）。

对整个迭代器概念的更彻底的描述可以在[2.x.28]文档模块中找到。




[1.x.26]

另一种可能性是生成完全不同几何形状的网格。虽然对于复杂的几何体来说，使用网格生成器获得的网格是没有办法的，但是有大量的几何体，deal.II可以使用GridGenerator命名空间的函数来创建网格。许多这样的几何体（如本例程序中使用的几何体）包含有弯曲面的单元：换句话说，我们希望放置在边界上的新顶点位于一个圆上。deal.II通过Manifold类（以及从它继承的类）处理复杂的几何体；尤其是GridGenerator中对应于非笛卡尔网格的函数（如[2.x.29]或[2.x.30]将一个Manifold对象附加到三角网格中应该是曲线的部分（分别为SphericalManifold和CylindricalManifold），并在应该是平面的部分使用另一个Manifold（FlatManifold）。关于这些类的设计理念和接口的描述，请参见Manifold的文档或[2.x.31]"manifold模块"。看看它们提供了什么，看看如何在这样的程序中使用它们。

我们还在第49步中讨论了其他各种创建和操作网格的方法（并描述了附加Manifolds的过程）。




[1.x.27]

最后，我们对用deal.II修改或编写程序做一个总体的评论。当你开始使用教程程序或你自己的应用程序时，你会发现错误会发生：你的程序会包含一些代码，这些代码要么是立即中止程序，要么是一些简单地导致错误结果的bug。无论哪种情况，你都会发现知道如何使用调试器是非常有帮助的：你可能会通过把调试输出放到你的程序中，编译它，然后运行它来应付一段时间，但最终用调试器寻找错误会更快，更方便，更可靠，因为你不必总是重新编译程序，而且你可以检查变量的值和它们的变化。

与其推迟学习如何使用调试器，直到你真的看不到任何其他方法来发现一个错误，这里是我们将在这个项目中提供的一个建议：尽快学习如何使用调试器。这将是很好的时间投资。( 从顶层的[1.x.28]链接到的[2.x.32]问题（FAQ）页面也提供了大量关于调试deal.II程序的提示。




[1.x.29]

在你的论文或出版物中包含网格往往是有用的。为此，按细化级别对单元格进行颜色编码，并在每个单元格上打印单元格号，可能不是很有用。但这并不意味着一定要这样做 -- GridOut类允许为每种可能的输出格式设置标志（参见GridOutFlags命名空间中的类），以控制网格的具体绘制方式。当然，你也可以选择其他的输出文件格式，如VTK或VTU；这对三维网格特别有用，因为二维格式如SVG并不特别有用，因为它固定了三维物体的特定视角。因此，你可能想探索GridOut类中的其他选项。


examples/step-10/doc/intro.dox

[1.x.30]

[1.x.31]


这是一个相当短的例子，只显示了使用高阶映射的一些方面。我们所说的[2.x.33]映射[2.x.34]是指单元格（即单位线、正方形或立方体）与现实空间中的单元格之间的转换。在前面所有的例子中，我们都隐含地使用了线性或d-线性映射；你根本不会注意到这一点，因为如果你不做任何特别的事情，这就是发生的情况。然而，如果你的域有弯曲的边界，在有些情况下，边界的片状线性逼近（即通过直线段）是不够的，你希望你的计算域也是一个使用弯曲边界的真实域的逼近。如果边界近似使用分片的二次抛物线来近似真实边界，那么我们说这是二次或[2.x.35]的近似。如果我们使用成片的立体多项式的图形，那么这是一个[2.x.36]的近似，以此类推。




对于某些微分方程，已知如果精确域的边界是弯曲的，那么边界的片状线性近似，即[2.x.37]映射，是不够的。例如，使用[2.x.38]元素的偏谐方程，或具有弯曲反射边界的域上的气体动力学的欧拉方程。在这些情况下，有必要使用高阶映射来计算积分。如果我们不使用这样的高阶映射，那么边界的逼近顺序将主导整个数值方案的收敛顺序，而不考虑域的内部离散化的收敛顺序。




我们没有用这些更复杂的例子来证明高阶映射的使用，而是只做了一个简单的计算：用两种不同的方法计算[2.x.39]的值。




第一种方法使用单位半径的圆的三角形近似，并在其上积分一个单位幅度的常数函数（[2.x.40]）。当然，如果领域是精确的单位圆，那么面积将是[2.x.41]，但由于我们只使用片状多项式段的近似，我们积分的面积值并不完全是[2.x.42] 。然而，众所周知，当我们细化三角形时，[2.x.43]映射以[2.x.44]的阶数逼近边界，其中[2.x.45]是网格大小。我们将检查圆的计算面积值，以及它们在不同映射的网格细化下向[2.x.46]收敛的情况。我们还将发现一种收敛行为，这种行为一开始是令人惊讶的，但有一个很好的解释。




第二种方法与此类似，但这次不使用三角形单位圆的面积，而是使用其周长。  [2.x.47]然后用周长的一半来近似，因为我们选择半径等于1。




[2.x.48] 本教程实质上展示了如何为积分选择一个特定的映射，方法是将一个特定的几何体附加到三角形上（例如在步骤1中已经完成），然后将一个映射参数传递给FEValues类，该类用于deal.II中的所有积分。我们选择的几何体是一个圆，deal.II已经有一个可以使用的类（SphericalManifold）。如果你想定义你自己的几何体，例如，因为它很复杂，不能用deal.II中已有的类来描述，你会想通过步骤53来阅读。


examples/step-10/doc/results.dox



[1.x.32]


该程序执行两个任务，第一个是生成映射域的可视化，第二个是通过所述的两种方法计算π。让我们先看一下生成的图形。它们是以Gnuplot格式生成的，可以用以下命令查看

[1.x.33]

或使用其他文件名之一。第二行确保生成的输出的长宽比实际上是1:1，也就是说，一个圆在你的屏幕上被画成一个圆，而不是一个椭圆。第三行关闭了图形中的键，因为那只会打印信息（文件名），而这些信息现在并不那么重要。同样地，第四行和第五行关闭了刻度线。然后生成具有特定线宽（"lw"，这里设置为4）和线型（"lt"，这里选择线应使用RGB颜色 "黑色"）的图。

下表显示了[2.x.49]、[2.x.50]和[2.x.51]映射的三角计算域，为原始粗网格（左）和一次均匀细化网格（右）。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_0_q1.svg" alt="磁盘的五单元离散化。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_1_q1.svg" alt="磁盘的20单元离散化（即。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_0_q2.svg" alt="五格离散化的圆盘，边缘为二次方。边界与实际的圆几乎没有区别。" width="400" height="400" > </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_1_q2.svg" alt="带有二次方边缘的20个单元离散化。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_0_q3.svg" alt="带有三次方边缘的圆的五单元离散化。边界与实际的圆几乎没有区别。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_1_q3.svg" alt="具有立方体边缘的20单元离散化。" width="400" height="400"> </div> </div>

这些图片显示了高阶映射的明显优势：它们在相当粗的网格上也能相当好地接近真实边界。为了进一步证明这一点，这里是使用[2.x.52]和[2.x.53]映射的粗网格的右上角四分之一圈的一部分，其中红色虚线标志着实际的圆。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_exact_vs_interpolate_q2.svg" alt="二次离散化的特写。二次插值和实际圆之间的距离很小。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_exact_vs_interpolate_q3.svg" alt="立方离散化的特写。立体插值和实际圆之间的距离非常小。" width="400" height="400"> </div> </div> </div>

很明显，二次映射很好地接近了边界，而对于三次映射来说，对于粗略的网格来说，近似域和真实域之间的差异已经很难看到了。你还可以看到，映射只在三角形的外部边界有一些变化。在内部，所有的线条仍然是由线性函数表示的，这就导致了只在边界的单元上进行额外的计算。因此，高阶映射通常不会比低阶映射明显地慢，因为额外的计算只在所有单元格的一个小子集上执行。




该程序的第二个目的是计算π的值，以达到良好的准确性。这是程序的这一部分的输出。

[1.x.34]






从输出的一个直接观察结果是，在所有情况下，数值都迅速收敛到[2.x.54]的真实值。请注意，对于[2.x.55]的映射，我们已经进入了四舍五入误差的制度，收敛率趋于平缓，这已经是相当多的了。然而，也请注意，对于[2.x.56]映射，即使在最细的网格上，精度也明显比[2.x.57]映射的粗网格上要差得多!




输出的最后一列显示了收敛顺序，以网格宽度的幂为单位 [2.x.58] 。在介绍中，我们曾说过 [2.x.59] 映射的收敛顺序应该是 [2.x.60] 。然而，在所示的例子中，顺序是[2.x.61] !这个起初令人惊讶的事实可以用[2.x.62]映射的特性来解释。在[1.x.35]阶时，它使用的支持点是基于[1.x.36]+1点的Gauss-Lobatto正交规则，以这样的方式选择支持点，使正交规则在2[1.x.37]阶时收敛。尽管这些点在这里只用于插值[1.x.38]阶多项式，但我们在数值评估积分时得到了超收敛效应，导致观察到的高阶收敛。这种效应在下面的出版物中也有详细讨论。A. Bonito, A. Demlow, and J. Owen:"拉普拉斯-贝特拉米算子的特征值和特征函数的有限元近似的先验误差估计"，提交，2018年）。)


examples/step-11/doc/intro.dox

[1.x.39]

[1.x.40]

我们要考虑的问题是只带诺伊曼边界条件的拉普拉斯问题的解决方案。

[1.x.41]

众所周知，如果这个问题要有一个解决方案，那么力需要满足兼容性条件

[1.x.42]

我们将考虑这样的特殊情况：[2.x.63]是围绕原点的半径为1的圆，而[2.x.64] ，[2.x.65] 。这种选择满足了兼容性条件。

兼容性条件允许上述方程的解，但它仍然保留了一个模糊性：因为只有解的导数出现在方程中，解只确定到一个常数。出于这个原因，我们必须为数字解提出另一个条件，以固定这个常数。

对于这一点，有多种可能性。<ol> [2.x.66] 将离散化的一个节点固定为零或任何其他固定值。   这相当于一个附加条件 [2.x.67] 。虽然这是常见的做法，但不一定是个好主意，因为我们知道拉普拉斯方程的解只在 [2.x.68] 中，这不允许定义点值，因为它不是连续函数的子集。因此，即使固定一个节点对离散函数来说是允许的，但对连续函数来说是不允许的，在数值解的这一点上，人们常常可以看到由此产生的错误尖峰。

[2.x.69] 将域上的均值固定为零或任何其他值。这在连续水平上是允许的，因为[2.x.70]由Sobolev不等式决定，因此在离散水平上也是允许的，因为我们那里只考虑[2.x.71]的子集。

[2.x.72] 将域的边界上的均值固定为零或任何其他值。这在连续水平上也是允许的，因为[2.x.73] ，同样由Sobolev的不等式。  [2.x.74] 我们将选择最后一种可能性，因为我们想用它来演示另一种技术。

虽然这描述了要解决的问题，但我们仍然要弄清楚如何实现它。基本上，除了额外的均值约束，我们已经多次解决了这个问题，使用的是迪里希特边界值，我们只需要放弃对迪里希特边界节点的处理。高阶映射的使用也是相当琐碎的，我们会在使用它的各个地方进行解释；在几乎所有可以想象的情况下，你只会把描述映射的对象视为一个黑盒子，你不需要担心，因为它们的唯一用途似乎是被传递到库的深处，在那里函数知道如何处理它们（即在[2.x.75]类及其后代）。

这个程序中的棘手之处在于对均值约束的使用。幸运的是，库中有一个知道如何处理这种约束的类，我们已经经常使用它了，没有提到它的通用性。请注意，如果我们假设边界节点沿边界的间隔是相等的，那么均值约束

[1.x.43]

可写为

[1.x.44]

其中总和应贯穿位于计算域边界上的所有自由度指数。让我们用[2.x.76]表示边界上数字最小的指数（或任何其他方便选择的指数），那么这个约束也可以用以下方式表示

[1.x.45]

幸运的是，这正是AffineConstraints类所设计的约束形式。请注意，我们在之前的几个例子中使用了这个类来表示悬空节点的约束，它也有这种形式：在这里，中间的顶点应具有相邻顶点的平均值。一般来说，AffineConstraints类被设计用来处理以下形式的仿生约束

[1.x.46]

其中[2.x.77]表示一个矩阵，[2.x.78]表示一个向量，[2.x.79]是节点值的向量。在这种情况下，由于[2.x.80]代表一个同质约束，[2.x.81]是零向量。

在这个例子中，沿边界的平均值允许这样的表示，[2.x.82]是一个只有一行的矩阵（即只有一个约束条件）。在实现中，我们将创建一个AffineConstraints对象，添加一个参考第一个边界节点[2.x.83]的约束（即给矩阵添加另一行），并插入所有其他节点贡献的权重，在这个例子中刚好是[2.x.84] 。

稍后，我们将使用这个对象来消除线性方程组中的第一个边界节点，将其还原为一个没有常数偏移值的解。实施过程中的一个问题是，这个节点的明确消除会导致矩阵中出现一些额外的元素，我们事先不知道这些元素的位置，也不知道矩阵的每一行中会有多少额外的条目。我们将展示我们如何使用一个中间对象来解决这个问题。

但现在开始实施解决这个问题的方案......


examples/step-11/doc/results.dox



[1.x.47]

这是该程序的输出结果。

[1.x.48]

正如我们所期望的，每个不同的映射的收敛顺序显然是与网格大小成二次方的。不过[2.x.85]有趣的是，双线性映射（即1度）的误差比高阶映射的误差大三倍以上；因此在这种情况下，使用高阶映射显然是有利的，不是因为它提高了收敛顺序，而只是为了减少收敛顺序前的常数。另一方面，除了在非常粗的网格上，使用立方体映射只能进一步改善结果，幅度微乎其微。

我们还可以通过使用例如ParaView来可视化底层网格。下面的图片显示了不同映射度的初始网格。

[2.x.87]

显然，当我们从线性映射到二次映射时，这种影响是最明显的。这也反映在上表中给出的误差值中。从二次方到三次方的效果没有那么明显，但由于对圆形边界的描述更加准确，所以还是很明显的。

接下来，让我们看看三次全局细化后的网格

[2.x.88]

在这里，差异就不那么明显了，特别是对于高阶映射。事实上，在这个细化水平上，表格中报告的误差值在二度和三度的映射之间基本上是相同的。


examples/step-12/doc/intro.dox

[2.x.89]

[1.x.49]

[1.x.50]

[1.x.51]

[1.x.52]

本例专门介绍了[2.x.90]非连续Galerkin方法[2.x.91]，简称为DG方法。它包括以下内容。<ol> [2.x.92] 用DG方法对线性平流方程进行离散化。    [2.x.93] 使用FEInterfaceValues组装跳跃项和单元间界面上的其他表达式。    [2.x.94] 使用[2.x.95] [2.x.96] 组合系统矩阵。

这个项目特别关注的是DG方法的循环。这些被证明是特别复杂的，主要是因为对于面的条件，我们必须分别区分边界、规则的内部面和有悬挂节点的内部面的情况。[2.x.97]处理了单元和面迭代的复杂性，并允许为不同的单元和面项指定 "工作者"。面条款本身的整合，包括对自适应细化面的整合，是通过FEInterfaceValues类完成的。

[1.x.53]

本例中解决的模型问题是线性平流方程

[1.x.54]

受制于边界条件

[1.x.55]

在域的边界[2.x.99]的流入部分[2.x.98]。  这里，[2.x.100]表示一个矢量场，[2.x.101]是（标量）解函数，[2.x.102]是边界值函数。

[1.x.56]

表示域边界的流入部分，[2.x.103]表示边界的单位外向法线[2.x.104] 。这个方程是本教程第9步中已经考虑过的平流方程的保守版本。


在每个单元格[2.x.105]上，我们从左边乘以一个测试函数[2.x.106]，并通过部分整合得到。

[1.x.57]

当对所有单元[2.x.107]求和时，边界积分是在所有内部和外部面进行的，因此，有三种情况。<ol> [2.x.108] 流入的外部边界（我们用给定的[2.x.110]代替[2.x.109]）。    [2.x.111] [2.x.112] 流出的外部边界。    [2.x.113] [2.x.114]内面（两边的积分变成了跳跃，我们使用上风速度）。    [2.x.115] [2.x.116]。

这里，跳跃被定义为[2.x.117]，其中上标指的是面的左（'+'）和右（'-'）值。如果[2.x.120]，上风值[2.x.118]被定义为[2.x.119]，否则为[2.x.121]。

因此，依赖网格的弱形式为：。

[1.x.58]

这里，[2.x.122]是三角形的所有活动单元的集合，[2.x.123]是所有活动内部面的集合。这种公式被称为上风非连续Galerkin方法。

为了实现这种双线性形式，我们需要用通常的方法计算单元项（第一个和）来实现单元上的积分，用FEInterfaceValues计算界面项（第二个和），以及边界项（另外两个项）。所有这些的求和是通过[2.x.124]完成的。




[1.x.59]

我们在[2.x.125]上求解平流方程，[2.x.126]代表一个圆形的逆时针流场，[2.x.127]代表[2.x.128]，[2.x.129]代表[2.x.130] 。

我们通过估计每个单元的梯度规范，自适应地细化网格，在一连串的网格上求解。在每个网格上求解后，我们以vtk格式输出解决方案，并计算解决方案的[2.x.131]准则。由于精确解是0或1，我们可以用它来衡量数值解的过冲程度。


examples/step-12/doc/results.dox



[1.x.60]


这个程序的输出包括控制台输出和vtk格式的解决方案。

[1.x.61]



我们展示了初始网格的解决方案，以及经过两个和五个自适应细化步骤后的网格。

[2.x.132] [2.x.133] [2.x.134]。

最后我们展示一个3D计算的图。

[2.x.135]


[1.x.62]

[1.x.63]

在这个程序中，我们使用了不连续的元素。这是一个合理的问题，为什么不简单地使用正常的、连续的元素呢？当然，对于每个有数值方法背景的人来说，答案是显而易见的：连续Galerkin（cG）方法对于输运方程是不稳定的，除非特别添加稳定项。然而，DG方法[1.x.64]则是稳定的。用目前的程序来说明这一点并不十分困难；事实上，只需要做以下的小修改就可以了。

- 将该元素改为FE_Q，而不是FE_DGQ。

- 以与步骤6完全相同的方式增加对悬挂节点约束的处理。

- 我们需要一个不同的求解器；步骤29中的直接求解器是一个方便的选择。一个有经验的deal.II用户将能够在10分钟内完成这一工作。

虽然上面显示了二维解决方案，在界面上含有一些小的尖峰，但是在网格细化的情况下，这些尖峰的高度是稳定的，当使用连续元素时，结果看起来有很大不同。

[2.x.136]

在细化迭代5中，图像不能再以合理的方式绘制成三维图。因此我们展示了一个范围为[2.x.137]的彩色图（当然，精确解的解值位于[2.x.138]）。在任何情况下，很明显，连续Galerkin解表现出振荡行为，随着网格的细化越来越差。

如果出于某种原因想使用连续元素，有很多策略可以稳定cG方法。讨论这些方法超出了本教程程序的范围；例如，感兴趣的读者可以看看步骤31。




[1.x.65]

[1.x.66]

鉴于在这种情况下确切的解是已知的，进一步扩展的一个有趣的途径是确认这个程序的收敛顺序。在目前的情况下，解是非光滑的，因此我们不能期望得到特别高的收敛阶，即使我们使用高阶元素。但是，即使解[1.x.67]光滑，方程也不是椭圆的，因此，我们应该得到等于最优插值估计的收敛阶，这一点并不明显（例如，我们通过使用二次元会得到[2.x.139]在[2.x.140]准则下的收敛）。

事实上，对于双曲方程来说，理论预测常常表明，我们所能希望的最好结果是比插值估计值低二分之一的阶。例如，对于流线扩散法（此处用于稳定传输方程解的DG法的替代方法），可以证明对于度数为[2.x.141]的元素，在任意网格上的收敛阶为[2.x.142]。虽然在均匀细化的网格上观察到的顺序经常是[2.x.143]，但人们可以构建所谓的彼得森网格，在这些网格上实际上达到了更差的理论约束。这应该是比较容易验证的，例如使用[2.x.144]函数。

一个不同的方向是观察运输问题的解决经常有不连续性，因此，我们[1.x.68]在每个坐标方向上的每个单元的网格可能不是最佳的。相反，一个更好的策略是只在平行于不连续的方向上切割单元。这被称为[1.x.69]，是步骤30的主题。


examples/step-12b/doc/intro.dox

[1.x.70]

[1.x.71]

这是第16步的一个变体，唯一的变化是我们使用MeshWorker框架和预制的LocalIntegrator辅助类，而不是使用FEInterfaceValues来组装面的术语。

关于这个框架在实践中如何使用的细节，将作为本教程计划的一部分加以解释。

[1.x.72]

我们在这里解决的问题与步骤12中的问题相同。


examples/step-12b/doc/results.dox



[1.x.73]


这个程序的输出与步骤16非常相似，我们在此不重复输出。

我们展示了初始网格的解决方案，以及经过两个和五个自适应细化步骤后的网格。

[2.x.145] [2.x.146] [2.x.147]。


然后，我们再次展示了最终的网格（经过5个细化步骤）和解决方案，这一次，我们使用了更漂亮的3D渲染（使用[2.x.148]函数和基于VTK的VisIt可视化程序获得），更好地显示了细化网格上跳跃的尖锐性以及解决方案沿界面的过度和不足。

[2.x.149] [2.x.150]。


最后我们展示一个3D计算的图。

[2.x.151]


[1.x.74]

[1.x.75]

关于进一步扩展的想法，请参见步骤12。


examples/step-13/doc/intro.dox

[1.x.76]

[1.x.77]

[1.x.78]


在这个例子程序中，我们将不太关注描述如何使用deal.II及其设施的新方法，而是介绍编写模块化和可扩展有限元程序的方法。其主要原因是现代研究软件的规模和复杂性：实现现代误差估计概念和自适应求解方法的应用程序往往变得相当大。例如，当这个程序是在2002年写的时候，deal.II的主要作者的三个最大的应用程序，在写这个例子程序的时候。<ol> [2.x.152] 一个用非连续加尔金有限元法求解守恒双曲方程的程序。33,775行代码； [2.x.153] 一个参数估计程序。28,980行代码； [2.x.154] 一个波浪方程求解器：21,020行代码。  [2.x.155]

这个库本身--不包括示例程序和测试套件--在2002年春天有略多于15万行的代码。当然，现在已经大了好几倍了）。)这些应用程序的规模是一个人，甚至是一个有经验的程序员，所能处理的边缘。




上面的数字相当清楚地说明了一件事：没有被分解成较小的、大部分独立的片段的单体程序是没有办法生存的，因为即使是作者也会很快失去对程序不同部分之间各种依赖关系的概述。只有数据封装，例如使用面向对象的编程方法，以及通过定义小而固定的接口来实现模块化，才能帮助构建数据流和相互依赖。如果一个以上的人在开发一个程序，这也是一个绝对的先决条件，因为否则的话，混乱会很快出现，因为如果一个开发人员需要知道另一个人是否改变了不同模块的内部结构，如果它们没有被干净地分开的话。




在前面的例子中，你已经看到了库本身是如何被分成几个复合体的，每个复合体都建立在底层复合体之上，但相对独立于其他复合体。<ol> [2.x.156] 三角形类复合物，以及相关的迭代器类；[2.x.157] 有限元类；[2.x.158] DoFHandler类复合物，以及相关的迭代器，建立在三角形和有限元类之上；[2.x.159] 实现单元和实数单元间映射的类；[2.x.160] FEValues类复合物，建立在有限元和映射之上。  [2.x.161] 除了这些，还有大量的小类，当然还有以下的 "工具 "模块。<ol> [2.x.162] 以各种图形格式输出； [2.x.163] 线性代数类。  [2.x.164] 这些复数也可以在deal.II手册网站的首页上以流程图的形式找到。




这个程序的目标是给出一个例子，说明一个相对简单的有限元程序的结构，使我们最终得到一组尽可能相互独立的模块。这使得我们可以在一端改变程序，而不必担心另一端的程序会被破坏，只要我们不触及两端交流的接口。当然，C++中的接口是抽象基类的声明。




在这里，我们将（再次）实现一个拉普拉斯求解器，尽管与之前的例子程序相比有一些不同。<ol> [2.x.165] 实现数值求解方程过程的类不再负责驱动 "求解-估计误差-再求解 "的过程，而是将其委托给外部函数。这首先允许在更大的范围内将其作为一个构件，在这里拉普拉斯方程的解可能只是其中的一部分（例如，在非线性问题中，拉普拉斯方程可能要在每个非线性步骤中解决）。它还允许围绕该类建立一个框架，允许使用其他方程的求解器（但具有相同的外部接口），以备对不同类型的偏微分方程评估一些技术。  [2.x.166] 它将评估计算出的解的过程分割成一组单独的类。原因是，人们通常对偏微分方程的解本身不感兴趣，而是对它的某些方面感兴趣。例如，人们可能希望在弹性计算中计算某一边界的牵引力，或者在某一位置的接收器上计算地震波的信号。有时，人们可能对这些方面中的几个方面感兴趣。由于解的评估是通常不影响解的过程，我们把它拆成一个单独的模块，以便独立于解算器类的开发来开发这种评估过滤器。  [2.x.167] 将实现网格细化的类与计算解的类分开。  [2.x.168] 将我们要介绍的测试案例的描述与程序的其他部分分开。  [2.x.169] 使用WorkStream设施对线性系统的装配进行并行化。这是在[2.x.170]"多处理器访问共享内存的并行计算 "文档模块中可以找到的广泛描述。该实现基本上遵循步骤9中已经描述过的内容。  [2.x.171]




该程序所做的事情并不新鲜。事实上，这更像是以前程序的混合体，从以前的例子中拆解了各种部分和功能。读者应该关注的是它们在这个程序中的安排方式，即程序中使用的软件设计技术，以达到实现所需数学方法的目的。然而，我们必须强调，软件设计在某种程度上也是一个主观的问题：不同的人有不同的编程背景，对编程的 "正确 "风格有不同的看法；因此，这个程序只表达了作者认为有用的做法，如果你对所选择的方式感到不舒服，不一定要采用这种风格来编写成功的数值软件。不过，它应该作为一个案例研究，用启发读者的想法来达到理想的目的。




一旦你完成了这个程序，你会注意到它的结构已经有些复杂了。然而，它只有大约850行代码，没有注释。在真正的应用程序中，当然会有注释和类文件，这将使其达到1200行。然而，与上面列出的应用程序相比，这仍然是很小的，因为它们的规模是它们的20到25倍。对于这么大的程序，从一开始就进行适当的设计是不可缺少的。否则，一旦它变得过于庞大而无法管理，就必须在其生命中的某一时刻重新设计它。




尽管如此，上面列出的三个程序都经历了重大的修改，甚至是重写。例如，波浪程序，在它还明显较小的时候，曾经被完全撕成了碎片，只是为了以更模块化的形式再次组装。那时，已经不可能在不影响代码的旧部分的情况下增加功能了（代码的主要问题是数据流：在时间依赖的应用中，主要的问题是什么时候把数据存储到磁盘，什么时候再重新加载；如果这不是以一种有组织的方式进行的，那么你最终会发现数据释放得太早，加载得太晚，或者根本没有释放）。尽管本例程序因此吸取了几年的经验，但它的设计肯定不是没有缺陷的，特别是可能不适合目标不同的应用。它应该作为一个灵感，让你以模块化的方式编写自己的应用程序，以避免过于紧密耦合的代码的陷阱。




[1.x.79]


程序实际做什么甚至不是这个程序的重点，程序的结构更重要。然而，用几句话来描述就是：求解给定右手边的拉普拉斯方程，使其解为函数 [2.x.172] 。计算的目标是得到解在点[2.x.173]处的值，并比较我们在两种细化标准下解决这个值的准确性，即全局细化和通过Kelly等人的误差指标细化，我们已经在以前的例子中使用过。




像往常一样，这些结果将在本文件的相应部分进行讨论。在这样做的过程中，我们将发现一个关于两个细化标准的相对性能的略微令人恼火的观察。在以后的例子程序中，在这个程序的基础上，我们将设计一个不同的方法，希望它能比这里讨论的技术表现更好。




现在，所有的理论和传闻背景都说了这么多。了解一个项目的最好方法是看它，所以它就在这里。


examples/step-13/doc/results.dox



[1.x.80]




这个程序的结果并不那么有趣--毕竟它的目的不是为了演示一些新的数学思想，也不是为了演示如何用deal.II编程，而是为了利用我们在前面的例子中所开发的材料，形成一些演示以模块化和可扩展的方式建立现代有限元软件的方法。




尽管如此，我们当然会展示程序的结果。最感兴趣的是点值计算，为此我们实现了相应的评估类。该程序的结果（即输出）看起来如下。

[1.x.81]




这里令人惊讶的是，精确的数值是1.59491554...，而且计算该解显然出奇的复杂，甚至只达到百分之一的精度，尽管该解是平滑的（事实上是无限常可微）。这种平滑性显示在程序生成的图形输出中，这里是粗网格和凯利细化指标的前9个细化步骤。


[2.x.174]


当我们已经在观看图片时，这是第八个网格，从顶部看。


[2.x.175]


然而，我们还没有完成对点值计算的评估。事实上，将两个细化标准的误差[2.x.176]绘制成图，可以得到下面的图片。


[2.x.177]





这幅图[2.x.178]令人不安的是，自适应网格细化不仅没有像人们通常期望的那样比全局细化好，甚至明显更差，因为它的收敛是不规则的，在使用后续网格的值时，阻止了所有的外推技术!另一方面，全局细化提供了一个完美的[2.x.180]或[2.x.181]收敛历史，并提供了各种机会，甚至可以通过外推法来改善点值。因此，在这个例子中，全局网格细化必须被认为是优越的!这更令人惊讶，因为评估点不是在左边的某个地方，那里的网格是粗糙的，而是在右边，自适应细化也应该细化评估点周围的网格。




因此，我们以一个问题来结束对这个例子程序的讨论。

<p align="center"> <strong> [2.x.182] 如果适应性不比全局细化好，那么它有什么问题？[2.x.183] </strong>





[2.x.184] 在这个例子的结尾处进行练习。[2.x.185] 有一个简单的原因导致适应性网格解决方案的不良和不规则行为。通过观察每个步骤中评估点周围的网格，可以很简单地找到这个原因--这个数据在程序的输出文件中。因此，一个练习是修改网格细化程序，使问题（一旦你注意到它）得以避免。第二个练习是检查结果是否比全局细化要好，如果是的话，是否能达到更好的收敛顺序（就自由度数而言），或者只达到一个更好的常数。




( [2.x.186] 对于没有耐心的人来说，非常简短的回答。[2.x.187]在误差较大的步骤中，网格在评估点上是不规则的，即一些相邻的单元有悬空的节点；这破坏了一些超级近似的效果，而全局细化的网格可以从中受益。答案2：这个快速黑客

[1.x.82]

在执行细化之前，在Kelly细化类的细化函数中，将改善结果（练习：代码是怎么做的？不过，行为仍然是不规则的，所以不可能有关于收敛顺序的结果）。)


examples/step-14/doc/intro.dox

[1.x.83]

[1.x.84]

[1.x.85]

Rolf Rannacher教授的海德堡小组，deal.II库的三位最初的作者在他们的博士期间和部分之后都属于该小组，自90年代中期以来一直从事有限元离散的适应性和误差估计的研究。其主要成就是开发了任意函数的误差估计，以及用于计算的最佳网格细化。

我们不会太详细地讨论这些概念的推导，但会在本例程序中实现主要思想。对于一般概念的彻底介绍，我们参考Becker和Rannacher的开创性工作[2.x.188]，[2.x.189]，以及同一作者在Acta Numerica[2.x.190]上的概述文章；前者介绍了拉普拉斯方程的误差估计和一般函数输出的适应性概念，而后者给出了这些概念在大量其他更复杂方程中的应用例子。关于个别类型方程的应用，也可参见Becker [2.x.191] , [2.x.192] , Kanschat [2.x.193] , [2.x.194] , Suttmeier [2.x.195] 的出版物。] , [2.x.196] , [2.x.197] , [2.x.198] , 班格特 [2.x.199] , [2.x.200] , [2.x.201] , [2.x.202] , 和哈特曼 [2.x.203] , [2.x.204] , [2.x.205] 。所有这些工作，从Becker和Rannacher的原始介绍到对特定方程的个别贡献，后来都被Bangerth和Rannacher总结成一本书，涵盖所有这些主题，见 [2.x.206] 。


其基本思想如下：在应用中，人们通常对解本身不感兴趣，而是对它的某些方面感兴趣。例如，在流动问题的模拟中，人们可能想知道浸在流体中的物体的升力或阻力；我们想知道的是这个量的最佳精度，而描述方程的其余解是否得到很好的解决并不是主要兴趣。同样，在弹性方面，人们可能想知道某些点的应力值，以猜测关节的最大负荷值是否安全，例如。或者，在辐射传输问题中，平均通量强度是有意义的。

在刚才列举的所有情况中，我们感兴趣的是解的函数[2.x.207]的评估，而不是各地的[2.x.208]的值。由于精确的解决方案[2.x.209]是不可用的，只有它的数字近似值[2.x.210]，所以询问计算值[2.x.211]是否在精确值[2.x.212]的一定范围内是明智的，也就是说，我们要约束与这个函数有关的误差，[2.x.213]。

为了简化论述，我们假设感兴趣的量[2.x.214]以及方程都是线性的，我们将特别展示具有同质Dirichlet边界条件的拉普拉斯方程的推导，尽管这一概念更为普遍。对于这种一般情况，我们参考上面列出的参考文献。  我们的目标是获得误差的界限， [2.x.215] 。为此，让我们用[2.x.216]表示对偶问题的解，定义如下。

[1.x.86]

其中[2.x.217]是与微分方程相关的双线性形式，测试函数从相应的解空间中选择。然后，以特殊的检验函数[2.x.218]作为误差，我们有

[1.x.87]

根据加尔金正交性，我们可以将其改写为

[1.x.88]

其中[2.x.219]可以用我们认为方便的任何方式从离散测试空间中选择。

具体来说，对于拉普拉斯方程来说，其误差特性为

[1.x.89]

因为我们不仅要用这个公式来计算误差，而且还要细化网格，所以我们需要将上面的表达式改写为单元格之和，每个单元格的贡献可以作为这个单元格的误差指标。因此，我们将标量产品分成每个单元的条款，并对每个单元进行分项积分。

[1.x.90]

接下来我们使用[2.x.220]，对于拉普拉斯方程的解来说，该解足够平滑，[2.x.221]几乎在任何地方都是连续的--因此在一个单元上涉及[2.x.222]的项与它的邻居上的项相抵消，其中法向量的符号相反。(不过[2.x.223]的情况并非如此。)在域的边界，没有可以抵消这个项的邻接单元，权重[2.x.224]可以选择为零，而整个项就消失了。

因此，我们有

[1.x.91]

在最后一步，注意当取[2.x.225]的法向导数时，我们指的是从单元格的这一边取的这个量的值（对于通常的拉格朗日元素，导数不是跨边连续的）。然后我们重写上述公式，将单元格[2.x.226]的一半边缘积分与相邻单元格[2.x.227]交换，得到

[1.x.92]

利用对于相邻单元格上的法向量，我们有[2.x.228]，我们定义法向导数的跳跃为

[1.x.93]

并在将离散函数[2.x.229]设置为对偶解的点插值后得到最终形式，[2.x.230]，现在它仍然是任意的。

[1.x.94]



借此，我们得到了关于任意（线性）函数的有限元离散化误差的精确表示 [2.x.231] 。其结构是残差估计的加权形式，因为[2.x.232]和[2.x.233]都是在精确解上消失的单元和边缘残差，而[2.x.234]是表示某个单元上的残差对于给定函数的评估有多重要的权重。此外，它是一个面向单元的量，所以我们可以把它作为一个网格细化的标准。问题是：如何评估它？毕竟，评估需要了解对偶解[2.x.235]，它带有我们想要知道的最准确的数量的信息。

在一些非常特殊的情况下，这个对偶解是已知的。例如，如果函数[2.x.236]是点评估，[2.x.237]，那么对偶解必须满足

[1.x.95]

右手边是狄拉克三角函数，对偶解是关于点[2.x.238]的格林函数。对于简单的几何形状，这个函数是分析上已知的，我们可以把它插入误差表示公式中。

然而，我们不想把自己限制在这种特殊情况下。相反，我们将以数值方式计算对偶解，并通过一些数值获得的[2.x.240]来近似[2.x.239]。我们注意到，使用与原始解[2.x.242]相同的方法来计算这个近似值[2.x.241]是不够的，因为这样[2.x.243]和整体误差估计值将为零。相反，近似值[2.x.244]必须来自一个比原始有限元空间更大的空间。有多种方法可以获得这样的近似值（见所引用的文献），我们将选择用高阶有限元空间来计算它。虽然这肯定不是最有效的方法，但它很简单，因为我们已经有了所有需要做的事情，而且还可以进行简单的实验。对于更有效的方法，再次参考给定的文献，特别是 [2.x.245] , [2.x.246] 。

至此，我们结束了对这个程序的数学方面的讨论，转而讨论实际的实施。




[2.x.247]如果你只关心计算误差的话，上面有两个步骤似乎没有必要：即(i)从[2.x.249]中减去[2.x.248]，以及(ii)将积分拆成单元格之和，并对每个单元格进行积分。事实上，这两个步骤根本没有改变[2.x.250]，因为在用[2.x.252]替换[2.x.251]之前，我们只考虑上面的相同点。换句话说，如果你只关心[1.x.96][2.x.253]，那么这些步骤就没有必要。另一方面，如果你想把误差估计值也作为网格中每个单元的细化标准，那么就有必要(i)把估计值分解成单元的总和，(ii)以这样的方式按摩公式，使每个单元的贡献都与局部误差有关。(虽然上面的扭曲没有改变[1.x.97][2.x.254]的值，但它们改变了我们为每个单元[2.x.255]计算的值) 。为此，我们想把一切都写成 "残差乘以双重权重 "的形式，其中 "残差 "是随着近似度变得[2.x.256]越来越好而归于零的东西。例如，[2.x.257]这个量不是残差，因为它只是收敛到精确解的梯度的（法线分量）。另一方面，[2.x.258]是一个残差，因为它收敛于[2.x.259] 。我们在制定[2.x.260]的最终形式时采取的所有步骤，实际上都是为了使最终公式变成一种形式，即当离散解[2.x.261]收敛到[2.x.262]时，每个项都收敛为零。这样就可以把每个单元的贡献看作是一个 "误差指标"，也会收敛为零--因为它应该随着网格的细化而收敛。




[1.x.98]

第14步的例子程序在很大程度上建立在第13步程序中已经使用的技术上。它对上面解释的双重加权残差估计器的实现是通过派生出第二个类，正确地称为[2.x.263]基类，并有一个类( [2.x.264])将两者再次连接起来，控制原始和双重问题的解决，然后用两者来计算网格细化的误差指标。

这个程序延续了上一个例子的模块化概念，通过一个抽象的基类来实现双重功能，描述感兴趣的数量，并提供两个不同的功能来实现这个接口。因此，增加一个不同的兴趣量是很简单的。

其中一个更根本的区别是对数据的处理。一个常见的情况是，你开发了一个解决某个方程的程序，并用不同的右手边、不同的域、不同的系数和边界值等来测试它。通常情况下，这些都必须匹配，这样才能知道确切的解决方案，或者它们的组合根本就有意义。

我们将演示如何以一种简单而又非常灵活的方式实现这一目标。我们将把属于某个设置的所有东西放到一个类中，并围绕它提供一个小的C++砂浆，这样整个设置（域、系数、右手边等）就可以通过只改变[2.x.265]中的某个[2.x.266]地方来交换。

再进一步，我们还将所有描述程序如何工作的其他参数集中在一个地方，如有限元的顺序、最大自由度数、对计算出的解应执行的评估对象等等。这使得程序的配置更加简单，我们将在后面的程序中展示如何使用一个库类来处理通过读取输入文件来设置这些参数。总的来说，我们的目的是要减少程序中想要改变某些参数时可能需要查找的地方，因为在实践中发现，随着程序的发展，人们会忘记它们的位置。此外，把所有描述程序在某次运行中的选项放到一个文件中（可以和结果一起存储），比在程序中的某个地方设置各种标志更有助于结果的可重复性，因为在下次改变这个地方后，它们的准确值就会被遗忘。

不幸的是，这个程序已经变得相当长了。虽然这无疑降低了它作为一个示例程序的作用，但我们认为它是一个很好的起点，可以为其他类型的问题开发一个程序，涉及不同于这里处理的拉普拉斯方程的方程。此外，它显示了我们可以向你展示的关于我们的后验误差估计方法的一切，它的结构应该使你能够简单地调整这个方法以适应其他问题、其他函数、其他几何形状、系数等等。

作者认为，就数学的复杂性和添加扩展的简单性而言，本程序是他在范例程序中的杰作。如果你使用这个程序作为你自己程序的基础，我们希望你能在出版物中说明这一事实以及示例程序的作者Wolfgang Bangerth的名字，因为你的程序有相当一部分是由示例程序组成的。


examples/step-14/doc/results.dox



[1.x.99]

[1.x.100]


这个程序提供了很多玩耍的可能性。因此，我们只能展示在这个程序的帮助下可以获得的所有可能结果的一小部分。然而，我们鼓励你通过改变主程序中的设置来尝试。在这里，我们先简单地让它运行，不做任何修改。

[1.x.101]




首先让我们看看这个程序实际计算的结果。在第七个网格上，原始和双重数值解看起来是这样的（使用的颜色方案旨在唤起科罗拉多州白雪皑皑的山峰，这个程序的原作者现在称之为家）。  [2.x.267]显然，左下角的区域对于右上角的点值评估是如此不重要，以至于网格在那里完全没有被细化，尽管解在该单元的内角有奇异点由于右手边和领域的对称性，解决方案实际上应该是在右上角的所有四个角落，但是涉及到对偶解决方案的网格细化标准选择了不同的细化方式--因为我们说过，我们真正关心的只是右上角某个地方的单一函数值。




下面是一些在细化周期0、2、4（顶行）和5、7、8（底行）中产生的网格。

[2.x.268]

请注意解决角部奇异点和解决评估点周围的奇异点之间的微妙相互作用。手工生成这样的网格是相当困难的，因为这将涉及到定量地判断四个角的奇异点应该被解决多少，并设置与评估点附近的权重。




程序会打印出这个数量的点值和估计的误差。通过推断，我们可以猜测出精确的数值接近0.0334473，正负0.0000001（注意，我们从只有22000个（原始）自由度中得到近6个有效数字。这个数字不能单独从函数值中得到，但我使用了误差估计器大部分是精确的假设，并将计算值加上估计误差进行外推，得到真实值的近似值。用更多自由度的计算表明，这个假设确实是有效的。




从计算结果中，我们可以生成两个图表：一个显示点值中误差[2.x.269]（将外推值视为正确）的收敛性，以及我们将计算值[2.x.270]和估计误差eta相加得到的值（如果误差估计器[2.x.271]是精确的，那么值[2.x.272]将等于精确的点值，并且这个量的误差将总是零；然而，由于误差估计器只是对真实误差的一个-好的-近似值，我们只能通过这个来减少误差的大小）。)在这张图中，我们还指出了复杂度[2.x.273]，以表明网格细化在这种情况下的作用是最佳的。第二张图比较了真实误差和估计误差，显示两者实际上是非常接近的，即使对于点值这样一个复杂的数量。


[2.x.274]




[1.x.102]


由于我们在使用由对偶加权误差估计器驱动的网格细化时接受了相当多的努力（用于解决对偶问题，以及评估误差表示），因此值得询问这种努力是否成功。为此，我们首先比较不同的网格细化标准所达到的误差水平。要产生这些数据，只需改变主程序中的网格细化准则变量的值。结果是这样的（对于Kelly指标中的权重，我们选择了[2.x.275]这个函数，其中[2.x.276]是到评估点的距离；可以证明，如果我们忽略边界的影响，这就是最佳权重）。

[2.x.277]




检查这些数字，我们看到对于全局细化，误差与[2.x.278]成正比，而对于双重估计器[2.x.279] 。一般来说，我们看到双重加权误差估计器比其他细化指标要好，至少在与那些具有类似规则行为的指标相比时是如此。凯利指标产生的误差较小，但在画面上的跳动相当不规则，误差有时也会改变符号。因此，它的行为不允许将结果推断到更大的N值。此外，如果我们相信双重加权误差估计器的误差估计值，可以通过将估计的误差加入到计算值中来改善结果。因此在可靠性方面，加权估计器比凯利指标更好，尽管后者有时会产生较小的误差。




[1.x.103]


除了评估某一点上的解的值，程序还提供了评估某一点上的X-导数的可能性，并且还可以为此定制网格细化的方法。要让程序计算这些量，只需将主函数中出现的两个[2.x.280]替换为[2.x.281]，然后让程序运行。

[1.x.104]






解决方案看起来与之前大致相同（准确的解决方案当然是[2.x.282]与[2.x.283]相同，只是网格发生了一点变化），但现在的对偶解决方案是不同的。评估点周围的特写显示了这一点。  [2.x.284]这次，细化周期0、5、6、7、8和9的网格是这样的。

[2.x.285]

请注意，与我们在点评估中获得的网格相比，这些网格是不对称的。这是由于域和原始解可能是围绕对角线对称的，但[2.x.286]-导数不是，后者进入了细化标准。




然后，有趣的是，将感兴趣的量的实际计算值（即在某一点的解决方案的X导数）与参考值-0.0528223...正负0.0000005进行比较。我们通过在更细的网格上计算得到这个参考值，经过一些更细的网格细化，大约有13万个单元。回顾一下，如果在最佳情况下，误差是[2.x.287]，那么采用多十倍的单元格的网格，我们的结果就会多出一个数字。




在下图的左边部分，你再次看到误差向这个外推值的收敛，而在右边你看到真实和估计误差的比较。

[2.x.288]

在初始阶段，真实的误差改变了它的符号，估计的误差又与它很好地匹配。还请注意，当使用估计误差来修正[2.x.289]的计算值时，误差有了极大的改善。




[1.x.105]


如果我们不选择[2.x.290]的数据集，而是在主函数中选择[2.x.291]，并选择[2.x.292]作为评价点，那么我们就可以重新进行前面的例子程序的计算，以比较在双重加权误差估计器帮助下得到的结果是否比之前的结果更好。




首先，分别用点评估和导数评估细化标准得到的9个自适应细化周期后的网格看起来是这样的。

[2.x.293]

在网格中仍然可以看到解的特征，但是由于解是光滑的，对偶解的奇异点完全主导了网格细化准则，并导致网格强烈集中。第七次细化步骤后的解看起来像下面这样。

[2.x.294]

显然，在某些地方的解是比较差的，但是网格细化过程中应该注意到这些地方对计算点值并不重要。





下一步是将新的（基于二重性的）网格细化标准与旧的标准进行比较。这些是结果。

[2.x.295]




其结果是，嗯，有点混合。首先，Kelly指标因其不稳定的行为而失去了资格，多次改变了误差的符号，而且在网格细化下误差越来越大。双重加权误差估计器的误差呈单调下降，比加权凯利和全局细化要好，但幅度没有预期的那么大。在这里，这是由于全局细化可以利用评估点周围网格的规则结构，从而导致点误差的收敛顺序更好。然而，如果我们有一个不是局部矩形的网格，例如因为我们必须近似弯曲的边界，或者如果系数不是恒定的，那么全局细化网格的这种优势就会消失，而基于对偶性的估计器的良好性能将保持不变。







[1.x.106]


这里的结果并没有太明显地表明双加权误差估计方法在网格细化方面比其他网格细化标准（如Kelly指标）更有优势。这是由于所显示的应用相对简单的缘故。如果你还不相信这种方法确实有优势，请你浏览一下引言中提到的文献，其中提供了大量的例子，双加权方法可以将必要的数值工作减少几个数量级，使之成为计算某些数量的合理精度的唯一途径。




除了你可能对其作为网格细化标准提出的反对意见外，考虑到对可能想要计算的量的误差的准确认识是非常有用的，因为我们可以在对精度满意的时候停止计算。使用更传统的方法，很难得到任意量的精确估计，也许除了能量准则的误差，我们将不能保证我们计算的结果满足对其准确性的任何要求。另外，正如对点值和导数的评价所显示的那样，误差估计可以用来推断结果，在我们想知道的量上产生更高的精度。




抛开这些数学上的考虑，我们试图以模块化的方式编写程序，这样实现另一个测试案例，或另一个评估和双重功能就很简单。我们鼓励你把这个程序作为你自己实验的基础，并且玩一玩。


examples/step-15/doc/intro.dox

[2.x.296]

[1.x.107][2.x.297] 。


[1.x.108]

[1.x.109]

[1.x.110]

这个程序涉及到一个非线性椭圆偏微分方程的例子，即[最小表面方程](https://en.wikipedia.org/wiki/Minimal_surface)。你可以想象这个方程的解来描述一个肥皂膜所跨越的表面，这个肥皂膜被一个封闭的金属环所包围。我们想象金属丝不只是一个平面的环，实际上是弯曲的。肥皂膜的表面张力将使该表面变成最小表面。最小表面方程的解描述了这个形状，电线的垂直位移是一个边界条件。为了简单起见，我们在此假定表面可以写成图形[2.x.298]，尽管很明显，构建这样的情况并不难，即钢丝弯曲的方式使得表面只能局部构建成图形，而不能整体构建。

因为这个方程是非线性的，所以我们不能直接解决它。相反，我们必须使用牛顿的方法来迭代计算解决方案。

[2.x.299] （ [2.x.300] ）。




[1.x.111]

在经典的意义上，该问题以如下形式给出。


  [1.x.112]



[2.x.301]是我们将导线的位置投影到[2.x.302]空间得到的域。在这个例子中，我们选择[2.x.303]作为单位盘。

如上所述，我们用牛顿方法解决这个方程，在这个方法中，我们从[2.x.305]个方程计算出[2.x.304]个近似解，并使用阻尼参数[2.x.306]来获得更好的全局收敛行为。   [1.x.113]

与[1.x.114]

而[2.x.307]是F在[2.x.308]方向的导数。

[1.x.115]



通过寻找[2.x.309]是什么，我们发现我们必须在每一个牛顿步骤中解决一个线性椭圆PDE，[2.x.310]是的解。

  [1.x.116]



为了解决最小表面方程，我们必须重复解决这个方程，每一个牛顿步骤一次。为了解决这个问题，我们必须看一下这个问题的边界条件。假设[2.x.311]已经有了正确的边界值，那么牛顿更新[2.x.312]的边界条件应该为零，这样才能在加入两者之后有正确的边界条件。  在第一个牛顿步骤中，我们从解[2.x.313]开始，牛顿更新仍然要向解[2.x.314]传递正确的边界条件。


综上所述，我们必须在第一步用边界条件[2.x.315]解决上述PDE，并在接下来的所有步骤中用[2.x.316]解决。

[2.x.317] 在某种意义上，人们可能会说，如果程序已经实现了[2.x.318]，那么还必须实现[2.x.319]就是重复的。像往常一样，重复会诱发错误，我们希望能避免它。虽然我们在这个程序中没有探讨这个问题，但我们将在下面的[1.x.117]部分的结尾处，特别是在步骤72中再来讨论这个问题。




[1.x.118]

从上面的强表述开始，我们通过将PDE的两边都乘以一个检验函数[2.x.320]并对两边进行部分积分，得到弱表述。   [1.x.119]

这里的解[2.x.321]是[2.x.322]中的一个函数，受制于上面讨论的边界条件。将这一空间还原为具有基数[2.x.323]的有限维空间，我们可以写出该解。

[1.x.120]



使用基函数作为测试函数并定义[2.x.324]，我们可以重写弱的表述。

[1.x.121]



其中解 [2.x.325] 是由系数 [2.x.326] 给出的。这个线性方程组可以改写为。

[1.x.122]



其中，矩阵[2.x.327]的条目由以下方式给出。

[1.x.123]



而右手边[2.x.328]由以下公式给出。

[1.x.124]






[1.x.125]

与上述牛顿步骤相对应的矩阵可以重新表述，以更好地显示其结构。稍微重写一下，我们可以得到它的形式是

[1.x.126]

其中矩阵[2.x.329]（在[2.x.331]空间维度中的大小为[2.x.330]）由以下表达式给出。

[1.x.127]

从这个表达式来看，显然[2.x.332]是对称的，所以[2.x.333]也是对称的。另一方面，[2.x.334]也是正定的，这使[2.x.335]也具有同样的属性。这可以通过注意到向量[2.x.336]是[2.x.337]的特征向量，其特征值为[2.x.338]，而所有与[2.x.340]相互垂直的向量[2.x.339]都是特征向量，其特征值为[2.x.341] 。由于所有的特征值都是正的，[2.x.342]是正定的，[2.x.343]也是正定的。因此我们可以使用CG方法来解决牛顿步骤。矩阵[2.x.344]是对称和正定的这一事实不应该令人惊讶。它是由取一个能量函数的导数而产生的算子的结果：最小表面方程只是最小化了一些非二次能量。因此，牛顿矩阵，作为标量能量的二阶导数矩阵，必须是对称的，因为与[2.x.345]th和[2.x.346]th自由度有关的导数显然应该相减。同样，如果能量函数是凸的，那么第二导数的矩阵必须是正定的，上面的直接计算只是重申了这一点。)

然而，值得注意的是，在[2.x.347]变大的问题上，正定性会退化。换句话说，如果我们简单地将所有边界值乘以2，那么一阶[2.x.348]和[2.x.349]也将被乘以2，但结果是[2.x.350]的最小特征值将变小，矩阵将变得更加涣散。更具体地说，对于[2.x.351]，我们有[2.x.352]而[2.x.353]；因此，[2.x.354]的条件数，也就是[2.x.355]的条件数的一个乘法因子，会像[2.x.356]那样增长）。用目前的程序很容易验证，确实将目前程序中使用的边界值乘以越来越大的数值，导致问题最终不再能用我们这里使用的简单预设条件的CG方法解决。




[1.x.128]

如上所述，牛顿方法的工作原理是计算一个方向[2.x.357]，然后以一个步长[2.x.359]执行更新[2.x.358] 。一个常见的现象是，对于强非线性模型，如果我们总是选择[2.x.360]，牛顿方法就不会收敛，除非我们从一个足够接近非线性问题的解[2.x.362]的初始猜测[2.x.361]开始。在实践中，我们并不总是有这样的初始猜测，因此采取完整的牛顿步骤（即使用[2.x.363]）往往是行不通的。

因此，一个常见的策略是，当迭代[2.x.364]离解[2.x.365]还很远时，在前几步使用较小的步长，随着我们越来越接近，使用较大的[2.x.366]值，直到最后我们可以开始使用全步[2.x.367]，因为我们已经足够接近解。当然，问题是如何选择[2.x.368]。基本上有两种广泛使用的方法：直线搜索和信任区域方法。

在这个程序中，我们总是简单地选择步长等于0.1。这确保了在手头的测试案例中，我们确实得到了收敛，尽管很明显，由于没有最终恢复到全步长，我们放弃了使牛顿方法如此吸引人的快速、二次收敛性。很明显，如果这个程序是为了解决更多的现实问题，我们最终必须解决这个问题。我们将在[1.x.129]中对这个问题进行更多的评论，并在第77步中使用一个更好的方法。




[1.x.130]

总的来说，我们这里的程序在许多方面与step-6并无不同。主类的布局基本上是相同的。另一方面，[2.x.369]函数中的驱动算法是不同的，工作原理如下。<ol> [2.x.370] 从函数[2.x.371]开始，以这样的方式修改它，使[2.x.372]的值沿边界等于正确的边界值[2.x.373]（这发生在[2.x.374]）。设[2.x.375] .  [2.x.376]

[2.x.377] 通过解决[2.x.378]系统和[2.x.379]上的边界条件，计算牛顿更新。  [2.x.381]

[2.x.382] 计算一个步长 [2.x.383] 。在这个程序中，我们总是设置 [2.x.384] 。为了便于以后的扩展，这发生在一个自己的函数中，即[2.x.385] 中。 (总是选择[2.x.386]的策略当然不是最优的--我们应该选择一个对给定搜索方向有效的步长--但这需要做一些工作来实现。最后，我们把这类事情留给外部软件包：step-77就是这样做的）。)  [2.x.387]

[2.x.388] 解的新近似值由 [2.x.389] 给出。  [2.x.390]

[2.x.391] 如果[2.x.392]是5的倍数，则细化网格，将解[2.x.393]转移到新的网格中，并设置[2.x.394]的值，以便沿边界有[2.x.395]（同样在[2.x.396]）。请注意，这并不是自动保证的，即使在网格细化之前我们已经有了[2.x.397]，因为网格细化会在网格中增加新的节点，当我们把旧的解决方案带到新的网格时，必须把旧的解决方案插值到新的节点。我们通过插值选择的数值可能接近于精确的边界条件，但一般来说，并不是正确的数值。  [2.x.398]

[2.x.399] 设置[2.x.400]并转到步骤2。  [2.x.401] [2.x.402]。

我们解决的测试案例选择如下。我们寻求在单位盘[2.x.403]上找到最小曲面的解决方案，其中曲面沿边界达到[2.x.404]的数值。


examples/step-15/doc/results.dox



[1.x.131]


程序的输出看起来如下。

[1.x.132]



很明显，该方案会收敛，即使不是非常快。我们将在下面讨论加速该方法的策略。

我们可以在每一组五次牛顿迭代之后，即在我们近似解决方案的每一个网格上，直观地看到解决方案。这就产生了以下一组图像。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_15_solution_1.png" alt="带等高线的零周期后的解决方案。" width="230" height="273"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_15_solution_2.png" alt="带等高线的一个周期后的解决方案。" width="230" height="273"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_15_solution_3.png" alt="带轮廓线的两个周期后的解决方案。" width="230" height="273"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_15_solution_4.png" alt="带轮廓线的三个周期后的解决方案。" width="230" height="273"> </div> <div>

可以清楚地看到，每次细化后的解决方案都能使表面最小化。解决方案收敛于人们想象中的肥皂泡，它位于一个像边界一样弯曲的线环内。同样可以看出，每次细化后，边界是如何被平滑化的。在粗略的网格上，边界看起来并不像正弦，而网格越细越像。

网格主要是在边界附近被细化，在那里解的增加或减少很强烈，而在域的内部则被粗化，在那里没有什么有趣的事情发生，因为解没有什么变化。这里显示的是第九个解和网格。

<div class="onecolumn" style="width: 60%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_15_solution_9.png" alt="第九个周期的网格和解决方案与等高线。" width="507" height="507"> </div> </div>




[1.x.133]

[1.x.134]

该程序显示了一个非线性、静止问题的求解器的基本结构。然而，它的收敛速度不是特别快，这是有原因的。

- 该程序总是采取0.1的步长。这就排除了牛顿方法通常选择的快速、二次收敛。

- 它没有将非线性迭代与网格细化迭代联系起来。

很明显，一个更好的方案必须解决这两点。我们将在下文中讨论它们。




[1.x.135]

牛顿方法有两个众所周知的特性。

- 它可能不会从任意选择的起点收敛。相反，一个起点必须足够接近解决方案以保证收敛。然而，我们可以通过使用 [1.x.136] 0< [2.x.405] 的阻尼迭代来扩大牛顿方法的收敛区域。

- 如果(i)步长选择为[2.x.406]，并且(ii)事实上在选择步长的情况下，它表现出快速收敛的二次方阶。

这两个观察的结果是，一个成功的策略是为初始迭代选择[2.x.407]，直到迭代已经足够接近，允许以全步长收敛，这时我们要切换到[2.x.408] 。问题是如何以自动方式选择[2.x.409]，以满足这些标准。

我们不想在这里回顾关于这个主题的文献，只是简单地提到有两种基本的方法来解决这个问题：回溯线搜索和信任区域方法。前者更广泛地用于偏微分方程，基本上是这样做的。

- 计算一个搜索方向

- 看看[2.x.410]与[2.x.411]产生的残差是否比[2.x.412]单独产生的残差 "大大减少"。

- 如果是这样，那么就采取 [2.x.413] 。

- 如果不是，用 [2.x.414] 试试残差是否 "大大缩小"。

- 如果是这样，则取[2.x.415] 。

- 如果不是，用[2.x.416]试试残差是否 "大大缩小"。

- 等等。当然，除了上面选择的[2.x.418]，我们还可以选择其他因素[2.x.417]，用于[2.x.419] 。很明显，"回溯 "一词的来源是：我们尝试一个长的步骤，但如果不成功，我们就尝试一个更短的步骤，越来越短的步骤，等等。函数[2.x.420]的编写方式正是为了支持这种用例。

我们是否接受一个特定的步长[2.x.421]取决于我们如何定义 "大大小于"。有很多方法，但不详细介绍，我们只说最常见的是使用沃尔夫和阿米约-戈尔德斯坦条件。对于这些，人们可以证明如下。

- 总有一个步长[2.x.422]可以满足条件，也就是说，只要问题是凸的，迭代就不会卡住。

- 如果我们足够接近解决方案，那么条件允许[2.x.423] ，从而实现二次收敛。

我们在此不再赘述，而是将这种算法的实现作为一个练习。然而，我们注意到，如果实施得当，大多数合理的非线性问题可以在5到15次牛顿迭代中得到解决，达到工程精度&mdash；比我们目前版本的程序所需要的次数要少得多，这是一个普遍现象。

关于包括回溯在内的全局化方法的更多细节，例如可以在 [2.x.424] 和 [2.x.425] 找到。

然而，非常值得一提的是，在实践中，高效非线性求解器的实现与高效有限元方法的实现一样复杂。我们不应该试图通过自己实现所有的必要步骤来重新发明车轮。在[2.x.426]函数中已经有了大量的拼图，可以用来实现这一目的。但是，相反，就像在deal.II等库上构建有限元求解器一样，人们应该在[SUNDIALS](https://computing.llnl.gov/projects/sundials)等库上构建非线性求解器。事实上，deal.II有与SUNDIALS的接口，特别是通过[2.x.427]类与它的非线性求解器子包KINSOL的接口。将目前的问题建立在该接口上并不十分困难--事实上，这正是step-77所做的。




[1.x.137]

我们目前在每个网格上正好做了5次迭代。但这是最优的吗？人们可以提出以下问题。

- 也许在初始网格上做更多的迭代是值得的，因为那里的计算很便宜。

- 另一方面，我们不希望在每个网格上做太多的迭代：是的，我们可以在每个网格上将残差驱动到零，但这只意味着非线性迭代误差远远小于离散化误差。

- 我们应该用更高还是更低的精度来解决每个牛顿步骤中的线性系统？

最终，这归结为我们需要将当前网格上的离散化误差与我们希望在特定网格上通过牛顿迭代实现的非线性残差，以及我们希望在每个牛顿迭代中通过CG方法实现的线性迭代结合起来。

如何做到这一点，同样不是完全微不足道的，我们再次将其作为未来的练习。




[1.x.138]

正如介绍中所概述的，当解决一个形式为[1.x.139]的非线性问题时

我们使用牛顿迭代，要求我们反复解决线性偏微分方程[1.x.140]。

这样，我们就可以计算出更新[1.x.141]。

与牛顿步骤的解[2.x.428]。对于这里的问题，我们可以用手计算导数[2.x.429]，得到[1.x.142] 。

但这已经是一个相当大的表达方式了，无论是推导还是实现都很麻烦。在某种意义上，它也是重复的。如果我们在代码的某个地方实现了[2.x.430]是什么，那么[2.x.431]就不是一个独立的信息，而是至少在原则上计算机应该能够自己推断出来的东西。如果这真的能发生，那不是很好吗？也就是说，如果我们真的只需要实现[2.x.432]，而[2.x.433]是以某种方式隐含完成的，那不是很好吗？这实际上是可能的，并以 "自动微分 "的名义运行。步骤-71讨论了这个概念的一般术语，步骤-72说明了如何在实践中应用于我们在这里考虑的问题。


examples/step-16/doc/intro.dox

[2.x.434]

[1.x.143]

[1.x.144]

[1.x.145]


这个例子展示了deal.II中多级函数的基本用法。它几乎解决了与步骤6中使用的相同的问题，但展示了使用多网格作为预处理程序时必须提供的东西。特别是，这要求我们定义一个层次结构，提供从一个层次到下一个层次以及返回的转移算子，并在每个层次上提供拉普拉斯算子的表示。

为了使微分方程系统和块状预处理程序具有足够的灵活性，在启动多级方法之前必须创建一些不同的对象，尽管大部分需要做的事情都是由deal.II本身提供。这些对象是

  - 网格之间的对象处理转移；我们使用MGTransferPrebuilt类来处理这个问题，它几乎完成了库内的所有工作。

  - 解算器的最粗层次；在这里，我们使用MGCoarseGridHouseholder。

  - 所有其他级别的平滑器，在我们的例子中，这将是使用SOR作为基本方法的[2.x.435]类。

  - 和[2.x.436]一个具有特殊水平乘法的类，也就是说，我们基本上每个网格水平存储一个矩阵并允许与之相乘。

这些对象中的大多数只需要在实际求解线性系统的函数中使用。在这里，这些对象被组合到一个多网格类型的对象中，其中包含V型循环的实现，它又被预设条件器PreconditionMG使用，准备插入LAC库的线性求解器中。

这里实现的自适应细化网格的多网格方法遵循[2.x.437]"多网格论文 "中的大纲，该论文在deal.II中描述了底层实现，也介绍了很多术语。首先，我们必须区分层次网格，即与粗网格有相同细化距离的单元，以及由层次中的活动单元组成的叶子网格（在较早的工作中，我们将其称为全局网格，但这个术语被过度使用）。最重要的是，叶子网格与最细层次上的层次网格不完全相同。下面的图片显示了我们认为的 "层次网"。

<p align="center"> [2.x.438] [2.x.439] 。

这个网格中的精细层次只包括定义在精细单元上的自由度，但不延伸到领域中未被精细化的那部分。虽然这保证了整体的努力增长为[2.x.440]的最佳多网格复杂度所必需的，但它导致了在定义平滑的地方和对定义在各个层次上的算子提出什么边界条件时的问题，如果层次边界不是外部边界。这些问题将在上面引用的文章中详细讨论。

[1.x.146]

我们在这里解决的问题与第6步类似，主要有两个不同点：第一，多网格预处理程序，显然。我们还改变了系数的不连续性，使局部装配器看起来不会比必要的更复杂。


examples/step-16/doc/results.dox



[1.x.147]

在最细的网格上，解决方案看起来像这样。

<p align="center"> [2.x.441] [2.x.442] 。

更重要的是，我们想看看多网格方法是否真的改善了求解器的性能。因此，这里是文本输出。

<p>周期0 活动单元数：80 自由度数：89（按级别：8，25，89） CG迭代数。8

周期1 活动单元数：158 自由度数：183（按级别：8，25，89，138） CG迭代次数。9

周期2 活动单元数：302 自由度数：352（按级别：8、25、89、223、160） CG迭代次数。10

周期3 活动单元数：578 自由度数：649（按级别：8、25、89、231、494、66） CG迭代次数。10

第四周期 活跃单元数：1100 自由度数：1218（按级别：8、25、89、274、764、417、126） CG迭代次数。10

周期5 活动单元数：2096 自由度数：2317（按级别：8、25、89、304、779、1214、817） CG迭代次数。11

第6周期 活跃单元数：3986 自由度数：4366（按级别：8，25，89，337，836，2270，897，1617） CG迭代数。10

周期7 活动单元数：7574 自由度数：8350（按级别：8、25、89、337、1086、2835、2268、1789、3217） CG迭代次数。11 </pre>

这几乎是完美的多重网格性能：线性残差在10个迭代步骤中被减少了12个数量级，而且结果几乎与网格大小无关。这显然部分是由于所解决的问题的简单性质，但它显示了多梯度方法的力量。




[1.x.148]


我们鼓励你生成solve()调用的时间并与步骤6进行比较。你会看到多网格方法在粗网格上有相当大的开销，但由于其最佳的复杂性，它在细网格上总是胜过其他方法。

仔细检查这个程序的性能就会发现，它主要是由矩阵-向量操作主导的。step-37展示了一种通过使用无矩阵方法来避免这种情况的方法。

另一个途径是使用代数多网格方法。这里使用的几何多栅方法在实现上有时会有点尴尬，因为它需要所有这些额外的数据结构，如果程序要在%parallel的机器上通过MPI耦合运行，就会变得更加困难，例如。在这种情况下，如果能使用一个黑盒预处理程序，就会更简单，该程序使用某种多栅层次结构以获得良好的性能，但可以自己计算出水平矩阵和类似的东西。代数多栅方法正是这样做的，我们将在步骤31中使用它们来解决斯托克斯问题，在步骤32和步骤40中使用它们来解决平行变化。也就是说，在步骤50中可以找到这个例子程序的MPI并行版本。

最后，人们可能要考虑如何将几何多网格用于其他类型的问题，特别是[2.x.443]"矢量值问题"。这是step-56的主题，我们将这里的技术用于斯托克斯方程。


examples/step-16b/doc/intro.dox

[2.x.444]

[1.x.149]

[1.x.150]

这是第16步的一个变体，唯一的变化是我们使用MeshWorker框架和预制的LocalIntegrator辅助类，而不是手动组装矩阵。

关于这个框架在实践中如何使用的细节，将作为本教程计划的一部分加以解释。

[1.x.151]

我们在这里解决的问题与步骤16中的问题相同。


examples/step-16b/doc/results.dox



[1.x.152]

如同第16步，在最细的网格上，解决方案看起来是这样的。

<p align="center"> [2.x.445] [2.x.446] 。

与step-16相比，输出的格式略有不同，但在功能上是一样的，显示了相同的收敛特性。<p> [2.x.447] 0 DEAL:: 活动单元数：20 DEAL:: 自由度数：25（通过级别：8，25） [2.x.448] 值 0.510691 [2.x.449] 步骤6 值 4.59193e-14 [2.x.450] 1 DEAL:: 活动单元数：44 DEAL:: 自由度数：55（按级别：8，25，45） [2.x.451] 值 0.440678 [2.x.452] 步骤8值 1.99419e-13 [2.x.453] 2 DEAL:: 活动单元数：86 DEAL:: 自由度数：105（按级别：8，25，69，49） [2.x.454] 值 0.371855 [2.x.455] 步骤 9 值 1.13984e-13 [2.x.456]3 DEAL:: 活动单元数：170 DEAL:: 自由度数：200（按级别：8，25，77，174） [2.x.457] 值 0.318967 [2.x.458] 步骤 9 值 2.62112e-13 [2.x.459] 4 DEAL:: 活动单元数：332 DEAL:: 自由度数：388（按级别：8, 25, 86, 231, 204） [2.x.460] 值 0.276534 [2.x.461] 步骤10值 1.69562e-13 [2.x.462] 5 DEAL:: 活动单元数：632 DEAL:: 自由度数：714（按级别：8, 25, 89, 231, 514, 141） [2.x.463] 值 0.215300 [2.x.464] 步骤10值 6.47463e-13 [2.x.465] 6 DEAL:: 活动单元数：1202 DEAL:: 自由度数：1332（按级别：8, 25, 89, 282, 771, 435, 257） [2.x.466] 值 0.175848 [2.x.467] 第10步值 1.80664e-13 [2.x.468] 7 DEAL:: 活动单元数：2288 DEAL:: 自由度数：2511（按级别：8、25、89、318、779、1420、829、30） [2.x.469] 值 0.136724 [2.x.470] 第11步值 9.73331e-14 </pre>


examples/step-17/doc/intro.dox

[1.x.153]

[1.x.154]

[1.x.155]

这个程序没有引入任何新的数学思想；事实上，它所做的只是做与step-8已经做的完全相同的计算，但它以一种不同的方式来做：我们没有使用deal.II自己的线性代数类，而是在deal.II提供的类之上建立一切，这些类包裹着[1.x.156]库的线性代数实现。由于PETSc允许将矩阵和向量分布在MPI网络中的几台计算机上，因此产生的代码甚至能够以%并行方式解决问题。如果你不知道PETSc是什么，那么这将是一个快速浏览其主页的好时机。

作为这个程序的先决条件，你需要安装PETSc，如果你想在一个集群上以%并行方式运行，你还需要[1.x.157]来划分网格。在[1.x.158]文件中描述了deal.II和这两个附加库的安装。

现在，关于细节：如前所述，该程序不计算任何新的东西，所以对有限元类等的使用与以前完全相同。与以前的程序不同的是，我们用几乎所有的类[2.x.471]代替了它们的近似值[2.x.472]和[2.x.473]，它们存储数据的方式使MPI网络中的每个处理器只存储矩阵或矢量的一部分。更具体地说，每个处理器将只存储与它 "拥有 "的自由度相对应的矩阵的那些行。对于向量，它们要么只存储与处理器拥有的自由度相对应的元素（这是右手边所需要的），要么也存储一些额外的元素，以确保每个处理器都能访问处理器拥有的单元（所谓[2.x.474]"本地活动的自由度"）或邻近单元（所谓[2.x.475]"本地相关自由度"）上的解组件。

来自PETScWrapper命名空间的类所提供的接口与deal.II线性代数类的接口非常相似，但它们不是自己实现这一功能，而是简单地传递给它们相应的PETSc函数。因此，包装器只是用来给PETSc一个更现代的、面向对象的接口，并使PETSc和deal.II对象的使用尽可能地互换。使用PETSc的主要意义在于它可以在%并行状态下运行。我们将利用这一点，将域划分为与MPI网络中的进程一样多的块（"子域"）。同时，PETSc还提供了假的MPI存根，所以如果PETSc的配置中没有MPI，你可以在一台机器上运行这个程序。




[1.x.159]

开发软件以通过MPI在%parallel中运行，需要改变一下思维方式，因为我们通常必须分割所有的数据结构，使每个处理器只存储整个问题的一部分。因此，你通常不能在每个处理器上访问一个解决方案向量的所有组成部分 -- 每个处理器可能根本没有足够的内存来容纳整个解决方案向量。由于数据被分割或 "分布 "在各个处理器上，我们把MPI使用的编程模型称为 "分布式内存计算"（与 "共享内存计算 "相反，后者意味着多个处理器可以访问一个内存空间中的所有数据，例如，当一台机器的多个核心在一个共同任务上工作时）。分布式内存计算的一些基本原理在[2.x.476]"使用分布式内存的多处理器并行计算 "文档模块中讨论，该模块本身是[2.x.477]"并行计算 "模块的一个子模块。

一般来说，为了真正能够扩展到大量的处理器，我们需要在可用的处理器之间分割出[1.x.160]数据结构，其大小随着整个问题的大小而扩展。关于程序 "扩展 "的定义，见[2.x.478]"本词汇表条目"）。这包括，例如，三角形、矩阵和所有全局向量（解决方案，右手边）。如果不拆分所有这些对象，其中一个对象将被复制到所有的处理器上，如果问题大小（和可用的处理器数量）变得很大，最终会简单地变得太大。另一方面，在每个处理器上保留大小与整个问题大小无关的对象是完全可以的。例如，可执行文件的每个副本将创建自己的有限元对象，或者我们在汇编中使用的局部矩阵）。)

在当前的程序中（以及相关的第18步），我们不会走得这么远，而是对MPI的使用做一个比较温和的介绍。更具体地说，我们要并行化的数据结构只有矩阵和向量。然而，我们并没有拆分Triangulation和DoFHandler类：每个进程仍然拥有这些对象的完整副本，而且所有进程都拥有其他进程所拥有的确切副本。然后，我们只需在每个处理器上的三角形的每个副本中，标记哪个处理器拥有哪些单元。这个过程被称为将网格 "分割 "为[2.x.479]"子域"。

对于较大的问题，必须在每个处理器上存储[1.x.161]网格，显然会产生一个瓶颈。分割网格是稍微的，虽然没有多复杂（从用户的角度来看，虽然它[1.x.162]下更复杂）来实现，我们将展示如何在step-40和其他一些程序中这样做。在讨论这个程序的某个功能如何工作的过程中，我们会多次评论它不会扩展到大型问题，以及为什么不会。所有这些问题都将在第18步，特别是第40步中得到解决，它可以扩展到非常多的进程。

从哲学上讲，MPI的运作方式如下。你通常通过以下方式运行一个程序

[1.x.163]

这意味着在（比如）32个处理器上运行它。如果你是在一个集群系统上，你通常需要[1.x.164]程序在32个处理器可用时运行；这将在你的集群的文档中描述。但是在系统内部，每当这些处理器可用时，通常会执行上述相同的调用）。)这样做的目的是，MPI系统将启动32个[1.x.165]的[2.x.480]的可执行文件。(这些正在运行的可执行文件中的每一个的MPI术语是，你有32个[2.x.481]"MPI进程"。)这可能发生在不同的机器上，甚至不能从对方的内存空间中读取，也可能发生在同一台机器上，但最终的结果是一样的：这32个副本中的每一个都将以操作系统分配给它的一些内存运行，而且它不能直接读取其他31个副本的内存。为了在一个共同的任务中进行协作，这32个副本就必须[1.x.166]相互协作。MPI是[1.x.167]的缩写，通过允许程序[1.x.168]来实现这一点。你可以把它看作是邮件服务：你可以把一封写给特定地址的信放入邮件，它将被送达。但这是你能控制事物的程度。如果你想让收信人对信的内容做些什么，例如把你想要的数据从那边返回给你，那么需要发生两件事。(i)接收方需要实际去检查他们的邮箱里是否有东西，(ii)如果有的话，做出适当的反应，比如说发送数据回来。如果你等待这个返回信息，但原来的接收者却心不在焉，没有注意，那么你就不走运了：你只需要等待，直到你在那边的请求将被解决。在某些情况下，错误会导致原始接收者永远不检查你的邮件，在这种情况下，你将永远等待--这被称为[1.x.169]。( [2.x.482]

在实践中，人们通常不在发送和接收单个消息的层面上编程，而是使用更高层次的操作。例如，在程序中，我们将使用函数调用，从每个处理器获取一个数字，将它们全部相加，然后将总和返回给所有处理器。在内部，这是用单个消息实现的，但对用户来说，这是透明的。我们称这种操作为[1.x.170]，因为[1.x.171]处理器参与其中。集合体允许我们编写程序，其中不是每个可执行文件的副本都在做完全不同的事情（这将是难以置信的编程难度），但实质上所有副本都在为自己做同样的事情（尽管是在不同的数据上），通过相同的代码块运行；然后他们通过集合体进行数据通信；然后再回到为自己做事情，通过相同的数据块运行。这是能够编写程序的关键部分，也是确保程序能够在任何数量的处理器上运行的关键部分，因为我们不需要为每个参与的处理器编写不同的代码。

这并不是说程序从来都是以不同的处理器在其可执行文件的副本中运行不同的代码块的方式来编写的。程序内部也经常以其他方式而不是通过集合体进行通信。但是在实践中，%并行有限元代码几乎总是遵循这样的方案：程序的每个副本在同一时间运行相同的代码块，中间穿插着所有处理器相互交流的阶段）。)

在现实中，即使是调用MPI集体函数的水平也太低了。相反，下面的程序根本不会包含对MPI的任何直接调用，而只包含对deal.II的用户隐藏这种通信的函数。这样做的好处是，你不需要学习MPI的细节和相当复杂的函数调用。也就是说，你确实必须理解上文所述的MPI背后的一般哲学。




[1.x.172]

然后，这个程序演示的技术是。

- 如何使用PETSc封装类；这在本程序的主类的声明中已经可以看到， [2.x.483] 。

- 如何将网格划分为子域；这发生在[2.x.484]函数。

- 如何对运行在MPI网络上的作业进行并行化操作；在这里，这是在很多地方都要注意的，最明显的是在[2.x.485]函数中。

- 如何处理只存储向量项子集的向量，对于这些向量，我们必须确保它们在当前处理器上存储我们需要的东西。例如见[2.x.486]函数。

- 如何处理同时在多个处理器上运行的程序的状态输出。这是通过程序中的[2.x.487]变量完成的，在构造函数中初始化。

由于这一切只能用实际的代码来证明，让我们直接进入代码，不再多说。


examples/step-17/doc/results.dox



[1.x.173]


如果上述程序在单处理器机器上编译和运行，它产生的结果应该与我们已经通过步骤8得到的结果非常相似。然而，如果我们在多核机器或计算机集群上运行它，就会变得更加有趣。运行MPI程序的最基本方法是使用一个命令行，如

[1.x.174]

以32个处理器运行step-17可执行文件。

如果你在一个集群上工作，那么中间通常有一个步骤，你需要设置一个作业脚本，并将该脚本提交给调度器。只要调度器能够为你的工作分配32个未使用的处理器，它就会执行这个脚本。如何编写这样的作业脚本因集群而异，你应该找到你的集群的文档来看看如何做。在我的系统上，我必须使用[2.x.488]这个命令，加上一大堆的选项来并行运行一个作业）。)

无论是直接还是通过调度器，如果你在8个处理器上运行这个程序，你应该得到如下输出。

[1.x.175]

(这次运行比examples/目录中的代码多用了几个细化周期。该运行还使用了2004年的METIS版本，产生了不同的分区；因此，你今天得到的数字略有不同）。)

可以看出，我们可以很容易地达到近400万个未知数。事实上，这段代码在8个进程中的运行时间不到7分钟，直到（包括）第14个周期，14分钟包括倒数第二步。(这些数字与该代码最初编写的时间有关，即2004年。)虽然我失去了最后一步的时间信息，但你会明白的。所有这些都是在通过运行[2.x.489]启用发布模式之后，并且由于上述程序注释中所述的原因，关闭了图形输出的生成。( [2.x.490] 我做的最大的2D计算大约有710万个未知数，在32个进程上完成。花了大约40分钟。毫不奇怪，一个人能够走多远的限制因素是他有多少内存，因为每个进程都必须持有整个网格和DoFHandler对象，尽管矩阵和向量被分割开来。对于7.1M的计算，每个未知数的内存消耗约为600字节，这并不坏，但我们必须考虑到这是针对每个未知数的，无论我们是否在本地存储矩阵和向量条目。




下面是在程序的第12个周期中产生的一些输出，即大约有30万个未知数。

[2.x.491]

正如人们所希望的那样，这里显示的X位移（左）和Y位移（右）与我们在第8步中已经看到的密切相关。正如第22步所示，我们也可以制作一个位移场的矢量图，而不是把它绘制成两个独立的标量场。不过，可能更有趣的是，在这一步看一下网格和分区。

[2.x.492]

同样，网格（左边）显示了与之前看到的相同的细化模式。右图显示了8个过程中的域的划分，每个过程用不同的颜色表示。图片显示，在网格单元较小的地方，子域较小，考虑到分区算法试图平衡每个子域的单元数，这一事实是需要预期的；这种平衡在上图所示的输出中也很容易识别，每个子域的度数大致相同。




值得注意的是，如果我们用不同的进程数来运行同一个程序，我们可能会得到稍微不同的输出：不同的网格，不同的未知数和迭代收敛的次数。其原因是，虽然矩阵和右手边是相同的，与使用的进程数无关，但预处理程序不是：它对每个处理器的[2.x.493] 矩阵块分别执行ILU(0) [2.x.494] 。因此，随着进程数的增加，它作为预处理程序的有效性会降低，这使得迭代次数增加。由于不同的预处理程序会导致计算出的解有细微的变化，这将导致细化时标记的网格单元略有不同，在后续步骤中的差异也更大。不过，解决方案看起来总是非常相似的。




最后，这里是3D模拟的一些结果。你可以通过改变以下内容来重复这些结果

[1.x.176]

至

[1.x.177]

在主函数中。如果你再并行运行该程序，你会得到与此类似的东西（这是针对一个有16个进程的工作）。

[1.x.178]






最后一步，达到150万个未知数，在8台双处理器机器（2003年可用的那种）上进行16个进程，需要大约55分钟。这个工作产生的图形输出相当大（第5周期已经打印了大约82MB的数据），所以我们要显示第4周期的输出。

[2.x.495]




左图显示的是将立方体划分为16个过程，而右图显示的是沿两个切面通过立方体的X位移。




[1.x.179]

[1.x.180]

该程序在每个处理器上都保留一份三角形和DoFHandler对象的完整副本。它还创建了解决方案矢量的完整副本，并且只在一个处理器上创建输出。就并行化而言，所有这些显然是瓶颈。

在内部，在deal.II中，将分层和非结构化三角计算中使用的数据结构并行化是一个难点，我们又花了几年时间才实现了这一点。step-40教程程序和[2.x.496]文档模块谈到了如何做这些步骤，以及从应用的角度来看需要什么。当前程序的一个明显的扩展是使用这个功能将计算完全分布到比这里使用的更多的处理器。


examples/step-18/doc/intro.dox

[1.x.181]

[1.x.182]


这个教程程序是我们已经在步骤8和步骤17中开始的弹性问题系列中的另一个。它将其扩展到两个不同的方向：首先，它用拉格朗日网格运动方法解决了大变形的准静态但与时间相关的弹性问题。其次，它又展示了一些使用PETSc的线性代数的%并行处理来解决此类问题的技术。除此之外，我们还展示了如何解决step-17的两个主要瓶颈中的一个，即我们只从一个进程中产生图形输出，而这在更多的进程和大问题上的扩展性非常差。另一个瓶颈，即每个处理器都必须持有整个网格和DoFHandler，将在第40步中解决）。最后，我们还展示了许多以前的程序中未曾展示过的各种改进和技术。

如同前面的第17步，只要你安装了PETSc，程序在单机上的运行也是一样的。关于如何告诉deal.II你的系统上安装了PETSc的信息可以在deal.II的README文件中找到，该文件可以从你安装的deal.II的[1.x.183]中链接到，或者在[1.x.184]上。




[1.x.185]

[1.x.186]

一般来说，随时间变化的小弹性变形是由弹性波方程描述的

[1.x.187]

其中[2.x.497]是身体的变形，[2.x.498]和[2.x.499]是密度和衰减系数，以及[2.x.500]外力。此外，初始条件

[1.x.188]

和Dirichlet（位移）或Neumann（牵引）边界条件，需要指定一个唯一的解决方案。

[1.x.189]

在上述公式中，[2.x.501]是位移的对称梯度，也称为[2.x.502]应变[2.x.503] 。  [2.x.504]是一个等级为4的张量，称为[2.x.505]应力-应变张量[2.x.506]（[1.x.190]的逆向）。]），它包含了材料弹性强度的知识；它的对称性特性确保它将秩为2的对称张量（&ldquo;矩阵&rdquo;的维数[2.x.507]，其中[2.x.508]是空间维数）映射到相同秩的对称张量上。我们将在下面更多地评论应变和应力张量的作用。现在只需要说，我们将术语[2.x.509]解释为具有分量[2.x.510]的向量，其中对指数[2.x.511]的求和是隐含的。

这个方程的准静态极限的动机如下：身体的每个小扰动，例如边界条件或强迫函数的变化，将导致身体配置的相应变化。一般来说，这将是以波的形式从扰动的位置辐射出去。由于阻尼项的存在，这些波将在例如[2.x.512]的时间尺度上被衰减。现在，假设所有外部强制力的变化发生在比[2.x.513]大得多的时间尺度上。在这种情况下，变化的动态性质并不重要：我们可以认为身体总是处于静态平衡状态，也就是说，我们可以假设在任何时候，身体都满足于

[1.x.191]

请注意，微分方程不再包含任何时间导数 -- 所有的时间依赖性都是通过边界条件和可能的时间变化的力函数引入的 [2.x.514] 。因此，配置的变化可以被认为是瞬时静止的。对此的另一种看法是，[2.x.515]并不是真正的时间变量，而只是一个支配问题演变的类似时间的参数。

虽然这些方程足以描述小的变形，但计算大的变形就有点复杂了，一般来说，会导致非线性方程，如步骤-44中处理的那些。在下文中，让我们考虑在模拟变形成为[1.x.192]的问题时，人们会采用的一些工具。

[2.x.516]我们下面要考虑的模型并不是建立在任何在数学上合理的基础上：我们将考虑一个模型，在这个模型中，我们产生一个小的变形，通过这个变形使身体的物理坐标变形，然后再考虑下一个加载步骤，作为一个线性问题。这并不一致，因为线性的假设意味着变形是无限小的，所以在解决下一个线性问题之前，在我们的网格顶点周围移动一个有限的量是不一致的做法。因此，我们应该注意到，在文献中找不到下面讨论的方程，这并不奇怪。[1.x.193]另一方面，我们所考虑的实现技术正是人们在实现[1.x.194]模型时需要使用的，我们将在步骤-44中看到。


为了回到定义我们的 "人工 "模型，让我们首先引入一个张量的应力变量[2.x.517]，并以应力为基础写出微分方程。

[1.x.195]

注意这些方程是在一个随时间变化的域[2.x.518]上提出的，边界根据边界上各点的位移[2.x.519]而移动。为了完成这个系统，我们必须指定应力和应变之间的增量关系，如下所示。[1.x.196]

[1.x.197]

其中点表示一个时间导数。应力[2.x.520]和应变[2.x.521]都是等级2的对称张量。




[1.x.198]

在数值上，该系统的求解方法如下：首先，我们使用后向欧拉方案对时间部分进行离散化。这导致了时间步长的离散平衡力 [2.x.522] 。

[1.x.199]

其中

[1.x.200]

和 [2.x.523] 时间步长的增量位移 [2.x.524] 。此外，我们必须指定初始数据 [2.x.525] 。这样一来，如果我们想求解位移增量，我们必须求解以下系统。

[1.x.201]

这组方程的弱形式，像往常一样是有限元公式的基础，其内容如下：找到[2.x.526]，使[1.x.202]这样的方程。

[1.x.203]

利用[2.x.527]，这些方程可以简化为

[1.x.204]



我们注意到，为了简单起见，在程序中我们总是假设没有边界力，即[2.x.528]，并且身体的变形仅由身体力[2.x.529]和规定的边界位移[2.x.530]驱动。还值得注意的是，当通过部分积分时，我们会得到形式为[2.x.531]的条款，但我们用涉及对称梯度的条款[2.x.532]而不是[2.x.533]来取代它们。由于[2.x.534]的对称性，这两个项在数学上是等价的，但对称版本避免了可能出现的四舍五入错误，使得到的矩阵略显非对称性。

在时间步长[2.x.535]的系统，要在旧域[2.x.536]上求解，其形式完全是一个静止的弹性问题，因此与我们在以前的例子程序中已经实现的类似。因此，除了说我们再次使用最低阶连续有限元之外，我们将不对空间离散化进行评论。

但也有不同之处。<ol> [2.x.537] 我们必须在每个时间步骤之后移动（更新）网格，以便能够在新的领域上解决下一个时间步骤。

   [2.x.538]我们需要知道[2.x.539]来计算下一个增量位移，也就是说，我们需要在时间步骤结束时计算它，以确保它可以用于下一个时间步骤。从本质上讲，应力变量是我们了解体的变形历史的窗口。  [2.x.540] 这两个操作在程序中的[2.x.541]和[2.x.542]函数中完成。移动网格只是一个技术问题，而更新应力则要复杂一些，将在下一节讨论。




[1.x.205]

如上所述，在计算时间步长[2.x.544]时，我们需要有应力变量[2.x.543]，我们可以用[1.x.206]来计算它。

[1.x.207]

尽管这个方程表面上很简单，但有两个问题我们需要讨论。第一个问题是关于我们存储[2.x.545]的方式：即使我们使用最低阶有限元计算增量更新[2.x.546]，那么其对称梯度[2.x.547]一般来说仍然是一个不容易描述的函数。特别是，它不是一个片状常数函数，在一般的网格上（单元不是平行于坐标轴的矩形）或非恒定应力-应变张量[2.x.548]，它甚至不是一个双线性或三线性函数。因此，如何在计算机程序中存储[2.x.549]是先验的。

要决定这一点，我们必须看它被用在什么地方。我们需要应力的唯一地方是在术语[2.x.550]中。在实践中，我们当然会用数值正交来代替这个项。

[1.x.208]

其中[2.x.551]是正交权重，[2.x.552]是单元格[2.x.553]上的正交点。这应该表明，我们真正需要的不是应力[2.x.554]本身，而只是所有单元上的正交点的应力值。然而，这是一个更简单的任务：我们只需要提供一个数据结构，能够为所有单元上的每个正交点（或者，由于我们是并行计算，目前的MPI进程拥有的所有单元的所有正交点&ldquo;rdquo;）容纳一个等级为2的对称张量。在每个时间步骤结束时，我们只需评估[2.x.555]，将其乘以应力-应变张量[2.x.556]，并使用该结果来更新正交点[2.x.558]的应力[2.x.557]。

第二个复杂的问题在我们上面选择的符号中并不明显。这是由于我们在域[2.x.560]上计算[2.x.559]，然后用这个位移增量来更新应力，同时移动网格节点，以达到[2.x.561]，在此基础上计算下一个增量。在这种情况下，我们必须确定的是，移动网格不仅涉及到节点的移动，还涉及到应力变量的相应变化：更新的应力是一个相对于旧域中材料的坐标系而定义的变量，必须转移到新域中。其原因可以理解为：在局部，增量变形[2.x.562]可以分解为三个部分，线性平移（点附近的位移增量场的常数部分），扩张分量（位移场梯度中具有非零发散的那部分），以及旋转。材料的线性平移并不影响冻结在其中的应力--应力值只是沿着平移。扩张或压缩的变化产生相应的应力更新。然而，旋转分量不一定会引起非零的应力更新（想想，在2d中，例如[2.x.563] ，与[2.x.564] 的情况）。尽管如此，如果材料在某个方向上被预应力，那么这个方向将随着材料的旋转而旋转。  为此，我们必须定义一个旋转矩阵[2.x.565]，描述在每一个点上由于位移增量而产生的旋转。不难看出，[2.x.566]对[2.x.567]的实际依赖只能是通过位移的卷曲，而不是位移本身或其全部梯度（如上所述，增量的常数分量描述平移，其发散描述扩张模式，而卷曲描述旋转模式）。由于[2.x.568]的确切形式很麻烦，我们只在程序代码中说明，并注意到应力变量的正确更新公式是[1.x.209] 。

[1.x.210]



应力更新和旋转都是在示例程序的函数[2.x.569]中实现的。




[1.x.211]

在步骤17中，就运行时间而言，平行计算的主要瓶颈是只有第一个处理器产生整个领域的输出。由于生成图形输出是很昂贵的，所以当涉及到更多数量的处理器时，这并不能很好地扩展。我们将在这里解决这个问题。关于程序 "扩展 "的定义，见[2.x.570]"本词汇表条目"）。

基本上，我们需要做的是让每个进程为它所拥有的那个单元子集产生图形输出，将它们写进单独的文件，并有办法同时显示某个时间步长的所有文件。这样，代码在每个时间步长的每个进程产生一个[2.x.571]文件。两个常见的VTK文件查看器ParaView和Viscit都支持一次打开一个以上的[2.x.572]文件。为了简化挑选正确文件的过程，并允许在时间上移动，两者都支持记录文件，以引用特定时间步长的所有文件。遗憾的是，记录文件在VisIt和Paraview之间有不同的格式，所以我们把两种格式都写出来。

代码将生成文件[2.x.573]，其中[2.x.574]是时间步数（从1开始），[2.x.575]是进程等级（从0开始）。这些文件包含时间段和处理器的本地所有单元。文件[2.x.576]是时间段的访问记录[2.x.577]对ParaView也是如此。(较新版本的VisIt实际上也可以读取[2.x.578]文件，但输出两种记录文件也无妨。)最后，[2.x.579]文件是只有ParaView支持的特殊记录，它引用所有的时间步骤。所以在ParaView中，只需要打开solution.pvd，而在VisIt中需要选择所有的.visit文件组，才能达到同样的效果。




[1.x.212]

在第17步中，我们使用了一个在每个处理器上简单复制的常规三角形，以及一个相应的DoFHandler。两者都不知道它们是在%并行环境下使用的--它们只是完整地存在于每个处理器上，我们认为这最终会成为一个主要的内存瓶颈。

我们在这里不解决这个问题（我们将在第40步中解决），但使情况稍微自动化一些。在第17步中，我们创建了三角形，然后手动 "分区"，也就是说，我们给每个单元分配了[2.x.580]"子域ID"，以表明哪个[2.x.581]"MPI进程""拥有 "该单元。在这里，我们使用了一个类[2.x.582]，它至少自动完成了这一部分：每当你创建或完善这样一个三角图时，它都会自动在所有参与的进程之间进行划分（它知道这些进程，因为你必须告诉它在构建三角图时连接这些进程的[2.x.583]"MPI通信器"）。否则，[2.x.584]看起来，就所有的实际目的而言，就像一个普通的Triangulation对象。

使用这个类的便利性不仅来自于能够避免手动调用[2.x.585]，相反，DoFHandler类现在也知道你想在并行环境下使用它，并且默认情况下会自动列举自由度，使进程0拥有的所有DoF先于进程1拥有的所有DoF，等等。换句话说，你也可以避免对[2.x.586]的调用。

还有其他好处。例如，由于三角计算知道它生活在一个%parallel universe中，它也知道它 "拥有 "某些单元（即那些子域id等于其MPI等级的单元；以前，三角计算只存储这些子域id，但没有办法使它们有意义）。因此，在汇编函数中，你可以测试一个单元是否 "本地拥有"（即由当前进程拥有，见[2.x.587]），当你在所有单元上循环时，使用以下语法

[1.x.213]

这种知识延伸到建立在这种三角形上的DoFHandler对象，然后它可以通过[2.x.589]和[2.x.590]等调用来识别哪些自由度是本地拥有的（见[2.x.588]）。最后，DataOut类也知道如何处理这种三角形，并将简单地跳过在非本地拥有的单元上生成图形输出。

当然，正如在第17步的讨论中多次指出的那样，在每个进程上保持整个三角形将无法扩展：大型问题可能根本无法再适合每个进程的内存，即使我们有足够多的进程在合理的时间内解决它们。在这种情况下，[2.x.591]不再是一个合理的计算基础，我们将在步骤40中展示如何使用[2.x.592]类来解决这个问题，即让每个进程只存储一个[1.x.214]的三角图。




[1.x.215]

程序的整体结构可以从[2.x.593]函数中推断出来，该函数首先在第一个时间步骤中调用[2.x.594]，然后在所有后续时间步骤中调用[2.x.595]。这些函数之间的区别仅仅在于，在第一个时间步骤中，我们从一个粗略的网格开始，在其上求解，自适应地细化网格，然后在新的网格上以干净的状态重新开始。这个过程给了我们一个更好的起始网格，尽管我们当然应该在迭代过程中不断调整网格--这个程序中没有这样做，但是下面会有评论。

这两个处理时间步骤的函数的共同部分是在本网格上的以下操作序列。  [2.x.596] [2.x.597] [2.x.598] ] 。   这第一个函数也是最有趣的一个。它组装了对应于方程[1.x.216]离散化版本的线性系统。这导致了一个系统矩阵[2.x.599]，由每个单元[2.x.600]上的局部贡献组成，其条目为[1.x.217] 。

  在实践中，[2.x.601]是根据公式[1.x.218]使用数值正交计算出来的。

  与正交点[2.x.602]和权重[2.x.603] 。我们之前在步骤8和步骤17中建立了这些贡献，但在这两种情况下，我们都是通过使用等级4张量[2.x.604]的组成知识，以及考虑应变张量的单个元素[2.x.605]，相当笨拙地完成的。这其实并不方便，特别是如果我们想考虑比各向同性的情况更复杂的弹性模型，而[2.x.606]有方便的形式 [2.x.607] 。虽然我们在本程序中没有使用比这更复杂的形式，但我们还是希望以一种容易实现的方式来编写它。因此，很自然地要引入代表等级为2（用于应变和应力）和4（用于应力-应变张量[2.x.608]）的对称张量的类。幸运的是，deal.II提供了这些：[2.x.609]类模板提供了等级[2.x.610]（需要是偶数）和维度[2.x.611]的这类张量的完整实现。

  然后我们需要的是两件事：一种创建应力-应变等级4张量[2.x.612]的方法，以及从形状函数[2.x.613]的梯度在给定单元上的正交点[2.x.614]创建一个等级2的对称张量（应变张量）。在这个例子程序的执行顶部，你会发现这样的函数。第一个，[2.x.615] ，需要两个参数，对应于Lam&eacute; 常数[2.x.616]和[2.x.617]，并返回对应于这些常数的各向同性的应力应变张量（在程序中，我们将选择对应于钢的常数）；用一个计算各向异性的张量的函数来代替这个函数是很简单的，或者考虑到晶体对称性，比如说。第二个，[2.x.618]和指数[2.x.619]和[2.x.620]，返回对称梯度，即应变，对应于形状函数[2.x.621]，在[2.x.622]对象最后被重新初始化的单元上评估。

  鉴于此，[2.x.623]的最内部循环以下列优雅的方式计算对矩阵的局部贡献（变量[2.x.624]，对应于张量[2.x.625]，之前已经用上述第一个函数的结果初始化了）。   [1.x.219]

  值得注意的是这段代码的表现力，并将其与我们在以前的例子中为弹性问题所经历的复杂情况进行比较。公平地说，在写这些以前的例子时，SymmetricTensor类模板还不存在）。为了简单起见，[2.x.626]在这里规定了偶数等级的对称张量之间的（双重求和）积。

  组建本地捐款[1.x.220]

  到[1.x.221]的右手边同样是直接的（注意，我们在这里不考虑任何边界牵引[2.x.627]）。请记住，我们只需要在单元格的正交点上存储旧的应力。在程序中，我们将提供一个变量[2.x.628]，允许访问每个正交点的应力[2.x.629]。有了这个，右手边的代码看起来就像这样，同样相当优雅。   [1.x.222]

  请注意，在乘法[2.x.630]中，我们利用了这样一个事实：对于所选的有限元素，[2.x.632]中只有一个向量分量（即[2.x.631]）是非零的，因此我们也只需要考虑[2.x.633]的一个分量。

  这基本上结束了我们在这个函数中提出的新材料。它后来必须处理边界条件以及悬挂节点约束，但这与我们以前在其他程序中已经要做的事情相类似。

[2.x.634] [2.x.635] ] 。   与前一个函数不同，这个函数其实并不有趣，因为它做的是以前所有教程程序中的类似函数--用CG方法求解线性系统，使用不完整的LU分解作为预处理程序（在%并行情况下，它分别使用每个处理器块的ILU）。它与第17步几乎没有变化。

[2.x.636] [2.x.637] [通过[2.x.638] ] 。基于之前计算的位移场[2.x.639]，我们根据[1.x.223]和[1.x.224]更新所有正交点的应力值，包括坐标系的旋转。

[2.x.640] [2.x.641] ：给定之前计算的解决方案，在这个函数中，我们通过移动每个顶点的位移矢量场来实现网格的变形。

[2.x.642] [2.x.643] : 这个函数只是根据我们上面所说的输出解决方案，也就是说，每个处理器只对自己的那部分域计算输出。除了解决方案，我们还计算了每个单元上所有正交点平均的应力的规范。  [2.x.644]

有了这个代码的一般结构，我们只需要定义我们要解决的情况。在本程序中，我们选择模拟一个垂直圆柱体的准静态变形，其底部边界是固定的，顶部边界以规定的垂直速度被推倒。然而，顶层边界的水平速度没有被指定--我们可以把这种情况想象成一块油性良好的板从顶部推到圆柱体上，圆柱体顶层边界上的点被允许沿着板的表面水平滑动，但被板强迫向下移动。圆柱体的内部和外部边界是自由的，不受任何规定的偏转或牵引的影响。此外，重力作用于身体。

程序文本将揭示更多关于如何实现这种情况，而结果部分将显示这种模拟产生的位移模式。


examples/step-18/doc/results.dox



[1.x.225]


如果使用调试模式，运行该程序需要很长时间；在我的i7台式机上需要大约11分钟。幸运的是，经过优化编译的版本要快得多；在同一台机器上用<tt>make release</tt>命令重新编译后，程序只需要大约1.5分钟，这个时间要合理得多。


如果运行，该程序会打印出以下输出，解释它在这段时间内做了什么。

[1.x.226]

换句话说，它是在12,000个单元和大约52,000个未知数的情况下进行计算。不是很多，但对于一个耦合的三维问题来说，足以让计算机忙上一阵子。在一天结束的时候，这就是我们的输出。

[1.x.227]




如果我们用VisIt或Paraview将这些文件可视化，我们就能看到我们的强制压缩对圆柱体造成的灾难的全貌（图像中的颜色编码了材料中的应力规范）。


<div class="threecolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0002.0000.png" alt="Time = 2" width="400"> </div> <div class="text" align="center"> Time = 2 </div> <div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0005.0000.png" alt="时间=5" width="400"> </div> <div class="text" align="center"> 时间=5 </div> </div> <div class="father"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0007.0000.png" alt="时间=7" width="400"> </div> <div class="text" align="center">时间=7 </div> </div> </div>


<div class="threecolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0008.0000.png" alt="Time = 8" width="400"> </div> <div class="text" align="center"> 时间 = 8 </div> </div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0009.0000.png" alt="时间=9" width="400"> </div> <div class="text" align="center"> 时间=9 </div> </div> <div class="father"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0010.0000.png" alt="Time = 10" width="400"> </div> <div class="text" align="center"> Time = 10 </div> </div> </div>


可以清楚地看到，当我们不断压缩圆柱体时，它开始在完全约束的底面附近弯曲，并在大约8个时间单位后，以方位对称的方式弯曲。


虽然这个结果对于对称几何和加载来说似乎是合理的，但计算是否完全收敛还有待确定。为了确定是否收敛，我们再次运行程序，在开始时再进行一次全局细化，并将时间步长减半。这在单机上会花费很长的时间，所以我们使用了一个合适的工作站，在16个处理器上并行运行。现在输出的开头看起来像这样。

[1.x.228]

考虑到我们是在三维空间中，这是一个相当好的未知数的数量。这个程序的输出是每个时间步骤的16个文件。

[1.x.229]




这里首先是我们计算的网格，以及16个处理器的分区。


<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-000mesh.png" alt="Discretization" width="400"> </div> <div class="text" align="center"> Discretization </div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0002.p.png" alt="Parallel partitioning" width="400"> </div> <div class="text" align="center"> Parallel partitioning</div> </div> </div>


最后，这里是与我们之前展示的更小的顺序情况相同的输出。

<div class="threecolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0002.s.png" alt="Time = 2" width="400"> </div> <div class="text" align="center"> 时间 = 2 </div> </div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0005.s.png" alt="时间=5" width="400"> </div> <div class="text" align="center"> 时间=5 </div> </div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0007.s.png" alt="Time = 7" width="400"> </div> <div class="text" align="center"> Time = 7 </div> </div> </div>


<div class="threecolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0008.s.png" alt="Time = 8" width="400"> </div> <div class="text" align="center"> 时间 = 8 </div> </div> <div class="parent"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0009.s.png" alt="Time = 9" width="400"> </div> <div class="text" align="center"> Time = 9 </div> </div> <div class="father"> <div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0010.s.png" alt="Time = 10" width="400"> </div> <div class="text" align="center"> Time = 10 </div> </div> </div>


和以前一样，我们观察到，在高轴向压缩时，圆柱体开始弯曲，但这一次最终是在自己身上塌陷。与我们的第一次运行相反，在模拟结束时，变形模式变得不对称（中心隆起向侧面偏转）。该模型显然没有规定这一点（我们所有的力和边界偏转都是对称的），但这种效果可能在物理上是正确的：在现实中，身体材料属性的小不均匀性会导致它向一侧弯曲以逃避强制力；在数值模拟中，小的扰动，如数值舍入或迭代求解器对线性系统的不精确求解，也会产生同样的效果。在自适应计算中，另一个典型的不对称来源是每一步只细化一定的单元，这可能导致不对称的网格，即使原来的粗网格是对称的。


如果将其与之前的运行相比较，结果在质和量上都有不同。因此，以前的计算肯定没有收敛，尽管我们不能肯定地说现在的计算有什么问题。我们需要一个更精细的计算来找出答案。然而，这一点可能是没有意义的：详细看一下最后一张图片，很明显，不仅我们选择的线性小变形模型是完全不够的，而且对于一个现实的模拟，我们还需要确保身体在变形过程中不相交（如果我们继续压缩圆柱体，我们会观察到一些自我相交）。如果没有这样的表述，我们就不能指望任何东西都有物理意义，即使它能产生漂亮的图片!




[1.x.230]

这个程序并没有真正解决一个在实践中有很多应用的方程：基于纯弹性规律的准静态材料变形几乎是无聊的。然而，该程序可以作为更有趣的实验的起点，而这确实是编写该程序的最初动机。这里有一些建议，说明这个程序缺少什么，以及它可以在什么方向上进行扩展。

[1.x.231]

最明显的扩展是使用一个更现实的材料模型来处理大规模的静态变形。这方面的自然选择是塑性，其中应力和应变之间的非线性关系取代了方程[1.x.232]。塑性模型的编程通常相当复杂，因为应力-应变关系通常是非平滑的。可以认为材料只能承受一个最大的应力（屈服应力），之后它就会开始&ldquo;流动&rdquo;。这方面的数学描述可以以变分不等式的形式给出，也可以将其视为弹性能量的最小化

[1.x.233]

受制于约束条件

[1.x.234]

对应力的影响。这种扩展使得在每个时间步长中要解决的问题是非线性的，所以我们需要在每个时间步长中的另一个循环。

在不进一步了解这个模型的细节的情况下，我们可以参考Simo和Hughes关于&ldquo;计算非弹性&rdquo;的优秀书籍，以全面了解解决塑性模型的计算策略。另外，在S. Commend, A. Truty, and Th. Zimmermann的文章中，对塑性的算法做了简单而简洁的描述。Zimmermann; [2.x.645] 。




[1.x.235]

我们选择的公式，即对位移矢量的所有分量使用分片（双，三）线性元素，并将应力视为依赖于位移的变量，对于大多数材料是合适的。然而，对于不可压缩或几乎不可压缩的材料，这种所谓的基于位移的公式变得不稳定，并表现出虚假的模式。虽然流体通常不是弹性的（在大多数情况下，应力取决于速度梯度，而不是位移梯度，但也有例外，如电流变流体），但也有少数固体是几乎不可压缩的，如橡胶。另一种情况是，许多塑性模型最终让材料变得不可压缩，尽管这不在本方案的范围之内。

不可压缩性是由泊松比来表征的

[1.x.236]

其中[2.x.646]是材料的Lam&eacute; 常数。物理约束表明[2.x.647]（该条件也来自于数学稳定性考虑）。如果[2.x.648]接近[2.x.649]，则材料变得不可压缩。在这种情况下，纯粹的基于位移的公式不再适合于解决这类问题，必须采用稳定化技术以获得稳定和准确的解决方案。上面引用的书和论文给出了如何做到这一点的指示，但在这个问题上也有大量的文献；在H.-Y. Duan和Q. Lin的论文的参考文献中可以找到一个获得该主题概述的良好开端。H.-Y. Duan and Q. Lin; [2.x.650] 。




[1.x.237]

在目前的形式下，程序只对初始网格进行若干次细化，然后就不再进行细化。对于任何一种现实的模拟，我们都希望将其扩展到每隔几步就对网格进行细化和粗化。事实上，这并不难做到，但如果你愿意的话，可以留待将来的教程程序或作为练习。

我们必须克服的主要复杂问题是，我们必须将存储在旧网格单元的正交点中的数据转移到新网格中，最好是通过某种投影方案。这方面的一般方法是这样的。

- 开始时，数据只在各个单元的正交点上可用，而不是作为一个到处定义的有限元场。

- 所以让我们找到一个[1.x.238]处处定义的有限元场，这样我们以后就可以把它插到新网格的正交点上。一般来说，要找到一个与正交点中的数值完全匹配的连续有限元场是很困难的，因为这些场的自由度数与正交点的数量不匹配，这个全局场的节点值要么是过定的，要么是欠定的。但是找到一个与正交点数值相匹配的不连续场通常不是很困难；例如，如果你有一个QGauss(2)正交公式（即2d中每个单元4个点，3d中8个点），那么就可以使用FE_DGQ(1)类型的有限元，即双/三线性函数，因为这些函数在2d中每个单元有4个自由度，在3d中有8个自由度。

- 有一些函数可以使这种从单个点到全局场的转换更简单。如果你使用QGauss(2)正交公式，下面这段伪代码应该会有所帮助。请注意，下面的投影矩阵的乘法需要一个标量分量的向量，也就是说，我们一次只能将一组标量从正交点转换成自由度，反之亦然。所以我们需要分别存储每个应力分量，这需要[2.x.651]个向量。我们将把这组向量存储在一个二维数组中，以便于用读出应力张量的方式来读出分量。   因此，我们将对每个单元的应力分量进行循环，并将这些值存储在全局历史域中。(前缀[2.x.652]表示我们的工作与正交点中定义的历史变量有关。)   [1.x.239]



- 现在我们有了一个全局场，我们可以像往常一样使用SolutionTransfer类来细化网格并转移history_field向量。这将把所有的东西从旧的网格插值到新的网格。

- 在最后一步，我们必须将数据从现在插值的全局场返回到新网格上的正交点。下面的代码将做到这一点。   [1.x.240]



一旦我们并行运行程序，情况就变得有点复杂了，因为那时每个进程只为它在旧网格上拥有的单元存储这些数据。也就是说，如果你在正交点转移到全局向量之后，使用[2.x.653]的并行向量就可以做到这一点。




[1.x.241]

目前，程序没有尝试确保一个单元在时间步数结束时移动其顶点后，仍然具有有效的几何形状（即它的雅各布行列式是正的，并且在任何地方都远离零的界限）。事实上，设置边界值和强迫项并不难，这样就可以很快得到扭曲和倒置的单元。当然，在某些大变形的情况下，这在有限网格的情况下是不可避免的，但在其他一些情况下，通过适当的网格细化和/或减少时间步长，这应该是可以避免的。这个程序没有做到这一点，但是一个更复杂的版本肯定应该采用某种启发式方法来定义哪些单元的变形量是可以接受的，哪些是不可以的。


examples/step-19/doc/intro.dox



[2.x.655]

[1.x.242]

[2.x.656] deal.II中存在对粒子的支持，这主要是由于Rene Gassmoeller的最初努力。如果你在自己的工作中使用粒子功能，请引用出版物[2.x.657]来确认这项工作。

[1.x.243]

[1.x.244]

一般来说，有限元方法，特别是deal.II，是为了解决偏微分方程而发明的--换句话说，是为了解决[连续体力学](https://en.wikipedia.org/wiki/Continuum_mechanics)问题。另一方面，有时人们想解决的问题是，跟踪单个物体（"粒子"）以及它们的位置如何演变是有用的。如果这只是导致一组常微分方程，例如，如果你想跟踪太阳系中行星随时间变化的位置，那么deal.II显然不是你合适的工具。另一方面，如果这种演变是由于与偏微分方程的解的相互作用，或者有一个网格来确定哪些粒子与其他粒子相互作用（如在[平滑粒子流体力学（SPH）](https://en.wikipedia.org/wiki/Smoothed-particle_hydrodynamics)方法中），那么deal.II对你有支持。

我们在这里要考虑的情况是带电粒子如何在电场中移动。作为动力，我们将考虑[阴极射线]（https://en.wikipedia.org/wiki/Cathode_ray）。由一块被加热的带负电的金属（"阴极"）发出的电子，然后被电场加速到带正电的电极（"阳极"）。阳极通常是环形的，这样大部分电子可以以电子束的形式飞过孔。在过去，它们可能会照亮由[阴极射线管](https://en.wikipedia.org/wiki/Cathode-ray_tube)制成的电视的屏幕。今天，电子束反而在[X射线机](https://en.wikipedia.org/wiki/X-ray_tube)、[电子束光刻](https://en.wikipedia.org/wiki/Electron-beam_lithography)、[电子束焊接](https://en.wikipedia.org/wiki/Electron-beam_welding)和其他一些领域发挥了作用。

然后我们要考虑的方程如下。首先，我们需要描述电场。通过注意到电势[2.x.658]满足方程，这是最容易完成的。

[1.x.245]

其中[2.x.659]是真空的介电常数，而[2.x.660]是电荷密度。这是由我们将选择的边界条件所增强的，如下所示。

[1.x.246]

换句话说，我们在两个电极上规定电压[2.x.661]和[2.x.662]，在其他地方规定绝缘（诺伊曼）边界条件。由于粒子的动力学纯粹是由于电场[2.x.663]，我们也可以在两个电极上规定[2.x.664]和[2.x.665]--所有重要的是两个电极的电压差。

考虑到这个电势[2.x.666]和电场[2.x.667]，我们可以用微分方程来描述[2.x.668]这个粒子的轨迹

[1.x.247]

其中[2.x.669]是每个粒子的质量和电荷。在实践中，将其写成位置[2.x.670]和速度[2.x.671]的一阶微分方程系统很方便。

[1.x.248]

我们将用来处理粒子的deal.II类，[2.x.672]以一种方式存储粒子，因此位置[2.x.673]是[2.x.674]数据结构的一部分。它存储的粒子是按它们所在的单元分类的，因此需要知道每个粒子的位置）。另一方面，速度[2.x.675]与[2.x.676]无关，因此我们将把它存储为每个粒子的 "属性"，并在每个时间步长中更新。属性也可以用来存储我们可能关心的关于每个粒子的任何其他数量：它的电荷，或者如果它们大于一个电子，它的颜色、质量、在空间的位置、化学成分等等。

要完成这个模型，还有两件事要讨论。粒子从哪里开始以及电荷密度[2.x.677]是什么。

首先，在历史上，阴极射线使用非常大的电场将电子从金属中拉出来。这只产生一个相对较小的电流。我们可以通过加热阴极来做得更好：在这种情况下，统计学上的一部分电子有足够的热能来离开金属；然后电场只要足够强，就可以把它们从宿主的吸引中拉出来。我们将以下列方式对此进行建模。如果（i）电场指向远离电极，即如果[2.x.678]，其中[2.x.679]是指向域外（进入电极）的面的法向量，以及（ii）电场超过一个阈值[2.x.680]，我们将创建一个新粒子。这肯定不是真正发生的足够精确的模型，但对于我们目前的教程程序来说已经足够好了。

第二，原则上我们必须通过以下方式建立电荷密度模型

[1.x.249]



[2.x.681]现在的问题是，在现实中，一台老式电视中的阴极射线管产生的电流大约为几毫安培。在粒子加速器的更高能量的光束中，电流可能只有几纳安培。但一个安培是每秒流动的[2.x.682]个电子。现在，正如你将在结果部分看到的，我们实际上只模拟了几微秒（[2.x.683]秒），但这仍然导致非常非常多的电子 -- 远远超过我们希望用像目前这样小的程序来模拟。因此，让我们假设每个粒子代表[2.x.684]个电子。那么粒子的质量和电荷也是[2.x.685]和[2.x.686]，我们要解决的方程式是

[1.x.250]

当然，这与上述情况完全相同。另一方面，这些电子 "团块 "的电荷密度由以下公式给出

[1.x.251]

我们将在程序中实现这种形式，其中[2.x.687]在程序中被选得相当大，以确保粒子实际影响电场。这在实践中可能并不现实。在大多数情况下，没有足够的电子来实际影响整个电场。但现实主义不是我们的目标）。)




[2.x.688] 人们可能会问，为什么电场（或者说，电势）的方程没有时间导数，而电子位置的方程却有。从本质上讲，这是一个建模假设。我们假设粒子移动得很慢，以至于在任何时候电场都处于平衡状态。这就是说，换句话说，电子的速度远远小于光速。换句话说，我们可以用电极电压来重新表述 [2.x.689] ：由于每伏特的电动势都会使电子加速约600公里/秒（忽略相对论效应），要求 [2.x.690] 等于说 [2.x.691] 。在这个假设下（以及电子总数很小的假设），我们也可以忽略移动电荷产生的磁场，否则也会影响电子的运动。




[1.x.252]

上面概述的方程形成了一组耦合微分方程。让我们再次把它们集中在一起，以明确这一点。

[1.x.253]

由于电势对粒子位置的依赖性很强，我们不想将其作为一个耦合系统来求解，而是采用一种解耦的方法，首先求解每个时间步长的电势，然后再求解粒子的位置。这与我们在第21步、第31步和第32步（仅举几例）所做的工作的精神是一样的，都可以在第58步讨论的算子分割方法的背景下加以理解。

因此，如果我们用大指数[2.x.692]表示时间步长，并且如果我们对ODE使用简单的时间离散化，那么这意味着我们必须在每个时间步长中解决以下方程组。

[1.x.254]

当然还有许多更好的方法来做时间离散化（例如简单的[跃迁方案](https://en.wikipedia.org/wiki/Leapfrog_integration)），但这不是本教程程序的重点，因此我们将满足于这里的内容。不过，我们将在本程序的[1.x.255]部分对这个难题的一个部分进行评论）。

还有一个问题是我们应该如何选择时间步长 [2.x.693] 。这里的限制是，[2.x.694]类需要跟踪每个粒子在哪个单元中。如果我们平行运行计算（比如，在step-70中），这尤其是一个问题，因为在这种情况下，每个进程只存储它拥有的那些单元，再加上一层 "幽灵单元"。这在这里并不重要，但一般来说，我们应该确保在每个时间步长中，一个粒子只从一个单元移动到它的任何一个近邻（面、边或顶点的邻居）。如果我们能确保这一点，那么[2.x.695]就能保证能够找出粒子最后在哪个单元。为了做到这一点，一个有用的经验法则是，我们应该选择时间步长，使所有粒子的预期移动距离小于一个细胞的直径。

[1.x.256]

或等价的

[1.x.257]

这里，[2.x.696]是粒子[2.x.697]所在的单元格最短边的长度--本质上是对单元格大小的衡量。

另一方面，一个粒子可能已经在一个单元的边界上，而邻近的单元可能已经进一步细化。因此，那么穿过那个*邻近*单元的时间实际上将是上述数量的一半，这表明

[1.x.258]



但即使这样也是不够的。上面的公式在每次更新粒子位置时使用的是

[1.x.259]

也就是说，使用当前的*速度[2.x.698]。但是当我们需要选择[2.x.699]时，我们还没有当前的速度 -- 也就是在我们更新了潜能[2.x.700]之后，但在我们将速度从[2.x.701]更新到[2.x.702]之前。我们有的只是 [2.x.703] 。所以我们需要一个额外的安全系数来实现我们的最终选择。

[1.x.260]

[2.x.704]应该有多大？这取决于与[2.x.706]相比，[2.x.705]可能被低估了多少，而这实际上是很容易评估的。如果沿途遇到的电场大致恒定，那么在一个时间步长中产生的速度为零的粒子，在每个连续的时间步长中大致会获得相等的速度增量。因此，[2.x.707]和[2.x.708]之间的最大差异将是一个系数。因此，我们将选择[2.x.709] 。

我们应该考虑的只有另外一种情况。在第一个时间步骤中会发生什么？在那里，任何要被移动的粒子刚刚被创造出来，但它们的速度是零。所以我们不知道我们应该为它们选择什么速度。当然，在所有其他时间步骤中，也有刚刚被创造出来的粒子，但一般来说，具有最高速度的粒子限制了时间步骤的大小，因此新创造出来的具有零速度的粒子并不重要。但是如果我们**只有这样的粒子？

在这种情况下，我们可以使用以下近似值。如果一个粒子从[2.x.710]开始，那么更新公式告诉我们

[1.x.261]

因此

[1.x.262]

我们可以把它写成

[1.x.263]

不想让一个粒子移动超过[2.x.711]，那么就意味着我们应该选择时间步长为

[1.x.264]

使用关于相邻单元可能小2倍的相同论点，然后得出时间步长为0的最终公式。

[1.x.265]



严格来说，我们必须在每个粒子的位置评估电势[2.x.712]，但一个足够好的近似值是使用各自单元顶点的最大值。为什么是顶点而不是中点？因为拉普拉斯方程的解的梯度，即电场，在位于单元顶点的角落奇点上是最大的）。)这样做的好处是，我们可以很好地利用FEValues功能，只要各单元的正交点相同，就可以循环使用预计算的材料。

我们总是可以运行这种方案来估计[2.x.713]和[2.x.714]之间的差异，但它依赖于评估每个单元的电场[2.x.715]，这很昂贵。因此，我们将把这种方法限制在第一个时间步骤上。




[1.x.266]

在讨论了时间离散化之后，对空间离散化的讨论将很简短：我们使用二次有限元，即空间[2.x.716] ，来近似计算电动势[2.x.717] 。在初始时间步骤中，网格被调整了几次。如果你读过第6步，所有这些都是完全标准的，而且实现起来也没有规定任何形式的惊喜。




[1.x.267]

实际上，在deal.II中，添加和移动粒子并不十分困难。要添加一个粒子，本程序的`create_particles()`函数只需使用以下形式的代码片段。

[1.x.268]

换句话说，它与在[2.x.718]或[2.x.719]中插入一个对象没有什么不同。 创建对象，设置其属性（这里是当前位置、其参考单元位置和其id）并调用`insert_particle`。唯一可能令人惊讶的是参考位置。为了评估诸如 [2.x.720] 的东西，有必要在位置 [2.x.721] 评估有限元场。但这需要在参考单元[2.x.722]上的点评估有限元形状函数。为了使之有效，每个粒子不仅要存储它的位置和它所在的单元，还要存储该点在单元参考坐标系中对应的位置。

这样，更新粒子的位置就不再困难了。我们只需要调用

[1.x.269]

我们在`move_particles()`函数中这样做。唯一的区别是，我们必须告诉[2.x.723]类也要找到该位置所对应的单元（而且，在并行计算时，哪个进程拥有该单元）。出于效率的考虑，这在更新所有粒子的位置后最容易完成，并通过[2.x.724]函数实现。

当然，有些时候，粒子可能会离开有关的域。在这种情况下，[2.x.725]不能找到周围的单元，而只是简单地删除该粒子。但是，跟踪以这种方式丢失的粒子的数量往往是有用的，为此，[2.x.726]类提供了一个可以附加的 "信号"。我们在主类的构造函数中展示了如何做到这一点，以计算每个时间步骤中损失了多少粒子。具体来说，这种工作方式是，[2.x.727]类有一个 "信号"，人们可以附加一个函数，只要信号被触发就会执行。在这里，这看起来如下。

[1.x.270]

这有点拗口，但实际情况是这样的。我们声明了一个 "捕获"`this`指针的lambda函数（这样我们就可以在lambda函数中访问周围对象的成员函数），它需要两个参数。

- 指的是已经 "丢失 "的粒子。

- 它最后所在的单元格的引用。这个lambda函数然后简单地用这些参数调用[2.x.728]函数。当我们把这个lambda函数附加到信号上时，[2.x.729]函数将为每个找不到新家的粒子触发信号。这让我们有机会记录下粒子的位置，并记录下关于它的统计数据。




[2.x.730] 在这个教程程序中，我们通过手工插入粒子，并在我们根据包括静电问题的解决的条件专门选择的位置插入粒子。但在其他情况下，人们主要希望将粒子作为被动对象使用，例如，追踪和可视化流体流动问题的流场。在这些情况下，[2.x.731]命名空间中有许多函数可以自动生成粒子。例如，这个命名空间中的一个函数也被用于step-70教程程序中。




[1.x.271]

这里的测试案例并不意味着是对阴极射线管的真实描述，但它具有正确的一般特征，而且在任何情况下，重点只是演示如何实现使用粒子的deal.II代码。

下图显示了我们要使用的几何图形。

<p align="center"> <img src="https://www.dealii.org/images/steps/developer/step-19.geometry.png" alt="本程序中使用的几何图形" width="600"> [2.x.732]

在这幅图中，边界上用红色和蓝色标记的部分是阴极，保持在一个电动势[2.x.733]。阴极的红色部分是被加热的部分，导致电子离开金属，然后被电场加速（也显示了一些电场线）。边界的绿色部分是阳极，保持在[2.x.734]。边界的其余部分满足诺伊曼边界条件。

这种设置模仿了真实的设备。重心角导致电势[2.x.735]，其导数（电场[2.x.736]）有一个奇点--换句话说，它在角的附近变得非常大，允许它把电子从金属中扯出来。这些电子然后被加速推向（绿色）阳极，阳极中间有一个孔，电子可以通过这个孔逃离设备并飞到屏幕上，在那里它们激发 "荧光粉"，然后发出我们从这些老式电视屏幕上看到的光。阴极的非加热部分不受电子发射的影响--在代码中，我们将其标记为电子管的 "聚焦元件"，因为它的负电压会排斥电子，并确保它们不只是垂直于边界从阴极的加热部分飞走，而是事实上将它们的路径弯曲到右边的阳极。

图中的电场线也说明了电场分别连接着负极和正极。电子经历的加速力是沿着这些场线的。最后，图片显示了计算中使用的网格，说明在重租角的顶端以及边界条件改变的所有地方都有奇异点；这些奇异点是可见的，因为网格在这些地方被细化。

实际的利益是要弄清楚从阴极发射的电子中有哪一部分真正通过了阳极上的孔--那些只是反弹到阳极本身的电子除了将电转化为热之外，实际上并没有什么用处。因此，在`track_lost_particle()`函数中（为每个离开域的粒子调用，见上文），我们将估计它可能离开域的位置并在输出中报告。




[2.x.737]值得重申的是，这里使用的几何图形，以及事实上这个程序的任何其他方面，都不是为了代表任何半点现实的东西。教程是我们教授deal.II如何工作的工具，我们经常使用我们有某种直觉的情况，因为这有助于我们解释程序的输出，但这就是我们打算让程序除了作为教学工具之外做任何有用的事情的程度。


examples/step-19/doc/results.dox



[1.x.272]

当这个程序运行时，它产生的输出看起来如下。``时间步数1 场自由度：4989 仿真中的粒子总数：20 这个时间步数损失的粒子数：0

  现在在t=2.12647e-07，dt=2.12647e-07。

时间步数2 场自由度：4989 仿真中的粒子总数：24 本时间步数损失的粒子数：0

  现在在t=4.14362e-07，dt=2.01715e-07。

时间步数3 场自由度：4989 仿真中的粒子总数：28 本时间步数损失的粒子数：0

  现在在t=5.96019e-07，dt=1.81657e-07。

时间步数4 场自由度：4989 仿真中的粒子总数。  32 这个时间步长损失的粒子数：0

  现在在t=7.42634e-07，dt=1.46614e-07。


...


  时间步数1000场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：6 通过阳极损失的粒子的比例。0.0601266

  现在在t=4.93276e-05，dt=4.87463e-08。

时间步数1001场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：0 通过阳极损失的粒子的分数。0.0601266

  现在在t=4.93759e-05，dt=4.82873e-08。


...


时间步数2091场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：0 通过阳极损失的粒子的比例。0.0503338

  现在在t=9.99237e-05，dt=4.26254e-08。

时间步数2092场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：0 通过阳极损失的粒子的分数。0.0503338

  现在在t=9.99661e-05，dt=4.24442e-08。

时间步数2093场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：2 通过阳极损失的粒子的比例。0.050308

  现在在t=0.0001，dt=3.38577e-08。```

随机选取几个时间步长，我们可以用电场的流线和电子的点的形式来可视化解决方案。<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-19.solution.0000.png" alt="时间步骤0（t=0秒）的解决方案。" width="500"> [2.x.738] 时间步骤0（t=0秒）的解决方案。      [2.x.739] </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-19.solution.1400.png" alt="时间步骤1400（t=0.000068秒）的解决方案。" width="500"> [2.x.740] 时间步骤1400（t=0.000068秒）的解决方案。      [2.x.741] </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-19.solution.0700.png" alt="时间步骤700（t=0.000035秒）的解决方案。" width="500"> [2.x.742] 在时间步骤700（t=0.000035秒）的解决方案。      [2.x.743] </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-19.solution.2092.png" alt="时间步骤2092（t=0.0001秒）的解决方案。" width="500"> [2.x.744] 时间步骤2092（t=0.0001秒）的解决方案。      [2.x.745] </div> </div>

也就是说，更合适的方式是通过创建一个视频，展示这些电子是如何运动的，以及电场是如何随着它们的运动而变化的，从而将这个程序的结果可视化。

[1.x.273]



在这里你可以看到边界的 "焦点元素 "是如何用其负电压排斥电子，并确保它们不会垂直于阴极飞走（就像它们在其轨迹的初始部分那样）。它还显示了电场线如何随着时间的推移而移动，以回应飞过的电荷--换句话说，粒子对电场的反馈，而电场本身驱动着电子的运动。

这部电影表明，电子是以 "成串 "或 "爆裂 "的方式移动的。这种表象的一个因素是电影是如何创建的，是一个伪影。电影的每一帧都对应着一个时间步长，但时间步长是不同的。更具体地说，穿过最小单元的最快粒子决定了时间步长（见介绍中的讨论），因此，每当一个（快速）粒子穿过域的右边缘的小单元时，时间步长都很小；一旦粒子离开域，时间步长又会变长。通过绘制屏幕输出中显示的时间步长，可以很容易地看到这种减速-加速的效果。

然而，这其中的第二部分是真实的。模拟在开始时创造了一大群粒子，而在大约第300个时间步长后，粒子数量就减少了。这可能是因为模拟中的粒子带有负电荷。它们降低了（同样带负电的电极）的电场强度，因此减少了阴极上的点的数量，在这些点上，电场强度超过了将电子从电极中吸引出来所需的阈值。


[1.x.274]

[1.x.275]

[1.x.276]

`assemble_system()`、`move_particles()`和`update_timestep_size()`函数都调用[2.x.746]和[2.x.747]，查询位于当前单元上的粒子信息。虽然这很方便，但也很低效。为了理解为什么会这样，我们需要知道粒子是如何存储在[2.x.748]中的，即在一个数据结构中，粒子是以某种线性方式按它们所在的单元进行排序的。因此，为了找到与给定单元相关的粒子，这些函数需要搜索给定单元上的第一个（也可能是最后一个）粒子--这种努力需要花费[2.x.749]次操作，其中[2.x.750]是粒子的数量。但这是在每个单元上重复的；假设对于大型计算来说，单元和粒子的数量大致成正比，那么这些函数调用的累积成本是[2.x.751]，因此大于我们应该对程序的所有部分进行的[2.x.752]成本。

不过，我们可以使之更便宜。首先，我们可以先调用[2.x.753]而不是[2.x.754]，然后通过计算当前单元上的最后一个粒子到第一个粒子的距离来计算单元上的粒子数。

[1.x.277]

其中第一个调用当然还是[2.x.755]，但至少第二个调用只需要与当前单元上的粒子数成比例的计算时间，因此，当累积到所有单元时，其成本为[2.x.756]。

但我们甚至可以通过一些适当的算法设计来摆脱这些调用中的第一个。这是因为粒子的排列方式与单元格相同，因此我们可以在单元格上移动时直接走动它们。下面的算法纲要就是这样做的。

[1.x.278]



在这段代码中，我们对每个单元都精确地接触了一次，而且我们从来不需要在大数据结构中搜索每个单元上的第一个或最后一个粒子。因此，该算法总共花费了[2.x.757]来完成对所有粒子和所有单元的扫瞄。

对这个程序中存在这个问题的所有三个函数实施这个方案并不十分困难。




[1.x.279]

该程序已经计算出了通过阳极上的孔离开该领域的电子的比例。但人们可能还对其他数量感兴趣。例如，这些粒子的平均速度。从每个粒子的属性中获得其速度并不是很困难，就像我们在`move_particles()`函数中所做的那样，并从中计算出统计数据。




[1.x.280]

如上所述，视频的不同帧之间有不同的时间差，因为我们为每个时间步长创建输出。一个更好的创建电影的方法是在固定的时间间隔内生成一个新的输出文件，不管每个这样的点之间有多少时间步长。




[1.x.281]

我们在这个程序中考虑的问题是一个耦合的、多物理学的问题。但是我们解决它的方法是首先计算（电）势场，然后更新粒子位置。这就是所谓的 "算子分割法"，我们将在第58步中更详细地研究这一概念。

虽然要想出一个不涉及将问题分割成PDE部分和粒子部分的方法是很尴尬的，但人们*可以*（而且可能应该！）想出一个更好的方法来更新粒子的位置。具体来说，我们用来更新粒子位置的方程是

[1.x.282]

这相当于一个简单的正向欧拉时间离散化--一种在时间步长上具有一阶精度的方法[2.x.758]，我们知道我们应该避免，因为我们可以做得更好。相反，我们可能想考虑一种方案，如[跃迁方案](https://en.wikipedia.org/wiki/Leapfrog_integration)或更普遍的[折衷积分器](https://en.wikipedia.org/wiki/Symplectic_integrator)，如[Verlet方案](https://en.wikipedia.org/wiki/Verlet_integration)。




[1.x.283]

在写这篇文章时，在作者的一台笔记本电脑上，在发布模式下，该程序的运行时间约为3.5分钟。这是可以接受的。但是，如果我们想让模拟变成三维的呢？如果我们想在任何时候都不使用最多约100个粒子（如这里使用的参数），而是使用100,000个？如果我们需要一个更细的网格？

在这些情况下，人们不只是想在单个处理器上运行程序，实际上是在尽可能多的处理器上运行。这就要求对PDE的解决方案以及粒子进行并行化。在实践中，虽然有大量的挑战要使其高效和良好地扩展，但这些挑战都在deal.II本身中得到了解决。例如，第40步显示了如何将有限元部分并行化，第70步显示了如何将粒子部分也并行化。


examples/step-2/doc/intro.dox

[1.x.284]

[1.x.285]

[2.x.759]

在前面的例子中，我们已经创建了一个网格，现在我们展示如何在这个网格上定义自由度。在这个例子中，我们将使用最低阶（[2.x.760]）的有限元，自由度与网格的顶点相关联。以后的例子将展示更高阶的元素，自由度不一定与顶点相关，但可以与边、面或单元相关。

术语 "自由度 "在有限元界通常用来表示两个略有不同但相关的事情。首先是我们希望将有限元解表示为形状函数的线性组合，形式为[2.x.761] 。这里，[2.x.762]是一个膨胀系数的向量。因为我们还不知道它们的值（我们将计算它们作为线性或非线性系统的解），它们被称为 "未知数 "或 "自由度"。该术语的第二个含义可以解释如下。对有限元问题的数学描述通常是说，我们正在寻找一个满足某些方程组的有限维函数[2.x.763]（例如，[2.x.764]为所有测试函数[2.x.765]）。换句话说，我们在这里说的是，解决方案需要位于某个空间 [2.x.766] 中。然而，为了在计算机上实际解决这个问题，我们需要选择这个空间的一个基；这就是我们在上面用系数[2.x.769]对[2.x.768]进行展开的形状函数[2.x.767]的集合。当然，空间[2.x.770]的基数有很多，但我们将特别选择由传统上在网格单元上局部定义的有限元函数描述的基数。在这种情况下描述 "自由度 "需要我们简单地 [1.x.286] 空间的基函数 [2.x.771] 。对于[2.x.772]元素，这意味着简单地以某种方式列举网格的顶点，但对于高阶元素，还必须列举与网格的边、面或单元内部相关的形状函数。换句话说，自由度的枚举是完全独立于我们用于顶点的索引的。提供这种列举[2.x.773]的基础函数的类被称为DoFHandler。

在网格上定义自由度（简称 "DoF"）是一个相当简单的任务，因为这个库为你做了所有的工作。基本上，你所要做的就是创建一个有限元对象（从deal.II已有的众多有限元类中选取，例如参见[2.x.774]文档），并通过[2.x.775]函数将其交给DoFHandler对象（"分配DoF "是我们用来描述上文讨论的[1.x.287]基函数过程的术语）。DoFHandler是一个知道哪些自由度住在哪里的类，也就是说，它可以回答 "全局有多少自由度 "和 "在这个单元上，给我住在这里的形状函数的全局索引 "这样的问题。当你决定你的系统矩阵应该有多大时，以及当把单个单元的贡献复制到全局矩阵时，你需要这种信息。

[1.x.288]

然后，下一步将是利用这个有限元和网格计算与特定微分方程对应的矩阵和右手。我们将为第三步程序保留这一步骤，而是谈论有限元程序的一个实际问题，即有限元矩阵总是非常稀疏的：这些矩阵中的几乎所有条目都是零。

更准确地说，如果一个矩阵中的非零项[1.x.289]的数量与整个自由度的数量无关，我们就说该矩阵是稀疏的。例如，拉普拉斯方程的有限差分近似的简单5点模版导致了一个稀疏矩阵，因为每行的非零条目数是5，因此与矩阵的总大小无关。对于更复杂的问题--比如说步骤22的斯托克斯问题--特别是在三维中，每行的条目数可能是几百个。但重要的一点是，这个数字与问题的总体大小无关：如果你细化网格，每行未知数的最大数量保持不变。

与使用泰勒扩展和匹配系数来逼近偏微分方程的解，或使用傅里叶基相比，稀疏性是有限元方法的一个突出特点。

在实践中，正是由于矩阵的稀疏性，使我们能够解决有数百万或数十亿未知数的问题。为了理解这一点，请注意，一个有[2.x.776]行的矩阵，每个非零项的数量都有固定的上限，需要[2.x.777]个内存位置来存储，而矩阵-向量乘法也只需要[2.x.778]次操作。因此，如果我们有一个线性求解器，只需要固定数量的矩阵向量乘法就能得出这个矩阵的线性系统的解，那么我们就会有一个能以最佳复杂度找到所有[2.x.779]未知数的值的求解器，也就是说，总共只需要[2.x.780]次操作。很明显，如果矩阵不是稀疏的，这是不可能的（因为那样的话，矩阵中的条目数必须是[2.x.781]与一些[2.x.782]，做固定数量的矩阵-向量乘积将需要[2.x.783]次操作），但这也需要非常专业的求解器，如多网格方法，以满足求解只需要固定数量的矩阵-向量乘法的要求。我们将在本教程的剩余程序中经常研究使用什么求解器的问题。

稀疏性是由以下事实产生的：有限元形状函数是在单个单元上定义的[1.x.290]，而不是全局的，并且双线性形式中的局部微分算子只对支持度重叠的形状函数进行耦合。一个函数的 "支持 "是指它的非零区域。对于有限元方法，形状函数的支持通常是指与它所定义的顶点、边或面相邻的单元。)换句话说，自由度[2.x.784]和[2.x.785]如果不是定义在同一个单元上，就不会重叠，因此，矩阵条目[2.x.786]将为零。  (在某些情况下，如非连续加尔金法，形状函数也可以通过面积分连接到相邻的单元。但是有限元方法一般不会将形状函数与定义了该函数的单元的近邻相联系）。)




[1.x.291]

默认情况下，DoFHandler类以一种相当随机的方式枚举网格上的自由度；因此，稀疏度模式也没有为任何特定的目的进行优化。为了说明这一点，下面的代码将演示一个简单的方法来输出对应于DoFHandler的 "稀疏模式"，即一个对象代表了在网格上离散偏微分方程时可能建立的矩阵的所有潜在非零元素及其DoFHandler。这种缺乏结构的疏散模式将从我们下面展示的图片中显现出来。

对于大多数应用和算法来说，自由度的确切编号方式并不重要。例如，我们用来解决线性系统的共轭梯度方法并不关心。另一方面，有些算法确实关心：特别是一些预处理程序，如SSOR，如果它们能以特定的顺序走过自由度，就能更好地工作，如果我们能以这样的方式排序，使SSOR能以这样的顺序从零到[2.x.787]迭代它们，那就太好了。其他的例子包括计算不完整的LU或Cholesky分解，或者如果我们关心矩阵的块状结构（见步骤20的例子）。因此，deal.II在命名空间DoFRenumbering中有一些算法可以以特定的方式重新列举自由度。重新编号可以被认为是选择了一个不同的、经排列的有限元空间的基础。因此，这种重新编号所产生的稀疏模式和矩阵与我们没有明确的重新编号所得到的相比，也只是行和列的排列组合。

在下面的程序中，我们将使用Cuthill和McKee的算法来完成。我们将在[1.x.292]中展示原始自由度列举和下面重新编号的版本的稀疏模式。


examples/step-2/doc/results.dox



[1.x.293]

该程序运行后，产生了两个稀疏模式。我们可以通过在网络浏览器中打开[2.x.788]文件来可视化它们。

结果是这样的（每一个点都表示一个可能为非零的条目；当然，这个条目是否真的为零取决于所考虑的方程，但矩阵中的指示位置告诉我们，在离散化局部，即微分方程时，哪些形状函数可以，哪些不可以耦合）。  [2.x.789]

左图中的不同区域，由线条中的扭结和左边和上面的单点表示，代表了三角法不同细化层次上的自由度。  从右图中可以看出，重新编号后，稀疏模式在矩阵的主对角线附近的聚类情况要好得多。虽然这可能不明显，但两张图片中非零项的数量当然是一样的。




[1.x.294]

就像第1步一样，你可能想在程序中玩一下，熟悉一下deal.II。例如，在[2.x.790]函数中，我们使用线性有限元（FE_Q对象的参数 "1 "就是如此）。探索一下如果你使用高阶元素，例如立方或五元元素（使用3和5作为各自的参数），稀疏模式会有什么变化。

你也可以通过细化网格来探索稀疏性模式的变化。你会发现，不仅矩阵的大小会发生变化，其带宽（矩阵中离对角线最远的那些非零元素与对角线的距离）也会发生变化，不过带宽与大小的比例通常会缩小，也就是说，矩阵在对角线周围聚集得更多。

实验的另一个想法是尝试DoFRenumbering命名空间中除Cuthill-McKee之外的其他重新编号策略，看看它们如何影响稀疏性模式。

你也可以使用[1.x.295]（较简单的可视化程序之一；也许不是最容易使用的，因为它是命令行驱动的，但在所有Linux和其他类似Unix的系统上也是普遍可用的）通过改变[2.x.791]来使输出可视化。

[1.x.296]



另一个基于[1.x.297]的做法是尝试打印出带有支撑点位置和编号的网格。为此，你需要包含GridOut和MappingQ1的头文件。这方面的代码是。

[1.x.298]

在我们运行该代码后，我们得到了一个名为gnuplot.gpl的文件。要查看这个文件，我们可以在命令行中运行以下代码。

[1.x.299].有了这个，你会得到一个类似于[2.x.792]的图片，这取决于你正在看的网格。更多信息，见[2.x.793]。


examples/step-20/doc/intro.dox

[1.x.300]

[1.x.301]

[2.x.794]

这个程序致力于两个方面：使用混合有限元--特别是Raviart-Thomas元--以及使用块状矩阵来定义求解器、预处理器和使用系统矩阵的子结构的嵌套版本。我们要解决的方程仍然是泊松方程，虽然有一个矩阵值的系数。

[1.x.302]

[2.x.795]被假定为均匀正定，即有[2.x.796]，使得[2.x.798]的特征值[2.x.797]满足[2.x.799] 。使用符号[2.x.800]而不是通常的[2.x.801]作为解变量将在下一节中变得清晰。

在讨论了方程和我们要用来解决它的公式之后，这个介绍将包括块状矩阵和向量的使用，求解器和预处理器的定义，以及最后我们要解决的实际测试案例。

我们将在第21步中扩展这个教程程序，不仅要解决混合拉普拉斯方程，还要增加另一个描述两种流体混合物运输的方程。

这里所涉及的方程属于矢量值问题的范畴。这个主题的顶层概述可以在[2.x.802]模块中找到。




[1.x.303]

在上述形式中，泊松方程（即具有非零右手边的拉普拉斯方程）通常被认为是流体在多孔介质中流动的良好模型方程。当然，人们通常通过[1.x.304]来模拟流体流动，或者，如果流体速度很慢或粘度很大，则通过[1.x.305]（我们在步骤22中涉及）。在这两个模型中，第一个模型的作用力是惯性和粘性摩擦力，而在第二个模型中，只有粘性摩擦力--即一个流体粒子对附近的粒子施加的力。如果你在一个大的领域里有自由流动，例如管道、河流或空气中，这是很合适的。另一方面，如果流体被限制在孔隙中，那么孔壁对流体施加的摩擦力变得越来越重要，而内部粘性摩擦力变得越来越不重要。如果这两种效应都很重要，那么建立模型首先会导致[1.x.306]，而在非常小的孔隙的限制下会导致[1.x.307]。后者只是泊松方程或拉普拉斯方程的不同名称，其内涵是人们想应用它的领域：多孔介质中的缓慢流动。本质上，它说速度与驱动流体通过多孔介质的负压梯度成正比。

达西方程对驱动流动的这种压力进行建模。由于解变量是压力，我们在这里使用[2.x.803]这个名字，而不是更常用于偏微分方程解的[2.x.804]这个名字）。这种拉普拉斯方程观点的典型应用是为地下水流建模，或者为油藏中的碳氢化合物流动建模。在这些应用中，[2.x.805]是渗透性张量，即衡量土壤或岩石基质对流体流动的阻力大小。

在上述应用中，数值方案的一个理想特征是它应该是局部保守的，也就是说，无论什么东西流入一个单元，也会从该单元流出（或者如果源不为零，则差值等于每个单元的源项的积分）。然而，事实证明，拉普拉斯方程的通常离散化（如步骤3、步骤4或步骤6中使用的那些）并不满足这一特性。但是，人们可以通过选择问题的不同表述和有限元空间的特定组合来实现这一点。




[1.x.308]

为此，我们首先引入了第二个变量，称为速度， [2.x.806] 。根据其定义，速度是压力梯度的负方向的一个矢量，乘以渗透性张量。如果渗透率张量与单位矩阵成正比，这个方程就很容易理解和直观：渗透率越高，速度越高；速度与压力梯度成正比，从高压区到低压区（因此是负号）。

有了这第二个变量，就可以找到拉普拉斯方程的另一个版本，称为[1.x.309]。

[1.x.310]

这里，我们将定义速度的方程[2.x.807]乘以[2.x.808]，因为这使得方程组是对称的：其中一个方程有梯度，第二个方程有负发散，这两个当然是彼此相邻的，结果是一个对称的双线性形式，因此在[2.x.809]是对称张量的共同假设下，是一个对称的系统矩阵。

这个问题的弱表述是通过将两个方程与测试函数相乘，并对一些项进行分项积分来找到的。

[1.x.311]

其中

[1.x.312]

这里，[2.x.810]是边界处的外向法向量。请注意，在这个公式中，原问题的迪里希特边界值被纳入到弱形式中。

为了得到良好的解决，我们必须在空间[2.x.811]中寻找[2.x.812]、[2.x.813]和[2.x.814]的解和检验函数。几乎每一本关于有限元理论的书都说过一个众所周知的事实，如果选择离散的有限元空间来逼近[2.x.816]是不恰当的，那么产生的离散问题是不稳定的，离散的解将不会收敛到精确的解。这里考虑的问题的一些细节--属于 "鞍点问题 "的范畴

--可以在维基百科上找到[1.x.313]的页面）。)

为了克服这个问题，已经为[2.x.817]开发了一些不同的有限元对，导致了稳定的离散问题。其中一个对子是对速度[2.x.819]使用Raviart-Thomas空间，对压力[2.x.821]使用类[2.x.820]的不连续元素。关于这些空间的细节，我们特别参考Brezzi和Fortin的关于混合有限元方法的书，但许多其他关于有限元理论的书，例如Brenner和Scott的经典书，也说明了相关结果。在任何情况下，在适当选择函数空间的情况下，离散的表述如下。找到[2.x.822]，以便

[1.x.314]




在继续之前，让我们简单地停顿一下，说明上面的函数空间的选择为我们提供了所需的局部守恒特性。特别是，由于压力空间由不连续的片断多项式组成，我们可以选择测试函数[2.x.823]作为在任何给定单元[2.x.824]上等于1，其他地方为0的函数。如果我们也到处选择[2.x.825]（记住，上面的弱式对[1.x.315]离散测试函数[2.x.826]必须成立），那么把这些测试函数的选择放入上面的弱式中，特别意味着

[1.x.316]

当然，我们可以将其以更明确的形式写为

[1.x.317]

应用发散定理的结果是，对于每个单元[2.x.827]的选择，[2.x.828]必须满足以下关系

[1.x.318]

如果你现在记得[2.x.829]是速度，那么左边的积分正好是穿过单元格边界的（离散）通量[2.x.830] 。那么声明是，通量必须等于对[2.x.831]内的源的积分。特别是，如果没有源（即[2.x.832]在[2.x.833]中），那么声明是[1.x.319]通量为零，也就是说，任何流入一个单元的东西都必须通过单元边界的其他部分流出。这就是我们所说的[1.x.320]，因为它对每个细胞都是成立的。

另一方面，通常的连续[2.x.834]元素在用于压力时不会产生这种性质（例如，我们在步骤-43中所做的），因为我们不能选择一个离散的测试函数[2.x.835]，在单元[2.x.836]上为1，其他地方为0：它将是不连续的，因此不在有限元空间内。严格来说，我们只能说上面的证明对连续元素不起作用。这些元素是否仍然可能导致局部守恒是一个不同的问题，因为人们可以认为不同的证明可能仍然有效；然而，在现实中，这个属性确实不成立）。)




[1.x.321]

deal.II库（当然）实现了任意阶的Raviart-Thomas元素[2.x.837]，以及不连续元素[2.x.839] 。如果我们暂时忘记它们的特殊属性，那么我们就必须解决一个离散的问题

[1.x.322]

的双线性形式和右手边，以及[2.x.840] , [2.x.841] 。[2.x.842]和[2.x.843]都来自空间[2.x.844]，其中[2.x.845]本身就是一个[2.x.846]维函数的空间，以适应流速为矢量值的事实。那么必要的问题是：我们如何在程序中做到这一点？

矢量值元素已经在以前的教程程序中讨论过了，第一次是在步骤8中详细讨论。那里的主要区别是，矢量值空间[2.x.847]的所有分量都是统一的：位移矢量的[2.x.848]分量都是相等的，来自同一个函数空间。因此，我们可以做的是将[2.x.849]建立为[2.x.850]乘以通常的[2.x.851]有限元空间的外积，并以此确保我们所有的形状函数只有一个非零矢量分量。因此，我们在步骤8中所做的不是处理矢量值的形状函数，而是查看（标量）唯一的非零分量，并使用[2.x.852]调用来计算这实际上是哪个分量。

这对Raviart-Thomas元素不起作用：由于它们的构造满足空间[2.x.853]的某些规则性属性，[2.x.854]的形状函数通常在其所有矢量分量中都是不为零。由于这个原因，如果应用[2.x.855]来确定形状函数[2.x.856]的唯一非零分量，就会产生一个例外。我们真正需要做的是在[2.x.857]中获得一个形状函数的所有[2.x.858]向量分量。在deal.II的字典中，我们称这样的有限元为[2.x.859]非原始[2.x.860]，而那些标量的有限元或者每个矢量值的形状函数只在一个矢量分量中不为零的有限元被称为[2.x.861] 原始[2.x.862]。

那么，对于非原始元素，我们要怎么做呢？为了弄清楚这个问题，让我们回到教程程序中，几乎是最开始的时候。在那里，我们了解到我们使用[2.x.863]类来确定正交点的形状函数的值和梯度。例如，我们会调用 [2.x.864] 来获得 [2.x.865] 第三个形状函数在编号为 [2.x.866] 的正交点的值。后来，在step-8和其他教程程序中，我们了解到这个函数调用也适用于矢量值的形状函数（原始有限元），它返回形状函数 [2.x.867] 在正交点 [2.x.868] 的唯一非零分量的值。

对于非原始形状函数，这显然是行不通的：形状函数[2.x.869]没有单一的非零向量分量，因此调用[2.x.870]也就没有什么意义。然而，deal.II提供了第二个函数调用，[2.x.871]，返回正交点[2.x.872]的值[2.x.873]是一个介于零和当前有限元的矢量分量数量之间的索引；例如，我们将用于描述速度和压力的元素将有[2.x.874]分量。值得注意的是，这个函数调用也可用于原始形状函数：它将简单地对除一个分量外的所有分量返回零；对于非原始形状函数，它一般会对不止一个分量返回非零值。

我们现在可以尝试用矢量分量来重写上面的双线性形式。例如，在2d中，第一项可以这样改写（注意，[2.x.875]）。

[1.x.323]

如果我们实现了这一点，我们会得到这样的代码。

[1.x.324]



这充其量是繁琐的，容易出错的，而且不是独立的维度。有一些明显的方法可以使事情与维度无关，但最终，代码根本不漂亮。如果我们能够简单地提取形状函数[2.x.876]和[2.x.877]的分量，那就更好了。在程序中，我们以如下方式进行。

[1.x.325]



事实上，这不仅是双线性形式的第一项，而且是整个事情（不包括边界贡献）。

这段代码的作用是，给定一个[2.x.879]对象，提取形状函数[2.x.881]在正交点[2.x.882]的第一个[2.x.880]分量的值，也就是该形状函数的速度部分。换句话说，如果我们把形状函数[2.x.883]写成元组[2.x.884]，那么该函数返回这个元组的速度部分。请注意，速度当然是一个[2.x.885]维的张量，函数返回一个相应的对象。同样地，在我们用压力提取器下标的地方，我们提取标量压力分量。整个机制在[2.x.886]模块中有更详细的描述。

在实践中，如果我们在每个最外层的循环中只评估一次形状函数、它们的梯度和发散，并存储结果，我们可以做得更好一些，因为这样可以节省一些重复的计算（通过提前计算所有相关的量，然后只在实际的循环中插入结果，甚至可以节省更多的重复操作，关于这种方法的实现见步骤22）。最后的结果是这样的，在每个空间维度上都是如此。

[1.x.326]



这非常类似于我们最初写下的双线性形式和右手边的形式。

有一个最后的项我们必须注意：右手边包含项[2.x.887]，构成压力边界条件的弱执行。我们已经在步骤7中看到了如何处理面积分：本质上与域积分完全相同，只是我们必须使用FEFaceValues类而不是[2.x.888]。为了计算边界项，我们只需在所有的边界面上进行循环并在那里进行积分。该机制的工作方式与上述相同，即提取器类也对FEFaceValues对象工作。

[1.x.327]



在本程序的源代码中，你会发现与上面完全相同的代码。因此，我们在下文中不做过多评论。




[1.x.328]

在组装好线性系统后，我们就面临着解决它的任务。这里的问题是，矩阵拥有两个不理想的特性。

- 它是[1.x.329]，也就是说，它有正负两个特征值。   我们不想在这里证明这个属性，但要注意，对于所有形式为[2.x.889]的矩阵，如这里的[2.x.890]是正定的矩阵，这都是真的。

- 矩阵的右下方有一个零块（在双线性形式中没有将压力[2.x.891]与压力测试函数[2.x.892]耦合的项）。

至少它是对称的，但是上面的第一个问题仍然意味着共轭梯度法是行不通的，因为它只适用于矩阵是对称和正定的问题。我们将不得不求助于其他迭代求解器，如MinRes、SymmLQ或GMRES，它们可以处理不确定的系统。然而，下一个问题立即浮现。由于零块，对角线上有零，通常的 "简单 "预处理程序（Jacobi、SSOR）都不能工作，因为它们需要除以对角线上的元素。

对于我们期望用这个程序运行的矩阵大小来说，迄今为止最简单的方法是直接使用一个直接求解器（特别是与deal.II捆绑的SparseDirectUMFPACK类）。Step-29走的就是这条路线，它表明只需3、4行代码就可以完成[1.x.330]线性系统的求解。

但是，这是一个教程。我们教的是如何做事情。因此，在下文中，我们将介绍一些可用于类似这种情况的技术。也就是说，我们将考虑线性系统不是由一个大矩阵和向量组成的，而是要将矩阵分解为[1.x.331]，这些矩阵对应于系统中出现的各个运算符。我们注意到，所产生的求解器并不是最优的--有更好的方法来有效地计算该系统，例如在步骤22的结果部分所解释的方法，或者我们在步骤43中用于类似于当前问题的方法。在这里，我们的目标只是介绍新的求解技术以及如何在交易中实现它们。




[1.x.332]

鉴于使用上述标准求解器和预处理器的困难，让我们再看一下矩阵。如果我们对自由度进行排序，使所有的速度变量排在所有的压力变量之前，那么我们可以将线性系统[2.x.893]细分为以下几个块。

[1.x.333]

其中[2.x.894]分别是速度和压力自由度的值，[2.x.895]是速度空间上的质量矩阵，[2.x.896]对应于负发散算子，[2.x.897]是其转置，对应于梯度。

通过区块消除法，我们就可以按以下方式对这个系统重新排序（用系统的第一行乘以[2.x.898]，然后用第二行减去）。

[1.x.334]

这里，矩阵[2.x.899]（称为[2.x.900]的[1.x.335]）显然是对称的，由于[2.x.901]的正定性和[2.x.902]具有全列秩，[2.x.903]也是正定的。

因此，如果我们能计算出[2.x.904]，我们就可以对其应用共轭梯度法。然而，计算[2.x.905]是昂贵的，因为它需要我们计算（可能很大的）矩阵[2.x.906]的逆；而且[2.x.907]实际上也是一个完整的矩阵，因为即使[2.x.908]是稀疏的，它的逆[2.x.909]通常是一个密集的矩阵。另一方面，CG算法并不要求我们真正拥有[2.x.910]的表示：只需与它形成矩阵-向量乘积即可。我们可以利用矩阵乘积是关联的这一事实，分步进行（也就是说，我们可以通过设置括号来使乘积的计算更加方便）。为了计算[2.x.911]，我们<ol> [2.x.912]计算[2.x.913]；[2.x.914]解[2.x.915]为[2.x.916]，使用CG方法应用于正定和对称质量矩阵[2.x.917]；[2.x.918]计算[2.x.919]，得到[2.x.920] 。  [2.x.921] 注意我们如何从右到左评估表达式[2.x.922]以避免矩阵-矩阵乘积；这样，我们所要做的就是评估矩阵-向量乘积。

在下文中，我们将不得不想出表示矩阵[2.x.923]的方法，以便它可以用于共轭梯度求解器，以及定义我们可以预设涉及[2.x.924]的线性系统解决方案的方法，并处理与矩阵[2.x.925]的线性系统求解（上述第二步骤）。

[2.x.926] 这个考虑的关键点是要认识到，为了实现CG或GMRES这样的迭代求解器，我们实际上从来不需要矩阵的实际[1.x.336]!所需要的只是我们能够形成矩阵-向量乘积。对于预处理程序也是如此。在deal.II中，我们对这一要求进行了编码，只要求给予求解器类的矩阵和预处理器有一个[2.x.927]成员函数来做矩阵-向量乘积。一个类如何选择实现这个函数对求解器来说并不重要。因此，类可以通过，例如，做一连串的乘积和线性求解来实现它，正如上面所讨论的。




[1.x.337]

deal.II包括支持以一种非常普遍的方式来描述这种线性操作。这是由LinearOperator类完成的，与[2.x.928]"MatrixType概念 "一样，它定义了[1.x.338]对矢量进行线性操作的最小接口。

[1.x.339]

然而，LinearOperator和普通矩阵的关键区别在于，LinearOperator不允许对底层对象进行任何进一步的访问。你能用LinearOperator做的就是把它的 "动作 "应用到一个向量上。我们借此机会介绍一下LinearOperator的概念，因为它是一个非常有用的工具，可以让你以非常直观的方式构造复杂的求解器和预处理器。

作为第一个例子，让我们构建一个代表 [2.x.929] 的 LinearOperator 对象。这意味着每当这个运算符的[2.x.930]函数被调用时，它必须解决一个线性系统。这就要求我们指定一个解算器（和相应的）前置条件。假设[2.x.931]是对系统矩阵左上块的引用，我们可以写出。

[1.x.340]

我们没有使用SolverControl，而是在这里使用ReductionControl类，当达到绝对公差（我们选择[2.x.932]）或者当残差减少了某个系数（这里是[2.x.933]）时，它就会停止迭代。相反，SolverControl类只检查绝对公差。在我们的案例中，我们必须使用ReductionControl来解决一个小问题。我们将送入[2.x.934]的右手边基本上是由残差形成的，随着外部迭代的进行，残差的规范自然会大大减少。这使得绝对公差的控制非常容易出错。

我们现在有一个LinearOperator [2.x.935]，我们可以用它来构造更复杂的运算符，如Schur补码 [2.x.936] 。假设[2.x.937]是对右上角区块的引用，构造一个LinearOperator [2.x.938]只需两行即可。

[1.x.341]

在这里，三个LinearOperator对象的乘法产生了一个复合对象[2.x.939]，该函数首先应用[2.x.940]，然后是[2.x.941]（即用[2.x.942]解方程），最后是[2.x.943]到任何指定的输入矢量。在这个意义上，[2.x.944]类似于以下代码。

[1.x.342]

( [2.x.945]是两个临时向量)。这种方法背后的关键点是，我们实际上从未创建一个矩阵的内积。相反，每当我们要用[2.x.946]进行矩阵向量乘法时，我们只需按上述顺序运行所有单独的[2.x.947]操作。

[2.x.948]我们可以通过实现一个专门的类[2.x.949]，提供一个合适的[2.x.950]函数，来实现创建一个 "类似矩阵 "的对象的相同目标。跳过一些细节，这可能看起来像下面这样。

[1.x.343]

尽管这两种方法完全等同，但LinearOperator类比这种手工方法有很大的优势。它提供了所谓的［1.x.344］［1.x.345］。在数学上，我们认为[2.x.951]是复合矩阵[2.x.952]，LinearOperator类允许你或多或少地逐字写出这一点。

[1.x.346]

另一方面，人工方法掩盖了这一事实。

现在我们要做的就是形成定义[2.x.953]和[2.x.954]的两个方程的右手边，然后分别用舒尔补码矩阵和质量矩阵来解决它们。例如，第一个方程的右手边为[2.x.955] 。这可以通过以下方式实现。

[1.x.347]

同样，这是一个完全有效的方法，但是deal.II要求我们手动调整最终向量和临时向量的大小，而且每一个操作都要占用一个新的行，这让我们很难阅读。这就是线性运算符框架中的第二个类可以将帮助我们的地方。与LinearOperator的精神类似，一个PackagedOperation存储了一个 "计算"。

[1.x.348]

该类允许[1.x.349]涉及向量和线性运算符的表达式。这是通过存储计算表达式来实现的，只有当对象被转换为向量对象，或者[2.x.956]（或[2.x.957]被手动调用时才执行计算。假设[2.x.958]是右手边的两个向量，我们可以简单地写。

[1.x.350]

这里，[2.x.959]是一个打包操作，[1.x.351]是我们指定的计算。它不会立即创建一个带有实际结果的向量。

有了这些先决条件，解决[2.x.960]和[2.x.961]的问题就是创建另一个解算器和反演。

[1.x.352]



[2.x.962] 我们在这个例子中手工开发的功能在库中已经是现成的。看看schur_complement(), condense_schur_rhs(), and postprocess_schur_solution()。




[1.x.353]

有人可能会问，如果我们有一个Schur补数的预处理程序，是否会有帮助 [2.x.963] 。一般来说，答案是：当然。问题是，我们对这个舒尔补码矩阵一无所知。我们不知道它的条目，我们所知道的只是它的作用。另一方面，我们必须认识到，我们的求解器是昂贵的，因为在每次迭代中，我们必须与舒尔补矩阵做一次矩阵-向量乘积，这意味着我们必须在每次迭代中对质量矩阵做一次反转。

对这样一个矩阵的预处理有不同的方法。一个极端是使用便宜的东西，因此对每次迭代的工作没有实际影响。另一个极端是使用本身非常昂贵的预处理程序，但作为回报，它确实降低了用[2.x.964]求解所需的迭代次数。

我们将按照第二种方法进行尝试，既是为了提高程序的性能，也是为了展示一些技术。为此，让我们回顾一下，理想的预处理程序当然是[2.x.965]，但这是无法实现的。然而，如何

[1.x.354]

作为一个预处理程序？这就意味着，每次我们要做一个预处理步骤时，实际上都要用[2.x.966]来解。起初，这看起来几乎和立即用[2.x.967]求解一样昂贵。然而，请注意，在内迭代中，我们不必计算[2.x.968]，而只需计算其对角线的逆值，这很便宜。

值得庆幸的是，LinearOperator框架使得这一点非常容易写出来。我们之前已经对[2.x.969]矩阵使用了雅可比预处理程序（[2.x.970]）。所以剩下的就是写出近似的舒尔补码应该是什么样子。

[1.x.355]

注意这个运算符的不同之处在于，它只是做了一次雅可比扫频（即与对角线的逆数相乘），而不是与整个[2.x.971]相乘。]的定义：它是与[2.x.973]的对角线的倒数相乘；换句话说，对向量[2.x.975]的[2.x.974]操作正是PreconditionJacobi所做的）。)

有了这些，我们几乎已经完成了预处理程序：它应该是近似Schur补码的逆。我们再次通过使用inverse_operator()函数创建一个线性算子来实现这一点。然而这一次我们想为CG求解器选择一个相对较小的容忍度（即反转[2.x.976]）。理由是[2.x.977]，所以我们实际上不需要完全反转它。然而，这产生了一个微妙的问题：[2.x.978]将被用于最后的外层CG迭代以创建一个正交基础。但为了使其发挥作用，每次调用都必须是精确的线性操作。我们通过使用IterationNumberControl来确保这一点，它允许我们将执行的CG迭代次数固定为一个固定的小数字（在我们的例子中为30）。

[1.x.356]



就这样吧!

很明显，应用这个近似Schur补数的逆运算是一个非常昂贵的预处理程序，几乎和反转Schur补数本身一样昂贵。我们可以期望它能大大减少Schur补数所需的外部迭代次数。事实上，它确实如此：在使用0阶元素的7次细化网格的典型运行中，外部迭代次数从592次下降到39次。另一方面，我们现在必须应用一个非常昂贵的预处理程序25次。因此，更好的衡量标准只是程序的运行时间：在目前的笔记本电脑上（截至2019年1月），对于这个测试案例，它从3.57秒下降到2.05秒。这似乎并不令人印象深刻，但在更细的网格和更高阶的元素上，节省的时间变得更加明显了。例如，一个7倍细化的网格和使用2阶元素（相当于约40万个自由度）产生了1134次到83次的外部迭代的改进，运行时间从168秒到40秒。虽然不是惊天动地，但意义重大。




[1.x.357]

在这个教程程序中，我们将求解上述混合公式中的拉普拉斯方程。由于我们想在程序中监测解的收敛性，我们选择右手边、边界条件和系数，以便恢复我们已知的解函数。特别是，我们选择压力解

[1.x.358]

而对于系数，为了简单起见，我们选择单位矩阵[2.x.979]。因此，确切的速度满足于

[1.x.359]

选择这个解决方案是因为它完全没有发散，使得它成为不可压缩流体流动的一个现实的测试案例。因此，右手边等于[2.x.980]，作为边界值，我们必须选择[2.x.981]。

对于本程序中的计算，我们选择 [2.x.982] 。你可以在[1.x.360]中找到结果的解决方案，在注释的程序之后。


examples/step-20/doc/results.dox



[1.x.361]

[1.x.362]


如果我们按原样运行程序，对于我们使用的[2.x.983]网格，我们得到这样的输出（因为我们使用片状常数，所以总共有1024个单元，1024个压力自由度，2112个速度，因为Raviart-Thomas元素定义了每个面的一个自由度，有[2.x.984]个面与[2.x.985] -轴平行，有同样数量的面与[2.x.986] -轴平行）。

[1.x.363]



当然，迭代次数如此之少的事实是由于我们开发的良好（但昂贵！）的预处理程序。为了获得对解决方案的信心，让我们看一下它。下面三张图片显示了（从左到右）X-速度、Y-速度和压力。

[2.x.987]




让我们从压力开始：它在左边是最高的，在右边是最低的，所以流动将是从左到右。此外，虽然在图中几乎看不出来，但我们选择的压力场是这样的：从左到右的流动首先是向中心流动，然后再向外流动。因此，X-速度必须增加以使流动通过狭窄的部分，这一点在左图中很容易看到。中间的图像表示在域的左端有Y方向的内流，而在域的右端有Y方向的外流。




作为补充说明，请注意左图中的x-速度在x方向上是连续的，而y-速度在y方向上是连续的。其他方向上的流场是不连续的。这非常明显地反映了Raviart-Thomas元素的连续性特性，事实上，它只在空间H(div)而不是在空间[2.x.988]。最后，压力场是完全不连续的，但鉴于我们选择了[2.x.989]作为该解分量的有限元，这不应该令人惊讶。




[1.x.364]


该程序提供了两个明显的玩耍和观察收敛的地方：使用的有限元的程度（传递给[2.x.990]的构造器），和细化水平（在[2.x.991]中确定）。人们可以做的是改变这些值，观察后来在程序运行过程中计算出的误差。




如果这样做，就会发现压力变量中[2.x.992]的错误有如下模式。  [2.x.993]

理论上预期的收敛顺序很好地反映在表中最后一行所显示的实验观察结果中。




我们可以用速度变量的[2.x.994]误差做同样的实验。  [2.x.995] 这里关于收敛顺序的结果是一样的。




[1.x.365]

[1.x.366]

[1.x.367]

用于地下水或油藏模拟的现实流动计算不会使用恒定的渗透率。下面是改变这种情况的第一个相当简单的方法：我们使用一个渗透率，它在远离中心流线的地方迅速衰减，直到达到一个背景值0.001。这是为了模仿流体在砂岩中的行为：在大部分领域中，砂岩是均匀的，虽然对流体有渗透性，但不是过分的渗透；在另一块石头上，石头沿着一条线裂开了，或者说断层了，流体沿着这条大裂缝更容易流动。下面是我们如何实现这样的东西。

[1.x.368]

记住，该函数返回渗透率张量的逆值。




通过一个明显更高的网格分辨率，我们可以直观地看到这一点，这里有x-和y-速度。

[2.x.996]

很明显，流体基本上只沿着中线流动，而不是其他地方。




另一种可能性是使用一个随机的渗透率场。实现这一点的一个简单方法是在领域周围分散一些中心，然后使用一个渗透率场，这个渗透率场是这些中心的（负）指数之和。然后，流动将试图从一个高渗透率的中心跳到下一个中心。这是描述随机介质的一种完全不科学的尝试，但实现这种行为的一种可能性是这样的。

[1.x.369]



这个张量的对角线元素的片状常数插值（即[2.x.997]）看起来如下。

[2.x.998]


有了这样一个渗透率场，我们将得到如下的x-velocities和压力。

[2.x.999]

我们将在步骤21和步骤43中再次使用这些渗透率场。




[1.x.370]

正如介绍中提到的，这里使用的Schur补码求解器并不是可以想象的最好的（也不打算成为一个特别好的）。更好的解算器可以在文献中找到，并且可以使用这里介绍的相同的块矩阵技术来构建。我们将在第22步中再次讨论这个主题，在这里我们首先为斯托克斯方程建立一个Schur补数求解器，然后在[1.x.371]部分讨论基于整体求解系统但基于单个块的预处理的更好方法。我们还将在第43步中再来讨论这个问题。


examples/step-21/doc/intro.dox

［1.x.372］ ［1.x.373］

这个项目是由德克萨斯A&amp;M大学的李艳的一个学生项目发展而来的。这个项目的大部分工作都是由她完成的。

在这个项目中，我们提出了一个针对多孔介质中两相流动问题的数值模拟。这个问题包括一个椭圆方程和一个非线性的、随时间变化的传输方程。因此，这也是第一个时间相关的教程程序（除了有点奇怪的时间相关的[2.x.1000]"step-18"）。

这里涉及的方程是步骤20中已经涉及的材料的延伸。特别是，它们属于矢量值问题的范畴。这个主题的顶层概述可以在[2.x.1001]模块中找到。




[1.x.374]

多孔介质中两相流动的建模对于环境修复和石油及地下水库的管理都很重要。涉及两相流动的实际情况包括非水相液体在含水层中的分散，或混合液体（如油和水）在储层中的联合运动。仿真模型如果要提供真实的预测，就必须准确地考虑到这些影响。

为了推导出管理方程，考虑储层中的两相流动[2.x.1002]，假设流体的运动由粘性效应主导；即我们忽略了重力、压缩性和毛细压力的影响。孔隙率将被认为是恒定的。我们将使用下标[2.x.1003]和[2.x.1004]来表示两相中的任何一个变量，即水和油的简称。然而，方程的推导对其他流体对也是适用的。

两相中每一相的分子移动的速度由达西定律决定，该定律指出速度与压力梯度成正比。

[1.x.375]

其中[2.x.1005]是相[2.x.1006]的速度，[2.x.1007]是渗透率张量，[2.x.1008]是相[2.x.1009]的相对渗透率，[2.x.1010]是压力，[2.x.1011]是相[2.x.1012]的粘性。最后，[2.x.1013]是饱和度（体积分数），即一个数值在0和1之间的函数，表示流体混合物的组成。一般来说，系数[2.x.1014]可能是空间上的变量，在下文中我们将始终把它们作为非常数函数。

我们将达西定律与各相的质量守恒声明结合起来。

[1.x.376]

每个相都有一个源项。通过对两相求和，我们可以用所谓的压力方程来表达治理方程。

[1.x.377]

这里，[2.x.1015]是和源项，而

[1.x.378]

是总的流动性。

到目前为止，这看起来是一个普通的静止的、类似泊松的方程，我们可以用前几个教程的技术马上解决（例如，看一下步骤6，非常类似的东西）。然而，我们还没有说到饱和度，这当然会随着流体的移动而改变。

方程的第二部分是对饱和度的动态描述，即两种流体的相对浓度如何随时间变化。置换流体（水）的饱和度方程由以下守恒定律给出。

[1.x.379]

这可以通过使用前一个方程中发散算子的乘积规则来重写。

[1.x.380]

这里，[2.x.1016]是上面介绍的总流入量，[2.x.1017]是置换流体（水）的流速。这两者与分流量[2.x.1018]的关系如下。

[1.x.381]

其中分数流通常通过（启发式）表达式进行参数化

[1.x.382]

将所有这些放在一起，可以得到以下形式的饱和度方程，即平流式。

[1.x.383]

其中[2.x.1019]是总速度

[1.x.384]

注意，平流方程包含术语[2.x.1020]而不是[2.x.1021]，以表明饱和度不是简单地沿途传送；相反，由于两相以不同的速度移动，即使在平流坐标系中，饱和度实际上也可以改变。为了看到这一点，重写[2.x.1022]，观察到具有饱和度[2.x.1023]的相的[1.x.385]传输速度是[2.x.1024]，而另一相的传输速度是[2.x.1025] 。  因此，[2.x.1026]通常被称为[1.x.386]。

综上所述，我们得到的是以下两个方程式。

[1.x.387]

这里，[2.x.1027]现在是随时间变化的函数：虽然在每个时间瞬间，流场与压力处于平衡状态（即我们忽略了动态加速），但饱和度随着流动而运输，因此随时间变化，反过来又通过第一个方程对[2.x.1028]的依赖性影响流场。

这组方程有一个奇特的特点：两个方程中的一个有时间导数，另一个没有。这与压力和速度通过瞬时约束耦合的特点相对应，而饱和度在有限的时间尺度上演变。

这样的方程组被称为微分代数方程（DAE），因为其中一个方程是微分方程，另一个不是（至少不是相对于时间变量），因此是一个 "代数 "方程。这个符号来自常微分方程领域，在这个领域中，所有没有关于时间变量的导数的东西都必然是一个代数方程）。这类方程包含相当知名的情况：例如，与时间相关的斯托克斯和纳维-斯托克斯方程（其中代数约束是流场的发散，[2.x.1029]，必须为零）以及与时间相关的麦克斯韦方程（这里，代数约束是电位移场的发散等于电荷密度，[2.x.1030] ，磁通密度的发散为零。  [2.x.1031]）；即使是Step-18的准静态模型也属于这个类别。我们将看到，这两个方程的不同特征将告知我们这两个方程的离散化策略。




[1.x.388]

在储层模拟界，通常是通过回到一阶混合公式来解决上面得出的方程。为此，我们重新引入总速度[2.x.1032]，并将方程写成以下形式。

[1.x.389]

这种表述方式还有一个好处，即我们不必将出现在传输方程中的总速度[2.x.1033]表示为压力的函数，而是可以将其作为主变量。鉴于前两个方程的鞍点结构以及它们与我们在第20步中介绍的混合拉普拉斯公式的相似性，我们将再次使用混合离散化，这并不奇怪。

但是，让我们先把这个问题推迟一下。我们处理这些方程的第一件事是考虑时间离散化。在储层模拟中，有一个相当标准的算法，我们将在这里使用。它首先使用隐式方程解决压力问题，然后使用显式时间步进方案解决饱和问题。该算法被称为IMplicit Pressure Explicit Saturation（隐式压力显式饱和），很早以前就被提出：Sheldon等人在1959年提出，Stone和Gardner在1961年提出（J.W.Sheldon, B. Zondek and W. T. Cardwell:[1.x.390], Trans.SPE AIME, 216 (1959), pp. 290-296; H. L. Stone and A. O. Gardner Jr: [1.x.391], Trans.SPE AIME, 222 (1961), pp. 92-104)。在一个稍加修改的形式中，这个算法可以写成如下：对于每一个时间步长，解决

[1.x.392]

其中[2.x.1034]是一个时间步长。请注意我们是如何解决隐式压力-速度系统的，它只取决于先前计算的饱和度[2.x.1035]，然后对[2.x.1036]做一个显式时间步长，它只取决于先前已知的[2.x.1037]和刚刚计算的[2.x.1038]。这样一来，我们就不必像使用全隐式方法那样，对系统的非线性进行迭代。从更现代的角度来看，这应该被看作是一种 "算子分割 "方法。

然后我们可以将问题以弱的形式陈述如下，用测试函数[2.x.1039]、[2.x.1040]和[2.x.1041]乘以每个方程，并通过部分整合条款。

[1.x.393]

注意，在第一项中，我们必须规定边界[2.x.1042]上的压力[2.x.1043]作为我们问题的边界值。  [2.x.1044]表示对[2.x.1045]的单位外向法向量，如常。

对于饱和度方程，我们通过部分积分后得到

[1.x.394]

利用[2.x.1046]这一事实，我们可以重写细胞项，得到如下方程。

[1.x.395]

我们引入了一个DiscreteTime类型的对象，以便在代码中保持对时间和时间步长的当前值的跟踪。这个类封装了许多关于调整时间步长和在指定的最终时间停止的复杂情况。




[1.x.396]

在每个时间步长中，我们再对速度和压力应用[2.x.1047]"step-20 "的混合有限方法。为了得到良好的解决，我们对[2.x.1049]选择Raviart-Thomas空间[2.x.1048]，对[2.x.1051]选择[2.x.1050]类的不连续元素。对于饱和度，我们也将选择[2.x.1052]空间。

由于我们有不连续的空间，我们必须考虑如何评估细胞之间界面上的项，因为不连续的函数在那里没有真正定义。特别是，我们必须给饱和度方程左边的最后一个项赋予一个意义。为此，让我们定义，我们要在以下意义上评估它。

[1.x.397]

其中[2.x.1053]表示流入边界，[2.x.1054]是边界的流出部分。数量[2.x.1055]对应于当前单元上的这些变量值，而[2.x.1056]（需要在[2.x.1057]边界的流入部分）是取自邻近单元的数量。关于非连续元素技术和通量评估的更多背景，也可以在步骤12和步骤12b中找到。




[1.x.398]

这个程序中使用的线性求解器是对步骤20中使用的线性求解器的直接扩展（但没有LinearOperator）。从本质上讲，我们只需将一切从两个解元扩展到三个解元。如果我们使用上面提到的离散空间，并将形状函数放入双线性形式中，我们得出以下线性系统，以解决时间步长[2.x.1058] 。

[1.x.399]

其中各个矩阵和向量的定义如下：使用形状函数[2.x.1059]（类型为Raviart Thomas[2.x.1060]）定义速度，使用[2.x.1061]（类型为[2.x.1062] ）定义压力和饱和度。

[1.x.400]



[2.x.1063] 由于历史原因，与第20步相比，矩阵[2.x.1064]和[2.x.1065]的作用在本程序中被还原了。换句话说，这里[2.x.1066]指的是发散，[2.x.1067]指的是梯度算子，而在第20步中则是相反。

上面的系统出现了一个复杂的问题。由于矩阵[2.x.1068]隐含地依赖于[2.x.1069]（需要速度来确定细胞边界[2.x.1070]的哪些部分是流入或流出的部分），我们只能在解决了速度问题之后才能组装这个矩阵。

然后，求解方案包括以下步骤。<ol> [2.x.1071] 使用步骤20中介绍的Schur补足技术求解压力[2.x.1072]。

   [2.x.1073] 求解速度[2.x.1074]，也是在步骤20中讨论的。

   [2.x.1075] 计算项[2.x.1076] ，使用刚刚计算的速度。

   [2.x.1077] 求解饱和度 [2.x.1078] 。  [2.x.1079]

在这个方案中，我们实际上从未建立过矩阵[2.x.1080]，而是在我们准备好后生成第三个方程的右手边。

在程序中，我们使用一个变量[2.x.1081]来存储当前时间步骤的解决方案。在每一步结束时，我们将其内容，即其所有的三个块状成分，复制到变量[2.x.1082]中，以便在下一个时间步骤中使用。




[1.x.401]

在双曲输运方程中，像我们要解决的饱和方程的一般经验法则是，如果我们使用显式时间步长方案，那么我们应该使用一个时间步长，使粒子在一个时间步长内所能走的距离不大于一个细胞的直径。换句话说，在这里，我们应该选择

[1.x.402]

幸运的是，我们处在一个可以做到这一点的位置：我们只需要当我们想集合饱和方程的右边时的时间步长，也就是在我们已经解出[2.x.1083]之后。因此，在求解速度之后，我们要做的就是在域中的所有正交点上循环，确定速度的最大幅度。然后我们可以将饱和方程的时间步长设定为

[1.x.403]



为什么要这样做呢？如果我们不这样做，那么我们就会发现很多地方的饱和度大于1或小于0，这一点很容易得到验证。请记住，饱和度对应于流体混合物中的水比例，因此在物理上必须在0和1之间）。另一方面，如果我们根据上面列出的标准选择时间步长，这种情况只会非常非常少地发生，事实上在整个程序运行中只有一次。然而，为了安全起见，我们在每个时间步长结束时运行一个函数[2.x.1084]，如果饱和度已经超出了物理范围，则简单地将其投射回区间[2.x.1085]。这很有用，因为函数[2.x.1086]和[2.x.1087]并不代表这个范围之外的任何物理现象，而且一旦我们有负的饱和度或大于1的饱和度，我们不应该期望程序做任何有用的事情。

请注意，我们在第23步和第24步中也会对时间步长有类似的限制，在这两步中我们要解决与时间有关的波浪方程，即另一个双曲问题。我们还将在下面的[1.x.404]一节中再来讨论时间步长的选择问题。




[1.x.405]

为了简单起见，本程序假定没有源头， [2.x.1088] ，并且异质多孔介质是各向同性的 [2.x.1089] 。其中第一个假设在油藏中是一个现实的假设：除了注水井和生产井之外，通常没有液体突然出现或消失的机制。第二个假设更难证明：在微观层面上，大多数岩石是各向同性的，因为它们是由相互连接的孔隙网络组成的。然而，这种微观尺度超出了今天计算机模拟的范围，我们不得不满足于模拟米级的东西。然而，在这个尺度上，流体运输通常是通过岩石中的裂缝网络，而不是通过孔隙发生的。然而，裂缝通常是由岩层中的外部应力场造成的（例如由构造断层造成的），因此裂缝是大致排列的。这就导致了这样一种情况：在平行于裂缝的方向上，渗透率往往比垂直于裂缝的方向大几个数量级。然而，在储层模拟中通常面临的一个问题是，建模者不知道裂缝的方向，因为油藏不容易被检查到。在这种情况下，唯一的解决办法是假设有效的、各向同性的渗透率。

无论怎样，这两个限制，即无源和各向同性，只要在程序中写上几行代码就能轻松解除。

接下来，为了简单起见，我们的数值模拟将在[2.x.1090]的单元格上进行，即[2.x.1091]。我们的初始条件是[2.x.1092]；在油藏图片中，[2.x.1093]将表示水的饱和度，这意味着油藏一开始就含有纯油。请注意，我们不需要任何压力或速度的初始条件，因为这些方程不包含这些变量的时间导数。最后，我们施加以下压力边界条件。

[1.x.406]

由于压力和速度求解的是混合形式的泊松方程，所以施加的压力导致了速度的流场。另一方面，这个流场决定了边界的某一部分是流入还是流出，这很重要，因为我们必须在边界的流入部分施加饱和度的边界条件。

[1.x.407]

在这个流入的边界上，我们施加以下的饱和值。

[1.x.408]

换句话说，我们有纯水在左边进入储层，而边界的其他部分与储层的未受干扰部分接触，只要这些边界上发生流入，纯油就会进入。

在我们的模拟中，我们选择总流动性为

[1.x.409]

其中我们用[2.x.1094]表示粘度。此外，水的分流量由以下公式给出

[1.x.410]



[2.x.1095] 几年后在step-43中再来看这个测试案例，发现这个测试案例的设置有一个奇怪之处。为此，考虑我们可以将饱和度的平流方程改写为 [2.x.1096] 。现在，在初始时间，我们有[2.x.1097]，在给定的函数[2.x.1098]的选择下，我们正好有[2.x.1099]。换句话说，在[2.x.1100]处，方程对所有[2.x.1102]都还原为[2.x.1101]，所以饱和度在任何地方都是零，而且在任何地方都会保持零！这就是为什么在[2.x.1102]处的饱和度为零。尽管[2.x.1103]不一定是零：组合流体在移动，但我们选择的部分通量[2.x.1104]是这样的：无穷小量的润湿流体也只以无穷小的速度移动（也就是说，它们粘附在介质上的程度比它们所嵌入的非润湿相要大）。也就是说，我们如何将这一点与润湿性液体从左边侵入，导致[1.x.411]中看到的流动模式的知识联系起来？这就是我们进入数学的地方。像我们在这里考虑的传输方程有无限多的解决方案，但其中只有一个是物理的：由所谓的粘性极限产生的解决方案，称为[1.x.412]。事情是这样的，用不连续的元素，我们到达了这个粘性极限，因为使用数值通量在数值方案中引入了有限量的人工粘性。另一方面，在step-43中，我们在每个单元上使用与[2.x.1105]成比例的人工粘度，在初始时间是零。因此，那里的饱和度为零，并保持为零；然后我们得到的解是[1.x.413]的平流方程解，但如果不进一步改变，该方法不会收敛到粘性解。因此，我们将在该程序中使用一个不同的初始条件。


最后，回到测试案例的描述，我们将展示用[2.x.1106] "step-20 "的结果部分末尾介绍的两个渗透率函数计算的结果。  [2.x.1107] [2.x.1108] 一个函数，模拟一个蜿蜒穿过领域的单一裂缝。与step-20相类似，但考虑到我们这里的几何形状略有不同，我们用以下函数来描述。   [1.x.414]

  取最大值是必要的，以确保最大和最小渗透率之间的比率保持有界。如果我们不这样做，渗透率将跨越许多数量级。另一方面，最大和最小渗透率之间的比率是舒尔补矩阵的条件数的一个因素，如果太大，会导致我们的线性求解器不再正常收敛的问题。

   [2.x.1109] 一个模拟某种随机介质的函数。在这里，我们选择[1.x.415]。

  其中中心[2.x.1110]是域内[2.x.1111]随机选择的位置。这个函数模拟了一个领域，其中有[2.x.1112]个渗透率较高的中心（例如，岩石已经开裂）嵌入到一个更原始的、未受干扰的背景岩石矩阵中。请注意，在这里我们切断了上方和下方的渗透率函数，以确保有界的条件数。  [2.x.1113]


examples/step-21/doc/results.dox



[1.x.416]

这里介绍的代码并没有真正计算出网页上的结果。原因是，即使在一台好的电脑上，它也要运行一天以上。如果你想重现这些结果，在TwoPhaseFlowProblem的构造函数中把DiscreteTime对象的结束时间修改为`250`。

如果我们运行该程序，我们会得到以下这种输出。

[1.x.417]

我们可以看到，时间步长从一开始就基本恒定，这表明域中的速度并不强烈依赖于饱和度的变化，尽管它们肯定是通过压力方程中的因子[2.x.1114]来决定的。

我们的第二个观察结果是，在第一和第二时间步之间，解决压力舒尔补足方程所需的CG迭代次数从22次下降到17次（事实上，在其余的计算中，它保持在17次左右）。原因其实很简单。在我们求解一个时间步长的压力之前，我们没有将[2.x.1115]变量重置为零。因此，在我们进入CG求解器时，压力（和其他变量）具有前一个时间步骤的值。由于速度和压力在计算过程中变化不大，前一个时间步骤的压力实际上是对这个时间步骤压力的一个很好的初始猜测。因此，一旦我们计算了一次压力，我们需要的迭代次数就会大大减少。

最后的观察是关于求解饱和度所需的迭代次数，也就是一次。这不应该让我们太惊讶：我们必须解决的矩阵是质量矩阵。然而，这是[2.x.1116]元素的分片常数的质量矩阵，其中没有元素与相邻单元的自由度耦合。因此，该矩阵是一个对角线矩阵，很明显，我们应该能够在一次CG迭代中反转该矩阵。


说了这么多，这里有几个电影，显示了饱和度是如何随时间推移而发展的。首先，这是针对单一裂缝模型的，正如在[2.x.1117]类中实现的那样。

[2.x.1118]

可以看出，富水流体主要是沿着域中间的高渗透区蜿蜒前行，而域的其他部分则大部分是不渗透的。这部电影和下一部电影是用[2.x.1119]生成的，导致[2.x.1120]的网格有大约16000个单元和大约66000个未知数。


第二部电影显示了[2.x.1121]类的随机介质模型的饱和度，我们有随机分布的高渗透率中心，流体从这些区域中的一个跳到另一个。

[2.x.1122]


最后，这里是在三个空间维度上的相同情况，在一个具有[2.x.1123]的网格上，产生一个大约32000个单元和167000个自由度的网格。

[2.x.1124]

要重复这些计算，你所要做的就是改变行数

[1.x.418]

在主函数中为

[1.x.419]

可视化采用了云技术，每个单元的饱和度都由彩色但透明的云来表示。这样，人们也可以在一定程度上看到域的深处发生了什么。另一种可视化的方式是显示饱和度随时间变化的等值面。有一些技术可以透明地绘制等值面，这样就可以像洋葱的层次一样同时看到几个等值面。

那么，为什么我们不显示这样的等值面呢？问题在于等值面的计算方式：它们要求要可视化的场是连续的，所以等值面可以通过至少在单个细胞中遵循轮廓线来生成。然而，我们的饱和场是片状常数和不连续的。如果我们想为一个饱和度[2.x.1125]绘制一个等值面，那么在这个领域中就很可能没有一个点是真正达到饱和度的。如果我们必须在这种情况下定义等值面，我们将不得不采取细胞之间的界面，其中相邻的两个细胞之一的饱和度大于，另一个细胞的饱和度小于0.5。然而，大多数可视化程序似乎并不具备做这种转换的能力。


[1.x.420]

[1.x.421]

这个项目有许多可以改进的地方。下面列出了其中的三个。事实上，所有这些问题都在构成当前程序的延续的辅导程序中得到了解决：Step-43。




[1.x.422]

目前，该程序并不是特别快：二维随机介质的计算在1000个左右的时间步长中花费了大约一天时间。相应的三维计算在800个时间步骤中几乎花了两天时间。没有比这更快的原因有两个方面。首先，我们在每个时间步骤中都要重建整个矩阵，尽管有些部分如[2.x.1126]、[2.x.1127]和[2.x.1128]块从未改变。

第二，我们可以在求解器和预处理器方面做得更好。目前，我们用CG方法解决Schur补数[2.x.1129]，使用[2.x.1130]作为预处理程序。应用这个预处理程序是很昂贵的，因为它涉及到每次解决一个线性系统。这可能适合于[2.x.1131]的 "第20步"，在那里我们只需要解决整个问题一次。然而，在这里我们必须求解数百次，在这种情况下，值得考虑使用一种第一次设置起来比较昂贵，但以后应用起来比较便宜的预处理程序。

一种可能性是意识到我们用作预处理的矩阵，[2.x.1132]仍然是稀疏的，而且是对称的。如果看一下流场随时间的演变，我们还可以看到，虽然[2.x.1133]随时间变化很大，但压力几乎没有变化，因此[2.x.1134] 。换句话说，第一个时间步骤的矩阵应该是一个很好的前提条件，也适用于所有后来的时间步骤。  通过一些反反复复的操作，实际上并不难得到一个SparseMatrix对象的表示。然后我们可以把它交给SparseMIC类，以形成一个稀疏的不完全Cholesky分解。形成这种分解是很昂贵的，但是我们只需要在第一个时间步骤中做一次，然后就可以在未来把它作为一个廉价的预处理程序。我们甚至可以通过使用SparseDirectUMFPACK类来做得更好，它不仅能产生一个不完整的，而且是一个完整的矩阵分解，这应该会产生一个更好的预处理程序。

最后，为什么使用近似值[2.x.1135]来预设[2.x.1136]？后者的矩阵毕竟是压力空间上拉普拉斯算子的混合形式，我们对其使用线性元素。因此，我们可以在直接对应于拉普拉斯的非混合形式的一侧建立一个单独的矩阵[2.x.1137]，例如使用双线性形式[2.x.1138] 。然后我们可以形成这个非混合矩阵的不完全或完全分解，并将其作为混合形式的预处理。

使用这样的技术，可以合理地预期，求解过程将至少快一个数量级。




[1.x.423]

在介绍中，我们已经确定了时间步长的限制

[1.x.424]

必须是全局性的，即对所有的[2.x.1139]。离散化后，我们通过选择以下方式来满足它

[1.x.425]



这种对时间步长的限制有些烦人：我们把网格做得越细，时间步长就越小；换句话说，我们受到了两次惩罚：每个时间步长的求解成本更高，我们必须做更多的时间步长。

这一点特别令人讨厌，因为大部分的额外工作是用来解决方程的隐含部分，即压力-速度系统，而正是饱和度的双曲传输方程施加了时间步长的限制。

为了避免这个瓶颈，人们发明了一些方法。例如，他们可能每隔几步时间才重新计算压力-速度场（或者，如果你愿意，对压力/速度和饱和度方程使用不同的时间步长）。这就保持了对廉价显式部分的时间步长限制，而使隐式部分的求解不那么频繁。这个方向的实验当然是值得的；这种方法的一个起点是陈章新、桓冠仁和李宝岩的论文：[1.x.426]，Transport in Porous Media，54（2004），第361&mdash；376页。当然也有很多其他关于这个主题的论文，但这篇论文前段时间刚好落在我们的桌上。




[1.x.427]

适应性显然也会有帮助。看一下电影，我们可以清楚地看到，大部分的行动都局限于领域的一个相对较小的部分（这对饱和度来说特别明显，但对速度和压力也是如此）。因此，自适应性可望保持必要的低自由度数量，或者增加精确度。

另一方面，对于时间相关问题的自适应性也不是一件小事：我们必须每隔几个时间步数改变网格，而且每次改变网格时，我们都必须将目前的解决方案传送到下一个网格（SolutionTransfer类可以帮助解决这个问题）。这些并不是无法克服的障碍，但它们确实需要一些额外的编码，而且比我们认为值得打包到这个教程程序中的更多。


examples/step-22/doc/intro.dox

[2.x.1140]

[1.x.428]




[1.x.429]

[1.x.430]

这个程序处理斯托克斯方程组，其非维度形式如下。

[1.x.431]

其中[2.x.1141]表示流体的速度，[2.x.1142]是其压力，[2.x.1143]是外力，[2.x.1144]是对称梯度的第2级张量；它的分量定义是[2.x.1145] 。

斯托克斯方程描述了缓慢移动的粘性流体的稳态运动，如蜂蜜、地幔中的岩石，或其他惯性不起作用的情况。如果流体的运动速度足够快，与粘性摩擦力相比，惯性力很重要，那么斯托克斯方程就不再有效；考虑到惯性效应，就会产生非线性纳维-斯托克斯方程。然而，在这个教程程序中，我们将重点关注更简单的斯托克斯系统。

请注意，在推导更一般的可压缩纳维-斯托克斯方程时，扩散被建模为应力张量的发散。

[1.x.432]

其中[2.x.1146]是流体的粘度。有了[2.x.1147]的假设（假设粘度恒定，通过除以[2.x.1148]使方程非立体化），并假设不可压缩性（[2.x.1149]），我们就可以得出上面的公式。

[1.x.433]

一个不同的公式使用拉普拉斯算子（[2.x.1150]）而不是对称梯度。这里一个很大的区别是，速度的不同分量并不耦合。如果你假定解的额外规律性[2.x.1151]（第二部分导数存在并且是连续的），这些公式是等同的。

[1.x.434]

这是因为[2.x.1152]中的第1个条目[2.x.1153]是由以下内容给出的。

[1.x.435]

如果你不能假设上述的规律性，或者你的粘度不是一个常数，那么这个等价关系就不再成立。因此，我们决定在本教程中坚持使用物理上更准确的对称张量公式。


为了得到良好的解决，我们将不得不在方程中加入边界条件。一旦我们讨论方程的微弱形式，哪些边界条件在这里是容易做到的就会变得清晰。

这里所涉及的方程属于矢量值问题的范畴。这个主题的顶层概述可以在[2.x.1154]模块中找到。




[1.x.436]

通过将其写成矢量形式，可以得到方程的弱形式为

[1.x.437]

从左边开始与一个矢量值测试函数[2.x.1155]形成点积，并在域[2.x.1156]上进行积分，得到以下一组方程。

[1.x.438]

这对所有的测试函数都必须成立 [2.x.1157] 。

一般来说，一个好的经验法则是，如果一个人[1.x.439]减少公式中任何变量的导数，那么他[1.x.440]实际上是用部分积分来做。这是由[1.x.441]的理论引起的，特别是强和[1.x.442]之间的区别）。我们已经为拉普拉斯方程做了这个工作，在那里我们对第二导数进行了分项积分，以获得在测试和试验函数上都只有一个导数的弱表述。

在当前情况下，我们对第二项进行分项积分。

[1.x.443]

同样地，我们对第一项进行分项积分，得到

[1.x.444]

其中，两个张量值的量之间的标量乘积在此定义为

[1.x.445]

利用这一点，我们现在已经将对我们的变量的要求降低到[2.x.1158]的一阶导数，而对[2.x.1159]完全没有导数。

因为像[2.x.1160]这样的一般张量和[2.x.1161]这样的对称张量之间的标量积等于两者的对称形式之间的标量积，我们也可以把上面的双线性形式写成如下。

[1.x.446]

我们将在下一节处理边界条款，但从域条款中已经可以看出

[1.x.447]

的双线性形式，斯托克斯方程产生一个对称的双线性形式，并因此产生一个对称的（如果是不确定的）系统矩阵。




[1.x.448]

[2.x.1162] （ [2.x.1163] 。

刚刚导出的弱形式立即为我们提供了施加边界条件的不同可能性。<ol> [2.x.1164] 迪里希特速度边界条件。在一个部分[2.x.1165]，我们可以对速度[2.x.1166]施加迪里希特条件。

    [1.x.449]

    因为测试函数[2.x.1167]来自解变量的切线空间，我们有[2.x.1168]对[2.x.1169]，因此有[1.x.450]。

    换句话说，像往常一样，强加的边界值并没有出现在弱形式中。

    值得注意的是，如果我们在整个边界上施加迪里希特边界值，那么压力就只能确定到一个常数。这方面的算法实现将使用类似于步骤11中的工具。

[2.x.1170] 诺伊曼型或自然边界条件。在边界的其余部分[2.x.1171]，让我们把边界条款重新写成如下。     [1.x.451]

    换句话说，在边界的诺伊曼部分，我们可以规定总应力的数值。     [1.x.452]

    如果边界被细分为Dirichlet和Neumann部分 [2.x.1172] ，这就导致了以下弱形式。     [1.x.453]




[2.x.1173] 罗宾式边界条件。罗宾式边界条件是迪里切特和诺伊曼边界条件的混合物。它们将读作[1.x.454]。

    有一个等级2的张量（矩阵） [2.x.1174] 。相关的弱形式是[1.x.455] 。



[2.x.1175] 部分边界条件。可以通过只对速度的某些分量强制执行Dirichlet和Neumann边界条件来结合它们。例如，施加人工边界条件的一种方法是要求流动垂直于边界，即切向分量[2.x.1176]为零，从而约束速度的[2.x.1177]-1分量。剩下的分量可以通过要求法向应力的法向分量为零来约束，产生以下一组边界条件。     [1.x.456]



    另一种情况是当人们希望流动是[1.x.457]而不是垂直于边界时（在deal.II中，[2.x.1178]函数可以为你这样做）。这种情况经常发生在自由边界的问题上（例如，在河流或湖泊的表面，如果流动的垂直力不足以使表面实际变形），或者如果边界对流体没有施加明显的摩擦力（例如，在地幔和地核的界面上，两种流体因密度不同而相遇，但它们的粘度都很小，不会对彼此产生很大的切向应力）。     在公式中，这意味着[1.x.458]

    第一个条件（需要强加）固定了速度的一个分量，第二个条件（将在弱形式下强制执行）固定了其余的两个分量。  [2.x.1179]

尽管有这么多的可能性，我们在这个教程程序中只使用迪里希特和（同质）诺伊曼边界条件。




[1.x.459]

如上所述，在[2.x.1180]和[2.x.1181]上有迪里希特和诺伊曼边界条件的方程的弱形式是这样的：找到[2.x.1182]，以便

[1.x.460]

为所有测试函数 [2.x.1183] 。

这些方程代表一个对称的[1.x.461]。众所周知，那么只有当我们寻找解决方案的函数空间必须满足某些条件时，解决方案才会存在，这些条件通常被称为Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件。上面的连续函数空间满足这些条件。然而，当我们将方程离散化，用有限维空间中的有限元函数取代连续变量和检验函数[2.x.1184]时，我们必须确保[2.x.1185]也满足LBB条件。这与我们在第20步中要做的事情类似。

对于斯托克斯方程，有许多可能的选择来确保有限元空间与LBB条件兼容。一个简单而准确的选择是[2.x.1186]，即对速度使用比压力高一阶的元素。

这就导致了以下的离散问题：找到[2.x.1187]，以便于

[1.x.462]

为所有测试函数 [2.x.1188] 。组装与此问题相关的线性系统遵循 [2.x.1189] "步骤-20"、步骤-21中使用的相同路线，并在 [2.x.1190] 模块中详细解释。




[1.x.463]

离散方程的微弱形式自然导致了以下速度场和压力场的节点值的线性系统。

[1.x.464]

与第20步和第21步一样，我们将通过形成舒尔补数来解决这个方程组，也就是说，我们将首先找到[2.x.1191]的解。

[1.x.465]

然后

[1.x.466]

我们这样做的方式与我们在以前的这些教程程序中做的差不多，也就是说，我们再次使用相同的类[2.x.1192]和[2.x.1193]。然而，有两个显著的区别。

<ol> [2.x.1194] 首先，在混合拉普拉斯方程中，我们必须处理如何对舒尔补数[2.x.1195]进行预处理的问题，它在谱上等同于压力空间上的拉普拉斯算子（因为[2.x.1196]代表梯度算子，[2.x.1197]代表其邻接算子[2.x.1198]，而[2.x.1199]代表身份（直到材料参数[2.x.1200]为止），因此[2.x.1201]类似于[2.x.1202]）。因此，对于小的网格尺寸来说，矩阵的条件很差，我们不得不为Schur补数提出一个精心设计的预处理方案。

[2.x.1203] 其次，每次我们与[2.x.1204]相乘时，我们必须用质量矩阵[2.x.1205]来解决。然而，这并不特别困难，因为质量矩阵总是有很好的条件的，所以使用CG和一点点预处理就能简单地反转。  换句话说，[2.x.1206]的内部求解器的预处理很简单，而[2.x.1208]的外部求解器的预处理很复杂。

在这里，情况几乎完全相反。差异源于这样一个事实，即舒尔补码的核心矩阵不是来自身份算子，而是来自拉普拉斯算子的一个变体，[2.x.1209]（其中[2.x.1210]是对称梯度），作用于一个矢量场。在对这个问题的研究中，我们主要遵循D. Silvester和A. Wathen的论文。"稳定的斯托克斯系统的快速迭代解第二部分。使用一般块状先决条件"。(SIAM J. Numer.Anal., 31 (1994), pp. 1352-1367)，可在线查阅[1.x.467]。主要来说，舒尔补码的核心矩阵的差异有两个后果。

<ol> [2.x.1211] 首先，它使外部预处理变得简单：Schur补数对应于压力空间上的算子[2.x.1212]；忘记我们处理的是对称梯度而不是常规梯度的事实，Schur补数类似于[2.x.1213]，即使在数学上不完全简明，在光谱上也等同于身份算子（一个启发式的论证是将算子换算成[2.x.1214]）。事实证明，用CG方法直接解决这个Schur补数并不容易：在没有预处理的情况下，Schur补数矩阵的条件数取决于最大和最小单元的大小比，而且仍然需要50-100次CG迭代。然而，有一个简单的解决办法：用压力空间上的质量矩阵进行预处理，我们就可以减少到5-15次CG迭代，几乎不受网格结构的影响（看看这个程序的[1.x.468]，可以看到CG迭代的数量确实不会随着我们细化网格而改变）。

因此，除了我们已经有的东西之外，我们需要的是压力变量上的质量矩阵，我们将把它存储在一个单独的对象中。




[2.x.1215] 虽然与第20步讨论的混合拉普拉斯情况相比，外部预调节器变得简单了，但内部求解器的问题却变得更加复杂。在混合拉普拉斯离散化中，舒尔补数的形式为 [2.x.1216] 。因此，每当我们与舒尔补码相乘时，我们必须解决一个线性系统[2.x.1217]；然而，这并不太复杂，因为压力空间上的质量矩阵[2.x.1218]是有条件的。


另一方面，对于我们这里考虑的斯托克斯方程，舒尔补码是[2.x.1219]，其中矩阵[2.x.1220]与拉普拉斯算子有关（事实上，它是对应于双线性形式[2.x.1221]的矩阵）。因此，用[2.x.1222]求解要复杂得多：矩阵的条件很差，我们知道我们需要很多迭代，除非我们有一个非常好的预处理程序。更糟糕的是，我们每次与舒尔补码相乘时都要用[2.x.1223]求解，使用上述的预处理程序需要5-15次。

因为我们必须多次用[2.x.1224]求解，所以多花一次时间为这个矩阵创建一个好的预处理程序是值得的。所以我们要做的是：如果在2d中，我们使用终极预处理程序，即矩阵的直接稀疏LU分解。这是用SparseDirectUMFPACK类实现的，它使用UMFPACK直接求解器来计算分解。要使用它，你必须建立支持UMFPACK的deal.II（这是默认的）；参见[1.x.469]中的说明。有了它，内解器在一次迭代中就能收敛。

在2D中，我们可以做这种事情，因为即使是合理的大问题，也很少有超过100,000个未知数的，每行的非零项相对较少。此外，2D中矩阵的带宽是[2.x.1225]，因此是中等的。对于这样的矩阵，稀疏因子可以在几秒钟内计算出来。作为参考，计算一个大小为[2.x.1226]、带宽为[2.x.1227]的矩阵的稀疏因子需要[2.x.1228]次操作。在2d中，这是[2.x.1229]；尽管这比例如组装线性系统的复杂度要高，后者需要[2.x.1230]，但计算分解的常数非常小，直到我们达到非常大的未知数%，甚至更多，它才成为整个程序中的主导因素）。)

情况在3D中发生了变化，因为在那里我们很快就会有更多的未知数，而且矩阵的带宽（决定了稀疏LU因子中非零项的数量）是[2.x.1231]，而且每行也有很多条目。这使得像UMFPACK这样的稀疏直接求解器的效率很低：只有在问题规模为10,000到100,000个未知数时，才能用合理的时间和内存资源计算稀疏分解。

在这种情况下，我们要做的是使用一个不完整的LU分解（ILU）作为预处理，而不是实际计算完整的LU因子。恰好，deal.II有一个类可以做到这一点。SparseILU。计算ILU所需要的时间只取决于稀疏矩阵中的非零项的数量（或者说我们愿意填入LU因子，如果这些非零项应该多于矩阵中的非零项），但与矩阵的带宽无关。因此，这也是一个可以有效地在三维中计算的操作。另一方面，根据定义，一个不完整的LU分解并不代表矩阵的精确逆 [2.x.1232] 。因此，与稀疏直接求解器的预处理不同，用ILU进行预处理仍然需要一次以上的迭代。因此，当与舒尔补码相乘时，内解器将花费更多时间：这是一个不可避免的权衡。  [2.x.1233]

在下面的程序中，我们将利用SparseILU和SparseDirectUMFPACK类具有非常相似的接口，可以互换使用的事实。我们所需要的是一个开关类，根据维度的不同，提供一个类型，即上述两个类中的任何一个。我们就是这样做的。

[1.x.470]



从这里开始，我们可以引用<code>typename [2.x.1234]这个类型，并自动得到正确的预处理程序类。由于这两个类的接口相似，我们将能够在所有地方使用相同的语法来互换使用它们。




[1.x.471]

上面的讨论显示了解决由斯托克斯方程产生的线性系统的*种方式，由于辅导程序是教学工具，这是有意义的。但这是解决这个方程组的**方式吗？

这个问题的答案是否定的。上面已经指出了这个方法的主要瓶颈，就是我们必须反复求解Schur补数内的[2.x.1235]线性系统，由于我们没有一个好的Schur补数的预处理程序，这些求解就不得不经常发生。一个更好的方法是使用块分解，这是基于Silvester和Wathen [2.x.1236]的观察，在[2.x.1237]中有更详细的解释。下面在本程序的结果部分的a [1.x.472]一节中讨论了这种替代方法的实现。




[1.x.473]

以上，我们已经声称线性系统的形式是

[1.x.474]

即，特别是在矩阵的右下方有一个零块。这样，我们就可以把舒尔补码写成[2.x.1238] 。但这并不完全正确。

想一想，如果对某些压力变量有约束会怎样（见[2.x.1239]"自由度的约束 "文件模块），例如因为我们使用自适应细化网格和连续压力有限元，所以会有悬挂节点。造成这种约束的另一个原因是压力的迪里希特边界条件。然后，AffineConstraints类，在将矩阵的局部贡献复制到全局线性系统时，会将对应于受限自由度的行和列清零，并在对角线上放一个正条目。为了简单起见，你可以认为这个条目是1，尽管实际上它是一个与其他矩阵条目相同数量级的值）。换句话说，右下角区块其实根本不是空的：它在对角线上有几个条目，每个受限的压力自由度都有一个，对我们要解决的线性系统的正确描述是，它的形式如下

[1.x.475]

其中[2.x.1240]是零矩阵，除了受限自由度的正对角线项。那么正确的舒尔补码实际上是矩阵[2.x.1241]，而不是上面说的那个。

思考这个问题使我们，首先，意识到所得到的舒尔补数现在是不确定的，因为[2.x.1242]是对称的和正定的，而[2.x.1243]是正半定的，从前者减去后者可能不再是正定的。这很烦人，因为我们不能再对这个真正的舒尔补数采用共轭梯度法。也就是说，我们可以在[2.x.1244]中通过简单地将*负*值放在受限压力变量的对角线上来解决这个问题--因为我们实际上只是放了一些非零的东西来确保结果矩阵不是奇异的；我们真的不关心那个条目是正还是负。因此，如果[2.x.1245]的对角线上的条目是负的，那么[2.x.1246]将再次成为一个对称的正定矩阵。

但是，其次，下面的代码实际上并没有做这些事。它很高兴地用错误的Schur补码[2.x.1247]来解决线性系统，完全忽略了这个问题。为什么会这样呢？为了理解为什么会这样，回顾一下，当把局部贡献写入全局矩阵时，[2.x.1248]把对应于受限自由度的行和列置零。这意味着[2.x.1249]有一些零行，[2.x.1250]零列。因此，如果要乘出[2.x.1251]的条目是什么，就会发现它的所有受限压力自由度的行和列都是零，包括对角线上的一个零。[2.x.1252]的非零条目将正好适合于这些零对角线位置，并确保[2.x.1253]是可逆的。不这样做，严格来说，意味着[2.x.1254]仍然是单数。它在非约束压力自由度子集上是对称和正定的，而在约束压力上只是一个零矩阵。为什么共轭梯度法对这个矩阵有效？因为[2.x.1255]也确保了对应于矩阵这些零行的右手边条目*也是零，也就是说，右手边是兼容的。

这意味着无论这些受限压力自由度的解向量的值是多少，这些行的残差总是为零，如果考虑到CG算法的内部操作，就永远不会对解向量产生任何更新。换句话说，CG算法只是*忽略*这些行，尽管矩阵是单数。这只是因为这些自由度与线性系统的其他部分完全解耦（因为整个行和相应的列都是零）。在求解过程结束时，求解向量中的受限压力值仍然和我们开始调用求解器时一模一样；当我们在CG求解器完成后调用[2.x.1256]时，它们最终被正确的值所覆盖。

这个讨论的结果是，大矩阵的右下角块为零的假设有点简化，但仅仅按照这个假设，实际上并没有导致任何值得解决的实际问题。




[1.x.476]

我们下面实现的域、右手边和边界条件与地球物理学中的一个问题有关：在那里，人们想计算大洋中裂缝下地球内部岩浆的流动场。裂缝是两个大陆板块非常缓慢地漂移开来的地方（每年最多几厘米），在地壳上留下一个裂缝，被下面的岩浆填充。在不试图完全现实的情况下，我们通过求解域[2.x.1257]上的以下一组方程和边界条件来模拟这种情况。

[1.x.477]

并在其他地方使用自然边界条件[2.x.1258]。换句话说，在顶面的左边部分，我们规定流体以速度[2.x.1259]随大陆板向左移动，在顶面的右边部分向右移动，并在其他地方施加自然流动条件。如果我们在2d中，描述基本上是相同的，只是我们省略了上述所有矢量的第二部分。

正如在[1.x.478]中会变得很明显的那样，流场将从下面拉动材料，并将其移动到域的左右两端，这是预期的。速度边界条件的不连续性将在顶面中心产生一个压力奇点，将材料一直吸到顶面，以填补材料在此位置向外运动所留下的缺口。




[1.x.479]

[1.x.480]

在之前的所有教程程序中，我们仅仅使用AffineConstraints对象来处理悬挂节点约束（步骤11除外）。然而，这个类也可以用来实现Dirichlet边界条件，正如我们将在这个程序中展示的，通过固定一些节点值 [2.x.1260] 。注意，这些是不均匀约束，我们要特别注意一些。我们要实现的方法是，首先通过调用AffineConstraints对象读入边界值

[1.x.481]



非常类似于我们之前制作边界节点列表的方式（注意，我们只在边界标志为1的边界上设置Dirichlet条件）。然后边界值的实际应用由AffineConstraints对象直接处理，没有任何额外的干扰。

然后我们可以像以前一样进行，即通过填充矩阵，然后在约束对象上调用一个浓缩函数，其形式为

[1.x.482]



请注意，我们在系统矩阵和系统右侧同时调用，因为解决不均匀约束需要对矩阵条目和右侧的知识。但出于效率的考虑，我们选择了另一种策略：所有收集在AffineConstraints对象中的约束都可以在将本地数据写入全局矩阵的同时得到解决，方法是使用调用

[1.x.483]



这个技术在step-27教程程序中进一步讨论。我们在这里需要知道的是，这个函数同时做了三件事：它把局部数据写入全局矩阵和右手边，它分布了悬挂的节点约束，另外还实现了（不均匀的）迪里切特边界条件。这很好，不是吗？

我们可以得出结论，AffineConstraints类提供了一个替代使用[2.x.1261]来实现Dirichlet边界条件的方法。


[1.x.484][1.x.485] 。

通常，稀疏矩阵包含大量的元素，当我们要开始线性求解时，这些元素实际上是零。这样的元素是在我们消除约束条件或实现Dirichlet条件时引入的，我们通常会删除受约束行和列中的所有条目，即把它们设置为零。对于本教程程序中所考虑的三维应用，存在于稀疏模式中但并不真正包含任何信息的那部分元素，可以达到矩阵中元素总数的四分之一。请记住，矩阵-向量乘积或预处理程序对稀疏矩阵的所有元素（甚至那些为零的元素）进行操作，这是我们在这里要避免的低效率。

直接解决约束自由度的一个好处是，我们可以避免在我们的稀疏矩阵中出现大部分要为零的条目&mdash；在矩阵构建过程中，我们不需要约束的条目（与传统算法相反，传统算法是先填充矩阵，之后才解决约束）。这将在形成矩阵-向量乘积时节省内存和时间。我们要做的是将约束信息传递给生成稀疏模式的函数，然后设置一个<tt>false</tt>参数，指定我们不打算使用约束条目。

[1.x.486]

顺便说一下，这个函数也避免了对稀疏模式的<tt>condense()</tt>函数的调用。




[1.x.487]

下面开发的程序已经看到了很多的TLC。我们在分析工具（主要是[1.x.488]的cachegrind和callgrind工具，以及用于可视化的KDE[1.x.489]程序）下一遍又一遍地运行它，看看瓶颈在哪里。这已经得到了回报：通过这种努力，当考虑到细化周期0到3的运行时间时，程序的速度已经提高了大约4倍，将CPU指令的总体执行数量从869,574,060,348减少到199,853,005,625。对于更高的细化水平，收益可能更大，因为一些不是[2.x.1262]的算法被取消了。

基本上，目前程序中有两种算法不随自由度数量的增加而线性扩展：自由度的重新编号（即[2.x.1263] ，以及线性求解器（即[2.x.1264] ）。至于第一个，虽然自由度的重新排序可能不是线性扩展，但它是整个算法中不可缺少的部分，因为它极大地提高了稀疏ILU的质量，很容易弥补计算重新编号的时间；证明这一点的图表和时间显示在DoFRenumbering命名空间的文档中，也强调了下面选择的Cuthill-McKee重新排序算法。

至于线性求解器：如上所述，我们在这里的实现使用了Schur补码公式。这不一定是非常好的选择，但展示了deal.II中的各种重要技术。关于哪种求解器最好的问题，在本程序的[1.x.490]中再次进行了讨论，同时还有显示备选求解器的代码和对其结果的比较。

除此以外，在这个程序的创建过程中，许多其他的算法也被测试和改进。例如，在建立稀疏性模式时，我们最初使用了一个（现在已经不存在了）BlockCompressedSparsityPattern对象，每次增加一个元素；然而，它的数据结构对于我们在3d中离散化所产生的每行大量的非零条目来说适应性很差，导致了一个二次方的行为。替换deal.II中的内部算法，一次设置许多元素，并使用BlockCompressedSimpleSparsityPattern（截至2015年初，它又被BlockDynamicSparsityPattern取代）作为一个更好的适应性数据结构，消除了这个瓶颈，代价是内存消耗略高。同样，SparseILU类中的分解步骤的实现也非常低效，已经被一个快10倍的步骤所取代。甚至SparseILU的vmult函数也得到了改进，节省了大约20%的时间。小的改进在这里和那里被应用。此外，AffineConstraints对象被用来消除稀疏矩阵中很多最终将为零的条目，见[1.x.491]。

这里显示了在3D的细化周期0到3中，CPU指令在程序中各个不同的地方花费了多少的概况。

[2.x.1265]

可以看出，在这个细化级别，大约四分之三的指令数花在实际求解上（左边的[2.x.1266]调用，中间的[2.x.1267]调用用于舒尔补码求解，另一个方框代表在求解[1.x.492]时与稀疏ILU和稀疏矩阵的乘法）。大约五分之一的指令数用于矩阵装配和稀疏ILU计算（右下角的方框），其余的用于其他方面。由于[2.x.1268]调用中的浮点运算通常比矩阵装配中的许多逻辑运算和查表要长得多，矩阵装配所占用的运行时间的比例实际上大大低于指令的比例，这在我们在结果部分的比较中会变得很明显。

对于更高的细化水平，代表求解器的方框以及右上角源自重排算法的蓝色方框将以牺牲程序的其他部分为代价而增长，因为它们不是线性扩展。在这个中等细化水平（3168个单元和93176个自由度），线性求解器已经占了大约四分之三的指令，这是一个很好的迹象，说明这个程序中使用的大多数算法都是经过良好调整的，加快程序速度的主要改进很可能不是来自手工优化的个别方面，而是通过改变求解器的算法。我们将在下面的结果讨论中也讨论这一点。

最后一点，作为参考，下图也显示了在优化这个程序的早期阶段，配置文件的样子。

[2.x.1269]

如上所述，这个版本的运行时间大约是第一个配置文件的四倍，其中SparseILU分解占用了大约30%的指令数，而操作早期低效版本的DynamicSparsityPattern大约占10%。这两个瓶颈后来都被完全消除了。


examples/step-22/doc/results.dox

[1.x.493]

[1.x.494]

[1.x.495]

[1.x.496]

在[2.x.1270]函数中空间维度设置为2的情况下运行程序，会产生以下输出（在 "释放模式 "下，[2.x.1271]）。

[1.x.497]



上述整个计算在一台相当快的（以2015年的标准）机器上需要大约2秒。

我们立即看到的是，（外部）迭代的次数并没有随着我们细化网格而增加。这证实了介绍中的说法，即用质量矩阵对Schur补码进行预处理，确实可以得到一个与身份矩阵频谱等价的矩阵（即特征值上下受限，与网格大小或单元的相对大小无关）。换句话说，质量矩阵和Schur补码在光谱上是等价的。

在下面的图片中，我们展示了程序中前六个细化步骤的网格。  观察一下网格是如何在解迅速变化的区域被细化的。在上边界，我们的迪里希特边界条件在左半边是-1，右半边是1，所以在[2.x.1272]有一个突然的变化。同样地，在两个上角也有从Dirichlet到Neumann数据的变化，所以那里也需要细化。

[2.x.1273]

最后，下面是一个流场图。它显示了流体随着上层边界的移动而被来自下层的物质所取代。

[2.x.1274]

该图使用了基于VTK的可视化程序的能力（在这种情况下是VisIt）来显示矢量数据；这是我们将使用中的有限元的速度分量声明为一组矢量分量，而不是本教程程序的[2.x.1275]函数中的独立标量分量的结果。




[1.x.498]

在3D中，程序的屏幕输出看起来像这样。

[1.x.499]



我们再次看到，随着我们对网格的细化，外迭代的次数并没有增加。然而，计算时间明显增加：对于上述每个迭代分别需要约0.14秒、0.63秒、4.8秒、35秒、2分33秒和13分12秒。这种运行时间的整体超线性（未知数的数量）增加是由于我们的内部求解器不是[2.x.1276]：一个简单的实验表明，随着我们不断细化网格，反演速度-速度块[2.x.1277]的ILU预处理的CG平均迭代次数会增加。

我们将解决如何可能改进我们的解算器[1.x.500]的问题。

至于图形输出，在解决过程中产生的网格看起来如下。

[2.x.1278]

同样，它们基本上显示了由边界条件引入的奇异点的位置。计算出的矢量场构成了一个有趣的图形。

[2.x.1279]

这里显示的等值线也是压力变量的等值线，显示了在不连续的速度边界条件下的奇异现象。




[1.x.501]

正如在生成稀疏模式时解释的那样，在使用不完全LU分解等预处理程序时，必须牢记自由度的编号。使用刚度矩阵中的非零元素的分布可以最方便地看到这一点。

如果我们不对自由度的重新编号做任何特殊处理（即不使用[2.x.1280]，而是使用[2.x.1281]来确保自由度被适当地排序到矩阵和向量的相应块中），那么我们在二维的第一次自适应细化后得到以下图像。

[2.x.1282]

为了生成这样的图表，你必须在设置步骤的末尾插入一段类似以下的代码。

[1.x.502]



可以清楚地看到，非零项几乎分布在整个矩阵中。  这使得用ILU进行预处理的效率很低。ILU生成的高斯消除（LU分解）没有填充元素，这意味着更多的暂定填充元素的遗漏将导致完整分解的近似度降低。

因此，在这个程序中，我们选择了一种更高级的元件重新编号的方法。  用[2.x.1283]进行重新编号，并将元件分组为速度和压力，得到以下输出。

[2.x.1284]

很明显，情况有了很大的改善。现在大多数元素都集中在矩阵中（0,0）块的对角线周围。其他区块也可以看到类似的效果。在这种情况下，ILU分解将更接近于完全的LU分解，这就提高了预处理程序的质量。值得注意的是，稀疏直接求解器UMFPACK在实际生成稀疏LU分解之前会对方程进行一些内部重新编号；这个过程导致了与我们从Cuthill-McKee算法中得到的模式非常相似）。

最后，我们想仔细看看三维的稀疏模式。我们只显示了矩阵的(0,0)块，还是在一次自适应细化之后。除了矩阵大小增加的事实之外，还可以看到矩阵中多了很多条目。此外，即使是优化后的重新编号，也会有相当数量的暂定填充元素。这说明了为什么UMFPACK在三维中不是一个好的选择--完整的分解需要许多新的条目，最终无法放入物理内存（RAM）。

[2.x.1285]




[1.x.503]

[1.x.504][1.x.505] 。

我们在计算结果一节中看到，外迭代次数不取决于网格大小，从可扩展性的角度看，这是最佳的。然而，如上所述，这并不适用于整个求解器。在生成矩阵[2.x.1286]和质量矩阵[2.x.1287]的逆时，我们没有研究内部迭代的数量。当然，这在二维情况下是没有问题的，我们用直接求解器对[2.x.1288]进行预处理，逆矩阵结构的[2.x.1289]操作将在一个单一的CG步骤中收敛，但这在三维情况下发生变化，我们只使用ILU预处理器。  在那里，反演[2.x.1290]所需的预处理CG步骤的数量随着网格的细化而增加，每个[2.x.1291]操作平均涉及上述细化步骤中的大约14、23、36、59、75和101次内部CG迭代。(另一方面，应用反压力质量矩阵的迭代次数总是在5次左右，在二维和三维中都是如此)。  总而言之，大部分的工作都花在了用相同的矩阵[2.x.1292]反复解决线性系统上。让这看起来更糟糕的是，我们实际上反转了一个矩阵，其大小约为整个系统矩阵的95%，并代表了稀疏模式中85%的非零条目。因此，自然的问题是，在计算块状系统的解时，用矩阵[2.x.1293]解约15次的线性系统是否合理。

当然，答案是，我们可以用其他一些（大多数时候是更好的）方法来做。然而，必须指出的是，正如我们在早期教程中所看到的那样，眼前的这个不确定系统对线性代数的要求确实比标准椭圆问题高得多。如果与类似规模的椭圆问题相比，其改进仍然相当不令人满意。无论如何，我们将在下面介绍一些对线性求解器的改进，我们将在第31步程序中用额外的选项再次重新考虑这一讨论。

[1.x.506][1.x.507] 提高线性求解过程速度的第一个尝试是选择一个道夫重排序，使ILU更接近于全LU分解，这在代码中的注释中已经提到。DoFRenumbering命名空间比较了几种对斯托克斯方程的道夫重新编号的选择。关于计算时间的最佳结果是通过调用[2.x.1294]找到的，通过该程序，内部求解器需要的操作大大减少，例如，在第4周期对[2.x.1295]进行反演的内部CG迭代约62次，而标准Cuthill-McKee-算法的迭代约75次。另外，在第4周期，对于[2.x.1296]的调用，计算时间从大约17分钟减少到11分钟。然而，King排序（以及一般由[2.x.1297]命名空间提供的排序）有一个严重的缺点--它比构建中的交易版本使用更多的内存，因为它作用于抽象图而不是由三角化提供的几何图形。在目前的情况下，重新编号需要大约5倍的内存，这就产生了一个不可行的算法，在3D的最后一个周期有120万未知数。

[1.x.508]另一个改善情况的想法是选择一个预处理程序，使(0,0)矩阵[2.x.1298]的CG在一个与网格无关的迭代次数中收敛，比如10到30次。我们在步骤16中已经看到了这样的候选方案：多网格。

[1.x.509] [1.x.510] 即使对[2.x.1299]有一个好的预处理程序，我们仍然需要反复求解同一个线性系统（虽然右手边不同），以使舒尔补码的求解趋于一致。我们这里要讨论的方法是如何将内部迭代和外部迭代结合起来。如果我们坚持计算舒尔补码，就没有其他的可能性了。

另一种方法是一次性攻击块状系统，并使用近似的Schur补码作为有效的预处理程序。其思路如下。如果我们找到一个块状预处理器[2.x.1300]，使矩阵

[1.x.511]

是简单的，那么使用该预处理程序的迭代求解器将在几次迭代中收敛。使用舒尔补码[2.x.1301]，我们发现

[1.x.512]

似乎是个不错的选择，因为

[1.x.513]

这就是引言中提到的Silvester和Wathen的论文所采取的方法（不同的是Silvester和Wathen使用了右预处理）。在这种情况下，基于Krylov的迭代方法只有在应用[2.x.1302]和[2.x.1303]的精确求逆时才会一步收敛，因为所有的特征值都是1（而这种方法的迭代次数是由不同特征值的数量所决定的）。下面，我们将讨论如何为这个问题选择一个适当的求解器。首先，我们要仔细研究一下预处理程序的实现。

由于[2.x.1304]的目的只是作为一个预处理程序，我们将使用舒尔补码[2.x.1305]和矩阵[2.x.1306]的近似反向。因此，舒尔补集将由压力质量矩阵[2.x.1307]近似，我们使用[2.x.1308]的预处理器（周围没有反矩阵类）来近似[2.x.1309]。

这里有一个实现块舒尔补码预处理的类。根据上面的推导，对块向量的[2.x.1310]操作可以通过三个连续的操作来指定。

[1.x.514]



由于我们现在对整个区块系统采取行动，我们必须忍受一个缺点：我们需要对整个区块系统而不是较小的压力空间进行求解器迭代。

现在我们转向我们应该对块系统使用哪种求解器的问题。第一个观察结果是，所产生的预处理矩阵不能用CG求解，因为它既不是正定也不是对称的。

deal.II库实现了几个适合手头问题的求解器。一种选择是求解器[2.x.1311]"BiCGStab"，它被用于解决步骤9中的非对称平流问题。第二个选择，也就是我们要选择的，是[2.x.1312] "GMRES"（广义最小残差）。这两种方法都有其优点和缺点--在有些问题上，两种候选方法中的一种明显优于另一种，反之亦然。[1.x.515]关于GMRES方法的文章给出了一个比较的介绍。更全面和有根据的比较可以在J.W.Demmel的书中读到（Applied Numerical Linear Algebra, SIAM, 1997, section 6.6.6）。

对于我们用ILU预处理[2.x.1313]的具体问题，对于大的问题规模，我们当然需要在块系统上进行数百次迭代（我们不会打败CG！）。实际上，这不利于GMRES。在GMRES迭代过程中，Krylov向量的基础被陆续建立起来，并对这些向量进行一些操作。这个基础上的向量越多，需要的操作和内存就越多。操作的数量以[2.x.1314]的形式扩展，内存以[2.x.1315]的形式扩展，其中[2.x.1316]是Krylov基础中的向量数量，[2.x.1317]是（块）矩阵的大小。为了不让这些需求过度增长，deal.II将基的大小[2.x.1318]默认限制为30个向量。然后，重新建立基。这种GMRES方法的实现被称为GMRES(k)，默认为 [2.x.1319] 。我们通过这一限制所获得的东西，即对操作和内存需求的约束，将被我们使用不完整的基础这一事实所补偿--这将增加所需的迭代次数。

另一方面，当需要多次迭代时，BiCGStab不会变慢（一次迭代只使用前面一个步骤的结果，而不是像GMRES那样使用所有的步骤）。除了BiCGStab由于需要两个矩阵-向量乘积（相比之下，CG或GMRES只需要一个），所以每一步的成本更高之外，还有一个主要原因使得BiCGStab不适合这个问题：预处理程序通过使用InverseMatrix类应用压力质量矩阵的逆。由于向量的逆矩阵应用只是以近似的方式进行（精确的逆太昂贵了），这也会影响求解器。在BiCGStab的情况下，由于这种扰动，Krylov向量将不会是正交的。虽然这对于少量的步骤（最多50步）来说是不关键的，但当这些扰动在迭代的粗放中增长到相当大的程度时，它就会破坏求解器的性能。

我们用BiCGStab做了一些实验，发现它在细化周期3之前比GMRES快（在3D中），但在周期4和5时变得非常慢（甚至比原来的Schur补码还慢），所以在这种情况下求解器是没有用的。为逆矩阵类选择一个更尖锐的容忍度（[2.x.1320]而不是[2.x.1321]）使BiCGStab在第4周期也表现良好，但没有改变在非常大的问题上的失败。

当然，GMRES也会受到近似求逆的影响，但它对正交性不那么敏感，而且对于大尺寸也能保持相对较好的性能，见下面的结果。

说到这里，我们转向用[2.x.1322]临时向量的GMRES实现求解器调用。

[1.x.516]



显然，人们需要添加include文件[2.x.1323]"<lac/solver_gmres.h>"以使其运行。我们用BlockVector模板来调用求解器，以便使GMRES能够对块状向量和矩阵进行操作。还要注意的是，在我们将信息复制到另一个矩阵之后，我们需要将系统矩阵中的（1,1）块设置为零（我们将压力质量矩阵保存在那里，这不是问题的一部分）。

使用定时器类，我们收集了一些统计数据，将块状求解器的运行时间与上述问题实现中的运行时间进行比较。除了两个选项的解决方案，我们还检查了两个变体的解决方案是否接近（即这个求解器给出的解决方案确实与我们之前的解决方案相同），并计算矢量差的无穷大准则。

让我们先看看二维的结果。

[1.x.517]



我们看到，块状舒尔补码预处理求解器和舒尔补码本身在求解时间上没有巨大差异。原因很简单：我们使用直接求解作为[2.x.1324]的预处理程序--所以我们不能指望通过避免内部迭代获得任何收益。我们看到，GMRES的迭代次数略有增加，但总的来说，这两种选择是相当相似的。

画面当然会发生三维变化。

[1.x.518]



在这里，块状预处理求解器明显优于Schur补数，但是网格点越多，优势就越小。这是因为GMRES(k)随着问题规模的扩大比CG更差，正如我们上面所讨论的。  尽管如此，对于中等规模的问题，3-6倍的改进是相当令人印象深刻的。




[1.x.519]这个问题的终极线性求解器可以想象为[2.x.1325]的最佳预处理器（如多网格）和上述的块状预处理器的组合，这就是步骤31和步骤32教程程序（我们使用代数多网格方法）和步骤56（我们使用几何多网格方法）中所采取的方法。




[1.x.520] 另一个可以考虑的可能性是不设置块状系统，而是一次性解决速度和压力系统。可以选择用UMFPACK直接求解（2D）或用ILU预处理的GMRES（3D）。这应该是很直接的尝试。




[1.x.521]

当然，这个程序也可以作为计算更有趣的情况下的流动的基础。编写这个程序的最初动机是希望它能成为一些地球物理流动问题的起点，例如大陆板块漂移分离的地方（例如洋中脊）下的岩浆运动。当然，在这种地方，几何形状比上面的例子更复杂，但要适应这种情况并不难。

例如，通过使用以下对边界值函数的修改

[1.x.522]

和以下方式生成网格作为域[2.x.1326]。

[1.x.523]

那么我们就会得到断层线是弯曲的图像。  [2.x.1327]


examples/step-23/doc/intro.dox

[1.x.524]

[1.x.525]

[2.x.1328]

这是一系列教程程序中的第一个，它将最终涵盖 "真正的 "时间依赖问题，而不是步骤18中发现的略显奇怪的时间依赖形式或步骤21的DAE模型。特别是，这个程序介绍了有界域中的波浪方程。后来，第24步将考虑一个吸收边界条件的例子，以及[2.x.1329]"第25步 "一种产生称为孤子的解的非线性波方程。

波浪方程的原型形式如下：找到满足以下条件的[2.x.1330]。

[1.x.526]

请注意，由于这是一个具有二阶时间导数的方程，我们需要提出两个初始条件，一个是值，一个是解的时间导数。

在物理上，该方程描述了弹性介质的运动。在二维空间中，我们可以考虑膜在受到力的作用下如何运动。上面的Dirichlet边界条件表明，膜被夹在边界的高度[2.x.1331]（这个高度可能也在移动&mdash；想想人们拿着毯子上下摇晃）。第一个初始条件等于膜的初始偏转，而第二个初始条件给出了其速度。例如，我们可以考虑用手指把膜推下去，然后在[2.x.1332]处让它离开（非零偏转但零初始速度），或者在[2.x.1333]处用锤子砸它（零偏转但非零速度）。这两种情况都会引起膜的运动。




[1.x.527]

[1.x.528]在数值分析界有一个长期的争论，即时间依赖方程的离散化是否应该首先离散时间变量，导致每个时间步长的静止PDE，然后用标准的有限元技术来解决（这被称为Rothe方法），或者是否应该首先离散空间变量，导致一个大型的常微分方程系统，然后用一个通常的ODE求解器来处理（这被称为线的方法）。

这两种方法都有优点和缺点。传统上，人们更倾向于线的方法，因为它允许使用非常发达的高阶ODE求解器，可用于由这种方法产生的相当刚性的ODE，包括步长控制和时间误差的估计。

另一方面，当使用高阶时间步长法时，罗特的方法变得很尴尬，因为这时人们必须写下一个PDE，将当前时间步长的解与前一个时间步长的解结合起来，而且可能还有更早的解，从而导致大量的条款。

由于这些原因，线条法在很长一段时间内都是人们的首选方法。然而，它有一个很大的缺点：如果我们先将空间变量离散化，导致一个大的ODE系统，我们必须一劳永逸地选择一个网格。如果我们愿意这样做，那么这就是一种合法的、可能是优越的方法。

另一方面，如果我们看的是波浪方程和其他许多与时间有关的问题，我们会发现，随着时间的推移，解的特征会发生变化。例如，对于波浪方程，我们可能有一个单一的波浪穿过域，在波浪的前后，解是平滑的，甚至是恒定的&mdash;自适应性对于这种情况确实很有用，但关键是我们需要细化网格的区域会随着时间步数的变化而变化!

如果我们打算这样做，即为每个时间步长（或一组时间步长）选择不同的网格，那么线段法就不再合适了：我们不是得到一个变量数等于有限元网格中未知数数量的ODE系统，而是未知数的数量一直在变化，这是标准ODE求解器肯定不准备处理的事实。另一方面，对于罗特方法，我们只是在每个时间步长得到一个PDE，我们可以选择独立于前一个时间步长所用的网格进行离散化；这种方法并非没有危险和困难，但至少是一个合理的、定义明确的程序。

由于所有这些原因，在本程序中，我们选择使用Rothe方法进行离散化，即我们首先在时间上进行离散化，然后在空间上离散化。我们实际上根本不会使用自适应网格，因为这涉及到大量的额外代码，但我们将在[1.x.529]中对此作一些评论。




[1.x.530]

鉴于这些考虑，我们将这样做：让我们首先为这个二阶问题定义一个简单的时间步进方法，然后在第二步做空间离散化，即我们将遵循Rothe的方法。

对于第一步，让我们先绕一点路：为了离散化一个第二时间导数，我们可以直接离散化它，或者引入一个额外的变量，将系统转化为一阶系统。在许多情况下，这证明是等价的，但处理一阶系统往往更简单。为此，让我们引入

[1.x.531]

并称这个变量为[1.x.532]，原因很明显。然后，我们可以将原来的波浪方程重新表述如下。

[1.x.533]

这个公式的优点是它现在只包含两个变量的第一时间导数，对于它来说，写下时间步进方案很简单。请注意，我们起初没有[2.x.1334]的边界条件。然而，我们可以在边界上强制执行[2.x.1335]。在数值例子中发现，这实际上是必要的：如果不这样做，解决方案看起来并不特别错误，但如果不执行这些边界条件，Crank-Nicolson方案并不保存能量。

有了这个公式，让我们引入以下时间离散化，其中上标[2.x.1336]表示一个时间步长，[2.x.1337]是当前时间步长。

[1.x.534] 注意我们在这里引入了一个参数[2.x.1338]。例如，如果我们选择[2.x.1339]，第一个方程将简化为[2.x.1340]，这就是众所周知的正向或显式欧拉方法。另一方面，如果我们设定[2.x.1341]，那么我们将得到[2.x.1342]，这对应于后向或隐式欧拉方法。这两种方法都是一阶精确方法。它们实现起来很简单，但其实并不十分精确。

第三种情况是选择[2.x.1343] 。然后上面的第一个方程将变成[2.x.1344] 。这种方法被称为Crank-Nicolson方法，它的优点是二阶精确。此外，它还有一个很好的特性，即保留了溶液中的能量（从物理上讲，能量是膜中粒子的动能加上由于局部拉伸而存在的势能的总和；这个量在连续方程中是一个守恒量，但大多数时间步进方案在时间离散化后并不保留它）。由于[2.x.1345]也出现在[2.x.1346]的方程中，Crank-Nicolson方案也是隐式的。

在程序中，我们将把[2.x.1347]作为一个参数，这样就很容易发挥它的作用了。结果部分将显示一些比较不同方案的数字证据。

上面的方程（称为[1.x.535]方程，因为我们只离散了时间，而没有离散空间），可以通过从第一个方程中消除[2.x.1348]和重新排列项来简化一下。然后我们得到

[1.x.536]在这种形式下，我们看到，如果我们得到了前一个时间段的解[2.x.1349]，那么我们就可以分别求解变量[2.x.1350]，也就是一次一个。这很方便。此外，我们认识到第一个方程中的算子是正定的，而第二个方程看起来特别简单。




[1.x.537]

我们现在已经得出了将时间[2.x.1351]的近似（半离散）解[2.x.1352]及其时间导数[2.x.1353]与前一个时间步骤[2.x.1355]的解[2.x.1354]相关的方程。下一步是使用通常的有限元方法将空间变量离散化。为此，我们将每个方程与一个测试函数相乘，在整个域上进行积分，并在必要时进行部分积分。这就导致了

[1.x.538]

然后习惯于近似[2.x.1356] ，其中[2.x.1357] 是用于离散化[2.x.1358] -个时间步长的形状函数，[2.x.1359] 是解决方案的未知结点值。同样地，[2.x.1360] 。最后，我们有前一个时间步骤的解， [2.x.1361] 和 [2.x.1362] 。请注意，由于在我们到达时间步骤[2.x.1363]时，前一个时间步骤的解已经被计算出来了，所以[2.x.1364]是已知的。此外，注意上一步的解可能是在不同的网格上计算的，所以我们必须使用形状函数 [2.x.1365] 。

如果我们将这些扩展插入上述方程，并用本网的测试函数进行测试，我们得到以下线性系统。

[1.x.539] 其中

[1.x.540]



如果我们解决这两个方程，我们可以将解决方案向前推进一步，并进入下一个时间步骤。

值得注意的是，如果我们在每个时间步长选择相同的网格（事实上我们将在下面的程序中这样做），那么我们在时间步长[2.x.1366]和[2.x.1367]上有相同的形状函数，即[2.x.1368] 。因此，我们得到 [2.x.1369] 和 [2.x.1370] 。另一方面，如果我们使用了不同的形状函数，那么我们将不得不计算包含定义在两个网格上的形状函数的积分。这是一个有些混乱的过程，我们在此省略，但在步骤28中会有一些详细的处理。

在这些条件下（即网格不发生变化），我们可以通过基本消除第二个线性系统的解来优化求解过程。我们将在[2.x.1371]"step-25 "程序的介绍中讨论这个问题。

[1.x.541]

比较时间步进方案质量的一个方法是看数值近似是否保留了连续方程的守恒特性。对于波浪方程来说，自然要看的是能量。通过将波浪方程乘以[2.x.1372]，对[2.x.1373]进行积分，并在必要时进行部分积分，我们发现

[1.x.542]

因此，在没有体力和恒定边界值的情况下，我们得到的结果是

[1.x.543]

是一个守恒量，即一个不随时间变化的量。我们将在每个时间步骤后计算这个量。很容易看出，如果我们用有限元近似值代替[2.x.1374]，用速度的有限元近似值代替[2.x.1375]，那么

[1.x.544]

正如我们将在结果部分看到的，Crank-Nicolson方案确实保存了能量，而前向和后向Euler方案都没有。




[1.x.545]

波浪方程的数值求解很麻烦，原因之一是显式时间离散化只有在时间步长足够小的情况下才稳定。特别是，它与空间网格宽度有耦合关系 [2.x.1377] 。对于我们这里使用的最低阶离散化，其关系为

[1.x.546]

其中[2.x.1378]是波速，在我们对波浪方程的表述中，它已被归一。因此，除非我们使用带有[2.x.1379]的隐式方案，否则如果我们违反这一限制，我们的解在数值上是不稳定的。隐式方案在稳定性方面没有这个限制，但如果时间步长过大，它们就会变得不准确了。

这一条件是由库兰特、弗里德里希斯和卢伊首先认识到的；在1928年，远在计算机可用于数值计算之前！（这一结果出现在德语文章R.库兰特、K.弗里德里希斯和H.卢伊中。这个结果出现在德语文章R.Courant, K. Friedrichs and H. Lewy:[1.x.547], Mathematische Annalen, vol. 100, no. 1, pages 32-74, 1928.)这个关于时间步长的条件最常被称为[1.x.548]条件。直观地说，CFL条件说的是，时间步长不能大于一个波穿过一个单元的时间。

在程序中，我们将对正方形[2.x.1380]均匀地细化七次，得到的网格尺寸为[2.x.1381] ，这就是我们设置的时间步长。我们在两个不同的地方分别设置时间步长和网格尺寸是很容易出错的：很容易再细化一次网格，却忘记同时调整时间步长。  [2.x.1382] "step-24 "显示了一个更好的方法来保持这些东西的同步。




[1.x.549]

尽管该程序具有处理非零初始和边界条件以及体力的所有钩子，但我们采取一个简单的案例，即领域是一个正方形[2.x.1383]，并且

[1.x.550]

这相当于一个最初处于静止状态、四周被夹住的膜，有人将夹住的边界的一部分上下挥动一次，从而将波射入领域。


examples/step-23/doc/results.dox



[1.x.551]

当该程序运行时，它产生了以下输出。

[1.x.552]



我们立即看到的是，至少在[2.x.1384]之后，能量是一个常数（在此之前，边界源项[2.x.1385]是非零的，向系统注入能量）。

除了屏幕输出外，程序还将每个时间步骤的解写到输出文件中。如果我们对其进行充分处理，并将其粘贴到电影中，我们会得到以下结果。

[2.x.1386]

影片显示了所产生的波在域中移动并返回，在夹持的边界处被反射。一些数值噪声跟在波的后面，这是由于网格尺寸过大造成的假象，可以通过减小网格宽度和时间步长来减少。


[1.x.553]

[1.x.554]

如果你想探索一下，可以尝试以下一些东西。  [2.x.1387] [2.x.1388] Varying [2.x.1389] 。这给出了不同的时间步进方案，其中一些是稳定的，而另一些则不是。看一看能量是如何演变的。

   [2.x.1390] 不同的初始和边界条件，右手边。

   [2.x.1391] 更复杂的域或更精细的网格。请记住，时间步长需要以网格宽度为界，所以改变网格也应该包括改变时间步长。我们将在第24步再来讨论这个问题。

   [2.x.1392] 可变系数。在现实介质中，波速往往是可变的。特别是，现实介质中的 "真实 "波浪方程将读作[1.x.555]

  其中[2.x.1393]是材料的密度，[2.x.1394]与刚度系数有关。那么波速就是 [2.x.1395] 。

  为了做出这样的改变，我们将不得不用可变系数来计算质量和拉普拉斯矩阵。幸运的是，这并不难：函数[2.x.1396]和[2.x.1397]有额外的默认参数，可以用来向它们传递非恒定系数函数。因此，所需的变化相对较小。另一方面，必须再次注意确保时间步长在允许范围内。

   [2.x.1398] 在代码内的注释中，我们讨论了这样一个事实：由于边界条件的原因，用于求解[2.x.1399]和[2.x.1400]的矩阵需要在每次都被重置，尽管实际内容没有变化。可以通过不消除线性系统中的列来避免复制，这可以通过在调用中附加一个[2.x.1401]参数来实现。   [1.x.556]



   [2.x.1402] deal.II是一个支持自适应网格的库，如果这个程序支持每隔几步就改变网格，那当然很好。考虑到解决方案的结构&mdash; 一个穿越领域的波浪&mdash; 如果我们只在波浪目前所在的地方完善网格，而不是简单地在所有地方完善网格，这似乎是合适的。直观地看，我们应该能够通过这种方式节省大量的单元。虽然经过进一步的思考，我们意识到这只是在模拟的初始阶段。   一段时间后，对于波浪现象来说，域中充满了初始波的反射，向各个方向发展，充满了域中的每个角落。   在这一点上，一般来说，使用局部网格细化可以获得的好处不多）。)

  为了使自适应改变网格成为可能，基本上有两条路线。   "正确 "的方法是回到我们使用罗特方法得到的弱形式。例如，在每个时间步骤中要解决的两个方程中的第一个方程看起来是这样的。   [1.x.557] 现在，注意我们在网格[2.x.1404]上求解[2.x.1403]，因此测试函数[2.x.1405]也必须来自空间[2.x.1406]。正如在介绍中所讨论的，像[2.x.1407]这样的条款要求我们将上一步的解决方案（可能是在不同的网格[2.x.1408]上计算的）与当前网格的测试函数进行整合，从而得到一个矩阵[2.x.1409]。这个整合不同网格的形状函数的过程，充其量是尴尬的。它是可以做到的，但是因为很难保证[2.x.1410]和[2.x.1411]最多只相差一个细化级别，所以我们必须递归匹配两个网格的单元。这样做是可行的，但它会导致冗长的、不完全明显的代码。

  第二种方法如下：每当我们改变网格时，我们只需使用SolutionTransfer类将旧网格上的最后一个时间步长的解内插到新网格上。换句话说，我们将解决[1.x.558]，其中[2.x.1412]将一个给定的函数插值到网格[2.x.1413]，而不是上面的方程。   这是一个更简单的方法，因为在每个时间步长中，我们不再需要担心[2.x.1414]是在我们现在使用的同一个网格上计算的，还是在不同的网格上计算的。因此，代码的唯一变化是增加了一个计算误差的函数，为细化标记单元，设置SolutionTransfer对象，将解转移到新的网格上，并在新的网格上重建矩阵和右手向量。建立矩阵和右手边的函数以及求解器都不需要改变。

  虽然严格来说，这第二种方法在罗特框架中是不太正确的（它引入了一个额外的误差源，即插值），然而这几乎是每个人在解决时间相关方程时所做的事情。我们将在步骤31中使用这种方法，例如。  [2.x.1415]


examples/step-24/doc/intro.dox

[1.x.559]

[1.x.560]

这个项目是由德克萨斯A&amp;M大学的Xing Jin的一个学生项目发展而来。本程序的大部分工作是由她完成的。这个教程程序的部分工作得到了美国国家科学基金会DMS-0604778号拨款的资助。

该计划是一个旨在模拟热声断层成像的项目的一部分。在热声断层成像中，脉冲电磁能量被送入生物问题。组织吸收一些这种能量，组织中吸收能量最多的那些部分通过热弹性膨胀产生热声波。对于成像来说，人们利用不同种类的组织，最重要的是健康和病变组织，吸收不同数量的能量，因此以不同的速度膨胀。实验装置是测量这些源在组织表面产生的压力波的振幅，并试图重建源的分布，这对吸收器的分布有指示作用，因此对不同种类的组织有指示作用。这个项目的一部分是将模拟数据与实际测量进行比较，因此必须解决 "正向问题"，即描述压力波在组织中传播的波浪方程。因此，这个程序是[2.x.1416]"step-23 "的延续，其中首次介绍了波浪方程。




[1.x.561]

在忽略热扩散的情况下，某个位置的温度可以表示为

[1.x.562]



这里[2.x.1417]是密度；[2.x.1418]是比热；[2.x.1419]是由于传递的微波能量引起的温升；[2.x.1420]是加热函数，定义为由沉积的微波能量转化的每一时间和体积的热能。

让我们假设组织具有异质的介电特性，但具有同质的声学特性。在声学均质介质中的基本声学生成方程可以描述如下：如果[2.x.1421]是矢量值的位移，那么组织肯定通过加速度对压力的变化做出反应。

[1.x.563]

此外，它因压力过大而收缩，并根据温度的变化而膨胀。

[1.x.564]

这里，[2.x.1422]是一个热膨胀系数。

现在让我们假设，加热只发生在比波在组织中传播短得多的时间尺度上（即加热组织的微波脉冲的时间长度远短于波穿过领域的时间）。在这种情况下，加热率[2.x.1423]可以写成[2.x.1424]（其中[2.x.1425]是微波能量的吸收强度图，[2.x.1426]是狄拉克三角函数），与上述第一个方程一起将产生温度[2.x.1427]在时间[2.x.1428]的瞬时跳跃。利用这一假设，并将所有方程放在一起，我们可以将上述内容重写并合并为以下内容。

[1.x.565]

其中[2.x.1429] 。

这个有点奇怪的方程，右边是狄拉克三角函数的导数，可以重写为一个初值问题，如下所示。

[1.x.566]

(在本引言的最后，作为附录给出了这种转化为初值问题的推导)。

在逆向问题中，人们希望恢复的是初始条件[2.x.1430]，因为它是微波能量的吸收强度图，因此可能是分辨健康和病变组织的指标。

在实际应用中，热声源相对于介质来说是非常小的。  因此，热声波的传播路径可以被近似为从源头到无限远。此外，检测器离源头只有有限的距离。我们只需要评估热声波通过检测器时的数值，尽管它们确实继续超出。因此，这是一个我们只对无限介质的一小部分感兴趣的问题，我们不希望某个地方产生的波在我们认为有趣的领域的边界上被反射。相反，我们希望只模拟包含在感兴趣的领域内的那部分波场，而碰到该领域边界的波则不受干扰地通过边界。换句话说，我们希望边界能吸收撞击它的任何波。

一般来说，这是一个困难的问题：好的吸收边界条件是非线性的和/或数值上非常昂贵。因此，我们选择了一个简单的一阶近似吸收边界条件，其内容为

[1.x.567]

这里，[2.x.1431]是边界处的法向导数。应该指出的是，这不是一个特别好的边界条件，但它是少数几个合理简单的实现条件之一。




[1.x.568]

如同步骤23，首先引入第二个变量，定义为压力势的导数。

[1.x.569]



有了第二个变量，我们就可以将正向问题转化为两个独立的方程式。

[1.x.570]

具有初始条件。

[1.x.571]

注意，我们在这里引入了一个右手边[2.x.1432]，以显示如何在一般情况下推导这些公式，尽管在应用于热声问题时[2.x.1433] 。

然后，使用步骤23中介绍的一般[2.x.1434]方案，这个模型的半具体化、弱化版本是。

[1.x.572]

其中[2.x.1435]是一个任意的测试函数，我们使用了吸收边界条件来进行部分积分：吸收边界条件通过使用以下方法被纳入到弱形式之中

[1.x.573]



由此，我们通过引入有限数量的形状函数得到离散模型，并得到

[1.x.574]

这里的矩阵[2.x.1436]和[2.x.1437]与步骤23相同，而边界质量矩阵

[1.x.575]

是使用吸收性边界条件的结果。

以上两个方程可以用矩阵形式重写，压力和它的导数是一个未知矢量。

[1.x.576]



其中

[1.x.577]



通过简单的转换，就可以得到压力势及其导数的两个方程，就像前面的教程程序一样。

[1.x.578]






[1.x.579]

与Step-23相比，本程序增加了对简单吸收边界条件的处理。此外，它还处理了从实际实验测量得到的数据。为此，我们需要在实验也评估了真实压力场的点上评估解决方案。我们将看到如何使用[2.x.1438]函数在下文中进一步做到这一点。




[1.x.580]

在推导波浪方程的初值问题时，我们最初发现该方程有一个狄拉克三角函数的导数作为右手边。

[1.x.581]

为了看看如何将这个单一的方程转化为具有初始条件的PDE的通常陈述，让我们假设物理上相当合理的介质最初处于静止状态，即[2.x.1439]为[2.x.1440] 。接下来，让我们对两边的时间形成不确定的积分。

[1.x.582]

这立即引出了一个说法

[1.x.583]

其中[2.x.1441]是这样的：[2.x.1442] 。接下来，我们对[2.x.1443]到[2.x.1444]的时间进行（定）积分，以求得

[1.x.584]

如果我们利用三角洲函数的属性，即[2.x.1445]，并假设[2.x.1446]是一个时间上的连续函数，我们发现当我们让[2.x.1447]归零时，我们发现

[1.x.585]

换句话说，利用[2.x.1448]，我们找回了初始条件

[1.x.586]

同时，我们知道，对于每一个[2.x.1449]，三角洲函数都是零，所以对于[2.x.1450]，我们得到的方程式是

[1.x.587]

因此，我们从原来有些奇怪的方程中得到了一个波浪方程和一个初始条件的表示。

最后，由于我们这里有一个带有两个时间导数的方程，我们仍然需要第二个初始条件。为此，让我们回到方程中去

[1.x.588]

并从[2.x.1451]到[2.x.1452]进行时间整合。这就导致了

[1.x.589]

使用部分整合的形式

[1.x.590]

在这里我们使用[2.x.1453]并插入[2.x.1454]，我们看到事实上

[1.x.591]



现在，让[2.x.1455] 。假设[2.x.1456]是一个时间上的连续函数，我们看到

[1.x.592]

因此

[1.x.593]

然而，我们已经假设[2.x.1457] 。因此，我们得到的第二个初始条件是

[1.x.594]

完成方程组。


examples/step-24/doc/results.dox



[1.x.595]

该程序将每个时间步骤的图形数据以及每个探测器位置的评估值都写入磁盘。然后我们将它们绘制成图。还收集了实验数据进行比较。目前，我们的实验只在二维空间通过圆形扫描单个探测器进行。这里的组织样本是[2.x.1458]平面的薄片（[2.x.1459]），我们假设其他[2.x.1460]方向的信号不会对数据产生影响。因此，我们只需要将我们的实验数据与二维模拟数据进行比较。

[1.x.596]

这部电影显示了由单个小吸收器产生的热声波在介质中传播（在我们的模拟中，我们假设介质是矿物油，其声速为1.437 [2.x.1461] ）。

[2.x.1462]

对于单个吸收器，我们当然要相应地改变[2.x.1463]类。

接下来，让我们比较一下实验和计算的结果。可视化使用了一种在地震学中长期使用的技术，即把每个探测器的数据全部绘制在一张图上。这样做的方法是将每个探测器的信号与前一个探测器相比偏移一点。例如，这里是前四个探测器的图（从下到上，时间从左到右为微秒），使用程序中使用的源设置，与目前只有一个源的情况相比，使事情更有趣。

[2.x.1464]

例如，可以看到的一点是，第二和第四个信号的到达时间在探测器数量较多的情况下（即最上面的探测器）会转移到较早的时间，但第一和第三信号则不然；这可以解释为这些信号的起源必须比前者更接近后一个探测器。

如果我们不仅将4个，而是将所有160个探测器堆叠在一张图中，单个线条就会变得模糊，但在它们运行在一起的地方，就会形成一种较深或较浅的灰度模式。  下面两张图显示了在以这种方式堆叠的探测器位置获得的结果。左图是由实验得到的，右图是模拟数据。在实验中，一个小的强吸收器被嵌入到较弱的吸收组织中。

[2.x.1465]

很明显，在角度[2.x.1466]处，源的位置离探测器更近。在实验数据中可以看到的所有其他信号都是由于组织的其他部分也有弱的吸收体，这些吸收体环绕着中心的小强吸收体产生的信号。另一方面，在模拟数据中，我们只模拟了小的强吸收体。

在现实中，探测器的带宽有限。因此，通过探测器的热声波将被过滤掉。通过使用高通滤波器（在MATLAB中实现并针对本程序产生的数据文件运行），可以使模拟结果看起来更接近于实验数据。

[2.x.1467]

在我们的模拟中，我们看到主波后面的假信号是由数值伪影造成的。这个问题可以通过使用更细的网格来缓解，从而得到下面的图。

[2.x.1468]




[1.x.597]

为了进一步验证该程序，我们还将展示多个吸收器的模拟结果。这与程序中实际实现的情况相对应。下面的影片显示了由多个吸收器产生的热声波在介质中的传播情况。

[2.x.1469]

实验数据和我们的模拟数据在以下两个图中进行了比较。  [2.x.1470]

请注意，在实验数据中，第一个信号（即最左边的暗线）来自于组织边界的吸收，因此首先到达检测器，比来自内部的任何信号都要早。这个信号在痕迹的末端也是微弱可见的，大约在30[2.x.1471]，这表明信号穿过整个组织到达另一侧的探测器，在所有来自内部的信号到达它们之后。

和以前一样，通过应用符合探测器实际行为的带宽滤波器（左）和选择更细的网格（右），数值结果与实验结果更加匹配。

[2.x.1472]

左图和右图的一个重要区别是，右图的曲线看起来没有那么多 "棱角"。角度来自于这样一个事实：虽然连续方程中的波在各个方向上的移动速度相同，但离散化后的情况并非如此：在那里，对角线上的波与平行于网格线的波的移动速度略有不同。这种各向异性导致波前不是完全的圆形（在堆积图中会产生正弦信号），而是在某些方向上凸出。更糟糕的是，我们使用的圆形网格（例如，见步骤6的粗略网格图）也不是各向同性的。最终的结果是，除非网格足够细，否则信号锋面不是正弦波的。右图在这方面要好得多，尽管仍然可以看到拖尾假波形式的伪影。


examples/step-25/doc/intro.dox

[1.x.598] [1.x.599]。

这个程序是由德克萨斯A&amp;M大学的Ivan Christov的一个学生项目发展而来的。这个程序的大部分工作都是由他完成的。

这个程序的目标是解决1、2或3空间维度的正弦戈登孤子方程。解决这个方程的动机是对二维和三维解的性质知之甚少，尽管一维情况已经被广泛研究。

确切地说，正弦-戈登方程的名称是对所谓的克莱因-戈登方程的双关语，它是薛定谔方程的相对论版本，适用于非零质量的粒子。这种相似性不仅仅是表面的，正弦-戈登方程已经被证明可以模拟一些统一场现象，如亚原子粒子的相互作用（见，例如，Perring &amp; Skyrme in Nuclear %Physics [1.x.600]）和超导体结中的约瑟夫森（量子）效应（见，例如[1.x.601]）。此外，从数学的角度来看，由于正弦戈登方程是 "完全可积分的"，它是使用反散射变换等通常方法研究的候选者。因此，多年来，人们发现了许多有趣的孤波，甚至是静止的正弦戈登方程解。在这些解中，粒子对应于局部特征。关于正弦戈登方程、反散射变换和其他寻找分析性孤子方程的方法的更多信息，读者应参考以下关于该主题的 "经典 "参考资料。G. L. Lamb的[1.x.602]（第5章，第2节）和G. B. Whitham的[1.x.603]（第17章，10-13节）。

[2.x.1473] 我们将在第58步中介绍量子力学中一个单独的非线性方程，即非线性Schr&ouml;dinger方程。

[1.x.604] 我们希望解决的正弦戈登初始边界值问题（IBVP）由以下方程组成。

[1.x.605] 这是一个非线性方程，类似于我们在步骤23和步骤24中讨论的波浪方程。我们选择执行零诺伊曼边界条件，以使波从我们的域的边界上反射出去。然而，应该注意的是，迪里希特边界条件对这个问题并不合适。尽管正弦戈登方程的解是局部的，但只有在[2.x.1474]处指定（迪里希特）边界条件才有意义，否则要么不存在解，要么只存在微不足道的解[2.x.1475]。

然而，上述方程的形式对于数值离散化来说并不理想。如果我们要直接准确地离散二阶时间导数，那么我们将需要一个大的模板（即需要在内存中保留几个时间步长），这可能变得很昂贵。因此，与我们在步骤23和步骤24中所做的完全类似，我们将二阶（时间上）正弦-戈登方程拆分为两个一阶（时间上）方程系统，我们称之为拆分，或速度公式。为此，通过设置[2.x.1476]，很容易看到正弦-戈登方程等同于

[1.x.606]

现在，我们可以使用[2.x.1477]方法对分裂公式进行时间离散，该方法的模板只有两个时间步长。通过选择[2.x.1478]，后者的离散化允许我们从一系列的方案中进行选择。特别是，如果我们选择[2.x.1479]或[2.x.1480]，我们可以分别得到一阶精确的显式或隐式欧拉方法。另一个重要的选择是[2.x.1481]，它给出了二阶精确的Crank-Nicolson方案。因此，上标[2.x.1482]表示在[2.x.1483]时间步长的变量值，即在[2.x.1484]，其中[2.x.1485]是（固定）时间步长。因此，时间分解的正弦-戈登方程的拆分表述为

[1.x.608]

我们可以通过一点代数来简化后者。从第一个方程中排除[2.x.1486]并重新排列，我们可以得到

[1.x.609]

在这一点上，我们似乎可以直接进行空间离散化的方程。虽然这对第二个方程（在[2.x.1487]中是线性的）来说是正确的，但这对所有的[2.x.1488]来说是不可行的，因为上面的第一个方程是非线性的。因此，必须实现一个非线性求解器，然后将方程在空间中离散化并求解。

为此，我们可以使用牛顿方法。给定非线性方程[2.x.1489]，我们对[2.x.1490]产生连续的近似值，如下。

[1.x.610] 迭代可以用旧的时间步长进行初始化，即[2.x.1491] ，最终会产生分裂公式的第一个方程的解（见上文）。对于这里所考虑的正弦-戈登方程的时间离散化，我们有

[1.x.611] 注意，虽然[2.x.1492]是一个函数，但[2.x.1493]是一个运算符。

[1.x.612] 事后看来，我们选择解和检验空间都是[2.x.1494] 。因此，乘以测试函数[2.x.1495]并进行积分，我们得到每个时间步长的分裂公式（包括第一个方程的非线性求解器）的以下变分（或弱）公式。

[1.x.613]注意，我们在涉及拉普拉斯算子的所有项上使用了分项积分和零诺伊曼边界条件。此外，[2.x.1496]和[2.x.1497]如上定义，[2.x.1498]表示域[2.x.1500]上通常的[2.x.1499]内积，即[2.x.1501] 。最后，请注意，第一个方程实际上是一个迭代程序的定义，所以在每个时间步骤中，它被多次解决，直到满足停止标准。

[1.x.614]使用有限元方法，我们在空间中离散变量公式。为此，让[2.x.1502]成为一个具有节点基[2.x.1505]的有限元空间（[2.x.1504]）。现在，我们可以用节点基来展开弱公式（见上文）中的所有函数。此后，我们将用大写字母表示一个函数的系数向量（在节点基中），用小写字母表示；例如，[2.x.1506] 其中[2.x.1507] 和[2.x.1508] 。因此，变量公式的有限维版本要求我们在每个时间步长中解决以下矩阵方程。

[1.x.615]

以上，矩阵[2.x.1509]和向量[2.x.1510]表示上面讨论的小工具的离散版本，即。

[1.x.616] 再次注意，上面的第一个矩阵方程实际上是迭代程序的定义，所以它被多次求解，直到满足停止标准。此外，[2.x.1511]是质量矩阵，即[2.x.1512] ，[2.x.1513]是拉普拉斯矩阵，即[2.x.1514] ，[2.x.1515] 是定义我们的辅助速度变量的方程中的非线性项，即[2.x.1516] ，[2.x.1517] 是[2.x.1518] 的雅各布矩阵中的非线性项，即[2.x.1519] 。

对于第一个方程，我们可以用什么解法？让我们来看看我们要反转的矩阵。

[1.x.617]

为一些[2.x.1520]，取决于现在和以前的解决方案。首先，请注意，该矩阵是对称的。此外，如果时间步长[2.x.1521]足够小，即如果[2.x.1522]，那么该矩阵也将是正定的。在下面的程序中，情况总是这样的，所以我们将使用共轭梯度法和SSOR法作为预处理。然而，我们应该记住，如果我们碰巧使用更大的时间步长，这将失败。幸运的是，在这种情况下，求解器将只是抛出一个异常，表明收敛失败，而不是默默地产生一个错误的结果。如果发生这种情况，那么我们可以简单地用能够处理不确定对称系统的方法取代CG方法。GMRES求解器通常是处理所有 "坏 "线性系统的标准方法，但它也是一个缓慢的方法。更好的方法可能是利用对称性的求解器，例如，SymmLQ，它也在deal.II中实现。

这个程序在步骤23和[2.x.1523]"步骤24 "上使用了巧妙的优化。如果你仔细阅读上述公式，就会发现，速度[2.x.1524]只出现在与质量矩阵的乘积中。因此，在步骤23和步骤24中，我们有点浪费：在每个时间步骤中，我们会用质量矩阵求解一个线性系统，只是在下一个时间步骤中再次将该系统的解乘以[2.x.1525]。当然，这可以避免，我们在这个程序中也是这样做的。




[1.x.618]

正弦戈登方程有几个分析解，包括一维和二维的。特别是，该程序如是计算一个具有单一的类似激波的初始条件的问题的解。  这个解是由Leibbrandt在Phys.Rev.Lett.中给出的。\b 41(7)中给出，并在[2.x.1526]类中实现。

应该注意的是，严格来说，这个闭式解只适用于无限空间的初值问题（而不是这里考虑的诺伊曼初界值问题）。然而，鉴于我们施加了零诺依曼边界条件，我们期望我们的初始边界值问题的解将接近无限空间初始值问题的解，如果波在我们领域的边界上的反射没有发生。在实践中，情况当然不是这样的，但我们至少可以假设是这样的。

二维解决方案中的常数[2.x.1527]和[2.x.1528]以及三维解决方案中的[2.x.1529]、[2.x.1530]和[2.x.1531]被称为B&auml;cklund变换参数。它们控制诸如扭结的方向和陡度。为了测试代码与精确解的对比，我们应该选择这些参数，使扭结与网格保持一致。

我们在[2.x.1532]类中实现的解决方案是这些。  [2.x.1533] [2.x.1534] 在1D中：[1.x.619] 。

  其中我们选择 [2.x.1535] 。

  在一维中，已知有更多有趣的分析解决方案。他们中的许多人被列在http://mathworld.wolfram.com/Sine-GordonEquation.html。

   [2.x.1536] 在2D：[1.x.620] 。

  其中[2.x.1537]被定义为[1.x.621]。

  而在这里我们选择[2.x.1538]。

   [2.x.1539] 在三维：[1.x.622] 。

  其中[2.x.1540]被定义为[1.x.623]。

  而在这里，我们选择[2.x.1541] 。  [2.x.1542]


由于这使得玩起来更容易，用于设置&mdash;惊喜！&mdash;我们模拟的初始值的[2.x.1543]类只是查询了描述初始时值的精确解的类，而不是重复实现解函数的努力。


examples/step-25/doc/results.dox



[1.x.624]显式欧拉时间步长方案（[2.x.1544]）对于我们希望解决的问题来说表现得很充分。不幸的是，由于稳定性问题，必须选择一个相当小的时间步长 ---- [2.x.1545]似乎对我们进行的大多数模拟都有效。另一方面，Crank-Nicolson方案（[2.x.1546]）是无条件稳定的，而且（至少对于一维呼吸器的情况）我们可以选择大到[2.x.1547]的时间步长而不对解决方案产生任何不良影响。隐式欧拉方案（[2.x.1548]）是 "指数阻尼 "的，所以它不是解决正弦戈登方程的好选择，因为它是保守的。然而，[2.x.1549]方法提供的连续体中的一些阻尼方案对于消除边界效应引起的虚假振荡很有用。

在下面的模拟中，我们在一维的区间[2.x.1550]和二维的正方形[2.x.1551]上解决正弦-戈登方程。在每种情况下，各自的网格被均匀地细化了6次，即[2.x.1552] 。

[1.x.625] 我们讨论的第一个例子是正弦-戈登方程的所谓一维（静止的）呼吸器解。正如介绍中提到的，呼吸器有如下闭合形式的表达。

[1.x.626] 其中[2.x.1553] , [2.x.1554] 和 [2.x.1555] 是常数。在下面的模拟中，我们选择了 [2.x.1556] , [2.x.1557] , [2.x.1558] 。此外，我们知道呼吸器的振荡周期是[2.x.1559]，因此我们选择[2.x.1560]和[2.x.1561]，这样我们可以观察到解决方案的三次振荡。然后，取[2.x.1562]、[2.x.1563]和[2.x.1564]，程序计算出以下解。

[2.x.1565]

虽然程序中没有显示如何做，但另一种可视化(1+1)-d解决方案的方法是使用DataOutStack类产生的输出；它允许 "堆叠 "单个时间步骤的解决方案，因此我们从一维时间相关的解决方案中得到二维时空图。这就产生了下面的时空图，而不是上面的动画。

[2.x.1566]

此外，由于呼吸器是正弦-戈登方程的分析解，我们可以用它来验证我们的代码，尽管我们必须假设我们选择的诺伊曼边界条件引入的误差与数值误差相比是很小的。在这种假设下，可以使用[2.x.1567]函数来计算数值解和本程序的[2.x.1568]类描述的函数之间的差异。对于上面两幅图所示的模拟，每个时间步长的有限元解的[2.x.1569]误差的规范保持在[2.x.1570]的数量级。因此，我们可以得出结论，数值方法在程序中得到了正确的实现。




[1.x.627]

在文献中可以找到的正弦戈登方程在(2+1)D中的唯一分析解是所谓的Kink孤波。它有以下的闭合式表达。   [1.x.628]

与[1.x.629]

其中[2.x.1571]、[2.x.1572]和[2.x.1573]为常数。在下面的模拟中，我们选择了[2.x.1574] 。请注意，如果[2.x.1575]是静止的，那么它将是一个很好的解决方案，我们可以用它来验证二维的程序，因为没有发生域边界的反射。

下面显示的模拟是用[2.x.1576]、[2.x.1577]、[2.x.1578]、[2.x.1579]和[2.x.1580]进行的。每个时间步长的有限元解的误差的[2.x.1581]准则保持在[2.x.1582]的数量级上，表明该程序在二维和一维中都能正常工作。不幸的是，这个解决方案并不十分有趣，不过为了完整起见，我们还是在下面附上了它的快照。

[2.x.1583]

现在我们已经在一维和二维中验证了代码，我们转到一个分析解未知的问题。

为此，我们围绕[2.x.1584]轴旋转上面讨论的扭结解：我们让[2.x.1585] .后者的结果是一个不与网格对齐的孤波，所以反射立即发生在域的边界。对于下面所示的模拟，我们采取了[2.x.1586]、[2.x.1587]、[2.x.1588]、[2.x.1589]和[2.x.1590] 。此外，我们不得不选择[2.x.1591]，因为对于任何[2.x.1592]的边界都会产生振荡，这可能是由于方案而不是方程造成的，因此选择[2.x.1593]的值，在时间步进方案的 "指数阻尼 "频谱中，确保这些振荡不会被产生。

[2.x.1594]

正弦-戈登方程的另一个有趣的解决方案（不能通过分析获得）可以通过使用两个一维呼吸器来构建以下可分离的二维初始条件来产生。

[1.x.630] 其中[2.x.1595] , [2.x.1596] 与我们上面讨论的一维情况一样。在下面的模拟中，我们选择了[2.x.1597]、[2.x.1598]、[2.x.1599]和[2.x.1600]。解决方案是相当有趣的



[2.x.1601]


[1.x.631]

[1.x.632]

改变初始条件是有意义的。大多数选择不会导致保持局部的解决方案（在孤子界，这样的解决方案被称为 "静止的"，尽管解决方案确实随时间变化），而是导致方程的波状特征占主导地位的解决方案，并且波从局部初始条件的位置传播出去。例如，值得玩一玩[2.x.1602]类，把对[2.x.1603]类的调用换成类似这样的函数。

[1.x.633]

如果[2.x.1604]，和[2.x.1605]在这个区域之外。

第二个方面是研究该方案是否是能量保持的。对于[2.x.1606]"step-23 "中讨论的纯波方程，如果我们选择时间步进参数，使我们得到Crank-Nicolson方案，情况就是这样。我们可以在这里做类似的事情，注意到正弦-戈登解中的能量被定义为

[1.x.634]

(我们在公式中使用[2.x.1607]而不是[2.x.1608]，以确保对能量的所有贡献都是正的，从而使衰变的解在无界域上具有有限的能量。)

除此以外，还有两个明显的领域。

- 显然，自适应性（即时间自适应网格）会对这样的问题产生兴趣。它们的复杂性导致我们再次将其排除在本方案之外，尽管[2.x.1609]"step-23 "介绍中的一般评论仍然正确。

- 解决这个问题的更快方案。虽然今天的计算机已经足够快，可以在不长的时间内解决二维甚至三维静止的问题，但与时间相关的问题则是完全不同的一类问题。我们在步骤48中讨论了这个问题，我们展示了如何在不组装或倒置任何矩阵的情况下并行解决这个问题。


examples/step-26/doc/intro.dox

[1.x.635]

[1.x.636]

[2.x.1610] （ [2.x.1611] 。


这个程序实现了热方程

[1.x.637]

从某种意义上说，这个方程比我们在前面的程序步骤23、步骤24、步骤25中讨论的方程，即波浪方程要简单。这是由于热方程随着时间的推移使解变得平滑，因此在许多方面更宽容。例如，当使用隐式时间步长方法时，我们实际上可以采取大的时间步长，我们对通过每隔几步适应网格而引入的小干扰的麻烦较小，等等。

我们在这里的目标将是使用theta-scheme解决上述方程，该方程在时间上离散，使用以下方法，我们希望[2.x.1612]在某个时间[2.x.1614]近似[2.x.1613] 。

[1.x.638]

这里，[2.x.1615]是时间步长。Theta-scheme概括了显式欧拉（ [2.x.1616] ）、隐式欧拉（ [2.x.1617] ）和Crank-Nicolson（ [2.x.1618] ）时间离散。由于后者具有最高的收敛顺序，我们将在下面的程序中选择[2.x.1619]，但要使这个参数的操作保持简单。如果你对玩更高阶的方法感兴趣，可以看一下步骤52）。

鉴于这种时间离散化，空间离散化会像往常一样发生，通过与测试函数相乘，通过部分积分，然后将一切限制在一个有限维的子空间。在与[2.x.1620]相乘之后，这就产生了以下一组完全离散的方程。

[1.x.639]

其中[2.x.1621]是质量矩阵，[2.x.1622]是将拉普拉斯离散化后的刚度矩阵。将所有已知的量带到右手边，就得到了我们在每一步都要解决的线性系统。

[1.x.640]

左手边的线性系统是对称和正定的，所以我们用共轭梯度法解决它应该没有问题。

如果我们在初始时间有一组节点系数[2.x.1623]，我们可以开始上面的迭代。在这里，我们采取的是将初始值[2.x.1624]插值到用于第一个时间步长的网格上得到的那些。我们还需要选择一个时间步长；在这里我们只选择固定的时间步长，但显然先进的模拟器会希望自适应地选择它。我们将在[1.x.641]中简要地回到这个问题。




[1.x.642]

在前面几个程序中求解波浪方程及其变体时，我们保持了固定的网格。就像静止方程一样，我们可以很好地说明这不是最聪明的方法，通过调整网格可以节省大量资金。然而，与静止的情况相比，还有很大的困难。让我们依次来看看这些困难。

[2.x.1625] [2.x.1626] [1.x.643] 。对于静止的问题，一般的做法是 "将网格做得越细越好"。对于有奇点的问题，这往往会导致我们在角落或界面上得到许多细化层次的情况。第一个使用自适应网格的教程，第6步，已经是一个案例的要点。

  然而，对于时间相关问题，我们通常需要选择与网格大小相关的时间步长。对于显式时间离散，这是显而易见的，因为我们需要遵守一个CFL条件，将时间步长与最小的网格尺寸联系起来。对于隐式时间离散，不存在这样的硬性限制，但在实践中，如果我们使网格尺寸变小，我们仍然希望使时间步长变小，因为我们通常有[2.x.1627]形式的误差估计，其中[2.x.1628]分别是时间和空间离散的收敛阶。我们只有减少这两个项，才能使误差变小。理想情况下，这样的估计会建议选择[2.x.1629] 。因为，至少对于非光滑解的问题来说，误差通常集中在网格尺寸最小的单元中，所以我们必须确实选择[2.x.1630] ，使用[1.x.644]网格尺寸。

  其结果是，在一个地方进一步细化网格不仅意味着略微增加自由度数量的适度额外努力，而且由于时间步长较小，必须更频繁地求解[1.x.645]线性系统的更大努力。

  在实践中，我们通常通过承认我们不能使时间步长任意地小，因此也不能使局部网格尺寸任意地小来处理这个问题。相反，我们设置了一个最大的细化水平，当我们标记单元进行细化时，我们只是不细化那些子单元会超过这个最大的细化水平。

  还有一个类似的问题是，我们将选择一个右手边，在不同的时间在领域的不同部分开启。为了避免在突然需要更细的网格的地方，被太粗的网格弄得措手不及，我们还将在程序中强制执行[1.x.646]的网格细化水平。

   [2.x.1631] [1.x.647]。让我们再次考虑我们在上面写下的半离散方程。   [1.x.648]

  我们在这里可以把[2.x.1632]视为数据，因为它可能已经被计算过了。现在，让我们替换掉[1.x.649]。

  与测试函数[2.x.1633]相乘，并在必要时按部分整合。在如上所述的过程中，这将产生[1.x.650]。

  现在想象一下，我们在时间步骤 [2.x.1634] 和 [2.x.1635] 之间改变了网格。那么问题来了，我们在[2.x.1636]和[2.x.1637]中使用的基函数是不同的！这与右边的项有关。这与右手边的项有关，其中第一个项我们可以更清楚地写成（第二个项遵循同样的模式）[1.x.651]

  如果在这两个时间步骤中使用的网格是相同的，那么[2.x.1638]就会形成一个方形的质量矩阵[2.x.1639] 。然而，如果网格不一样，那么一般来说，矩阵是矩形的。更糟的是，甚至很难计算这些积分，因为如果我们在时间步长[2.x.1640]的网格单元上循环，那么我们需要在这些单元的正交点上评估[2.x.1641]，但它们不一定对应于时间步长[2.x.1642]的网格单元，而且[2.x.1643]不是通过这些单元定义的；如果我们想通过对网格[2.x.1644]的单元积分计算这些积分当然也是一样。

  在任何情况下，我们必须面对的情况是，我们需要整合定义在两个不同网格上的形状函数。这是可以做到的，事实上在步骤28中也有演示，但这个过程最多只能用 "笨拙 "一词来形容。

  在实践中，人们通常不希望这样做。相反，我们在每次调整网格的时候，通过从旧的网格插值到新的网格来避免整个情况。换句话说，我们不是解决上面的方程，而是解决[1.x.652]的问题

  其中[2.x.1645]是对时间步骤[2.x.1646]中使用的有限元空间的内插算子。这不是最佳的方法，因为它除了时间和空间离散化之外还引入了一个额外的误差，但这是一个务实的方法，使得做时间适应网格是可行的。  [2.x.1647]




[1.x.653]

在实现有限元代码时，通常有许多事情会出错。特别是对于时间相关问题，以下是常见的错误来源。

- 时间积分，例如把涉及当前和前一个时间步骤的条款前面的系数弄错了（例如，把一个系数[2.x.1648]混为[2.x.1649]）。

- 处理右侧，例如忘记了[2.x.1650]或[2.x.1651]的系数。

- 对边界值处理不当，例如再次忘记了[2.x.1652]或[2.x.1653]的系数，或忘记了不仅对右手边而且对系统矩阵应用非零边界值。

一个不太常见的问题是把初始条件弄错了，因为通常只要输出第一个时间步长就能看出它是错的。在任何情况下，为了验证代码的正确性，有一个测试协议是很有帮助的，它允许我们分别验证这些组件中的每一个。这意味着

- 用非零初始条件但零右手边和边界值测试代码，并验证时间演化是否正确。

- 然后用零初始条件和边界值但非零的右手边进行测试，再次确保正确性。

- 最后，用零初始条件和右手边但非零边界值进行测试。

这听起来很复杂，但幸运的是，对于像这里的无系数（或常数系数）的线性偏微分方程，有一个相当标准的协议，它基于以下观察：如果你选择一个正方形[2.x.1654]作为你的领域（或者，稍加修改，一个矩形），那么精确解可以写成

[1.x.654]

有整数常数[2.x.1655]），如果只有初始条件、右手边和边界值也都是[2.x.1656]的形式。这是由于函数[2.x.1657]是拉普拉斯算子的特征函数，允许我们以分析方式计算时间因子[2.x.1658]等东西，并因此与我们的数值结果进行比较。

作为一个例子，让我们考虑我们有[2.x.1659]和[2.x.1660]的情况。通过上面对[2.x.1661]的形式的主张（ansatz），我们可以得到

[1.x.655]

为了使其等于[2.x.1662]，我们需要： 1.

[1.x.656]

并由于初始条件，[2.x.1663] 。这个微分方程可以被整合，得到

[1.x.657]

换句话说，如果初始条件是正弦的乘积，那么解的形状与正弦的乘积完全相同，它以已知的时间依赖性衰减到零。如果你有足够细的网格和足够小的时间步长，这一点是很容易测试的。

如果你把时间积分方案弄错了（例如，在各条款前面有错误的[2.x.1664]或[2.x.1665]的因子），通常会发生的情况是你没有得到正确的解的时间行为。仔细检查各种因素，直到你得到正确的行为。你可能还想验证一下，时间衰减率（例如，通过绘制固定点的解的值来确定）在你每次将时间步长或网格大小增加一倍或减少一半的时候，都不会增加。你知道这不是对边界条件或右手边的处理，因为这些都是零。

如果你已经如此验证了时间积分器的正确性，那么就拿右手边非零但初始条件为零的情况来说。  [2.x.1666] 和 [2.x.1667] 。再来看看。

[1.x.658]

而要使其等于[2.x.1668]，我们需要的是

[1.x.659]

并由于初始条件，[2.x.1669] 。对这个方程进行时间积分，可以得到

[1.x.660]



同样，如果你在右手边的条款前面有[2.x.1670]或[2.x.1671]的错误因子，你将不会得到正确的解的时间行为，或者它将收敛到[2.x.1672]以外的最大值。

一旦我们验证了使用这个方案的时间积分和右手处理是正确的，我们就可以继续验证我们的边界值是否正确，使用非常类似的方法。




[1.x.661]

在一个简单的域上用一个简单的右手边求解热方程，几乎总是导致解非常无聊，因为它们很快就变得非常光滑，然后就不再有什么变化。相反，我们在这里用零迪里希特边界值和零初始条件在L形域上求解方程，但作为右手边我们选择

[1.x.662]

在这里。

[1.x.663]

换句话说，在每一个长度为[2.x.1673]的周期中，右手边首先在域1中闪烁，然后完全关闭，然后在域2中打开，然后再次完全关闭。通过[1.x.664]中显示的解决方案的小动画，这种模式可能是最好的观察。

如果你把热方程解释为寻找导电固体的空间和时间可变的温度分布，那么上面的测试案例相当于一个L形体，我们把边界保持在零温度，并在领域的两个部分交替加热。在加热的同时，这些地方的温度会上升，之后温度会扩散并再次减弱。这些初始条件的意义在于，它们为我们提供了一个在时间上（当源打开和关闭时）以及时间上（在再入角以及源作用区域的边缘和角落）都有奇点的解决方案。


examples/step-26/doc/results.dox



[1.x.665]

正如许多教程一样，程序的实际输出并不重要，重要的是我们是如何到达那里的。尽管如此，它还是来了。

[1.x.666]



也许更有意义的是解决方案的可视化和计算的网格。

[2.x.1674]

这部电影显示了两个信号源是如何开启和关闭的，以及网格对此的反应。很明显，现在的网格可能不是我们能想出的最好的。我们将在下一节再来讨论这个问题。


[1.x.667]

[1.x.668]

至少有两个方面可以大大改善这个程序：自适应时间步长和更好地选择网格。

[1.x.669]

由于选择了隐式时间步进方案，我们不受任何类似CFL的时间步进条件的约束。此外，由于在热力方程中发生变化的时间尺度不受细胞直径的约束（与波浪方程的情况不同，在波浪方程中我们有一个固定的信息传输速度，将时间尺度和空间尺度联系起来），我们可以随意选择时间步长。或者，最好是按照我们认为必要的准确性来选择它。

看一下解决方案，很明显，行动并不是随时间均匀发生的：在我们打开一个源的时候，很多东西都在发生变化，一旦一个源开启了一段时间，事情就变得不那么戏剧化了，而当两个源都关闭的时候，我们进入了一个漫长的下降阶段。在这些时候，我们肯定可以在不牺牲太多精确度的情况下，采用比以前更大的时间步长。

文献中有许多关于如何自适应地选择时间步长的建议。例如，可以从ODE求解器选择其时间步长的方式中学到很多。我们也可以从后验误差估计中得到启发，理想情况下，后验误差估计可以写成由对整体误差的时间和空间贡献组成。如果时间上的贡献太大，我们应该选择一个较小的时间步长。例如，这个方向的想法可以在deal.II的前主要开发者Ralf Hartmann的博士论文中找到，该论文由德国海德堡大学在2002年出版。




[1.x.670]

我们在这里使用了一种比较简单的时间步进方法，即二阶时间的Crank-Nicolson方法。然而，更精确的方法如Runge-Kutta方法是可用的，并且应该使用，因为它们并不代表很多额外的努力。对于目前的程序来说，实现这一点并不困难，但在step-52中也给出了一个更系统的处理。




[1.x.671]

如果你看一下上面电影中的网格，很明显，它们不是特别适合手头的任务。事实上，它们看起来相当随意。

有两个因素在起作用。首先，有一些岛屿，其中的单元已经被细化，但周围是未细化的单元（可能还有一些偶尔被粗化的岛屿）。这些并不可怕，因为它们大多数时候并不影响网格的近似质量，但是它们也没有帮助，因为它们的许多额外的自由度事实上受到悬挂节点约束的限制。也就是说，这很容易解决：Triangulation类在其构造函数中接受一个参数，表示 "网格平滑 "的程度。传递许多可能的标志之一，这将指示三角剖分细化一些额外的单元，或者不细化一些单元，这样得到的网格就不会有这些伪影。

第二个问题更为严重：网格似乎滞后于解。其根本原因是我们每隔五步才调整一次网格，而且在这些情况下只允许进行一次细化。每当一个源打开时，之前的解在这个区域是非常平滑的，因此网格也是相当粗糙的。这意味着在下一个时间步骤中，当我们细化网格时，我们会在这个区域多得到一个细化级别，五个时间步骤后再多一个级别，等等。但这还不够：首先，我们应该在一个源打开时立即进行细化（毕竟在当前情况下，我们至少知道右手边是什么），而且我们应该允许超过一个细化级别。当然，所有这些都可以用deal.II来完成，只是需要在如何使其发挥作用方面有一些算法上的思考!




[1.x.672]

为了提高你的模拟在时间上的准确性和分辨率，通常会减少时间步长 [2.x.1675] 。如果你在这个特定的例子中开始玩弄时间步长，你会注意到，如果[2.x.1676]低于某个阈值，解决方案会变成部分负数。这不是我们所期望发生的（在自然界）。

为了从数学上了解这种行为，让我们考虑一个一般的、完全离散的问题。

[1.x.673]

那么[2.x.1677]th方程的一般形式为：。

[1.x.674]

其中[2.x.1678]是与DoF[2.x.1679]耦合的自由度集合（即矩阵[2.x.1680]或矩阵[2.x.1681]在位置[2.x.1682]有一个非零条目）。如果所有系数都满足以下条件。

[1.x.675]

所有的解决方案[2.x.1683]都保持其与之前的解决方案[2.x.1684]的符号，因此也保持其与初始值[2.x.1685]的符号。关于正性保留的更多信息，请参见例如 [1.x.676] 。

根据要解决的PDE和使用的时间积分方案，人们能够推导出时间步长的条件 [2.x.1686] 。对于采用Crank-Nicolson方案的热方程，[1.x.677]已将其转化为下列方案。

[1.x.678]

其中[2.x.1687]表示质量矩阵，[2.x.1688]表示刚度矩阵，[2.x.1689]分别表示[2.x.1690]。有了[2.x.1691]，我们可以制定全局时间步长[2.x.1692]的界限如下。

[1.x.679]

换句话说，在Crank-Nicolson方案的情况下，时间步长受到[1.x.680]的限制。这些约束应与CFL条件一起考虑，以确保所进行的模拟的重要性。

无法使时间步长达到我们想要的小，以获得更多的精度，而又不失去积极性属性，这是令人讨厌的。这就提出了一个问题：在这个特定的教程中，我们是否至少可以[1.x.681]选择最小的时间步长来确保正性的保留。事实上，我们可以使用通过MatrixCreator函数创建的质量和刚度的SparseMatrix对象。通过SparseMatrixIterators遍历每个条目，我们可以检查对角线和非对角线条目，从而动态地设置一个合适的时间步长。对于二次元矩阵，对角线元素被存储为一行的第一个成员（见SparseMatrix文档）。下面是一个关于如何从[2.x.1693]中抓取感兴趣的条目的示范性代码片断。

[1.x.682]



利用这样计算出来的信息，我们可以通过上述公式来约束时间步长。


examples/step-27/doc/intro.dox

[1.x.683]

[1.x.684]

这个教程程序试图展示如何使用[2.x.1694]-finite element方法与deal.II。它解决的是拉普拉斯方程，因此只建立在前几个教程程序的基础上，特别是步骤4的独立维度编程和步骤6的自适应网格细化。

Babu&scaron;ka和Guo在20世纪80年代初提出了[2.x.1695]-有限元方法，作为(i)网格细化（即减少有限元计算中的网格参数[2.x.1696]）或(ii)增加用于形状函数的多项式程度[2.x.1697]的替代方法。它是基于这样的观察：如果解足够光滑，增加形状函数的多项式程度可以减少近似误差。另一方面，众所周知，即使对于一般良好的椭圆问题，在边界附近、角落或系数不连续的地方也不能保证较高的规则度；因此，在这些地方不能通过增加多项式度来改善近似 [2.x.1698] ，而只能通过细化网格，即减少网格大小 [2.x.1699] 。这些减少误差的不同手段导致了[2.x.1700]有限元的概念，即在解足够光滑的地方，近似的有限元空间被调整为具有高多项式度[2.x.1701]，而在解缺乏规则性的地方，网格宽度[2.x.1702]被减少。在关于这种方法的第一篇论文中已经意识到，[2.x.1703]-无限元素可以是一个强有力的工具，它可以保证误差不仅以自由度数的某个负数减少，而且实际上是以指数形式减少。

为了实现这个方法，我们需要一些高于一般有限元程序所需的东西，特别是高于我们在步骤6之前的教程程序中所介绍的东西。特别是，我们将不得不讨论以下几个方面。  [2.x.1704] [2.x.1705] 我们现在不是在所有单元上使用相同的有限元，而是要有一个有限元对象的集合，并将每个单元与这个集合中的一个对象相关联。[2.x.1706]

   [2.x.1707]然后，自由度将不得不根据与该特定单元相关的有限元来分配给每个单元。约束条件必须以与悬挂节点相同的方式生成，但我们现在还必须处理两个相邻单元分配不同有限元的情况。[2.x.1708]

   [2.x.1709] 我们将需要能够集合单元和面对全局矩阵和右手向量的贡献。[2.x.1710]

   [2.x.1711]在求解所得到的线性系统后，我们将想分析该解决方案。特别是，我们要计算误差指标，告诉我们是否应该细化一个给定的单元和/或是否应该增加对其使用的形状函数的多项式程度。[2.x.1712] [2.x.1713]。

我们将在本介绍的以下几个小节中讨论所有这些方面。这些任务中的大部分已经由deal.II提供的功能很好地支持了，我们只需要提供程序应该做什么的逻辑，而不是确切地说明这一切将如何发生，这不会让人感到很惊讶。

在deal.II中，[2.x.1714]的功能大部分被打包到hp-namespace中。这个命名空间提供了处理[2.x.1715]分解、集合矩阵和向量以及其他任务的类。我们将在下文中进一步了解它们中的许多。此外，DoFTools和VectorTools命名空间中的大多数函数除了接受非[2.x.1717]的对象外，还接受[2.x.1716]的对象。许多[2.x.1718]的实现也在[2.x.1719]文档模块和那里的链接中讨论。

也许值得在这第一部分介绍的最后给出一个稍大的观点。  [2.x.1720]-功能已经在许多不同的有限元软件包中实现（例如，见[2.x.1721]"hp-paper "中引用的参考文献列表）。然而，总的来说，这些软件包大多只在(i)2d情况下和/或(ii)不连续的Galerkin方法中实现了它。后者是一个重要的简化，因为根据定义，不连续的有限元不要求单元之间的面的连续性，因此，当不同的多项式程度的有限元在一个共同的面相遇时，不需要特殊处理。相比之下，deal.II实现了最普遍的情况，即它允许1d、2d和3d的连续和不连续元素，并自动处理由此产生的复杂性。特别是，它可以处理不同程度的元素在一个面或边缘相遇时的约束（类似于悬挂节点约束）的计算。许多必要的算法和数据结构技术在[2.x.1722]"hp-paper "中描述，供那些对这些细节感兴趣的人参考。

我们希望，提供这样一个通用的实现方式将有助于进一步探索[2.x.1723]-方法的潜力。




[1.x.685]

现在再来看看如何在deal.II中使用[2.x.1724]-功能的细节。我们要处理的第一个方面是，现在我们不再只有一个用于所有单元的有限元，而是有许多不同的单元可以选择使用的元素。为此，deal.II引入了[1.x.686]的概念，在[2.x.1725]类中实现。实质上，这样的集合就像[2.x.1726]类型的对象，但多了一些小功能和内存管理，更适合手头的任务。正如我们以后所看到的，我们还将使用类似的正交集合，以及&mdash; 尽管我们在这里没有使用它们&mdash; 还有映射集合的概念。所有这些类都在[2.x.1727]概述中有所描述。

在这个教程程序中，我们将使用阶数为2到7（在2D中）或2到5（在3D中）的连续Lagrange元素。然后可以按以下方式创建所用元素的集合。

[1.x.687]






[1.x.688][1.x.689] 。

我们要考虑的下一个任务是如何处理我们要使用的有限元对象的列表。在之前的教程程序中，从第2步开始，我们已经看到DoFHandler类负责在网格（由三角形对象描述）和有限元之间建立联系，为网格的每个顶点、面、边和单元分配正确的自由度数。

这里的情况有点复杂，因为我们不只是有一个单一的有限元对象，而是可能想在不同的单元上使用不同的元素。因此，我们需要两样东西。(i) 一个能够处理这种情况的DoFHandler类的版本，以及(ii) 告诉DoFHandler在哪个单元上使用哪个元素的方法。

这两件事中的第一件是在DoFHandler类的[1.x.690]模式下实现的：不是将其与一个三角形和一个有限元对象相关联，而是与一个三角形和一个有限元集合相关联。第二部分是通过在DoFHandler的所有单元上的循环来实现的，并为每个单元设置集合中的有限元的索引，该索引将被用于该单元。我们将集合中用于某个单元的有限元对象的索引称为该单元的[1.x.691]，以表明这是活跃在该单元上的有限元，而集合中的所有其他元素在该单元上是不活跃的。其大致内容是这样的。

[1.x.692]



调用[2.x.1728]中的点表示我们以后必须有某种策略来决定在哪个单元格上使用哪个元素；我们以后会再来讨论这个。这里的重点是，这个代码片段的第一行和最后一行与非 [2.x.1729] 的情况几乎完全相同。

另一个复杂的情况是，这次我们不只是有来自局部网格细化的悬挂节点，我们还必须处理这样的情况：如果有两个具有不同活动有限元指数的单元在一个面上相遇（例如一个Q2和一个Q3单元），那么我们必须计算有限元场上的额外约束，以确保它是连续的。这在概念上与我们计算悬挂节点约束的方式非常相似，事实上，代码看起来也完全一样。

[1.x.693]

换句话说，[2.x.1730]不仅处理悬挂节点约束，而且同时处理[2.x.1731]-约束。




[1.x.694]

在这之后，我们必须为正确大小的线性系统设置矩阵和向量，并将它们组合起来。设置它们的方法与非[2.x.1732]的情况完全相同。组装则需要更多的思考。

当然，主要的想法是不变的：我们必须在所有单元中循环，集合局部贡献，然后将它们复制到全局对象中。正如在第3步中详细讨论的那样，deal.II有一个FEValues类，它将有限元描述、映射和正交公式拉到一起，帮助评估形状函数的值和梯度，以及映射到单元实际位置的每个正交点的其他信息。每当我们转到一个新的单元时，我们就会重新初始化这个FEValues对象，从而要求它重新计算从一个单元到另一个单元的那部分信息。然后，它可以被用来总结本地对双线性形式和右手边的贡献。

在[2.x.1733]有限元方法的背景下，我们必须处理这样一个事实：我们不在每个单元上使用相同的有限元对象。事实上，我们甚至不应该对所有单元使用相同的正交对象，而应该对使用高阶有限元的单元使用高阶正交公式。同样地，我们可能也想在这些单元上使用高阶映射。

为了方便这些考虑，deal.II有一个类[2.x.1734]，可以做我们在当前背景下需要的事情。不同的是，它不是一个单一的有限元、正交公式和映射，而是这些对象的集合。它的使用非常类似于常规的FEValues类，也就是说，在所有单元中循环的有趣部分看起来像这样。

[1.x.695]



在这个教程程序中，我们将始终使用Q1映射，所以[2.x.1735]结构的映射集合参数将被省略。在循环中，我们首先初始化当前单元的[2.x.1736]对象。第二个、第三个和第四个参数表示我们希望在该单元上使用的正交、映射和有限元对象在各自集合中的索引。这些参数可以省略（在下面的程序中也是如此），在这种情况下，[2.x.1737]被用于这个索引。之所以这样选择这些参数的顺序，是因为有时人们可能想从各自的集合中挑选不同的正交或映射对象，但几乎不可能从这个单元上使用的有限元中挑选不同的有限元，即索引与[2.x.1738]不同。因此，有限元集合的索引是最后一个默认参数，这样可以方便地省略它。

这个[2.x.1739]调用的作用如下：[2.x.1740]类检查它之前是否已经为这个有限元、正交和映射对象的组合分配了一个非[2.x.1741]-FEValues对象。如果没有，它将分配一个。然后，它为当前单元重新初始化这个对象，之后，现在有一个FEValues对象可用于当前单元上选定的有限元、正交和映射。然后通过调用[2.x.1742]获得对该对象的引用，并将以通常的方式用于集合本地贡献。




[1.x.696]

自适应有限元方法的核心之一是，我们用一个指标来检查计算出的解（后验），告诉我们哪些是误差最大的单元，然后再对它们进行细化。在其他许多教程程序中，我们使用KellyErrorEstimator类来获得一个单元上的误差大小的指示，尽管我们也在一些程序中讨论了更复杂的策略，最重要的是在步骤14。

在任何情况下，只要决定只是 "细化这个单元 "或 "不细化这个单元"，实际的细化步骤就不是特别具有挑战性。然而，在这里，我们有一个能够进行hp细化的代码，也就是说，每当我们检测到某个单元上的误差太大，我们突然有两个选择：我们可以通过把它分割成几个小单元来细化这个单元，或者我们可以增加在它上面使用的形状函数的多项式程度。我们如何知道哪个是更有希望的策略？回答这个问题是本文写作时[2.x.1743]-无限元研究的核心问题。

简而言之，这个问题目前在文献中似乎还没有解决。有许多或多或少复杂的方案来解决这个问题，但没有任何方案像KellyErrorEstimator那样被普遍接受为一个好的、即使不是最佳的误差指标。大多数建议采用这样的事实：只要解是局部光滑的，增加多项式的度数是有益的，而只要网格是粗糙的，就应该细化。然而，如何确定解的局部光滑度以及决定一个解何时光滑到允许增加[2.x.1744]的问题无疑是很大很重要的问题。

在下文中，我们提出了一个简单的解决方案的局部平滑性的估计方法。正如我们将在结果部分看到的，这个估计器有缺陷，特别是就有局部悬空节点的单元而言。因此，我们不打算把下面的想法作为问题的完整解决方案。相反，它是作为一个值得进一步研究和调查的想法来处理的。换句话说，我们不打算在关于一般问题的答案的争论中进入一个复杂的建议。然而，为了证明我们对[2.x.1745]-无限元素的方法，我们需要一个简单的指标，它确实产生一些有用的信息，能够驱动本教程程序将进行的简单计算。




[1.x.697]

我们在这里的方法很简单：对于一个函数[2.x.1746]来说，它是在单元格[2.x.1748]上的索博列夫空间[2.x.1747]中，它必须满足条件

[1.x.698]

假设单元格[2.x.1749]不是退化的，即从单元格到单元格[2.x.1750]的映射足够规则，上述条件当然等同于

[1.x.699]

其中[2.x.1751]是映射回单元格[2.x.1753]的函数[2.x.1752] 。从这里，我们可以做以下工作：首先，让我们定义[2.x.1754]的傅里叶级数为

[1.x.700]

傅里叶向量[2.x.1755]在2d中，[2.x.1756]在3d中，等等，以及[2.x.1757] 。扩张[2.x.1758]的系数可以用[2.x.1759]得到--指数基的正交性

[1.x.701]

导致以下表达式

[1.x.702]

很明显，我们可以将[2.x.1760]的[2.x.1761]准则写成

[1.x.703]

换句话说，如果这个规范是有限的（即，对于[2.x.1762]在[2.x.1763]中），我们需要

[1.x.704]

换句话说：我们想要的规则性[2.x.1764]越高，傅里叶系数归零的速度就越快。如果你想知道额外的指数[2.x.1765]从何而来：我们想利用这样一个事实：[2.x.1766]如果序列[2.x.1767]对于任何[2.x.1768]。问题是，我们在这里不仅有一个单一变量的求和，而且有位于[2.x.1770]维球内的[2.x.1769]的所有整数倍的求和，因为我们有向量成分[2.x.1771] 。就像我们通过用整个直线上的积分代替总和来证明上面的序列[2.x.1772]收敛一样，我们可以用[2.x.1773]-维空间上的积分来代替我们的[2.x.1774]-维总和。现在我们必须注意到，在距离[2.x.1775]和[2.x.1776]之间，存在着多达一个常数的[2.x.1777]模式，这与我们可以将体积元素[2.x.1778]转化为[2.x.1779]的方式相同。因此，不再是[2.x.1780]必须衰变为[2.x.1781]，而实际上是[2.x.1782]。指数的比较产生了结果。

我们可以把这个问题转过来。假设我们得到了一个未知平滑度的函数[2.x.1783]。让我们计算它的傅里叶系数[2.x.1784]，看看它们衰减的速度。如果它们的衰减速度为

[1.x.705]

因此，我们这里的函数是在[2.x.1785]。




[1.x.706]

那么，我们要做什么来估计[2.x.1786]在单元格[2.x.1787]上的局部光滑度呢？显然，第一步是计算我们解决方案的傅里叶系数。傅里叶级数是无限级数，我们通过只计算级数的前几项来简化我们的任务，例如，[2.x.1788]有一个截止点[2.x.1789]。让我们顺便说一下，我们希望选择[2.x.1790]足够大，这样我们至少可以捕获那些变化最大的形状函数的变化。另一方面，我们不应该把[2.x.1791]选得太大：显然，一个有限元函数，作为一个多项式，在任何给定的单元上都在[2.x.1792]中，所以系数将不得不在一个点上指数衰减；由于我们想估计这个多项式所近似的函数的平稳性，而不是多项式本身，我们需要为[2.x.1793]选择一个合理的截止点。无论怎样，计算这个数列并不特别困难：从定义上看

[1.x.707]

我们看到，我们可以计算系数[2.x.1794]为

[1.x.708]

其中[2.x.1795]是这个单元上[2.x.1796]个自由度的值。换句话说，我们可以把它写成一个矩阵-向量乘积

[1.x.709]

与矩阵

[1.x.710]

对于给定数量的形状函数 [2.x.1797] 和傅里叶模式 [2.x.1798] ，这个矩阵很容易计算出来。因此，寻找系数[2.x.1799]是一个相当琐碎的工作。为了进一步简化我们的生活，我们将使用[2.x.1800]类，它正是这样做的。

接下来的任务是，我们必须估计这些系数随[2.x.1801]衰减的速度。问题是，当然，我们首先只有有限的这些系数。换句话说，我们能做的最好的事情是将一个函数[2.x.1802]拟合到我们的数据点[2.x.1803]，例如通过最小二乘法程序确定[2.x.1804]。

[1.x.711]

然而，这样做的问题是，它导致了一个非线性问题，这是我们想避免的事实。另一方面，如果我们试图将我们的系数的对数与[2.x.1805]的对数相适应，我们可以将问题转化为一个更简单的问题，就像这样。

[1.x.712]

利用关于对数的一般事实，我们可以看到，这就产生了一个问题

[1.x.713]

其中 [2.x.1806] 。现在这是一个问题，对于这个问题，最优性条件 [2.x.1807] , 在 [2.x.1808] 中是线性的。我们可以把这些条件写成如下。

[1.x.714]

这个线性系统很容易被倒置，从而得到

[1.x.715]

和

[1.x.716]



这无非是线性回归拟合，为了做到这一点，我们将使用[2.x.1809]虽然我们对[2.x.1810]的实际值不是特别感兴趣，但上面的公式给了我们一个计算指数[2.x.1811]的平均值，然后我们可以用来确定[2.x.1812]与[2.x.1814]在一起。

上面概述的这些步骤适用于许多不同的场景，这促使我们在deal.II中引入了一个通用函数[2.x.1815]，该函数将本节描述的所有任务结合在一个简单的函数调用中。我们将在本程序的实现中使用它。




[1.x.717]

在上面的公式中，我们已经得出了傅里叶系数[2.x.1816] 。因为[2.x.1817]是一个矢量，对于相同的绝对值[2.x.1819]，我们会得到许多傅里叶系数[2.x.1818]，对应于不同方向的傅里叶变换。如果我们现在考虑一个像[2.x.1820]这样的函数，那么我们会发现在[2.x.1821]方向有很多大的傅里叶系数，因为这个方向的函数是不平滑的，但在[2.x.1822]方向有快速衰减的傅里叶系数，因为那里的函数是平滑的。由此产生的问题是：如果我们简单地将我们的多项式衰减[2.x.1823]与[1.x.718]的傅里叶系数拟合，我们将把它拟合成一个光滑度[1.x.719]。这就是我们想要的吗？还是只考虑所有[2.x.1825]中幅度最大的系数[2.x.1824]，本质上是想确定解在那个空间方向上的平滑度，在这个方向上解显得最粗糙？

人们也许可以为这两种情况争辩。如果deal.II有能力使用各向异性的有限元，即在不同的空间方向使用不同的多项式度数的有限元，那么这个问题将更有意义，因为它们能够更好地利用方向上的可变平滑度。唉，在编写这个教程程序时，这种能力并不存在。

无论怎样，由于我们只有同位素的有限元类，我们采取的观点是，我们应该将多项式的程度调整到最低的规则性，以保持低的数值努力。因此，不使用公式

[1.x.720]

为了计算如上所示的[2.x.1826]，我们必须对所有的和稍作修改：不是对所有的傅里叶模式求和，而是只对那些傅里叶系数是所有[2.x.1827]中最大的、具有相同幅度的[2.x.1828]求和，也就是说，上面的所有和必须由以下的和来代替。

[1.x.721]

这是我们将在计划中实施的形式。




[1.x.722]

有人可能会问，我们只在解的[1.x.723]（而不是实数单元）上计算傅里叶变换，这是否是一个问题？毕竟，在变换过程中，我们将解决方案拉伸了一个系数[2.x.1829]，从而使傅里叶频率移动了一个系数[2.x.1830]。这是一个特别值得关注的问题，因为我们可能有相邻的单元，其网格大小[2.x.1831]相差2倍，如果其中一个单元比另一个更精细。这个问题也是出于这样的考虑：正如我们在下面的结果部分所看到的，估计的解决方案的平滑度应该是一个或多或少的连续函数，但在网格大小跳跃的地方表现出跳跃。因此，我们似乎很自然地要问，我们是否必须对这种转换进行补偿。

简短的回答是 "不"。在上述过程中，我们试图找到系数[2.x.1832]，使条款的平方之和最小。

[1.x.724]

补偿变换意味着不试图拟合相对于傅里叶频率[2.x.1834][1.x.725]的衰减[2.x.1833]，而是拟合在参考单元[1.x.726]上计算的系数[2.x.1835]，其中[2.x.1836]是变换算子的规范（即类似单元直径的东西）。换句话说，我们将不得不最小化条款的平方之和

[1.x.727]

来代替。然而，利用对数的基本属性，这只是相当于最小化了

[1.x.728]

换句话说，这个问题和原来的最小二乘法问题将产生相同的最佳拟合指数[2.x.1837]，尽管偏移量在一种情况下是[2.x.1838]，在另一种情况下是[2.x.1839] 。然而，由于我们对偏移量根本不感兴趣，而只对指数感兴趣，所以我们是否对傅里叶频率进行缩放以考虑网格大小的影响并不重要，在两种情况下估计的平滑度指数都是一样的。




[1.x.729]

[1.x.730]

[2.x.1840]-方法的问题之一是，形状函数的高多项式程度与大量受限自由度一起导致矩阵的某些行有大量非零条目。同时，因为有些地方我们使用的是低多项式度，因此矩阵行的非零项相对较少。因此，为这些矩阵分配稀疏性模式是一个挑战：我们不能简单地从带宽的估计开始组装一个SparsityPattern，而不使用大量的额外内存。

我们为底层线性系统创建SparsityPattern的方式与我们用来执行约束的策略紧密相连。 deal.II支持以两种方式处理线性系统中的约束。<ol> [2.x.1841] 在不考虑约束条件的情况下组装矩阵，之后用[2.x.1842]或[2.x.1843]来应用约束条件 [2.x.1844] 在我们用[2.x.1845][2.x.1846]来组装系统时应用约束条件。然后系统矩阵使用从DynamicSparsityPattern复制过来的SparsityPattern。这个方法在步骤2中解释，并在大多数教程程序中使用。

早期的教程程序使用一阶或二阶有限元，因此去除与受限自由度相对应的稀疏模式中的条目不会对矩阵明确存储的零的总体数量产生很大影响。然而，由于多达三分之一的自由度在hp微分中可能受到约束（对于高阶元素，这些约束可以将一个自由度与多达10个或20个其他自由度相联系），值得考虑这些约束，因为所产生的矩阵将更加稀疏（因此，矩阵-向量乘积或因子化也将大大加快）。




[1.x.731]

[2.x.1848]方法的第二个问题是，我们有如此多的受限自由度：通常有三分之一的自由度（在三维中）是受限的，因为它们要么属于有悬空节点的单元，要么位于与具有更高或更低多项式度的单元相邻的单元上。事实上，这并不比非[2.x.1849]模式中受约束自由度的比例高多少，但不同的是，每个受约束的悬空节点不仅受制于相邻的两个自由度，而且还受制于更多的自由度。

事实证明，在步骤6中首先提出的在用[2.x.1850]计算元素矩阵和向量时消除约束的策略，对于这种情况也是最有效的方法。另一种策略是首先建立没有约束的矩阵，然后 "浓缩 "掉有约束的自由度，这种策略要昂贵得多。事实证明，用这种低效率的算法建立稀疏模式至少需要[2.x.1851]个未知数，而理想的有限元程序当然只有与未知数成线性的算法。对稀疏模式的创建以及矩阵的装配进行计时显示，步骤6中提出的算法（并在下面的代码中使用）确实更快。

在我们的程序中，我们也将把边界条件作为（可能是不均匀的）约束条件，并把矩阵的行和列也消除。为此我们要做的就是在设置阶段调用插值Dirichlet边界条件的函数，以便告诉AffineConstraints对象关于它们的情况，然后同时在矩阵和向量上做从局部到全局的数据转移。这正是我们在步骤6中所展示的。




[1.x.732]

我们要用这个程序解决的测试案例是我们在第14步中已经看过的一个案例的重考：我们要解决拉普拉斯方程

[1.x.733]

2d，与[2.x.1852]，以及[2.x.1853]的零Dirichlet边界值。我们在域[2.x.1854]上这样做，即一个中间有一个方孔的正方形。

当然，与第14步的不同之处在于，我们使用[2.x.1855]-无限元素来求解。这个测试案例是有意义的，因为它在洞的四角有重入角，在这些地方的解有奇异性。因此，我们期望解在域的内部是平滑的，而在奇点附近是粗糙的。希望我们的细化和光滑度指标能够看到这种行为，并在远离奇点的地方细化网格，同时提高多项式的度数。正如我们将在结果部分看到的，情况确实如此。


examples/step-27/doc/results.dox



[1.x.734]

在这一节中，我们讨论了运行当前教程程序所产生的一些结果。更多的结果，特别是对三维计算的扩展和确定程序的各个部分需要多少计算时间，在[2.x.1856]"hp-paper "中给出。

当运行时，这是该程序产生的结果。

[1.x.735]



我们从中了解到的第一件事是，受限自由度的数量是总自由度的20-25%，至少在后来的网格上，当我们有相对高阶的元素时（在三维中，受限自由度的比例可以达到30%）。事实上，这与非[2.x.1857]分化的数量级相同。例如，在第6步程序的最后一步，我们有18353个自由度，其中4432个是受约束的。不同的是，在后一个程序中，每个受约束的悬挂节点只对相邻的两个自由度进行约束，而在[2.x.1858]-案例中，受约束的节点对许多自由度进行约束。还要注意的是，目前的程序在约束列表中还包括受迪里希特边界条件约束的节点。在第0周期中，所有的约束实际上都是因为边界条件。

也许更感兴趣的是看一下图形输出。首先，这是该问题的解决方案。

<img src="https://www.dealii.org/images/steps/developer/step-27-solution.png" alt="解决方案的立面图，显示出在内部（再入）角落附近缺乏规则性。" width="200" height="200">

其次，让我们看看生成网格的顺序。

<div class="threecolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.mesh-00.svg" alt="包含无适应性细化的再入角的三角图。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.mesh-01.svg" alt="包含有一级细化的再入角的三角图。新的单元格被放置在角落附近。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.mesh-02.svg" alt="包含具有两级细化的重入角的三角图。新的单元格被放置在角落附近。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.mesh-03.svg" alt="包含三层细化的重入角的三角图。新的单元格被放置在角落附近。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.mesh-04.svg" alt="含有四级细化的重入角的三角图。新的单元格被放置在角落附近。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.mesh-05.svg" alt="包含有五级细化的重入角的三角图。新的单元被放置在角附近。" width="200" height="200"> </div> </div> </div>

我们可以清楚地看到，在角部奇点附近的网格是如何被细化的，正如我们所期望的那样。更有趣的是，我们应该好奇地看看这些网格单元的有限元多项式的度数分布，其中最浅的颜色对应于度数2，最深的对应于度数7。

<div class="threecolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-00.svg" alt="初始网格，所有单元格只包含双二次函数。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-01.svg" alt="一次细化后的局部近似度描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-02.svg" alt="两次细化后的局部近似度描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-03.svg" alt="三次细化后的局部近似度描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-04.svg" alt="四次细化后的局部近似度描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-05.svg" alt="五次细化后的局部近似度描述。" width="200" height="200"> </div> </div>

虽然这肯定不是一个完美的安排，但它确实有一定的意义：我们在靠近边界和角落的地方使用低阶元素，那里的规则性很低。另一方面，在以下情况下使用高阶元素：(i) 误差一度相当大，即主要在角部奇点周围的一般区域和右上角解大的地方；(ii) 解是平滑的，即远离边界的地方。

这种多项式程度的安排当然是由我们的平滑度估计器得出的。这里是对解决方案的平滑度的估计，深色表示最不平滑，浅色表示最平滑的区域。

<div class="threecolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-00.svg" alt="初始网格上每个单元的估计规则性。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-01.svg" alt="经过一次细化后每个单元的估计规则性的描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-02.svg" alt="经过两次细化后每个单元估计规则性的描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-03.svg" alt="经过三次细化后每个单元格的估计规则性的描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-04.svg" alt="经过四次细化后每个单元格的估计规则性的描述。" width="200" height="200"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-05.svg" alt="经过五次细化后每个单元格的估计规则性的描述。" width="200" height="200"> </div> </div>

从这里可以得出的主要结论是，内角的规则性损失是一个高度局部的现象；它似乎只影响到与角本身相邻的单元，所以当我们细化网格时，黑色的颜色不再可见。除了角部，这一连串的图示意味着平滑度估计在某种程度上与网格细化无关，特别是当我们远离边界时。同样明显的是，平滑度估计值与解的实际尺寸无关（见上面的解的图片），这也是应该的。然而，更值得关注的一点是，人们在仔细观察后发现，我们的估计器高估了有悬空节点的单元格的解决方案的平滑度。这反过来又导致了这些区域的多项式度数更高，使有限元在单元上的分配出现偏差。

对于这种效果，我们目前还没有很好的解释。一种理论是，在有悬挂节点的单元上的数值解当然是受限制的，因此不能完全自由地探索函数空间以接近精确解。这种自由度的缺乏可能表现为在这些单元上产生具有抑制振荡的数值解，意味着更高的平滑度。估计器会捕捉到这个信号，估计的平滑度会高估实际值。然而，这个程序的作者目前还没有得到关于发生了什么的明确答案。

当然，更大的问题是如何避免这个问题。可能的做法包括不是在单个细胞上估计平滑度，而是在每个细胞周围的细胞集合体或斑块上估计平滑度。也可能为每个细胞找到简单的校正因子，这取决于它所拥有的受限自由度的数量。无论哪种情况，都有大量的机会来进一步研究寻找好的[2.x.1859]-精化标准。另一方面，目前方案的主要内容是在deal.II中演示使用[2.x.1860]-技术，这不受我们使用可能的次优细化标准的影响。




[1.x.736]

[1.x.737]

[1.x.738]

本教程只演示了决定[2.x.1861]-和[2.x.1862]-适应的一个特殊策略。事实上，还有许多自动决定适应类型的方法，其中一些已经在deal.II中实现： [2.x.1863] [2.x.1864] [1.x.739] 这是本教程中目前实现的策略。有关该策略的更多信息，请参见[2.x.1865]命名空间的一般文档。[2.x.1866]

   [2.x.1867] [1.x.740] 这个策略与目前的策略很相似，但使用了Legendre级数扩展，而不是傅里叶级数：这个策略使用Legendre多项式，而不是正弦波作为基础函数。当然，由于我们在每个单元上使用有限维度的多项式来近似解，因此解在Legendre多项式中的扩展也是有限的，因此，当我们谈论这个扩展的 "衰减 "时，我们只能考虑这个扩展的有限多个非零系数，而不是用渐进的方式来思考。   但是，如果我们有足够多的这些系数，我们当然可以把这些系数的衰减看作是精确解的系数衰减的特征（一般来说，精确解不是多项式的，所以会有一个无限的Legendre扩展），考虑我们拥有的系数应该可以揭示一些关于精确解的特性。

  从傅里叶策略过渡到Legendre策略是非常简单的。   你只需要改变序列扩展类和相应的平滑度估计函数，使其成为适当命名空间[2.x.1868]和[2.x.1869]的一部分，这个策略在step-75中使用。关于这个策略的理论背景，请参考[2.x.1870]命名空间的一般文档，以及[2.x.1871]、[2.x.1872]和[2.x.1873] 。[2.x.1874]

   [2.x.1875] [1.x.741] 最后一种策略与其他两种截然不同。在理论上，我们知道在改变函数空间离散化后，误差将如何收敛。用[2.x.1876]-细化，解会以代数方式收敛，正如在步骤7中已经指出的。不过，如果解足够平滑，我们预计解将随着有限元的多项式程度的增加而指数级收敛。我们可以在下面的步骤中把对误差的正确预测与实际误差进行比较，看看我们对适应类型的选择是否合理。

  向这一策略的过渡要复杂一些。为此，我们需要一个纯[2.x.1877]-或[2.x.1878]-细化的初始化步骤，我们需要将预测的误差转移到适应的网格上。[2.x.1879]函数的大量文档不仅描述了这种方法的理论细节，而且还介绍了如何在你的代码中实现这种策略的蓝图。欲了解更多信息，请参见 [2.x.1880] 。

  请注意，用这个特殊的函数，你无法预测时间依赖性问题的下一个时间步骤的误差。因此，这种策略不能不加思索地应用于这种类型的问题。另外，也可以使用下面的方法，这也适用于所有其他的策略：从每个时间步长的粗网格开始，不断细化，直到对结果满意，然后才进入下一个时间步长。[2.x.1881] [2.x.1882]。

试着在本教程中实施这些策略之一，观察结果的微妙变化。你会注意到，所有的策略都能够识别重心角附近的奇点，并在这些区域执行[2.x.1883]-精简，而在体域中更倾向于[2.x.1884]-精简。这些策略的详细比较见[2.x.1885] 。




[1.x.742]

本教程中介绍的所有功能都已经适用于顺序和并行应用。不费吹灰之力就可以改成[2.x.1886]或[2.x.1887]类。如果你觉得急于尝试，我们建议先阅读前者的第18步和后者的第40步，以进一步了解该主题的背景信息，然后再回到本教程来尝试你新获得的技能。

我们在第75步中更进一步：在这里，我们将hp-adapative和MatrixFree方法与[2.x.1888]对象结合在一起。


examples/step-28/doc/intro.dox

[2.x.1889]

[1.x.743][1.x.744][1.x.745]

[2.x.1890]


[1.x.746] [1.x.747] 在这个例子中，我们打算解决中子传输方程的多组扩散近似。基本上，看待这个问题的方式如下。在核反应堆中，中子以不同的能量飞驰，被吸收或散射，或开始一个新的裂变事件。如果从足够长的长度尺度来看，中子的运动可以被视为一个扩散过程。

对这一点的数学描述将把中子归入能级，并考虑每个能级或能量组中的中子通量的平衡方程。然后，散射、吸收和裂变事件将成为描述中子通量的扩散方程中的算子。假设我们有能量组[2.x.1891]，按照惯例，我们假设能量最高的中子在1组，能量最低的中子在[2.x.1892]组。那么每组的中子通量满足以下公式。

[1.x.748]

通过适当的边界条件增强。这里，[2.x.1893]是[2.x.1894]组内中子的速度。换句话说，[2.x.1895]组中的中子通量的时间变化受以下过程支配。  2.x.1896] [2.x.1897] 扩散 [2.x.1898] 。这里，[2.x.1899]是（空间上可变的）扩散系数。  [2.x.1900] 吸收 [2.x.1901] （注意是负号）。系数[2.x.1902]被称为[1.x.749]。  [2.x.1903] 核裂变 [2.x.1904] 。   能量的中子[2.x.1905]的产生与能量的中子通量[2.x.1906]乘以能量的中子[2.x.1907]引起裂变事件的概率[2.x.1908]乘以每个裂变事件中产生的中子数量[2.x.1909]乘以该事件中产生的中子具有能量的概率[2.x.1910] 。  [2.x.1911]被称为[1.x.750]，[2.x.1912]被称为[1.x.751]。我们将把[2.x.1913]这个词表示为程序中的[1.x.752]。  [2.x.1914]能量为[2.x.1915]的中子的散射[2.x.1916]产生能量为[2.x.1917]的中子 。  2.x.1918]被称为[1.x.753]。弹性、群内散射[2.x.1919]的情况也存在，但我们将其归入清除截面。[2.x.1920]的情况被称为向下散射，因为中子在这样的事件中失去了能量。另一方面，[2.x.1921]对应于上散射：中子在散射事件中从其周围原子的热运动中获得能量；因此，上散射仅对动能已经与热动能处于同一等级（即在[2.x.1922]以下范围）的中子是一个重要过程。  [2.x.1923] 一个外源 [2.x.1924] 。  [2.x.1925]

为了在反应堆分析中进行现实模拟，人们可能希望将中子能量的连续谱分成许多能量组，通常多达100个。然而，如果对某些类型的反应堆（例如压水反应堆，PWR）的中子能谱有足够的了解，那么只用2个能群就有可能获得满意的结果。

在本教程的程序中，我们提供的结构可以根据需要用尽可能多的能量组进行计算。然而，为了保持适度的计算时间，并避免将数百个系数列表，我们只提供上述两组模拟方程的系数，即 [2.x.1926] 。然而，我们确实考虑了一个现实的情况，即假设系数不是恒定的，而是取决于以相当复杂的方式装配到反应堆燃料组件的材料（见下文）。




[1.x.754]

如果我们一次考虑所有的能量组，我们可以将上述方程写成以下算子形式。

[1.x.755]

其中[2.x.1927]分别是沉降、裂变和散射算子。  这里的[2.x.1928]包括扩散和清除项。请注意，[2.x.1929]是对称的，而[2.x.1930]和[2.x.1931]不是。

众所周知，如果算子[2.x.1932]的所有特征值都是负的，这个方程就有一个稳定的解。这可以通过将方程乘以[2.x.1933]并在域上进行积分而很容易看出，从而导致

[1.x.756]

稳定性意味着解决方案不会增长，也就是说，我们希望左手边的值小于零，如果右边算子的特征值都是负的，就会出现这种情况。由于显而易见的原因，如果核反应堆产生的中子通量呈指数增长，这不是很理想，所以特征值分析是核工程师的面包和主食。因此，该程序的要点是考虑特征值问题

[1.x.757]

其中我们要确保所有的特征值都是正的。请注意，[2.x.1934]，即扩散算子加上吸收（去除），是正定的；因此，所有特征值为正的条件意味着我们要确保裂变和组间散射足够弱，不会使频谱转移到负值。

在核工程中，人们通常会关注特征值问题的一个稍微不同的表述。为此，我们不只是与[2.x.1935]相乘并整合，而是与[2.x.1936]相乘。然后我们得到以下演化方程。

[1.x.758]

如果以下问题的特征值都是负的，那么稳定性就得到了保证。

[1.x.759]

等同于特征值问题

[1.x.760]

核工程中的典型表述是将其写为

[1.x.761]

其中[2.x.1937] 。直观地说，[2.x.1938]是类似于每个典型时间尺度的中子的乘法系数，对于反应堆的稳定运行，它应该小于或等于1：如果它小于1，链式反应将消亡，而核弹等的[2.x.1939]-特征值大于1。一个稳定的反应堆应该有[2.x.1940] 。

对于那些想知道在实践中如何才能做到这一点，而又不至于在不经意间变得稍大而引发核弹的人来说：首先，裂变过程发生在不同的时间尺度上。虽然大多数中子在裂变事件后很快就被释放出来，但少量的中子只有在裂变开始后经过几次进一步的衰变后，才会由子核释放出来，最长可达10-60秒。因此，如果一个人稍稍超过[2.x.1941]，就会有许多秒的反应时间，直到裂变中产生的所有中子重新进入裂变循环。然而，吸收中子的核反应堆中的控制棒--并因此减少[2.x.1942]--被设计成最多在2秒内全部进入反应堆。

因此，如果[2.x.1943]在一段时间内大于1，正如不断增长的中子通量所显示的那样，人们有10-60秒的时间来调节核反应。调节可以通过持续监测中子通量来实现，必要时通过将吸收中子的控制棒移入或移出反应堆几毫米来增加或减少中子通量。在更大的范围内，冷却反应堆的水含有硼，一种良好的中子吸收剂。每隔几个小时，通过添加硼或稀释冷却剂来调整硼的浓度。

最后，一些吸收和散射反应有一些内置的稳定性；例如，较高的中子通量导致局部温度升高，这降低了水的密度，因此减少了散射体的数量，而这些散射体是在中子开始裂变事件本身之前将其从高能量调节到低能量所必需的。

在这个教程程序中，我们解决上述[2.x.1944]-两个能量组的特征值问题，我们正在寻找最大的乘法因子[2.x.1945] ，它与最小特征值的逆值加1成正比。为了解决特征值问题，我们一般使用[1.x.762]的修改版。该算法看起来像这样。

<ol> [2.x.1946] 用[2.x.1949]和[2.x.1950]初始化[2.x.1947]和[2.x.1948]，让[2.x.1951] .

[2.x.1952] 通过[1.x.764]定义所谓的[1.x.763]。



[2.x.1953] 利用[1.x.765]求解所有组通量[2.x.1954] 。



[2.x.1955] 更新[1.x.766] 。



[2.x.1956] 比较[2.x.1957]和[2.x.1958] 。   如果变化大于规定的公差，则设置 [2.x.1959] 从步骤2开始重复迭代，否则结束迭代。  [2.x.1960]

需要注意的是，在这个方案中，我们在每次幂迭代中并不完全求解群通量，而是考虑以前只计算 [2.x.1961] 的下散射事件 [2.x.1962] 。上散射仅通过使用旧的迭代器[2.x.1963]来处理，实质上是假设散射算子是三角形的。这在物理上是有原因的，因为向上散射在中子散射中并不扮演太重要的角色。此外，实践表明，即使使用这种简化方法，反功率迭代也是稳定的。

还要注意的是，我们可以使用很多外推技术来加速上述的功率迭代。然而，这些都没有在这个例子中实现。




[1.x.767]

人们可能会想，在同一网格上求解各个能量组方程的解是否合适。这个问题可以归结为：[2.x.1964]和[2.x.1965]是否会有类似的光滑度特性？如果是这样的话，那么对两者使用相同的网格是合适的；一个典型的应用可能是化学燃烧，通常所有或大多数化学物种的浓度在火焰前沿快速变化。事实证明，通过观察本教程程序结果部分显示的图形就会发现，然而这里的情况并非如此：由于不同能量组的扩散系数不同，快中子（在小群数[2.x.1966]的仓中）有一个非常平滑的通量函数，而慢中子（在大群数的仓中）受当地材料特性的影响更大，如果像我们这里计算的情况一样，系数粗糙，则有一个相应的粗糙解决方案。因此，我们要使用不同的网格来计算每个能量组。

这有两个影响，我们将不得不考虑。首先，我们需要找到一种方法来单独细化这些网格。第二，为逆功率迭代组装源项，我们必须将定义在网格[2.x.1968]上的解[2.x.1967]与定义在网格[2.x.1969]上的形状函数进行整合，这将成为一项更为复杂的任务。




[1.x.768]

我们使用通常的范式：在一个给定的网格上求解，然后为每个网格的每个单元评估一个误差指标。因为它非常方便，我们再次使用Kelly, Gago, Zienkiewicz和Babuska的事后误差估计器，它通过整合每个单元面的解的梯度跳跃来接近每个单元的误差。利用这一点，我们得到指标

[1.x.769]

其中[2.x.1970]是用于解决[2.x.1971]的三角法。问题是该如何处理这个问题。其一，很明显，只细化那些误差指标最高的单元可能会导致不好的结果。为了理解这一点，必须认识到[2.x.1972]与[2.x.1973]的二阶导数成比例。换句话说，如果我们有两个能量组[2.x.1974]，它们的解同样平滑，但其中一个大了一万倍，例如，那么只有该网格的单元被细化，而小幅度的解的网格将保持粗糙。这可能不是人们想要的，因为我们可以认为解的两个部分同样重要。

因此，从本质上讲，我们必须用一个重要系数[2.x.1976]来衡量[2.x.1975]，这个系数表示将[2.x.1977]解决到任何特定的精度有多重要。这样的重要系数可以用二元性技术来计算（例如，见step-14教程程序，以及那里引用的Bangerth和Rannacher的书的参考）。然而，我们不会去那里，而只是假设所有的能量组都是同等重要的，因此将以解[2.x.1980]的最大值来规范[2.x.1978]组的误差指标[2.x.1979] 。然后我们对误差满足以下条件的单元进行细化

[1.x.770]

和粗化的细胞，其中

[1.x.771]

我们在代码中选择了［2.x.1981］和［2.x.1982］。注意，这当然会导致不同能量组的不同网格。

上面的策略实质上意味着以下几点。如果对于能量组[2.x.1983]来说，有许多单元[2.x.1984]的误差很大，例如因为解决方案在整体上非常粗糙，那么许多单元将高于阈值。另一方面，如果有几个单元的误差较大，而许多单元的误差较小，例如因为除少数地方外，解决方案总体上相当平滑，那么只有少数有较大误差的单元将被细化。因此，该策略允许网格很好地跟踪相应的解决方案的全局平滑性属性。




[1.x.772]

如上所述，多组细化策略导致不同解的网格不同 [2.x.1985] 。那么问题出在哪里呢？实质上是这样的：在特征值迭代的第3步中，我们要像往常一样通过与定义在网格上的测试函数[2.x.1987]相乘来形成要计算的方程的弱形式[2.x.1986]；在这个过程中，我们要计算包含以下形式的项的右手向量。

[1.x.773]

其中[2.x.1989]是用于特征值方程右侧的系数函数[2.x.1990]或[2.x.1991]中的一个。现在的困难是，[2.x.1992]是定义在能量组[2.x.1993]的网格上，即它可以扩展为[2.x.1994]，基函数[2.x.1995]定义在网格[2.x.1996]。因此，对右边的贡献可以写成

[1.x.774]

另一方面，测试函数 [2.x.1997] 是在网格 [2.x.1998] 上定义的。这意味着我们不能将积分 [2.x.1999] 分割成网格 [2.x.2000] 或 [2.x.2001] 上的积分，因为其他的基函数可能没有定义在这些单元上。

这个问题的解决方案在于，[2.x.2002]和[2.x.2003]的网格都是通过自适应细化从一个共同的粗略的网格中得到。因此，我们总能找到一组单元，我们用[2.x.2004]表示，它们满足以下条件。  2.x.2005] [2.x.2006] 这些单元的联合覆盖了整个领域，并且 [2.x.2007] 一个单元 [2.x.2008] 在两个网格中至少有一个是活动的。  [2.x.2009] 构建这个集合的方法是，取粗略网格的每个单元，做以下步骤。(i) 如果该单元在[2.x.2010]或[2.x.2011]上处于活动状态，则将该单元加入该集合；(ii) 否则，即如果该单元在两个网格上都有子节点，则对该单元的每个子节点进行步骤(i)。事实上，deal.II有一个函数[2.x.2012]，可以准确地计算出在两个网格中至少有一个处于活动状态的单元的集合。

有了这个，我们可以把上述积分写成如下。

[1.x.775]

在代码中，我们在函数[2.x.2013]中计算右手边，其中（除其他外）我们在常见的最精炼的单元格集合上循环，对这些单元格的每一对调用函数[2.x.2014]。

根据结构，现在有三种情况需要考虑。<ol> [2.x.2015] 单元[2.x.2016]在两个网格上都是有效的，也就是说，基函数[2.x.2017]以及[2.x.2018]都是在[2.x.2019]上定义。  [2.x.2020] 单元[2.x.2021]在网格[2.x.2022]上是有效的，但在[2.x.2023]上不是，即[2.x.2024]是在[2.x.2025]上定义的，而[2.x.2026]是在[2.x.2027]的子网格上定义的。  [2.x.2028] 单元[2.x.2029]在网格[2.x.2030]上是有效的，但在[2.x.2031]上不是，其结论与(ii)相反。  [2.x.2032]

为了计算上面的右手边，我们就需要对这三种情况有不同的代码，如下所示。<ol> [2.x.2033] 如果单元[2.x.2034]在两个网格上都是活动的，那么我们可以直接评估积分。事实上，我们甚至不必理会基函数[2.x.2035]，因为我们所需要的只是[2.x.2036]在正交点的值。我们可以使用[2.x.2037]函数来完成这个任务。这在[2.x.2038]函数中直接完成。

[2.x.2039] 如果单元格 [2.x.2040] 在网格 [2.x.2041] 上是有效的，而不是 [2.x.2042] ，那么基函数 [2.x.2043] 只能定义在子单元 [2.x.2044] 上，或者在这些子单元 [2.x.2045] 上被精炼一次以上。

  让我们假设[2.x.2047]在网格[2.x.2048]上只比在网格[2.x.2049]上多精炼一次。利用我们使用嵌入式有限元空间的事实，即一个网格上的每个基函数可以写成下一个细化网格上的基函数的线性组合，我们可以将[2.x.2050]对子单元[2.x.2051]的限制扩展为定义在该子单元上的基函数（即定义了基函数[2.x.2052]的单元上）。   [1.x.776]

  在这里，以及在下文中，对出现两次的指数进行求和是隐含的。矩阵[2.x.2053]是将数据从一个单元格内插到其[2.x.2054]的子单元的矩阵。

  那么我们可以把单元格[2.x.2055]对右侧分量[2.x.2056]的贡献写成[1.x.777] 。

  在矩阵符号中，这可以写成[1.x.778]

  其中[2.x.2057]是单元格[2.x.2059]的子[2.x.2058]上的加权质量矩阵。

  下一个问题是，如果[2.x.2061]的一个子集[2.x.2060]没有被激活，会发生什么？然后，我们必须递归地应用这个过程，即我们必须将基础函数[2.x.2062]插值到[2.x.2064]的子[2.x.2063]上，然后插值到该单元的子[2.x.2065]上，插值到该单元的子[2.x.2066]上，等等，直到我们找到一个活动单元。然后，我们必须将单元格[2.x.2067]的所有子代、孙代等的贡献相加，其贡献形式为[1.x.779] 。

  或[1.x.780]

  等等。我们递归地做这个过程，即如果我们坐在单元格[2.x.2068]上，看到它在网格[2.x.2069]上有孩子，那么我们就用一个身份矩阵调用一个函数[2.x.2070]；该函数将把它的参数从左边乘以延长矩阵；如果该单元格还有孩子，它将用这个新矩阵调用自己，否则它将进行整合。

[2.x.2071] 最后一种情况是[2.x.2072]在网格[2.x.2073]上是有效的，但在网格[2.x.2074]上不是。在这种情况下，我们必须用定义在单元格 [2.x.2076] 上的基函数来表达基函数 [2.x.2075] ，而不是像以前那样用 [2.x.2077] 来表达。这当然是以完全相同的方式进行的。如果[2.x.2078]的子单元在网格[2.x.2079]上是活动的，那么就会导致表达式[1.x.781] 。

  在矩阵符号中，这个表达式现在读作[1.x.782] 。

  而相应地，对于单元格[2.x.2080]在网格[2.x.2081]上被精炼一次以上的情况：[1.x.783] 。

  或[1.x.784]

  等。换句话说，这个过程与之前的工作方式完全相同，只是我们必须采取延长矩阵的转置，并需要从另一侧乘以质量矩阵。  [2.x.2082]


情况（二）和（三）的表达式可以理解为将标量积[2.x.2083]中的左或右基函数反复插值到子单元上，然后在最后的单元上形成内积（质量矩阵）。为了使这些情况的对称性更加明显，我们可以这样写：对于情况（二），我们有

[1.x.785]

而对于情况（三），我们得到

[1.x.786]






[1.x.787]

一个核反应堆的堆芯是由不同类型的组件组成的。一个组件基本上是可以在反应堆内和外移动的最小单元，通常是矩形或方形。然而，组件并不是固定的单位，因为它们是由不同的燃料棒、控制棒和仪器元件组成的复杂晶格组装而成的，这些元件通过永久连接到燃料棒上的间隔件来保持彼此的位置。使事情更加复杂的是，在反应堆中同时使用不同种类的组件，这些组件在其组成的燃料棒的类型和排列上有所不同。

显然，组件的排列以及组件内燃料棒的排列都会影响反应堆内中子通量的分布（这一事实通过查看本方案结果部分中下面显示的解决方案就会很明显）。例如，燃料棒在铀235或钚239的富集程度上彼此不同。另一方面，控制棒具有零裂变，但散射和吸收截面不为零。

这整个安排将使描述或空间上的材料参数变得非常复杂。它不会变得更简单，但我们将做一个近似：我们将每个圆柱形棒和周围的水所居住的体积合并成二次横截面的体积，变成所谓的 "夹子单元"，用核数据库和中子光谱的知识获得这些单元的同质化材料数据。同质化使所有材料数据在带有新燃料的反应堆的求解域上成为片状常数。然后为一个点所在的四元组查询空间相关的材料参数，然后为这个四元组中的四元针单元查询。

在这个教程程序中，我们模拟了一个由[2.x.2084]组件组成的反应堆的四分之一。我们使用对称性（Neumann）边界条件，将问题缩小到四分之一的领域，因此只模拟[2.x.2085]套组件。其中两个将是UO[2.x.2086]燃料，另外两个是MOX燃料。这些组件中的每一个都由不同成分的[2.x.2087]棒组成。因此，我们总共创造了一个[2.x.2088]棒子的晶格。为了使以后的事情更简单，我们通过创建一个[2.x.2089]单元的粗大网格来反映这一事实（尽管领域是一个正方形，我们通常会使用一个单元）。在deal.II中，每个单元都有一个[2.x.2090]，可以用来将每个单元与一个特定的数字联系起来，识别这个单元的体积是由什么材料制成的；我们将使用这个材料ID来识别在这个测试案例中使用的8种不同的杆子中的哪一种组成了一个特定的单元。请注意，在网格细化后，单元格的子代会继承材料ID，这样即使在网格细化后也能简单地跟踪材料。

在结果部分显示的图像中，棒的排列将清晰可见。材料和两个能量组的横截面取自OECD/NEA的基准问题。详细的配置和材料数据在代码中给出。




[1.x.788]

作为对程序具体工作的粗略概述，这里是基本布局：从每个能量组相同的粗略网格开始，我们计算反特征值迭代以计算给定网格集上的[2.x.2091]特征值。当特征值的变化低于一定的容忍度时，我们停止这些迭代，然后写出每个能量组的网格和解，供图形程序检查。由于解决方案的网格是不同的，我们必须为每个能量组生成一个单独的输出文件，而不是能够将所有能量组的解决方案添加到同一个文件中。

在这之后，我们按照上面某一节的解释对每个网格的误差指标进行评估，并独立地对每个网格的单元进行细化和粗化。由于特征值迭代是相当昂贵的，我们不想在新的网格上重新开始；相反，我们使用SolutionTransfer类在网格细化时将前一个网格的解插到下一个网格。一个简单的实验会让你相信，这比我们省略这一步要省事得多。这样做之后，我们在下一组网格上继续进行特征值迭代。

该程序由一个参数文件控制，使用ParameterHandler类。我们将在本教程的结果部分展示一个参数文件。现在只需说它控制了所使用的有限元的多项式程度、能量组的数量（尽管目前实现的只是2组问题的系数）、停止反特征值迭代的容忍度以及我们要做的细化循环的数量。


examples/step-28/doc/results.dox



[1.x.789]

我们可以用下面的输入文件运行该程序。

[1.x.790]

这个程序的输出包括控制台输出，一个名为 "convergence_table "的文件，记录网格迭代的主要结果，以及vtu格式的图形输出。

控制台的输出看起来像这样。

[1.x.791]



我们看到动力迭代在第0周期后确实收敛得更快，这是因为用上一次网格迭代的解决方案进行了初始化。收敛表 "的内容是。

[1.x.792]

列的含义是：网格迭代次数，快速能量组的自由度数，热能组的自由度数，收敛的K效应和快速通量的最大值和热能的最大值之间的比率。

网格迭代#9时，快速和热能组的网格看起来如下。

[2.x.2092]&nbsp; [2.x.2093] 。

我们看到，热组的网格比快组的网格要细得多。这些网格上的解决方案是：（注：通量被归一化，总裂变源等于1）。

[2.x.2094] &nbsp; [2.x.2095]

然后我们绘制出多项式阶数等于1、2和3的收敛数据。

[2.x.2096]

估计的 "精确的 "k-effective=0.906834721253，这只是从最后一次网格迭代的多项式阶数3减去2e-10。我们看到，h-adaptive计算提供了一个代数收敛性。多项式阶数越高，网格迭代收敛的速度越快。在我们的问题中，我们需要较少的DoFs数量来实现较高的多项式阶数下的相同精度。


examples/step-29/doc/intro.dox

[2.x.2097]

[1.x.793]

[1.x.794] 为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接求解器。请参考[1.x.795]中的说明如何做到这一点。


[1.x.796]

[1.x.797]


一个经常出现的问题是如何用deal.II解决涉及复值函数的问题。对于许多问题，与其直接使用复值有限元，不如将复值函数分成实部和虚部，并使用单独的标量有限元场来离散它们中的每一个，这样做往往更方便。基本上，这相当于把一个复值方程看作是两个实值方程的系统。这个简短的例子演示了如何在deal.II中通过使用[2.x.2098]对象来堆叠两个代表实部和虚部的有限元场来实现。(相反的方法，保持所有的复值，在另一个教程程序中演示：见步骤58)。当分成实部和虚部时，这里涉及的方程属于矢量值问题的范畴。这个主题的顶层概述可以在 [2.x.2099] 模块中找到。

除了这些讨论，我们还讨论了ParameterHandler类，它提供了一种方便的方法，在运行时从配置文件中读取参数，而不需要重新编译程序代码。




[1.x.798]

这个程序的最初目的是模拟由一个几何形状可变的换能器透镜产生的超声波的聚焦特性。最近在医学成像方面的应用，不仅将超声波用于成像，而且还能激发材料中的某些局部效应，如光学特性的变化，然后可以用其他成像技术来测量。这些方法的一个重要因素是能够将超声波的强度集中在材料的一个特定部分，最好是一个点，以便能够检查该特定位置的材料特性。

为了推导出这个问题的模型，我们把超声波看成是由波浪方程支配的压力波。

[1.x.799]

其中[2.x.2100]是波速（为简单起见，我们假设为常数），[2.x.2101] 。边界[2.x.2102]分为两部分[2.x.2103]和[2.x.2104]，其中[2.x.2105]代表换能器透镜，[2.x.2106]是吸收边界（也就是说，我们希望在[2.x.2107]上选择边界条件，使其模仿一个更大的域）。在[2.x.2108]上，换能器产生一个恒定频率[2.x.2109]和恒定振幅（我们在这里选择为1）的波。

[1.x.800]



如果没有其他（内部或边界）源，并且由于唯一的源具有频率[2.x.2110]，那么解决方案可以接受形式为[2.x.2111]的变量分离。复值函数[2.x.2112]描述了频率为[2.x.2113]的波的振幅和相位（相对于源）的空间依赖性，其中振幅是我们感兴趣的量。通过将这种形式的解决方案插入波浪方程，我们看到，对于[2.x.2114]，我们有

[1.x.801]



为了在[2.x.2115]上找到模拟吸收边界的合适条件，考虑一个频率为[2.x.2117]的波在[2.x.2118]方向上行驶。为了使[2.x.2119]能够解决波浪方程，[2.x.2120]必须成立。假设这个波以直角击中[2.x.2121]的边界，即[2.x.2122]，[2.x.2123]表示[2.x.2124]在[2.x.2125]的外单位法线。然后在[2.x.2126]，这个波满足方程式

[1.x.802]

因此，通过强制执行边界条件

[1.x.803]

以直角撞击边界[2.x.2127]的波将被完全吸收。另一方面，那些没有以直角撞击边界的波场部分不满足这个条件，将其作为边界条件强制执行会产生部分反射，即只有部分波会通过边界，就像它不在这里一样，而剩下的部分波会被反射回域中。

如果我们愿意接受这一点作为吸收边界的充分近似，我们最终得出以下问题，对于[2.x.2128] 。

[1.x.804]

这是一个亥姆霍兹方程（类似于步骤7中的方程，但这次有''坏符号''），在[2.x.2129]上有Dirichlet数据，在[2.x.2130]上有混合边界条件。由于[2.x.2131]上的条件，我们不能只是分别处理[2.x.2132]的实部和虚部方程。然而，我们可以把[2.x.2133]的PDE看作是[2.x.2134]的实部和虚部的两个PDE系统，[2.x.2135]的边界条件代表系统中两个部分之间的耦合项。这是按以下思路进行的。让[2.x.2136]，然后在[2.x.2137]和[2.x.2138]方面，我们有以下系统。

[1.x.805]



对于[2.x.2139]与[2.x.2140]的测试函数，经过通常的乘法，在[2.x.2141]上的积分和应用部分积分，我们得到弱的表述

[1.x.806]



我们选择有限元空间[2.x.2142]和[2.x.2143]，基数为[2.x.2144]，寻找近似解

[1.x.807]

将其插入变异形式中，可以得到方程组

[1.x.808]

用矩阵符号表示。

[1.x.809]

(不要被这里的右手边为零所迷惑，那是因为我们还没有包括Dirichlet边界数据)。由于非对角线区块的交替符号，我们已经可以看到这个系统是非对称的，事实上它甚至是不确定的。当然，没有必要选择空间[2.x.2145]和[2.x.2146]是相同的。然而，我们期望解的实部和虚部具有类似的性质，因此在实现中确实会采取[2.x.2147]，并且也会对两个空间使用相同的基函数[2.x.2148]。使用不同符号的原因只是让我们能够区分[2.x.2149]和[2.x.2150]的形状函数，因为这种区分在实施中起着重要作用。




[1.x.810]

在计算中，我们将考虑波在单位方阵中的传播，超声由换能器透镜产生，透镜的形状是圆的一段，中心在[2.x.2151]，半径略大于[2.x.2152]；这种形状应该导致声波在圆中心的聚焦。改变[2.x.2153]会改变透镜的 "焦点"，并影响[2.x.2154]强度的空间分布，我们主要关注的是[2.x.2155]的聚焦效果如何。

在下面的程序中，我们将使用实部和虚部分裂的公式来实现复值亥姆霍兹方程。我们还将讨论如何生成一个看起来像正方形并带有轻微隆起的模拟换能器的域（在[2.x.2156]函数中），以及如何生成不仅包含解分量[2.x.2157]和[2.x.2158]，而且直接在输出文件中包含幅值[2.x.2159]的图形输出（在[2.x.2160]）。最后，我们使用ParameterHandler类来轻松读取参数，如焦距[2.x.2161]、波速[2.x.2162]、频率[2.x.2163]，以及在运行时从输入文件中读取其他一些参数，而不是在源代码中固定这些参数，因为每次我们想改变参数时，都必须重新编译。


examples/step-29/doc/results.dox

[1.x.811]

[1.x.812]

当前程序从一个名为[2.x.2164]的输入文件中读取其运行时参数，该文件看起来像这样。

[1.x.813]



可以看出，我们设置了[2.x.2165] ，相当于换能器镜头的焦点在[2.x.2166] ，[2.x.2167] 。粗略的网格被细化了5次，结果是160x160个单元，输出结果以vtu格式写入。参数读取器可以理解更多的参数，特别是与输出的生成有关的参数，但是我们在这里不需要这些参数，因此坚持使用其默认值。

这是调试模式下程序的控制台输出。

[1.x.814]



(当然，如果你在本地运行该程序，执行时间会有所不同。)事实上，大部分时间花在组装系统矩阵和生成输出上是由于在调试模式下需要检查许多断言。在发布模式下，程序的这些部分运行得更快，而求解线性系统的速度几乎没有加快。

[1.x.815]



程序的图形输出看起来如下。


[2.x.2168]

前两张图片显示了[2.x.2169]的实部和虚部，而最后一张显示了强度[2.x.2170]。我们可以清楚地看到，强度集中在镜头的焦点周围（0.5，0.3），焦点在[2.x.2171]-方向上相当尖锐，但在[2.x.2172]-方向上更加模糊，这是聚焦镜头的几何形状、其有限孔径和问题的波性的结果。

因为五颜六色的图形总是很有趣，而且为了进一步强调聚焦效果，这里还有一组图片，强调了强度在[2.x.2173]-方向上的实际聚焦效果。

[2.x.2174]


最后，程序的结构使我们很容易确定程序的哪些部分可以随着网格的细化而很好地扩展，哪些部分不可以。下面是5、6、7次全局细化的运行时间。

[1.x.816]



每次我们细化一次网格，所以每一步的单元和自由度的数量大约是四倍。可以看出，生成网格、设置自由度、组装线性系统和生成输出的规模相当接近于线性，而求解线性系统的操作，自由度的数量每增加4倍，就需要8倍的时间，也就是说，它是[2.x.2175] 。这可以解释为（使用最优排序）有限元矩阵的带宽是 [2.x.2176] ，而使用LU分解解决带状线性系统的努力是 [2.x.2177] 。这也解释了为什么该程序也能在3D中运行（在改变了[2.x.2178]对象的维度后），但其扩展性很差，需要非常耐心才能完成对具有明显分辨率的网格上的线性系统的求解，尽管该程序的其他部分的扩展性非常好。




[1.x.817]

[1.x.818]

这个程序的一个明显的可能的扩展是在3D中运行它&mdash；毕竟，我们周围的世界是三维的，而超声束在三维介质中传播。你可以通过简单地改变[2.x.2179]中主类的模板参数并运行它来尝试。但这不会让你走得很远：当然，如果你按照参数文件中的设置做5个全局细化步骤，就更不会了。你的内存会耗尽，因为网格（含[2.x.2180]单元），特别是稀疏直接求解器会占用太多的内存。然而，如果你有时间的话，你可以用3个全局细化步骤来求解：在2011年初，直接求解大约需要半个小时。然而，你会注意到，这个解是完全错误的：网格大小根本不够小，不能准确地解决解的波浪，你可以在解的图中看到这一点。因此，在这种情况下，如果你不想在这个问题上扔一个更大的（估计是%并行的）机器，那么自适应性是必不可少的。


examples/step-3/doc/intro.dox

[1.x.819]

[1.x.820]

[2.x.2181]

[1.x.821]

这是第一个我们实际使用有限元来计算的例子。我们将解决一个简单的泊松方程，其边界值为零，但右手边非零。

[1.x.822]

我们将在正方形[2.x.2182]上求解这个方程，你已经在步骤1和步骤2中学习了如何生成网格。在这个程序中，我们也将只考虑[2.x.2183]这个特殊情况，并在下一个教程程序中再来讨论如何实现更一般的情况，即步骤4。

如果你学过有限元方法的基本知识，你会记得我们需要采取的步骤，用有限维度的近似方法来近似解[2.x.2184]。具体来说，我们首先需要推导出上述方程的弱形式，通过将方程乘以测试函数[2.x.2185][1.x.823]（我们将在下面回到从左而非从右相乘的原因）并在域[2.x.2186]上积分得到。

[1.x.824]

这可以通过部件进行整合。

[1.x.825]

测试函数[2.x.2187]必须满足同样的边界条件（用数学术语来说：它需要来自我们寻求解决方案的集合的切线空间），因此在边界上[2.x.2188]，因此我们正在寻找的弱形式为

[1.x.826]

其中我们使用了常用的符号 [2.x.2189] 。然后，问题要求从适当的空间（这里是空间[2.x.2192]）中找出一个函数[2.x.2190]，对于该函数，这一声明对于所有测试函数[2.x.2191]都是真的。

当然，在一般情况下，我们无法在计算机上找到这样的函数，而是寻求一个近似值[2.x.2193] ，其中[2.x.2194]是我们需要确定的未知膨胀系数（这个问题的 "自由度"），[2.x.2195]是我们将使用的有限元形状函数。为了定义这些形状函数，我们需要以下内容。

- 一个用来定义形状函数的网格。你已经看到如何在步骤1和步骤2中生成和操作描述网格的对象。

- 一个描述我们想在参考单元上使用的形状函数的有限元（在deal.II中总是单位间隔[2.x.2196]、单位正方形[2.x.2197]或单位立方体[2.x.2198]，取决于你在哪个空间维度工作）。在步骤2中，我们已经使用了FE_Q<2>类型的对象，它表示通常的拉格朗日元素，通过对支持点的插值来定义形状函数。最简单的是FE_Q<2>(1)，它使用1度的多项式。在2D中，这些通常被称为[1.x.827]，因为它们在参考单元的两个坐标中都是线性的。(在1d中，它们是[1.x.828]，在3d中是[1.x.829]；然而，在deal.II文档中，我们经常不做这种区分，而总是简单地称这些函数为 "线性"。)

- 一个DoFHandler对象，以有限元对象提供的参考单元描述为基础，枚举网格上的所有自由度。你也已经在步骤2中看到了如何做到这一点。

- 一个映射，告诉你如何从参考单元上的有限元类定义的形状函数中获得实数单元上的形状函数。默认情况下，除非你明确说明，否则deal.II将使用（双，三）线性映射，所以在大多数情况下，你不必担心这个步骤。

通过这些步骤，我们现在有一组函数[2.x.2199]，我们可以定义离散问题的弱形式：找到一个函数[2.x.2200]，即找到上面提到的扩展系数[2.x.2201]，以便

[1.x.830]

请注意，我们在此遵循惯例，即一切从零开始计算，这在C和C++中很常见。如果你插入表示法[2.x.2202]，这个方程可以重写为一个线性系统，然后观察到

[1.x.831]

有了这个，问题就成了。找到一个向量[2.x.2203]，以便

[1.x.832]

其中矩阵[2.x.2204]和右手边[2.x.2205]定义为

[1.x.833]






[1.x.834]

在我们继续描述如何计算这些数量之前，请注意，如果我们从[1.x.835]乘以一个测试函数而不是从左边乘以原方程，那么我们将得到一个形式为的线性系统

[1.x.836]

有一个行向量 [2.x.2206] 。通过转置这个系统，这当然等同于解决了

[1.x.837]

这里与上面的[2.x.2207]相同。但一般来说不是，为了避免任何形式的混淆，经验表明，只要养成从左边而不是从右边乘方程的习惯（正如数学文献中经常做的那样），就可以避免一类常见的错误，因为在比较理论和实现时，矩阵会自动正确，不需要转置。本教程的第一个例子见第9步，我们有一个非对称的双线性方程，对于这个方程，我们从右面还是从左面相乘是有区别的。




[1.x.838]

现在我们知道我们需要什么（即：持有矩阵和向量的对象，以及计算[2.x.2208]的方法），我们可以看看需要什么来实现这一点。

- [2.x.2209]的对象是SparseMatrix类型，而[2.x.2210]和[2.x.2211]的对象则是Vector类型。我们将在下面的程序中看到哪些类是用来解决线性系统的。

- 我们需要一种方法来形成积分。在有限元方法中，最常见的是使用正交法，也就是说，积分被每个单元上的一组点的加权和所取代。也就是说，我们首先将[2.x.2212]的积分分成所有单元的积分，[1.x.839]

  然后用正交法对每个单元的贡献进行近似。   [1.x.840]

  其中[2.x.2213]是[2.x.2214]单元上的第三个正交点[2.x.2215]，[2.x.2216]是[2.x.2217]的正交权。这样做需要有不同的部分，接下来我们将依次讨论它们。

- 首先，我们需要一种方法来描述正交点的位置 [2.x.2218] 和它们的权重 [2.x.2219] 。它们通常以与形状函数相同的方式从参考单元映射出来，即隐含地使用MappingQ1类，或者，如果你明确地说，通过从Mapping派生的其他类之一。参考单元上的位置和权重由派生自正交基类的对象来描述。通常，人们选择一个正交公式（即一组点和权重），使正交正好等于矩阵中的积分；这可以实现，因为积分中的所有因子都是多项式，由高斯正交公式完成，在QGauss类中实现。

- 然后我们需要一些东西来帮助我们在[2.x.2221]单元上评估[2.x.2220]。这就是FEValues类的作用：它需要一个有限元对象来描述参考单元上的[2.x.2222]，一个正交对象来描述正交点和权重，以及一个映射对象（或隐含地采用MappingQ1类），并在位于[2.x.2224]的正交点上提供形状函数的值和导数，以及积分所需的各种其他信息。

FEValues确实是装配过程中的核心类。你可以这样看待它。FiniteElement和派生类描述了形状[1.x.841]，即无限维度的对象：函数在每一点都有值。由于理论上的原因，我们需要这样做，因为我们想用函数的积分来进行分析。然而，对于计算机来说，这是一个非常困难的概念，因为它们一般只能处理有限的信息量，所以我们用正交点上的和来代替积分，我们通过使用定义在参考单元（正交对象）上的点映射（映射对象）到真实单元上的点来获得。实质上，我们将问题简化为我们只需要有限的信息，即形状函数值和导数、正交权重、法向量等，只需要在有限的点集合上。FEValues类就是将这三个部分结合在一起，并在一个特定的单元上提供这个有限的信息集 [2.x.2225] 。当我们组装下面的线性系统时，你会看到它的作用。

值得注意的是，如果你只是在应用程序中自己创建这三个对象，并自己处理这些信息，那么所有这些也都可以实现。然而，这样做既不简单（FEValues类提供的正是你实际需要的信息），也不快：FEValues类经过高度优化，只在每个单元中计算你需要的特定信息；如果有任何东西可以从上一个单元中重复使用，那么它就会这样做，而且该类中有很多代码可以确保在有利的地方进行缓存。

这个介绍的最后一块是要提到，在得到一个线性系统后，要用迭代求解器进行求解，然后进行后处理：我们用DataOut类创建一个输出文件，然后可以用一个常见的可视化程序进行可视化。

[2.x.2226] 前面对任何有限元实现的所有重要步骤的概述，在deal.II中也有对应的内容：该库可以自然地归纳为若干 "模块"，涵盖刚才概述的基本概念。你可以通过本页面顶部的标签访问这些模块。在[1.x.842]上也有对最基本的概念组的概述。




[1.x.843]

虽然这是你能用有限元方法解决的最简单的方程，但这个程序显示了大多数有限元程序的基本结构，也是几乎所有下面的程序基本上都会遵循的模板。具体来说，这个程序的主类看起来像这样。

[1.x.844]



这遵循了[1.x.845]的面向对象编程口号，也就是说，我们尽力将这个类的几乎所有内部细节隐藏在外部无法访问的私有成员中。

让我们从成员变量开始。这些遵循我们在上面的要点中所概述的构建模块，即我们需要一个三角形和一个DoFHandler对象，以及一个描述我们想要使用的各种形状函数的有限元对象。第二组对象与线性代数有关：系统矩阵和右手边以及解向量，还有一个描述矩阵稀疏模式的对象。这就是这个类所需要的全部内容（也是任何静止PDE的求解器所需要的基本内容），并且需要在整个程序中存活。与此相反，我们在装配时需要的FEValues对象只在整个装配过程中需要，因此我们在进行装配的函数中把它作为一个局部对象来创建，并在结束时再次销毁它。

其次，让我们来看看成员函数。这些，也已经构成了几乎所有下面的教程程序都会使用的共同结构。  [2.x.2227] [2.x.2228] [2.x.2229] : 这就是人们所说的[1.x.846]。顾名思义，它设置了存储三角图的对象。在以后的例子中，它还可以处理边界条件、几何形状等。    [2.x.2230] [2.x.2231] : 这是一个函数，其中设置了解决问题所需的所有其他数据结构。特别是，它将初始化DoFHandler对象并正确确定与线性代数有关的各种对象的大小。这个函数通常与上面的预处理函数分开，因为在一个与时间相关的程序中，每当网格被自适应细化时（我们将在步骤6中看到如何做），它可能至少每隔几个时间步就会被调用。另一方面，在上面的预处理函数中，设置网格本身只在程序开始时进行一次，因此，它被分离成自己的函数。    [2.x.2232] [2.x.2233] : 这就是计算矩阵和右手边的内容的地方，在上面的介绍中已经详细讨论过。由于对这个线性系统进行处理在概念上与计算其条目有很大不同，我们将其与以下函数分开。    [2.x.2234] [2.x.2235] : 这就是我们计算线性系统[2.x.2236]的解的函数。在当前的程序中，这是一个简单的任务，因为矩阵是如此简单，但只要问题不再那么微不足道，它就会成为程序规模的重要部分（例如，一旦你对库有了更多的了解，请参阅步骤20，步骤22，或步骤31）。    [2.x.2238] [2.x.2239] : 最后，当你计算出一个解决方案后，你可能想用它做一些事情。例如，你可能想以可视化的格式输出它，或者你可能想计算你感兴趣的量：例如，热交换器中的热通量、机翼的空气摩擦系数、最大桥梁载荷，或者仅仅是某一点上的数值解的值。因此，这个函数是对你的解进行后处理的地方。  [2.x.2240]所有这些都是由单一的公共函数（除构造函数外），即[2.x.2241]函数来支撑的。它是在创建这种类型的对象的地方被调用的，它是按正确顺序调用所有其他函数的函数。把这个操作封装到[2.x.2242]函数中，而不是从[2.x.2243]中调用所有其他函数，确保你可以改变这个类中的关注点分离的实现方式。例如，如果其中一个函数变得太大了，你可以把它分成两个，而你唯一需要关注的地方就是这个类中的变化，而不是其他地方。

如上所述，你会看到这种一般的结构&mdash；有时在函数名称的拼写上会有一些变化，但基本上是按照这种功能分离的顺序&mdash；在下面的许多教程程序中也是如此。




[1.x.847]

deal.II通过命名空间[2.x.2244]中的别名定义了一些积分%类型（在前一句中，"积分 "一词被用作与名词 "整数 "相对应的[1.x.848]。它不应该与表示曲线或曲面下的面积或体积的[1.x.849]"积分 "混淆起来。形容词 "积分 "在C++世界中被广泛使用，如 "积分类型"、"积分常数 "等。）特别是，在这个程序中，你会在几个地方看到[2.x.2245]：一个整数类型，用来表示自由度的[1.x.850]索引，即在定义在三角形之上的DoFHandler对象中特定自由度的索引（而不是特定单元中的特定自由度的索引）。对于当前的程序（以及几乎所有的教程程序），你将有几千个到几百万个全局未知数（而且，对于[2.x.2246]元素，你将有4个[1.x.851]的2D和8个3D）。因此，允许为全局DoF指数存储足够大的数字的数据类型是[2.x.2247]，因为它允许存储0到略高于40亿的数字（在大多数系统中，整数是32位的）。事实上，这就是[2.x.2248]的作用。

那么，为什么不马上使用[2.x.2249]呢？deal.II在7.3版本之前一直是这样做的。然而，deal.II支持非常大的计算（通过步骤40中讨论的框架），当分布在几千个处理器上时，可能有超过40亿个未知数。因此，有些情况下[2.x.2250]不够大，我们需要一个64位的无符号积分类型。为了实现这一点，我们引入了[2.x.2251]，它默认被定义为<code>unsigned int</code>，而如果有必要，可以通过在配置过程中传递一个特定的标志，将其定义为<code>unsigned long long int</code>（见ReadMe文件）。

这涵盖了技术方面。但是还有一个文档的目的：在图书馆和建立在它之上的代码中，如果你看到一个地方使用数据类型[2.x.2252]，你就会立即知道被引用的数量实际上是一个全局dof指数。如果我们只是使用[2.x.2253]（它也可能是一个局部索引，一个边界指示器，一个材料ID，等等），就不会有这样的意义了。立即知道一个变量指的是什么也有助于避免错误：如果你看到一个[2.x.2254]类型的对象被分配给[2.x.2255]类型的变量，这很明显一定有一个错误，尽管它们都是用无符号整数表示，因此编译器不会抱怨。

在更实际的情况下，这种类型的存在意味着在装配过程中，我们创建一个[2.x.2256]矩阵（在2d中，使用[2.x.2257]元素）来表示我们当前所在单元的贡献，然后我们需要将这个矩阵的元素添加到全局（系统）矩阵的相应元素中。为此，我们需要获得当前单元的局部自由度的全局指数，为此我们将始终使用下面这段代码。

[1.x.852]

其中[2.x.2258]被声明为

[1.x.853]

这个变量的名字可能有点名不副实--它代表 "在当前单元上局部定义的那些自由度的全局指数"--但持有这种信息的变量在整个库中普遍是这样命名的。

[2.x.2259] [2.x.2260] 并不是这个命名空间中定义的唯一类型。相反，有一整个系列，包括[2.x.2261][2.x.2262]和[2.x.2263]所有这些都是整数数据类型的别名，但正如上面所解释的，它们被用于整个库，以便（i）变量的意图变得更容易辨别，以及（ii）如果有必要，可以将实际类型改为一个更大的类型，而不必翻阅整个库，找出[2.x.2264]的特定使用是否对应于，例如，一个材料指标。


examples/step-3/doc/results.dox



[1.x.854]

程序的输出看起来如下。

[1.x.855]



前两行是我们写给 [2.x.2265] 的内容。最后两行是CG求解器在没有我们的干预下生成的。前两行说明了迭代开始时的残差，而最后一行告诉我们求解器需要47次迭代才能使残差的规范值达到5.3e-13，即低于我们在 "solve "函数中设置的阈值1e-12。我们将在下一个程序中展示如何抑制这种输出，这种输出有时对调试很有用，但往往会使屏幕显示变得混乱。

除了上面显示的输出，该程序还生成了文件[2.x.2266]，该文件为VTK格式，被当今许多可视化程序广泛使用--包括两个重量级的[1.x.856]和[1.x.857]，是当今最常使用的程序。

使用VisIt，生成一张像这样的解决方案的图片并不是很困难。  [2.x.2267] 它同时显示了解和网格，根据每一点的解的值提升到[2.x.2268] - [2.x.2269]平面之上。当然，这里的解并不特别令人兴奋，但这是拉普拉斯方程所代表的内容和我们为这个程序选择的右手边[2.x.2270]的结果。拉普拉斯方程描述了（在许多其他用途中）受外部（也是垂直）力作用的膜的垂直变形。在目前的例子中，膜的边界被夹在一个没有垂直变化的方形框架上；因此，一个恒定的力密度将直观地导致膜简单地向上隆起--就像上图所示。

VisIt和Paraview都允许玩各种可视化的解决方案。几个视频讲座展示了如何使用这些程序。  [2.x.2271]




[1.x.858]

[1.x.859]

如果你想用这个程序玩一玩，这里有几个建议。  [2.x.2272]

[2.x.2273] [2.x.2274] 改变几何图形和网格。在程序中，我们通过使用[2.x.2275]函数生成了一个方形域和网格。然而，[2.x.2276]也有大量的其他函数。试试L形域，环形域，或其他你在那里找到的域。    [2.x.2277]

   [2.x.2278] 改变边界条件。代码使用[2.x.2279]函数来生成零边界条件。然而，你可能想用[2.x.2280]而不是[2.x.2281]尝试非零常数边界值，以获得单位Dirichlet边界值。在函数命名空间的文档中描述了更多的奇异函数，你可以选择一个来描述你的特定边界值。    [2.x.2282]

   [2.x.2283] 修改边界条件的类型。目前，发生的情况是，我们在周围使用迪里希特边界值，因为默认情况是所有边界部分的边界指标为零，然后我们告诉[2.x.2284]函数，在所有指标为零的边界部分上将边界值插值为零。   [2.x.2285] 如果我们给边界的部分分配不同的指标，我们可以改变这种行为。例如，在调用[2.x.2286][1.x.860]后立即尝试这样做。



  这样做的目的是，首先要求三角剖分返回一个迭代器，指向第一个活动单元。当然，由于这是一个正方形的三角测量的粗略网格，此刻三角测量只有一个单元，而且它是活动的。接下来，我们要求单元格返回它的第一个面的迭代器，然后我们要求面将该面的边界指标重置为1。接下来的事情就是这样。当网格被细化时，子单元的面会继承其父母的边界指示器，也就是说，即使在最细的网格上，广场一侧的面的边界指示器为1。稍后，当我们要插值边界条件时，[2.x.2287]调用将只为那些边界指标为零的面产生边界值，而对那些具有不同边界指标的面则不予理会。这样做的目的是对前者施加Dirichlet边界条件，而对后者施加同质的Neumann条件（即解的法向导数为零，除非在变分等式的右侧添加额外的条款来处理潜在的非零Neumann条件）。如果你运行该程序，你会看到这一点。

  另一种改变边界指标的方法是根据面中心的笛卡尔坐标来标注边界。   例如，我们可以通过检查单元格中心的y坐标是否在-1和1的公差（这里是1e-12）范围内，将沿上下边界的所有单元格标记为边界指示器1。在调用[2.x.2288]后，像以前一样立即尝试这样做。   [1.x.861]

  虽然这段代码比以前长了一些，但它对复杂的几何形状很有用，因为它不需要脸部标签的知识。

   [2.x.2289]最后一点的一个小变化是像上面那样设置不同的边界值，但随后为边界指标一使用不同的边界值函数。在实践中，你要做的是为边界指标一增加对[2.x.2290]的第二次调用。   [1.x.862]

  如果你在这个函数的第一个调用之后立即进行这个调用，那么它将把边界指标为1的面的边界值内插到单位值，并将这些内插值与之前计算的边界指标为0的值合并。

   [2.x.2291] 观察收敛情况。我们将只讨论第7步中规范的计算误差，但很容易检查计算在这里已经收敛了。例如，我们可以在一个点上评估解的值，并比较不同%的全局细化的值（全局细化的步骤数在上面的[2.x.2292]中设定）。为了评估某个点的解决方案，例如在[2.x.2293]，我们可以在[2.x.2294]函数中加入以下代码。   [1.x.863]

  对于1到9个全局细化步骤，我们就会得到以下的点值序列。    [2.x.2295] 通过注意到每两个连续值之间的差异减少了大约4倍，我们可以猜测 "正确 "的值可能是[2.x.2296] 。事实上，如果我们假设这是正确的值，我们可以证明上面的序列确实显示了[2.x.2297]的收敛&mdash；理论上，收敛顺序应该是[2.x.2298]，但是领域和网格的对称性可能导致了观察到的更好的收敛顺序。

  这方面的一个小变种是用二次元重复测试。你需要做的就是在构造函数中把有限元的多项式程度设置为2 [2.x.2299] 。

   [2.x.2300] 平均值的收敛。一个不同的方法是计算解的平均数，以了解解是否真的收敛了（收敛到什么程度&mdash；我们无法判断它是否真的是正确的值！）。为此，在[2.x.2301]中添加以下代码：[1.x.864]

  该函数的文档解释了第二和第四个参数的含义，而第一和第三个参数应该是很明显的。再次做同样的研究，我们改变了全局细化步骤的数量，我们得到以下结果。    [2.x.2302] 同样，两个相邻值之间的差异下降了约四倍，表明收敛为 [2.x.2303] 。  [2.x.2304]




[1.x.865]

%HDF5是一种常用的格式，可以被许多脚本语言（如R或Python）读取。让deal.II产生一些%HDF5文件并不困难，然后可以在外部脚本中使用，对该程序产生的一些数据进行后处理。这里有一些关于可能的想法。




[1.x.866]

为了充分利用自动化，我们首先需要为全局细化步骤的数量引入一个私有变量[2.x.2305]，它将被用于输出文件名。在[2.x.2306]中用

[1.x.867]

deal.II库有两个不同的%HDF5绑定，一个在HDF5命名空间（用于对接通用数据文件），另一个在DataOut（专门用于为解决方案的可视化写文件）。尽管HDF5 deal.II绑定支持串行和MPI，但%HDF5 DataOut绑定只支持并行输出。由于这个原因，我们需要初始化一个只有一个处理器的MPI通信器。这可以通过添加以下代码来实现。

[1.x.868]

接下来我们改变[2.x.2307]的输出例程，如DataOutBase命名空间文档中所述。

[1.x.869]

然后，产生的文件可以被可视化，就像教程的原始版本产生的VTK文件一样；但是，由于%HDF5是一种更通用的文件格式，它也可以很容易地用脚本语言处理，用于其他目的。




[1.x.870]

在输出解决方案后，可以再次打开该文件以包括更多的数据集。  这使得我们可以将实验的所有必要信息保存在一个结果文件中，然后可以由一些后处理脚本来读取和处理。关于可能的输出选项，请看[2.x.2308]的进一步信息）。

为了实现这一点，我们首先将必要的头文件纳入我们的文件。

[1.x.871]

在我们的输出例程的末尾添加以下几行，将关于某一点的解的值，以及解的平均值的信息添加到我们的%HDF5文件中。

[1.x.872]






[1.x.873]

上述放入%HDF5文件的数据，然后可以从脚本语言中使用，进行进一步的后处理。在下文中，让我们展示一下，特别是如何用[1.x.874]这个在统计数据分析中广泛使用的语言来完成。(例如，类似的事情也可以在Python中完成。)如果你不熟悉R和ggplot2，你可以看看R的数据木工课程[1.x.875]。此外，由于大多数搜索引擎对 "R+主题 "这种形式的搜索很吃力，我们建议使用专门的服务[1.x.876]来代替。

R和其他语言最突出的区别是，赋值运算符（`a = 5`）通常被写成`a <- 5`。由于后者被认为是标准的，我们将在我们的例子中也使用它。要在R语言中打开`.h5`文件，你必须安装[1.x.877]包，它是Bioconductor软件包的一部分。

首先，我们将包括所有必要的包，并看看我们文件中的数据是如何结构化的。

[1.x.878]

这给出了以下输出

[1.x.879]

数据集可以通过 [2.x.2309] 访问。函数 [2.x.2310] 给我们提供了用于存储我们单元格的矩阵的尺寸。我们可以看到以下三个矩阵，以及我们添加的两个额外数据点。  [2.x.2311] [2.x.2312] [2.x.2313] ：一个4x1024的矩阵，存储每个单元的（C++）顶点指数 [2.x.2314] [2.x.2315] ：一个2x1089的矩阵，存储我们单元顶点的位置值（x，y） [2.x.2316] [2.x.2317] : 一个1x1089的矩阵，存储我们的解决方案在每个顶点的值 [2.x.2318] 现在我们可以使用这些数据来生成各种图表。用ggplot2作图通常分为两步。首先，数据需要被处理并添加到一个 [2.x.2319] 。之后，构建一个[2.x.2320]对象，并通过向其添加绘图元素来进行操作。

[2.x.2321]包含我们绘制网格所需的所有信息。下面的代码将所有的数据打包成一个数据框架，用于绘制我们的网格。

[1.x.880]



有了完成的数据框架，我们就有了绘制网格所需的一切。

[1.x.881]



这个文件的内容看起来如下（不是很令人兴奋，但你会明白的）。  [2.x.2322]

我们还可以将解决方案本身可视化，这看起来会更有趣。为了给我们的解决方案做一个二维伪色图，我们将使用 [2.x.2323] 。这个函数需要一个结构化的网格，即在x和y方向上是均匀的。幸运的是，我们在这一点上的数据是以正确的方式结构化的。下面的代码将我们的曲面的伪彩色表示法绘制成一个新的PDF。

[1.x.882]

现在的情况是这样的。  [2.x.2324]

为了绘制收敛曲线，我们需要从1开始用不同的[2.x.2325]值多次重新运行C++代码。由于每个文件只包含一个数据点，我们需要对它们进行循环，并将结果串联成一个矢量。

[1.x.883]

由于我们对数值本身不感兴趣，而是对与 "精确 "解决方案相比的误差感兴趣，我们将假设我们的最高细化水平是该解决方案，并从数据中省略它。

[1.x.884]

现在我们有所有的数据可以用来生成我们的图。在对数尺度上绘制误差往往是有用的，这在下面的代码中可以实现。

[1.x.885]

这就产生了下面的图，显示了均值和所选点的解值的误差如何很好地收敛到零。  [2.x.2326]


examples/step-30/doc/intro.dox

[1.x.886]

[1.x.887]




[1.x.888]

这个例子专门讨论[2.x.2327]各向异性细化[2.x.2328]，它扩展到局部细化的可能性。在大多数情况下，这是对step-12教程程序的修改，我们使用相同的DG方法处理线性输运方程。这个程序将涵盖以下主题。<ol> [2.x.2329] [2.x.2330] 各向异性细化 [2.x.2331] : 各向异性细化的含义是什么？    [2.x.2332] [2.x.2333] 实现 [2.x.2334] ：对代码进行必要的修改，以便与各向异性的细化网格一起工作。    [2.x.2335] [2.x.2336] 跳跃指标 [2.x.2337] : 在DG方法中，各向异性细化的一个简单指标。  [2.x.2338] 将不讨论离散化本身，也不讨论这里使用的非各向异性细化的实施技术。这一点请参考步骤12。

请注意，在编写这个教程程序的时候，各向异性的细化只在不连续的Galerkin有限元中完全实现。这一点以后可能会改变（或者已经改变）。




[2.x.2339] 虽然这个程序是对step-12的修改，但它是在deal.II历史上早期写的step-12的一个版本，当时MeshWorker框架还没有出现。因此，它与现在的step-12几乎没有任何相似之处，除了它以相同的离散化方式求解相同的方程。




[1.x.889]

在前面的教程程序中，所有的适应过程都是基于[2.x.2340]各向同性[2.x.2341]细化单元，它将所有的边切成两半，并将这些分割的边形成新的单元（当然，还要加上一些额外的边、面和顶点）。在deal.II中，[2.x.2342]各向异性细化[2.x.2343]指的是只分割部分边而不改变其他边的过程。例如，考虑一个简单的方形单元。

[1.x.890]

经过通常的细化，它将由四个孩子组成，看起来像这样。

[1.x.891]

新的各向异性细化可能有两种形式：一是我们可以将平行于水平X轴的边缘分割开来，形成这两个子单元。

[1.x.892]

或者我们可以拆分沿y轴运行的两条边，再次产生两个孩子，不过，看起来是这样的。

[1.x.893]

所有单元的细化情况都由枚举[2.x.2344]来描述，上述各向异性情况被称为[2.x.2345]和[2.x.2346]，原因很明显。各向同性的细化情况在二维中被称为[2.x.2347]，可以通过[2.x.2348]从细化案例类中请求。

在三维中，有第三个轴可以被分割，即z轴，因此我们在这里有一个额外的细化案例[2.x.2349]。各向同性的细化现在将沿x轴、y轴和z轴细化一个单元，因此被称为[2.x.2350] cut_xyz。另外还有[2.x.2351][2.x.2352]和[2.x.2353]的情况，它们沿两个轴精化单元，但不沿第三个轴精化。给出一个六面体单元，X轴向右，Y轴 "进入页面"，Z轴在顶部。

[1.x.894]

我们有各向同性的细化情况。

[1.x.895]

三种各向异性的情况，只细化一个轴。

[1.x.896]

和三个案例，它们完善了三个轴中的两个。

[1.x.897]

对于一维问题，各向异性的细化不会产生任何影响，因为一个单元只有一个坐标方向，所以除了各向同性外，不可能以任何其他方式分割。

[1.x.898]自适应局部细化是用来获得很好地适应有效解决手头问题的细网格。简而言之，产生较大误差的单元的尺寸被减小，以获得手头问题的更好的近似解。然而，很多问题都含有各向异性的特征。突出的例子是可压缩粘性流动中的冲击或边界层。一个有效的网格可以用较高长宽比的单元来逼近这些特征，而这些单元是根据上述特征定向的。只使用各向同性的细化，原始网格单元的长宽比会被保留下来，因为它们会被单元的子代所继承。因此，从各向同性的网格开始，边界层将被细化，以捕捉壁面法线方向上流场的快速变化，从而导致在法线和切线方向上都具有非常小的边缘长度的单元。通常情况下，在切线方向上的边长要大得多，因此可以使用更少的单元，而不会在近似精度上有明显的损失。各向异性的细化过程可以在每个细化步骤中把母细胞和子细胞的长宽比修改为两个系数。在多次细化的过程中，细单元的长宽比可以得到优化，从而节省了相当数量的单元和相应的自由度，从而节省了计算资源、内存以及CPU时间。

[1.x.899]

大多数时候，当我们进行有限元计算时，我们一次只考虑一个单元，例如计算单元对全局矩阵的贡献，或插值边界值。然而，有时我们不得不看一下单元在我们的算法中是如何关联的。单元之间的关系有两种形式：邻居关系和母子关系。对于各向同性的细化情况，deal.II对始终保持的单元格关系使用了某些约定（不变量）。例如，一个细化的单元总是正好有[2.x.2354]个子女。而且（除了1d情况），两个相邻的单元格最多可以相差一个细化级别：它们同样经常被细化，或者其中一个正好再被细化一次，在共同面上正好留下一个悬挂的节点。几乎所有的时候，这些不变量都只在库的内部实现中被关注。然而，在有些情况下，对它们的了解也与应用程序有关。

在当前情况下，值得注意的是，网格细化的种类会影响一些最基本的假设。因此，在应用程序中发现的一些常规代码将需要修改，以利用使用各向异性细化创建的网格的特征。对于那些对deal.II如何演变感兴趣的人来说，可能会感兴趣的是，这种不变量的松动需要一些不兼容的变化。例如，库中曾经有一个成员[2.x.2355]，规定一个单元一旦被细化后有多少个孩子。对于各向同性的细化，这个数字等于 [2.x.2356] ，如上所述。然而，对于各向异性的细化，这个数字并不存在，因为在二维中可以是2或4，在三维中可以是2、4或8，因此成员[2.x.2357]已经被删除。它现在已经被[2.x.2358]所取代，后者指定了一个单元格可以有的[1.x.900]个子嗣。一个细化的单元有多少个子代以前是作为静态信息提供的，但现在它取决于一个单元的实际细化状态，可以使用[2.x.2359]检索，这个调用对各向同性和各向异性的细化都同样有效。对于面和它们的子面也有非常类似的情况：相关的信息可以使用[2.x.2360]或[2.x.2361]进行查询，这取决于上下文。

另一个重要的方面，也是本教程中最重要的方面，是在组装单元格之间的面的跳跃项时对邻居关系的处理。在步骤12中查看assemble_system函数的文档，我们注意到，我们需要决定一个相邻的单元是否更粗、更细或者与我们当前的单元处于同一（细化）水平。这些决定对于各向异性的细化并不适用，因为细胞的[2.x.2362]级[2.x.2363]所提供的信息并不足以完全描述各向异性的细胞；例如，一个二维细胞的终端子女是否首先在[2.x.2364]方向切割的二维单元，其子女随后在[2.x.2365]方向切割时是在第2层，还是在第1层，因为如果该单元被各向同性地精炼一次，就会产生同一组最好的单元？

在各向异性的细化之后，一个更粗的邻居不一定正好比我们低一个级别，而是几乎可以有相对于当前级别的任何级别；事实上，它甚至可以在一个更高的级别上，尽管它更粗。因此，必须在不同的基础上做出决定，而决定的意图却保持不变。

在下文中，我们将讨论当我们想计算对矩阵（或右手边）的贡献时可能发生的情况，其形式为

[1.x.901]

或类似的；记住，我们使用FEFaceValues和FESubfaceValues类来整合这样的条款。我们还将展示如何编写适用于各向同性和各向异性细化的代码。

[2.x.2366]

   [2.x.2367] [2.x.2368] 更精细的邻居 [2.x.2369] ：如果我们在一个活动单元上，想要整合到一个面 [2.x.2370] 上，第一个可能性是这个面后面的邻居更精细，即有孩子只占据了共同面的一部分。在这种情况下，所考虑的面必须是一个精致的面，这可以通过询问 [2.x.2371] 来确定。如果这是真的，我们需要在所有的子面中循环，得到这个子面后面的邻居的孩子，这样我们就可以用邻居重新输入一个FEFaceValues对象，用我们的单元格和相应的子面重新输入一个FESubfaceValues对象。

  对于各向同性的细化，这种情况相当简单，因为我们知道，在deal.II中，各向同性细化的自适应网格的一个不变性是，邻居只能正好相差一个细化等级。然而，对于各向异性细化的网格来说，这并不完全正确，特别是在三维中；在那里，我们感兴趣的位于[2.x.2372]另一侧的活动单元实际上可能不是我们邻居的孩子，而可能是孙子甚至是更远的后代。幸运的是，这种复杂性被隐藏在库的内部。我们所要做的就是调用[2.x.2373]函数。尽管如此，在3D中，有两种情况需要特别考虑。    [2.x.2374] [2.x.2375] 如果邻居被各向异性地细化了一次以上，可能这里需要考虑的不是两个或四个而是三个子面。想象一下我们正在考虑的（三维）邻接单元的（二维）面的以下细化过程：首先该面沿x方向细化，后来只沿y方向细化左侧子面。

[1.x.902]

     这里子脸的数量是三个。需要注意的是，对于一个面，[2.x.2376]和[2.x.2377]之间的细微差别。第一个函数返回直系子女的数量，在上面的例子中是两个，而第二个函数返回活动后代的数量（即，包括子女、孙子和进一步的后代），在上面的例子中是正确的三个。使用[2.x.2378]对各向同性和各向异性以及二维和三维情况都有效，所以应该始终使用它。应该注意的是，如果最右边图像左侧的两个小子面后面的任何一个单元被进一步细化，那么当前的单元（即我们从这个共同面看的那一面）也要被细化：之所以这样，是因为否则就会违反每条边只有一个悬挂节点的不变量。

     [2.x.2379]可能是，邻居比较粗，但仍有比我们当前单元更细的孩子。如果两个同样粗糙的单元被细化，其中一个单元在所考虑的面有两个孩子，另一个有四个孩子，这种情况就会发生。下图中的单元格只是相互分离，以显示各个细化的情况。

[1.x.903]



  这里，左边的两个单元是在[2.x.2380]-方向上对母单元进行各向异性分割的结果，而右边的四个单元是在[2.x.2381] -和[2.x.2382]-方向上同时进行各向异性细化的结果。   标有#的左边单元有两个标有+的更细的邻居，但左边单元的实际邻居是完整的右边母单元，因为标有+的两个单元更细，它们的直接母体是一个大单元。    [2.x.2383]

  然而，幸运的是，[2.x.2384]可以自己处理这些情况，如果你在正确的子界面数量上循环，在上面的例子中，这是两个。[2.x.2385]函数也会照顾到这一点，因此，结果的状态总是正确的。然而，有一个小的注意事项。为了重新调用邻居的FEFaceValues对象，你需要知道指向当前单元格的面的索引。通常你会假设你直接得到的邻居和你一样粗或细，如果它有孩子的话，因此这个信息可以通过[2.x.2386]得到，然而如果邻居比较粗，你就必须使用[2.x.2387]中的第一个值来代替。为了方便你，有一个[2.x.2388]可以为你做正确的事情，并返回所需的结果。

   [2.x.2389] [2.x.2390] 邻居和我们的单元格一样细 [2.x.2391] ：在我们排除了所有存在更细的子代的情况后，我们只需要决定，邻居是否在这里更粗。为此，有一个[2.x.2392]函数，返回一个布尔值。为了得到相同粗度的邻居的相关情况，我们将使用 [2.x.2393] 。这个块里面的代码可以不动。然而，这里有一件事要提到。如果我们想使用一个规则，哪个单元应该在一个给定的面上组合某些条款，我们可以考虑步骤12中提出的规则。我们知道，我们必须舍弃将我们的单元格的水平与邻居的水平进行比较的部分，而用上面提出的对较粗的邻居的测试来取代。然而，我们也必须考虑到具有相同粗度的相邻单元具有相同指数（在不同水平上）的可能性。因此，我们必须包括单元格具有相同索引的情况，并给出一个额外的条件，即哪一个单元格应该集合条款，例如，我们可以选择较低层次的单元格。这个概念的细节可以在下面的实现中看到。

   [2.x.2394] [2.x.2395] 较粗的邻居 [2.x.2396] ：剩下的情况很明显：如果没有精炼的邻居，而且邻居不像当前单元那么细，那么它一定是较粗的。因此我们可以留下旧的条件短语，简单地使用 [2.x.2397] 。[2.x.2398]函数照顾到各向异性细化的所有复杂性，结合一般三维网格上可能的非标准面的方向、翻转和旋转。

[2.x.2399]

[1.x.904] 当一个三角形被细化时，没有被标记为细化的单元可能仍然被细化。这是由于额外的平滑算法，这些算法是必要的或明确要求的。特别是，在每条边上最多有一个悬空节点的限制，经常迫使邻近已经很细的单元的额外单元被细化，并被标记为进一步细化。

然而，deal.II也实现了一些算法，以确保得到的网格比最低限度的平滑，例如，确保没有孤立的精化单元被非精化单元所包围，因为这些岛屿上的额外自由度几乎都会受到悬挂节点的约束。关于网格平滑的更多信息，请参见三角形类及其[2.x.2400]成员的文档）。

大多数最初为各向同性情况开发的平滑算法已经被调整为以非常相似的方式用于各向异性和各向同性的细化工作。然而，有两种算法值得一提。<ol> [2.x.2401] [2.x.2402] : 在各向同性的环境中，该算法试图通过减少在共同顶点相遇的单元的细化水平差异来确保良好的近似质量。然而，对于各向异性的细化没有明确的对应概念，因此该算法不能与各向异性的细化结合使用。这个限制是由一个断言强制执行的，一旦在一个已经被各向异性细化的三角形上调用该算法，就会抛出一个错误。

   [2.x.2403] [2.x.2404] : 如果引入细化来限制悬空节点的数量，往往不需要额外的单元来提高近似质量。这对DG方法来说尤其如此。如果你设置了标志[2.x.2405]，平滑算法试图通过使用各向异性的细化来尽量减少可能不需要的额外单元的数量。如果你设置了这个平滑标志，你可能会得到各向异性的细化单元，即使你从未将一个细化标志设置为各向异性的细化。请注意，如果你的代码尊重各向异性网格的可能性，你只应该使用这个标志。结合一个合适的各向异性指标，这个标志可以帮助节省额外的单元，从而节省精力。  [2.x.2406]




[1.x.905]

利用各向异性细化的好处，需要一个指标来捕捉溶液的各向异性特征，并利用它们来进行细化过程。一般来说，各向异性的细化过程将包括几个步骤。<ol> [2.x.2407] 计算一个误差指标。    [2.x.2408] 使用误差指标来标记单元进行细化，例如使用固定数量或分数的单元。这些单元将被自动标记为各向同性的细化。    [2.x.2409] 只在被标记的单元上评估一个明显的各向异性指标。    [2.x.2410] 使用各向异性指标为合适的单元设置一个新的各向异性细化标志，否则保持标志不变。    [2.x.2411] 调用[2.x.2412]来执行要求的细化，使用要求的各向同性和各向异性标志。  [2.x.2413] 这种方法类似于我们在步骤27中用于hp-细化的方法，具有很大的灵活性优势。任何误差指标都可以在各向异性过程中使用，也就是说，如果你有相当多的后验目标导向的误差指标可用，你可以像使用简单的凯利误差估计器一样方便地使用它们。精细化过程的各向异性部分不受这种选择的影响。此外，只要省去第三和第四步，就可以得到与你在deal.II或你的应用程序中的任何各向异性变化之前相同的各向异性的细化结果。作为最后一个优点，只对标记为细化的单元进行工作会使各向异性指标的评估更快，如果指标涉及很多单元的话，这在有很多单元的细网格上会变得很明显。

在这里，我们使用一个非常简单的方法，它只适用于DG方法。一般的想法是非常简单的。DG方法允许离散解在一个单元的面上跳跃，而在每个单元内是平滑的。当然，在极限情况下，我们期望随着我们对网格的细化和对真实解的近似程度越来越高，跳跃会趋于零。因此，在一个给定的面的大跳跃表明该单元应该被细化（至少是）正交于该面，而小跳跃则不会导致这一结论。当然，有可能确切的解决方案并不平滑，它也有跳跃的特征。然而，在这种情况下，一个面的大跳跃表明，这个面或多或少地与跳跃平行，并且在它的附近，因此我们再次期望与所考虑的面正交的细化是有效的。

所提出的指标计算平均跳跃[2.x.2414]，即离散解[2.x.2416]在单元格上与坐标方向[2.x.2417]、[2.x.2418]、[2.x.2419]正交的两个面上绝对跳跃[2.x.2415]的平均值。

[1.x.906]

如果一个方向的平均跳动比其他方向的跳动的平均值大一定的系数[2.x.2421]，即如果[2.x.2422]，则该单元只沿该特定方向进行细化[2.x.2423]，否则该单元是各向同性细化的。

这样的标准很容易被推广到方程组：跳跃的绝对值将被矢量值跳跃的适当规范所取代。




[1.x.907]

我们解决步骤12中提出的线性传输方程。域被扩展到覆盖二维的[2.x.2424]，其中流场[2.x.2425]在域的右半部描述了一个围绕原点的逆时针四分之一圆，在域的左半部平行于x轴。流入边界再次位于[2.x.2426]处，并沿x轴的正向部分，边界条件选择与步骤12相同。


examples/step-30/doc/results.dox



[1.x.908]


该程序的输出包括控制台输出、包含网格的SVG文件以及以VTU格式给出的解决方案。

[1.x.909]



这个文本输出显示了各向异性细化的连续应用所带来的单元数量的减少。在最后一个细化步骤之后，节省的数量已经积累到几乎是各向同性情况下所需单元和自由度的四倍。装配所需的时间也以类似的因素进行扩展。

第一个有趣的部分当然是看这些网格是什么样子的。左边是各向同性细化的网格，右边是各向异性的网格（颜色表示单元的细化程度）。

[2.x.2427]


当然，另一个有趣的事情是看这两个网格序列上的解。在这里，它们是在细化周期1和4上，清楚地显示出解决方案确实是由[1.x.910]分片多项式组成。

[2.x.2428]

我们看到，各向异性细化网格上的解与各向同性细化网格上的解非常相似。因此，各向异性指标似乎可以有效地选择适当的单元进行各向异性的细化。

这些图片也解释了为什么网格被细化成这样。在整个域的左边部分，细化只沿着[2.x.2429]的单元轴进行。在域的右边部分，细化以各向同性的细化为主，因为解的各向异性特征--从1到0的跳跃--在平流方向转弯的地方不能很好地与网格对齐。然而，在四分之一圆的底部和最接近（观察者）的部分，这种跳跃又变得越来越与网格对齐，细化算法的反应是创建长宽比越来越大的各向异性单元。

看起来，各向异性特征和粗大网格的必要对齐会大大降低实际问题的性能。这在一般情况下是不会错的。例如，如果将各向异性细化应用于出现冲击的问题（如步骤69中求解的方程），那么在许多情况下，冲击并没有与网格对齐，各向异性细化的帮助不大，除非同时引入技术将网格与冲击对齐。另一方面，许多陡峭的解的特征是由于边界层造成的。在这些情况下，网格已经与各向异性特征对齐，因为它当然是与边界本身对齐的，各向异性的细化几乎总是可以提高这些情况下适应网格的计算效率。


examples/step-31/doc/intro.dox

[2.x.2430]

[1.x.911]


[1.x.912]

[1.x.913]

[1.x.914]

这个程序涉及一个有趣的物理问题：如果流体（即液体或气体）遇到由温度差异引起的浮力差异，它是如何表现的？很明显，流体中温度较高（因此较轻）的部分会上升，温度较低（密度较大）的部分会在重力作用下下沉。

在流体运动速度足够慢，以至于惯性效应可以被忽略的情况下，描述这种行为的方程是布西尼斯克方程，其内容如下。

[1.x.915]

这些方程属于矢量值问题的范畴（这个主题的顶层概述可以在[2.x.2431]模块中找到）。这里，[2.x.2432]是速度场，[2.x.2433]是压力，[2.x.2434]是流体的温度。  [2.x.2435]是速度的对称梯度。可以看出，速度和压力解决了描述不可压缩流体运动的斯托克斯方程，这个方程我们以前在步骤22中考虑过；我们将广泛借鉴在该程序中获得的经验，特别是关于高效线性斯托克斯求解器的经验。

流体运动的强制项是流体的浮力，表示为密度[2.x.2436]、热膨胀系数[2.x.2437]、温度[2.x.2438]和指向下方的重力矢量[2.x.2439]的积。在第32步的介绍中给出了为什么右手边看起来像它的推导）。前两个方程描述了流体如何通过移动对温差做出反应，第三个方程说明了流体运动如何影响温度场：它是一个平流扩散方程，即温度附着在流体颗粒上，并在流场中平流，还有一个额外的扩散（热传导）项。在许多应用中，扩散系数相当小，温度方程实际上是传输的，而不是扩散主导的，因此其特征是双曲而不是椭圆；我们在开发一个稳定的离散化时必须考虑到这一点。

在上述方程中，右侧的[2.x.2440]项表示热源，可能是一个空间和时间上的变化函数。  [2.x.2441]和[2.x.2442]表示粘度和扩散系数，在本教程程序中我们假定这两个系数为常数。当[2.x.2443]取决于温度时，更普遍的情况是物理应用中的一个重要因素。大多数材料随着温度的升高而变得更加流动（即[2.x.2444]随着[2.x.2445]的降低而降低）；有时，如在温度接近熔点的岩石矿物的情况下，[2.x.2446]可能在典型的温度范围内发生数量级的变化。

我们注意到，上述斯托克斯方程可以通过引入[1.x.916] [2.x.2447]来实现非维度化，使用的是典型长度尺度[2.x.2448]、典型温差[2.x.2449]、密度[2.x.2450]、热扩散率[2.x.2451]和热导率[2.x.2452] 。  [2.x.2453]是一个无尺寸的数字，它描述了由温差引起的浮力变化导致的热传输和热扩散导致的热传输的比率。一个小的瑞利数意味着浮力相对于粘度来说并不强，流体运动[2.x.2454]足够慢，因此热扩散[2.x.2455]是主要的热传输项。另一方面，高瑞利数的流体将显示出主导热传导的强烈对流。

对于我们感兴趣的计算热对流的大多数流体，瑞利数是非常大的，通常是[2.x.2456]或更大。从方程的结构中，我们看到这将导致大的压力差和大的速度。因此，[2.x.2457]的对流-扩散方程中的对流项也将非常大，这个方程的精确解将要求我们选择小的时间步长。因此，具有大雷利数的问题很难用数值来解决，其原因与[1.x.917]大时难以解决[1.x.918]的问题相似。

请注意，大的瑞利数不一定涉及大的绝对速度。例如，地幔中的瑞利数大于[2.x.2458] 。然而，速度却很小：该材料实际上是固体岩石，但它是如此之热，而且处于压力之下，它可以非常缓慢地流动，每年最多只有几厘米的速度。然而，这可以导致在数百万年的时间尺度上的混合，这个时间尺度比相同数量的热量通过热传导分布要短得多，而且这个时间尺度与影响地球内部和表面结构的演变有关。

[2.x.2459]如果你对使用该程序作为你自己实验的基础感兴趣，你也会想看看它在step-32中的延续。此外，step-32后来被发展成更大的开放源代码ASPECT（见https://aspect.geodynamics.org/），它可以解决现实的问题，在试图将step-31变形为可以解决任何你想解决的问题之前，你可能想研究一下它。




[1.x.919]

由于Boussinesq方程是在流体运动的惯性不起作用的假设下推导出来的，所以流场在每个时间段完全由该时间段的浮力差决定，而不是由以前的流场决定。这反映在上面的前两个方程是不包含时间导数的稳态斯托克斯方程的事实。因此，我们不需要速度或压力的初始条件。另一方面，温度场确实满足一个有时间导数的方程，所以我们需要初始条件[2.x.2460] 。

至于边界条件：如果[2.x.2461]，那么温度满足一个二阶微分方程，需要边界周围所有时间的边界数据。这些数据可以是规定的边界温度[2.x.2462]（Dirichlet边界条件），也可以是规定的热通量[2.x.2463]；在这个程序中，我们将使用一个绝缘的边界条件，即规定没有热通量。  [2.x.2464] .

同样地，速度场要求我们提出边界条件。这些条件可以是[2.x.2465]上的无滑移无通量条件[2.x.2466]，如果流体粘在边界上，或者无正常通量条件[2.x.2467]，如果流体可以沿边界流动但不能穿过边界，或者任何数量的其他物理上合理的条件。在这个程序中，我们将使用无正常通量条件。




[1.x.920]

与步骤21中解决的方程一样，我们这里有一个微分代数方程（DAE）系统：就时间变量而言，只有温度方程是微分方程，而[2.x.2468]和[2.x.2469]的斯托克斯系统没有时间导数，因此属于必须在每个时间瞬间保持的那种代数约束。与第21步的主要区别是，那里的代数约束是一个混合拉普拉斯系统，其形式为

[1.x.921]

现在我们有一个斯托克斯系统

[1.x.922]

其中[2.x.2470]是一个类似于拉普拉斯[2.x.2471]的算子，适用于一个矢量场。

鉴于与我们在步骤21中所做的相似，我们选择类似的方法可能并不令人惊讶，尽管我们将不得不对微分算子左上角的算子变化进行调整。




[1.x.923]

作为DAE的问题结构允许我们使用与我们在步骤21中已经使用的相同的策略，即我们使用一个时间滞后方案：我们首先解决温度方程（使用外推的速度场），然后将新的温度解插入速度方程的右侧。不过，我们在代码中实现这一方案的方式是从一个稍微不同的角度来看问题。我们首先使用前一个时间步长的温度场来求解速度和压力的斯托克斯方程，这意味着我们得到前一个时间步长的速度。换句话说，我们首先求解时间步长[2.x.2472]的斯托克斯系统，即

[1.x.924]

然后用外推速度场的温度方程到时间 [2.x.2473] 。

与第21步相比，我们在这里将使用一个高阶时间步进方案，即用（单边）差分商[2.x.2475]取代时间导数[2.x.2474]，[2.x.2476]为时间步长。这就得到了离散化的时间温度方程

[1.x.926]

请注意温度方程是如何被半显式解决的：扩散被隐式处理，而平流被显式处理，使用温度和速度的外推法（或前推法），包括刚刚计算的速度 [2.x.2477] 。对当前时间水平的正向投影 [2.x.2478] 是由泰勒扩展得出的， [2.x.2479] 。我们需要这个投影来保持BDF-2方案的精度。换句话说，我们在显式右手边使用的温度场是当前温度场的二阶近似值&mdash；不完全是显式时间步进方案，但从特征上看也不会太远。

温度外推的引入将时间步长限制在[1.x.927]，就像在[2.x.2480]"步骤-21 "中一样。(如果我们隐含地处理平流项，我们就不会有这个稳定条件，因为BDF-2方案是A级稳定的，代价是我们需要在每个时间步长建立一个新的温度矩阵。)我们将在[1.x.928]中讨论时间步长的确切选择，但目前重要的是，这个CFL条件意味着时间步长[2.x.2481]可能在不同的时间步长中发生变化，我们必须稍微修改上述公式。如果[2.x.2482]是当前和前一个时间步长的时间步长，那么我们使用近似值

[1.x.929]

和

[1.x.930]

并将上述方程概括如下。

[1.x.931]



其中[2.x.2483]表示速度[2.x.2484]和温度[2.x.2485]外推到时间级别[2.x.2486]，使用前两个时间步骤的数值。这不是一个容易读懂的方程，但会为我们提供所需的高阶精度。作为一致性检查，很容易验证，如果[2.x.2487] ，它可以还原成与上面相同的方程。

最后我们注意到，选择高阶时间步进方案当然会迫使我们在内存中保留更多的时间步进；特别是，我们在这里需要保留[2.x.2488]，这是一个我们以前可以抛弃的向量。这似乎是一个麻烦，我们以前可以通过使用一阶时间步进方案来避免，但是正如我们在下面讨论稳定化问题时看到的那样，我们无论如何都需要这个向量，因此在时间离散化中保留它基本上是免费的，并给我们提供了使用高阶方案的机会。




[1.x.932]

像解决混合拉普拉斯方程一样，解决斯托克斯方程需要我们为速度和压力变量选择特定的有限元对。因为这在步骤22中已经讨论过了，所以我们只简单介绍一下这个话题。这里，我们使用稳定对[2.x.2489] 。这些都是连续元素，所以我们可以通过部分积分和用离散函数替代连续函数来形成斯托克斯方程的弱形式，没有问题。

[1.x.933]

为所有测试函数 [2.x.2490] 。第一个方程的第一项被认为是张量之间的内积，即[2.x.2491] 。因为这个乘积中的第二个张量是对称的，所以[2.x.2492]的反对称分量不起作用，如果我们用[2.x.2493]的对称梯度代替，会导致完全一样的形式。因此，我们考虑并实施的表述是

[1.x.934]



这与我们在第22步中已经讨论过的完全一样，这里就不多说了。




[1.x.935]

更有趣的问题是如何处理温度平流-扩散方程。默认情况下，并不是所有这个方程的离散化都是同样稳定的，除非我们要么做一些像上卷、稳定化，或者所有这些的事情。实现这一点的方法之一是使用不连续元素（即我们在步骤12中离散传输方程或在步骤20和步骤21中离散压力时使用的FE_DGQ类），并在单元间的界面上定义一个考虑到上卷的流量。如果我们有一个纯粹的平流问题，这可能是最简单的方法。然而，这里我们也有一些扩散，用不连续元素对拉普拉斯算子进行离散化是很麻烦的，因为有大量的附加项需要在单元间的每个面上进行积分。不连续元素还有一个缺点，即使用数值通量会带来额外的数值扩散，这种扩散无处不在，而我们真的希望将数值扩散的影响降到最低，只在需要稳定方案的地方应用它。

因此，一个更好的选择是在模型中加入一些非线性粘度。从本质上讲，这样做的目的是将温度方程的形式从

[1.x.936]

到类似于

[1.x.937]

其中[2.x.2494]是一个额外的粘度（扩散）项，只在冲击和其他不连续点附近发挥作用。  [2.x.2495]的选择方式是，如果[2.x.2496]满足原始方程，则额外的粘性为零。

为了实现这一点，文献中包含了许多方法。我们在这里将遵循Guermond和Popov开发的一种方法，它建立在一个适当定义的残差和一个额外粘度的极限程序之上。为此，让我们定义一个残差[2.x.2497]如下。

[1.x.938]

其中，我们以后将从[2.x.2499]范围内选择稳定指数[2.x.2498]。请注意，如果[2.x.2501]满足温度方程，[2.x.2500]将为零，因为此时括号内的项将为零。将条款相乘，我们得到以下完全等同的形式。

[1.x.939]



有了这个残差，我们现在可以把人工黏度定义为一个片状常数函数，在直径为[2.x.2502]的每个单元上分别定义如下。

[1.x.940]



这里，[2.x.2504]是一个稳定常数（通过维度分析发现它是无单位的，因此与比例无关；我们将在[1.x.941]中讨论其选择），[2.x.2505]是一个归一化常数，其单位必须是[2.x.2506] 。我们将选择它作为[2.x.2507] ，其中[2.x.2508]是目前温度值的范围（记住，浮力是由温度变化驱动的，而不是绝对温度），[2.x.2509]是一个无尺寸常数。为了理解这个方法为什么有效，请考虑这个问题。如果在一个特定的单元[2.x.2510]上，温度场是平滑的，那么我们希望那里的残差很小（事实上是在[2.x.2511]的数量级上），注入人工扩散的稳定项在那里的大小将是[2.x.2512]&mdash；也就是说，相当小，就像我们希望它在没有必要进行额外扩散时那样。另一方面，如果我们处于或接近温度场的不连续性，那么残差将很大；[2.x.2513]定义中的最小操作将确保稳定项的大小为[2.x.2514]&mdash；这是确保方案稳定的最佳人工粘性量。

这种方案是否真的有效是个好问题。Guermond和Popov的计算表明，这种形式的稳定方案实际上比其他大多数稳定方案（例如流线扩散，仅举最简单的一种）表现得更好。此外，对于[2.x.2515]，他们甚至可以证明，对于线性传输方程，它比流线扩散产生更好的收敛阶数。对于[2.x.2516]，目前还没有理论结果，但数值测试表明，其结果比[2.x.2517]好得多。

一个更实际的问题是如何将这种人工扩散引入我们想要解决的方程。请注意，数值粘度[2.x.2518]是随温度变化的，所以我们要解决的方程在[2.x.2519]中是非线性的&mdash；这不是人们对稳定方程的简单方法的期望，如果我们意识到[2.x.2520]在[2.x.2521]中是不可分的，那就更不可能了。然而，我们没有理由绝望：我们仍然要在时间上进行离散，我们可以明确地处理这个术语。

在稳定参数的定义中，我们用 [2.x.2522] 对时间导数进行近似。这种近似只利用了可用的时间数据，这就是我们需要存储前两个时间步骤的数据的原因（这使我们能够使用BDF-2方案而不需要额外的存储成本）。我们现在可以简单地在[2.x.2523]处评估其余的项，但这样一来，离散残差无非是一个向后的欧拉近似，它只有一阶精度。因此，在平滑解的情况下，尽管外部BDF-2方案和空间FE离散化的时间精度为二阶，但残差仍为[2.x.2524]阶。这当然不是我们想要的（事实上，我们希望在解决方案表现良好的区域有较小的残差），所以需要更谨慎一些。这个问题的关键是观察我们构造的第一导数实际上是以[2.x.2525]为中心的。如果我们通过使用近似值[2.x.2527]来评估[2.x.2526]处的所有空间项，我们就可以得到所需的二阶精确残差计算，这意味着我们将非线性粘度计算为这个中间温度的函数，[2.x.2528] 。请注意，这种对残差的评估无非是一个Crank-Nicholson方案，所以我们可以肯定，现在一切正常了。人们可能会想，现在的数值粘度没有在时间[2.x.2529]进行评估（相对于方程的其余部分），这是否是一个问题。然而，这种偏移是不严谨的。对于平滑解，[2.x.2530]将连续变化，所以时间偏移的误差比非线性粘度本身要小[2.x.2531]倍，也就是说，它是被遗漏的一个小的高阶贡献。这很好，因为该项本身已经达到了光滑区域的离散化误差水平。

使用上面介绍的BDF-2方案，这就得到了更简单的大小为[2.x.2532]的均匀时间步长的情况。

[1.x.942]

在这个方程的左侧仍然是来自时间导数的项和我们隐含处理的原始（物理）扩散（这实际上是一个很好的项：从左侧产生的矩阵是质量矩阵和拉普拉斯矩阵的倍数&mdash；两者都是正定的，如果时间步长[2.x.2533]很小，和很容易反转）。在右侧，第一行的条款是时间导数的结果；第二行是时间[2.x.2534]的人工扩散；第三行包含平流条款，第四行是来源。请注意，人工扩散对当前时间的外推温度的作用，与我们在时间步进一节中讨论的平流作用相同。

我们在现实中必须使用的非均匀时间步长的形式要复杂一些（这就是为什么我们先展示了上面的简单形式），其内容为：。

[1.x.943]



在解决了所有这些问题之后，弱形式自然而然地从最后一个方程中显示的强形式中产生，我们立即得出了离散化方程的弱形式。

[1.x.944]

为所有离散测试函数 [2.x.2535] 。在这里，扩散项已经被部分整合，我们已经使用，我们将施加没有热通量， [2.x.2536] 。

这就产生了一个矩阵方程，其形式为

[1.x.945]

考虑到左边的矩阵结构（两个正定矩阵之和），使用共轭梯度法很容易解决这个问题。




[1.x.946]

如上所述，我们解决速度/压力和温度的联合系统的方法是使用算子分割，我们首先用旧的温度场解决速度和压力的斯托克斯系统，然后用刚刚计算的速度场解决新的温度场。关于算子分割方法的更广泛的讨论可以在步骤58中找到）。




[1.x.947]

解决来自斯托克斯系统的线性方程已经在步骤22中进行了详细的讨论。特别是在该程序的结果部分，我们讨论了一些替代的线性求解器策略，结果发现这些策略比原来的方法更有效。在那里确定的最佳替代方案是使用一个由涉及舒尔补码的块状矩阵预处理的GMRES求解器。具体来说，斯托克斯算子导致了一个块状结构的矩阵

[1.x.948]

正如那里所讨论的，一个好的预处理程序是

[1.x.949]

其中[2.x.2537]是斯托克斯算子的舒尔补[2.x.2538] 。当然，这个预处理程序是没有用的，因为我们不能形成矩阵的各种倒数，但我们可以用下面的方法作为预处理程序。

[1.x.950]

其中[2.x.2539]是反矩阵的近似值。特别是，事实证明[2.x.2540]在光谱上等同于质量矩阵，因此，用适用于压力空间上的质量矩阵的CG求解器取代[2.x.2541]是一个不错的选择。与步骤22稍有不同的是，我们在这里的动量方程中有一个系数[2.x.2542]，通过与那里相同的推导，我们应该得出结论，我们应该使用的是具有条目[2.x.2543]的加权质量矩阵。

想出一个好的替代方案[2.x.2544]更为复杂，它对应于矢量值速度场的离散化对称拉普拉斯，即[2.x.2545] 。在步骤22中，我们用[2.x.2546]的稀疏LU分解（使用SparseDirectUMFPACK类）来代替[2.x.2547]&mdash; 完美的前置条件&mdash; 在2D中，但对于3D来说，内存和计算时间通常不足以实际计算这个分解；因此，我们在3D中只使用不完全LU分解（ILU，使用稀疏ILU类）。

对于这个项目，我们想走得更远一点。为此，请注意，矢量场上的对称化双线性形式[2.x.2548]与非对称化版本[2.x.2549]相差不大（请注意，在这个形式中因子2已经消失了）。然而，后者的优点是测试函数的[2.x.2550]矢量分量不是耦合的（好吧，几乎是，见下文），也就是说，得到的矩阵是块对角线的：每个矢量分量有一个块，这些块中的每个都等于这个矢量分量的拉普拉斯矩阵。因此，假设我们以这样的方式排列自由度，即首先对速度的所有[2.x.2551]分量进行编号，然后是[2.x.2552]分量，然后是[2.x.2553]分量，那么与这种稍有不同的双线性形式相关的矩阵[2.x.2554]具有如下形式

[1.x.951]

其中[2.x.2555]是一个拉普拉斯矩阵，其大小等于与矢量值速度的每个分量相关的形状函数数量。有了这个矩阵，我们就可以对速度矩阵[2.x.2556]的预处理进行如下定义。

[1.x.952]

其中[2.x.2557]是拉普拉斯矩阵的预处理程序&mdash;我们非常清楚如何建立良好的预处理程序!

在现实中，故事并不那么简单。为了使矩阵[2.x.2558]确定，我们需要通过应用边界条件使各个块[2.x.2559]确定。我们可以尝试通过在边界周围应用狄氏边界条件来做到这一点，然后，如果后者的矩阵是由斯托克斯问题产生的，我们在领域周围的速度分量上也有狄氏边界条件，即如果我们执行[2.x.2562]，那么如此定义的前置条件[2.x.2560]就变成了[2.x.2561]的良好前置条件。

不幸的是，这个 "如果 "是 "如果且仅是如果"：在下面的程序中，我们将希望使用[2.x.2563]形式的无流量边界条件（即允许与边界平行的流量%，但没有通过边界的流量）。在这种情况下，事实证明，上面定义的块状对角线矩阵不是一个好的预处理程序，因为它忽略了边界上的成分耦合。因此，更好的方法是如果我们将矩阵[2.x.2564]建立为矢量拉普拉斯矩阵[2.x.2565]，然后应用与我们应用于[2.x.2566]相同的边界条件。如果这是一个围绕域的迪里希特边界条件，[2.x.2567]将像上面那样解耦为三个对角线块，如果边界条件是[2.x.2568]的形式，那么这将在边界引入自由度的耦合，但只在那里。事实上，这被证明是一个比上面介绍的更好的预处理程序，而且几乎具有我们希望得到的所有好处。


总结这整个故事，我们可以看到。  [2.x.2569] [2.x.2570] 与我们在步骤22中从对称梯度产生的原始矩阵[2.x.2571]建立一个预处理程序相比，我们不得不期待基于拉普拉斯双线性形式的预处理程序表现得更差，因为它没有考虑到向量分量之间的耦合。

   [2.x.2572]另一方面，拉普拉斯矩阵的预处理程序通常比矢量问题的预处理程序更成熟，性能更好。例如，在写这篇文章的时候，代数%多重网格（AMG）算法对于标量问题已经非常成熟，但对于矢量问题却不是如此。

   [2.x.2573]在建立这个预处理程序时，我们将不得不建立矩阵[2.x.2574]及其预处理程序。虽然这意味着我们必须存储一个之前不需要的额外矩阵，但与存储耦合矩阵[2.x.2576]的预处理程序相比，预处理程序[2.x.2575]可能需要的内存要少得多。这是因为矩阵[2.x.2577]每行只有三分之一的条目对应于内部自由度，并且只在边界条件引入耦合的部分包含向量分量之间的耦合。因此，存储该矩阵是比较便宜的，我们可以预期，计算和存储预处理程序[2.x.2578]也将比为完全耦合的矩阵做这些事情便宜得多。  [2.x.2579]




[1.x.953]

这是最容易的部分。温度方程的矩阵具有[2.x.2580]的形式，其中[2.x.2581]是温度空间上的质量和刚度矩阵，[2.x.2582]是与时间步进方案以及当前和前一个时间步进有关的常数。这是一个对称正定和一个对称正半定矩阵之和，其结果也是对称正定的。此外，[2.x.2583]是一个与时间步长成正比的数字，因此只要网格很细就会变小，从而阻尼当时条件不好的刚度矩阵的影响。

因此，用共轭梯度算法反转这个矩阵，使用一个简单的预处理程序，与反转斯托克斯矩阵相比是微不足道和非常便宜的。




[1.x.954]

[1.x.955]

关于下面的程序，值得事先解释的一件事是使用了两个不同的DoFHandler对象。如果看一下上述方程的结构和它们的求解方案，就会发现几乎没有什么共同点能使斯托克斯部分和温度部分保持一致。在我们以前讨论[2.x.2584]"矢量值问题 "的所有教程程序中，我们总是只使用一个具有几个矢量分量的单一有限元，以及一个DoFHandler对象。有时，我们将得到的矩阵分解成若干块，以方便特定的求解器方案；例如，在目前程序所依据的斯托克斯方程的第22步程序中就是如此。

当然，我们在这里也可以这样做。我们将得到的线性系统看起来像这样。

[1.x.956]

这方面的问题是。我们从未同时使用整个矩阵。事实上，它从未真正同时存在。如上所述，[2.x.2585]和[2.x.2586]依赖于已经计算出的解[2.x.2587]，在第一种情况下，通过时间步长（这依赖于[2.x.2588]，因为它必须满足CFL条件）。所以我们只有在已经解决了左上角[2.x.2589]块斯托克斯系统后才能组装它，一旦我们转向温度方程，我们就不再需要斯托克斯部分了；我们为一个在任何时候都不会以整体存在于内存中的矩阵建立一个对象，这导致我们在步骤21中跳了一些圈套，所以我们不要重复这类错误。此外，我们实际上并没有建立矩阵[2.x.2590]：因为当我们进入温度方程时，我们已经知道了[2.x.2591]，而且因为我们必须在这个时候组装右手边的[2.x.2592]，我们只是将项[2.x.2593]移到右手边，并将其与所有其他项组装在一起。这意味着矩阵中不存在温度变量和斯托克斯变量耦合的部分，因此所有自由度的全局列举不再重要：如果我们有所有斯托克斯自由度的列举，以及所有温度自由度的独立列举就足够了。

从本质上讲，将[1.x.957]放入一个块状矩阵中并没有什么用处（当然，对于[2.x.2594]斯托克斯部分，也有同样好的理由这样做），或者，就这一点而言，将所有东西放入同一个DoFHandler对象。

但这样做是否有[1.x.958]的好处？这些问题是存在的，尽管它们一开始可能并不明显。主要问题是，如果我们需要创建一个包含速度、压力和温度形状函数的全局有限元，并使用它来初始化DoFHandler。但是我们也用这个有限元对象来初始化我们使用的所有FEValues或FEFaceValues对象。这可能看起来不是什么大问题，但是想象一下，例如，当我们评估我们需要计算人工粘度[2.x.2595]的残差[2.x.2596]时会发生什么。  为此，我们需要温度的拉普拉斯，我们使用形状函数的二阶导数（Hessians）张量来计算（为此我们必须给FEValues对象加上[2.x.2597]标志）。现在，如果我们有一个包含速度、压力和温度的形状函数的有限性，这意味着我们必须计算[1.x.959]形状函数的Hessians，包括速度的许多高阶形状函数。这是很多我们不需要的计算，事实上，如果一个人要这样做（就像我们在程序的早期版本中那样），组装右手边需要大约四分之一的整体计算时间。

所以我们要做的是使用两个不同的有限元对象，一个用于斯托克斯成分，一个用于温度。这样就有两个不同的DoFHandlers，两个稀疏模式和两个用于斯托克斯和温度部分的矩阵，等等。每当我们要组装包含温度和斯托克斯形状函数的东西时（特别是斯托克斯和温度方程的右侧），我们就使用两个FEValues对象，用两个单元格迭代器进行初始化，通过与同一三角化对象相关的两个DoFHandler对象进行平行行走。对于这两个FEValues对象，我们当然使用相同的正交对象，这样我们就可以在同一组正交点上进行迭代，但是每个FEValues对象将只根据它实际需要计算的内容来获得更新标志。特别是，当我们像上面那样计算残差时，我们只要求得到斯托克斯形状函数的值，但也要求得到温度形状函数的Hessians &mdash；确实便宜得多，而且事实证明：组装温度方程的右手边现在是程序中几乎无法测量的一个组成部分。

有了这些变化，对程序进行计时，可以得出只有以下操作与整个运行时间有关。  [2.x.2598] [2.x.2599] 解决斯托克斯系统：72%的运行时间。    [2.x.2600] 组装斯托克斯预处理程序，并使用Trilinos ML包计算代数多网格层次结构：占运行时间的11%。    [2.x.2601] 函数 [2.x.2602] : 占整体运行时间的7%。    [2.x.2603] 组装斯托克斯和温度右侧向量以及组装矩阵。7%.  [2.x.2604] 实质上这意味着除了代数多重网格之外，所有的瓶颈都已经被移除。




[1.x.960]

与我们在第17步和第18步中使用PETSc来支持我们的线性代数需求一样，我们在这个程序中使用了[1.x.961]库的接口（安装说明见deal.II README文件）。Trilinos是一个非常大的集合，包括与线性和非线性代数有关的所有东西，以及围绕这些东西的各种工具（看起来它在未来也会向许多其他方向发展）。

使用Trilinos的主要原因，类似于我们探索的PETSc，是它是一个非常强大的库，比deal.II自己的线性代数库提供了很多工具。这尤其包括在集群上以%parallel方式工作的能力，使用MPI，以及更多种类的前置条件器。在后一类中，最有趣的能力之一是Trilinos ML包的存在，它实现了代数多栅（AMG）方法。我们将使用这个预处理程序对动量方程的二阶算子部分进行预处理。在步骤32中，我们将使用与这里讨论的相同的问题，探索以%并行方式解决问题的能力。

我们在第17步和第18步中使用的PETSc无疑是一个强大的库，它提供了大量处理矩阵、向量、迭代求解器和预处理器的函数，还有很多其他的东西，其中大部分在%parallel中运行得相当好。然而，它比Trilinos早了几年，是用C语言编写的，而且一般来说不像其他一些库那样容易使用。因此，deal.II也获得了与Trilinos的接口，Trilinos与PETSc有很多相同的功能。然而，它是一个年轻了好几年的项目，是用C++编写的，其作者一般都非常重视软件设计。




[1.x.962]

我们在这里要解决的情况如下：我们用[2.x.2605]来解决上述的Boussinesq方程，即一个相对缓慢运动的流体，它几乎没有热扩散传导性，主要通过对流来传输热量。在边界上，我们将要求速度（[2.x.2606]）和温度（[2.x.2607]）没有正态流量。这是在步骤22的介绍中讨论的情况之一，它固定了速度的一个分量，同时允许流动与边界%平行。还有[2.x.2608]分量需要固定，即法向应力的切向分量；对于这些分量，我们选择同质条件，这意味着我们不需要任何特殊条件。初始条件只对温度场是必要的，我们选择它为恒定的零。

然后，问题的演变完全由温度方程的右手边[2.x.2609]驱动，即由热源和汇驱动。在这里，我们选择了一个在圣诞讲座前发明的设置：美国的教室里当然禁止使用真实的蜡烛，但允许使用虚拟的蜡烛。因此，我们选择了三个球形的热源，不等距地靠近领域的底部，模仿三个蜡烛的样子。位于这些热源处的流体，最初处于静止状态，然后被加热，随着温度的升高，获得浮力，上升；更多的流体被拖上来，穿过热源，导致三个热羽上升，直到它们被外面下沉的流体循环所捕获，取代了因加热而上升的空气。


examples/step-31/doc/results.dox



[1.x.963]

[1.x.964]

当你在2D中运行该程序时，输出将看起来像这样。<code> <pre> 活动单元的数量：256（在5层） 自由度的数量：3556（2178+289+1089)

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.919118温度的9次CG迭代。    温度范围：-0.16687 1.30011

活动单元的数量：280（在6层） 自由度的数量：4062（2490+327+1245）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.459559温度的9次CG迭代。    温度范围：-0.0982971 0.598503

活动单元的数量：520（在7个层面上） 自由度的数量：7432（4562+589+2281）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.229779 温度的9次CG迭代。    温度范围：-0.0551098 0.294493

活动单元的数量：1072（在8层） 自由度的数量：15294（9398+1197+4699）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.11489 温度的9次CG迭代。    温度范围：-0.0273524 0.156861

活动单元的数量：2116（在9层） 自由度的数量：30114（18518+2337+9259）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.0574449温度的9次CG迭代。    温度范围：-0.014993 0.0738328

时间步骤1：t=0.0574449 装配...    解决...    斯托克斯子系统的56次GMRES迭代。    时间步长：0.0574449 温度的9次CG迭代。    温度范围：-0.0273934 0.14488

...</pre> </code>

在开始的时候，我们自适应地细化了几次网格，并总是返回到时间步长为零的新细化的网格上重新开始。只有这样，我们才开始实际的时间迭代。

程序运行了一段时间。时间步数为0、500、1000、1500、2000、3000、4000和5000的温度字段看起来是这样的（注意温度使用的色标并不总是相同）。

[2.x.2610]

这里显示的视觉效果是使用实例的一个版本生成的，该版本在传输网格后没有强制执行约束。

可以看出，我们有三个加热流体的热源，因此产生了一个浮力效应，让流体的热袋上升并旋转起来。通过烟囱效应，这三股气流被来自外部并想加入上升气流的流体压在一起。请注意，由于流体最初处于静止状态，那些最初在源头上的流体部分比后来被充分发展的流场拖到源头上的流体获得更长的加热时间。因此，它更热，这一事实可以从三个羽流的红色尖端看出。还要注意流场的相对精细的特征，这是我们选择的温度方程的复杂传输稳定的结果。

除了上面的图片外，下面的图片显示了自适应网格和同一时间步长的流场。

[2.x.2611]




[1.x.965]

当然，同样的事情也可以在3D中完成，将[2.x.2612]中的BoussinesqFlowProblem对象的模板参数从2改为3，这样，现在的输出看起来如下。

<code> <pre> 活动单元的数量：64（在3层） 自由度的数量：3041（2187+125+729）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：2.45098 温度的9次CG迭代。    温度范围：-0.675683 4.94725

活动单元的数量：288（在4层） 自由度的数量：12379（8943+455+2981）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：1.22549 温度的9次CG迭代。    温度范围：-0.527701 2.25764

活动单元的数量：1296（在5层） 自由度的数量：51497（37305+1757+12435）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.612745温度的10次CG迭代。    温度范围：-0.496942 0.847395

活动单元的数量：5048（在6层） 自由度的数量：192425（139569+6333+46523）。

时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.306373 温度的10次CG迭代。    温度范围：-0.267683 0.497739

时间步数1：t=0.306373 正在组装...    解决...    斯托克斯子系统的27次GMRES迭代。    时间步长：0.306373 温度的10次CG迭代。    温度范围：-0.461787 0.958679

...</pre> </code>

在时间步数为0、50、100、150、200、300、400、500、600、700和800的情况下，将温度等值线可视化，得到以下图示。

[2.x.2613]

第一张图片看起来像三只刺猬，这是因为我们的方案基本上是将源乘以第一时间步长投射到网格上，以获得第一时间步的温度场。由于源函数是不连续的，我们需要期待这个项目的过冲和欠冲。这就是事实上发生的情况（在2d中更容易检查），并导致等值面的皱缩外观。  这里显示的视觉效果是使用例子的一个版本生成的，该版本在传输网格后没有强制执行约束。




[1.x.966]

现在的程序有三个参数，我们在理论上并没有掌握如何以最佳方式进行选择。这三个参数是。  [2.x.2614] [2.x.2615] 时间步骤必须满足CFL条件 [2.x.2616] 。这里，[2.x.2617]是无量纲的，但什么是正确的值？    [2.x.2618] 在计算人工黏度时。

[1.x.967]

      与[2.x.2619] 。       这里，无量纲%数[2.x.2620]的选择是有意义的。  [2.x.2621] 在所有这些情况下，我们将不得不期望每个值的正确选择取决于其他值的正确选择，而且很可能也取决于用于温度的有限元的空间尺寸和多项式程度。下面我们将讨论一些数值实验来选择常数 [2.x.2622] 和 [2.x.2623] 。

下面，我们将不讨论[2.x.2624]的选择问题。在程序中，我们将其设定为[2.x.2625] 。这个值的原因有点复杂，与程序的历史而不是推理有关：虽然全局缩放参数[2.x.2626]的正确公式如上所示，但程序（包括与deal.II 6.2一起出厂的版本）最初有一个错误，即我们计算的是[2.x.2627]，而在这里我们将缩放参数设置为1。由于我们只在[2.x.2628]的单位平方/立方体上进行计算，这完全等同于使用[2.x.2629]的正确公式。由于[2.x.2630]的这个值对于当前的程序来说似乎很好用，我们在程序中修正了公式，并将[2.x.2631]设置为一个值，正好再现了我们之前的结果。不过，我们将在第32步中再次审视这个问题。

然而，现在回到讨论[2.x.2632]和[2.x.2633]的什么值来选择。




[1.x.968][1.x.969] 。

这两个常数肯定在某种程度上有联系。原因很容易看出来。在纯平流问题的情况下，[2.x.2634]，任何显式方案都必须满足形式为[2.x.2635]的CFL条件。另一方面，对于纯扩散问题，[2.x.2636]，显式方案需要满足一个条件[2.x.2637]。因此，鉴于上述[2.x.2638]的形式，像我们这里要解决的平流扩散问题将导致一个[2.x.2639]的条件。因此，我们必须面对这样一个事实：我们可能想选择[2.x.2640]大一些，以提高数值方案的稳定性（通过增加人工扩散量），但我们必须以更小的、因而更多的时间步骤为代价。因此，在实践中，人们希望尽可能地选择[2.x.2641]，以保持传输问题的充分稳定，同时尽量选择大的时间步长，以减少总体工作量。

要找到正确的平衡，唯一的办法是做一些计算实验。下面是我们的做法。我们稍微修改了程序，允许更少的网格细化（所以我们不一定要等那么久），并选择[2.x.2642]来消除常数[2.x.2643]的影响（我们知道通过使用这个版本的[2.x.2644]作为人工粘度，解决方案是稳定的，但我们可以通过使用这个人工粘度的更复杂的公式来改善情况--即使解决方案更清晰）。然后我们对不同的值[2.x.2645]运行程序，观察域中的最大和最小温度。我们期望看到的情况是这样的。如果我们选择的时间步长过大（即选择一个比理论上允许的大的[2.x.2646]），那么我们将得到温度的指数式增长。如果我们选择[2.x.2647]太小，那么传输稳定变得不充分，解决方案将显示出明显的振荡，但不是指数级增长。




[1.x.970]

下面是我们对[2.x.2648]，和[2.x.2649]，[2.x.2650]的不同选择，以及2d的双线性元素（[2.x.2651]）得到的结果。

[2.x.2652]

解释这些图表的方法是这样的：对于[2.x.2653]和[2.x.2654]，我们看到指数增长或至少是大的变化，但如果我们选择[2.x.2655]或更小，那么这个方案虽然有点摇摆不定，但还是稳定的。对于更多的人工扩散，我们可以选择[2.x.2656]或更小的[2.x.2657]，[2.x.2658]或更小的[2.x.2659]，并再次需要[2.x.2660]的[2.x.2661]（这次是因为许多扩散需要一个小的时间步长）。

那么该如何选择呢？如果我们只是对大时间步长感兴趣，那么我们会选择[2.x.2662]和[2.x.2663] 。另一方面，我们也对准确性感兴趣，在这里，实际调查这些曲线所显示的内容可能会有兴趣。为此，请注意，我们从零温度开始，我们的来源是正的&mdash；所以我们会直观地期望温度永远不会降到零以下。但它确实如此，这是使用连续元素来近似不连续的解决方案时，吉布现象的结果。因此，我们可以看到，选择[2.x.2664]太小是不好的：太少的人工扩散会导致没有扩散掉的过冲和欠冲。另一方面，对于大的[2.x.2665]，最低温度在开始时下降到零以下，但随后迅速扩散回零。

另一方面，我们也来看看最高温度。观察溶液的电影，我们看到最初流体处于静止状态。源头不断加热相同体积的流体，其温度在开始时呈线性增长，直到其浮力能够使其向上移动。因此，流体中最热的部分被带离了溶液，取而代之的流体只被加热了很短的时间就被移出了源区，因此仍然比初始气泡要冷。如果[2.x.2666]（在程序中是非零的，但非常小），那么流体中最热的部分应该随着流动而平移，其温度不变。这就是我们在最小的[2.x.2667]图中可以看到的：一旦达到最高温度，它就几乎不再变化。另一方面，人工扩散越大，热点的扩散就越多。请注意，对于这个标准，时间步长的大小并不发挥重要作用。

因此，总结起来，可能最好的选择似乎是[2.x.2668]和[2.x.2669] 。曲线有点摇摆不定，但总的来说，图片看起来相当合理，除了由于吉布现象而在接近开始时间时出现一些过冲和欠冲的情况。




[1.x.971]

我们也可以对高阶元素重复同样的实验序列。这里是温度的双二次方形状函数（[2.x.2670]）的图形，同时我们保留了斯托克斯系统的[2.x.2671]稳定泰勒-胡德元素。

[2.x.2672]

同样，[2.x.2673]的小值会导致较少的扩散，但我们必须选择非常小的时间步长来保持事情的控制。太大的[2.x.2674]值会导致更多的扩散，但同样需要小的时间步骤。最佳值似乎是[2.x.2675]，和[2.x.2676]元素一样，然后我们必须选择[2.x.2677]&mdash；正好是[2.x.2678]元素的一半大小。]元素，如果我们把CFL条件说成是要求时间步长足够小，以便运输在每个时间步长中的移动距离不超过一个[1.x.972]距离（对于[2.x.2679]元素是[2.x.2680]，但对于[2.x.2681]元素是[2.x.2682]），这个事实可能并不令人惊讶。事实证明，[2.x.2683]需要稍微大一点，以便在模拟后期获得稳定的结果，时间大于60，所以我们实际上在代码中选择它作为[2.x.2684]。




[1.x.973]

我们可以在3D中重复这些实验，找到每个[2.x.2685]值的最佳时间步骤，并找到[2.x.2686]的最佳值。人们发现，对于2d中已经使用的相同的[2.x.2687]，时间步长需要小一点，大约是1.2倍左右。这很容易解释：时间步长的限制是[2.x.2688]，其中[2.x.2689]是单元的[1.x.974]。然而，真正需要的是网格点之间的距离，它是[2.x.2690] 。所以更合适的形式是 [2.x.2691] 。

第二个发现是，需要把[2.x.2692]选得稍微大一点（大约[2.x.2693]左右）。这就再次减少了我们可以采取的时间步骤。







[1.x.975]

总之，从上面的简单计算来看，[2.x.2694]似乎是2D中稳定参数的一个好选择，而[2.x.2695]则是3D中的稳定参数。以独立于维度的方式，我们可以将其建模为[2.x.2696] 。如果在更细的网格上做更长时间的计算（几千个时间步长），就会意识到时间步长还不够小，为了稳定，就必须把上述数值再降低一些（大约是[2.x.2697]的一个系数）。

因此，调和2D、3D和可变多项式程度并考虑到所有因素的公式如下。

[1.x.976]

在第一种形式中（方程中心），[2.x.2698]是一个通用常数，[2.x.2699]是说明单元直径和网格点间距的因素，[2.x.2700]说明[2.x.2701]随着空间尺寸的增加而增加，[2.x.2702]说明高阶元素的网格点之间的距离，[2.x.2703]说明相对于单元尺寸的局部传输速度。这就是我们在程序中使用的公式。

至于对温度使用[2.x.2704]或[2.x.2705]元素的问题，以下考虑可能是有用的。首先，解决温度方程在整个方案中几乎不是一个因素，因为几乎所有的计算时间都用于解决每个时间步骤中的斯托克斯系统。因此，温度方程的高阶元素并不是一个重要的缺点。另一方面，如果比较一下由于不连续的源描述而产生的过冲和欠冲的大小，我们会注意到，对于上述[2.x.2706]和[2.x.2707]的选择，[2.x.2708]的解决方案下降到[2.x.2709]左右，而[2.x.2710]的解决方案只到[2.x.2711]（记住，精确解决方案根本不应该变成负数。这意味着[2.x.2712]解明显更准确；因此程序使用这些高阶元素，尽管我们在较小的时间步长方面付出了代价。




[1.x.977]

有各种方法来扩展当前的程序。当然，特别感兴趣的是使其更快和/或提高程序的分辨率，特别是在3D方面。这就是step-32教程程序的主题，它将实现在集群上以%并行方式解决这个问题的策略。它也是更大的开放源代码ASPECT（见https://aspect.geodynamics.org/）的基础，它可以解决现实问题，并构成step-32的进一步发展。

另一个方向是使流体流动更加真实。这个程序最初是为了模拟各种情况，模拟地幔中的物质对流，即外地核和固体地壳之间的区域：在那里，物质从下面被加热，从上面被冷却，导致热对流。然而，这种流体的物理学要比这个程序中显示的复杂得多。地幔材料的粘度与温度有很大的关系，即[2.x.2713]，这种关系经常被模拟为粘度随温度升高而呈指数下降。其次，地幔的大部分动态是由化学反应决定的，主要是构成地幔的各种晶体的相变；然后，斯托克斯方程右边的浮力项不仅取决于温度，而且还取决于某个特定位置的化学成分，这些化学成分被流场平流，但也作为压力和温度的函数而变化。我们将在以后的教程程序中也研究其中的一些影响。


examples/step-32/doc/intro.dox

[2.x.2714]

[1.x.978][1.x.979][1.x.980][1.x.981][1.x.982]


[1.x.983]

[1.x.984]

这个程序所做的事情与step-31已经做的差不多：它解决了描述温度不平衡的流体运动的Boussinesq方程。因此，我们在step-31中描述的所有方程仍然成立：我们使用相同的有限元方案、相同的时间步进算法和或多或少相同的温度平流-扩散方程的稳定方法来解决相同的一般偏微分方程（只做了些许修改，以适应问题设置的更多现实性）。因此，你可能首先要了解那个程序和它的实现，然后再研究当前的程序。

step-31和当前程序的不同之处在于，在这里，我们想以%并行的方式做事，既利用集群中许多机器的可用性（基于MPI的并行化），也利用一台机器中的许多处理器核心（基于线程的并行化）。因此，本程序的主要工作是引入必要的变化，以利用这些%并行计算资源的可用性。在这方面，它建立在第40步程序的基础上，该程序首先为大部分的%并行功能介绍了必要的类，而第55步则展示了如何为一个矢量值的问题做这件事。

除了这些变化之外，我们还使用了一个略微不同的预处理程序，而且我们将不得不做出一些改变，这与我们在这里想要解决一个[1.x.985]问题，而不是一个模型问题有关。特别是后者，将要求我们考虑比例问题，以及所考虑的方程中所有这些参数和系数的实际含义。我们将首先讨论影响数学公式和求解器结构变化的问题，然后讨论如何将事情并行化，最后讨论我们将考虑的实际测试案例。




[1.x.986]

在步骤31中，我们对速度和压力场使用了以下斯托克斯模型。

[1.x.987]

第一个等式的右手边显得有点无动于衷。事情其实应该是这样的。我们需要作用在流体上的外力，我们假设这些外力只是由重力给出的。在目前的情况下，我们假设流体确实为了这个重力的目的而轻微膨胀，但还不足以让我们需要修改不可压缩性条件（第二个方程）。这意味着，为了右手边的目的，我们可以假设[2.x.2715] 。一个可能不完全合理的假设是，我们可以假设密度作为温度的函数的变化很小，导致形式为[2.x.2716] 的表达，即在参考温度下密度等于[2.x.2717]，并且随着温度的升高（随着材料的膨胀）线性下降。然后，力平衡方程看起来正确地写成这样。

[1.x.988]

现在注意到，引力是由重力势产生的，如[2.x.2718] ，因此我们可以将其重新写成如下。

[1.x.989]

右边的第二个项是与时间无关的，因此我们可以引入一个新的 "动态 "压力[2.x.2719]，用它来表示斯托克斯方程。

[1.x.990]

这正是我们在第31步中使用的形式，这样做是合适的，因为流体流动的所有变化只由温度差异导致的动态压力驱动。(换句话说。任何因取标量场的梯度而导致的对右手边的贡献都对速度场没有影响）。)

另一方面，我们在这里将使用考虑总压力的斯托克斯方程的形式来代替。

[1.x.991]

这有几个好处。

- 这样我们就可以在我们的程序中绘制压力图，它实际上显示的是包括温差影响以及上覆岩石的静压力在内的总压力。由于压力没有进一步出现在任何其他方程中，因此使用一个还是另一个，更多的是口味问题，而不是正确性问题。流动场是完全相同的，但我们得到的压力现在可以与地球物理书籍中给出的数值进行比较，例如，在地幔底部的压力。

- 如果我们想让这个模型更加真实，我们就必须考虑到许多材料参数（如粘度、密度等）不仅取决于温度，而且还取决于[1.x.992]压力。

- 上面的模型假设了一个线性依赖[2.x.2720]，并假定[2.x.2721]很小。在实践中，情况可能并非如此。事实上，现实的模型肯定不是线性的，而且[2.x.2722]至少在部分温度范围内也可能不小，因为密度的行为不仅大大取决于热膨胀，而且取决于相变。

- 这样做的最后一个原因将在结果部分讨论，涉及到对我们在这里使用的模型的可能扩展。这与我们在这里使用的温度方程（见下文）不包括包含压力的条款这一事实有关。然而，它应该包括：岩石，像气体一样，在你压缩它的时候会升温。因此，上升的物质以绝热方式冷却，而下沉的冷物质以绝热方式升温。我们在下面进一步讨论这个问题。

[2.x.2723] 然而，这个程序有一个缺点。在地球上，动压比总压要小几个数量级。如果我们使用上述方程并解决所有变量，例如，4位数的精度，那么我们可能会得到正确的速度和总压力，但如果我们通过从总压力中减去静态部分来计算动态压力，我们将完全没有精度 [2.x.2724] 。例如，如果动压比静压小六个数量级，那么我们就需要将总压解到至少七位数的精度，才能得到任何精确的结果。也就是说，在实践中，这并不是一个限制性因素。




[1.x.993]

请记住，我们要解决以下方程组。

[1.x.994]

用适当的边界条件和初始条件加以补充。正如第31步所讨论的，我们将通过在每个时间步长中首先求解斯托克斯问题，然后将温度方程向前移动一个时间间隔来解决这组方程。

本节所考虑的问题是斯托克斯问题：如果我们像往常一样对其进行离散化，我们会得到一个线性系统

[1.x.995]

在这个程序中，我们将用FGMRES求解器来解决这些问题。这个求解器一直迭代到这些线性方程的残差低于某个公差，也就是说，直到

[1.x.996]

从物理单位的角度来看，这没有任何意义：这里涉及的量有物理单位，所以残差的第一部分有单位[2.x.2725]（通过考虑术语[2.x.2726]和考虑压力有单位[2.x.2727]以及积分得到的系数[2.x.2728]最容易确定），而残差的第二部分有单位[2.x.2729] 。取这个残差向量的常数将得到一个单位为 [2.x.2730] 的量。很明显，这样做是没有意义的，而且我们不应该惊讶这样做最终会伤害到我们。

那么，为什么这在这里是个问题，而在第31步却不是呢？原因是一切都很平衡：速度是1，压力也是1，粘度是1，域的直径是[2.x.2731] 。结果是，虽然不符合逻辑，但没有发生什么坏事。另一方面，正如我们将在下面解释的那样，这里的事情不会是那么简单的缩放。  [2.x.2732]将在[2.x.2733]左右，速度在[2.x.2734]的数量级，压力在[2.x.2735]左右，域的直径是[2.x.2736]。换句话说，第一个方程的数量级将是 [2.x.2737] ，而第二个方程将是 [2.x.2738] 左右。那么，这将导致这样的结果：如果求解器想使残差变小，它几乎会完全集中在第一组方程上，因为它们大得多，而忽略描述质量守恒的发散方程。这正是发生的情况：除非我们将公差设置为极小的值，否则所得到的流场肯定不是无发散的。作为一个辅助问题，事实证明，很难找到一个始终有效的公差；在实践中，人们往往最终得到一个公差，在大多数时间步骤中需要30或40次迭代，而在其他一些时间步骤中需要10,000次。

那么，在这样的情况下，数字分析员该怎么做呢？答案是要从根本上入手，首先确保一切在数学上是一致的。在我们的例子中，这意味着如果我们想联合解决斯托克斯方程组，我们必须对它们进行缩放，使它们都有相同的物理尺寸。在我们的例子中，这意味着将第二个方程乘以具有单位[2.x.2739]的东西；一种选择是乘以[2.x.2740]，其中[2.x.2741]是我们领域的典型长度尺度（实验表明最好选择羽流的直径&mdash；大约10公里&mdash；而不是领域的直径）。使用[2.x.2742]和[2.x.2743]的这些%数，这个系数约为[2.x.2744]。因此，我们现在对斯托克斯系统得到这个。

[1.x.997]

这样做的问题是，结果不再是对称的（我们在左下方有[2.x.2745]，但在右上方没有它的转置算子）。然而，这可以通过引入一个按比例的压力[2.x.2746]来解决，我们得到按比例的方程式

[1.x.998]

这现在是对称的。很明显，我们可以很容易地从我们作为这个程序的结果计算的比例压力[2.x.2748]中恢复原始压力[2.x.2747]。

在下面的程序中，我们将引入一个与[2.x.2749]相对应的因子，我们将在系统矩阵和预处理程序的装配中使用这个因子。因为这很烦人而且容易出错，我们将在线性系统的解之后立即恢复未标定的压力，也就是说，解矢量的压力分量将立即被取消标定以检索物理压力。由于求解器使用的是我们可以通过推断以前的解来使用一个好的初始猜测，所以我们也要立即对压力进行缩放[1.x.999]求解。




[1.x.1000]

在这个教程程序中，我们应用了步骤31中使用的预处理程序的一个变体。该预处理程序是以块状形式对系统矩阵[2.x.2751]进行操作，从而使乘积矩阵

[1.x.1001]

其形式是基于Krylov的迭代求解器，如GMRES，可以在几次迭代中解决。然后，我们用基于矢量拉普拉斯矩阵的AMG预处理程序[2.x.2753]的作用取代了[2.x.2752]的精确逆，用压力空间上的质量矩阵[2.x.2755]来逼近舒尔补码[2.x.2754]，并编写了一个<tt>InverseMatrix</tt>类，用于实现[2.x.2756]对矢量的作用。在InverseMatrix类中，我们使用了带有不完全Cholesky（IC）预处理的CG求解器来进行内部求解。

我们可以观察到，我们仅仅使用了预处理程序的作用来逼近速度逆[2.x.2757]（外部GMRES迭代处理了逆的近似特性），而我们对[2.x.2758]使用了或多或少的[1.x.1002]逆，由完全收敛的CG解实现。这似乎是不平衡的，但这种疯狂是有系统的：几乎所有的努力都用在了左上角的区块上，我们将AMG预处理程序应用于此，而即使是压力质量矩阵的精确反转也基本上不需要花费什么。因此，如果它能帮助我们在一定程度上减少总的迭代次数，那么这种努力是值得的。

也就是说，尽管求解器对step-31工作得很好，但我们这里的问题有点复杂（细胞是变形的，压力有数量级的变化，我们要为更复杂的物理学提前做计划），所以我们要稍微改变一些东西。

- 对于更复杂的问题，事实证明，仅仅使用单一的AMG V-循环作为预处理器并不总是足够的。外围求解器在大多数时候都能在合理的迭代次数内收敛（例如，少于50次），但偶尔会出现突然需要700次左右的时间步骤。到底发生了什么，很难确定，但这个问题可以通过对左上角的块使用更精确的求解器来避免。因此，我们要使用CG迭代来反转预处理矩阵的左上块，并使用AMG作为CG求解器的预处理。

- 这样做的缺点是，当然，斯托克斯预处理程序变得更加昂贵（比我们只使用单个V型循环时大约昂贵10倍）。我们的策略是这样的：让我们只用V型循环作为预处理程序做多达30次的GMRES迭代，如果没有收敛，那么在这第一轮迭代后得到的斯托克斯解的最佳近似值，并将其作为我们使用具有相当宽松容忍度的完整内部求解器作为预处理程序的迭代的起始猜测。在我们所有的实验中，这只导致了少数额外迭代的收敛。

- 我们需要注意的一点是，当在前置条件器中使用具有宽松容忍度的CG时，那么[2.x.2759]就不再是[2.x.2760]的线性函数（当然，如果我们的求解器中具有非常严格的容忍度，或者我们只应用单一的V型循环，它就是如此）。这是一个问题，因为现在我们的预处理程序不再是一个线性算子；换句话说，每次GMRES使用它时，预处理程序看起来都不一样。标准的GMRES求解器无法处理这个问题，导致收敛缓慢甚至崩溃，但F-GMRES变体正是为了处理这种情况而设计的，我们因此使用了它。

- 另一方面，一旦我们确定使用F-GMRES，我们就可以放宽在倒置[2.x.2761]的预处理时使用的容忍度。在第31步中，我们对[2.x.2762]运行了一个预处理的CG方法，直到残差减少了7个数量级。在这里，我们可以再次宽松一些，因为我们知道外部预处理程序不会受到影响。

- 在第31步中，我们使用了一个左边的预处理程序，首先反转预处理矩阵的左上块，然后应用左下块（发散）的，再反转右下块。换句话说，预处理器的应用起到了左下块三角矩阵的作用。另一种选择是使用右预处理器，这里将是右上块三角化，即我们首先反转右下舒尔补码，应用右上（梯度）算子，然后反转椭圆的左上块。在某种程度上，选择哪一个是一个品味的问题。也就是说，在GMRES类型的求解器中，右预处理有一个明显的优势：我们决定是否应该停止迭代的残差是真正的残差，而不是预处理方程的规范。因此，将其与我们通常使用的停止标准，即右手边向量的规范进行比较要简单得多。在编写这段代码时，我们发现上面讨论的缩放问题也使我们难以确定适合于左预处理线性系统的停止准则，因此本程序使用了右预处理器。

- 在第31步中，我们对舒尔补码预处理中的压力质量矩阵和温度系统的解使用了IC（不完全Cholesky）预处理。在这里，我们原则上也可以这样做，但我们确实选择了一个更简单的预处理程序，即两个系统的雅可比预处理程序。这是因为在这里我们的目标是大规模的并行计算，IC/ILU的分解必须在每个处理器上对本地拥有的自由度逐块执行。这意味着，无论如何，预处理程序会变得更像一个雅可比预处理程序，所以我们宁愿直接从这个变体开始。请注意，我们只对有质量矩阵的CG求解器使用Jacobi预处理，无论如何它们都能提供最佳的（[1.x.1003]独立的）收敛性，尽管它们通常需要两倍于IC预处理的迭代次数。

最后，让我们指出，在第31步中，我们通过逼近[2.x.2764]来计算舒尔补数[2.x.2763]。然而现在，我们已经对[2.x.2765]和[2.x.2766]算子进行了重新缩放。所以[2.x.2767]现在应该近似于[2.x.2768] 。我们用这个的右手边的离散形式作为我们对[2.x.2769]的近似[2.x.2770]。




[1.x.1004]

与第31步类似，我们将使用一个基于方程残差的人工黏度进行稳定。  作为与步骤-31的不同之处，我们将提供两个略有不同的稳定参数的定义。对于[2.x.2771]，我们使用与步骤31相同的定义。

[1.x.1005]

我们从方程的残差[2.x.2772]中计算粘度，在残差较大的区域（陡峭的梯度周围），由与网格大小[2.x.2773]成比例的扩散来限制粘度。这个定义已被证明对给定的情况，[2.x.2774]在step-31中效果很好，但它通常不如[2.x.2775]的扩散有效。对于这种情况，我们选择一个稍微可读的粘度定义。

[1.x.1006]

其中第一项又给出了最大耗散量（类似于一阶上风方案）。

[1.x.1007]

而熵粘度的定义为

[1.x.1008]



这个公式在[1.x.1009]一文中有描述。与[2.x.2776]的情况相比，残差是由温度熵计算出来的，[2.x.2778]是平均温度（我们在计算中选择最高和最低温度之间的平均值），这就得到了以下公式

[1.x.1010]

[2.x.2779]公式中的分母被计算为熵与空间平均熵的整体偏差 [2.x.2780] 。如同在步骤31中，我们根据前两个时间层次的温度和速度来评估人工黏度，以避免其定义中的非线性。

上述粘度的定义很简单，但取决于两个参数，即 [2.x.2781] 和 [2.x.2782] 。  对于目前的程序，我们想在[2.x.2783]的情况下对这两个参数更系统地去解决这个问题，使用我们在步骤31的结果部分选择离散化的另外两个参数[2.x.2784]和[2.x.2785]的相同推理。特别是，请记住，我们希望使人工粘度尽可能小，同时保持必要的大。在下文中，让我们描述一下人们可能遵循的一般策略。这里显示的计算是用程序的早期版本完成的，因此你在运行程序时得到的实际数值可能不再与这里显示的数值一致；尽管如此，一般的方法仍然有效，并已被用于寻找程序中实际使用的参数值。

为了了解发生了什么，请注意，下面我们将对973和4273开尔文之间的温度施加边界条件，初始条件也选择在这个范围内；出于这些考虑，我们在没有%内部热源或散热器的情况下运行程序，因此温度应该总是在这个范围内，排除任何%内部振荡。如果最低温度下降到973开尔文以下，那么我们需要通过增加[2.x.2786]或减少[2.x.2787]来增加稳定度。

正如我们在第31步所做的那样，我们首先通过使用 "传统 "公式确定[2.x.2788]的最佳值

[1.x.1011]

我们知道，只要[2.x.2789]足够大，它就是稳定的。在2d中做几百个时间步数（在比程序中显示的网格更粗的网格上，用不同的粘度影响传输速度，从而影响时间步数大小），将产生以下图表。

[2.x.2790]

可以看出，[2.x.2791]的数值太小，而[2.x.2792]似乎是有效的，至少在这里显示的时间范围内。顺便说一句，这里至少有两个问题是人们可能想知道的。首先，当解决方案变得不稳定时，会发生什么？看一下图形输出，我们可以看到，在这些实验所选择的不合理的粗大网格下，大约在[2.x.2793]秒的时间里，一直向冷的外部边界上升，然后向侧面扩散的热物质羽流开始相互靠近，将中间的冷物质挤出去。这就形成了一个细胞层，流体从两个相对的侧面流入，并向第三个侧面流出，显然，这种情况会在没有足够稳定的情况下产生这些不稳定性。第二：在步骤31中，我们使用了[2.x.2794]；为什么这在这里不起作用？这个问题的答案并不完全清楚--稳定参数肯定取决于单元格的形状等因素，在第31步中我们使用的是正方形，而在当前程序中则是梯形。不管具体原因是什么，我们至少有一个[2.x.2795]的值，即2d的0.052，对当前程序有效。在3d中也可以做类似的实验，我们发现[2.x.2796]是一个很好的选择&mdash; 整齐地引出公式[2.x.2797] 。

有了这个值，我们就可以回到粘度的原始公式[2.x.2798]，并玩弄常数[2.x.2799]，使其尽可能大，以便使[2.x.2800]尽可能小。这样我们就得到了这样的画面。

[2.x.2801]

因此，[2.x.2802]似乎是这里的正确值。虽然这个图形是针对指数[2.x.2803]得到的，但在程序中我们用[2.x.2804]代替，在这种情况下，必须重新调整参数（并观察到[2.x.2805]出现在分子中而不是分母中）。事实证明，[2.x.2806]与[2.x.2807]一起工作。




[1.x.1012]

Stokes的标准Taylor-Hood离散化，使用[2.x.2808]元素，是全局保守的，即[2.x.2809] 。这很容易看出：发散方程的弱形式为 [2.x.2810] 。因为压力空间确实包含函数 [2.x.2811] ，所以我们得到

[1.x.1013]

由发散定理决定。这个性质很重要：如果我们想用速度场[2.x.2812]沿途输送其他量（如电流方程中的温度，但也可以是化学物质的浓度或完全是人为的示踪量），那么守恒性质保证所输送的量保持恒定。

也就是说，在有些应用中，这个[1.x.1014]属性是不够的。相反，我们希望它在每个单元上都持有[1.x.1015]。这可以通过使用空间[2.x.2813]进行离散化来实现，我们用相同程度的完整多项式的[1.x.1017]空间代替压力的张量积多项式[2.x.2814]空间。(注意，2d中的张量积多项式包含函数[2.x.2815]，而完全多项式只包含函数[2.x.2816]) 。这个空间对斯托克斯方程来说是稳定的。

因为空间是不连续的，我们现在可以特别选择测试函数 [2.x.2817] ，即单元格 [2.x.2818] 的特征函数。然后我们以类似于上面的方式得到

[1.x.1018]

显示了单元格[2.x.2819]的保存属性。这显然对每个细胞都是成立的。

使用这种离散化是有充分理由的。如上所述，这个元素保证了每个单元上平流量的守恒。第二个优点是，我们用作预处理的压力质量矩阵代替了Schur补码，成为块状对角线，因此非常容易反转。然而，也有缺点。首先，现在有更多的压力变量，增加了问题的总体规模，尽管这在实践中似乎没有造成太大的影响。但更重要的是，现在每个单元上的发散是零，而以前不是，这并不能保证发散是点状的小。事实上，我们可以很容易地验证，与标准Taylor-Hood离散化相比，这个离散化的[2.x.2820]准则是[1.x.1019]。然而，两者都以相同的速度收敛到零，因为很容易看到[2.x.2821] 。因此，并不是先验的，仅仅因为我们现在有更多的自由度，误差就真的小了。

鉴于这些考虑，目前还不清楚应该选择哪种离散化方式。因此，我们把这个问题留给用户，并在输入文件中规定使用哪个参数。




[1.x.1020]

在程序中，我们将使用一个球壳作为域。这意味着域的内部和外部边界不再是 "直的"（我们通常指它们是可以用FlatManifold类表示的双线性表面）。相反，它们是弯曲的，如果我们已经使用高阶有限元来计算速度，那么在程序中使用一个弯曲的近似值似乎是谨慎的。因此，我们将引入一个MappingQ类型的成员变量，表示这样的映射（步骤10和步骤11首次引入这样的映射），我们将在与边界相邻的单元的所有计算中使用。由于这只影响到相对较小的一部分单元格，额外的努力并不是很大，我们将对这些单元格使用四分法映射。