<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_41.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-41 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-41 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Introduction">Introduction</a>
        <li><a href="#Classicalformulation">Classical formulation</a>
        <li><a href="#Derivationofthevariationalinequality">Derivation of the variational inequality</a>
        <li><a href="#Formulationasasaddlepointproblem">Formulation as a saddle point problem</a>
        <li><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to solve the saddle point problem</a>
        <li><a href="#Theprimaldualactivesetalgorithm">The primal-dual active set algorithm</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeObstacleProblemcodeclasstemplate">The <code>ObstacleProblem</code> class template</a>
        <li><a href="#Righthandsideboundaryvaluesandtheobstacle">Right hand side, boundary values, and the obstacle</a>
        <li><a href="#ImplementationofthecodeObstacleProblemcodeclass">Implementation of the <code>ObstacleProblem</code> class</a>
      <ul>
        <li><a href="#ObstacleProblemObstacleProblem">ObstacleProblem::ObstacleProblem</a>
        <li><a href="#ObstacleProblemmake_grid">ObstacleProblem::make_grid</a>
        <li><a href="#ObstacleProblemsetup_system">ObstacleProblem::setup_system</a>
        <li><a href="#ObstacleProblemassemble_system">ObstacleProblem::assemble_system</a>
        <li><a href="#ObstacleProblemassemble_mass_matrix_diagonal">ObstacleProblem::assemble_mass_matrix_diagonal</a>
        <li><a href="#ObstacleProblemupdate_solution_and_constraints">ObstacleProblem::update_solution_and_constraints</a>
        <li><a href="#ObstacleProblemsolve">ObstacleProblem::solve</a>
        <li><a href="#ObstacleProblemoutput_results">ObstacleProblem::output_results</a>
        <li><a href="#ObstacleProblemrun">ObstacleProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by JÃ¶rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&amp;M University. <br />
 This material is based upon work partly supported by ThyssenKrupp Steel Europe. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h3>Introduction</h3>
<p>This example is based on the Laplace equation in 2d and deals with the question what happens if a membrane is deflected by some external force but is also constrained by an obstacle. In other words, think of a elastic membrane clamped at the boundary to a rectangular frame (we choose \(\Omega = \left[-1,1\right]^2\)) and that sags through due to gravity acting on it. What happens now if there is an obstacle under the membrane that prevents it from reaching its equilibrium position if gravity was the only existing force? In the current example program, we will consider that under the membrane is a stair step obstacle against which gravity pushes the membrane.</p>
<p>This problem is typically called the "obstacle problem" (see also <a href="http://en.wikipedia.org/wiki/Obstacle_problem">this Wikipedia article</a>), and it results in a variational inequality, rather than a variational equation when put into the weak form. We will below derive it from the classical formulation, but before we go on to discuss the mathematics let us show how the solution of the problem we will consider in this tutorial program looks to gain some intuition of what we should expect:</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.png"/>
</div>
   </td></tr>
</table>
<p>Here, at the left, we see the displacement of the membrane. The shape of the obstacle underneath is clearly visible. On the right, we overlay which parts of the membrane are in contact with the obstacle. We will later call this set of points the "active set" to indicate that an inequality constraint is active there.</p>
<p><a class="anchor" id="Classicalformulation"></a></p><h3>Classical formulation</h3>
<p>The classical formulation of the problem possesses the following form: </p><p class="formulaDsp">
\begin{align*} -\textrm{div}\ \sigma &amp;\geq f &amp; &amp;\quad\text{in } \Omega,\\ \sigma &amp;= \nabla u &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;= 0 &amp; &amp;\quad\text{on }\partial\Omega,\\ (-\Delta u - f)(u - g) &amp;= 0 &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;\geq g(\mathbf x) &amp; &amp;\quad\text{in } \Omega \end{align*}
</p>
<p> with \(u\in H^2(\Omega)\). \(u\) is a scalar valued function that denotes the vertical displacement of the membrane. The first equation is called equilibrium condition with a force of areal density \(f\). Here, we will consider this force to be gravity. The second one is known as Hooke's Law that says that the stresses \(\sigma\) are proportional to the gradient of the displacements \(u\) (the proportionality constant, often denoted by \(E\), has been set to one here, without loss of generality; if it is constant, it can be put into the right hand side function). At the boundary we have zero Dirichlet conditions. Obviously, the first two equations can be combined to yield \(-\Delta u \ge f\).</p>
<p>Intuitively, gravity acts downward and so \(f(\mathbf x)\) is a negative function (we choose \(f=-10\) in this program). The first condition then means that the total force acting on the membrane is gravity plus something positive: namely the upward force that the obstacle exerts on the membrane at those places where the two of them are in contact. How big is this additional force? We don't know yet (and neither do we know "where" it actually acts) but it must be so that the membrane doesn't penetrate the obstacle.</p>
<p>The fourth equality above together with the last inequality forms the obstacle condition which has to hold at every point of the whole domain. The latter of these two means that the membrane must be above the obstacle \(g(\mathbf x)\) everywhere. The second to last equation, often called the "complementarity
condition" says that where the membrane is not in contact with the obstacle (i.e., those \(\mathbf x\) where \(u(\mathbf x) - g(\mathbf x) \neq 0\)), then \(-\Delta u=f\) at these locations; in other words, no additional forces act there, as expected. On the other hand, where \(u=g\) we can have \(-\Delta u-f \neq 0\), i.e., there can be additional forces (though there don't have to be: it is possible for the membrane to just touch, not press against, the obstacle).</p>
<p><a class="anchor" id="Derivationofthevariationalinequality"></a></p><h3>Derivation of the variational inequality</h3>
<p>An obvious way to obtain the variational formulation of the obstacle problem is to consider the total potential energy: </p><p class="formulaDsp">
\begin{equation*} E(u) \dealcoloneq \dfrac{1}{2}\int\limits_{\Omega} \nabla u \cdot \nabla u - \int\limits_{\Omega} fu. \end{equation*}
</p>
<p> We have to find a solution \(u\in G\) of the following minimization problem: </p><p class="formulaDsp">
\begin{equation*} E(u)\leq E(v)\quad \forall v\in G, \end{equation*}
</p>
<p> with the convex set of admissible displacements: </p><p class="formulaDsp">
\begin{equation*} G \dealcoloneq \lbrace v\in V: v\geq g \text{ a.e. in } \Omega\rbrace,\quad V\dealcoloneq H^1_0(\Omega). \end{equation*}
</p>
<p> This set takes care of the third and fifth conditions above (the boundary values and the complementarity condition).</p>
<p>Consider now the minimizer \(u\in G\) of \(E\) and any other function \(v\in G\). Then the function </p><p class="formulaDsp">
\begin{equation*} F(\varepsilon) \dealcoloneq E(u+\varepsilon(v-u)),\quad\varepsilon\in\left[0,1\right], \end{equation*}
</p>
<p> takes its minimum at \(\varepsilon = 0\) (because \(u\) is a minimizer of the energy functional \(E(\cdot)\)), so that \(F&#39;(0)\geq 0\) for any choice of \(v\). Note that \(u+\varepsilon(v-u) = (1-\varepsilon)u+\varepsilon v\in G\) because of the convexity of \(G\). If we compute \(F&#39;(\varepsilon)\vert_{\varepsilon=0}\) it yields the variational formulation we are searching for:</p>
<p><em>Find a function \(u\in G\) with</em> </p><p class="formulaDsp">
\begin{equation*} \left(\nabla u, \nabla(v-u)\right) \geq \left(f,v-u\right) \quad \forall v\in G. \end{equation*}
</p>
<p>This is the typical form of variational inequalities, where not just \(v\) appears in the bilinear form but in fact \(v-u\). The reason is this: if \(u\) is not constrained, then we can find test functions \(v\) in \(G\) so that \(v-u\) can have any sign. By choosing test functions \(v_1,v_2\) so that \(v_1-u = -(v_2-u)\) it follows that the inequality can only hold for both \(v_1\) and \(v_2\) if the two sides are in fact equal, i.e., we obtain a variational equality.</p>
<p>On the other hand, if \(u=g\) then \(G\) only allows test functions \(v\) so that in fact \(v-u\ge 0\). This means that we can't test the equation with both \(v-u\) and \(-(v-u)\) as above, and so we can no longer conclude that the two sides are in fact equal. Thus, this mimics the way we have discussed the complementarity condition above.</p>
<p><a class="anchor" id="Formulationasasaddlepointproblem"></a></p><h3>Formulation as a saddle point problem</h3>
<p>The variational inequality above is awkward to work with. We would therefore like to reformulate it as an equivalent saddle point problem. We introduce a Lagrange multiplier \(\lambda\) and the convex cone \(K\subset V&#39;\), \(V&#39;\) dual space of \(V\), \(K \dealcoloneq \{\mu\in V&#39;: \langle\mu,v\rangle\geq 0,\quad \forall v\in V, v \le 0 \}\) of Lagrange multipliers, where \(\langle\cdot,\cdot\rangle\) denotes the duality pairing between \(V&#39;\) and \(V\). Intuitively, \(K\) is the cone of all "non-positive
functions", except that \(K\subset (H_0^1)&#39;\) and so contains other objects besides regular functions as well. This yields:</p>
<p><em>Find \(u\in V\) and \(\lambda\in K\) such that</em> </p><p class="formulaDsp">
\begin{align*} a(u,v) + b(v,\lambda) &amp;= f(v),\quad &amp;&amp;v\in V\\ b(u,\mu - \lambda) &amp;\leq \langle g,\mu - \lambda\rangle,\quad&amp;&amp;\mu\in K, \end{align*}
</p>
<p> <em>with</em> </p><p class="formulaDsp">
\begin{align*} a(u,v) &amp;\dealcoloneq \left(\nabla u, \nabla v\right),\quad &amp;&amp;u,v\in V\\ b(u,\mu) &amp;\dealcoloneq \langle u,\mu\rangle,\quad &amp;&amp;u\in V,\quad\mu\in V&#39;. \end{align*}
</p>
<p> In other words, we can consider \(\lambda\) as the negative of the additional, positive force that the obstacle exerts on the membrane. The inequality in the second line of the statement above only appears to have the wrong sign because we have \(\mu-\lambda&lt;0\) at points where \(\lambda=0\), given the definition of \(K\).</p>
<p>The existence and uniqueness of \((u,\lambda)\in V\times K\) of this saddle point problem has been stated in Glowinski, Lions and Tr&eacute;moli&egrave;res: Numerical Analysis of Variational Inequalities, North-Holland, 1981.</p>
<p><a class="anchor" id="ActiveSetmethodstosolvethesaddlepointproblem"></a></p><h3>Active Set methods to solve the saddle point problem</h3>
<p>There are different methods to solve the variational inequality. As one possibility you can understand the saddle point problem as a convex quadratic program (QP) with inequality constraints.</p>
<p>To get there, let us assume that we discretize both \(u\) and \(\lambda\) with the same finite element space, for example the usual \(Q_k\) spaces. We would then get the equations </p><p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;[BU-G]_i \geq 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[BU-G]_i = 0 \qquad \forall i.&amp; \end{eqnarray*}
</p>
<p> where \(B\) is the mass matrix on the chosen finite element space and the indices \(i\) above are for all degrees of freedom in the set \(\cal S\) of degrees of freedom located in the interior of the domain (we have Dirichlet conditions on the perimeter). However, we can make our life simpler if we use a particular quadrature rule when assembling all terms that yield this mass matrix, namely a quadrature formula where quadrature points are only located at the interpolation points at which shape functions are defined; since all but one shape function are zero at these locations, we get a diagonal mass matrix with </p><p class="formulaDsp">
\begin{align*} B_{ii} = \int_\Omega \varphi_i(\mathbf x)^2\ \textrm{d}x, \qquad B_{ij}=0 \ \text{for } i\neq j. \end{align*}
</p>
<p> To define \(G\) we use the same technique as for \(B\). In other words, we define </p><p class="formulaDsp">
\begin{align*} G_{i} = \int_\Omega g_h(x) \varphi_i(\mathbf x)\ \textrm{d}x, \end{align*}
</p>
<p> where \(g_h\) is a suitable approximation of \(g\). The integral in the definition of \(B_{ii}\) and \(G_i\) are then approximated by the trapezoidal rule. With this, the equations above can be restated as </p><p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;U_i-B_{ii}^{-1}G_i \ge 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[U_i-B_{ii}^{-1}G_i] = 0 \qquad \forall i\in{\cal S}.&amp; \end{eqnarray*}
</p>
<p>Now we define for each degree of freedom \(i\) the function </p><p class="formulaDsp">
\begin{equation*} C([BU]_i,\Lambda_i) \dealcoloneq -\Lambda_i + \min\lbrace 0, \Lambda_i + c([BU]_i - G_i) \rbrace, \end{equation*}
</p>
<p> with some \(c&gt;0\). (In this program we choose \(c = 100\). It is a kind of a penalty parameter which depends on the problem itself and needs to be chosen large enough; for example there is no convergence for \(c = 1\) using the current program if we use 7 global refinements.)</p>
<p>After some head-scratching one can then convince oneself that the inequalities above can equivalently be rewritten as </p><p class="formulaDsp">
\begin{equation*} C([BU]_i,\Lambda_i) = 0, \qquad \forall i\in{\cal S}. \end{equation*}
</p>
<p> The primal-dual active set strategy we will use here is an iterative scheme which is based on this condition to predict the next active and inactive sets \(\mathcal{A}_k\) and \(\mathcal{F}_k\) (that is, those complementary sets of indices \(i\) for which \(U_i\) is either equal to or not equal to the value of the obstacle \(B^{-1}G\)). For a more in depth treatment of this approach, see Hintermueller, Ito, Kunisch: The primal-dual active set strategy as a semismooth newton method, SIAM J. OPTIM., 2003, Vol. 13, No. 3, pp. 865-888.</p>
<p><a class="anchor" id="Theprimaldualactivesetalgorithm"></a></p><h3>The primal-dual active set algorithm</h3>
<p>The algorithm for the primal-dual active set method works as follows (NOTE: \(B = B^T\)):</p>
<ol type="1">
<li>Initialize \(\mathcal{A}_k\) and \(\mathcal{F}_k\), such that \(\mathcal{S}=\mathcal{A}_k\cup\mathcal{F}_k\) and \(\mathcal{A}_k\cap\mathcal{F}_k=\emptyset\) and set \(k=1\).</li>
<li>Find the primal-dual pair \((U^k,\Lambda^k)\) that satisfies <p class="formulaDsp">
\begin{align*} AU^k + B\Lambda^k &amp;= F,\\ [BU^k]_i &amp;= G_i\quad&amp;&amp;\forall i\in\mathcal{A}_k,\\ \Lambda_i^k &amp;= 0\quad&amp;&amp;\forall i\in\mathcal{F}_k. \end{align*}
</p>
 Note that the second and third conditions imply that exactly \(|S|\) unknowns are fixed, with the first condition yielding the remaining \(|S|\) equations necessary to determine both \(U\) and \(\Lambda\).</li>
<li>Define the new active and inactive sets by <p class="formulaDsp">
\begin{equation*} \begin{split} \mathcal{A}_{k+1} \dealcoloneq \lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\rbrace,\\ \mathcal{F}_{k+1} \dealcoloneq \lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)\geq 0\rbrace. \end{split} \end{equation*}
</p>
</li>
<li>If \(\mathcal{A}_{k+1}=\mathcal{A}_k\) (and then, obviously, also \(\mathcal{F}_{k+1}=\mathcal{F}_k\)) then stop, else set \(k=k+1\) and go to step (2).</li>
</ol>
<p>The method is called "primal-dual" because it uses both primal (the displacement \(U\)) as well as dual variables (the Lagrange multiplier \(\Lambda\)) to determine the next active set.</p>
<p>At the end of this section, let us add two observations. First, for any primal-dual pair \((U^k,\Lambda^k)\) that satisfies these condition, we can distinguish the following cases:</p>
<ol type="1">
<li>\(\Lambda^k_i + c([BU^k]_i - G_i) &lt; 0\) (i active): <br />
 Then either \([BU^k]_i&lt;G_i\) and \(\Lambda^k_i=0\) (penetration) or \(\Lambda^k_i&lt;0\) and \([BU^k]_i=G_i\) (pressing load).</li>
<li>\(\Lambda^k_i + c([BU^k]_i - G_i)\geq 0\) (i inactive): <br />
 Then either \([BU^k]_i\geq G_i\) and \(\Lambda^k_i=0\) (no contact) or \(\Lambda^k_i\geq0\) and \([BU^k]_i=G_i\) (unpressing load).</li>
</ol>
<p>Second, the method above appears intuitively correct and useful but a bit ad hoc. However, it can be derived in a concisely in the following way. To this end, note that we'd like to solve the nonlinear system </p><p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;C([BU-G]_i, \Lambda_i) = 0, \qquad \forall i.&amp; \end{eqnarray*}
</p>
<p> We can iteratively solve this by always linearizing around the previous iterate (i.e., applying a Newton method), but for this we need to linearize the function \(C(\cdot,\cdot)\) that is not differentiable. That said, it is slantly differentiable, and in fact we have </p><p class="formulaDsp">
\begin{equation*} \dfrac{\partial}{\partial U^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} cB_{ii},&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}
</p>
 <p class="formulaDsp">
\begin{equation*} \dfrac{\partial}{\partial\Lambda^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ -1,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}
</p>
<p> This suggest a semismooth Newton step of the form </p><p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; -Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; cB_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} \delta U^k_{\mathcal{F}_k}\\ \delta U^k_{\mathcal{A}_k}\\ \delta \Lambda^k_{\mathcal{F}_k}\\ \delta \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = -\begin{pmatrix} (AU^k + \Lambda^k - F)_{\mathcal{F}_k}\\ (AU^k + \Lambda^k - F)_{\mathcal{A}_k}\\ -\Lambda^k_{\mathcal{F}_k}\\ c(B_{\mathcal{A}_k} U^k - G)_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}
</p>
<p> where we have split matrices \(A,B\) as well as vectors in the natural way into rows and columns whose indices belong to either the active set \({\mathcal{A}_k}\) or the inactive set \({\mathcal{F}_k}\).</p>
<p>Rather than solving for updates \(\delta U, \delta \Lambda\), we can also solve for the variables we are interested in right away by setting \(\delta U^k \dealcoloneq U^{k+1} - U^k\) and \(\delta \Lambda^k \dealcoloneq \Lambda^{k+1} - \Lambda^k\) and bringing all known terms to the right hand side. This yields </p><p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{F}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ 0\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
<p> These are the equations outlined above in the description of the basic algorithm.</p>
<p>We could even drive this a bit further. It's easy to see that we can eliminate the third row and the third column because it implies \(\Lambda_{\mathcal{F}_k} = 0\): </p><p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; B_{\mathcal{A}_k}\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
<p> This shows that one in fact only needs to solve for the Lagrange multipliers located on the active set. By considering the second row one would then recover the full Lagrange multiplier vector through </p><p class="formulaDsp">
\begin{equation*} \Lambda^k_S = B^{-1}\left(f_{\mathcal{S}} - A_{\mathcal{S}}U^k_{\mathcal{S}}\right). \end{equation*}
</p>
<p> Because of the third row and the fact that \(B_{\mathcal{A}_k}\) is a diagonal matrix we are able to calculate \(U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}\) directly. We can therefore also write the linear system as follows: </p><p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; 0\\ 0 &amp; Id_{\mathcal{A}_k} \\ \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k} - A_{\mathcal{F}_k\mathcal{A}_k}B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k} \\ B_{\mathcal{A}_k}^{-1}G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
<p> Fortunately, this form is easy to arrive at: we simply build the usual Laplace linear system </p><p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} \\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}
</p>
<p> and then let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class eliminate all constrained degrees of freedom, namely \(U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}\), in the same way as if the dofs in \(\mathcal{A}_k\) were Dirichlet data. The result linear system (the second to last one above) is symmetric and positive definite and we solve it with a CG-method and the AMG preconditioner from Trilinos.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>This tutorial is quite similar to <a class="el" href="step_4.html">step-4</a>. The general structure of the program follows <a class="el" href="step_4.html">step-4</a> with minor differences:</p><ul>
<li>We need two new methods, <code>assemble_mass_matrix_diagonal</code> and <code>update_solution_and_constraints</code>.</li>
<li>We need new member variables that denote the constraints we have here.</li>
<li>We change the preconditioner for the solver.</li>
</ul>
<p>You may want to read up on <a class="el" href="step_4.html">step-4</a> if you want to understand the current program.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As usual, at the beginning we include all the header files we need in here. With the exception of the various files that provide interfaces to the Trilinos library, there are no surprises:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeObstacleProblemcodeclasstemplate"></a> </p><h3>The <code>ObstacleProblem</code> class template</h3>
<p>This class supplies all function and variables needed to describe the obstacle problem. It is close to what we had to do in <a class="el" href="step_4.html">step-4</a>, and so relatively simple. The only real new components are the update_solution_and_constraints function that computes the active set and a number of variables that are necessary to describe the original (unconstrained) form of the linear system (<code>complete_system_matrix</code> and <code>complete_system_rhs</code>) as well as the active set itself and the diagonal of the mass matrix \(B\) used in scaling Lagrange multipliers in the active set formulation. The rest is as in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ObstacleProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ObstacleProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">       assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">  <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>                  active_set;</div><div class="line"></div><div class="line">  TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> complete_system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diagonal_of_mass_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> contact_force;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandtheobstacle"></a> </p><h3>Right hand side, boundary values, and the obstacle</h3>
<p>In the following, we define classes that describe the right hand side function, the Dirichlet boundary values, and the height of the obstacle as a function of \(\mathbf x\). In all three cases, we derive these classes from <a class="el" href="classFunction.html">Function</a>&lt;dim&gt;, although in the case of <code>RightHandSide</code> and <code>Obstacle</code> this is more out of convention than necessity since we never pass such objects to the library. In any case, the definition of the right hand side and boundary values classes is obvious given our choice of \(f=-10\), \(u|_{\partial\Omega}=0\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> -10;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>We describe the obstacle function by a cascaded barrier (think: stair steps):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (p(0) &lt; -0.5)</div><div class="line">      <span class="keywordflow">return</span> -0.2;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= -0.5 &amp;&amp; p(0) &lt; 0.0)</div><div class="line">      <span class="keywordflow">return</span> -0.4;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt; 0.5)</div><div class="line">      <span class="keywordflow">return</span> -0.6;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> -0.8;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeObstacleProblemcodeclass"></a> </p><h3>Implementation of the <code>ObstacleProblem</code> class</h3>
<p><a class="anchor" id="ObstacleProblemObstacleProblem"></a> </p><h4>ObstacleProblem::ObstacleProblem</h4>
<p>To everyone who has taken a look at the first few tutorial programs, the constructor is completely obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ObstacleProblem&lt;dim&gt;::ObstacleProblem()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemmake_grid"></a> </p><h4>ObstacleProblem::make_grid</h4>
<p>We solve our obstacle problem on the square \([-1,1]\times [-1,1]\) in 2D. This function therefore just sets up one of the simplest possible meshes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsetup_system"></a> </p><h4>ObstacleProblem::setup_system</h4>
<p>In this first function of note, we set up the degrees of freedom handler, resize vectors and matrices, and deal with the constraints. Initially, the constraints are, of course, only given by boundary values, so we interpolate them towards the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  active_set.set_size(dof_handler.n_dofs());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  system_matrix.reinit(dsp);</div><div class="line">  complete_system_matrix.reinit(dsp);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.locally_owned_dofs();</div><div class="line">  solution.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  contact_force.reinit(solution_index_set, MPI_COMM_WORLD);</div></div><!-- fragment --><p>The only other thing to do here is to compute the factors in the \(B\) matrix which is used to scale the residual. As discussed in the introduction, we'll use a little trick to make this mass matrix diagonal, and in the following then first compute all of this as a matrix and then extract the diagonal elements for later use:</p>
<div class="fragment"><div class="line">  TrilinosWrappers::SparseMatrix <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(dsp);</div><div class="line">  assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line">  diagonal_of_mass_matrix.reinit(solution_index_set);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; solution.size(); j++)</div><div class="line">    diagonal_of_mass_matrix(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_system"></a> </p><h4>ObstacleProblem::assemble_system</h4>
<p>This function at once assembles the system matrix and right-hand-side and applied the constraints (both due to the active set as well as from boundary values) to our system. Otherwise, it is functionally equivalent to the corresponding function in, for example, <a class="el" href="step_4.html">step-4</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree + 1);</div><div class="line">  RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">            cell_rhs(i) +=</div><div class="line">              (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">               right_hand_side.value(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point)) *</div><div class="line">               fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">          }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                             cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs,</div><div class="line">                                             <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_mass_matrix_diagonal"></a> </p><h4>ObstacleProblem::assemble_mass_matrix_diagonal</h4>
<p>The next function is used in the computation of the diagonal mass matrix \(B\) used to scale variables in the active set method. As discussed in the introduction, we get the mass matrix to be diagonal by choosing the trapezoidal rule for quadrature. Doing so we don't really need the triple loop over quadrature points, indices \(i\) and indices \(j\) any more and can, instead, just use a double loop. The rest of the function is obvious given what we have discussed in many of the previous tutorial programs.</p>
<p>Note that at the time this function is called, the constraints object only contains boundary value constraints; we therefore do not have to pay attention in the last copy-local-to-global step to preserve the values of matrix entries that may later on be constrained by the active set.</p>
<p>Note also that the trick with the trapezoidal rule only works if we have in fact \(Q_1\) elements. For higher order elements, one would need to use a quadrature formula that has quadrature points at all the support points of the finite element. Constructing such a quadrature formula isn't really difficult, but not the point here, and so we simply assert at the top of the function that our implicit assumption about the finite element is in fact satisfied.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">  TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a> quadrature_formula;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">            (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             mass_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemupdate_solution_and_constraints"></a> </p><h4>ObstacleProblem::update_solution_and_constraints</h4>
<p>In a sense, this is the central function of this program. It updates the active set of constrained degrees of freedom as discussed in the introduction and computes an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object from it that can then be used to eliminate constrained degrees of freedom from the solution of the next iteration. At the same time we set the constrained degrees of freedom of the solution to the correct value, namely the height of the obstacle.</p>
<p>Fundamentally, the function is rather simple: We have to loop over all degrees of freedom and check the sign of the function \(\Lambda^k_i + c([BU^k]_i - G_i) = \Lambda^k_i + cB_i(U^k_i - [g_h]_i)\) because in our case \(G_i = B_i[g_h]_i\). To this end, we use the formula given in the introduction by which we can compute the Lagrange multiplier as the residual of the original linear system (given via the variables <code>complete_system_matrix</code> and <code>complete_system_rhs</code>. At the top of this function, we compute this residual using a function that is part of the matrix classes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(</div><div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(dof_handler.n_dofs()));</div><div class="line">  complete_system_matrix.residual(lambda, solution, complete_system_rhs);</div></div><!-- fragment --><p>compute contact_force[i] = - lambda[i] * diagonal_of_mass_matrix[i]</p>
<div class="fragment"><div class="line">contact_force = lambda;</div><div class="line">contact_force.scale(diagonal_of_mass_matrix);</div><div class="line">contact_force *= -1;</div></div><!-- fragment --><p>The next step is to reset the active set and constraints objects and to start the loop over all degrees of freedom. This is made slightly more complicated by the fact that we can't just loop over all elements of the solution vector since there is no way for us then to find out what location a DoF is associated with; however, we need this location to test whether the displacement of a DoF is larger or smaller than the height of the obstacle at this location.</p>
<p>We work around this by looping over all cells and DoFs defined on each of these cells. We use here that the displacement is described using a \(Q_1\) function for which degrees of freedom are always located on the vertices of the cell; thus, we can get the index of each degree of freedom and its location by asking the vertex for this information. On the other hand, this clearly wouldn't work for higher order elements, and so we add an assertion that makes sure that we only deal with elements for which all degrees of freedom are located in vertices to avoid tripping ourselves with non-functional code in case someone wants to play with increasing the polynomial degree of the solution.</p>
<p>The price to pay for having to loop over cells rather than DoFs is that we may encounter some degrees of freedom more than once, namely each time we visit one of the cells adjacent to a given vertex. We will therefore have to keep track which vertices we have already touched and which we haven't so far. We do so by using an array of flags <code>dof_touched</code>:</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">active_set.clear();</div><div class="line"></div><div class="line"><span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">std::vector&lt;bool&gt;   dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dof_handler.get_fe().n_dofs_per_cell() == cell-&gt;n_vertices(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index(v, 0);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">        dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">continue</span>;</div></div><!-- fragment --><p>Now that we know that we haven't touched this DoF yet, let's get the value of the displacement function there as well as the value of the obstacle function and use this to decide whether the current DoF belongs to the active set. For that we use the function given above and in the introduction.</p>
<p>If we decide that the DoF should be part of the active set, we add its index to the active set, introduce an inhomogeneous equality constraint in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, and reset the solution value to the height of the obstacle. Finally, the residual of the non-contact part of the system serves as an additional control (the residual equals the remaining, unaccounted forces, and should be zero outside the contact zone), so we zero out the components of the residual vector (i.e., the Lagrange multiplier lambda) that correspond to the area where the body is in contact; at the end of the loop over all cells, the residual will therefore only consist of the residual in the non-contact zone. We output the norm of this residual along with the size of the active set after the loop.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value(cell-&gt;vertex(v));</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution(dof_index);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (lambda(dof_index) + penalty_parameter *</div><div class="line">                                diagonal_of_mass_matrix(dof_index) *</div><div class="line">                                (solution_value - obstacle_value) &lt;</div><div class="line">          0)</div><div class="line">        {</div><div class="line">          active_set.add_index(dof_index);</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a>(dof_index);</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a>(dof_index, obstacle_value);</div><div class="line"></div><div class="line">          solution(dof_index) = obstacle_value;</div><div class="line"></div><div class="line">          lambda(dof_index) = 0;</div><div class="line">        }</div><div class="line">    }</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">          &lt;&lt; lambda.l2_norm() &lt;&lt; std::endl;</div></div><!-- fragment --><p>In a final step, we add to the set of constraints on DoFs we have so far from the active set those that result from Dirichlet boundary values, and close the constraints object:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsolve"></a> </p><h4>ObstacleProblem::solve</h4>
<p>There is nothing to say really about the solve function. In the context of a Newton method, we are not typically interested in very high accuracy (why ask for a highly accurate solution of a linear problem that we know only gives us an approximation of the solution of the nonlinear problem), and so we use the <a class="el" href="classReductionControl.html">ReductionControl</a> class that stops iterations when either an absolute tolerance is reached (for which we choose \(10^{-12}\)) or when the residual is reduced by a certain factor (here, \(10^{-3}\)).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classReductionControl.html">ReductionControl</a>                        reduction_control(100, 1e-12, 1e-3);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(reduction_control);</div><div class="line">  TrilinosWrappers::PreconditionAMG       precondition;</div><div class="line">  precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, precondition);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">            &lt;&lt; reduction_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">            &lt;&lt; reduction_control.last_step() &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemoutput_results"></a> </p><h4>ObstacleProblem::output_results</h4>
<p>We use the vtk-format for the output. The file contains the displacement and a numerical representation of the active set.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(</div><div class="line">    dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">    active_set_vector[index] = 1.;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output_vtk(<span class="stringliteral">&quot;output_&quot;</span> +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iteration, 3) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output_vtk);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemrun"></a> </p><h4>ObstacleProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is not very long, and in fact rather straightforward: in every iteration of the active set method, we assemble the linear system, solve it, update the active set and project the solution back to the feasible set, and then output the results. The iteration is terminated whenever the active set has not changed in the previous iteration.</p>
<p>The only trickier part is that we have to save the linear system (i.e., the matrix and right hand side) after assembling it in the first iteration. The reason is that this is the only step where we can access the linear system as built without any of the contact constraints active. We need this to compute the residual of the solution at other iterations, but in other iterations that linear system we form has the rows and columns that correspond to constrained degrees of freedom eliminated, and so we can no longer access the full residual of the original equation.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ObstacleProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old(active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 0; iteration &lt;= solution.size(); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from(system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"></div><div class="line">        solve();</div><div class="line">        update_solution_and_constraints();</div><div class="line">        output_results(iteration);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        active_set_old = active_set;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step41</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>And this is the main function. It follows the pattern of all other main functions. The call to initialize MPI exists because the Trilinos library upon which we build our linear solvers in this program requires it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"></div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program produces output like this: </p><div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Total number of cells: 21845</div><div class="line">Number of degrees of freedom: 16641</div><div class="line"></div><div class="line">Newton iteration 0</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.310059 -&gt; 5.16619e-05 in 5 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 13164</div><div class="line">   Residual of the non-contact part of the system: 1.61863e-05</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line">Newton iteration 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 1.11987 -&gt; 0.00109377 in 6 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 12363</div><div class="line">   Residual of the non-contact part of the system: 3.9373</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Newton iteration 17</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.00713308 -&gt; 2.29249e-06 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 0.000957525</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line">Newton iteration 18</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.000957525 -&gt; 2.8033e-07 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 2.8033e-07</div><div class="line">   Writing graphical output...</div></div><!-- fragment --><p>The iterations end once the active set doesn't change any more (it has 5,399 constrained degrees of freedom at that point). The algebraic precondition is apparently working nicely since we only need 4-6 CG iterations to solve the linear system (although this also has a lot to do with the fact that we are not asking for very high accuracy of the linear solver).</p>
<p>More revealing is to look at a sequence of graphical output files (every third step is shown, with the number of the iteration in the leftmost column):</p>
<table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.00.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.03.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">6 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.06.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">9 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.09.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">12 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.12.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">15 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.15.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">18 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.18.png"/>
</div>
   </td></tr>
</table>
<p>The pictures show that in the first step, the solution (which has been computed without any of the constraints active) bends through so much that pretty much every interior point has to be bounced back to the stairstep function, producing a discontinuous solution. Over the course of the active set iterations, this unphysical membrane shape is smoothed out, the contact with the lower-most stair step disappears, and the solution stabilizes.</p>
<p>In addition to this, the program also outputs the values of the Lagrange multipliers. Remember that these are the contact forces and so should only be positive on the contact set, and zero outside. If, on the other hand, a Lagrange multiplier is negative in the active set, then this degree of freedom must be removed from the active set. The following pictures show the multipliers in iterations 1, 9 and 18, where we use red and browns to indicate positive values, and blue for negative values.</p>
<table align="center">
<tr>
<td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.01.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.18.png"/>
</div>
   </td></tr>
<tr>
<td align="center">Iteration 1  </td><td align="center">Iteration 9  </td><td align="center">Iteration 18   </td></tr>
</table>
<p>It is easy to see that the positive values converge nicely to moderate values in the interior of the contact set and large upward forces at the edges of the steps, as one would expect (to support the large curvature of the membrane there); at the fringes of the active set, multipliers are initially negative, causing the set to shrink until, in iteration 18, there are no more negative multipliers and the algorithm has converged.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>As with any of the programs of this tutorial, there are a number of obvious possibilities for extensions and experiments. The first one is clear: introduce adaptivity. Contact problems are prime candidates for adaptive meshes because the solution has lines along which it is less regular (the places where contact is established between membrane and obstacle) and other areas where the solution is very smooth (or, in the present context, constant wherever it is in contact with the obstacle). Adding this to the current program should not pose too many difficulties, but it is not trivial to find a good error estimator for that purpose.</p>
<p>A more challenging task would be an extension to 3d. The problem here is not so much to simply make everything run in 3d. Rather, it is that when a 3d body is deformed and gets into contact with an obstacle, then the obstacle does not act as a constraining body force within the domain as is the case here. Rather, the contact force only acts on the boundary of the object. The inequality then is not in the differential equation but in fact in the (Neumann-type) boundary conditions, though this leads to a similar kind of variational inequality. Mathematically, this means that the Lagrange multiplier only lives on the surface, though it can of course be extended by zero into the domain if that is convenient. As in the current program, one does not need to form and store this Lagrange multiplier explicitly.</p>
<p>A further interesting problem for the 3d case is to consider contact problems with friction. In almost every mechanical process friction has a big influence. For the modelling we have to take into account tangential stresses at the contact surface. Also we have to observe that friction adds another nonlinearity to our problem.</p>
<p>Another nontrivial modification is to implement a more complex constitutive law like nonlinear elasticity or elasto-plastic material behavior. The difficulty here is to handle the additional nonlinearity arising through the nonlinear constitutive law.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="comment"> *                        University of Siegen, 2011, 2012</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ObstacleProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ObstacleProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">    <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>                  active_set;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> complete_system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diagonal_of_mass_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> contact_force;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> -10;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (p(0) &lt; -0.5)</div><div class="line">        <span class="keywordflow">return</span> -0.2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= -0.5 &amp;&amp; p(0) &lt; 0.0)</div><div class="line">        <span class="keywordflow">return</span> -0.4;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt; 0.5)</div><div class="line">        <span class="keywordflow">return</span> -0.6;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> -0.8;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ObstacleProblem&lt;dim&gt;::ObstacleProblem()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line">    active_set.set_size(dof_handler.n_dofs());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    system_matrix.reinit(dsp);</div><div class="line">    complete_system_matrix.reinit(dsp);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.locally_owned_dofs();</div><div class="line">    solution.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    contact_force.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(dsp);</div><div class="line">    assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line">    diagonal_of_mass_matrix.reinit(solution_index_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; solution.size(); j++)</div><div class="line">      diagonal_of_mass_matrix(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree + 1);</div><div class="line">    RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell_rhs(i) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                 right_hand_side.value(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point)) *</div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a> quadrature_formula;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">              (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">               fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               mass_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(</div><div class="line">      <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(dof_handler.n_dofs()));</div><div class="line">    complete_system_matrix.residual(lambda, solution, complete_system_rhs);</div><div class="line"></div><div class="line">    contact_force = lambda;</div><div class="line">    contact_force.scale(diagonal_of_mass_matrix);</div><div class="line">    contact_force *= -1;</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    active_set.clear();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">    std::vector&lt;bool&gt;   dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dof_handler.get_fe().n_dofs_per_cell() == cell-&gt;n_vertices(),</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index(v, 0);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">            dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value(cell-&gt;vertex(v));</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution(dof_index);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (lambda(dof_index) + penalty_parameter *</div><div class="line">                                    diagonal_of_mass_matrix(dof_index) *</div><div class="line">                                    (solution_value - obstacle_value) &lt;</div><div class="line">              0)</div><div class="line">            {</div><div class="line">              active_set.add_index(dof_index);</div><div class="line">              constraints.<a class="code" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a>(dof_index);</div><div class="line">              constraints.<a class="code" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a>(dof_index, obstacle_value);</div><div class="line"></div><div class="line">              solution(dof_index) = obstacle_value;</div><div class="line"></div><div class="line">              lambda(dof_index) = 0;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">              &lt;&lt; lambda.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>                        reduction_control(100, 1e-12, 1e-3);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(reduction_control);</div><div class="line">    TrilinosWrappers::PreconditionAMG       precondition;</div><div class="line">    precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, precondition);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">              &lt;&lt; reduction_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">              &lt;&lt; reduction_control.last_step() &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(</div><div class="line">      dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">      active_set_vector[index] = 1.;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output_vtk(<span class="stringliteral">&quot;output_&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iteration, 3) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output_vtk);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ObstacleProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old(active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 0; iteration &lt;= solution.size(); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from(system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"></div><div class="line">        solve();</div><div class="line">        update_solution_and_constraints();</div><div class="line">        output_results(iteration);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        active_set_old = active_set;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step41</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"></div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Introduction">Introduction</a><a href="#Introduction">Introduction</a>
        <li><a href="#Classicalformulation">Classical formulation</a><a href="#Classicalformulation">Classical formulation</a>
        <li><a href="#Derivationofthevariationalinequality">Derivation of the variational inequality</a><a href="#Derivationofthevariationalinequality">Derivation of the variational inequality</a>
        <li><a href="#Formulationasasaddlepointproblem">Formulation as a saddle point problem</a><a href="#Formulationasasaddlepointproblem">Formulation as a saddle point problem</a>
        <li><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to solve the saddle point problem</a><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to solve the saddle point problem</a>
        <li><a href="#Theprimaldualactivesetalgorithm">The primal-dual active set algorithm</a><a href="#Theprimaldualactivesetalgorithm">The primal-dual active set algorithm</a>
        <li><a href="#Implementation">Implementation</a><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeObstacleProblemcodeclasstemplate">The <code>ObstacleProblem</code> class template</a><a href="#ThecodeObstacleProblemcodeclasstemplate">The <code>ObstacleProblem</code> class template</a>
        <li><a href="#Righthandsideboundaryvaluesandtheobstacle">Right hand side, boundary values, and the obstacle</a><a href="#Righthandsideboundaryvaluesandtheobstacle">Right hand side, boundary values, and the obstacle</a>
        <li><a href="#ImplementationofthecodeObstacleProblemcodeclass">Implementation of the <code>ObstacleProblem</code> class</a><a href="#ImplementationofthecodeObstacleProblemcodeclass">Implementation of the <code>ObstacleProblem</code> class</a>
      <ul>
        <li><a href="#ObstacleProblemObstacleProblem">ObstacleProblem::ObstacleProblem</a><a href="#ObstacleProblemObstacleProblem">ObstacleProblem::ObstacleProblem</a>
        <li><a href="#ObstacleProblemmake_grid">ObstacleProblem::make_grid</a><a href="#ObstacleProblemmake_grid">ObstacleProblem::make_grid</a>
        <li><a href="#ObstacleProblemsetup_system">ObstacleProblem::setup_system</a><a href="#ObstacleProblemsetup_system">ObstacleProblem::setup_system</a>
        <li><a href="#ObstacleProblemassemble_system">ObstacleProblem::assemble_system</a><a href="#ObstacleProblemassemble_system">ObstacleProblem::assemble_system</a>
        <li><a href="#ObstacleProblemassemble_mass_matrix_diagonal">ObstacleProblem::assemble_mass_matrix_diagonal</a><a href="#ObstacleProblemassemble_mass_matrix_diagonal">ObstacleProblem::assemble_mass_matrix_diagonal</a>
        <li><a href="#ObstacleProblemupdate_solution_and_constraints">ObstacleProblem::update_solution_and_constraints</a><a href="#ObstacleProblemupdate_solution_and_constraints">ObstacleProblem::update_solution_and_constraints</a>
        <li><a href="#ObstacleProblemsolve">ObstacleProblem::solve</a><a href="#ObstacleProblemsolve">ObstacleProblem::solve</a>
        <li><a href="#ObstacleProblemoutput_results">ObstacleProblem::output_results</a><a href="#ObstacleProblemoutput_results">ObstacleProblem::output_results</a>
        <li><a href="#ObstacleProblemrun">ObstacleProblem::run</a><a href="#ObstacleProblemrun">ObstacleProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em>This program was contributed by JÃ¶rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&amp;M University. <br />
 This material is based upon work partly supported by ThyssenKrupp Steel Europe. </em></p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h3>Introduction</h3>
<p>This example is based on the Laplace equation in 2d and deals with thequestion what happens if a membrane is deflected by some external force but isalso constrained by an obstacle. In other words, think of a elastic membraneclamped at the boundary to a rectangular frame (we choose \(\Omega = \left[-1,1\right]^2\) ) and that sags through due to gravity acting on it. Whathappens now if there is an obstacle under the membrane that prevents it fromreaching its equilibrium position if gravity was the only existing force? Inthe current example program, we will consider that under the membrane is astair step obstacle against which gravity pushes the membrane. This problem is typically called the "obstacle problem" (see also <a href="http://en.wikipedia.org/wiki/Obstacle_problem">this Wikipedia article</a>), and it results in avariational inequality, rather than a variational equation when put into theweak form. We will below derive it from the classical formulation, but before wego on to discuss the mathematics let us show how the solution of the problem wewill consider in this tutorial program looks to gain some intuition of whatwe should expect: </p><table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.png"/>
</div>
   </td></tr>
</table>
<p>Here, at the left, we see the displacement of the membrane. The shapeof the obstacle underneath is clearly visible. On the right, we overlay whichparts of the membrane are in contact with the obstacle. We will later callthis set of points the "active set" to indicate that an inequality constraintis active there.</p>
<p><a class="anchor" id="Classicalformulation"></a></p><h3>Classical formulation</h3>
<p>The classical formulation of the problem possesses the following form: </p><p class="formulaDsp">
\begin{align*} -\textrm{div}\ \sigma &amp;\geq f &amp; &amp;\quad\text{in } \Omega,\\ \sigma &amp;= \nabla u &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;= 0 &amp; &amp;\quad\text{on }\partial\Omega,\\ (-\Delta u - f)(u - g) &amp;= 0 &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;\geq g(\mathbf x) &amp; &amp;\quad\text{in } \Omega \end{align*}
</p>
<p> with \(u\in H^2(\Omega)\) . \(u\) is a scalar valued function that denotes thevertical displacement of the membrane. The first equation is called equilibriumcondition with a force of areal density \(f\) . Here, we will consider this forceto be gravity. The second one is known as Hooke's Law that says that the stresses \(\sigma\) are proportional to the gradient of the displacements \(u\) (theproportionality constant, often denoted by \(E\) , has been set to one here,without loss of generality; if it is constant, it can be put into the righthand side function). At the boundary we have zero Dirichletconditions. Obviously, the first two equations can be combined to yield \(-\Delta u \ge f\) . Intuitively, gravity acts downward and so \(f(\mathbf x)\) is a negativefunction (we choose \(f=-10\) in this program). The first condition then meansthat the total force acting on the membrane is gravity plus somethingpositive: namely the upward force that the obstacle exerts on the membrane atthose places where the two of them are in contact. How big is this additionalforce? We don't know yet (and neither do we know "where" it actually acts) butit must be so that the membrane doesn't penetrate the obstacle. The fourth equality above together with the last inequality forms the obstaclecondition which has to hold at every point of the whole domain. The latter ofthese two means that the membrane must be above the obstacle \(g(\mathbf x)\) everywhere. The second to last equation, often called the "complementaritycondition" says that where the membrane is not in contact with the obstacle(i.e., those \(\mathbf x\) where \(u(\mathbf x) - g(\mathbf x) \neq 0\) ), then \(-\Delta u=f\) at these locations; in other words, no additional forces actthere, as expected. On the other hand, where \(u=g\) we can have \(-\Delta u-f \neq 0\) , i.e., there can be additional forces (though there don't have to be:it is possible for the membrane to just touch, not press against, theobstacle).</p>
<p><a class="anchor" id="Derivationofthevariationalinequality"></a></p><h3>Derivation of the variational inequality</h3>
<p>An obvious way to obtain the variational formulation of the obstacle problem is to consider the total potential energy: </p><p class="formulaDsp">
\begin{equation*} E(u) \dealcoloneq \dfrac{1}{2}\int\limits_{\Omega} \nabla u \cdot \nabla u - \int\limits_{\Omega} fu. \end{equation*}
</p>
<p> We have to find a solution \(u\in G\) of the following minimization problem: </p><p class="formulaDsp">
\begin{equation*} E(u)\leq E(v)\quad \forall v\in G, \end{equation*}
</p>
<p> with the convex set of admissible displacements: </p><p class="formulaDsp">
\begin{equation*} G \dealcoloneq \lbrace v\in V: v\geq g \text{ a.e. in } \Omega\rbrace,\quad V\dealcoloneq H^1_0(\Omega). \end{equation*}
</p>
<p> This set takes care of the third and fifth conditions above (the boundaryvalues and the complementarity condition). Consider now the minimizer \(u\in G\) of \(E\) and any other function \(v\in G\) . Then the function </p><p class="formulaDsp">
\begin{equation*} F(\varepsilon) \dealcoloneq E(u+\varepsilon(v-u)),\quad\varepsilon\in\left[0,1\right], \end{equation*}
</p>
<p> takes its minimum at \(\varepsilon = 0\) (because \(u\) is a minimizer of theenergy functional \(E(\cdot)\) ), so that \(F&#39;(0)\geq 0\) for any choiceof \(v\) . Note that \(u+\varepsilon(v-u) = (1-\varepsilon)u+\varepsilon v\in G\) because of theconvexity of \(G\) . If we compute \(F&#39;(\varepsilon)\vert_{\varepsilon=0}\) ityields the variational formulation we are searching for: <em>Find a function \(u\in G\) with</em> </p><p class="formulaDsp">
\begin{equation*} \left(\nabla u, \nabla(v-u)\right) \geq \left(f,v-u\right) \quad \forall v\in G. \end{equation*}
</p>
<p>This is the typical form of variational inequalities, where not just \(v\) appears in the bilinear form but in fact \(v-u\) . The reason is this: if \(u\) isnot constrained, then we can find test functions \(v\) in \(G\) so that \(v-u\) can haveany sign. By choosing test functions \(v_1,v_2\) so that \(v_1-u = -(v_2-u)\) itfollows that the inequality can only hold for both \(v_1\) and \(v_2\) if the twosides are in fact equal, i.e., we obtain a variational equality. On the other hand, if \(u=g\) then \(G\) only allows test functions \(v\) so that in fact \(v-u\ge 0\) . This means that we can't test the equation with both \(v-u\) and \(-(v-u)\) as above, and so we can no longer conclude that the two sides are infact equal. Thus, this mimics the way we have discussed the complementaritycondition above.</p>
<p><a class="anchor" id="Formulationasasaddlepointproblem"></a></p><h3>Formulation as a saddle point problem</h3>
<p>The variational inequality above is awkward to work with. We would thereforelike to reformulate it as an equivalent saddle point problem. We introduce aLagrange multiplier \(\lambda\) and the convex cone \(K\subset V&#39;\) , \(V&#39;\) dual space of \(V\) , \(K \dealcoloneq \{\mu\in V&#39;: \langle\mu,v\rangle\geq 0,\quad \forall v\in V, v \le 0 \}\) ofLagrange multipliers, where \(\langle\cdot,\cdot\rangle\) denotes the dualitypairing between \(V&#39;\) and \(V\) . Intuitively, \(K\) is the cone of all "non-positivefunctions", except that \(K\subset (H_0^1)&#39;\) and so contains other objectsbesides regular functions as well.This yields: <em>Find \(u\in V\) and \(\lambda\in K\) such that</em> </p><p class="formulaDsp">
\begin{align*} a(u,v) + b(v,\lambda) &amp;= f(v),\quad &amp;&amp;v\in V\\ b(u,\mu - \lambda) &amp;\leq \langle g,\mu - \lambda\rangle,\quad&amp;&amp;\mu\in K, \end{align*}
</p>
<p> <em>with</em> </p><p class="formulaDsp">
\begin{align*} a(u,v) &amp;\dealcoloneq \left(\nabla u, \nabla v\right),\quad &amp;&amp;u,v\in V\\ b(u,\mu) &amp;\dealcoloneq \langle u,\mu\rangle,\quad &amp;&amp;u\in V,\quad\mu\in V&#39;. \end{align*}
</p>
<p> In other words, we can consider \(\lambda\) as the negative of the additional, positive force that theobstacle exerts on the membrane. The inequality in the second line of thestatement above only appears to have the wrong sign because we have \(\mu-\lambda&lt;0\) at points where \(\lambda=0\) , given the definition of \(K\) . The existence and uniqueness of \((u,\lambda)\in V\times K\) of this saddlepoint problem has been stated in Glowinski, Lions and Tr&eacute;moli&egrave;res: Numerical Analysis of VariationalInequalities, North-Holland, 1981.</p>
<p><a class="anchor" id="ActiveSetmethodstosolvethesaddlepointproblem"></a></p><h3>Active Set methods to solve the saddle point problem</h3>
<p>There are different methods to solve the variational inequality. As onepossibility you can understand the saddle point problem as a convex quadratic program (QP) withinequality constraints. To get there, let us assume that we discretize both \(u\) and \(\lambda\) with thesame finite element space, for example the usual \(Q_k\) spaces. We would thenget the equations </p><p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;[BU-G]_i \geq 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[BU-G]_i = 0 \qquad \forall i.&amp; \end{eqnarray*}
</p>
<p> where \(B\) is the mass matrix on the chosen finite element space and theindices \(i\) above are for all degrees of freedom in the set \(\cal S\) of degrees offreedom located in the interior of the domain(we have Dirichlet conditions on the perimeter). However, wecan make our life simpler if we use a particular quadrature rule whenassembling all terms that yield this mass matrix, namely a quadrature formulawhere quadrature points are only located at the interpolation points atwhich shape functions are defined; since all but one shape function are zeroat these locations, we get a diagonal mass matrix with </p><p class="formulaDsp">
\begin{align*} B_{ii} = \int_\Omega \varphi_i(\mathbf x)^2\ \textrm{d}x, \qquad B_{ij}=0 \ \text{for } i\neq j. \end{align*}
</p>
<p> To define \(G\) we use the same technique as for \(B\) . In other words, wedefine </p><p class="formulaDsp">
\begin{align*} G_{i} = \int_\Omega g_h(x) \varphi_i(\mathbf x)\ \textrm{d}x, \end{align*}
</p>
<p> where \(g_h\) is a suitable approximation of \(g\) . The integral in the definitionof \(B_{ii}\) and \(G_i\) are then approximated by the trapezoidal rule.With this, the equations above can be restated as </p><p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;U_i-B_{ii}^{-1}G_i \ge 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[U_i-B_{ii}^{-1}G_i] = 0 \qquad \forall i\in{\cal S}.&amp; \end{eqnarray*}
</p>
<p>Now we define for each degree of freedom \(i\) the function </p><p class="formulaDsp">
\begin{equation*} C([BU]_i,\Lambda_i) \dealcoloneq -\Lambda_i + \min\lbrace 0, \Lambda_i + c([BU]_i - G_i) \rbrace, \end{equation*}
</p>
<p> with some \(c&gt;0\) . (In this program we choose \(c = 100\) . It is a kind of apenalty parameter which depends on the problem itself and needs to be chosenlarge enough; for example there is no convergence for \(c = 1\) using thecurrent program if we use 7 global refinements.) After some head-scratching one can then convince oneself that the inequalitiesabove can equivalently be rewritten as </p><p class="formulaDsp">
\begin{equation*} C([BU]_i,\Lambda_i) = 0, \qquad \forall i\in{\cal S}. \end{equation*}
</p>
<p> The primal-dual active set strategy we will use here is an iterative scheme which is based onthis condition to predict the next active and inactive sets \(\mathcal{A}_k\) and \(\mathcal{F}_k\) (that is, those complementary sets of indices \(i\) for which \(U_i\) is either equal to or not equal to the value of the obstacle \(B^{-1}G\) ). For a more in depth treatment of this approach, see Hintermueller, Ito, Kunisch: The primal-dual active setstrategy as a semismooth newton method, SIAM J. OPTIM., 2003, Vol. 13, No. 3,pp. 865-888. <a class="anchor" id="Theprimaldualactivesetalgorithm"></a></p><h3>The primal-dual active set algorithm</h3>
<p>The algorithm for the primal-dual active set method works as follows (NOTE: \(B = B^T\) ):</p><ol type="1">
<li>Initialize \(\mathcal{A}_k\) and \(\mathcal{F}_k\) , such that \(\mathcal{S}=\mathcal{A}_k\cup\mathcal{F}_k\) and \(\mathcal{A}_k\cap\mathcal{F}_k=\emptyset\) and set \(k=1\) .2. Find the primal-dual pair \((U^k,\Lambda^k)\) that satisfies</li>
</ol>
<p class="formulaDsp">
\begin{align*} AU^k + B\Lambda^k &amp;= F,\\ [BU^k]_i &amp;= G_i\quad&amp;&amp;\forall i\in\mathcal{A}_k,\\ \Lambda_i^k &amp;= 0\quad&amp;&amp;\forall i\in\mathcal{F}_k. \end{align*}
</p>
<p> Note that the second and third conditions imply that exactly \(|S|\) unknowns are fixed, with the first condition yielding the remaining \(|S|\) equations necessary to determine both \(U\) and \(\Lambda\) .3. Define the new active and inactive sets by </p><p class="formulaDsp">
\begin{equation*} \begin{split} \mathcal{A}_{k+1} \dealcoloneq \lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\rbrace,\\ \mathcal{F}_{k+1} \dealcoloneq \lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)\geq 0\rbrace. \end{split} \end{equation*}
</p>
<ol type="1">
<li>If \(\mathcal{A}_{k+1}=\mathcal{A}_k\) (and then, obviously, also \(\mathcal{F}_{k+1}=\mathcal{F}_k\) ) then stop, else set \(k=k+1\) and go to step (2). The method is called "primal-dual" because it uses both primal (thedisplacement \(U\) ) as well as dual variables (the Lagrange multiplier \(\Lambda\) ) to determine the next active set. At the end of this section, let us add two observations. First,for any primal-dual pair \((U^k,\Lambda^k)\) that satisfies thesecondition, we can distinguish the following cases:</li>
</ol>
<ol type="1">
<li>\(\Lambda^k_i + c([BU^k]_i - G_i) &lt; 0\) (i active): <br />
 Then either \([BU^k]_i&lt;G_i\) and \(\Lambda^k_i=0\) (penetration) or \(\Lambda^k_i&lt;0\) and \([BU^k]_i=G_i\) (pressing load).2. \(\Lambda^k_i + c([BU^k]_i - G_i)\geq 0\) (i inactive): <br />
 Then either \([BU^k]_i\geq G_i\) and \(\Lambda^k_i=0\) (no contact) or \(\Lambda^k_i\geq0\) and \([BU^k]_i=G_i\) (unpressing load). Second, the method above appears intuitively correct and useful but a bit adhoc. However, it can be derived in a concisely in the following way. To thisend, note that we'd like to solve the nonlinear system <p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;C([BU-G]_i, \Lambda_i) = 0, \qquad \forall i.&amp; \end{eqnarray*}
</p>
 We can iteratively solve this by always linearizing around the previousiterate (i.e., applying a Newton method), but for this we need to linearizethe function \(C(\cdot,\cdot)\) that is not differentiable. That said, it isslantly differentiable, and in fact we have <p class="formulaDsp">
\begin{equation*} \dfrac{\partial}{\partial U^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} cB_{ii},&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}
</p>
 <p class="formulaDsp">
\begin{equation*} \dfrac{\partial}{\partial\Lambda^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ -1,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}
</p>
 This suggest a semismooth Newton step of the form <p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; -Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; cB_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} \delta U^k_{\mathcal{F}_k}\\ \delta U^k_{\mathcal{A}_k}\\ \delta \Lambda^k_{\mathcal{F}_k}\\ \delta \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = -\begin{pmatrix} (AU^k + \Lambda^k - F)_{\mathcal{F}_k}\\ (AU^k + \Lambda^k - F)_{\mathcal{A}_k}\\ -\Lambda^k_{\mathcal{F}_k}\\ c(B_{\mathcal{A}_k} U^k - G)_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}
</p>
 where we have split matrices \(A,B\) as well as vectors in the natural way intorows and columns whose indices belong to either the active set \({\mathcal{A}_k}\) or the inactive set \({\mathcal{F}_k}\) . Rather than solving for updates \(\delta U, \delta \Lambda\) , we can also solvefor the variables we are interested in right away by setting \(\delta U^k \dealcoloneq U^{k+1} - U^k\) and \(\delta \Lambda^k \dealcoloneq \Lambda^{k+1} - \Lambda^k\) andbringing all known terms to the right hand side. This yields <p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{F}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ 0\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
 These are the equations outlined above in the description of the basic algorithm. We could even drive this a bit further.It's easy to see that we can eliminate the third row and the third columnbecause it implies \(\Lambda_{\mathcal{F}_k} = 0\) : <p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; B_{\mathcal{A}_k}\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
 This shows that one in fact only needs to solve for the Lagrange multiplierslocated on the active set. By considering the second row one would then recoverthe full Lagrange multiplier vector through <p class="formulaDsp">
\begin{equation*} \Lambda^k_S = B^{-1}\left(f_{\mathcal{S}} - A_{\mathcal{S}}U^k_{\mathcal{S}}\right). \end{equation*}
</p>
 Because of the third row and the fact that \(B_{\mathcal{A}_k}\) is a diagonal matrix we are ableto calculate \(U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}\) directly. We can therefore also write thelinear system as follows: <p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; 0\\ 0 &amp; Id_{\mathcal{A}_k} \\ \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k} - A_{\mathcal{F}_k\mathcal{A}_k}B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k} \\ B_{\mathcal{A}_k}^{-1}G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
 Fortunately, this form is easy to arrive at: we simply build the usual Laplacelinear system <p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} \\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}
</p>
 and then let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class eliminate all constrained degrees offreedom, namely \(U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}\) ,in the same way as if the dofs in \(\mathcal{A}_k\) were Dirichlet data. Theresult linear system (the second to last one above) is symmetric and positivedefinite and we solve it with a CG-methodand the AMG preconditioner from Trilinos.</li>
</ol>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>This tutorial is quite similar to <a class="el" href="step_4.html">step-4</a> . The general structure of the programfollows <a class="el" href="step_4.html">step-4</a> with minor differences:</p>
<ul>
<li>We need two new methods, <code>assemble_mass_matrix_diagonal</code> and <code>update_solution_and_constraints</code> .</li>
<li>We need new member variables that denote the constraints we have here.</li>
<li>We change the preconditioner for the solver.</li>
</ul>
<p>You may want to read up on <a class="el" href="step_4.html">step-4</a> if you want to understand thecurrent program.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As usual, at the beginning we include all the header files we need in here. With the exception of the various files that provide interfaces to the Trilinos library, there are no surprises:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeObstacleProblemcodeclasstemplate"></a> </p><h3>The <code>ObstacleProblem</code> class template</h3>
<p>This class supplies all function and variables needed to describe the obstacle problem. It is close to what we had to do in <a class="el" href="step_4.html">step-4</a> , and so relatively simple. The only real new components are the update_solution_and_constraints function that computes the active set and a number of variables that are necessary to describe the original (unconstrained) form of the linear system ( <code>complete_system_matrix</code> and <code>complete_system_rhs</code> ) as well as the active set itself and the diagonal of the mass matrix \(B\) used in scaling Lagrange multipliers in the active set formulation. The rest is as in <a class="el" href="step_4.html">step-4</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ObstacleProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ObstacleProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">       assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">  <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>                  active_set;</div><div class="line"></div><div class="line">  TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> complete_system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diagonal_of_mass_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> contact_force;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandtheobstacle"></a> </p><h3>Right hand side, boundary values, and the obstacle</h3>
<p>In the following, we define classes that describe the right hand side function, the Dirichlet boundary values, and the height of the obstacle as a function of \(\mathbf x\) . In all three cases, we derive these classes from <a class="el" href="classFunction.html">Function</a> &lt;dim&gt;, although in the case of <code>RightHandSide</code> and <code>Obstacle</code> this is more out of convention than necessity since we never pass such objects to the library. In any case, the definition of the right hand side and boundary values classes is obvious given our choice of \(f=-10\) , \(u|_{\partial\Omega}=0\) :</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       (void)component;</div><div class="line">       <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  </div><div class="line">       <span class="keywordflow">return</span></div><div class="line">  </div><div class="line">-10;</div><div class="line">     }</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       (void)component;</div><div class="line">       <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  </div><div class="line">       <span class="keywordflow">return</span> 0;</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p>We describe the obstacle function by a cascaded barrier (think: stair steps):</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       (void)component;</div><div class="line">       <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  </div><div class="line">       <span class="keywordflow">if</span> (p(0) &lt;</div><div class="line">  </div><div class="line">-0.5)</div><div class="line">         <span class="keywordflow">return</span></div><div class="line">  </div><div class="line">-0.2;</div><div class="line">       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;=</div><div class="line">  </div><div class="line">-0.5 &amp;&amp; p(0) &lt; 0.0)</div><div class="line">         <span class="keywordflow">return</span></div><div class="line">  </div><div class="line">-0.4;</div><div class="line">       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt; 0.5)</div><div class="line">         <span class="keywordflow">return</span></div><div class="line">  </div><div class="line">-0.6;</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">         <span class="keywordflow">return</span></div><div class="line">  </div><div class="line">-0.8;</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeObstacleProblemcodeclass"></a> </p><h3>Implementation of the <code>ObstacleProblem</code> class</h3>
<p><a class="anchor" id="ObstacleProblemObstacleProblem"></a> </p><h4>ObstacleProblem::ObstacleProblem</h4>
<p>To everyone who has taken a look at the first few tutorial programs, the constructor is completely obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ObstacleProblem&lt;dim&gt;::ObstacleProblem()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemmake_grid"></a> </p><h4>ObstacleProblem::make_grid</h4>
<p>We solve our obstacle problem on the square \([-1,1]\times [-1,1]\) in 2D. This function therefore just sets up one of the simplest possible meshes.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid()</div><div class="line">   {</div><div class="line">     <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation,</div><div class="line">  </div><div class="line">-1, 1);</div><div class="line">     triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line">  </div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">               &lt;&lt; std::endl</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">               &lt;&lt; std::endl;</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsetup_system"></a> </p><h4>ObstacleProblem::setup_system</h4>
<p>In this first function of note, we set up the degrees of freedom handler, resize vectors and matrices, and deal with the constraints. Initially, the constraints are, of course, only given by boundary values, so we interpolate them towards the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  active_set.set_size(dof_handler.n_dofs());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  system_matrix.reinit(dsp);</div><div class="line">  complete_system_matrix.reinit(dsp);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.locally_owned_dofs();</div><div class="line">  solution.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  contact_force.reinit(solution_index_set, MPI_COMM_WORLD);</div></div><!-- fragment --><p>The only other thing to do here is to compute the factors in the \(B\) matrix which is used to scale the residual. As discussed in the introduction, we'll use a little trick to make this mass matrix diagonal, and in the following then first compute all of this as a matrix and then extract the diagonal elements for later use:</p>
<div class="fragment"><div class="line">  TrilinosWrappers::SparseMatrix <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(dsp);</div><div class="line">  assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line">  diagonal_of_mass_matrix.reinit(solution_index_set);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; solution.size(); j++)</div><div class="line">    diagonal_of_mass_matrix(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_system"></a> </p><h4>ObstacleProblem::assemble_system</h4>
<p>This function at once assembles the system matrix and right-hand-side and applied the constraints (both due to the active set as well as from boundary values) to our system. Otherwise, it is functionally equivalent to the corresponding function in, for example, <a class="el" href="step_4.html">step-4</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree + 1);</div><div class="line">  RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point)</div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">            cell_rhs(i) +=</div><div class="line">              (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">               right_hand_side.value(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point))</div><div class="line">               fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">          }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                             cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs,</div><div class="line">                                             <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_mass_matrix_diagonal"></a> </p><h4>ObstacleProblem::assemble_mass_matrix_diagonal</h4>
<p>The next function is used in the computation of the diagonal mass matrix \(B\) used to scale variables in the active set method. As discussed in the introduction, we get the mass matrix to be diagonal by choosing the trapezoidal rule for quadrature. Doing so we don't really need the triple loop over quadrature points, indices \(i\) and indices \(j\) any more and can, instead, just use a double loop. The rest of the function is obvious given what we have discussed in many of the previous tutorial programs. Note that at the time this function is called, the constraints object only contains boundary value constraints; we therefore do not have to pay attention in the last copy-local-to-global step to preserve the values of matrix entries that may later on be constrained by the active set. Note also that the trick with the trapezoidal rule only works if we have in fact \(Q_1\) elements. For higher order elements, one would need to use a quadrature formula that has quadrature points at all the support points of the finite element. Constructing such a quadrature formula isn't really difficult, but not the point here, and so we simply assert at the top of the function that our implicit assumption about the finite element is in fact satisfied.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">  TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a> quadrature_formula;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">            (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             mass_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemupdate_solution_and_constraints"></a> </p><h4>ObstacleProblem::update_solution_and_constraints</h4>
<p>In a sense, this is the central function of this program. It updates the active set of constrained degrees of freedom as discussed in the introduction and computes an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object from it that can then be used to eliminate constrained degrees of freedom from the solution of the next iteration. At the same time we set the constrained degrees of freedom of the solution to the correct value, namely the height of the obstacle. Fundamentally, the function is rather simple: We have to loop over all degrees of freedom and check the sign of the function \(\Lambda^k_i + c([BU^k]_i - G_i) = \Lambda^k_i + cB_i(U^k_i - [g_h]_i)\) because in our case \(G_i = B_i[g_h]_i\) . To this end, we use the formula given in the introduction by which we can compute the Lagrange multiplier as the residual of the original linear system (given via the variables <code>complete_system_matrix</code> and <code>complete_system_rhs</code> . At the top of this function, we compute this residual using a function that is part of the matrix classes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(</div><div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(dof_handler.n_dofs()));</div><div class="line">  complete_system_matrix.residual(lambda, solution, complete_system_rhs);</div></div><!-- fragment --><p>compute contact_force[i] =</p>
<ul>
<li>lambda[i] diagonal_of_mass_matrix[i]</li>
</ul>
<div class="fragment"><div class="line">     contact_force = lambda;</div><div class="line">     contact_force.scale(diagonal_of_mass_matrix);</div><div class="line">     contact_force=</div><div class="line">  </div><div class="line">-1;</div></div><!-- fragment --><p>The next step is to reset the active set and constraints objects and to start the loop over all degrees of freedom. This is made slightly more complicated by the fact that we can't just loop over all elements of the solution vector since there is no way for us then to find out what location a DoF is associated with; however, we need this location to test whether the displacement of a DoF is larger or smaller than the height of the obstacle at this location. We work around this by looping over all cells and DoFs defined on each of these cells. We use here that the displacement is described using a \(Q_1\) function for which degrees of freedom are always located on the vertices of the cell; thus, we can get the index of each degree of freedom and its location by asking the vertex for this information. On the other hand, this clearly wouldn't work for higher order elements, and so we add an assertion that makes sure that we only deal with elements for which all degrees of freedom are located in vertices to avoid tripping ourselves with non-functional code in case someone wants to play with increasing the polynomial degree of the solution. The price to pay for having to loop over cells rather than DoFs is that we may encounter some degrees of freedom more than once, namely each time we visit one of the cells adjacent to a given vertex. We will therefore have to keep track which vertices we have already touched and which we haven't so far. We do so by using an array of flags <code>dof_touched</code> :</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">active_set.clear();</div><div class="line"></div><div class="line"><span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">std::vector&lt;bool&gt;   dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dof_handler.get_fe().n_dofs_per_cell() == cell-&gt;n_vertices(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index(v, 0);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">        dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">continue</span>;</div></div><!-- fragment --><p>Now that we know that we haven't touched this DoF yet, let's get the value of the displacement function there as well as the value of the obstacle function and use this to decide whether the current DoF belongs to the active set. For that we use the function given above and in the introduction. If we decide that the DoF should be part of the active set, we add its index to the active set, introduce an inhomogeneous equality constraint in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, and reset the solution value to the height of the obstacle. Finally, the residual of the non-contact part of the system serves as an additional control (the residual equals the remaining, unaccounted forces, and should be zero outside the contact zone), so we zero out the components of the residual vector (i.e., the Lagrange multiplier lambda) that correspond to the area where the body is in contact; at the end of the loop over all cells, the residual will therefore only consist of the residual in the non-contact zone. We output the norm of this residual along with the size of the active set after the loop.</p>
<div class="fragment"><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value(cell-&gt;vertex(v));</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution(dof_index);</div><div class="line">  </div><div class="line">           <span class="keywordflow">if</span> (lambda(dof_index) + penalty_parameter</div><div class="line">                                     diagonal_of_mass_matrix(dof_index)</div><div class="line">                                     (solution_value</div><div class="line">  </div><div class="line">- obstacle_value) &lt;</div><div class="line">               0)</div><div class="line">             {</div><div class="line">               active_set.add_index(dof_index);</div><div class="line">               constraints.<a class="code" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a>(dof_index);</div><div class="line">               constraints.<a class="code" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a>(dof_index, obstacle_value);</div><div class="line">  </div><div class="line">               solution(dof_index) = obstacle_value;</div><div class="line">  </div><div class="line">               lambda(dof_index) = 0;</div><div class="line">             }</div><div class="line">         }</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">               &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">               &lt;&lt; lambda.l2_norm() &lt;&lt; std::endl;</div></div><!-- fragment --><p>In a final step, we add to the set of constraints on DoFs we have so far from the active set those that result from Dirichlet boundary values, and close the constraints object:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsolve"></a> </p><h4>ObstacleProblem::solve</h4>
<p>There is nothing to say really about the solve function. In the context of a Newton method, we are not typically interested in very high accuracy (why ask for a highly accurate solution of a linear problem that we know only gives us an approximation of the solution of the nonlinear problem), and so we use the <a class="el" href="classReductionControl.html">ReductionControl</a> class that stops iterations when either an absolute tolerance is reached (for which we choose \(10^{-12}\) ) or when the residual is reduced by a certain factor (here, \(10^{-3}\) ).</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve()</div><div class="line">   {</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">     <a class="code" href="classReductionControl.html">ReductionControl</a>                        reduction_control(100, 1e-12, 1e-3);</div><div class="line">     <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(reduction_control);</div><div class="line">     TrilinosWrappers::PreconditionAMG       precondition;</div><div class="line">     precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(system_matrix);</div><div class="line">  </div><div class="line">     solver.solve(system_matrix, solution, system_rhs, precondition);</div><div class="line">     constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  </div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value() &lt;&lt; <span class="stringliteral">&quot;</span></div><div class="line"><span class="stringliteral">  </span></div><div class="line"><span class="stringliteral">-&gt; &quot;</span></div><div class="line">               &lt;&lt; reduction_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">               &lt;&lt; reduction_control.last_step() &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">               &lt;&lt; std::endl;</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemoutput_results"></a> </p><h4>ObstacleProblem::output_results</h4>
<p>We use the vtk-format for the output. The file contains the displacement and a numerical representation of the active set.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(</div><div class="line">    dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">    active_set_vector[index] = 1.;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output_vtk(<span class="stringliteral">&quot;output_&quot;</span> +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iteration, 3) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output_vtk);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemrun"></a> </p><h4>ObstacleProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is not very long, and in fact rather straightforward: in every iteration of the active set method, we assemble the linear system, solve it, update the active set and project the solution back to the feasible set, and then output the results. The iteration is terminated whenever the active set has not changed in the previous iteration. The only trickier part is that we have to save the linear system (i.e., the matrix and right hand side) after assembling it in the first iteration. The reason is that this is the only step where we can access the linear system as built without any of the contact constraints active. We need this to compute the residual of the solution at other iterations, but in other iterations that linear system we form has the rows and columns that correspond to constrained degrees of freedom eliminated, and so we can no longer access the full residual of the original equation.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ObstacleProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line"> </div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old(active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 0; iteration &lt;= solution.size(); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        assemble_system();</div><div class="line"> </div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from(system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"> </div><div class="line">        solve();</div><div class="line">        update_solution_and_constraints();</div><div class="line">        output_results(iteration);</div><div class="line"> </div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"> </div><div class="line">        active_set_old = active_set;</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step41</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>And this is the main function. It follows the pattern of all other main functions. The call to initialize MPI exists because the Trilinos library upon which we build our linear solvers in this program requires it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"> </div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"> </div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program produces output like this: </p><div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Total number of cells: 21845</div><div class="line">Number of degrees of freedom: 16641</div><div class="line">  </div><div class="line">Newton iteration 0</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.310059</div><div class="line">  </div><div class="line">-&gt; 5.16619e-05 in 5 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 13164</div><div class="line">   Residual of the non-contact part of the system: 1.61863e-05</div><div class="line">   Writing graphical output...</div><div class="line">  </div><div class="line">Newton iteration 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 1.11987</div><div class="line">  </div><div class="line">-&gt; 0.00109377 in 6 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 12363</div><div class="line">   Residual of the non-contact part of the system: 3.9373</div><div class="line">   Writing graphical output...</div><div class="line">  </div><div class="line">...</div><div class="line">  </div><div class="line">Newton iteration 17</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.00713308</div><div class="line">  </div><div class="line">-&gt; 2.29249e-06 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 0.000957525</div><div class="line">   Writing graphical output...</div><div class="line">  </div><div class="line">Newton iteration 18</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.000957525</div><div class="line">  </div><div class="line">-&gt; 2.8033e-07 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 2.8033e-07</div><div class="line">   Writing graphical output...</div></div><!-- fragment --><p>The iterations end once the active set doesn't change any more (it has5,399 constrained degrees of freedom at that point). The algebraicprecondition is apparently working nicely since we only need 4-6 CGiterations to solve the linear system (although this also has a lot todo with the fact that we are not asking for very high accuracy of thelinear solver). More revealing is to look at a sequence of graphical output files(every third step is shown, with the number of the iteration in theleftmost column): </p><table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.00.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.03.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">6 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.06.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">9 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.09.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">12 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.12.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">15 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.15.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">18 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.18.png"/>
</div>
   </td></tr>
</table>
<p>The pictures show that in the first step, the solution (which has beencomputed without any of the constraints active) bends through so muchthat pretty much every interior point has to be bounced back to thestairstep function, producing a discontinuous solution. Over thecourse of the active set iterations, this unphysical membrane shape issmoothed out, the contact with the lower-most stair step disappears,and the solution stabilizes. In addition to this, the program also outputs the values of theLagrange multipliers. Remember that these are the contact forces andso should only be positive on the contact set, and zero outside. If,on the other hand, a Lagrange multiplier is negative in the activeset, then this degree of freedom must be removed from the activeset. The following pictures show the multipliers in iterations 1, 9and 18, where we use red and browns to indicate positive values, andblue for negative values. </p><table align="center">
<tr>
<td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.01.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.18.png"/>
</div>
   </td></tr>
<tr>
<td align="center">Iteration 1  </td><td align="center">Iteration 9  </td><td align="center">Iteration 18   </td></tr>
</table>
<p>It is easy to see that the positive values converge nicely to moderatevalues in the interior of the contact set and large upward forces atthe edges of the steps, as one would expect (to support the largecurvature of the membrane there); at the fringes of the active set,multipliers are initially negative, causing the set to shrink until,in iteration 18, there are no more negative multipliers and thealgorithm has converged.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>As with any of the programs of this tutorial, there are a number ofobvious possibilities for extensions and experiments. The first one isclear: introduce adaptivity. Contact problems are prime candidates foradaptive meshes because the solution has lines along which it is lessregular (the places where contact is established between membrane andobstacle) and other areas where the solution is very smooth (or, inthe present context, constant wherever it is in contact with theobstacle). Adding this to the current program should not pose too manydifficulties, but it is not trivial to find a good error estimator forthat purpose. A more challenging task would be an extension to 3d. The problem hereis not so much to simply make everything run in 3d. Rather, it is thatwhen a 3d body is deformed and gets into contact with an obstacle,then the obstacle does not act as a constraining body force within thedomain as is the case here. Rather, the contact force only acts on theboundary of the object. The inequality then is not in the differentialequation but in fact in the (Neumann-type) boundary conditions, thoughthis leads to a similar kind of variationalinequality. Mathematically, this means that the Lagrange multiplieronly lives on the surface, though it can of course be extended by zerointo the domain if that is convenient. As in the current program, onedoes not need to form and store this Lagrange multiplier explicitly. A further interesting problem for the 3d case is to consider contact problemswith friction. In almost every mechanical process friction has a big influence.For the modelling we have to take into account tangential stresses at the contactsurface. Also we have to observe that friction adds another nonlinearity toour problem. Another nontrivial modification is to implement a more complex constitutivelaw like nonlinear elasticity or elasto-plastic material behavior.The difficulty here is to handle the additional nonlinearity arisingthrough the nonlinear constitutive law.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="comment"> *                        University of Siegen, 2011, 2012</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ObstacleProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ObstacleProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">    <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>                  active_set;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> complete_system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diagonal_of_mass_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> contact_force;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> -10;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (p(0) &lt; -0.5)</div><div class="line">        <span class="keywordflow">return</span> -0.2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= -0.5 &amp;&amp; p(0) &lt; 0.0)</div><div class="line">        <span class="keywordflow">return</span> -0.4;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt; 0.5)</div><div class="line">        <span class="keywordflow">return</span> -0.6;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> -0.8;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ObstacleProblem&lt;dim&gt;::ObstacleProblem()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line">    active_set.set_size(dof_handler.n_dofs());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    system_matrix.reinit(dsp);</div><div class="line">    complete_system_matrix.reinit(dsp);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.locally_owned_dofs();</div><div class="line">    solution.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    contact_force.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(dsp);</div><div class="line">    assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line">    diagonal_of_mass_matrix.reinit(solution_index_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; solution.size(); j++)</div><div class="line">      diagonal_of_mass_matrix(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree + 1);</div><div class="line">    RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell_rhs(i) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                 right_hand_side.value(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point)) *</div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a> quadrature_formula;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">              (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">               fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               mass_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(</div><div class="line">      <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(dof_handler.n_dofs()));</div><div class="line">    complete_system_matrix.residual(lambda, solution, complete_system_rhs);</div><div class="line"></div><div class="line">    contact_force = lambda;</div><div class="line">    contact_force.scale(diagonal_of_mass_matrix);</div><div class="line">    contact_force *= -1;</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    active_set.clear();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">    std::vector&lt;bool&gt;   dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dof_handler.get_fe().n_dofs_per_cell() == cell-&gt;n_vertices(),</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index(v, 0);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">            dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value(cell-&gt;vertex(v));</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution(dof_index);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (lambda(dof_index) + penalty_parameter *</div><div class="line">                                    diagonal_of_mass_matrix(dof_index) *</div><div class="line">                                    (solution_value - obstacle_value) &lt;</div><div class="line">              0)</div><div class="line">            {</div><div class="line">              active_set.add_index(dof_index);</div><div class="line">              constraints.<a class="code" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a>(dof_index);</div><div class="line">              constraints.<a class="code" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a>(dof_index, obstacle_value);</div><div class="line"></div><div class="line">              solution(dof_index) = obstacle_value;</div><div class="line"></div><div class="line">              lambda(dof_index) = 0;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">              &lt;&lt; lambda.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>                        reduction_control(100, 1e-12, 1e-3);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(reduction_control);</div><div class="line">    TrilinosWrappers::PreconditionAMG       precondition;</div><div class="line">    precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, precondition);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">              &lt;&lt; reduction_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">              &lt;&lt; reduction_control.last_step() &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(</div><div class="line">      dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">      active_set_vector[index] = 1.;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output_vtk(<span class="stringliteral">&quot;output_&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iteration, 3) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output_vtk);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ObstacleProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old(active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 0; iteration &lt;= solution.size(); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from(system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"></div><div class="line">        solve();</div><div class="line">        update_solution_and_constraints();</div><div class="line">        output_results(iteration);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        active_set_old = active_set;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step41</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"></div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Introduction">Introduction</a>
        <li><a href="#Classicalformulation">Classical formulation</a>
        <li><a href="#Derivationofthevariationalinequality">Derivation of the variational inequality</a>
        <li><a href="#Formulationasasaddlepointproblem">Formulation as a saddle point problem</a>
        <li><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to solve the saddle point problem</a>
        <li><a href="#Theprimaldualactivesetalgorithm">The primal-dual active set algorithm</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeObstacleProblemcodeclasstemplate">The <code>ObstacleProblem</code> class template</a>
        <li><a href="#Righthandsideboundaryvaluesandtheobstacle">Right hand side, boundary values, and the obstacle</a>
        <li><a href="#ImplementationofthecodeObstacleProblemcodeclass">Implementation of the <code>ObstacleProblem</code> class</a>
      <ul>
        <li><a href="#ObstacleProblemObstacleProblem">ObstacleProblem::ObstacleProblem</a>
        <li><a href="#ObstacleProblemmake_grid">ObstacleProblem::make_grid</a>
        <li><a href="#ObstacleProblemsetup_system">ObstacleProblem::setup_system</a>
        <li><a href="#ObstacleProblemassemble_system">ObstacleProblem::assemble_system</a>
        <li><a href="#ObstacleProblemassemble_mass_matrix_diagonal">ObstacleProblem::assemble_mass_matrix_diagonal</a>
        <li><a href="#ObstacleProblemupdate_solution_and_constraints">ObstacleProblem::update_solution_and_constraints</a>
        <li><a href="#ObstacleProblemsolve">ObstacleProblem::solve</a>
        <li><a href="#ObstacleProblemoutput_results">ObstacleProblem::output_results</a>
        <li><a href="#ObstacleProblemrun">ObstacleProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-41/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by JÃ¶rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&amp;M University. <br />
 This material is based upon work partly supported by ThyssenKrupp Steel Europe. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h3>Introduction</h3>
<p>è¿ä¸ªä¾å­æ¯åºäºäºç»´çææ®ææ¯æ¹ç¨ï¼æ¶åçé®é¢æ¯ï¼å¦æä¸ä¸ªèè¢«ä¸äºå¤ååè½¬ï¼ä½ä¹è¢«ä¸ä¸ªéç¢ç©æéå¶ï¼ä¼åçä»ä¹ãæ¢å¥è¯è¯´ï¼æ³æ³ä¸ä¸ªå¼¹æ§èå¨è¾¹çå¤è¢«å¤¹å¨ä¸ä¸ªç©å½¢æ¡æ¶ä¸ï¼æä»¬éæ© \(\Omega = \left[-1,1\right]^2\) ï¼ï¼ç±äºéåä½ç¨èä¸åãå¦æèä¸æä¸ä¸ªéç¢ç©ï¼é»æ­¢å®è¾¾å°å¹³è¡¡ä½ç½®ï¼å¦æéåæ¯å¯ä¸å­å¨çåï¼ç°å¨ä¼åçä»ä¹ï¼å¨ç®åçä¾å­ç¨åºä¸­ï¼æä»¬å°èèå¨èä¸æä¸ä¸ªæ¥¼æ¢¯çéç¢ç©ï¼éåæ¨çèã</p>
<p>è¿ä¸ªé®é¢éå¸¸è¢«ç§°ä¸º "éç¢é®é¢"ï¼ä¹è§<a href="http://en.wikipedia.org/wiki/Obstacle_problem">this Wikipedia article</a>ï¼ï¼å®çç»ææ¯ä¸ä¸ªååä¸ç­å¼ï¼èä¸æ¯åæå¼±å½¢å¼çååæ¹ç¨ãä¸é¢æä»¬å°ä»ç»å¸çè¡¨è¿°ä¸­æ¨å¯¼åºå®ï¼ä½å¨æä»¬ç»§ç»­è®¨è®ºæ°å­¦é®é¢ä¹åï¼è®©æä»¬å±ç¤ºä¸ä¸æä»¬å¨è¿ä¸ªæç¨ç¨åºä¸­è¦èèçé®é¢çè§£å³æ¹å¼ï¼ä»¥è·å¾ä¸äºæä»¬åºè¯¥æå¾çç´è§ã</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.png"/>
</div>
   </td></tr>
</table>
<p>å¨è¿éï¼å¨å·¦è¾¹ï¼æä»¬çå°èçä½ç§»ãä¸é¢çéç¢ç©çå½¢ç¶æ¯æ¸æ°å¯è§çãå¨å³è¾¹ï¼æä»¬å å äºèçåªäºé¨åä¸éç¢ç©æ¥è§¦ãæä»¬ä»¥åä¼æè¿ç»ç¹ç§°ä¸º "æ´»å¨é"ï¼ä»¥è¡¨æè¿éæä¸ä¸ªä¸ç­å¼çº¦æå¨æ´»å¨ã</p>
<p><a class="anchor" id="Classicalformulation"></a></p><h3>Classical formulation</h3>
<p>è¯¥é®é¢çç»å¸è¡¨è¿°å·æä»¥ä¸å½¢å¼ã</p>
<p class="formulaDsp">
\begin{align*} -\textrm{div}\ \sigma &amp;\geq f &amp; &amp;\quad\text{in } \Omega,\\ \sigma &amp;= \nabla u &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;= 0 &amp; &amp;\quad\text{on }\partial\Omega,\\ (-\Delta u - f)(u - g) &amp;= 0 &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;\geq g(\mathbf x) &amp; &amp;\quad\text{in } \Omega \end{align*}
</p>
<p>ä¸ \(u\in H^2(\Omega)\) ã \(u\) æ¯ä¸ä¸ªæ éå¼å½æ°ï¼è¡¨ç¤ºèçåç´ä½ç§»ãç¬¬ä¸ä¸ªæ¹ç¨è¢«ç§°ä¸ºå¹³è¡¡æ¡ä»¶ï¼æä¸ä¸ªåºåå¯åº¦çå \(f\) ãè¿éï¼æä»¬å°èèè¿ä¸ªåæ¯éåãç¬¬äºä¸ªæ¹ç¨è¢«ç§°ä¸ºè¡åå®å¾ï¼å³åºå \(\sigma\) ä¸ä½ç§» \(u\) çæ¢¯åº¦ææ­£æ¯ï¼æ¯ä¾å¸¸æ°ï¼éå¸¸ç¨ \(E\) è¡¨ç¤ºï¼è¿éè¢«è®¾å®ä¸º1ï¼ä½ä¸å¤±ä¸è¬æ§ï¼å¦æå®æ¯å¸¸æ°ï¼å®å¯ä»¥è¢«æ¾å¥å³è¾¹çå½æ°ï¼ãå¨è¾¹çï¼æä»¬æé¶è¿ªéå¸ç¹æ¡ä»¶ãå¾ææ¾ï¼åä¸¤ä¸ªæ¹ç¨å¯ä»¥ç»åèµ·æ¥ï¼å¾å° \(-\Delta u \ge f\) ã</p>
<p>ç´è§å°è¯´ï¼éåæ¯åä¸ä½ç¨çï¼æä»¥ \(f(\mathbf x)\) æ¯ä¸ä¸ªè´å½æ°ï¼æä»¬å¨è¿ä¸ªç¨åºä¸­éæ© \(f=-10\) ï¼ãé£ä¹ï¼ç¬¬ä¸ä¸ªæ¡ä»¶æå³çä½ç¨å¨èä¸çæ»åæ¯éåå ä¸ä¸äºæ­£å¼ï¼å³éç¢ç©å¨å®ä»¬ä¸¤ä¸ªæ¥è§¦çå°æ¹å¯¹èæ½å çåä¸çåãè¿ä¸ªé¢å¤çåæå¤å¤§ï¼æä»¬è¿ä¸ç¥éï¼æä»¬ä¹ä¸ç¥éå®å®éä½ç¨ç "ä½ç½®"ï¼ï¼ä½å®å¿é¡»æ¯ä½¿èä¸ç©¿ééç¢ç©çã</p>
<p>ä¸é¢çç¬¬åä¸ªç­å¼åæåä¸ä¸ªä¸ç­å¼ææäºéç¢æ¡ä»¶ï¼å®å¿é¡»å¨æ´ä¸ªé¢åçæ¯ä¸ç¹é½æç«ãè¿ä¸¤ä¸ªæ¡ä»¶ä¸­çåèæå³çèå¿é¡»å¨ä»»ä½å°æ¹é½é«äºéç¢ç© \(g(\mathbf x)\) ãåæ°ç¬¬äºä¸ªæ¹ç¨ï¼éå¸¸è¢«ç§°ä¸º "äºè¡¥æ¡ä»¶"ï¼è¯´çæ¯å¨èä¸ä¸éç¢ç©æ¥è§¦çå°æ¹ï¼å³é£äº \(\mathbf x\) çå°æ¹ \(u(\mathbf x) - g(\mathbf x) \neq 0\) ï¼ï¼é£ä¹ \(-\Delta u=f\) å¨è¿äºå°æ¹ï¼æ¢å¥è¯è¯´ï¼æ²¡æé¢å¤çåä½ç¨å¨é£éï¼å¦é¢æçé£æ ·ãå¦ä¸æ¹é¢ï¼å¨ \(u=g\) çå°æ¹ï¼æä»¬å¯ä»¥æ \(-\Delta u-f \neq 0\) ï¼ä¹å°±æ¯è¯´ï¼å¯ä»¥æé¢å¤çåï¼å°½ç®¡ä¸ä¸å®è¦æï¼èæå¯è½åªæ¯æ¥è§¦èä¸æ¯åä½éç¢ç©ï¼ã</p>
<p><a class="anchor" id="Derivationofthevariationalinequality"></a></p><h3>Derivation of the variational inequality</h3>
<p>è·å¾éç¢ç©é®é¢çåéè¡¨è¿°çä¸ä¸ªææ¾æ¹æ³æ¯èèæ»å¿è½ã</p>
<p class="formulaDsp">
\begin{equation*} E(u) \dealcoloneq \dfrac{1}{2}\int\limits_{\Omega} \nabla u \cdot \nabla u - \int\limits_{\Omega} fu. \end{equation*}
</p>
<p>æä»¬å¿é¡»æ¾å°ä»¥ä¸æå°åé®é¢çè§£å³æ¹æ¡ \(u\in G\) ã</p>
<p class="formulaDsp">
\begin{equation*} E(u)\leq E(v)\quad \forall v\in G, \end{equation*}
</p>
<p>ä¸å¯æ¥åä½ç§»çå¸éã</p>
<p class="formulaDsp">
\begin{equation*} G \dealcoloneq \lbrace v\in V: v\geq g \text{ a.e. in } \Omega\rbrace,\quad V\dealcoloneq H^1_0(\Omega). \end{equation*}
</p>
<p>è¿ç»æ°æ®ç§é¡¾å°äºä¸è¿°ç¬¬ä¸åç¬¬äºä¸ªæ¡ä»¶ï¼è¾¹çå¼åäºè¡¥æ¡ä»¶ï¼ã</p>
<p>ç°å¨èè \(E\) çæå°åå¨ \(u\in G\) åä»»ä½å¶ä»å½æ° \(v\in G\) ãé£ä¹å½æ°</p>
<p class="formulaDsp">
\begin{equation*} F(\varepsilon) \dealcoloneq E(u+\varepsilon(v-u)),\quad\varepsilon\in\left[0,1\right], \end{equation*}
</p>
<p>å¨ \(\varepsilon = 0\) å¤åæå°å¼ï¼å ä¸º \(u\) æ¯è½éå½æ° \(E(\cdot)\) çæå°å¼ï¼ï¼å æ­¤ï¼å¯¹äº \(v\) çä»»ä½éæ©ï¼ \(F&#39;(0)\geq 0\) ãè¯·æ³¨æï¼ \(u+\varepsilon(v-u) = (1-\varepsilon)u+\varepsilon v\in G\) å ä¸º \(G\) çå¸æ§ãå¦ææä»¬è®¡ç® \(F&#39;(\varepsilon)\vert_{\varepsilon=0}\) ï¼å°±å¯ä»¥å¾å°æä»¬è¦å¯»æ¾çåå¼å¬å¼ã</p>
<p><em>Find a function \(u\in G\) with</em></p>
<p class="formulaDsp">
\begin{equation*} \left(\nabla u, \nabla(v-u)\right) \geq \left(f,v-u\right) \quad \forall v\in G. \end{equation*}
</p>
<p>è¿æ¯ååä¸ç­å¼çå¸åå½¢å¼ï¼ä¸ä»ä»æ¯ \(v\) åºç°å¨åçº¿æ§å½¢å¼ä¸­ï¼å®éä¸è¿æ \(v-u\) ãåå æ¯è¿æ ·çï¼å¦æ \(u\) ä¸åçº¦æï¼é£ä¹æä»¬å¯ä»¥å¨ \(G\) ä¸­æ¾å°æµè¯å½æ° \(v\) ï¼ä»èä½¿ \(v-u\) å¯ä»¥æä»»ä½ç¬¦å·ãéè¿éæ©æµè¯å½æ° \(v_1,v_2\) ä½¿ \(v_1-u = -(v_2-u)\) ï¼å¯ä»¥çåºï¼åªæå½ä¸¤è¾¹äºå®ä¸ç¸ç­æ¶ï¼ä¸ç­å¼æè½å¯¹ \(v_1\) å \(v_2\) é½æç«ï¼ä¹å°±æ¯è¯´ï¼æä»¬å¾å°ä¸ä¸ªåå¼çç¸ç­ã</p>
<p>å¦ä¸æ¹é¢ï¼å¦æ \(u=g\) ï¼é£ä¹ \(G\) åªåè®¸æµè¯å½æ° \(v\) ï¼æä»¥å®éä¸ \(v-u\ge 0\) ãè¿æå³çæä»¬ä¸è½åä¸é¢é£æ ·ç¨ \(v-u\) å \(-(v-u)\) æ¥æµè¯è¿ä¸ªæ¹ç¨ï¼æä»¥æä»¬ä¸è½åå¾åºä¸¤è¾¹å®éä¸ç¸ç­çç»è®ºãå æ­¤ï¼è¿å°±æ¨¡ä»¿äºæä»¬ä¸é¢è®¨è®ºäºè¡¥æ§æ¡ä»¶çæ¹å¼ã</p>
<p><a class="anchor" id="Formulationasasaddlepointproblem"></a></p><h3>Formulation as a saddle point problem</h3>
<p>ä¸é¢çååä¸ç­å¼å¨å·¥ä½ä¸­æ¯å¾å°´å°¬çãå æ­¤ï¼æä»¬æ³æå®éæ°è¡¨è¿°ä¸ºä¸ä¸ªç­ä»·çéç¹é®é¢ãæä»¬å¼å¥ææ ¼ææ¥ä¹å­ \(\lambda\) åææ ¼ææ¥ä¹å­ \(K\subset V&#39;\) ã \(V&#39;\) çå¸é¥ \(V\) ã \(K \dealcoloneq \{\mu\in V&#39;: \langle\mu,v\rangle\geq 0,\quad \forall v\in V, v \le 0 \}\) çå¯¹å¶ç©ºé´ï¼å¶ä¸­ \(\langle\cdot,\cdot\rangle\) è¡¨ç¤º \(V&#39;\) å \(V\) ä¹é´çå¯¹å¶æ§ãç´è§å°è¯´ï¼ \(K\) æ¯ææ "éæ­£å½æ° "çé¥ä½ï¼é¤äº \(K\subset (H_0^1)&#39;\) ï¼æä»¥ä¹åå«äºé¤æ­£å½æ°ä¹å¤çå¶ä»å¯¹è±¡ãè¿å°±äº§çäºã</p>
<p><em>Find \(u\in V\) and \(\lambda\in K\) such that</em></p>
<p class="formulaDsp">
\begin{align*} a(u,v) + b(v,\lambda) &amp;= f(v),\quad &amp;&amp;v\in V\\ b(u,\mu - \lambda) &amp;\leq \langle g,\mu - \lambda\rangle,\quad&amp;&amp;\mu\in K, \end{align*}
</p>
<p><em>with</em></p>
<p class="formulaDsp">
\begin{align*} a(u,v) &amp;\dealcoloneq \left(\nabla u, \nabla v\right),\quad &amp;&amp;u,v\in V\\ b(u,\mu) &amp;\dealcoloneq \langle u,\mu\rangle,\quad &amp;&amp;u\in V,\quad\mu\in V&#39;. \end{align*}
</p>
<p>æ¢å¥è¯è¯´ï¼æä»¬å¯ä»¥æ \(\lambda\) çä½æ¯éç¢ç©å¯¹èæ½å çé¢å¤æ­£åçè´æ°ãä¸é¢éè¿°çç¬¬äºè¡ä¸­çä¸ç­å¼ä¼¼ä¹åªæéè¯¯çç¬¦å·ï¼å ä¸ºæä»¬å¨ \(\lambda=0\) çå°æ¹æ \(\mu-\lambda&lt;0\) ï¼é´äº \(K\) çå®ä¹ã</p>
<p>Glowinski, Lions and Tr&eacute;moli&egrave;res.ä¸­éè¿°äºè¿ä¸ªéç¹é®é¢ \((u,\lambda)\in V\times K\) çå­å¨æ§åå¯ä¸æ§ãNumerical Analysis of Variational Inequalities, North-Holland, 1981.</p>
<p><a class="anchor" id="ActiveSetmethodstosolvethesaddlepointproblem"></a></p><h3>Active Set methods to solve the saddle point problem</h3>
<p>æä¸åçæ¹æ³æ¥è§£å³åéä¸ç­å¼ãä½ä¸ºä¸ç§å¯è½æ§ï¼ä½ å¯ä»¥æéç¹é®é¢çè§£ä¸ºä¸ä¸ªå¸¦æä¸ç­å¼çº¦æçå¸äºæ¬¡æ¹ç¨åºï¼QPï¼ã</p>
<p>ä¸ºäºè¾¾å°è¿ä¸ªç®çï¼è®©æä»¬åè®¾æä»¬ç¨ç¸åçæéåç©ºé´æ¥ç¦»æ£ \(u\) å \(\lambda\) ï¼ä¾å¦éå¸¸ç \(Q_k\) ç©ºé´ãç¶åæä»¬ä¼å¾å°æ¹ç¨</p>
<p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;[BU-G]_i \geq 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[BU-G]_i = 0 \qquad \forall i.&amp; \end{eqnarray*}
</p>
<p>å¶ä¸­ \(B\) æ¯æéæéåç©ºé´ä¸çè´¨éç©éµï¼ä¸é¢çææ° \(i\) æ¯éå¯¹ä½äºååé¨çèªç±åº¦éå \(\cal S\) ä¸­çææèªç±åº¦ï¼æä»¬å¨å¨è¾¹æè¿ªéå¸æ¡ä»¶ï¼ãç¶èï¼å¦ææä»¬å¨ç»åäº§çè¿ä¸ªè´¨éç©éµçææé¡¹æ¶ä½¿ç¨ä¸ä¸ªç¹æ®çæ­£äº¤è§åï¼å³ä¸ä¸ªæ­£äº¤å¬å¼ï¼å¶ä¸­æ­£äº¤ç¹åªä½äºå®ä¹äºå½¢ç¶å½æ°çæå¼ç¹ï¼å ä¸ºé¤äºä¸ä¸ªå½¢ç¶å½æ°å¤ï¼ææçå½¢ç¶å½æ°å¨è¿äºä½ç½®é½æ¯é¶ï¼æä»¥æä»¬å¾å°ä¸ä¸ªå¯¹è§çº¿è´¨éç©éµï¼å·æ</p>
<p class="formulaDsp">
\begin{align*} B_{ii} = \int_\Omega \varphi_i(\mathbf x)^2\ \textrm{d}x, \qquad B_{ij}=0 \ \text{for } i\neq j. \end{align*}
</p>
<p>ä¸ºäºå®ä¹ \(G\) ï¼æä»¬ä½¿ç¨ä¸ \(B\) ç¸åçææ¯ãæ¢å¥è¯è¯´ï¼æä»¬å®ä¹</p>
<p class="formulaDsp">
\begin{align*} G_{i} = \int_\Omega g_h(x) \varphi_i(\mathbf x)\ \textrm{d}x, \end{align*}
</p>
<p>å¶ä¸­ \(g_h\) æ¯ \(g\) çä¸ä¸ªåéçè¿ä¼¼å¼ãç¶åï¼ \(B_{ii}\) å \(G_i\) å®ä¹ä¸­çç§¯åç±æ¢¯å½¢è§åè¿ä¼¼ãæäºè¿ä¸ªï¼ä¸é¢çæ¹ç¨å¯ä»¥éè¿°ä¸º</p>
<p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;U_i-B_{ii}^{-1}G_i \ge 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[U_i-B_{ii}^{-1}G_i] = 0 \qquad \forall i\in{\cal S}.&amp; \end{eqnarray*}
</p>
<p>ç°å¨æä»¬ä¸ºæ¯ä¸ªèªç±åº¦ \(i\) å®ä¹å½æ°</p>
<p class="formulaDsp">
\begin{equation*} C([BU]_i,\Lambda_i) \dealcoloneq -\Lambda_i + \min\lbrace 0, \Lambda_i + c([BU]_i - G_i) \rbrace, \end{equation*}
</p>
<p>å¨è¿ä¸ªç¨åºä¸­ï¼æä»¬éæ© \(c&gt;0\) ãè¿æ¯ä¸ç§æ©ç½åæ°ï¼åå³äºé®é¢æ¬èº«ï¼éè¦éæ©è¶³å¤å¤§çåæ°ï¼ä¾å¦ï¼å¦ææä»¬ä½¿ç¨7ä¸ªå¨å±ç»åï¼ä½¿ç¨å½åç¨åºå¯¹ \(c = 1\) æ²¡ææ¶æä½ç¨ï¼ã)</p>
<p>ç»è¿ä¸çªæ å¤´ï¼äººä»¬å¯ä»¥è¯´æèªå·±ï¼ä¸é¢çä¸ç­å¼å¯ä»¥ç­æå°æ¹åä¸º</p>
<p class="formulaDsp">
\begin{equation*} C([BU]_i,\Lambda_i) = 0, \qquad \forall i\in{\cal S}. \end{equation*}
</p>
<p>æä»¬å¨è¿éå°ä½¿ç¨çåå§-åéä¸»å¨éç­ç¥æ¯ä¸ä¸ªè¿­ä»£æ¹æ¡ï¼å®åºäºè¿ä¸ªæ¡ä»¶æ¥é¢æµä¸ä¸ä¸ªä¸»å¨éåéä¸»å¨é \(\mathcal{A}_k\) å \(\mathcal{F}_k\) ï¼å³é£äºææ° \(i\) çäºè¡¥éï¼å¯¹äºè¿äºææ° \(U_i\) è¦ä¹ç­äºè¦ä¹ä¸ç­äºéç¢ç©çå¼ \(B^{-1}G\) ï¼ãå³äºè¿ç§æ¹æ³çæ´æ·±å¥çå¤çï¼è§Hintermueller, Ito, Kunisch:The primal-dual active set strategy as a semismooth newton method, SIAM J. OPTIM., 2003, Vol.13, No.3, pp.865-888.</p>
<p><a class="anchor" id="Theprimaldualactivesetalgorithm"></a></p><h3>The primal-dual active set algorithm</h3>
<p>åçº§-äºçº§ä¸»å¨éæ¹æ³çç®æ³å·¥ä½åçå¦ä¸ï¼æ³¨ï¼ \(B = B^T\) ï¼ã</p>
<p>1.åå§å \(\mathcal{A}_k\) å \(\mathcal{F}_k\) ï¼ä½¿ \(\mathcal{S}=\mathcal{A}_k\cup\mathcal{F}_k\) å \(\mathcal{A}_k\cap\mathcal{F}_k=\emptyset\) å¹¶è®¾ç½® \(k=1\) ã2.æ¾åºæ»¡è¶³ </p><p class="formulaDsp">
\begin{align*} AU^k + B\Lambda^k &amp;= F,\\ [BU^k]_i &amp;= G_i\quad&amp;&amp;\forall i\in\mathcal{A}_k,\\ \Lambda_i^k &amp;= 0\quad&amp;&amp;\forall i\in\mathcal{F}_k. \end{align*}
</p>
<p>çåå§-åæ°å¯¹ \((U^k,\Lambda^k)\) ã</p>
<p>è¯·æ³¨æï¼ç¬¬äºä¸ªåç¬¬ä¸ä¸ªæ¡ä»¶æå³çæ­£å¥½ \(|S|\) ä¸ªæªç¥æ°æ¯åºå®çï¼ç¬¬ä¸ä¸ªæ¡ä»¶äº§çäºç¡®å® \(U\) å \(\Lambda\) æéçå©ä½ \(|S|\) ä¸ªæ¹ç¨ã3.3. ç¨ </p><p class="formulaDsp">
\begin{equation*} \begin{split} \mathcal{A}_{k+1} \dealcoloneq \lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\rbrace,\\ \mathcal{F}_{k+1} \dealcoloneq \lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)\geq 0\rbrace. \end{split} \end{equation*}
</p>
<p>å®ä¹æ°çæ´»å¨åéæ´»å¨éã</p>
<p>å¦æ \(\mathcal{A}_{k+1}=\mathcal{A}_k\) ï¼ç¶åï¼æ¾ç¶ä¹æ¯ \(\mathcal{F}_{k+1}=\mathcal{F}_k\) ï¼ï¼ååæ­¢ï¼å¦åè®¾ç½® \(k=k+1\) å¹¶è½¬å°æ­¥éª¤ï¼2ï¼ã</p>
<p>è¯¥æ¹æ³è¢«ç§°ä¸º "åå§-åé"ï¼å ä¸ºå®åæ¶ä½¿ç¨åå§åéï¼ä½ç§» \(U\) ï¼ä»¥ååéåéï¼ææ ¼ææ¥ä¹æ° \(\Lambda\) ï¼æ¥ç¡®å®ä¸ä¸ä¸ªæ´»å¨éã</p>
<p>å¨æ¬èçæåï¼è®©æä»¬è¡¥åä¸¤ç¹æè§ãé¦åï¼å¯¹äºä»»ä½æ»¡è¶³è¿äºæ¡ä»¶çåå§-åéå¯¹ \((U^k,\Lambda^k)\) ï¼æä»¬å¯ä»¥åºåä»¥ä¸å ç§æåµã</p>
<ol type="1">
<li>\(\Lambda^k_i + c([BU^k]_i - G_i) &lt; 0\) (i active)ã <br />
 ç¶åæ¯ \([BU^k]_i&lt;G_i\) å \(\Lambda^k_i=0\) ï¼æ¸éï¼æ \(\Lambda^k_i&lt;0\) å \([BU^k]_i=G_i\) ï¼åè½½ï¼ã2. \(\Lambda^k_i + c([BU^k]_i - G_i)\geq 0\) (iä¸æ´»å¨)ã <br />
 ç¶åæ¯ \([BU^k]_i\geq G_i\) å \(\Lambda^k_i=0\) ï¼æ æ¥è§¦ï¼æ \(\Lambda^k_i\geq0\) å \([BU^k]_i=G_i\) ï¼æ åè¿«è´è·ï¼ã</li>
</ol>
<p>ç¬¬äºï¼ä¸é¢çæ¹æ³å¨ç´è§ä¸ä¼¼ä¹æ¯æ­£ç¡®çï¼ä¹æ¯æç¨çï¼ä½æç¹ä¸´æ¶æ§çãç¶èï¼å®å¯ä»¥éè¿ä»¥ä¸æ¹å¼ç®æå°æ¨å¯¼åºæ¥ãä¸ºæ­¤ï¼è¯·æ³¨æï¼æä»¬è¦è§£å³çæ¯éçº¿æ§ç³»ç»</p>
<p class="formulaDsp">
\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;C([BU-G]_i, \Lambda_i) = 0, \qquad \forall i.&amp; \end{eqnarray*}
</p>
<p>æä»¬å¯ä»¥éè¿å§ç»å´ç»åä¸ä¸ªè¿­ä»£è¿è¡çº¿æ§åï¼å³åºç¨çé¡¿æ¹æ³ï¼æ¥è¿­ä»£è§£å³ï¼ä½ä¸ºæ­¤æä»¬éè¦å¯¹ä¸å¯å¾®åçå½æ° \(C(\cdot,\cdot)\) è¿è¡çº¿æ§åãä¹å°±æ¯è¯´ï¼å®æ¯å¯å¾®çï¼äºå®ä¸æä»¬æ</p>
<p class="formulaDsp">
\begin{equation*} \dfrac{\partial}{\partial U^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} cB_{ii},&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}
</p>
<p class="formulaDsp">
\begin{equation*} \dfrac{\partial}{\partial\Lambda^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ -1,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}
</p>
<p>è¿è¡¨æä¸ä¸ªååæ»ççé¡¿æ­¥éª¤ï¼å¶å½¢å¼ä¸º</p>
<p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; -Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; cB_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} \delta U^k_{\mathcal{F}_k}\\ \delta U^k_{\mathcal{A}_k}\\ \delta \Lambda^k_{\mathcal{F}_k}\\ \delta \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = -\begin{pmatrix} (AU^k + \Lambda^k - F)_{\mathcal{F}_k}\\ (AU^k + \Lambda^k - F)_{\mathcal{A}_k}\\ -\Lambda^k_{\mathcal{F}_k}\\ c(B_{\mathcal{A}_k} U^k - G)_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}
</p>
<p>å¶ä¸­ï¼æä»¬å°ç©éµ \(A,B\) ä»¥ååéä»¥èªç¶çæ¹å¼åæè¡ååï¼å¶ç´¢å¼å±äºæ´»å¨é \({\mathcal{A}_k}\) æéæ´»å¨é \({\mathcal{F}_k}\) ã</p>
<p>æä»¬ä¹å¯ä»¥éè¿è®¾ç½® \(\delta U^k \dealcoloneq U^{k+1} - U^k\) å \(\delta \Lambda^k \dealcoloneq \Lambda^{k+1} - \Lambda^k\) å¹¶å°ææå·²ç¥é¡¹å¸¦å°å³æè¾¹æ¥è§£å³æä»¬æå´è¶£çåéï¼èä¸æ¯æ±è§£æ´æ° \(\delta U, \delta \Lambda\) ãè¿å°±å¾å°äº</p>
<p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{F}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ 0\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
<p>è¿äºæ¯ä¸ææè¿°åºæ¬ç®æ³æ¶æ¦è¿°çæ¹ç¨å¼ã</p>
<p>æä»¬çè³å¯ä»¥è¿ä¸æ­¥æ¨å¨è¿ä¸ç¹ãå¾å®¹æçåºï¼æä»¬å¯ä»¥æ¶é¤ç¬¬ä¸è¡åç¬¬ä¸åï¼å ä¸ºå®æå³ç \(\Lambda_{\mathcal{F}_k} = 0\) ã</p>
<p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; B_{\mathcal{A}_k}\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
<p>è¿è¡¨æï¼äºå®ä¸æä»¬åªéè¦è§£å³ä½äºæ´»å¨éä¸çææ ¼ææ¥ä¹æ°ãéè¿èèç¬¬äºè¡ï¼æä»¬å°éè¿ä»¥ä¸æ¹å¼æ¢å¤å¨é¨ææ ¼ææ¥ä¹æ°åé</p>
<p class="formulaDsp">
\begin{equation*} \Lambda^k_S = B^{-1}\left(f_{\mathcal{S}} - A_{\mathcal{S}}U^k_{\mathcal{S}}\right). \end{equation*}
</p>
<p>ç±äºç¬¬ä¸è¡å \(B_{\mathcal{A}_k}\) æ¯ä¸ä¸ªå¯¹è§çº¿ç©éµçäºå®ï¼æä»¬è½å¤ç´æ¥è®¡ç®åº \(U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}\) ãå æ­¤ï¼æä»¬ä¹å¯ä»¥æçº¿æ§ç³»ç»åæå¦ä¸ã</p>
<p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; 0\\ 0 &amp; Id_{\mathcal{A}_k} \\ \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k} - A_{\mathcal{F}_k\mathcal{A}_k}B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k} \\ B_{\mathcal{A}_k}^{-1}G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}
</p>
<p>å¹¸è¿çæ¯ï¼è¿ç§å½¢å¼å¾å®¹æå¾åºï¼æä»¬åªéå»ºç«éå¸¸çææ®ææ¯çº¿æ§ç³»ç»å³å¯</p>
<p class="formulaDsp">
\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} \\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}
</p>
<p>ç¶åè®©AffineConstraintsç±»æ¶é¤ææåéèªç±åº¦ï¼å³ \(U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}\) ï¼å¶æ¹å¼ä¸ \(\mathcal{A}_k\) ä¸­çèªç±åº¦æ¯Dirichletæ°æ®ä¸æ ·ãç»æçº¿æ§ç³»ç»ï¼ä¸é¢çç¬¬äºä¸ªå°æåä¸ä¸ªï¼æ¯å¯¹ç§°åæ­£å®çï¼æä»¬ç¨CGæ¹æ³åTrilinosçAMGé¢å¤çç¨åºæ¥è§£å³å®ã</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>æ¬æç¨ä¸ç¬¬4æ­¥å¾ç¸ä¼¼ãç¨åºçæ»ä½ç»æéµå¾ªæ­¥éª¤4ï¼ä½ç¥æä¸åã</p>
<ul>
<li>æä»¬éè¦ä¸¤ä¸ªæ°çæ¹æ³ï¼ <code>assemble_mass_matrix_diagonal</code> å <code>update_solution_and_constraints</code> ã</li>
<li>æä»¬éè¦æ°çæååéæ¥è¡¨ç¤ºæä»¬è¿éççº¦æã</li>
<li>æä»¬æ¹åæ±è§£å¨çé¢å¤çç¨åºã</li>
</ul>
<p>å¦æä½ æ³äºè§£ç®åçè®¡åï¼ä½ å¯è½æ³éè¯»ä¸ä¸æ­¥éª¤4ã</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As usual, at the beginning we include all the header files we need in here. With the exception of the various files that provide interfaces to the Trilinos library, there are no surprises:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeObstacleProblemcodeclasstemplate"></a> </p><h3>The <code>ObstacleProblem</code> class template</h3>
<p>This class supplies all function and variables needed to describe the obstacle problem. It is close to what we had to do in <a class="el" href="step_4.html">step-4</a>, and so relatively simple. The only real new components are the update_solution_and_constraints function that computes the active set and a number of variables that are necessary to describe the original (unconstrained) form of the linear system (<code>complete_system_matrix</code> and <code>complete_system_rhs</code>) as well as the active set itself and the diagonal of the mass matrix \(B\) used in scaling Lagrange multipliers in the active set formulation. The rest is as in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ObstacleProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ObstacleProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">       assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">  <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>                  active_set;</div><div class="line"></div><div class="line">  TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> complete_system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diagonal_of_mass_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> contact_force;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandtheobstacle"></a> </p><h3>Right hand side, boundary values, and the obstacle</h3>
<p>In the following, we define classes that describe the right hand side function, the Dirichlet boundary values, and the height of the obstacle as a function of \(\mathbf x\). In all three cases, we derive these classes from <a class="el" href="classFunction.html">Function</a>&lt;dim&gt;, although in the case of <code>RightHandSide</code> and <code>Obstacle</code> this is more out of convention than necessity since we never pass such objects to the library. In any case, the definition of the right hand side and boundary values classes is obvious given our choice of \(f=-10\), \(u|_{\partial\Omega}=0\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> -10;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>We describe the obstacle function by a cascaded barrier (think: stair steps):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (p(0) &lt; -0.5)</div><div class="line">      <span class="keywordflow">return</span> -0.2;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= -0.5 &amp;&amp; p(0) &lt; 0.0)</div><div class="line">      <span class="keywordflow">return</span> -0.4;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt; 0.5)</div><div class="line">      <span class="keywordflow">return</span> -0.6;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> -0.8;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeObstacleProblemcodeclass"></a> </p><h3>Implementation of the <code>ObstacleProblem</code> class</h3>
<p><a class="anchor" id="ObstacleProblemObstacleProblem"></a> </p><h4>ObstacleProblem::ObstacleProblem</h4>
<p>To everyone who has taken a look at the first few tutorial programs, the constructor is completely obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ObstacleProblem&lt;dim&gt;::ObstacleProblem()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemmake_grid"></a> </p><h4>ObstacleProblem::make_grid</h4>
<p>We solve our obstacle problem on the square \([-1,1]\times [-1,1]\) in 2D. This function therefore just sets up one of the simplest possible meshes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsetup_system"></a> </p><h4>ObstacleProblem::setup_system</h4>
<p>In this first function of note, we set up the degrees of freedom handler, resize vectors and matrices, and deal with the constraints. Initially, the constraints are, of course, only given by boundary values, so we interpolate them towards the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  active_set.set_size(dof_handler.n_dofs());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  system_matrix.reinit(dsp);</div><div class="line">  complete_system_matrix.reinit(dsp);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.locally_owned_dofs();</div><div class="line">  solution.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">  contact_force.reinit(solution_index_set, MPI_COMM_WORLD);</div></div><!-- fragment --><p>The only other thing to do here is to compute the factors in the \(B\) matrix which is used to scale the residual. As discussed in the introduction, we'll use a little trick to make this mass matrix diagonal, and in the following then first compute all of this as a matrix and then extract the diagonal elements for later use:</p>
<div class="fragment"><div class="line">  TrilinosWrappers::SparseMatrix <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(dsp);</div><div class="line">  assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line">  diagonal_of_mass_matrix.reinit(solution_index_set);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; solution.size(); j++)</div><div class="line">    diagonal_of_mass_matrix(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_system"></a> </p><h4>ObstacleProblem::assemble_system</h4>
<p>This function at once assembles the system matrix and right-hand-side and applied the constraints (both due to the active set as well as from boundary values) to our system. Otherwise, it is functionally equivalent to the corresponding function in, for example, <a class="el" href="step_4.html">step-4</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree + 1);</div><div class="line">  RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">            cell_rhs(i) +=</div><div class="line">              (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">               right_hand_side.value(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point)) *</div><div class="line">               fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">          }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                             cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs,</div><div class="line">                                             <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_mass_matrix_diagonal"></a> </p><h4>ObstacleProblem::assemble_mass_matrix_diagonal</h4>
<p>The next function is used in the computation of the diagonal mass matrix \(B\) used to scale variables in the active set method. As discussed in the introduction, we get the mass matrix to be diagonal by choosing the trapezoidal rule for quadrature. Doing so we don't really need the triple loop over quadrature points, indices \(i\) and indices \(j\) any more and can, instead, just use a double loop. The rest of the function is obvious given what we have discussed in many of the previous tutorial programs.</p>
<p>Note that at the time this function is called, the constraints object only contains boundary value constraints; we therefore do not have to pay attention in the last copy-local-to-global step to preserve the values of matrix entries that may later on be constrained by the active set.</p>
<p>Note also that the trick with the trapezoidal rule only works if we have in fact \(Q_1\) elements. For higher order elements, one would need to use a quadrature formula that has quadrature points at all the support points of the finite element. Constructing such a quadrature formula isn't really difficult, but not the point here, and so we simply assert at the top of the function that our implicit assumption about the finite element is in fact satisfied.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">  TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a> quadrature_formula;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">            (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             mass_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemupdate_solution_and_constraints"></a> </p><h4>ObstacleProblem::update_solution_and_constraints</h4>
<p>In a sense, this is the central function of this program. It updates the active set of constrained degrees of freedom as discussed in the introduction and computes an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object from it that can then be used to eliminate constrained degrees of freedom from the solution of the next iteration. At the same time we set the constrained degrees of freedom of the solution to the correct value, namely the height of the obstacle.</p>
<p>Fundamentally, the function is rather simple: We have to loop over all degrees of freedom and check the sign of the function \(\Lambda^k_i + c([BU^k]_i - G_i) = \Lambda^k_i + cB_i(U^k_i - [g_h]_i)\) because in our case \(G_i = B_i[g_h]_i\). To this end, we use the formula given in the introduction by which we can compute the Lagrange multiplier as the residual of the original linear system (given via the variables <code>complete_system_matrix</code> and <code>complete_system_rhs</code>. At the top of this function, we compute this residual using a function that is part of the matrix classes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(</div><div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(dof_handler.n_dofs()));</div><div class="line">  complete_system_matrix.residual(lambda, solution, complete_system_rhs);</div></div><!-- fragment --><p>compute contact_force[i] = - lambda[i] * diagonal_of_mass_matrix[i]</p>
<div class="fragment"><div class="line">contact_force = lambda;</div><div class="line">contact_force.scale(diagonal_of_mass_matrix);</div><div class="line">contact_force *= -1;</div></div><!-- fragment --><p>The next step is to reset the active set and constraints objects and to start the loop over all degrees of freedom. This is made slightly more complicated by the fact that we can't just loop over all elements of the solution vector since there is no way for us then to find out what location a DoF is associated with; however, we need this location to test whether the displacement of a DoF is larger or smaller than the height of the obstacle at this location.</p>
<p>We work around this by looping over all cells and DoFs defined on each of these cells. We use here that the displacement is described using a \(Q_1\) function for which degrees of freedom are always located on the vertices of the cell; thus, we can get the index of each degree of freedom and its location by asking the vertex for this information. On the other hand, this clearly wouldn't work for higher order elements, and so we add an assertion that makes sure that we only deal with elements for which all degrees of freedom are located in vertices to avoid tripping ourselves with non-functional code in case someone wants to play with increasing the polynomial degree of the solution.</p>
<p>The price to pay for having to loop over cells rather than DoFs is that we may encounter some degrees of freedom more than once, namely each time we visit one of the cells adjacent to a given vertex. We will therefore have to keep track which vertices we have already touched and which we haven't so far. We do so by using an array of flags <code>dof_touched</code>:</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">active_set.clear();</div><div class="line"></div><div class="line"><span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">std::vector&lt;bool&gt;   dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dof_handler.get_fe().n_dofs_per_cell() == cell-&gt;n_vertices(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index(v, 0);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">        dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">continue</span>;</div></div><!-- fragment --><p>Now that we know that we haven't touched this DoF yet, let's get the value of the displacement function there as well as the value of the obstacle function and use this to decide whether the current DoF belongs to the active set. For that we use the function given above and in the introduction.</p>
<p>If we decide that the DoF should be part of the active set, we add its index to the active set, introduce an inhomogeneous equality constraint in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, and reset the solution value to the height of the obstacle. Finally, the residual of the non-contact part of the system serves as an additional control (the residual equals the remaining, unaccounted forces, and should be zero outside the contact zone), so we zero out the components of the residual vector (i.e., the Lagrange multiplier lambda) that correspond to the area where the body is in contact; at the end of the loop over all cells, the residual will therefore only consist of the residual in the non-contact zone. We output the norm of this residual along with the size of the active set after the loop.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value(cell-&gt;vertex(v));</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution(dof_index);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (lambda(dof_index) + penalty_parameter *</div><div class="line">                                diagonal_of_mass_matrix(dof_index) *</div><div class="line">                                (solution_value - obstacle_value) &lt;</div><div class="line">          0)</div><div class="line">        {</div><div class="line">          active_set.add_index(dof_index);</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a>(dof_index);</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a>(dof_index, obstacle_value);</div><div class="line"></div><div class="line">          solution(dof_index) = obstacle_value;</div><div class="line"></div><div class="line">          lambda(dof_index) = 0;</div><div class="line">        }</div><div class="line">    }</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">          &lt;&lt; lambda.l2_norm() &lt;&lt; std::endl;</div></div><!-- fragment --><p>In a final step, we add to the set of constraints on DoFs we have so far from the active set those that result from Dirichlet boundary values, and close the constraints object:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsolve"></a> </p><h4>ObstacleProblem::solve</h4>
<p>There is nothing to say really about the solve function. In the context of a Newton method, we are not typically interested in very high accuracy (why ask for a highly accurate solution of a linear problem that we know only gives us an approximation of the solution of the nonlinear problem), and so we use the <a class="el" href="classReductionControl.html">ReductionControl</a> class that stops iterations when either an absolute tolerance is reached (for which we choose \(10^{-12}\)) or when the residual is reduced by a certain factor (here, \(10^{-3}\)).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classReductionControl.html">ReductionControl</a>                        reduction_control(100, 1e-12, 1e-3);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(reduction_control);</div><div class="line">  TrilinosWrappers::PreconditionAMG       precondition;</div><div class="line">  precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, precondition);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">            &lt;&lt; reduction_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">            &lt;&lt; reduction_control.last_step() &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemoutput_results"></a> </p><h4>ObstacleProblem::output_results</h4>
<p>We use the vtk-format for the output. The file contains the displacement and a numerical representation of the active set.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(</div><div class="line">    dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">    active_set_vector[index] = 1.;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output_vtk(<span class="stringliteral">&quot;output_&quot;</span> +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iteration, 3) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output_vtk);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemrun"></a> </p><h4>ObstacleProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is not very long, and in fact rather straightforward: in every iteration of the active set method, we assemble the linear system, solve it, update the active set and project the solution back to the feasible set, and then output the results. The iteration is terminated whenever the active set has not changed in the previous iteration.</p>
<p>The only trickier part is that we have to save the linear system (i.e., the matrix and right hand side) after assembling it in the first iteration. The reason is that this is the only step where we can access the linear system as built without any of the contact constraints active. We need this to compute the residual of the solution at other iterations, but in other iterations that linear system we form has the rows and columns that correspond to constrained degrees of freedom eliminated, and so we can no longer access the full residual of the original equation.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ObstacleProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old(active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 0; iteration &lt;= solution.size(); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from(system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"></div><div class="line">        solve();</div><div class="line">        update_solution_and_constraints();</div><div class="line">        output_results(iteration);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        active_set_old = active_set;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step41</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>And this is the main function. It follows the pattern of all other main functions. The call to initialize MPI exists because the Trilinos library upon which we build our linear solvers in this program requires it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"></div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-41/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>è¿è¡è¯¥ç¨åºä¼äº§çè¿æ ·çè¾åºã</p>
<div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Total number of cells: 21845</div><div class="line">Number of degrees of freedom: 16641</div><div class="line"></div><div class="line"></div><div class="line">Newton iteration 0</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.310059 -&gt; 5.16619e-05 in 5 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 13164</div><div class="line">   Residual of the non-contact part of the system: 1.61863e-05</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line"></div><div class="line">Newton iteration 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 1.11987 -&gt; 0.00109377 in 6 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 12363</div><div class="line">   Residual of the non-contact part of the system: 3.9373</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">Newton iteration 17</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.00713308 -&gt; 2.29249e-06 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 0.000957525</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line"></div><div class="line">Newton iteration 18</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.000957525 -&gt; 2.8033e-07 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 2.8033e-07</div><div class="line">   Writing graphical output...</div></div><!-- fragment --><p>ä¸æ¦æ´»å¨éä¸åååï¼è¿­ä»£å°±ä¼ç»æï¼æ­¤æ¶å®æ5399ä¸ªåéèªç±åº¦ï¼ãä»£æ°åææ¡ä»¶æ¾ç¶å·¥ä½å¾å¾å¥½ï¼å ä¸ºæä»¬åªéè¦4-6æ¬¡CGè¿­ä»£æ¥è§£å³çº¿æ§ç³»ç»ï¼å°½ç®¡è¿ä¹ä¸æä»¬å¯¹çº¿æ§æ±è§£å¨çç²¾åº¦è¦æ±ä¸é«æå¾å¤§å³ç³»ï¼ã</p>
<p>æ´å·å¯ç¤ºæ§çæ¯çä¸è¿ä¸²çå¾å½¢è¾åºæä»¶ï¼æ¯ä¸æ­¥æ¾ç¤ºä¸æ¬¡ï¼æå·¦è¾¹ä¸æ æ¯è¿­ä»£çç¼å·ï¼ã</p>
<table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.00.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.03.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">6 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.06.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">9 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.09.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">12 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.12.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">15 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.15.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">18 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.18.png"/>
</div>
   </td></tr>
</table>
<p>å¾çæ¾ç¤ºï¼å¨ç¬¬ä¸æ­¥ä¸­ï¼è§£å³æ¹æ¡ï¼å¨æ²¡æä»»ä½çº¦ææ¡ä»¶çæåµä¸è¢«è®¡ç®åºæ¥çï¼æ¯å¦æ­¤çå¼¯æ²ï¼ä»¥è³äºå ä¹æ¯ä¸ä¸ªåé¨ç¹é½å¿é¡»è¢«åå¼¹å°é¶æ¢¯å½æ°ä¸ï¼äº§çä¸ä¸ªä¸è¿ç»­çè§£å³æ¹æ¡ãå¨æ´»å¨éè¿­ä»£çè¿ç¨ä¸­ï¼è¿ç§ä¸åå®éçèçå½¢ç¶è¢«å¹³æ»æäºï¼ä¸æä¸å±é¶æ¢¯çæ¥è§¦æ¶å¤±äºï¼è§£å³æ¹æ¡ä¹ç¨³å®ä¸æ¥ã</p>
<p>é¤æ­¤ä»¥å¤ï¼ç¨åºè¿è¾åºææ ¼ææ¥ä¹æ°çå¼ãè¯·è®°ä½ï¼è¿äºæ¯æ¥è§¦åï¼æä»¥å¨æ¥è§¦éä¸åªåºè¯¥æ¯æ­£çï¼èå¨æ¥è§¦éä¹å¤æ¯é¶ãå¦ä¸æ¹é¢ï¼å¦æä¸ä¸ªææ ¼ææ¥ä¹æ°å¨æ´»å¨éä¸æ¯è´çï¼é£ä¹è¿ä¸ªèªç±åº¦å¿é¡»ä»æ´»å¨éä¸å é¤ãä¸é¢çå¾çæ¾ç¤ºäºè¿­ä»£1ã9å18ä¸­çä¹æ°ï¼æä»¬ç¨çº¢è²åæ£è²è¡¨ç¤ºæ­£å¼ï¼èè²è¡¨ç¤ºè´å¼ã</p>
<table align="center">
<tr>
<td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.01.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.18.png"/>
</div>
   </td></tr>
<tr>
<td align="center">Iteration 1  </td><td align="center">Iteration 9  </td><td align="center">Iteration 18   </td></tr>
</table>
<p>å¾å®¹æçåºï¼æ­£å¼å¨æ¥è§¦éçåé¨å¾å¥½å°æ¶æä¸ºéåº¦çå¼ï¼å¨å°é¶çè¾¹ç¼æå¾å¤§çåä¸çåï¼æ­£å¦äººä»¬æææçé£æ ·ï¼ä»¥æ¯æé£éçèçå¤§æ²çï¼ï¼å¨æ´»å¨éçè¾¹ç¼ï¼ä¹æ°æåæ¯è´çï¼å¯¼è´éåç¼©å°ï¼ç´å°å¨è¿­ä»£18ï¼ä¸åæè´çä¹æ°ï¼ç®æ³å·²ç»æ¶æäºã</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>ä¸æ¬æç¨çä»»ä½ç¨åºä¸æ ·ï¼æè®¸å¤ææ¾çæ©å±åå®éªçå¯è½æ§ãç¬¬ä¸ä¸ªå¾æ¸æ¥ï¼å¼å¥èªéåºæ§ãæ¥è§¦é®é¢æ¯èªéåºç½æ ¼çä¸»è¦åéèï¼å ä¸ºè§£å³æ¹æ¡ææ²¿çå®ä¸å¤ªè§åççº¿ï¼èåéç¢ç©ä¹é´å»ºç«æ¥è§¦çå°æ¹ï¼åè§£å³æ¹æ¡éå¸¸åæ»çå¶ä»åºåï¼æèï¼å¨ç®åçæåµä¸ï¼å¨å®ä¸éç¢ç©æ¥è§¦çå°æ¹æ¯æå®çï¼ãå¨ç®åçç¨åºä¸­å å¥è¿ä¸ç¹åºè¯¥ä¸ä¼é æå¤ªå¤å°é¾ï¼ä½è¦ä¸ºæ­¤æ¾å°ä¸ä¸ªå¥½çè¯¯å·®ä¼°è®¡å¨å¹¶éæäºã</p>
<p>ä¸ä¸ªæ´å·æææ§çä»»å¡æ¯æ©å±å°3Dãè¿éçé®é¢ä¸æ¯ç®åå°è®©ä¸åé½å¨ä¸ç»´ä¸­è¿è¡ãç¸åï¼å½ä¸ä¸ªä¸ç»´ç©ä½åå½¢å¹¶ä¸ä¸ä¸ªéç¢ç©æ¥è§¦æ¶ï¼éç¢ç©å¹¶ä¸åè¿éçæåµé£æ ·å¨ååä½ä¸ºä¸ä¸ªçº¦æä½çåéåæ¥ä½ç¨ãç¸åï¼æ¥è§¦ååªä½ç¨äºç©ä½çè¾¹çãé£ä¹ä¸ç­å¼å°±ä¸å¨å¾®åæ¹ç¨ä¸­ï¼èå®éä¸å¨ï¼è¯ºä¼æ¼åï¼è¾¹çæ¡ä»¶ä¸­ï¼å°½ç®¡è¿å¯¼è´äºä¸ç§ç±»ä¼¼çååä¸ç­å¼ãå¨æ°å­¦ä¸ï¼è¿æå³çææ ¼ææ¥ä¹æ°åªå­å¨äºè¡¨é¢ï¼å½ç¶ï¼å¦ææ¹ä¾¿çè¯ï¼å®ä¹å¯ä»¥éè¿é¶æ©å±å°åä¸­ãå¨ç®åçç¨åºä¸­ï¼äººä»¬ä¸éè¦æç¡®å°å½¢æåå­å¨è¿ä¸ªææ ¼ææ¥ä¹æ°ã</p>
<p>å¯¹äºä¸ç»´æ¡ä¾æ¥è¯´ï¼å¦ä¸ä¸ªæè¶£çé®é¢æ¯èèææ©æ¦çæ¥è§¦é®é¢ãå¨å ä¹æ¯ä¸ªæºæ¢°è¿ç¨ä¸­ï¼æ©æ¦é½æå¾å¤§çå½±åãä¸ºäºå»ºæ¨¡ï¼æä»¬å¿é¡»èèå°æ¥è§¦é¢çåååºåãæä»¬è¿å¿é¡»æ³¨æå°ï¼æ©æ¦ç»æä»¬çé®é¢å¢å äºå¦ä¸ä¸ªéçº¿æ§ã</p>
<p>å¦ä¸ä¸ªä¸ç®åçä¿®æ¹æ¯å®ç°ä¸ä¸ªæ´å¤æçæææ³åï¼å¦éçº¿æ§å¼¹æ§æå¼¹å¡æ§ææè¡ä¸ºãè¿éçå°é¾å¨äºå¦ä½å¤çéè¿éçº¿æ§æææ³äº§ççé¢å¤éçº¿æ§ã</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="comment"> *                        University of Siegen, 2011, 2012</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ObstacleProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ObstacleProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">    <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>                  active_set;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> complete_system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diagonal_of_mass_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> contact_force;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> -10;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (p(0) &lt; -0.5)</div><div class="line">        <span class="keywordflow">return</span> -0.2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= -0.5 &amp;&amp; p(0) &lt; 0.0)</div><div class="line">        <span class="keywordflow">return</span> -0.4;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt; 0.5)</div><div class="line">        <span class="keywordflow">return</span> -0.6;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> -0.8;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ObstacleProblem&lt;dim&gt;::ObstacleProblem()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line">    active_set.set_size(dof_handler.n_dofs());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    system_matrix.reinit(dsp);</div><div class="line">    complete_system_matrix.reinit(dsp);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.locally_owned_dofs();</div><div class="line">    solution.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line">    contact_force.reinit(solution_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(dsp);</div><div class="line">    assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line">    diagonal_of_mass_matrix.reinit(solution_index_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; solution.size(); j++)</div><div class="line">      diagonal_of_mass_matrix(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree + 1);</div><div class="line">    RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell_rhs(i) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                 right_hand_side.value(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point)) *</div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a> quadrature_formula;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">              (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">               fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               mass_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(</div><div class="line">      <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(dof_handler.n_dofs()));</div><div class="line">    complete_system_matrix.residual(lambda, solution, complete_system_rhs);</div><div class="line"></div><div class="line">    contact_force = lambda;</div><div class="line">    contact_force.scale(diagonal_of_mass_matrix);</div><div class="line">    contact_force *= -1;</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    active_set.clear();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">    std::vector&lt;bool&gt;   dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dof_handler.get_fe().n_dofs_per_cell() == cell-&gt;n_vertices(),</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index(v, 0);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">            dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value(cell-&gt;vertex(v));</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution(dof_index);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (lambda(dof_index) + penalty_parameter *</div><div class="line">                                    diagonal_of_mass_matrix(dof_index) *</div><div class="line">                                    (solution_value - obstacle_value) &lt;</div><div class="line">              0)</div><div class="line">            {</div><div class="line">              active_set.add_index(dof_index);</div><div class="line">              constraints.<a class="code" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a>(dof_index);</div><div class="line">              constraints.<a class="code" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a>(dof_index, obstacle_value);</div><div class="line"></div><div class="line">              solution(dof_index) = obstacle_value;</div><div class="line"></div><div class="line">              lambda(dof_index) = 0;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">              &lt;&lt; lambda.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>                        reduction_control(100, 1e-12, 1e-3);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(reduction_control);</div><div class="line">    TrilinosWrappers::PreconditionAMG       precondition;</div><div class="line">    precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, precondition);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">              &lt;&lt; reduction_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">              &lt;&lt; reduction_control.last_step() &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(</div><div class="line">      dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">      active_set_vector[index] = 1.;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output_vtk(<span class="stringliteral">&quot;output_&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iteration, 3) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output_vtk);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ObstacleProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old(active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 0; iteration &lt;= solution.size(); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from(system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"></div><div class="line">        solve();</div><div class="line">        update_solution_and_constraints();</div><div class="line">        output_results(iteration);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        active_set_old = active_set;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step41</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"></div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
