<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_23.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-23 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-23 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Timediscretization">Time discretization</a>
      <ul>
        <li><a href="#MethodoflinesorRothesmethod">Method of lines or Rothe's method?</a>
        <li><a href="#Rothesmethod">Rothe's method!</a>
      </ul>
        <li><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Energyconservation">Energy conservation</a>
        <li><a href="#WhoareCourantFriedrichsandLewy">Who are Courant, Friedrichs, and Lewy?</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeWaveEquationcodeclass">The <code>WaveEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeWaveEquationcodeclass">Implementation of the <code>WaveEquation</code> class</a>
      <ul>
        <li><a href="#WaveEquationsetup_system">WaveEquation::setup_system</a>
        <li><a href="#WaveEquationsolve_uandWaveEquationsolve_v">WaveEquation::solve_u and WaveEquation::solve_v</a>
        <li><a href="#WaveEquationoutput_results">WaveEquation::output_results</a>
        <li><a href="#WaveEquationrun">WaveEquation::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>This is the first of a number of tutorial programs that will finally cover "real" time-dependent problems, not the slightly odd form of time dependence found in <a class="el" href="step_18.html">step-18</a> or the DAE model of <a class="el" href="step_21.html">step-21</a>. In particular, this program introduces the wave equation in a bounded domain. Later, <a class="el" href="step_24.html">step-24</a> will consider an example of absorbing boundary conditions, and <a class="el" href="step_25.html">step-25</a> a kind of nonlinear wave equation producing solutions called solitons.</p>
<p>The wave equation in its prototypical form reads as follows: find \(u(x,t), x\in\Omega, t\in[0,T]\) that satisfies </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial^2 u}{\partial t^2} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ \frac{\partial u(x,0)}{\partial t} &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}
</p>
<p> Note that since this is an equation with second-order time derivatives, we need to pose two initial conditions, one for the value and one for the time derivative of the solution.</p>
<p>Physically, the equation describes the motion of an elastic medium. In 2-d, one can think of how a membrane moves if subjected to a force. The Dirichlet boundary conditions above indicate that the membrane is clamped at the boundary at a height \(g(x,t)\) (this height might be moving as well &mdash; think of people holding a blanket and shaking it up and down). The first initial condition equals the initial deflection of the membrane, whereas the second one gives its velocity. For example, one could think of pushing the membrane down with a finger and then letting it go at \(t=0\) (nonzero deflection but zero initial velocity), or hitting it with a hammer at \(t=0\) (zero deflection but nonzero velocity). Both cases would induce motion in the membrane.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p><a class="anchor" id="MethodoflinesorRothesmethod"></a></p><h4>Method of lines or Rothe's method?</h4>
<p>There is a long-standing debate in the numerical analysis community over whether a discretization of time dependent equations should involve first discretizing the time variable leading to a stationary PDE at each time step that is then solved using standard finite element techniques (this is called the Rothe method), or whether one should first discretize the spatial variables, leading to a large system of ordinary differential equations that can then be handled by one of the usual ODE solvers (this is called the method of lines).</p>
<p>Both of these methods have advantages and disadvantages. Traditionally, people have preferred the method of lines, since it allows to use the very well developed machinery of high-order ODE solvers available for the rather stiff ODEs resulting from this approach, including step length control and estimation of the temporal error.</p>
<p>On the other hand, Rothe's method becomes awkward when using higher-order time stepping method, since one then has to write down a PDE that couples the solution of the present time step not only with that at the previous time step, but possibly also even earlier solutions, leading to a significant number of terms.</p>
<p>For these reasons, the method of lines was the method of choice for a long time. However, it has one big drawback: if we discretize the spatial variable first, leading to a large ODE system, we have to choose a mesh once and for all. If we are willing to do this, then this is a legitimate and probably superior approach.</p>
<p>If, on the other hand, we are looking at the wave equation and many other time dependent problems, we find that the character of a solution changes as time progresses. For example, for the wave equation, we may have a single wave travelling through the domain, where the solution is smooth or even constant in front of and behind the wave &mdash; adaptivity would be really useful for such cases, but the key is that the area where we need to refine the mesh changes from time step to time step!</p>
<p>If we intend to go that way, i.e. choose a different mesh for each time step (or set of time steps), then the method of lines is not appropriate any more: instead of getting one ODE system with a number of variables equal to the number of unknowns in the finite element mesh, our number of unknowns now changes all the time, a fact that standard ODE solvers are certainly not prepared to deal with at all. On the other hand, for the Rothe method, we just get a PDE for each time step that we may choose to discretize independently of the mesh used for the previous time step; this approach is not without perils and difficulties, but at least is a sensible and well-defined procedure.</p>
<p>For all these reasons, for the present program, we choose to use the Rothe method for discretization, i.e. we first discretize in time and then in space. We will not actually use adaptive meshes at all, since this involves a large amount of additional code, but we will comment on this some more in the <a href="#Results">results section below</a>.</p>
<p><a class="anchor" id="Rothesmethod"></a></p><h4>Rothe's method!</h4>
<p>Given these considerations, here is how we will proceed: let us first define a simple time stepping method for this second order problem, and then in a second step do the spatial discretization, i.e. we will follow Rothe's approach.</p>
<p>For the first step, let us take a little detour first: in order to discretize a second time derivative, we can either discretize it directly, or we can introduce an additional variable and transform the system into a first order system. In many cases, this turns out to be equivalent, but dealing with first order systems is often simpler. To this end, let us introduce </p><p class="formulaDsp">
\[ v = \frac{\partial u}{\partial t}, \]
</p>
<p> and call this variable the <em>velocity</em> for obvious reasons. We can then reformulate the original wave equation as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial u}{\partial t} - v &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times [0,T], \\ \frac{\partial v}{\partial t} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ v(x,0) &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}
</p>
<p> The advantage of this formulation is that it now only contains first time derivatives for both variables, for which it is simple to write down time stepping schemes. Note that we do not have boundary conditions for \(v\) at first. However, we could enforce \(v=\frac{\partial g}{\partial t}\) on the boundary. It turns out in numerical examples that this is actually necessary: without doing so the solution doesn't look particularly wrong, but the Crank-Nicolson scheme does not conserve energy if one doesn't enforce these boundary conditions.</p>
<p>With this formulation, let us introduce the following time discretization where a superscript \(n\) indicates the number of a time step and \(k=t_n-t_{n-1}\) is the length of the present time step: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{u^n - u^{n-1}}{k} - \left[\theta v^n + (1-\theta) v^{n-1}\right] &amp;=&amp; 0, \\ \frac{v^n - v^{n-1}}{k} - \Delta\left[\theta u^n + (1-\theta) u^{n-1}\right] &amp;=&amp; \theta f^n + (1-\theta) f^{n-1}. \end{eqnarray*}
</p>
<p> Note how we introduced a parameter \(\theta\) here. If we chose \(\theta=0\), for example, the first equation would reduce to \(\frac{u^n - u^{n-1}}{k} - v^{n-1} = 0\), which is well-known as the forward or explicit Euler method. On the other hand, if we set \(\theta=1\), then we would get \(\frac{u^n - u^{n-1}}{k} - v^n = 0\), which corresponds to the backward or implicit Euler method. Both these methods are first order accurate methods. They are simple to implement, but they are not really very accurate.</p>
<p>The third case would be to choose \(\theta=\frac 12\). The first of the equations above would then read \(\frac{u^n - u^{n-1}}{k} - \frac 12 \left[v^n + v^{n-1}\right] = 0\). This method is known as the Crank-Nicolson method and has the advantage that it is second order accurate. In addition, it has the nice property that it preserves the energy in the solution (physically, the energy is the sum of the kinetic energy of the particles in the membrane plus the potential energy present due to the fact that it is locally stretched; this quantity is a conserved one in the continuous equation, but most time stepping schemes do not conserve it after time discretization). Since \(v^n\) also appears in the equation for \(u^n\), the Crank-Nicolson scheme is also implicit.</p>
<p>In the program, we will leave \(\theta\) as a parameter, so that it will be easy to play with it. The results section will show some numerical evidence comparing the different schemes.</p>
<p>The equations above (called the <em>semidiscretized</em> equations because we have only discretized the time, but not space), can be simplified a bit by eliminating \(v^n\) from the first equation and rearranging terms. We then get </p><p class="formulaDsp">
\begin{eqnarray*} \left[ 1-k^2\theta^2\Delta \right] u^n &amp;=&amp; \left[ 1+k^2\theta(1-\theta)\Delta\right] u^{n-1} + k v^{n-1} + k^2\theta\left[\theta f^n + (1-\theta) f^{n-1}\right],\\ v^n &amp;=&amp; v^{n-1} + k\Delta\left[ \theta u^n + (1-\theta) u^{n-1}\right] + k\left[\theta f^n + (1-\theta) f^{n-1}\right]. \end{eqnarray*}
</p>
<p> In this form, we see that if we are given the solution \(u^{n-1},v^{n-1}\) of the previous timestep, that we can then solve for the variables \(u^n,v^n\) separately, i.e. one at a time. This is convenient. In addition, we recognize that the operator in the first equation is positive definite, and the second equation looks particularly simple.</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>We have now derived equations that relate the approximate (semi-discrete) solution \(u^n(x)\) and its time derivative \(v^n(x)\) at time \(t_n\) with the solutions \(u^{n-1}(x),v^{n-1}(x)\) of the previous time step at \(t_{n-1}\). The next step is to also discretize the spatial variable using the usual finite element methodology. To this end, we multiply each equation with a test function, integrate over the entire domain, and integrate by parts where necessary. This leads to </p><p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \\ (v^n,\varphi) &amp;=&amp; (v^{n-1},\varphi) - k\left[ \theta (\nabla u^n,\nabla\varphi) + (1-\theta) (\nabla u^{n-1},\nabla \varphi)\right] + k \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}
</p>
<p>It is then customary to approximate \(u^n(x) \approx u^n_h(x) = \sum_i U_i^n\phi_i^n(x)\), where \(\phi_i^n(x)\) are the shape functions used for the discretization of the \(n\)-th time step and \(U_i^n\) are the unknown nodal values of the solution. Similarly, \(v^n(x) \approx v^n_h(x) = \sum_i V_i^n\phi_i^n(x)\). Finally, we have the solutions of the previous time step, \(u^{n-1}(x) \approx u^{n-1}_h(x) = \sum_i U_i^{n-1}\phi_i^{n-1}(x)\) and \(v^{n-1}(x) \approx v^{n-1}_h(x) = \sum_i V_i^{n-1}\phi_i^{n-1}(x)\). Note that since the solution of the previous time step has already been computed by the time we get to time step \(n\), \(U^{n-1},V^{n-1}\) are known. Furthermore, note that the solutions of the previous step may have been computed on a different mesh, so we have to use shape functions \(\phi^{n-1}_i(x)\).</p>
<p>If we plug these expansions into above equations and test with the test functions from the present mesh, we get the following linear system: </p><p class="formulaDsp">
\begin{eqnarray*} (M^n + k^2\theta^2 A^n)U^n &amp;=&amp; M^{n,n-1}U^{n-1} - k^2\theta(1-\theta) A^{n,n-1}U^{n-1} + kM^{n,n-1}V^{n-1} + k^2\theta \left[ \theta F^n + (1-\theta) F^{n-1} \right], \\ M^nV^n &amp;=&amp; M^{n,n-1}V^{n-1} - k\left[ \theta A^n U^n + (1-\theta) A^{n,n-1} U^{n-1}\right] + k \left[ \theta F^n + (1-\theta) F^{n-1} \right], \end{eqnarray*}
</p>
<p> where </p><p class="formulaDsp">
\begin{eqnarray*} M^n_{ij} &amp;=&amp; (\phi_i^n, \phi_j^n), \\ A^n_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^n), \\ M^{n,n-1}_{ij} &amp;=&amp; (\phi_i^n, \phi_j^{n-1}), \\ A^{n,n-1}_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^{n-1}), \\ F^n_{i} &amp;=&amp; (f^n,\phi_i^n), \\ F^{n-1}_{i} &amp;=&amp; (f^{n-1},\phi_i^n). \end{eqnarray*}
</p>
<p>If we solve these two equations, we can move the solution one step forward and go on to the next time step.</p>
<p>It is worth noting that if we choose the same mesh on each time step (as we will in fact do in the program below), then we have the same shape functions on time step \(n\) and \(n-1\), i.e. \(\phi^n_i=\phi_i^{n-1}=\phi_i\). Consequently, we get \(M^n=M^{n,n-1}=M\) and \(A^n=A^{n,n-1}=A\). On the other hand, if we had used different shape functions, then we would have to compute integrals that contain shape functions defined on two meshes. This is a somewhat messy process that we omit here, but that is treated in some detail in <a class="el" href="step_28.html">step-28</a>.</p>
<p>Under these conditions (i.e. a mesh that doesn't change), one can optimize the solution procedure a bit by basically eliminating the solution of the second linear system. We will discuss this in the introduction of the <a class="el" href="step_25.html">step-25</a> program.</p>
<p><a class="anchor" id="Energyconservation"></a></p><h3>Energy conservation</h3>
<p>One way to compare the quality of a time stepping scheme is to see whether the numerical approximation preserves conservation properties of the continuous equation. For the wave equation, the natural quantity to look at is the energy. By multiplying the wave equation by \(u_t\), integrating over \(\Omega\), and integrating by parts where necessary, we find that </p><p class="formulaDsp">
\[ \frac{d}{d t} \left[\frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx\right] = \int_\Omega f \frac{\partial u}{\partial t} \; dx + \int_{\partial\Omega} n\cdot\nabla u \frac{\partial g}{\partial t} \; dx. \]
</p>
<p> By consequence, in absence of body forces and constant boundary values, we get that </p><p class="formulaDsp">
\[ E(t) = \frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx \]
</p>
<p> is a conserved quantity, i.e. one that doesn't change with time. We will compute this quantity after each time step. It is straightforward to see that if we replace \(u\) by its finite element approximation, and \(\frac{\partial u}{\partial t}\) by the finite element approximation of the velocity \(v\), then </p><p class="formulaDsp">
\[ E(t_n) = \frac 12 \left&lt;V^n, M^n V^n\right&gt; + \frac 12 \left&lt;U^n, A^n U^n\right&gt;. \]
</p>
<p> As we will see in the results section, the Crank-Nicolson scheme does indeed conserve the energy, whereas neither the forward nor the backward Euler scheme do.</p>
<p><a class="anchor" id="WhoareCourantFriedrichsandLewy"></a></p><h3>Who are Courant, Friedrichs, and Lewy?</h3>
<p>One of the reasons why the wave equation is nasty to solve numerically is that explicit time discretizations are only stable if the time step is small enough. In particular, it is coupled to the spatial mesh width \(h\). For the lowest order discretization we use here, the relationship reads </p><p class="formulaDsp">
\[ k\le \frac hc \]
</p>
<p> where \(c\) is the wave speed, which in our formulation of the wave equation has been normalized to one. Consequently, unless we use the implicit schemes with \(\theta&gt;0\), our solutions will not be numerically stable if we violate this restriction. Implicit schemes do not have this restriction for stability, but they become inaccurate if the time step is too large.</p>
<p>This condition was first recognized by Courant, Friedrichs, and Lewy &mdash; in 1928, long before computers became available for numerical computations! (This result appeared in the German language article R. Courant, K. Friedrichs and H. Lewy: <em>&Uuml;ber die partiellen Differenzengleichungen der mathematischen Physik</em>, Mathematische Annalen, vol. 100, no. 1, pages 32-74, 1928.) This condition on the time step is most frequently just referred to as the <em>CFL</em> condition. Intuitively, the CFL condition says that the time step must not be larger than the time it takes a wave to cross a single cell.</p>
<p>In the program, we will refine the square \([-1,1]^2\) seven times uniformly, giving a mesh size of \(h=\frac 1{64}\), which is what we set the time step to. The fact that we set the time step and mesh size individually in two different places is error prone: it is too easy to refine the mesh once more but forget to also adjust the time step. <a class="el" href="step_24.html">step-24</a> shows a better way how to keep these things in sync.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>Although the program has all the hooks to deal with nonzero initial and boundary conditions and body forces, we take a simple case where the domain is a square \([-1,1]^2\) and </p><p class="formulaDsp">
\begin{eqnarray*} f &amp;=&amp; 0, \\ u_0 &amp;=&amp; 0, \\ u_1 &amp;=&amp; 0, \\ g &amp;=&amp; \left\{\begin{matrix}\sin (4\pi t) &amp;\qquad&amp; \text{for }\ t\le \frac 12, x=-1, -\frac 13&lt;y&lt;\frac 13 \\ 0 &amp;&amp;\text{otherwise} \end{matrix} \right. \end{eqnarray*}
</p>
<p> This corresponds to a membrane initially at rest and clamped all around, where someone is waving a part of the clamped boundary once up and down, thereby shooting a wave into the domain.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with the usual assortment of include files that we've seen in so many of the previous tests:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Here are the only three include files of some new interest: The first one is already used, for example, for the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> and <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> functions. However, we here use another function in that class, <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> to compute our initial values as the \(L^2\) projection of the continuous initial values. Furthermore, we use <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a> to generate the integrals \((f^n,\phi^n_i)\). These were previously always generated by hand in <code>assemble_system</code> or similar functions in application code. However, we're too lazy to do that here, so simply use a library function:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>In a very similar vein, we are also too lazy to write the code to assemble mass and Laplace matrices, although it would have only taken copying the relevant code from any number of previous tutorial programs. Rather, we want to focus on the things that are truly new to this program and therefore use the <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a> and <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a> functions. They are declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, here is an include file that contains all sorts of tool functions that one sometimes needs. In particular, we need the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> class that, given an integer argument, returns a string representation of it. It is particularly useful since it allows for a second parameter indicating the number of digits to which we want the result padded with leading zeros. We will use this to write output files that have the form <code>solution-XXX.vtu</code> where <code>XXX</code> denotes the number of the time step and always consists of three digits even if we are still in the single or double digit time steps.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeWaveEquationcodeclass"></a> </p><h3>The <code>WaveEquation</code> class</h3>
<p>Next comes the declaration of the main class. It's public interface of functions is like in most of the other tutorial programs. Worth mentioning is that we now have to store four matrices instead of one: the mass matrix \(M\), the Laplace matrix \(A\), the matrix \(M+k^2\theta^2A\) used for solving for \(U^n\), and a copy of the mass matrix with boundary conditions applied used for solving for \(V^n\). Note that it is a bit wasteful to have an additional copy of the mass matrix around. We will discuss strategies for how to avoid this in the section on possible improvements.</p>
<p>Likewise, we need solution vectors for \(U^n,V^n\) as well as for the corresponding vectors at the previous time step, \(U^{n-1},V^{n-1}\). The <code>system_rhs</code> will be used for whatever right hand side vector we have when solving one of the two linear systems in each time step. These will be solved in the two functions <code>solve_u</code> and <code>solve_v</code>.</p>
<p>Finally, the variable <code>theta</code> is used to indicate the parameter \(\theta\) that is used to define which time stepping scheme to use, as explained in the introduction. The rest is self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>WaveEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WaveEquation();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> solve_u();</div><div class="line">  <span class="keywordtype">void</span> solve_v();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_u, solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> old_solution_u, old_solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">double</span>       time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial and boundary values for both the solution \(u\) and its time derivative \(v\), as well as a right hand side class. We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not be a surprise.</p>
<p>Let's start with initial values and choose zero for both the value \(u\) as well as its time derivative, the velocity \(v\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Secondly, we have the right hand side forcing term. Boring as we are, we choose zero here as well:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Finally, we have boundary values for \(u\) and \(v\). They are as described in the introduction, one being the time derivative of the other:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">        (p[1] &gt; -1. / 3))</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">        (p[1] &gt; -1. / 3))</div><div class="line">      <span class="keywordflow">return</span> (std::cos(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>) * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeWaveEquationcodeclass"></a> </p><h3>Implementation of the <code>WaveEquation</code> class</h3>
<p>The implementation of the actual logic is actually fairly short, since we relegate things like assembling the matrices and right hand side vectors to the library. The rest boils down to not much more than 130 lines of actual code, a significant fraction of which is boilerplate code that can be taken from previous example programs (e.g. the functions that solve linear systems, or that generate output).</p>
<p>Let's start with the constructor (for an explanation of the choice of time step, see the section on Courant, Friedrichs, and Lewy in the introduction):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">WaveEquation&lt;dim&gt;::WaveEquation()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time_step(1. / 64)</div><div class="line">  , time(time_step)</div><div class="line">  , timestep_number(1)</div><div class="line">  , theta(0.5)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsetup_system"></a> </p><h4>WaveEquation::setup_system</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div></div><!-- fragment --><p>Then comes a block where we have to initialize the 3 matrices we need in the course of the program: the mass matrix, the Laplace matrix, and the matrix \(M+k^2\theta^2A\) used when solving for \(U^n\) in each time step.</p>
<p>When setting up these matrices, note that they all make use of the same sparsity pattern object. Finally, the reason why matrices and sparsity patterns are separate objects in deal.II (unlike in many other finite element or linear algebra classes) becomes clear: in a significant fraction of applications, one has to hold several matrices that happen to have the same sparsity pattern, and there is no reason for them not to share this information, rather than re-building and wasting memory on it several times.</p>
<p>After initializing all of these matrices, we call library functions that build the Laplace and mass matrices. All they need is a <a class="el" href="classDoFHandler.html">DoFHandler</a> object and a quadrature formula object that is to be used for numerical integration. Note that in many respects these functions are better than what we would usually do in application programs, for example because they automatically parallelize building the matrices if multiple processors are available in a machine: for more information see the documentation of <a class="el" href="namespaceWorkStream.html">WorkStream</a> or the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. The matrices for solving linear systems will be filled in the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> method because we need to re-apply boundary conditions every time step.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">laplace_matrix.reinit(sparsity_pattern);</div><div class="line">matrix_u.reinit(sparsity_pattern);</div><div class="line">matrix_v.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"><a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line"><a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                     laplace_matrix);</div></div><!-- fragment --><p>The rest of the function is spent on setting vector sizes to the correct value. The final line closes the hanging node constraints object. Since we work on a uniformly refined mesh, no constraints exist or have been computed (i.e. there was no need to call <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a> as in other programs), but we need a constraints object in one place further down below anyway.</p>
<div class="fragment"><div class="line">  solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsolve_uandWaveEquationsolve_v"></a> </p><h4>WaveEquation::solve_u and WaveEquation::solve_v</h4>
<p>The next two functions deal with solving the linear systems associated with the equations for \(U^n\) and \(V^n\). Both are not particularly interesting as they pretty much follow the scheme used in all the previous tutorial programs.</p>
<p>One can make little experiments with preconditioners for the two matrices we have to invert. As it turns out, however, for the matrices at hand here, using Jacobi or SSOR preconditioners reduces the number of iterations necessary to solve the linear system slightly, but due to the cost of applying the preconditioner it is no win in terms of run-time. It is not much of a loss either, but let's keep it simple and just do without:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(matrix_u, solution_u, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(matrix_v, solution_v, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationoutput_results"></a> </p><h4>WaveEquation::output_results</h4>
<p>Likewise, the following function is pretty much what we've done before. The only thing worth mentioning is how here we generate a string representation of the time step number padded with leading zeros to 3 character length using the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> function's second argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div></div><!-- fragment --><p>Like <a class="el" href="step_15.html">step-15</a>, since we write output at every time step (and the system we have to solve is relatively easy), we instruct <a class="el" href="classDataOut.html">DataOut</a> to use the zlib compression algorithm that is optimized for speed instead of disk usage since otherwise plotting the output becomes a bottleneck:</p>
<div class="fragment"><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">  vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">    DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(vtk_flags);</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationrun"></a> </p><h4>WaveEquation::run</h4>
<p>The following is really the only interesting function of the program. It contains the loop over all time steps, but before we get to that we have to set up the grid, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices. In addition, we have to somehow get started with initial values. To this end, we use the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function that takes an object that describes a continuous function and computes the \(L^2\) projection of this function onto the finite element space described by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. Can't be any simpler than that:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WaveEquation&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  setup_system();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                       constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                       InitialValuesU&lt;dim&gt;(),</div><div class="line">                       old_solution_u);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                       constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                       InitialValuesV&lt;dim&gt;(),</div><div class="line">                       old_solution_v);</div></div><!-- fragment --><p>The next thing is to loop over all the time steps until we reach the end time ( \(T=5\) in this case). In each time step, we first have to solve for \(U^n\), using the equation \((M^n + k^2\theta^2 A^n)U^n =\) \((M^{n,n-1} - k^2\theta(1-\theta) A^{n,n-1})U^{n-1} + kM^{n,n-1}V^{n-1} +\) \(k\theta \left[k \theta F^n + k(1-\theta) F^{n-1} \right]\). Note that we use the same mesh for all time steps, so that \(M^n=M^{n,n-1}=M\) and \(A^n=A^{n,n-1}=A\). What we therefore have to do first is to add up \(MU^{n-1} - k^2\theta(1-\theta) AU^{n-1} + kMV^{n-1}\) and the forcing terms, and put the result into the <code>system_rhs</code> vector. (For these additions, we need a temporary vector that we declare before the loop to avoid repeated memory allocations in each time step.)</p>
<p>The one thing to realize here is how we communicate the time variable to the object describing the right hand side: each object derived from the <a class="el" href="classFunction.html">Function</a> class has a time field that can be set using the <a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">Function::set_time</a> and read by <a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">Function::get_time</a>. In essence, using this mechanism, all functions of space and time are therefore considered functions of space evaluated at a particular time. This matches well what we typically need in finite element programs, where we almost always work on a single time step at a time, and where it never happens that, for example, one would like to evaluate a space-time function for all times at any given spatial location.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution_u.size());</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> forcing_terms(solution_u.size());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; time &lt;= 5; time += time_step, ++timestep_number)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(system_rhs, old_solution_u);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">    system_rhs.add(time_step, tmp);</div><div class="line"></div><div class="line">    laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">    system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp);</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">    rhs_function.set_time(time);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                        rhs_function,</div><div class="line">                                        tmp);</div><div class="line">    forcing_terms = tmp;</div><div class="line">    forcing_terms *= theta * time_step;</div><div class="line"></div><div class="line">    rhs_function.set_time(time - time_step);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                        rhs_function,</div><div class="line">                                        tmp);</div><div class="line"></div><div class="line">    forcing_terms.add((1 - theta) * time_step, tmp);</div><div class="line"></div><div class="line">    system_rhs.add(theta * time_step, forcing_terms);</div></div><!-- fragment --><p>After so constructing the right hand side vector of the first equation, all we have to do is apply the correct boundary values. As for the right hand side, this is a space-time function evaluated at a particular time, which we interpolate at boundary nodes and then use the result to apply boundary values as we usually do. The result is then handed off to the solve_u() function:</p>
<div class="fragment"><div class="line">{</div><div class="line">  BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">  boundary_values_u_function.set_time(time);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           boundary_values_u_function,</div><div class="line">                                           boundary_values);</div></div><!-- fragment --><p>The matrix for solve_u() is the same in every time steps, so one could think that it is enough to do this only once at the beginning of the simulation. However, since we need to apply boundary values to the linear system (which eliminate some matrix rows and columns and give contributions to the right hand side), we have to refill the matrix in every time steps before we actually apply boundary data. The actual content is very simple: it is the sum of the mass matrix and a weighted Laplace matrix:</p>
<div class="fragment"><div class="line">  matrix_u.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  matrix_u.add(theta * theta * time_step * time_step, laplace_matrix);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     matrix_u,</div><div class="line">                                     solution_u,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line">solve_u();</div></div><!-- fragment --><p>The second step, i.e. solving for \(V^n\), works similarly, except that this time the matrix on the left is the mass matrix (which we copy again in order to be able to apply boundary conditions, and the right hand side is \(MV^{n-1} - k\left[ \theta A U^n + (1-\theta) AU^{n-1}\right]\) plus forcing terms. Boundary values are applied in the same way as before, except that now we have to use the BoundaryValuesV class:</p>
<div class="fragment"><div class="line">laplace_matrix.vmult(system_rhs, solution_u);</div><div class="line">system_rhs *= -theta * time_step;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">system_rhs += tmp;</div><div class="line"></div><div class="line">laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">system_rhs.add(-time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">system_rhs += forcing_terms;</div><div class="line"></div><div class="line">{</div><div class="line">  BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">  boundary_values_v_function.set_time(time);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           boundary_values_v_function,</div><div class="line">                                           boundary_values);</div><div class="line">  matrix_v.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     matrix_v,</div><div class="line">                                     solution_v,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line">solve_v();</div></div><!-- fragment --><p>Finally, after both solution components have been computed, we output the result, compute the energy in the solution, and go on to the next time step after shifting the present solution into the vectors that hold the solution at the previous time step. Note the function <a class="el" href="classSparseMatrix.html#a56d106dfe8792db57f2d6e60bdfe63e1">SparseMatrix::matrix_norm_square</a> that can compute \(\left&lt;V^n,MV^n\right&gt;\) and \(\left&lt;U^n,AU^n\right&gt;\) in one step, saving us the expense of a temporary vector and several lines of code:</p>
<div class="fragment"><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square(solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square(solution_u)) /</div><div class="line">                       2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step23</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>What remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"></div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When the program is run, it produces the following output: </p><div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Number of degrees of freedom: 16641</div><div class="line"></div><div class="line">Time step 1 at t=0.015625</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 22 CG iterations.</div><div class="line">   Total energy: 1.17887</div><div class="line">Time step 2 at t=0.03125</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 2.9655</div><div class="line">Time step 3 at t=0.046875</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 4.33761</div><div class="line">Time step 4 at t=0.0625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 5.35499</div><div class="line">Time step 5 at t=0.078125</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 6.18652</div><div class="line">Time step 6 at t=0.09375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 6.6799</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Time step 31 at t=0.484375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 21.9068</div><div class="line">Time step 32 at t=0.5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.3394</div><div class="line">Time step 33 at t=0.515625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Time step 319 at t=4.98438</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line">Time step 320 at t=5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div></div><!-- fragment --><p>What we see immediately is that the energy is a constant at least after \(t=\frac 12\) (until which the boundary source term \(g\) is nonzero, injecting energy into the system).</p>
<p>In addition to the screen output, the program writes the solution of each time step to an output file. If we process them adequately and paste them into a movie, we get the following:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-23.movie.gif" alt="Animation of the solution of step 23."/>
</div>
<p>The movie shows the generated wave nice traveling through the domain and back, being reflected at the clamped boundary. Some numerical noise is trailing the wave, an artifact of a too-large mesh size that can be reduced by reducing the mesh width and the time step.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>If you want to explore a bit, try out some of the following things: </p><ul>
<li>
<p class="startli">Varying \(\theta\). This gives different time stepping schemes, some of which are stable while others are not. Take a look at how the energy evolves.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Different initial and boundary conditions, right hand sides.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">More complicated domains or more refined meshes. Remember that the time step needs to be bounded by the mesh width, so changing the mesh should always involve also changing the time step. We will come back to this issue in <a class="el" href="step_24.html">step-24</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Variable coefficients: In real media, the wave speed is often variable. In particular, the "real" wave equation in realistic media would read </p><p class="formulaDsp">
\[ \rho(x) \frac{\partial^2 u}{\partial t^2} - \nabla \cdot a(x) \nabla u = f, \]
</p>
<p> where \(\rho(x)\) is the density of the material, and \(a(x)\) is related to the stiffness coefficient. The wave speed is then \(c=\sqrt{a/\rho}\).</p>
<p>To make such a change, we would have to compute the mass and Laplace matrices with a variable coefficient. Fortunately, this isn't too hard: the functions <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a> and <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a> have additional default parameters that can be used to pass non-constant coefficient functions to them. The required changes are therefore relatively small. On the other hand, care must be taken again to make sure the time step is within the allowed range.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In the in-code comments, we discussed the fact that the matrices for solving for \(U^n\) and \(V^n\) need to be reset in every time because of boundary conditions, even though the actual content does not change. It is possible to avoid copying by not eliminating columns in the linear systems, which is implemented by appending a <code>false</code> argument to the call: </p><div class="fragment"><div class="line"><a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                   matrix_u,</div><div class="line">                                   solution_u,</div><div class="line">                                   system_rhs,</div><div class="line">                                   <span class="keyword">false</span>);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">deal.II being a library that supports adaptive meshes it would of course be nice if this program supported change the mesh every few time steps. Given the structure of the solution &mdash; a wave that travels through the domain &mdash; it would seem appropriate if we only refined the mesh where the wave currently is, and not simply everywhere. It is intuitively clear that we should be able to save a significant amount of cells this way. (Though upon further thought one realizes that this is really only the case in the initial stages of the simulation. After some time, for wave phenomena, the domain is filled with reflections of the initial wave going in every direction and filling every corner of the domain. At this point, there is in general little one can gain using local mesh refinement.)</p>
<p>To make adaptively changing meshes possible, there are basically two routes. The "correct" way would be to go back to the weak form we get using Rothe's method. For example, the first of the two equations to be solved in each time step looked like this: </p><p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}
</p>
<p> Now, note that we solve for \(u^n\) on mesh \({\mathbb T}^n\), and consequently the test functions \(\varphi\) have to be from the space \(V_h^n\) as well. As discussed in the introduction, terms like \((u^{n-1},\varphi)\) then require us to integrate the solution of the previous step (which may have been computed on a different mesh \({\mathbb T}^{n-1}\)) against the test functions of the current mesh, leading to a matrix \(M^{n,n-1}\). This process of integrating shape functions from different meshes is, at best, awkward. It can be done but because it is difficult to ensure that \({\mathbb T}^{n-1}\) and \({\mathbb T}^{n}\) differ by at most one level of refinement, one has to recursively match cells from both meshes. It is feasible to do this, but it leads to lengthy and not entirely obvious code.</p>
<p>The second approach is the following: whenever we change the mesh, we simply interpolate the solution from the last time step on the old mesh to the new mesh, using the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class. In other words, instead of the equation above, we would solve </p><p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (I^n u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla I^n u^{n-1},\nabla \varphi) + k(I^n v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \end{eqnarray*}
</p>
<p> where \(I^n\) interpolates a given function onto mesh \({\mathbb T}^n\). This is a much simpler approach because, in each time step, we no longer have to worry whether \(u^{n-1},v^{n-1}\) were computed on the same mesh as we are using now or on a different mesh. Consequently, the only changes to the code necessary are the addition of a function that computes the error, marks cells for refinement, sets up a <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> object, transfers the solution to the new mesh, and rebuilds matrices and right hand side vectors on the new mesh. Neither the functions building the matrices and right hand sides, nor the solvers need to be changed.</p>
<p class="endli">While this second approach is, strictly speaking, not quite correct in the Rothe framework (it introduces an addition source of error, namely the interpolation), it is nevertheless what almost everyone solving time dependent equations does. We will use this method in <a class="el" href="step_31.html">step-31</a>, for example. </p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>WaveEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    WaveEquation();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> solve_u();</div><div class="line">    <span class="keywordtype">void</span> solve_v();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution_u, solution_v;</div><div class="line">    Vector&lt;double&gt; old_solution_u, old_solution_v;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">          (p[1] &gt; -1. / 3))</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">          (p[1] &gt; -1. / 3))</div><div class="line">        <span class="keywordflow">return</span> (std::cos(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>) * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  WaveEquation&lt;dim&gt;::WaveEquation()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time_step(1. / 64)</div><div class="line">    , time(time_step)</div><div class="line">    , timestep_number(1)</div><div class="line">    , theta(0.5)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">    laplace_matrix.reinit(sparsity_pattern);</div><div class="line">    matrix_u.reinit(sparsity_pattern);</div><div class="line">    matrix_v.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         laplace_matrix);</div><div class="line"></div><div class="line">    solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(matrix_u, solution_u, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(matrix_v, solution_v, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">    vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(vtk_flags);</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WaveEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesU&lt;dim&gt;(),</div><div class="line">                         old_solution_u);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesV&lt;dim&gt;(),</div><div class="line">                         old_solution_v);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(solution_u.size());</div><div class="line">    Vector&lt;double&gt; forcing_terms(solution_u.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= 5; time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(system_rhs, old_solution_u);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        system_rhs.add(time_step, tmp);</div><div class="line"></div><div class="line">        laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">        system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp);</div><div class="line"></div><div class="line">        RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">        rhs_function.set_time(time);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                            rhs_function,</div><div class="line">                                            tmp);</div><div class="line">        forcing_terms = tmp;</div><div class="line">        forcing_terms *= theta * time_step;</div><div class="line"></div><div class="line">        rhs_function.set_time(time - time_step);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                            rhs_function,</div><div class="line">                                            tmp);</div><div class="line"></div><div class="line">        forcing_terms.add((1 - theta) * time_step, tmp);</div><div class="line"></div><div class="line">        system_rhs.add(theta * time_step, forcing_terms);</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">          boundary_values_u_function.set_time(time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                   0,</div><div class="line">                                                   boundary_values_u_function,</div><div class="line">                                                   boundary_values);</div><div class="line"></div><div class="line">          matrix_u.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">          matrix_u.add(theta * theta * time_step * time_step, laplace_matrix);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                             matrix_u,</div><div class="line">                                             solution_u,</div><div class="line">                                             system_rhs);</div><div class="line">        }</div><div class="line">        solve_u();</div><div class="line"></div><div class="line"></div><div class="line">        laplace_matrix.vmult(system_rhs, solution_u);</div><div class="line">        system_rhs *= -theta * time_step;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        system_rhs += tmp;</div><div class="line"></div><div class="line">        laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">        system_rhs.add(-time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        system_rhs += forcing_terms;</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">          boundary_values_v_function.set_time(time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                   0,</div><div class="line">                                                   boundary_values_v_function,</div><div class="line">                                                   boundary_values);</div><div class="line">          matrix_v.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                             matrix_v,</div><div class="line">                                             solution_v,</div><div class="line">                                             system_rhs);</div><div class="line">        }</div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square(solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square(solution_u)) /</div><div class="line">                       2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step23</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"></div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Timediscretization">Time discretization</a><a href="#Timediscretization">Time discretization</a>
      <ul>
        <li><a href="#MethodoflinesorRothesmethod">Method of lines or Rothe's method?</a><a href="#MethodoflinesorRothesmethod">Method of lines or Rothe's method?</a>
        <li><a href="#Rothesmethod">Rothe's method!</a><a href="#Rothesmethod">Rothe's method!</a>
      </ul>
        <li><a href="#Spacediscretization">Space discretization</a><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Energyconservation">Energy conservation</a><a href="#Energyconservation">Energy conservation</a>
        <li><a href="#WhoareCourantFriedrichsandLewy">Who are Courant, Friedrichs, and Lewy?</a><a href="#WhoareCourantFriedrichsandLewy">Who are Courant, Friedrichs, and Lewy?</a>
        <li><a href="#Thetestcase">The test case</a><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeWaveEquationcodeclass">The <code>WaveEquation</code> class</a><a href="#ThecodeWaveEquationcodeclass">The <code>WaveEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeWaveEquationcodeclass">Implementation of the <code>WaveEquation</code> class</a><a href="#ImplementationofthecodeWaveEquationcodeclass">Implementation of the <code>WaveEquation</code> class</a>
      <ul>
        <li><a href="#WaveEquationsetup_system">WaveEquation::setup_system</a><a href="#WaveEquationsetup_system">WaveEquation::setup_system</a>
        <li><a href="#WaveEquationsolve_uandWaveEquationsolve_v">WaveEquation::solve_u and WaveEquation::solve_v</a><a href="#WaveEquationsolve_uandWaveEquationsolve_v">WaveEquation::solve_u and WaveEquation::solve_v</a>
        <li><a href="#WaveEquationoutput_results">WaveEquation::output_results</a><a href="#WaveEquationoutput_results">WaveEquation::output_results</a>
        <li><a href="#WaveEquationrun">WaveEquation::run</a><a href="#WaveEquationrun">WaveEquation::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<pre class="fragment">@note The material presented here is also discussed in &lt;a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html"&gt;video lecture 28&lt;/a&gt;. (All video lectures are also available &lt;a href="http://www.math.colostate.edu/~bangerth/videos.html"&gt;here&lt;/a&gt;.)  
</pre><p> This is the first of a number of tutorial programs that will finallycover "real" time-dependent problems, not the slightly odd form of timedependence found in <a class="el" href="step_18.html">step-18</a> or the DAE model of <a class="el" href="step_21.html">step-21</a> . In particular, this program introducesthe wave equation in a bounded domain. Later, <a class="el" href="step_24.html">step-24</a> will consider an example of absorbing boundary conditions, and <a class="el" href="step_25.html">step_25 </a>step-25"  " a kind of nonlinear wave equation producingsolutions called solitons. The wave equation in its prototypical form reads as follows: find \(u(x,t), x\in\Omega, t\in[0,T]\) that satisfies </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial^2 u}{\partial t^2} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ \frac{\partial u(x,0)}{\partial t} &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}
</p>
<p> Note that since this is an equation with second-order timederivatives, we need to pose two initial conditions, one for the valueand one for the time derivative of the solution. Physically, the equation describes the motion of an elastic medium. In2-d, one can think of how a membrane moves if subjected to aforce. The Dirichlet boundary conditions above indicate that themembrane is clamped at the boundary at a height \(g(x,t)\) (this heightmight be moving as well &mdash; think of people holding a blanket andshaking it up and down). The first initial condition equals theinitial deflection of the membrane, whereas the second one gives itsvelocity. For example, one could think of pushing the membrane downwith a finger and then letting it go at \(t=0\) (nonzero deflection butzero initial velocity), or hitting it with a hammer at \(t=0\) (zerodeflection but nonzero velocity). Both cases would induce motion inthe membrane.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p><a class="anchor" id="MethodoflinesorRothesmethod"></a></p><h4>Method of lines or Rothe's method?</h4>
<p>There is a long-standing debate in the numerical analysis communityover whether a discretization of time dependent equations shouldinvolve first discretizing the time variable leading to a stationaryPDE at each time step that is then solved using standard finiteelement techniques (this is called the Rothe method), or whetherone should first discretize the spatial variables, leading to a largesystem of ordinary differential equations that can then be handled byone of the usual ODE solvers (this is called the method of lines). Both of these methods have advantages and disadvantages.Traditionally, people have preferred the method of lines, since itallows to use the very well developed machinery of high-order ODEsolvers available for the rather stiff ODEs resulting from thisapproach, including step length control and estimation of the temporalerror. On the other hand, Rothe's method becomes awkward when usinghigher-order time stepping method, since one then has to write down aPDE that couples the solution of the present time step not only withthat at the previous time step, but possibly also even earliersolutions, leading to a significant number of terms. For these reasons, the method of lines was the method of choice for along time. However, it has one big drawback: if we discretize thespatial variable first, leading to a large ODE system, we have tochoose a mesh once and for all. If we are willing to do this, thenthis is a legitimate and probably superior approach. If, on the other hand, we are looking at the wave equation and manyother time dependent problems, we find that the character of asolution changes as time progresses. For example, for the waveequation, we may have a single wave travelling through the domain,where the solution is smooth or even constant in front of and behindthe wave &mdash; adaptivity would be really useful for such cases, but thekey is that the area where we need to refine the mesh changes fromtime step to time step! If we intend to go that way, i.e. choose a different mesh for eachtime step (or set of time steps), then the method of lines is notappropriate any more: instead of getting one ODE system with a numberof variables equal to the number of unknowns in the finite elementmesh, our number of unknowns now changes all the time, a fact thatstandard ODE solvers are certainly not prepared to deal with atall. On the other hand, for the Rothe method, we just get a PDE foreach time step that we may choose to discretize independently of themesh used for the previous time step; this approach is not withoutperils and difficulties, but at least is a sensible and well-definedprocedure. For all these reasons, for the present program, we choose to use theRothe method for discretization, i.e. we first discretize in time andthen in space. We will not actually use adaptive meshes at all, sincethis involves a large amount of additional code, but we will commenton this some more in the <a href="#Results">results section below</a>.</p>
<p><a class="anchor" id="Rothesmethod"></a></p><h4>Rothe's method!</h4>
<p>Given these considerations, here is how we will proceed: let us firstdefine a simple time stepping method for this second order problem,and then in a second step do the spatial discretization, i.e. we willfollow Rothe's approach. For the first step, let us take a little detour first: in order todiscretize a second time derivative, we can either discretize itdirectly, or we can introduce an additional variable and transform thesystem into a first order system. In many cases, this turns out to beequivalent, but dealing with first order systems is often simpler. Tothis end, let us introduce </p><p class="formulaDsp">
\[ v = \frac{\partial u}{\partial t}, \]
</p>
<p> call this variable the <em>velocity</em> for obvious reasons. We canthen reformulate the original wave equation as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial u}{\partial t} - v &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times [0,T], \\ \frac{\partial v}{\partial t} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ v(x,0) &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}
</p>
<p> The advantage of this formulation is that it now only contains firsttime derivatives for both variables, for which it is simple to writedown time stepping schemes. Note that we do not have boundaryconditions for \(v\) at first. However, we could enforce \(v=\frac{\partial g}{\partial t}\) on the boundary. It turns out in numerical examples that thisis actually necessary: without doing so the solution doesn't look particularlywrong, but the Crank-Nicolson scheme does not conserve energy if one doesn'tenforce these boundary conditions. With this formulation, let us introduce the following timediscretization where a superscript \(n\) indicates the number of a timestep and \(k=t_n-t_{n-1}\) is the length of the present time step: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{u^n - u^{n-1}}{k} - \left[\theta v^n + (1-\theta) v^{n-1}\right] &amp;=&amp; 0, \\ \frac{v^n - v^{n-1}}{k} - \Delta\left[\theta u^n + (1-\theta) u^{n-1}\right] &amp;=&amp; \theta f^n + (1-\theta) f^{n-1}. \end{eqnarray*}
</p>
<p> how we introduced a parameter \(\theta\) here. If we chose \(\theta=0\) , for example, the first equation would reduce to \(\frac{u^n - u^{n-1}}{k} - v^{n-1} = 0\) , which is well-known as theforward or explicit Euler method. On the other hand, if we set \(\theta=1\) , then we would get \(\frac{u^n - u^{n-1}}{k} - v^n = 0\) , which corresponds to thebackward or implicit Euler method. Both these methods are first orderaccurate methods. They are simple to implement, but they are notreally very accurate. The third case would be to choose \(\theta=\frac 12\) . The first of theequations above would then read \(\frac{u^n - u^{n-1}}{k} - \frac 12 \left[v^n + v^{n-1}\right] = 0\) . This method is known asthe Crank-Nicolson method and has the advantage that it is secondorder accurate. In addition, it has the nice property that itpreserves the energy in the solution (physically, the energy is thesum of the kinetic energy of the particles in the membrane plus thepotential energy present due to the fact that it is locally stretched;this quantity is a conserved one in the continuous equation, but mosttime stepping schemes do not conserve it after timediscretization). Since \(v^n\) also appears in the equation for \(u^n\) ,the Crank-Nicolson scheme is also implicit. In the program, we will leave \(\theta\) as a parameter, so that it willbe easy to play with it. The results section will show some numericalevidence comparing the different schemes. The equations above (called the <em>semidiscretized</em> equationsbecause we have only discretized the time, but not space), can besimplified a bit by eliminating \(v^n\) from the first equation andrearranging terms. We then get </p><p class="formulaDsp">
\begin{eqnarray*} \left[ 1-k^2\theta^2\Delta \right] u^n &amp;=&amp; \left[ 1+k^2\theta(1-\theta)\Delta\right] u^{n-1} + k v^{n-1} + k^2\theta\left[\theta f^n + (1-\theta) f^{n-1}\right],\\ v^n &amp;=&amp; v^{n-1} + k\Delta\left[ \theta u^n + (1-\theta) u^{n-1}\right] + k\left[\theta f^n + (1-\theta) f^{n-1}\right]. \end{eqnarray*}
</p>
<p> this form, we see that if we are given the solution \(u^{n-1},v^{n-1}\) of the previous timestep, that we can then solve forthe variables \(u^n,v^n\) separately, i.e. one at a time. This isconvenient. In addition, we recognize that the operator in the firstequation is positive definite, and the second equation looksparticularly simple.</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>We have now derived equations that relate the approximate(semi-discrete) solution \(u^n(x)\) and its time derivative \(v^n(x)\) attime \(t_n\) with the solutions \(u^{n-1}(x),v^{n-1}(x)\) of the previoustime step at \(t_{n-1}\) . The next step is to also discretize thespatial variable using the usual finite element methodology. To thisend, we multiply each equation with a test function, integrate overthe entire domain, and integrate by parts where necessary. This leadsto </p><p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \\ (v^n,\varphi) &amp;=&amp; (v^{n-1},\varphi) - k\left[ \theta (\nabla u^n,\nabla\varphi) + (1-\theta) (\nabla u^{n-1},\nabla \varphi)\right] + k \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}
</p>
<p> It is then customary to approximate \(u^n(x) \approx u^n_h(x) = \sum_i U_i^n\phi_i^n(x)\) , where \(\phi_i^n(x)\) are the shape functions usedfor the discretization of the \(n\) -th time step and \(U_i^n\) are theunknown nodal values of the solution. Similarly, \(v^n(x) \approx v^n_h(x) = \sum_i V_i^n\phi_i^n(x)\) . Finally, we have the solutions ofthe previous time step, \(u^{n-1}(x) \approx u^{n-1}_h(x) = \sum_i U_i^{n-1}\phi_i^{n-1}(x)\) and \(v^{n-1}(x) \approx v^{n-1}_h(x) = \sum_i V_i^{n-1}\phi_i^{n-1}(x)\) . Note that since the solution of the previoustime step has already been computed by the time we get to time step \(n\) , \(U^{n-1},V^{n-1}\) are known. Furthermore, note that the solutionsof the previous step may have been computed on a different mesh, sowe have to use shape functions \(\phi^{n-1}_i(x)\) . If we plug these expansions into above equations and test with thetest functions from the present mesh, we get the following linearsystem: </p><p class="formulaDsp">
\begin{eqnarray*} (M^n + k^2\theta^2 A^n)U^n &amp;=&amp; M^{n,n-1}U^{n-1} - k^2\theta(1-\theta) A^{n,n-1}U^{n-1} + kM^{n,n-1}V^{n-1} + k^2\theta \left[ \theta F^n + (1-\theta) F^{n-1} \right], \\ M^nV^n &amp;=&amp; M^{n,n-1}V^{n-1} - k\left[ \theta A^n U^n + (1-\theta) A^{n,n-1} U^{n-1}\right] + k \left[ \theta F^n + (1-\theta) F^{n-1} \right], \end{eqnarray*}
</p>
 <p class="formulaDsp">
\begin{eqnarray*} M^n_{ij} &amp;=&amp; (\phi_i^n, \phi_j^n), \\ A^n_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^n), \\ M^{n,n-1}_{ij} &amp;=&amp; (\phi_i^n, \phi_j^{n-1}), \\ A^{n,n-1}_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^{n-1}), \\ F^n_{i} &amp;=&amp; (f^n,\phi_i^n), \\ F^{n-1}_{i} &amp;=&amp; (f^{n-1},\phi_i^n). \end{eqnarray*}
</p>
<p>If we solve these two equations, we can move the solution one stepforward and go on to the next time step. It is worth noting that if we choose the same mesh on each time step(as we will in fact do in the program below), then we have the sameshape functions on time step \(n\) and \(n-1\) ,i.e. \(\phi^n_i=\phi_i^{n-1}=\phi_i\) . Consequently, we get \(M^n=M^{n,n-1}=M\) and \(A^n=A^{n,n-1}=A\) . On the other hand, if we hadused different shape functions, then we would have to computeintegrals that contain shape functions defined on two meshes. This is asomewhat messy process that we omit here, but that is treated in somedetail in <a class="el" href="step_28.html">step-28</a> . Under these conditions (i.e. a mesh that doesn't change), one can optimize thesolution procedure a bit by basically eliminating the solution of the secondlinear system. We will discuss this in the introduction of the <a class="el" href="step_25.html">step_25 </a>step-25"  " program. <a class="anchor" id="Energyconservation"></a></p><h3>Energy conservation</h3>
<p>One way to compare the quality of a time stepping scheme is to see whether thenumerical approximation preserves conservation properties of the continuousequation. For the wave equation, the natural quantity to look at is theenergy. By multiplying the wave equation by \(u_t\) , integrating over \(\Omega\) ,and integrating by parts where necessary, we find that </p><p class="formulaDsp">
\[ \frac{d}{d t} \left[\frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx\right] = \int_\Omega f \frac{\partial u}{\partial t} \; dx + \int_{\partial\Omega} n\cdot\nabla u \frac{\partial g}{\partial t} \; dx. \]
</p>
<p> consequence, in absence of body forces and constant boundary values, we getthat </p><p class="formulaDsp">
\[ E(t) = \frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx \]
</p>
<p> a conserved quantity, i.e. one that doesn't change with time. Wewill compute this quantity after each timestep. It is straightforward to see that if we replace \(u\) by its finiteelement approximation, and \(\frac{\partial u}{\partial t}\) by the finiteelement approximation of the velocity \(v\) , then </p><p class="formulaDsp">
\[ E(t_n) = \frac 12 \left&lt;V^n, M^n V^n\right&gt; + \frac 12 \left&lt;U^n, A^n U^n\right&gt;. \]
</p>
<p> we will see in the results section, the Crank-Nicolson scheme does indeedconserve the energy, whereas neither the forward nor the backward Euler schemedo.</p>
<p><a class="anchor" id="WhoareCourantFriedrichsandLewy"></a></p><h3>Who are Courant, Friedrichs, and Lewy?</h3>
<p>One of the reasons why the wave equation is nasty to solve numerically is thatexplicit time discretizations are only stable if the time step is smallenough. In particular, it is coupled to the spatial mesh width \(h\) . For thelowest order discretization we use here, the relationship reads </p><p class="formulaDsp">
\[ k\le \frac hc \]
</p>
<p> \(c\) is the wave speed, which in our formulation of the wave equation hasbeen normalized to one. Consequently, unless we use the implicit schemes with \(\theta&gt;0\) , our solutions will not be numerically stable if we violate thisrestriction. Implicit schemes do not have this restriction for stability, butthey become inaccurate if the time step is too large. This condition was first recognized by Courant, Friedrichs, and Lewy &mdash;in 1928, long before computers became available for numericalcomputations! (This result appeared in the German language articleR. Courant, K. Friedrichs and H. Lewy: <em>&Uuml;ber die partiellen Differenzengleichungen der mathematischen Physik</em>, MathematischeAnnalen, vol. 100, no. 1, pages 32-74, 1928.)This condition on the time step is most frequently just referredto as the <em>CFL</em> condition. Intuitively, the CFL condition saysthat the time step must not be larger than the time it takes a wave tocross a single cell. In the program, we will refine the square \([-1,1]^2\) seven times uniformly, giving a mesh size of \(h=\frac 1{64}\) , whichis what we set the time step to. The fact that we set the time step and meshsize individually in two different places is error prone: it is too easy torefine the mesh once more but forget to also adjust the time step. <a class="el" href="step_24.html">step_24 </a>step-24"  " shows a better way how to keep these things in sync.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>Although the program has all the hooks to deal with nonzero initial andboundary conditions and body forces, we take a simple case where the domain isa square \([-1,1]^2\) and </p><p class="formulaDsp">
\begin{eqnarray*} f &amp;=&amp; 0, \\ u_0 &amp;=&amp; 0, \\ u_1 &amp;=&amp; 0, \\ g &amp;=&amp; \left\{\begin{matrix}\sin (4\pi t) &amp;\qquad&amp; \text{for }\ t\le \frac 12, x=-1, -\frac 13&lt;y&lt;\frac 13 \\ 0 &amp;&amp;\text{otherwise} \end{matrix} \right. \end{eqnarray*}
</p>
<p> This corresponds to a membrane initially at rest and clamped all around, wheresomeone is waving a part of the clamped boundary once up and down, therebyshooting a wave into the domain.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with the usual assortment of include files that we've seen in so many of the previous tests:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Here are the only three include files of some new interest: The first one is already used, for example, for the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> and <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> functions. However, we here use another function in that class, <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> to compute our initial values as the \(L^2\) projection of the continuous initial values. Furthermore, we use <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a> to generate the integrals \((f^n,\phi^n_i)\) . These were previously always generated by hand in <code>assemble_system</code> or similar functions in application code. However, we're too lazy to do that here, so simply use a library function:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>In a very similar vein, we are also too lazy to write the code to assemble mass and Laplace matrices, although it would have only taken copying the relevant code from any number of previous tutorial programs. Rather, we want to focus on the things that are truly new to this program and therefore use the <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a> and <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a> functions. They are declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, here is an include file that contains all sorts of tool functions that one sometimes needs. In particular, we need the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> class that, given an integer argument, returns a string representation of it. It is particularly useful since it allows for a second parameter indicating the number of digits to which we want the result padded with leading zeros. We will use this to write output files that have the form <code>solution-XXX.vtu</code> where <code>XXX</code> denotes the number of the time step and always consists of three digits even if we are still in the single or double digit time steps.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeWaveEquationcodeclass"></a> </p><h3>The <code>WaveEquation</code> class</h3>
<p>Next comes the declaration of the main class. It's public interface of functions is like in most of the other tutorial programs. Worth mentioning is that we now have to store four matrices instead of one: the mass matrix \(M\) , the Laplace matrix \(A\) , the matrix \(M+k^2\theta^2A\) used for solving for \(U^n\) , and a copy of the mass matrix with boundary conditions applied used for solving for \(V^n\) . Note that it is a bit wasteful to have an additional copy of the mass matrix around. We will discuss strategies for how to avoid this in the section on possible improvements. Likewise, we need solution vectors for \(U^n,V^n\) as well as for the corresponding vectors at the previous time step, \(U^{n-1},V^{n-1}\) . The <code>system_rhs</code> will be used for whatever right hand side vector we have when solving one of the two linear systems in each time step. These will be solved in the two functions <code>solve_u</code> and <code>solve_v</code> . Finally, the variable <code>theta</code> is used to indicate the parameter \(\theta\) that is used to define which time stepping scheme to use, as explained in the introduction. The rest is self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>WaveEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WaveEquation();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> solve_u();</div><div class="line">  <span class="keywordtype">void</span> solve_v();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_u, solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> old_solution_u, old_solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">double</span>       time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial and boundary values for both the solution \(u\) and its time derivative \(v\) , as well as a right hand side class. We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not be a surprise. Let's start with initial values and choose zero for both the value \(u\) as well as its time derivative, the velocity \(v\) :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Secondly, we have the right hand side forcing term. Boring as we are, we choose zero here as well:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Finally, we have boundary values for \(u\) and \(v\) . They are as described in the introduction, one being the time derivative of the other:</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       (void)component;</div><div class="line">       <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  </div><div class="line">       <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">           (p[1] &gt;</div><div class="line">  </div><div class="line">-1. / 3))</div><div class="line">         <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>() 4 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">         <span class="keywordflow">return</span> 0;</div><div class="line">     }</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       (void)component;</div><div class="line">       <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  </div><div class="line">       <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">           (p[1] &gt;</div><div class="line">  </div><div class="line">-1. / 3))</div><div class="line">         <span class="keywordflow">return</span> (std::cos(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() 4 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>) 4 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">         <span class="keywordflow">return</span> 0;</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeWaveEquationcodeclass"></a> </p><h3>Implementation of the <code>WaveEquation</code> class</h3>
<p>The implementation of the actual logic is actually fairly short, since we relegate things like assembling the matrices and right hand side vectors to the library. The rest boils down to not much more than 130 lines of actual code, a significant fraction of which is boilerplate code that can be taken from previous example programs (e.g. the functions that solve linear systems, or that generate output). Let's start with the constructor (for an explanation of the choice of time step, see the section on Courant, Friedrichs, and Lewy in the introduction):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">WaveEquation&lt;dim&gt;::WaveEquation()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time_step(1. / 64)</div><div class="line">  , time(time_step)</div><div class="line">  , timestep_number(1)</div><div class="line">  , theta(0.5)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsetup_system"></a> </p><h4>WaveEquation::setup_system</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a> :</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system()</div><div class="line">   {</div><div class="line">     <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation,</div><div class="line">  </div><div class="line">-1, 1);</div><div class="line">     triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line">  </div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">               &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">     dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  </div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">               &lt;&lt; std::endl</div><div class="line">               &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">     <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">     sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div></div><!-- fragment --><p>Then comes a block where we have to initialize the 3 matrices we need in the course of the program: the mass matrix, the Laplace matrix, and the matrix \(M+k^2\theta^2A\) used when solving for \(U^n\) in each time step. When setting up these matrices, note that they all make use of the same sparsity pattern object. Finally, the reason why matrices and sparsity patterns are separate objects in deal.II (unlike in many other finite element or linear algebra classes) becomes clear: in a significant fraction of applications, one has to hold several matrices that happen to have the same sparsity pattern, and there is no reason for them not to share this information, rather than re-building and wasting memory on it several times. After initializing all of these matrices, we call library functions that build the Laplace and mass matrices. All they need is a <a class="el" href="classDoFHandler.html">DoFHandler</a> object and a quadrature formula object that is to be used for numerical integration. Note that in many respects these functions are better than what we would usually do in application programs, for example because they automatically parallelize building the matrices if multiple processors are available in a machine: for more information see the documentation of <a class="el" href="namespaceWorkStream.html">WorkStream</a> or the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. The matrices for solving linear systems will be filled in the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> method because we need to re-apply boundary conditions every time step.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">laplace_matrix.reinit(sparsity_pattern);</div><div class="line">matrix_u.reinit(sparsity_pattern);</div><div class="line">matrix_v.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"><a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line"><a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                     laplace_matrix);</div></div><!-- fragment --><p>The rest of the function is spent on setting vector sizes to the correct value. The final line closes the hanging node constraints object. Since we work on a uniformly refined mesh, no constraints exist or have been computed (i.e. there was no need to call <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a> as in other programs), but we need a constraints object in one place further down below anyway.</p>
<div class="fragment"><div class="line">  solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsolve_uandWaveEquationsolve_v"></a> </p><h4>WaveEquation::solve_u and WaveEquation::solve_v</h4>
<p>The next two functions deal with solving the linear systems associated with the equations for \(U^n\) and \(V^n\) . Both are not particularly interesting as they pretty much follow the scheme used in all the previous tutorial programs. One can make little experiments with preconditioners for the two matrices we have to invert. As it turns out, however, for the matrices at hand here, using Jacobi or SSOR preconditioners reduces the number of iterations necessary to solve the linear system slightly, but due to the cost of applying the preconditioner it is no win in terms of run-time. It is not much of a loss either, but let's keep it simple and just do without:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(matrix_u, solution_u, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(matrix_v, solution_v, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationoutput_results"></a> </p><h4>WaveEquation::output_results</h4>
<p>Likewise, the following function is pretty much what we've done before. The only thing worth mentioning is how here we generate a string representation of the time step number padded with leading zeros to 3 character length using the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> function's second argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div></div><!-- fragment --><p>Like <a class="el" href="step_15.html">step-15</a> , since we write output at every time step (and the system we have to solve is relatively easy), we instruct <a class="el" href="classDataOut.html">DataOut</a> to use the zlib compression algorithm that is optimized for speed instead of disk usage since otherwise plotting the output becomes a bottleneck:</p>
<div class="fragment"><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">  vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">    DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(vtk_flags);</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationrun"></a> </p><h4>WaveEquation::run</h4>
<p>The following is really the only interesting function of the program. It contains the loop over all time steps, but before we get to that we have to set up the grid, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices. In addition, we have to somehow get started with initial values. To this end, we use the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function that takes an object that describes a continuous function and computes the \(L^2\) projection of this function onto the finite element space described by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. Can't be any simpler than that:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WaveEquation&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  setup_system();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                       constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                       InitialValuesU&lt;dim&gt;(),</div><div class="line">                       old_solution_u);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                       constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                       InitialValuesV&lt;dim&gt;(),</div><div class="line">                       old_solution_v);</div></div><!-- fragment --><p>The next thing is to loop over all the time steps until we reach the end time ( \(T=5\) in this case). In each time step, we first have to solve for \(U^n\) , using the equation \((M^n + k^2\theta^2 A^n)U^n =\) \((M^{n,n-1} - k^2\theta(1-\theta) A^{n,n-1})U^{n-1} + kM^{n,n-1}V^{n-1} +\) \(k\theta \left[k \theta F^n + k(1-\theta) F^{n-1} \right]\) . Note that we use the same mesh for all time steps, so that \(M^n=M^{n,n-1}=M\) and \(A^n=A^{n,n-1}=A\) . What we therefore have to do first is to add up \(MU^{n-1} - k^2\theta(1-\theta) AU^{n-1} + kMV^{n-1}\) and the forcing terms, and put the result into the <code>system_rhs</code> vector. (For these additions, we need a temporary vector that we declare before the loop to avoid repeated memory allocations in each time step.) The one thing to realize here is how we communicate the time variable to the object describing the right hand side: each object derived from the <a class="el" href="classFunction.html">Function</a> class has a time field that can be set using the <a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">Function::set_time</a> and read by <a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">Function::get_time</a>. In essence, using this mechanism, all functions of space and time are therefore considered functions of space evaluated at a particular time. This matches well what we typically need in finite element programs, where we almost always work on a single time step at a time, and where it never happens that, for example, one would like to evaluate a space-time function for all times at any given spatial location.</p>
<div class="fragment"><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution_u.size());</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> forcing_terms(solution_u.size());</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (; time &lt;= 5; time += time_step, ++timestep_number)</div><div class="line">       {</div><div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                   &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(system_rhs, old_solution_u);</div><div class="line">  </div><div class="line">         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">         system_rhs.add(time_step, tmp);</div><div class="line">  </div><div class="line">         laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">         system_rhs.add(-theta (1</div><div class="line">  </div><div class="line">- theta) time_step time_step, tmp);</div><div class="line">  </div><div class="line">         RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">         rhs_function.set_time(time);</div><div class="line">         <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                             <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                             rhs_function,</div><div class="line">                                             tmp);</div><div class="line">         forcing_terms = tmp;</div><div class="line">         forcing_terms= theta time_step;</div><div class="line">  </div><div class="line">         rhs_function.set_time(time</div><div class="line">  </div><div class="line">- time_step);</div><div class="line">         <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                             <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                             rhs_function,</div><div class="line">                                             tmp);</div><div class="line">  </div><div class="line">         forcing_terms.add((1</div><div class="line">  </div><div class="line">- theta) time_step, tmp);</div><div class="line">  </div><div class="line">         system_rhs.add(theta time_step, forcing_terms);</div></div><!-- fragment --><p>After so constructing the right hand side vector of the first equation, all we have to do is apply the correct boundary values. As for the right hand side, this is a space-time function evaluated at a particular time, which we interpolate at boundary nodes and then use the result to apply boundary values as we usually do. The result is then handed off to the solve_u() function:</p>
<div class="fragment"><div class="line">{</div><div class="line">  BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">  boundary_values_u_function.set_time(time);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           boundary_values_u_function,</div><div class="line">                                           boundary_values);</div></div><!-- fragment --><p>The matrix for solve_u() is the same in every time steps, so one could think that it is enough to do this only once at the beginning of the simulation. However, since we need to apply boundary values to the linear system (which eliminate some matrix rows and columns and give contributions to the right hand side), we have to refill the matrix in every time steps before we actually apply boundary data. The actual content is very simple: it is the sum of the mass matrix and a weighted Laplace matrix:</p>
<div class="fragment"><div class="line">  matrix_u.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  matrix_u.add(theta theta time_step time_step, laplace_matrix);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     matrix_u,</div><div class="line">                                     solution_u,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line">solve_u();</div></div><!-- fragment --><p>The second step, i.e. solving for \(V^n\) , works similarly, except that this time the matrix on the left is the mass matrix (which we copy again in order to be able to apply boundary conditions, and the right hand side is \(MV^{n-1} - k\left[ \theta A U^n + (1-\theta) AU^{n-1}\right]\) plus forcing terms. Boundary values are applied in the same way as before, except that now we have to use the BoundaryValuesV class:</p>
<div class="fragment"><div class="line">         laplace_matrix.vmult(system_rhs, solution_u);</div><div class="line">         system_rhs=</div><div class="line">  </div><div class="line">-theta time_step;</div><div class="line">  </div><div class="line">         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">         system_rhs += tmp;</div><div class="line">  </div><div class="line">         laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">         system_rhs.add(-time_step (1</div><div class="line">  </div><div class="line">- theta), tmp);</div><div class="line">  </div><div class="line">         system_rhs += forcing_terms;</div><div class="line">  </div><div class="line">         {</div><div class="line">           BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">           boundary_values_v_function.set_time(time);</div><div class="line">  </div><div class="line">           std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">           <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                    0,</div><div class="line">                                                    boundary_values_v_function,</div><div class="line">                                                    boundary_values);</div><div class="line">           matrix_v.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">           <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                              matrix_v,</div><div class="line">                                              solution_v,</div><div class="line">                                              system_rhs);</div><div class="line">         }</div><div class="line">         solve_v();</div></div><!-- fragment --><p>Finally, after both solution components have been computed, we output the result, compute the energy in the solution, and go on to the next time step after shifting the present solution into the vectors that hold the solution at the previous time step. Note the function <a class="el" href="classSparseMatrix.html#a56d106dfe8792db57f2d6e60bdfe63e1">SparseMatrix::matrix_norm_square</a> that can compute \(\left&lt;V^n,MV^n\right&gt;\) and \(\left&lt;U^n,AU^n\right&gt;\) in one step, saving us the expense of a temporary vector and several lines of code:</p>
<div class="fragment"><div class="line">        output_results();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square(solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square(solution_u)) /</div><div class="line">                       2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step23</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>What remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"> </div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When the program is run, it produces the following output: </p><div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Number of degrees of freedom: 16641</div><div class="line">  </div><div class="line">Time step 1 at t=0.015625</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 22 CG iterations.</div><div class="line">   Total energy: 1.17887</div><div class="line">Time step 2 at t=0.03125</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 2.9655</div><div class="line">Time step 3 at t=0.046875</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 4.33761</div><div class="line">Time step 4 at t=0.0625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 5.35499</div><div class="line">Time step 5 at t=0.078125</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 6.18652</div><div class="line">Time step 6 at t=0.09375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 6.6799</div><div class="line">  </div><div class="line">...</div><div class="line">  </div><div class="line">Time step 31 at t=0.484375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 21.9068</div><div class="line">Time step 32 at t=0.5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.3394</div><div class="line">Time step 33 at t=0.515625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line">  </div><div class="line">...</div><div class="line">  </div><div class="line">Time step 319 at t=4.98438</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line">Time step 320 at t=5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div></div><!-- fragment --><p>What we see immediately is that the energy is a constant at least after \(t=\frac 12\) (until which the boundary source term \(g\) is nonzero, injectingenergy into the system). In addition to the screen output, the program writes the solution of each timestep to an output file. If we process them adequately and paste them into amovie, we get the following: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-23.movie.gif" alt="Animation of the solution of step 23."/>
</div>
<p> The movie shows the generated wave nice traveling through the domain and back,being reflected at the clamped boundary. Some numerical noise is trailing thewave, an artifact of a too-large mesh size that can be reduced by reducing themesh width and the time step.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>If you want to explore a bit, try out some of the following things: </p><ul>
<li>
Varying \(\theta\) . This gives different time stepping schemes, some of which are stable while others are not. Take a look at how the energy evolves. </li>
<li>
Different initial and boundary conditions, right hand sides. </li>
<li>
More complicated domains or more refined meshes. Remember that the time step needs to be bounded by the mesh width, so changing the mesh should always involve also changing the time step. We will come back to this issue in <a class="el" href="step_24.html">step-24</a> . </li>
<li>
Variable coefficients: In real media, the wave speed is often variable. In particular, the "real" wave equation in realistic media would read <p class="formulaDsp">
\[ \rho(x) \frac{\partial^2 u}{\partial t^2} - \nabla \cdot a(x) \nabla u = f, \]
</p>
 where \(\rho(x)\) is the density of the material, and \(a(x)\) is related to the stiffness coefficient. The wave speed is then \(c=\sqrt{a/\rho}\) . To make such a change, we would have to compute the mass and Laplace matrices with a variable coefficient. Fortunately, this isn't too hard: the functions <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a> and <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a> have additional default parameters that can be used to pass non-constant coefficient functions to them. The required changes are therefore relatively small. On the other hand, care must be taken again to make sure the time step is within the allowed range. </li>
<li>
In the in-code comments, we discussed the fact that the matrices for solving for \(U^n\) and \(V^n\) need to be reset in every time because of boundary conditions, even though the actual content does not change. It is possible to avoid copying by not eliminating columns in the linear systems, which is implemented by appending a <code>false</code> argument to the call: <div class="fragment"><div class="line"><a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                   matrix_u,</div><div class="line">                                   solution_u,</div><div class="line">                                   system_rhs,</div><div class="line">                                   <span class="keyword">false</span>);</div></div><!-- fragment --> <pre class="fragment">&lt;li&gt;  deal.II being a library that supports adaptive meshes it would of course be  nice if this program supported change the mesh every few time steps. Given the  structure of the solution &amp;mdash; a wave that travels through the domain &amp;mdash;  it would seem appropriate if we only refined the mesh where the wave currently is,  and not simply everywhere. It is intuitively clear that we should be able to  save a significant amount of cells this way. (Though upon further thought one  realizes that this is really only the case in the initial stages of the simulation.  After some time, for wave phenomena, the domain is filled with reflections of  the initial wave going in every direction and filling every corner of the domain.  At this point, there is in general little one can gain using local mesh  refinement.)
</pre> To make adaptively changing meshes possible, there are basically two routes. The "correct" way would be to go back to the weak form we get using Rothe's method. For example, the first of the two equations to be solved in each time step looked like this: <p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}
</p>
 Now, note that we solve for \(u^n\) on mesh \({\mathbb T}^n\) , and consequently the test functions \(\varphi\) have to be from the space \(V_h^n\) as well. As discussed in the introduction, terms like \((u^{n-1},\varphi)\) then require us to integrate the solution of the previous step (which may have been computed on a different mesh \({\mathbb T}^{n-1}\) ) against the test functions of the current mesh, leading to a matrix \(M^{n,n-1}\) . This process of integrating shape functions from different meshes is, at best, awkward. It can be done but because it is difficult to ensure that \({\mathbb T}^{n-1}\) and \({\mathbb T}^{n}\) differ by at most one level of refinement, one has to recursively match cells from both meshes. It is feasible to do this, but it leads to lengthy and not entirely obvious code. The second approach is the following: whenever we change the mesh, we simply interpolate the solution from the last time step on the old mesh to the new mesh, using the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class. In other words, instead of the equation above, we would solve <p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (I^n u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla I^n u^{n-1},\nabla \varphi) + k(I^n v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \end{eqnarray*}
</p>
 where \(I^n\) interpolates a given function onto mesh \({\mathbb T}^n\) . This is a much simpler approach because, in each time step, we no longer have to worry whether \(u^{n-1},v^{n-1}\) were computed on the same mesh as we are using now or on a different mesh. Consequently, the only changes to the code necessary are the addition of a function that computes the error, marks cells for refinement, sets up a <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> object, transfers the solution to the new mesh, and rebuilds matrices and right hand side vectors on the new mesh. Neither the functions building the matrices and right hand sides, nor the solvers need to be changed. While this second approach is, strictly speaking, not quite correct in the Rothe framework (it introduces an addition source of error, namely the interpolation), it is nevertheless what almost everyone solving time dependent equations does. We will use this method in <a class="el" href="step_31.html">step-31</a> , for example. </li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>WaveEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    WaveEquation();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> solve_u();</div><div class="line">    <span class="keywordtype">void</span> solve_v();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution_u, solution_v;</div><div class="line">    Vector&lt;double&gt; old_solution_u, old_solution_v;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">          (p[1] &gt; -1. / 3))</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">          (p[1] &gt; -1. / 3))</div><div class="line">        <span class="keywordflow">return</span> (std::cos(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>) * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  WaveEquation&lt;dim&gt;::WaveEquation()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time_step(1. / 64)</div><div class="line">    , time(time_step)</div><div class="line">    , timestep_number(1)</div><div class="line">    , theta(0.5)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">    laplace_matrix.reinit(sparsity_pattern);</div><div class="line">    matrix_u.reinit(sparsity_pattern);</div><div class="line">    matrix_v.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         laplace_matrix);</div><div class="line"></div><div class="line">    solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(matrix_u, solution_u, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(matrix_v, solution_v, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">    vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(vtk_flags);</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WaveEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesU&lt;dim&gt;(),</div><div class="line">                         old_solution_u);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesV&lt;dim&gt;(),</div><div class="line">                         old_solution_v);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(solution_u.size());</div><div class="line">    Vector&lt;double&gt; forcing_terms(solution_u.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= 5; time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(system_rhs, old_solution_u);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        system_rhs.add(time_step, tmp);</div><div class="line"></div><div class="line">        laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">        system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp);</div><div class="line"></div><div class="line">        RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">        rhs_function.set_time(time);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                            rhs_function,</div><div class="line">                                            tmp);</div><div class="line">        forcing_terms = tmp;</div><div class="line">        forcing_terms *= theta * time_step;</div><div class="line"></div><div class="line">        rhs_function.set_time(time - time_step);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                            rhs_function,</div><div class="line">                                            tmp);</div><div class="line"></div><div class="line">        forcing_terms.add((1 - theta) * time_step, tmp);</div><div class="line"></div><div class="line">        system_rhs.add(theta * time_step, forcing_terms);</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">          boundary_values_u_function.set_time(time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                   0,</div><div class="line">                                                   boundary_values_u_function,</div><div class="line">                                                   boundary_values);</div><div class="line"></div><div class="line">          matrix_u.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">          matrix_u.add(theta * theta * time_step * time_step, laplace_matrix);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                             matrix_u,</div><div class="line">                                             solution_u,</div><div class="line">                                             system_rhs);</div><div class="line">        }</div><div class="line">        solve_u();</div><div class="line"></div><div class="line"></div><div class="line">        laplace_matrix.vmult(system_rhs, solution_u);</div><div class="line">        system_rhs *= -theta * time_step;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        system_rhs += tmp;</div><div class="line"></div><div class="line">        laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">        system_rhs.add(-time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        system_rhs += forcing_terms;</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">          boundary_values_v_function.set_time(time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                   0,</div><div class="line">                                                   boundary_values_v_function,</div><div class="line">                                                   boundary_values);</div><div class="line">          matrix_v.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                             matrix_v,</div><div class="line">                                             solution_v,</div><div class="line">                                             system_rhs);</div><div class="line">        }</div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square(solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square(solution_u)) /</div><div class="line">                       2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step23</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"></div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Timediscretization">Time discretization</a>
      <ul>
        <li><a href="#MethodoflinesorRothesmethod">Method of lines or Rothe's method?</a>
        <li><a href="#Rothesmethod">Rothe's method!</a>
      </ul>
        <li><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Energyconservation">Energy conservation</a>
        <li><a href="#WhoareCourantFriedrichsandLewy">Who are Courant, Friedrichs, and Lewy?</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeWaveEquationcodeclass">The <code>WaveEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeWaveEquationcodeclass">Implementation of the <code>WaveEquation</code> class</a>
      <ul>
        <li><a href="#WaveEquationsetup_system">WaveEquation::setup_system</a>
        <li><a href="#WaveEquationsolve_uandWaveEquationsolve_v">WaveEquation::solve_u and WaveEquation::solve_v</a>
        <li><a href="#WaveEquationoutput_results">WaveEquation::output_results</a>
        <li><a href="#WaveEquationrun">WaveEquation::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-23/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>这是一系列教程程序中的第一个，它将最终涵盖 "真正的 "时间依赖问题，而不是步骤18中发现的略显奇怪的时间依赖形式或步骤21的DAE模型。特别是，这个程序介绍了有界域中的波浪方程。后来，第24步将考虑一个吸收边界条件的例子，以及 <a class="el" href="step_25.html">第25步 </a>一种产生称为孤子的解的非线性波方程。</p>
<p>波浪方程的原型形式如下：找到满足以下条件的 \(u(x,t), x\in\Omega, t\in[0,T]\) 。</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{\partial^2 u}{\partial t^2} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ \frac{\partial u(x,0)}{\partial t} &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}
</p>
<p>请注意，由于这是一个具有二阶时间导数的方程，我们需要提出两个初始条件，一个是值，一个是解的时间导数。</p>
<p>在物理上，该方程描述了弹性介质的运动。在二维空间中，我们可以考虑膜在受到力的作用下如何运动。上面的Dirichlet边界条件表明，膜被夹在边界的高度 \(g(x,t)\) （这个高度可能也在移动&amp;mdash；想想人们拿着毯子上下摇晃）。第一个初始条件等于膜的初始偏转，而第二个初始条件给出了其速度。例如，我们可以考虑用手指把膜推下去，然后在 \(t=0\) 处让它离开（非零偏转但零初始速度），或者在 \(t=0\) 处用锤子砸它（零偏转但非零速度）。这两种情况都会引起膜的运动。</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p><a class="anchor" id="MethodoflinesorRothesmethod"></a></p><h4>Method of lines or Rothe's method?</h4>
<p>在数值分析界有一个长期的争论，即时间依赖方程的离散化是否应该首先离散时间变量，导致每个时间步长的静止PDE，然后用标准的有限元技术来解决（这被称为Rothe方法），或者是否应该首先离散空间变量，导致一个大型的常微分方程系统，然后用一个通常的ODE求解器来处理（这被称为线的方法）。</p>
<p>这两种方法都有优点和缺点。传统上，人们更倾向于线的方法，因为它允许使用非常发达的高阶ODE求解器，可用于由这种方法产生的相当刚性的ODE，包括步长控制和时间误差的估计。</p>
<p>另一方面，当使用高阶时间步长法时，罗特的方法变得很尴尬，因为这时人们必须写下一个PDE，将当前时间步长的解与前一个时间步长的解结合起来，而且可能还有更早的解，从而导致大量的条款。</p>
<p>由于这些原因，线条法在很长一段时间内都是人们的首选方法。然而，它有一个很大的缺点：如果我们先将空间变量离散化，导致一个大的ODE系统，我们必须一劳永逸地选择一个网格。如果我们愿意这样做，那么这就是一种合法的、可能是优越的方法。</p>
<p>另一方面，如果我们看的是波浪方程和其他许多与时间有关的问题，我们会发现，随着时间的推移，解的特征会发生变化。例如，对于波浪方程，我们可能有一个单一的波浪穿过域，在波浪的前后，解是平滑的，甚至是恒定的&mdash;自适应性对于这种情况确实很有用，但关键是我们需要细化网格的区域会随着时间步数的变化而变化!</p>
<p>如果我们打算这样做，即为每个时间步长（或一组时间步长）选择不同的网格，那么线段法就不再合适了：我们不是得到一个变量数等于有限元网格中未知数数量的ODE系统，而是未知数的数量一直在变化，这是标准ODE求解器肯定不准备处理的事实。另一方面，对于罗特方法，我们只是在每个时间步长得到一个PDE，我们可以选择独立于前一个时间步长所用的网格进行离散化；这种方法并非没有危险和困难，但至少是一个合理的、定义明确的程序。</p>
<p>由于所有这些原因，在本程序中，我们选择使用Rothe方法进行离散化，即我们首先在时间上进行离散化，然后在空间上离散化。我们实际上根本不会使用自适应网格，因为这涉及到大量的额外代码，但我们将在<a href="#Results">results section below</a>中对此作一些评论。</p>
<p><a class="anchor" id="Rothesmethod"></a></p><h4>Rothe's method!</h4>
<p>鉴于这些考虑，我们将这样做：让我们首先为这个二阶问题定义一个简单的时间步进方法，然后在第二步做空间离散化，即我们将遵循Rothe的方法。</p>
<p>对于第一步，让我们先绕一点路：为了离散化一个第二时间导数，我们可以直接离散化它，或者引入一个额外的变量，将系统转化为一阶系统。在许多情况下，这证明是等价的，但处理一阶系统往往更简单。为此，让我们引入</p>
<p class="formulaDsp">
\[ v = \frac{\partial u}{\partial t}, \]
</p>
<p>并称这个变量为<em>velocity</em>，原因很明显。然后，我们可以将原来的波浪方程重新表述如下。</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{\partial u}{\partial t} - v &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times [0,T], \\ \frac{\partial v}{\partial t} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ v(x,0) &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}
</p>
<p>这个公式的优点是它现在只包含两个变量的第一时间导数，对于它来说，写下时间步进方案很简单。请注意，我们起初没有 \(v\) 的边界条件。然而，我们可以在边界上强制执行 \(v=\frac{\partial g}{\partial t}\) 。在数值例子中发现，这实际上是必要的：如果不这样做，解决方案看起来并不特别错误，但如果不执行这些边界条件，Crank-Nicolson方案并不保存能量。</p>
<p>有了这个公式，让我们引入以下时间离散化，其中上标 \(n\) 表示一个时间步长， \(k=t_n-t_{n-1}\) 是当前时间步长。</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{u^n - u^{n-1}}{k} - \left[\theta v^n + (1-\theta) v^{n-1}\right] &amp;=&amp; 0, \\ \frac{v^n - v^{n-1}}{k} - \Delta\left[\theta u^n + (1-\theta) u^{n-1}\right] &amp;=&amp; \theta f^n + (1-\theta) f^{n-1}. \end{eqnarray*}
</p>
<p> 注意我们在这里引入了一个参数 \(\theta\) 。例如，如果我们选择 \(\theta=0\) ，第一个方程将简化为 \(\frac{u^n - u^{n-1}}{k} - v^{n-1} = 0\) ，这就是众所周知的正向或显式欧拉方法。另一方面，如果我们设定 \(\theta=1\) ，那么我们将得到 \(\frac{u^n - u^{n-1}}{k} - v^n = 0\) ，这对应于后向或隐式欧拉方法。这两种方法都是一阶精确方法。它们实现起来很简单，但其实并不十分精确。</p>
<p>第三种情况是选择 \(\theta=\frac 12\) 。然后上面的第一个方程将变成 \(\frac{u^n - u^{n-1}}{k} - \frac 12 \left[v^n + v^{n-1}\right] = 0\) 。这种方法被称为Crank-Nicolson方法，它的优点是二阶精确。此外，它还有一个很好的特性，即保留了溶液中的能量（从物理上讲，能量是膜中粒子的动能加上由于局部拉伸而存在的势能的总和；这个量在连续方程中是一个守恒量，但大多数时间步进方案在时间离散化后并不保留它）。由于 \(v^n\) 也出现在 \(u^n\) 的方程中，Crank-Nicolson方案也是隐式的。</p>
<p>在程序中，我们将把 \(\theta\) 作为一个参数，这样就很容易发挥它的作用了。结果部分将显示一些比较不同方案的数字证据。</p>
<p>上面的方程（称为<em>semidiscretized</em>方程，因为我们只离散了时间，而没有离散空间），可以通过从第一个方程中消除 \(v^n\) 和重新排列项来简化一下。然后我们得到</p>
<p class="formulaDsp">
\begin{eqnarray*} \left[ 1-k^2\theta^2\Delta \right] u^n &amp;=&amp; \left[ 1+k^2\theta(1-\theta)\Delta\right] u^{n-1} + k v^{n-1} + k^2\theta\left[\theta f^n + (1-\theta) f^{n-1}\right],\\ v^n &amp;=&amp; v^{n-1} + k\Delta\left[ \theta u^n + (1-\theta) u^{n-1}\right] + k\left[\theta f^n + (1-\theta) f^{n-1}\right]. \end{eqnarray*}
</p>
<p>在这种形式下，我们看到，如果我们得到了前一个时间段的解 \(u^{n-1},v^{n-1}\) ，那么我们就可以分别求解变量 \(u^n,v^n\) ，也就是一次一个。这很方便。此外，我们认识到第一个方程中的算子是正定的，而第二个方程看起来特别简单。</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>我们现在已经得出了将时间 \(u^n(x)\) 的近似（半离散）解 \(v^n(x)\) 及其时间导数 \(t_n\) 与前一个时间步骤 \(t_{n-1}\) 的解 \(u^{n-1}(x),v^{n-1}(x)\) 相关的方程。下一步是使用通常的有限元方法将空间变量离散化。为此，我们将每个方程与一个测试函数相乘，在整个域上进行积分，并在必要时进行部分积分。这就导致了</p>
<p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \\ (v^n,\varphi) &amp;=&amp; (v^{n-1},\varphi) - k\left[ \theta (\nabla u^n,\nabla\varphi) + (1-\theta) (\nabla u^{n-1},\nabla \varphi)\right] + k \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}
</p>
<p>然后习惯于近似 \(u^n(x) \approx u^n_h(x) = \sum_i U_i^n\phi_i^n(x)\) ，其中 \(\phi_i^n(x)\) 是用于离散化 \(n\) -个时间步长的形状函数， \(U_i^n\) 是解决方案的未知结点值。同样地， \(v^n(x) \approx v^n_h(x) = \sum_i V_i^n\phi_i^n(x)\) 。最后，我们有前一个时间步骤的解， \(u^{n-1}(x) \approx u^{n-1}_h(x) = \sum_i U_i^{n-1}\phi_i^{n-1}(x)\) 和 \(v^{n-1}(x) \approx v^{n-1}_h(x) = \sum_i V_i^{n-1}\phi_i^{n-1}(x)\) 。请注意，由于在我们到达时间步骤 \(n\) 时，前一个时间步骤的解已经被计算出来了，所以 \(U^{n-1},V^{n-1}\) 是已知的。此外，注意上一步的解可能是在不同的网格上计算的，所以我们必须使用形状函数 \(\phi^{n-1}_i(x)\) 。</p>
<p>如果我们将这些扩展插入上述方程，并用本网的测试函数进行测试，我们得到以下线性系统。</p>
<p class="formulaDsp">
\begin{eqnarray*} (M^n + k^2\theta^2 A^n)U^n &amp;=&amp; M^{n,n-1}U^{n-1} - k^2\theta(1-\theta) A^{n,n-1}U^{n-1} + kM^{n,n-1}V^{n-1} + k^2\theta \left[ \theta F^n + (1-\theta) F^{n-1} \right], \\ M^nV^n &amp;=&amp; M^{n,n-1}V^{n-1} - k\left[ \theta A^n U^n + (1-\theta) A^{n,n-1} U^{n-1}\right] + k \left[ \theta F^n + (1-\theta) F^{n-1} \right], \end{eqnarray*}
</p>
<p> 其中</p>
<p class="formulaDsp">
\begin{eqnarray*} M^n_{ij} &amp;=&amp; (\phi_i^n, \phi_j^n), \\ A^n_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^n), \\ M^{n,n-1}_{ij} &amp;=&amp; (\phi_i^n, \phi_j^{n-1}), \\ A^{n,n-1}_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^{n-1}), \\ F^n_{i} &amp;=&amp; (f^n,\phi_i^n), \\ F^{n-1}_{i} &amp;=&amp; (f^{n-1},\phi_i^n). \end{eqnarray*}
</p>
<p>如果我们解决这两个方程，我们可以将解决方案向前推进一步，并进入下一个时间步骤。</p>
<p>值得注意的是，如果我们在每个时间步长选择相同的网格（事实上我们将在下面的程序中这样做），那么我们在时间步长 \(n\) 和 \(n-1\) 上有相同的形状函数，即 \(\phi^n_i=\phi_i^{n-1}=\phi_i\) 。因此，我们得到 \(M^n=M^{n,n-1}=M\) 和 \(A^n=A^{n,n-1}=A\) 。另一方面，如果我们使用了不同的形状函数，那么我们将不得不计算包含定义在两个网格上的形状函数的积分。这是一个有些混乱的过程，我们在此省略，但在步骤28中会有一些详细的处理。</p>
<p>在这些条件下（即网格不发生变化），我们可以通过基本消除第二个线性系统的解来优化求解过程。我们将在 <a class="el" href="step_25.html">step-25 </a>程序的介绍中讨论这个问题。</p>
<p><a class="anchor" id="Energyconservation"></a></p><h3>Energy conservation</h3>
<p>比较时间步进方案质量的一个方法是看数值近似是否保留了连续方程的守恒特性。对于波浪方程来说，自然要看的是能量。通过将波浪方程乘以 \(u_t\) ，对 \(\Omega\) 进行积分，并在必要时进行部分积分，我们发现</p>
<p class="formulaDsp">
\[ \frac{d}{d t} \left[\frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx\right] = \int_\Omega f \frac{\partial u}{\partial t} \; dx + \int_{\partial\Omega} n\cdot\nabla u \frac{\partial g}{\partial t} \; dx. \]
</p>
<p>因此，在没有体力和恒定边界值的情况下，我们得到的结果是</p>
<p class="formulaDsp">
\[ E(t) = \frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx \]
</p>
<p>是一个守恒量，即一个不随时间变化的量。我们将在每个时间步骤后计算这个量。很容易看出，如果我们用有限元近似值代替 \(u\) ，用速度的有限元近似值代替 \(\frac{\partial u}{\partial t}\) ，那么</p>
<p class="formulaDsp">
\[ E(t_n) = \frac 12 \left&lt;V^n, M^n V^n\right&gt; + \frac 12 \left&lt;U^n, A^n U^n\right&gt;. \]
</p>
<p>正如我们将在结果部分看到的，Crank-Nicolson方案确实保存了能量，而前向和后向Euler方案都没有。</p>
<p><a class="anchor" id="WhoareCourantFriedrichsandLewy"></a></p><h3>Who are Courant, Friedrichs, and Lewy?</h3>
<p>波浪方程的数值求解很麻烦，原因之一是显式时间离散化只有在时间步长足够小的情况下才稳定。特别是，它与空间网格宽度有耦合关系 \(h\) 。对于我们这里使用的最低阶离散化，其关系为</p>
<p class="formulaDsp">
\[ k\le \frac hc \]
</p>
<p>其中 \(c\) 是波速，在我们对波浪方程的表述中，它已被归一。因此，除非我们使用带有 \(\theta&gt;0\) 的隐式方案，否则如果我们违反这一限制，我们的解在数值上是不稳定的。隐式方案在稳定性方面没有这个限制，但如果时间步长过大，它们就会变得不准确了。</p>
<p>这一条件是由库兰特、弗里德里希斯和卢伊首先认识到的；在1928年，远在计算机可用于数值计算之前！（这一结果出现在德语文章R.库兰特、K.弗里德里希斯和H.卢伊中。这个结果出现在德语文章R.Courant, K. Friedrichs and H. Lewy:<em>&Uuml;ber die partiellen Differenzengleichungen der mathematischen Physik</em>, Mathematische Annalen, vol. 100, no. 1, pages 32-74, 1928.)这个关于时间步长的条件最常被称为<em>CFL</em>条件。直观地说，CFL条件说的是，时间步长不能大于一个波穿过一个单元的时间。</p>
<p>在程序中，我们将对正方形 \([-1,1]^2\) 均匀地细化七次，得到的网格尺寸为 \(h=\frac 1{64}\) ，这就是我们设置的时间步长。我们在两个不同的地方分别设置时间步长和网格尺寸是很容易出错的：很容易再细化一次网格，却忘记同时调整时间步长。 <a class="el" href="step_24.html">step-24 </a>显示了一个更好的方法来保持这些东西的同步。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>尽管该程序具有处理非零初始和边界条件以及体力的所有钩子，但我们采取一个简单的案例，即领域是一个正方形 \([-1,1]^2\) ，并且</p>
<p class="formulaDsp">
\begin{eqnarray*} f &amp;=&amp; 0, \\ u_0 &amp;=&amp; 0, \\ u_1 &amp;=&amp; 0, \\ g &amp;=&amp; \left\{\begin{matrix}\sin (4\pi t) &amp;\qquad&amp; \text{for }\ t\le \frac 12, x=-1, -\frac 13&lt;y&lt;\frac 13 \\ 0 &amp;&amp;\text{otherwise} \end{matrix} \right. \end{eqnarray*}
</p>
<p>这相当于一个最初处于静止状态、四周被夹住的膜，有人将夹住的边界的一部分上下挥动一次，从而将波射入领域。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with the usual assortment of include files that we've seen in so many of the previous tests:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Here are the only three include files of some new interest: The first one is already used, for example, for the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> and <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> functions. However, we here use another function in that class, <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> to compute our initial values as the \(L^2\) projection of the continuous initial values. Furthermore, we use <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a> to generate the integrals \((f^n,\phi^n_i)\). These were previously always generated by hand in <code>assemble_system</code> or similar functions in application code. However, we're too lazy to do that here, so simply use a library function:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>In a very similar vein, we are also too lazy to write the code to assemble mass and Laplace matrices, although it would have only taken copying the relevant code from any number of previous tutorial programs. Rather, we want to focus on the things that are truly new to this program and therefore use the <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a> and <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a> functions. They are declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, here is an include file that contains all sorts of tool functions that one sometimes needs. In particular, we need the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> class that, given an integer argument, returns a string representation of it. It is particularly useful since it allows for a second parameter indicating the number of digits to which we want the result padded with leading zeros. We will use this to write output files that have the form <code>solution-XXX.vtu</code> where <code>XXX</code> denotes the number of the time step and always consists of three digits even if we are still in the single or double digit time steps.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeWaveEquationcodeclass"></a> </p><h3>The <code>WaveEquation</code> class</h3>
<p>Next comes the declaration of the main class. It's public interface of functions is like in most of the other tutorial programs. Worth mentioning is that we now have to store four matrices instead of one: the mass matrix \(M\), the Laplace matrix \(A\), the matrix \(M+k^2\theta^2A\) used for solving for \(U^n\), and a copy of the mass matrix with boundary conditions applied used for solving for \(V^n\). Note that it is a bit wasteful to have an additional copy of the mass matrix around. We will discuss strategies for how to avoid this in the section on possible improvements.</p>
<p>Likewise, we need solution vectors for \(U^n,V^n\) as well as for the corresponding vectors at the previous time step, \(U^{n-1},V^{n-1}\). The <code>system_rhs</code> will be used for whatever right hand side vector we have when solving one of the two linear systems in each time step. These will be solved in the two functions <code>solve_u</code> and <code>solve_v</code>.</p>
<p>Finally, the variable <code>theta</code> is used to indicate the parameter \(\theta\) that is used to define which time stepping scheme to use, as explained in the introduction. The rest is self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>WaveEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WaveEquation();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> solve_u();</div><div class="line">  <span class="keywordtype">void</span> solve_v();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_u, solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> old_solution_u, old_solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">double</span>       time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial and boundary values for both the solution \(u\) and its time derivative \(v\), as well as a right hand side class. We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not be a surprise.</p>
<p>Let's start with initial values and choose zero for both the value \(u\) as well as its time derivative, the velocity \(v\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Secondly, we have the right hand side forcing term. Boring as we are, we choose zero here as well:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Finally, we have boundary values for \(u\) and \(v\). They are as described in the introduction, one being the time derivative of the other:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">        (p[1] &gt; -1. / 3))</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">        (p[1] &gt; -1. / 3))</div><div class="line">      <span class="keywordflow">return</span> (std::cos(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>) * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeWaveEquationcodeclass"></a> </p><h3>Implementation of the <code>WaveEquation</code> class</h3>
<p>The implementation of the actual logic is actually fairly short, since we relegate things like assembling the matrices and right hand side vectors to the library. The rest boils down to not much more than 130 lines of actual code, a significant fraction of which is boilerplate code that can be taken from previous example programs (e.g. the functions that solve linear systems, or that generate output).</p>
<p>Let's start with the constructor (for an explanation of the choice of time step, see the section on Courant, Friedrichs, and Lewy in the introduction):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">WaveEquation&lt;dim&gt;::WaveEquation()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time_step(1. / 64)</div><div class="line">  , time(time_step)</div><div class="line">  , timestep_number(1)</div><div class="line">  , theta(0.5)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsetup_system"></a> </p><h4>WaveEquation::setup_system</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div></div><!-- fragment --><p>Then comes a block where we have to initialize the 3 matrices we need in the course of the program: the mass matrix, the Laplace matrix, and the matrix \(M+k^2\theta^2A\) used when solving for \(U^n\) in each time step.</p>
<p>When setting up these matrices, note that they all make use of the same sparsity pattern object. Finally, the reason why matrices and sparsity patterns are separate objects in deal.II (unlike in many other finite element or linear algebra classes) becomes clear: in a significant fraction of applications, one has to hold several matrices that happen to have the same sparsity pattern, and there is no reason for them not to share this information, rather than re-building and wasting memory on it several times.</p>
<p>After initializing all of these matrices, we call library functions that build the Laplace and mass matrices. All they need is a <a class="el" href="classDoFHandler.html">DoFHandler</a> object and a quadrature formula object that is to be used for numerical integration. Note that in many respects these functions are better than what we would usually do in application programs, for example because they automatically parallelize building the matrices if multiple processors are available in a machine: for more information see the documentation of <a class="el" href="namespaceWorkStream.html">WorkStream</a> or the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. The matrices for solving linear systems will be filled in the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> method because we need to re-apply boundary conditions every time step.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">laplace_matrix.reinit(sparsity_pattern);</div><div class="line">matrix_u.reinit(sparsity_pattern);</div><div class="line">matrix_v.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"><a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line"><a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                     laplace_matrix);</div></div><!-- fragment --><p>The rest of the function is spent on setting vector sizes to the correct value. The final line closes the hanging node constraints object. Since we work on a uniformly refined mesh, no constraints exist or have been computed (i.e. there was no need to call <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a> as in other programs), but we need a constraints object in one place further down below anyway.</p>
<div class="fragment"><div class="line">  solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsolve_uandWaveEquationsolve_v"></a> </p><h4>WaveEquation::solve_u and WaveEquation::solve_v</h4>
<p>The next two functions deal with solving the linear systems associated with the equations for \(U^n\) and \(V^n\). Both are not particularly interesting as they pretty much follow the scheme used in all the previous tutorial programs.</p>
<p>One can make little experiments with preconditioners for the two matrices we have to invert. As it turns out, however, for the matrices at hand here, using Jacobi or SSOR preconditioners reduces the number of iterations necessary to solve the linear system slightly, but due to the cost of applying the preconditioner it is no win in terms of run-time. It is not much of a loss either, but let's keep it simple and just do without:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(matrix_u, solution_u, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(matrix_v, solution_v, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationoutput_results"></a> </p><h4>WaveEquation::output_results</h4>
<p>Likewise, the following function is pretty much what we've done before. The only thing worth mentioning is how here we generate a string representation of the time step number padded with leading zeros to 3 character length using the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> function's second argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div></div><!-- fragment --><p>Like <a class="el" href="step_15.html">step-15</a>, since we write output at every time step (and the system we have to solve is relatively easy), we instruct <a class="el" href="classDataOut.html">DataOut</a> to use the zlib compression algorithm that is optimized for speed instead of disk usage since otherwise plotting the output becomes a bottleneck:</p>
<div class="fragment"><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">  vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">    DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(vtk_flags);</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationrun"></a> </p><h4>WaveEquation::run</h4>
<p>The following is really the only interesting function of the program. It contains the loop over all time steps, but before we get to that we have to set up the grid, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices. In addition, we have to somehow get started with initial values. To this end, we use the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function that takes an object that describes a continuous function and computes the \(L^2\) projection of this function onto the finite element space described by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. Can't be any simpler than that:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WaveEquation&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  setup_system();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                       constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                       InitialValuesU&lt;dim&gt;(),</div><div class="line">                       old_solution_u);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                       constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                       InitialValuesV&lt;dim&gt;(),</div><div class="line">                       old_solution_v);</div></div><!-- fragment --><p>The next thing is to loop over all the time steps until we reach the end time ( \(T=5\) in this case). In each time step, we first have to solve for \(U^n\), using the equation \((M^n + k^2\theta^2 A^n)U^n =\) \((M^{n,n-1} - k^2\theta(1-\theta) A^{n,n-1})U^{n-1} + kM^{n,n-1}V^{n-1} +\) \(k\theta \left[k \theta F^n + k(1-\theta) F^{n-1} \right]\). Note that we use the same mesh for all time steps, so that \(M^n=M^{n,n-1}=M\) and \(A^n=A^{n,n-1}=A\). What we therefore have to do first is to add up \(MU^{n-1} - k^2\theta(1-\theta) AU^{n-1} + kMV^{n-1}\) and the forcing terms, and put the result into the <code>system_rhs</code> vector. (For these additions, we need a temporary vector that we declare before the loop to avoid repeated memory allocations in each time step.)</p>
<p>The one thing to realize here is how we communicate the time variable to the object describing the right hand side: each object derived from the <a class="el" href="classFunction.html">Function</a> class has a time field that can be set using the <a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">Function::set_time</a> and read by <a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">Function::get_time</a>. In essence, using this mechanism, all functions of space and time are therefore considered functions of space evaluated at a particular time. This matches well what we typically need in finite element programs, where we almost always work on a single time step at a time, and where it never happens that, for example, one would like to evaluate a space-time function for all times at any given spatial location.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution_u.size());</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> forcing_terms(solution_u.size());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; time &lt;= 5; time += time_step, ++timestep_number)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(system_rhs, old_solution_u);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">    system_rhs.add(time_step, tmp);</div><div class="line"></div><div class="line">    laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">    system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp);</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">    rhs_function.set_time(time);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                        rhs_function,</div><div class="line">                                        tmp);</div><div class="line">    forcing_terms = tmp;</div><div class="line">    forcing_terms *= theta * time_step;</div><div class="line"></div><div class="line">    rhs_function.set_time(time - time_step);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                        rhs_function,</div><div class="line">                                        tmp);</div><div class="line"></div><div class="line">    forcing_terms.add((1 - theta) * time_step, tmp);</div><div class="line"></div><div class="line">    system_rhs.add(theta * time_step, forcing_terms);</div></div><!-- fragment --><p>After so constructing the right hand side vector of the first equation, all we have to do is apply the correct boundary values. As for the right hand side, this is a space-time function evaluated at a particular time, which we interpolate at boundary nodes and then use the result to apply boundary values as we usually do. The result is then handed off to the solve_u() function:</p>
<div class="fragment"><div class="line">{</div><div class="line">  BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">  boundary_values_u_function.set_time(time);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           boundary_values_u_function,</div><div class="line">                                           boundary_values);</div></div><!-- fragment --><p>The matrix for solve_u() is the same in every time steps, so one could think that it is enough to do this only once at the beginning of the simulation. However, since we need to apply boundary values to the linear system (which eliminate some matrix rows and columns and give contributions to the right hand side), we have to refill the matrix in every time steps before we actually apply boundary data. The actual content is very simple: it is the sum of the mass matrix and a weighted Laplace matrix:</p>
<div class="fragment"><div class="line">  matrix_u.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  matrix_u.add(theta * theta * time_step * time_step, laplace_matrix);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     matrix_u,</div><div class="line">                                     solution_u,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line">solve_u();</div></div><!-- fragment --><p>The second step, i.e. solving for \(V^n\), works similarly, except that this time the matrix on the left is the mass matrix (which we copy again in order to be able to apply boundary conditions, and the right hand side is \(MV^{n-1} - k\left[ \theta A U^n + (1-\theta) AU^{n-1}\right]\) plus forcing terms. Boundary values are applied in the same way as before, except that now we have to use the BoundaryValuesV class:</p>
<div class="fragment"><div class="line">laplace_matrix.vmult(system_rhs, solution_u);</div><div class="line">system_rhs *= -theta * time_step;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">system_rhs += tmp;</div><div class="line"></div><div class="line">laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">system_rhs.add(-time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">system_rhs += forcing_terms;</div><div class="line"></div><div class="line">{</div><div class="line">  BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">  boundary_values_v_function.set_time(time);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           boundary_values_v_function,</div><div class="line">                                           boundary_values);</div><div class="line">  matrix_v.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     matrix_v,</div><div class="line">                                     solution_v,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line">solve_v();</div></div><!-- fragment --><p>Finally, after both solution components have been computed, we output the result, compute the energy in the solution, and go on to the next time step after shifting the present solution into the vectors that hold the solution at the previous time step. Note the function <a class="el" href="classSparseMatrix.html#a56d106dfe8792db57f2d6e60bdfe63e1">SparseMatrix::matrix_norm_square</a> that can compute \(\left&lt;V^n,MV^n\right&gt;\) and \(\left&lt;U^n,AU^n\right&gt;\) in one step, saving us the expense of a temporary vector and several lines of code:</p>
<div class="fragment"><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square(solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square(solution_u)) /</div><div class="line">                       2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step23</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>What remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"></div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-23/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>当该程序运行时，它产生了以下输出。</p>
<div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Number of degrees of freedom: 16641</div><div class="line"></div><div class="line"></div><div class="line">Time step 1 at t=0.015625</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 22 CG iterations.</div><div class="line">   Total energy: 1.17887</div><div class="line">Time step 2 at t=0.03125</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 2.9655</div><div class="line">Time step 3 at t=0.046875</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 4.33761</div><div class="line">Time step 4 at t=0.0625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 5.35499</div><div class="line">Time step 5 at t=0.078125</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 6.18652</div><div class="line">Time step 6 at t=0.09375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 6.6799</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">Time step 31 at t=0.484375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 21.9068</div><div class="line">Time step 32 at t=0.5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.3394</div><div class="line">Time step 33 at t=0.515625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">Time step 319 at t=4.98438</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line">Time step 320 at t=5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div></div><!-- fragment --><p>我们立即看到的是，至少在 \(t=\frac 12\) 之后，能量是一个常数（在此之前，边界源项 \(g\) 是非零的，向系统注入能量）。</p>
<p>除了屏幕输出外，程序还将每个时间步骤的解写到输出文件中。如果我们对其进行充分处理，并将其粘贴到电影中，我们会得到以下结果。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-23.movie.gif" alt="Animation of the solution of step 23."/>
</div>
<p>影片显示了所产生的波在域中移动并返回，在夹持的边界处被反射。一些数值噪声跟在波的后面，这是由于网格尺寸过大造成的假象，可以通过减小网格宽度和时间步长来减少。</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>如果你想探索一下，可以尝试以下一些东西。 </p><ul>
<li>
<p class="startli">Varying \(\theta\) 。这给出了不同的时间步进方案，其中一些是稳定的，而另一些则不是。看一看能量是如何演变的。 </p><pre class="fragment">&lt;li&gt;  不同的初始和边界条件，右手边。

&lt;li&gt;  更复杂的域或更精细的网格。请记住，时间步长需要以网格宽度为界，所以改变网格也应该包括改变时间步长。我们将在第24步再来讨论这个问题。

&lt;li&gt;  可变系数。在现实介质中，波速往往是可变的。特别是，现实介质中的 "真实 "波浪方程将读作 \form#3092@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl
</pre><p>其中 \(\rho(x)\) 是材料的密度， \(a(x)\) 与刚度系数有关。那么波速就是 \(c=\sqrt{a/\rho}\) 。</p>
<p>为了做出这样的改变，我们将不得不用可变系数来计算质量和拉普拉斯矩阵。幸运的是，这并不难：函数 <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a> 和 <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a> 有额外的默认参数，可以用来向它们传递非恒定系数函数。因此，所需的变化相对较小。另一方面，必须再次注意确保时间步长在允许范围内。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">在代码内的注释中，我们讨论了这样一个事实：由于边界条件的原因，用于求解 \(U^n\) 和 \(V^n\) 的矩阵需要在每次都被重置，尽管实际内容没有变化。可以通过不消除线性系统中的列来避免复制，这可以通过在调用中附加一个 <code>false</code> 参数来实现。</p><div class="fragment"><div class="line"><a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                   matrix_u,</div><div class="line">                                   solution_u,</div><div class="line">                                   system_rhs,</div><div class="line">                                   <span class="keyword">false</span>);</div></div><!-- fragment --><pre class="fragment">&lt;li&gt;  deal.II是一个支持自适应网格的库，如果这个程序支持每隔几步就改变网格，那当然很好。考虑到解决方案的结构&amp;mdash; 一个穿越领域的波浪&amp;mdash; 如果我们只在波浪目前所在的地方完善网格，而不是简单地在所有地方完善网格，这似乎是合适的。直观地看，我们应该能够通过这种方式节省大量的单元。虽然经过进一步的思考，我们意识到这只是在模拟的初始阶段。   一段时间后，对于波浪现象来说，域中充满了初始波的反射，向各个方向发展，充满了域中的每个角落。   在这一点上，一般来说，使用局部网格细化可以获得的好处不多）。)
</pre><p>为了使自适应改变网格成为可能，基本上有两条路线。 "正确 "的方法是回到我们使用罗特方法得到的弱形式。例如，在每个时间步骤中要解决的两个方程中的第一个方程看起来是这样的。 </p><p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}
</p>
<p> 现在，注意我们在网格 \({\mathbb T}^n\) 上求解 \(u^n\) ，因此测试函数 \(\varphi\) 也必须来自空间 \(V_h^n\) 。正如在介绍中所讨论的，像 \((u^{n-1},\varphi)\) 这样的条款要求我们将上一步的解决方案（可能是在不同的网格 \({\mathbb T}^{n-1}\) 上计算的）与当前网格的测试函数进行整合，从而得到一个矩阵 \(M^{n,n-1}\) 。这个整合不同网格的形状函数的过程，充其量是尴尬的。它是可以做到的，但是因为很难保证 \({\mathbb T}^{n-1}\) 和 \({\mathbb T}^{n}\) 最多只相差一个细化级别，所以我们必须递归匹配两个网格的单元。这样做是可行的，但它会导致冗长的、不完全明显的代码。</p>
<p>第二种方法如下：每当我们改变网格时，我们只需使用SolutionTransfer类将旧网格上的最后一个时间步长的解内插到新网格上。换句话说，我们将解决 </p><p class="formulaDsp">
\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (I^n u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla I^n u^{n-1},\nabla \varphi) + k(I^n v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \end{eqnarray*}
</p>
<p>，其中 \(I^n\) 将一个给定的函数插值到网格 \({\mathbb T}^n\) ，而不是上面的方程。 这是一个更简单的方法，因为在每个时间步长中，我们不再需要担心 \(u^{n-1},v^{n-1}\) 是在我们现在使用的同一个网格上计算的，还是在不同的网格上计算的。因此，代码的唯一变化是增加了一个计算误差的函数，为细化标记单元，设置SolutionTransfer对象，将解转移到新的网格上，并在新的网格上重建矩阵和右手向量。建立矩阵和右手边的函数以及求解器都不需要改变。</p>
<p class="endli">虽然严格来说，这第二种方法在罗特框架中是不太正确的（它引入了一个额外的误差源，即插值），然而这几乎是每个人在解决时间相关方程时所做的事情。我们将在步骤31中使用这种方法，例如。 </p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>WaveEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    WaveEquation();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> solve_u();</div><div class="line">    <span class="keywordtype">void</span> solve_v();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution_u, solution_v;</div><div class="line">    Vector&lt;double&gt; old_solution_u, old_solution_v;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">          (p[1] &gt; -1. / 3))</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp; (p[0] &lt; 0) &amp;&amp; (p[1] &lt; 1. / 3) &amp;&amp;</div><div class="line">          (p[1] &gt; -1. / 3))</div><div class="line">        <span class="keywordflow">return</span> (std::cos(this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>) * 4 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  WaveEquation&lt;dim&gt;::WaveEquation()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time_step(1. / 64)</div><div class="line">    , time(time_step)</div><div class="line">    , timestep_number(1)</div><div class="line">    , theta(0.5)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">    laplace_matrix.reinit(sparsity_pattern);</div><div class="line">    matrix_u.reinit(sparsity_pattern);</div><div class="line">    matrix_v.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         laplace_matrix);</div><div class="line"></div><div class="line">    solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_u.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(matrix_u, solution_u, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(matrix_v, solution_v, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">    vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(vtk_flags);</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WaveEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesU&lt;dim&gt;(),</div><div class="line">                         old_solution_u);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesV&lt;dim&gt;(),</div><div class="line">                         old_solution_v);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(solution_u.size());</div><div class="line">    Vector&lt;double&gt; forcing_terms(solution_u.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= 5; time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(system_rhs, old_solution_u);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        system_rhs.add(time_step, tmp);</div><div class="line"></div><div class="line">        laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">        system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp);</div><div class="line"></div><div class="line">        RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">        rhs_function.set_time(time);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                            rhs_function,</div><div class="line">                                            tmp);</div><div class="line">        forcing_terms = tmp;</div><div class="line">        forcing_terms *= theta * time_step;</div><div class="line"></div><div class="line">        rhs_function.set_time(time - time_step);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(dof_handler,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                            rhs_function,</div><div class="line">                                            tmp);</div><div class="line"></div><div class="line">        forcing_terms.add((1 - theta) * time_step, tmp);</div><div class="line"></div><div class="line">        system_rhs.add(theta * time_step, forcing_terms);</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">          boundary_values_u_function.set_time(time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                   0,</div><div class="line">                                                   boundary_values_u_function,</div><div class="line">                                                   boundary_values);</div><div class="line"></div><div class="line">          matrix_u.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">          matrix_u.add(theta * theta * time_step * time_step, laplace_matrix);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                             matrix_u,</div><div class="line">                                             solution_u,</div><div class="line">                                             system_rhs);</div><div class="line">        }</div><div class="line">        solve_u();</div><div class="line"></div><div class="line"></div><div class="line">        laplace_matrix.vmult(system_rhs, solution_u);</div><div class="line">        system_rhs *= -theta * time_step;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        system_rhs += tmp;</div><div class="line"></div><div class="line">        laplace_matrix.vmult(tmp, old_solution_u);</div><div class="line">        system_rhs.add(-time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        system_rhs += forcing_terms;</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">          boundary_values_v_function.set_time(time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                   0,</div><div class="line">                                                   boundary_values_v_function,</div><div class="line">                                                   boundary_values);</div><div class="line">          matrix_v.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                             matrix_v,</div><div class="line">                                             solution_v,</div><div class="line">                                             system_rhs);</div><div class="line">        }</div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square(solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square(solution_u)) /</div><div class="line">                       2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step23</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"></div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
