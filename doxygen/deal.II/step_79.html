<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_79.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-79 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-79 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic Material with Penalization</a>
        <li><a href="#ElasticityEquation">Elasticity Equation</a>
        <li><a href="#Makingthesolutionmeshindependent">Making the solution mesh-independent</a>
        <li><a href="#CompleteProblemFormulation">Complete Problem Formulation</a>
        <li><a href="#Solutionprocedure">Solution procedure</a>
        <li><a href="#Discretization">Discretization</a>
        <li><a href="#NonlinearAlgorithm">Nonlinear Algorithm</a>
        <li><a href="#MeritFunction">Merit Function</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Preliminaries">Preliminaries</a>
        <li><a href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a>
        <li><a href="#Constructorandsetupfunctions">Constructor and set-up functions</a>
        <li><a href="#Settingupblockmatricesandvectors">Setting up block matrices and vectors</a>
        <li><a href="#Creatingthefiltermatrix">Creating the filter matrix</a>
        <li><a href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a>
        <li><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear system</a>
        <li><a href="#Detailsoftheoptimizationalgorithm">Details of the optimization algorithm</a>
      <ul>
        <li><a href="#Computingsteplengths">Computing step lengths</a>
        <li><a href="#Computingresiduals">Computing residuals</a>
        <li><a href="#Computingthemeritfunction">Computing the merit function</a>
        <li><a href="#Findingasearchdirection">Finding a search direction</a>
        <li><a href="#Computingascaledstep">Computing a scaled step</a>
        <li><a href="#Checkingforconvergence">Checking for convergence</a>
      </ul>
        <li><a href="#Postprocessingthesolution">Postprocessing the solution</a>
        <li><a href="#Therunfunctiondrivingtheoverallalgorithm">The run() function driving the overall algorithm</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#TestProblem">Test Problem</a>
      <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>Topology Optimization of Elastic Media is a technique used to optimize a structure that is bearing some load. Ideally, we would like to minimize the maximum stress placed on a structure by selecting a region \(E\) where material is placed. In other words, </p><p class="formulaDsp">
\[ \text{minimize}\| \boldsymbol{\sigma} (\mathbf{u}) \|_\infty \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } |E|\leq V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0}. \]
</p>
<p>Here, \(\boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon}(\mathbf{u})\) is the stress within the body that is caused by the external forces \(\mathbf F\), where we have for simplicity assumed that the material is linear-elastic and so \(\mathbf{C}\) is the stress-strain tensor and \(\boldsymbol{\varepsilon}(\mathbf{u})=\frac{1}{2} (\nabla \mathbf{u} + (\nabla\mathbf{u})^T)\) is the small-deformation strain as a function of the displacement \(\mathbf{u}\) &ndash; see <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a> for more on linear elasticity. In the formulation above, \(V_\text{max}\) is the maximal amount of material we are willing to provide to build the object. The last of the constraints is the partial differential equation that relates stress \(\boldsymbol{\sigma}\) and forces \(\mathbf F\) and is simply the steady-state force balance.</p>
<p>That said, the infinity norm above creates a problem: As a function of location of material, this objective function is necessarily not differentiable, making prospects of optimization rather bleak. So instead, a common approach in topology optimization is to find an approximate solution by optimizing a related problem: We would like to minimize the strain energy. This is a measure of the potential energy stored in an object due to its deformation, but also works as a measure of total deformation over the structure.</p>
<p class="formulaDsp">
\[ \text{minimize } \int_E \frac{1}{2}\boldsymbol{\sigma} : \boldsymbol{\varepsilon} dV \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \|E\| \leq V_{\max} \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} \]
</p>
<p>The value of the objective function is calculated using a finite element method, where the solution is the displacements. This is placed inside of a nonlinear solver loop that solves for a vector denoting placement of material.</p>
<p><a class="anchor" id="SolidIsotropicMaterialwithPenalization"></a></p><h3>Solid Isotropic Material with Penalization</h3>
<p>In actual practice, we can only build objects in which the material is either present, or not present, at any given point &ndash; i.e., we would have an indicator function \(\rho_E(\mathbf{x})\in \{0,1\}\) that describes the material-filled region and that we want to find through the optimization problem. In this case, the optimization problem becomes combinatorial, and very expensive to solve. Instead, we use an approach called Solid Isotropic Material with Penalization, or SIMP. <b>[Bendse2004]</b></p>
<p>The SIMP method is based on an idea of allowing the material to exist in a location with a density \(\rho\) between 0 and 1. A density of 0 suggests the material is not there, and it is not a part of the structure, while a density of 1 suggests the material is present. Values between 0 and 1 do not reflect a design we can create in the real-world, but allow us to turn the combinatorial problem into a continuous one. One then looks at density values \(\rho\), with the constraint that \(0 &lt; \rho_{\min} \leq \rho \leq 1\). The minimum value \(\rho_{\min}\), typically chosen to be around \(10^{-3}\), avoids the possibility of having an infinite strain energy, but is small enough to provide accurate results.</p>
<p>The straightforward application of the effect of this "density" on the elasticity of the media would be to simply multiply the stiffness tensor \(\mathbf{C}_0\) of the medium by the given density, that is, \(\mathbf{C} = \rho \mathbf{C}_0\). However, this approach often gives optimal solutions where density values are far from both 0 and 1. As one wants to find a real-world solution, meaning the material either is present or it is not, a penalty is applied to these in-between values. A simple and effective way to do this is to multiply the stiffness tensor by the density raised to some integer power penalty parameter \(p\), so that \(\mathbf{C} = \rho^p \mathbf{C}_0\). This makes density values farther away from 0 or 1 less effective. It has been shown that using \(p=3\) is sufficiently high to create 'black-and-white' solutions: that is, one gets optimal solutions in which material is either present or not present at all points.</p>
<p>More material should always provide a structure with a lower strain energy, and so the inequality constraint can be viewed as an equality where the total volume used is the maximum volume.</p>
<p>Using this density idea also allows us to reframe the volume constraint on the optimization problem. Use of SIMP then turns the optimization problem into the following:</p>
<p class="formulaDsp">
\[ \text{minimize } \int_\Omega \frac{1}{2}\boldsymbol{\sigma}(\rho) : \boldsymbol{\varepsilon}(\rho) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \int_\Omega \rho(x) d\Omega= V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ 0&lt;\rho_{\min}\leq \rho(x) \leq 1, \]
</p>
 <p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma}(\rho) + \mathbf{F} = 0 \quad \text{on } \Omega \]
</p>
<p> The final constraint, the balance of linear momentum (which we will refer to as the elasticity equation), gives a method for finding \(\boldsymbol{\sigma}\) and \(\boldsymbol{\varepsilon}\) given the density \(\rho\).</p>
<p><a class="anchor" id="ElasticityEquation"></a></p><h3>Elasticity Equation</h3>
<p>The elasticity equation in the time independent limit reads </p><p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} . \]
</p>
<p> In the situations we will care about, we will assume that the medium has a linear material response and in that case, we have that </p><p class="formulaDsp">
\[ \boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon} = \rho^p \mathbf{C}_0 : \boldsymbol{\varepsilon}(\mathbf{u}) = \rho^p \mathbf{C}_0 : \left[\frac{1}{2} (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) \right] . \]
</p>
<p> In everything we will do below, we will always consider the displacement field \(\mathbf{u}\) as the only solution variable, rather than considering \(\mathbf{u}\) and \(\boldsymbol{\sigma}\) as solution variables (as is done in mixed formulations).</p>
<p>Furthermore, we will make the assumption that the material is linear isotropic, in which case the stress-strain tensor can be expressed in terms of the Lam&eacute; parameters \(\lambda,\mu\) such that </p><p class="formulaDsp">
\begin{align} \boldsymbol{\sigma} &amp;= \rho^p (\lambda \text{tr}(\boldsymbol{\varepsilon}) \mathbf{I} + 2 \mu \boldsymbol{\varepsilon}) , \\ \sigma_{i,j} &amp;= \rho^p (\lambda \varepsilon_{k,k} \delta_{i,j} + 2 \mu \varepsilon_{i,j}) . \end{align}
</p>
<p> See <a class="el" href="step_8.html">step-8</a> for how this transformation works.</p>
<p>Integrating the objective function by parts gives </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u}))^T d\Omega+ \int_\Omega (\nabla \cdot \boldsymbol{\sigma}(\rho)) \cdot \mathbf{u} d\Omega= \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega , \]
</p>
<p> into which the linear elasticity equation can then be substituted, giving </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_\Omega \mathbf{F}\cdot \mathbf{u} d\Omega+ \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega . \]
</p>
<p> Because we are assuming no body forces, this simplifies further to </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega, \]
</p>
<p> which is the final form of the governing equation that we'll be considering from this point forward.</p>
<p><a class="anchor" id="Makingthesolutionmeshindependent"></a></p><h3>Making the solution mesh-independent</h3>
<p>Typically, the solutions to topology optimization problems are mesh-dependent, and as such the problem is ill-posed. This is because fractal structures are often formed as the mesh is refined further. As the mesh gains resolution, the optimal solution typically gains smaller and smaller structures. There are a few competing workarounds to this issue, but the most popular for first order optimization is the sensitivity filter, while second order optimization methods tend to prefer use of a density filter.</p>
<p>As the filters affect the gradient and Hessian of the strain energy (i.e., the objective function), the choice of filter has an effect on the solution of the problem. The density filter as part of a second order method works by introducing an unfiltered density, which we refer to as \(\varrho\), and then requiring that the density be a convolution of the unfiltered density: </p><p class="formulaDsp">
\[ \rho = H(\varrho). \]
</p>
<p> Here, \(H\) is an operator so that \(\rho(\mathbf{x})\) is some kind of average of the values of \(\varrho\) in the area around \(\mathbf{x}\) &ndash; i.e., it is a smoothed version of \(\varrho\).</p>
<p>This prevents checkerboarding; the radius of the filter allows the user to define an effective minimal beam width for the optimal structures we seek to find.</p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.checkerboard.png" alt="Checkerboarding occurring in an MBB Beam"/>
</div>
 </div><p><a class="anchor" id="CompleteProblemFormulation"></a></p><h3>Complete Problem Formulation</h3>
<p>The minimization problem is now </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega= V \]
</p>
 <p class="formulaDsp">
\[ 0\leq \varrho \leq 1 \]
</p>
<p>The inequality constraints are dealt with by first introducing slack variables, and second using log barriers to ensure that we obtain an interior-point method. The penalty parameter is going to be \(\alpha\), and the following slack variables are </p><ol>
<li>
\(s_1\) - a slack variable corresponding to the lower bound </li>
<li>
\(s_2\) - a slack variable corresponding to the upper bound. </li>
</ol>
<p>This now gives the following problem: </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}, s_1, s_2} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega = V \]
</p>
 <p class="formulaDsp">
\[ \varrho = s_1 \]
</p>
 <p class="formulaDsp">
\[ 1-\varrho = s_2 \]
</p>
<p>With these variables in place, we can then follow the usual approach to solving constrained optimization problems: We introduce a Lagrangian in which we combine the objective function and the constraints by multiplying the constraints by Lagrange multipliers. Specifically, we will use the following symbols for the Lagrange multipliers for the various constraints: </p><ol>
<li>
\(\mathbf{y}_1 \): a Lagrange multiplier corresponding to the elasticity constraint,  </li>
<li>
\(y_2\): a Lagrange multiplier corresponding to the convolution filter constraint,  </li>
<li>
\(z_1\): a Lagrange multiplier corresponding to the lower slack variable, and  </li>
<li>
\(z_2\): a Lagrange multiplier corresponding to the upper slack variable.  </li>
</ol>
<p>With these variables, the Lagrangian function reads as follows:</p>
<p class="formulaDsp">
\begin{align} \mathcal{L} =&amp; \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega - \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega- \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{y}_1):\boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_1 \right)\right) d\Omega - \int_{\partial \Omega} \mathbf{y}_1 \cdot \mathbf{t} d\partial\Omega \\ &amp; -\int_\Omega y_2 (\rho - H(\varrho)) d\Omega - \int_\Omega z_1 (\varrho-s_1) d\Omega - \int_\Omega z_2 (1 - s_2 -\varrho) d\Omega \end{align}
</p>
<p>The solution of the optimization problem then needs to satisfy what are known as the <a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">Karush-Kuhn-Tucker (KKT) conditions</a>: The derivatives of the Lagrangian with respect to all of its arguments need to be equal to zero, and because we have inequality constraints, we also have "complementarity" conditions. Since we here have an infinite-dimensional problem, these conditions all involve directional derivatives of the Lagrangian with regard to certain test functions &ndash; in other words, all of these conditions have to be stated in weak form as is typically the basis for finite element methods anyway.</p>
<p>The barrier method allows us to initially weaken the "complementary slackness" as required by the typical KKT conditions. Typically, we would require that \(s_i z_i = 0\), but the barrier formulations give KKT conditions where \(s_i z_i = \alpha\), where \(\alpha\) is our barrier parameter. As part of the barrier method, this parameter must be driven close to 0 to give a good approximation of the original problem.</p>
<p>In the following, let us state all of these conditions where \(d_{\{\bullet\}}\) is a test function that is naturally paired with variational derivatives of the Lagrangian with respect to the \(\{\bullet\}\) function. For simplicity, we introduce \(\Gamma\) to indicate the portion of the boundary where forces are applied, and Neumann boundary conditions are used.</p>
<ol>
<li>
Stationarity: <p class="formulaDsp">
\[ \int_\Omega - d_\rho y_2 + p\rho^{p-1}d_\rho \left[\lambda (\nabla \cdot \mathbf{y}_1) (\nabla \cdot \mathbf{u}) + \mu \boldsymbol{\varepsilon}(\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall d_\rho \]
</p>
 <p class="formulaDsp">
\[ \int_\Gamma \mathbf d_\mathbf{u} \cdot \mathbf{t} d\partial\Omega+ \int_\Omega p\rho^{p} \left[\lambda (\nabla \cdot \mathbf d_\mathbf{u})( \nabla \cdot \mathbf{y}_1) + \mu \boldsymbol{\varepsilon}(\mathbf d_\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall \mathbf{d}_\mathbf{u} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega= 0\;\;\forall d_\varrho \]
</p>
  </li>
<li>
Primal Feasibility: <p class="formulaDsp">
\[ \int_\Omega \rho^{p}\lambda (\nabla \cdot \mathbf d_{\mathbf{y}_1}) (\nabla \cdot \mathbf{u}) + \rho^{p}\mu \boldsymbol{\varepsilon}(\mathbf d_{\mathbf{y}_1}) : \boldsymbol{\varepsilon}(\mathbf{u}) d\Omega - \int_\Gamma \mathbf d_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega =0 \;\;\forall \mathbf{d}_{\mathbf{y}_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_1}(\varrho - s_1) d\Omega = 0\;\;\forall d_{z_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_z}(1-\varrho-s_2) d\Omega = 0\;\;\forall d_{z_2} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{y_2}(\rho - H(\varrho)) d\Omega = 0\;\;\forall d_{y_2} \]
</p>
  </li>
<li>
Complementary Slackness: <p class="formulaDsp">
\[ \int_\Omega d_{s_1}(s_1z_1 - \alpha) d\Omega = 0 \;\;\forall d_{s_1} ,\;\;\; \alpha \to 0 \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{s_2}(s_2z_2 - \alpha) d\Omega = 0 \;\;\forall d_{s_2} ,\;\;\; \alpha \to 0 \]
</p>
  </li>
<li>
Dual Feasibility: <p class="formulaDsp">
\[ s_{1,i},s_{2,i},z_{1,i},z_{2,i} \geq 0 \;\;\;\; \forall i \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Solutionprocedure"></a></p><h3>Solution procedure</h3>
<p>The optimality conditions above are, in addition to being convoluted, of a kind that is not easy to solve: They are generally nonlinear, and some of the relationships are also inequalities. We will address the nonlinearity using a Newton method to compute search directions, and come back to how to deal with the inequalities below when talking about step length procedures.</p>
<p>Newton's method applied to the equations above results in the system of equations listed below. Therein, variational derivatives with respect to the \(\{\bullet\}\) variable are taken in the \(c_{\{\bullet\}}\) direction.</p>
<ol>
<li>
<p class="startli">Stationarity: These equations ensure we are at a critical point of the objective function when constrained.</p>
<p>Equation 1 </p><p class="formulaDsp">
\begin{align} &amp;\int_\Omega-d_\rho c_{y_2} + p(p-1) \rho^{p-2} d_\rho c_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] + p \rho^{p-1} d_\rho[\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] + p \rho^{p-1} d_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \\ &amp;= -\int_\Omega -d_\rho z_1 + d_\rho z_2 - d_\rho y_2 + p\rho^{p-1}d_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 2 </p><p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y})] + \rho^{p} [\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Gamma \mathbf{d}_\mathbf{u} \cdot \mathbf{t} -\int_\Omega \rho^{p} [\lambda \nabla \cdot \mathbf{y} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(d_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 3 </p><p class="formulaDsp">
\[ \int_\Omega - d_\varrho c_{z_1} +d_\varrho c_{z_2} + H(d_\varrho)c_{y_2} d\Omega = -\int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Primal Feasibility: These equations ensure the equality constraints are met.</p>
<p>Equation 4 </p><p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_p[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] + \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Omega \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon} (\mathbf{d}_{\mathbf{y}_1})] + \int_\Gamma \mathbf{d}_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega \end{align}
</p>
<p>Equation 5 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_1}(c_\varrho - c_{s_1}) d\Omega=\int_\Omega d_{z_1} (\varrho - s_1) d\Omega \]
</p>
<p>Equation 6 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_2}(-c_\varrho-c_{s_2}) d\Omega= \int_\Omega d_{z_2} (1-\varrho-s_2) d\Omega \]
</p>
<p>Equation 7 </p><p class="formulaDsp">
\[ -\int_\Omega d_{y_2}(c_\rho - H(c_\varrho)) d\Omega=\int_\Omega d_{y_2} (\rho - H(\varrho)) d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Complementary Slackness: These equations essentially ensure the barrier is met - in the final solution, we need \(s^T z = 0\).</p>
<p>Equation 8 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_1}(c_{s_1}z_1/s_1 + c_{z_1} ) d\Omega=-\int_\Omega d_{s_1} (z_1 - \alpha/s_1) d\Omega ,\;\;\; \alpha \to 0 \]
</p>
<p>Equation 9 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_2} (c_{s_2}z_2/s_2 + c_{z_2} ) d\Omega=-\int_\Omega d_{s_2} (z_2 - \alpha/s_2) d\Omega,\;\;\; \alpha \to 0 \]
</p>
 <p class="endli"></p>
</li>
<li>
Dual Feasibility: The Lagrange multiplier on slacks and slack variables must be kept greater than 0. (This is the only part not implemented in the <code>SANDTopOpt::assemble_system()</code> function.) <p class="formulaDsp">
\[ s,z \geq 0 \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p>We use a quadrilateral mesh with \(Q_1\) elements to discretize the displacement and displacement Lagrange multiplier. Piecewise constant \(DGQ_0\) elements are used to discretize the density, unfiltered density, density slack variables, and multipliers for the slack variables and filter constraint.</p>
<p><a class="anchor" id="NonlinearAlgorithm"></a></p><h3>Nonlinear Algorithm</h3>
<p>While most of the discussion above follows traditional and well-known approaches to solving nonlinear optimization problems, it turns out that the problem is actually quite difficult to solve in practice. In particular, it is quite nonlinear and an important question is not just to find search directions \(c_{\{\bullet\}}\) as discussed above based on a Newton method, but that one needs to spend quite a lot of attention to how far one wants to go in this direction. This is often called "line search" and comes down to the question of how to choose the step length \(\alpha_k \in (0,1]\) so that we move from the current iterate \(\mathbf{x}_k\) to the next iterate \(\mathbf{x}_{k+1}=\mathbf{x}_k+\alpha_k \mathbf{x}_k\) in as efficient a way as possible. It is well understood that we need to eventually choose \(\alpha_k=1\) to realize the Newton's method's quadratic convergence; however, in the early iterations, taking such a long step might actually make things worse, either by leading to a point that has a worse objective function or at which the constraints are satisfied less well than they are at \(\mathbf{x}_k\).</p>
<p>Very complex algorithms have been proposed to deal with this issue <b>[Nocedal2009]</b> <b>[Waechter2005]</b>. Here, we implement a watchdog-search algorithm <b>[Nocedal2006]</b>. When discussing this algorithm, we will use the vector \(\mathbf{x}\) to represent all primal variables - the filtered and unfiltered densities, slack variables and displacement - and use the vector \(\mathbf{y}\) to represent all of the dual vectors. The (incremental) solution to the nonlinear system of equations stated above will now be referred to as \(\Delta \mathbf{x}\) and \(\Delta \mathbf{y}\) instead of \(c_{\{\bullet\}}\). A merit function (explained in more detail later) is referred to here as \(\phi(\mathbf{x,\mathbf{y}})\).</p>
<p>The watchdog algorithm applied to a subproblem with a given barrier parameter works in the following way: First, the current iteration is saved as a "watchdog" state, and the merit of the watchdog state is recorded. A maximal feasible Newton step is then taken. If the merit sufficiently decreased from the first step, this new step is accepted. If not, another maximal feasible Newton step is taken, and the merit is again compared to the watchdog merit. If after some number (typically between 5 and 8) of Newton steps, the merit did not adequately decrease, the algorithm takes a scaled Newton step from either the watchdog state or the last iteration that guarantees a sufficient decrease of the merit, and that step is accepted. Once a step is accepted, the norm of the KKT error is measured, and if it is sufficiently small, the barrier value is decreased. If it is not sufficiently small, the last accepted step is taken to be the new watchdog step, and the process is repeated.</p>
<p>Above, the "maximal feasible step" is a scaling of the Newton step in both the primal and dual variables given by</p>
<p class="formulaDsp">
\[ \beta^\mathbf{y} = \min\{1,\max \beta \text{ such that }\left(\mathbf{z}_{k+i} + \beta^\mathbf{z}_{k+i} \Delta \mathbf{z}_{k+i}\right)_j \geq \zeta \mathbf{z}_{k+i,j} \forall j\} \]
</p>
 <p class="formulaDsp">
\[ \beta^\mathbf{x} = \min\{1,\max \beta \text{ such that }\left(\mathbf{s}_{k+i} + \beta^\mathbf{s}_{k+i} \Delta \mathbf{s}_{k+i}\right)_j \geq \zeta \mathbf{s}_{k+i,j} \forall j\} \]
</p>
<p>Above, \(\zeta\) is the "fraction to boundary" that is allowed on any step. Because the derivatives become ill-conditioned near the boundary, this technique stands in for a <a href="https://en.wikipedia.org/wiki/Trust_region">trust region</a> and is necessary to ensure good approximations in the future. \(\zeta\) is taken to be \(\max\{0.8, 1-\alpha\}\), which allows movement closer to the boundary as the barrier becomes smaller. In the future, when implementing the LOQO algorithm for barrier reduction, this must be kept to 0.8 as the barrier parameter can vary wildly.</p>
<p>Separately, we need to deal with the log-barrier that we have used to enforce the positivity constraint on the slack variables \(s_1,s_2\): In the statement of the final optimization problem we solve, we have added the term </p><p class="formulaDsp">
\[ -\alpha \int_\Omega (\log(s_1) + \log(s_2)) d\Omega. \]
</p>
<p> The question is how we should choose the penalty factor \(\alpha\). As with all penalty methods, we are in reality only interested in the limit as \(\alpha\to 0\), since this is then the problem we really wanted to solve, subject to the positivity constraints on the slack variables. On the other hand, we need to choose \(\alpha\) large enough to make the problem solvable in practice. Actual implementations therefore start with a larger value of \(\alpha\) and gradually decrease it as the outer iterations proceed.</p>
<p>In the monotone method implemented here, the barrier parameter is updated whenever some level of convergence is achieved at the current barrier parameter. We use the \(l_\infty\) norm of the KKT conditions to check for convergence at each barrier size. The requirement is that \(\|KKT\|_{l_\infty} &lt; c \cdot \alpha\) where \(c\) is a constant over any barrier size and \(\alpha\) is the barrier parameter. This forces better convergence in later iterations, and is the same requirement as is used in <a href="https://coin-or.github.io/Ipopt/">IPOPT</a> (an open source software package for large-scale nonlinear optimization).</p>
<p>Here, the barrier is reduced linearly at larger values, and superlinearly at smaller values. At larger values, it is multiplied by a constant (around 0.6), and at lower values the barrier value is replaced by the barrier value raised to some exponent (around 1.2). This method has proven to be effective at keeping the subproblem solvable at large barrier values, while still allowing superlinear convergence at smaller barrier values. In practice, this looks like the following: </p><p class="formulaDsp">
\[ \alpha_{k+1} = \min\{\alpha_k^{1.2},0.6\alpha_k\} \]
</p>
<p>While taking large steps at reducing the barrier size when convergence is reached is widely used, more recent research has shown that it is typically faster to use algorithms that adaptively update barrier each iteration, i.e., methods in which we use concrete criteria at the end of each iteration to determine what the penalty parameter should be in the next iteration, rather than using reduction factors that are independent of the current solution. That said, such methods are also more complicated and we will not do this here.</p>
<p><a class="anchor" id="MeritFunction"></a></p><h3>Merit Function</h3>
<p>The algorithm outlined above makes use of a "merit function". Merit functions are used to determine whether a step from \(x_k\) to a proposed point \(x_{k+1}\) is beneficial. In unconstrained optimization problems, one can simply check this with the objective function we try to minimize, and typically uses conditions such as the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe and Goldstein conditions</a>.</p>
<p>In constrained optimization problems, the question is how to balance reduction in the objective function against a possible increase in the violation of constraints: A proposed step might make the objective function smaller but be further away from the set of points that satisfy the constraints &ndash; or the other way around. This trade-off is typically resolved by using a merit function that combines the two criteria.</p>
<p>Here, we use an exact \(l_1\) merit function to test the steps: </p><p class="formulaDsp">
\begin{align} \phi(\mathbf{x},\mathbf{y}) =&amp; \int_{\partial \Omega} \mathbf{u}\cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega (\log(s_1) + \log(s_2)) + p \sum_i\left| \int_\Omega y_{2,i}(H(\varrho) - \rho) d\Omega \right| \\ &amp; + p \sum_i\left| \int_{\partial \Omega} \mathbf{y}_{1,i}\cdot \mathbf{t} d\partial\Omega - \int_\Omega \rho^p[\lambda \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_{1,i} + \mu \boldsymbol{\varepsilon}{\mathbf{u}}\boldsymbol{\varepsilon}{\mathbf{y}_{1,i}}] d\Omega \right| + p \sum_i\left| \int_\Omega z_{1,i}(s_1 - \varrho) d\Omega\right| + p \sum_i\left| \int_\Omega z_{2,i}(1-\varrho - s_2) d\Omega\right| \end{align}
</p>
<p>Here, \(p\) is a penalty parameter. This merit function being exact means that there exists some \(p_0\) so that for any \(p &gt; p_0\), the merit function has its minima at the same location as the original problem. This penalty parameter is updated (by recommendation of Nocedal and Wright <b>[Benson2002]</b>) as follows: </p><p class="formulaDsp">
\[ p &gt; \frac{\frac{1}{2} \mathbf{x}^T \cdot \mathbf{H} \cdot \mathbf{x} - \mathbf{x}^T \cdot \nabla f}{\|c_i\|_{l_\infty}} \quad , i \in \mathcal{E}, \]
</p>
<p> where \(\mathbf{H}\) is the Hessian of the objective function, \(\mathbf{x}\) is a vector of our decision (primal) variables, \(f\) is the objective function, and \(c_i\) is the error on a current equality constraint.</p>
<p>Our use of this method is partially due to already having most of the necessary parts calculated in finding the right hand side, but also the use of an exact merit function ensures that it is minimized in the same location as the overall problem. Recent research has shown that one can replace merit functions by what are called "filter methods", and one should consider using these instead as they prove to be more efficient.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Preliminaries"></a> </p><h3>Preliminaries</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div></div><!-- fragment --><p>Above are fairly common files to include. These also include the one for the sparse direct class <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>. This is not the most efficient way to solve large linear problems, but it will do for now.</p>
<p>As usual, we put everything into a common namespace. We then start by declaring a number of symbolic names for constants that will be used throughout this tutorial. Specifically, we have a <em>lot</em> of variables in this program (of course the density and the displacement, but also the unfiltered density and quite a number of Lagrange multipliers). It is easy to forget which of these variables is at which position in the solution vector, and trying to use numbers for these vector components is a prescription for bugs. Rather, we define static variables that can be used in all of these places and that have to be initialized only once. In practice, this will lead to some lengthy expressions, but they are more readable and less likely to be wrong.</p>
<p>A similar issue arises with the ordering of blocks in the system matrix and in vectors. The matrices have \(9\times 9\) blocks, and it's difficult to remember which is which. It is far easier to just use symbolic names for those as well.</p>
<p>Finally, while we're at it, we introduce symbolic names also for the boundary indicators we will use, in the same spirit as was done in <a class="el" href="step_19.html">step-19</a>.</p>
<p>In all of these cases, we declare these variables as members in a namespace. In the case of the solution components, the concrete values of these variables depend on the space dimension, so we use <a href="https://en.cppreference.com/w/cpp/language/variable_template">template variables</a> to make the value of the variable depend on a template argument in the same way as we often use template functions.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>This namespace keeps track of the first component in our finite element system that corresponds to each variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionComponents</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">} <span class="comment">// namespace SolutionComponents</span></div></div><!-- fragment --><p>This is the namespace which keeps track of which block corresponds to which variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionBlocks</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">} <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>BoundaryIds</div><div class="line">{</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">} <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ValueExtractors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">    displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">    SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">    SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">    SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">    SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">} <span class="comment">// namespace ValueExtractors</span></div></div><!-- fragment --><p><a class="anchor" id="TheSANDTopOptmainclass"></a> </p><h3>The SANDTopOpt main class</h3>
<p>Next up is the main class for this problem. The majority of functions follow the usual naming schemes of tutorial programs, though there are a couple that have been broken out of what is usually called the <code>setup_system()</code> function because of their length, and there are also a number that deal with various aspects of the optimization algorithm.</p>
<p>As an added bonus, the program writes the computed design as an STL file that one can, for example, send to a 3d printer.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SANDTopOpt</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SANDTopOpt();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Most of the member variables are also standard. There are, however, a number of variables that are specifically related to the optimization algorithm (such the various scalar factors below) as well as the filter matrix to ensure that the design remains smooth.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">  <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">  <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h3>Constructor and set-up functions</h3>
<p>We initialize a <a class="el" href="classFESystem.html">FESystem</a> composed of 2 \(\times\)dim <code><a class="el" href="classFE__Q.html">FE_Q(1)</a></code> elements for the displacement variable and its Lagrange multiplier, and 7 <code><a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a></code> elements. These piecewise constant functions are for density-related variables: the density itself, the unfiltered density, the slack variables for the lower and upper bounds on the unfiltered density, and then Lagrange multipliers for the connection between filtered and unfiltered densities as well as for the inequality constraints.</p>
<p>The order in which these elements appear is documented above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       5)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , density_ratio(.5)</div><div class="line">  , density_penalty_exponent(3)</div><div class="line">  , filter_r(.251)</div><div class="line">  , penalty_multiplier(1)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p>The first step then is to create the triangulation that matches the problem description in the introduction &ndash; a 6-by-1 rectangle (or a 6-by-1-by-1 box in 3d) where a force will be applied in the top center. This triangulation is then uniformly refined a number of times.</p>
<p>In contrast to nearly the entire rest of this program, this function specifically assumes that we are in 2d and will require changes if we wanted to move to 3d simulations. We ensure that nobody tries to accidentally run in 3d without such modifications through an assertion at the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            {6, 1},</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">  triangulation.refine_global(3);</div></div><!-- fragment --><p>The second step is to apply boundary indicators to parts of the boundary. The following code assigns boundary indicators to the bottom, top, left, and right boundaries of the box, respectively. The center region of the top boundary is given a separate boundary indicator: This is where we will apply the down force.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the constraints due to boundary values. The bottom corners of the domain are kept in place in the \(y\) direction &ndash; the bottom left also in the \(x\) direction. deal.II generally thinks of boundary values as attached to pieces of the boundary, i.e., faces, rather than individual vertices. Indeed, mathematically speaking, one can not assign boundary values to individual points for the infinite-dimensional partial differential equation. But, since we are trying to reproduce a widely used benchmark, we will do so anyway and keep in mind that we have a finite-dimensional problem for which imposing boundary conditions at a single node is valid.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">{</div><div class="line">  boundary_values.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div></div><!-- fragment --><p>Check whether the current face is on the bottom boundary, and if it is whether one of its vertices might be the bottom left or bottom right vertex:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[x_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line"></div><div class="line">                      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                               <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Settingupblockmatricesandvectors"></a> </p><h3>Setting up block matrices and vectors</h3>
<p>The next function makes a giant 9-by-9 block matrix, and also sets up the necessary block vectors. The sparsity pattern for this matrix includes the sparsity pattern for the filter matrix. It also initializes any block vectors we will use.</p>
<p>Setting up the blocks by themselves is not overly complicated and follows what is already done in programs such as <a class="el" href="step_22.html">step-22</a>, for example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">  block_component[0] = 0;</div><div class="line">  block_component[1] = 1;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">    n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">      dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">  dsp.collect_sizes();</div></div><!-- fragment --><p>The bulk of the function is in setting up which of these blocks will actually contain anything, i.e., which variables couple with which other variables. This is cumbersome but necessary to ensure that we don't just allocate a very large number of entries for our matrix that will then end up being zero.</p>
<p>The concrete pattern you see below is something one probably has to draw once on a piece of paper, but follows in an otherwise relatively straightforward way from looking through the many terms of the bilinear form we will have to assemble in each nonlinear iteration.</p>
<p>The use of the symbolic names defined in namespace <code>SolutionComponents</code> helps understand what each of the following terms corresponds to, but it also makes the expressions lengthy and unwieldy: A term such as <code>coupling[SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;][SolutionComponents::density&lt;dim&gt;]</code> just doesn't read very well, and would either have to be split over several lines or run off the right edge of nearly every screen. As a consequence, we open a curly-brace enclosed code block in which we temporarily make the names in namespace <code>SolutionComponents</code> available without the namespace qualifier, by saying <code>using namespace SolutionComponents</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for displacement </span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">        {</div><div class="line">          coupling[displacement&lt;dim&gt; + i]</div><div class="line">                  [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                  [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for slack variables </span></div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">}</div></div><!-- fragment --><p>Before we can create the sparsity pattern, we also have to set up constraints. Since this program does not adaptively refine the mesh, the only constraint we have is one that couples all density variables to enforce the volume constraint. This will ultimately lead to a dense sub-block of the matrix, but there is little we can do about that.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">  fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line"><a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">  density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">constraints.clear();</div><div class="line">constraints.add_line(last_density_dof);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">  constraints.add_entry(last_density_dof,</div><div class="line">                        density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                        -1);</div><div class="line">constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">constraints.close();</div></div><!-- fragment --><p>We can now finally create the sparsity pattern for the matrix, taking into account which variables couple with which other variables, and the constraints we have on the density.</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div></div><!-- fragment --><p>The only part of the matrix we have not dealt with is the filter matrix and its transpose. These are non-local (integral) operators for which deal.II does not currently have functions. What we will ultimately need to do is go over all cells and couple the unfiltered density on this cell to all filtered densities of neighboring cells that are less than a threshold distance away, and the other way around; for the moment, we are only concerned with building the sparsity pattern that would correspond to this kind of matrix, so we perform the equivalent loop and where later on we would write into an entry of the matrix, we now simply add an entry to the sparsity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Having so generated the "dynamic" sparsity pattern, we can finally copy it to the structure that is used to associate matrices with a sparsity pattern. Because the sparsity pattern is large and complex, we also output it into a file of its own for visualization purposes &ndash; in other words, for "visual debugging".</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>What is left is to correctly size the various vectors and their blocks, as well as setting initial guesses for some of the components of the (nonlinear) solution vector. We here use the symbolic component names for individual blocks of the solution vector and, for brevity, use the same trick with <code>using namespace</code> as above:</p>
<div class="fragment"><div class="line">  nonlinear_solution.reinit(block_sizes);</div><div class="line">  system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">    nonlinear_solution.block(density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">      .add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">    nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">    nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefiltermatrix"></a> </p><h3>Creating the filter matrix</h3>
<p>Next up, a function that is used once at the beginning of the program: It creates a matrix \(H\) so that the filtered density vector equals \(H\) times the unfiltered density. The creation of this matrix is non-trivial, and it is used in every iteration, and so rather than reforming it as we do with the Newton matrix, it is made only once and stored separately.</p>
<p>The way this matrix is computed follows the outline used above already to form its sparsity pattern. We repeat this process here for the sparsity pattern of this separately formed matrix, and then actually build the matrix itself. You may want to check the definition of this matrix in the introduction to this program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">{</div></div><!-- fragment --><p>The sparsity pattern of the filter has already been determined and implemented in the setup_system() function. We copy the structure from the appropriate block and use it again here.</p>
<div class="fragment"><div class="line">filter_sparsity_pattern.copy_from(</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">filter_matrix.reinit(filter_sparsity_pattern);</div></div><!-- fragment --><p>Having so built the sparsity pattern, now we re-do all of these loops to actually compute the necessary values of the matrix entries:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            filter_matrix.add(i,</div><div class="line">                              check_cell-&gt;active_cell_index(),</div><div class="line">                              filter_r - distance);</div><div class="line">            </div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The final step is to normalize the matrix so that for each row, the sum of entries equals one.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> denominator = 0;</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        denominator = denominator + iter-&gt;value();</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function is used for building the filter matrix. We create a set of all the cell iterators within a certain radius of the cell that is input. These are the neighboring cells that will be relevant for the filter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">  neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">  cells_to_check.insert(cell);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">           std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">             cells_to_check.begin(), cells_to_check.end()))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                    cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                  <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                      !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                    {</div><div class="line">                      cells_to_check.insert(neighbor);</div><div class="line">                      neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                      new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">  <span class="keywordflow">return</span> cells_to_check;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingtheNewtonmatrix"></a> </p><h3>Assembling the Newton matrix</h3>
<p>Whereas the setup_filter_matrix function built a matrix that is the same as long as the mesh does not change (which we don't do anyway in this program), the next function builds the matrix to be solved in each iteration. This is where the magic happens. The components of the system of linear equations describing Newton's method for finding the solution of the KKT conditions are implemented here.</p>
<p>The top of the function is as in most of these functions and just sets up all sorts of variables necessary for the actual assembly, including a whole bunch of extractors. The entire set up should look familiar, though somewhat lengthier, if you've previously looked at <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div></div><!-- fragment --><p>At this point, we apply the filter to the unfiltered density, and apply the adjoint (transpose) operation to the unfiltered density multiplier, both to the current best guess for the nonlinear solution. We use this later to tell us how far off our filtered density is from the filter applied to the unfiltered density. That is because while at the solution of the nonlinear problem, we have \(\rho=H\varrho\), but at intermediate iterations, we in general have \(\rho^k\neq H\varrho^k\) and the "residual" \(\rho^k-H\varrho^k\) will then appear as the right hand side of one of the Newton update equations that we compute below.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"></div><div class="line">filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                      SolutionBlocks::unfiltered_density),</div><div class="line">                    nonlinear_solution.block(</div><div class="line">                      SolutionBlocks::unfiltered_density));</div><div class="line">filter_matrix.Tvmult(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">  nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">  n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">  n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>ValueExtractors;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">    mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div></div><!-- fragment --><p>As part of the construction of our system matrix, we need to retrieve values from our current guess at the solution. The following lines of code retrieve the needed values.</p>
<div class="fragment"><div class="line">fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                              old_density_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_divs);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">  nonlinear_solution, old_displacement_symmgrads);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">  .get_function_symmetric_gradients(</div><div class="line">    nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_values);</div><div class="line">fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_values);</div><div class="line">fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filtered_unfiltered_density_solution,</div><div class="line">  filtered_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We need several more values corresponding to the test functions coming from the first derivatives taken from the Lagrangian, that is the \(d_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">      fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">      fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      displacement_multiplier_phi_i_symmgrad =</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">          i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                          q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">      fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                           q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div></div><!-- fragment --><p>Finally, we need values that come from the second round of derivatives taken from the Lagrangian, the \(c_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">  fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                   q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">  fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  displacement_multiplier_phi_j_symmgrad =</div><div class="line">    fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">      .symmetric_gradient(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">  fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">  fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">  fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">  fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">  fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div></div><!-- fragment --><p>This is where the actual work starts. In the following, we will build all of the terms of the matrix &ndash; they are numerous and not entirely self-explanatory, also depending on the previous solutions and its derivatives (which we have already evaluated above and put into the variables called <code>old_*</code>). To understand what each of these terms corresponds to, you will want to look at the explicit form of these terms in the introduction above.</p>
<p>The right hand sides of the equations being driven to 0 give all the KKT conditions for finding a local minimum &ndash; the descriptions of what each individual equation are given with the computations of the right hand side.</p>
<div class="fragment"><div class="line">          <span class="comment">// Equation 1 </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  (density_penalty_exponent - 1) *</div><div class="line">                  std::pow(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 2) *</div><div class="line">                  density_phi_i * density_phi_j *</div><div class="line">                  (old_displacement_multiplier_divs[q_point] *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_multiplier_phi_j_div *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     old_displacement_multiplier_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                      displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">// Equation 2 </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (density_penalty_exponent *</div><div class="line">               <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent - 1) *</div><div class="line">               density_phi_j *</div><div class="line">               (old_displacement_multiplier_divs[q_point] *</div><div class="line">                  displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                2 * mu_values[q_point] *</div><div class="line">                  (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                   displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">             + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent) *</div><div class="line">                 (displacement_multiplier_phi_j_div *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                     displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">            );</div><div class="line"></div><div class="line">          <span class="comment">// Equation 3, which has to do with the filter and which is calculated elsewhere. </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (-1 * unfiltered_density_phi_i *</div><div class="line">               lower_slack_multiplier_phi_j +</div><div class="line">             unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">          <span class="comment">// Equation 4: Primal feasibility </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              density_penalty_exponent *</div><div class="line">                <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent - 1) *</div><div class="line">                density_phi_j *</div><div class="line">                (old_displacement_divs[q_point] *</div><div class="line">                   displacement_multiplier_phi_i_div *</div><div class="line">                   lambda_values[q_point] +</div><div class="line">                 2 * mu_values[q_point] *</div><div class="line">                   (old_displacement_symmgrads[q_point] *</div><div class="line">                    displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">              + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent) *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     displacement_multiplier_phi_i_div *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (displacement_phi_j_symmgrad *</div><div class="line">                      displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">// Equation 5: Primal feasibility </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            lower_slack_multiplier_phi_i *</div><div class="line">            (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 6: Primal feasibility </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            upper_slack_multiplier_phi_i *</div><div class="line">            (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 7: Primal feasibility - the part with the filter is added later </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               unfiltered_density_multiplier_phi_i *</div><div class="line">                               (density_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 8: Complementary slackness </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">             + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                 old_lower_slack_multiplier_values[q_point] /</div><div class="line">                 old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 9: Complementary slackness </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">             + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                 old_upper_slack_multiplier_values[q_point] /</div><div class="line">                 old_upper_slack_values[q_point]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have everything assembled, all we have to do is deal with the effect of (Dirichlet) boundary conditions and other constraints. We incorporate the former locally with just the contributions from the current cell, and then let the AffineConstraint class deal with the latter while copying contributions from the current cell into the global linear system:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                           local_dof_indices,</div><div class="line">                                           cell_matrix,</div><div class="line">                                           dummy_cell_rhs,</div><div class="line">                                           <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Having accumulated all of the terms that belong into the Newton matrix, we now also have to compute the terms for the right hand side (i.e., the negative residual). We already do this in another function, and so we call that here:</p>
<div class="fragment"><div class="line">system_rhs = calculate_test_rhs(nonlinear_solution);</div></div><!-- fragment --><p>Here we use the filter matrix we have already constructed. We only need to integrate this filter applied to test functions, which are piecewise constant, and so the integration becomes a simple multiplication by the measure of the cell. Iterating over the pre-made filter matrix allows us to use the information about which cells are in or out of the filter without repeatedly checking neighbor cells again.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">             filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           ++iter)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                   SolutionBlocks::unfiltered_density)</div><div class="line">            .add(i, j, value);</div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density,</div><div class="line">                   SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">            .add(j, i, value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvingtheNewtonlinearsystem"></a> </p><h3>Solving the Newton linear system</h3>
<p>We will need to solve a linear system in each iteration. We use a direct solver, for now &ndash; this is clearly not an efficient choice for a matrix that has so many non-zeroes, and it will not scale to anything interesting. For "real" applications, we will need an iterative solver but the complexity of the system means that an iterative solver algorithm will take a good deal of work. Because this is not the focus of the current program, we simply stick with the direct solver we have here &ndash; the function follows the same structure as used in <a class="el" href="step_29.html">step-29</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">  linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> linear_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Detailsoftheoptimizationalgorithm"></a> </p><h3>Details of the optimization algorithm</h3>
<p>The next several functions deal with specific parts of the optimization algorithm, most notably with deciding whether the direction computed by solving the linearized (Newton) system is viable and, if so, how far we want to go in this direction.</p>
<p><a class="anchor" id="Computingsteplengths"></a> </p><h4>Computing step lengths</h4>
<p>We start with a function that does a binary search to figure out the maximum step that meets the dual feasibility &ndash; that is, how far can we go so that \(s&gt;0\) and \(z&gt;0\). The function returns a pair of values, one each for the \(s\) and \(z\) slack variables.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">        fraction_to_boundary = 1 - barrier_size;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">    {</div><div class="line">      step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">      step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">        (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">        (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">           .is_non_negative());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">           .is_non_negative());</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_s)</div><div class="line">        step_size_s_low = step_size_s;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_z)</div><div class="line">        step_size_z_low = step_size_z;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_z_high = step_size_z;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingresiduals"></a> </p><h4>Computing residuals</h4>
<p>The next function computes a right hand side vector linearized around a "test solution vector" that we can use to look at the magnitude of the KKT conditions. This is then used for testing the convergence before shrinking the barrier size, as well as in the calculation of the \(l_1\) merit.</p>
<p>The function is lengthy and complicated, but it is really just a copy of the right hand side part of what the <code>assemble_system()</code> function above did.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>We first create a zero vector with size and blocking of system_rhs</p>
<div class="fragment"><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">  test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">    test_solution;</div><div class="line">  filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density) = 0;</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">  filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density),</div><div class="line">                      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density));</div><div class="line">  filter_matrix.Tvmult(</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">    test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">    n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">      mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">      fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                    old_density_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_divs);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">        test_solution, old_displacement_symmgrads);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_multiplier_values);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_multiplier_divs);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">        .get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_values);</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_multiplier_values);</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_values);</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filtered_unfiltered_density_solution,</div><div class="line">        filtered_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                displacement_multiplier_phi_i_symmgrad =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                    i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                    q_point);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                     q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 1: This equation, along with equations 2 and 3, are the variational derivatives of the Lagrangian with respect to the decision variables - the density, displacement, and unfiltered density. </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (density_penalty_exponent *</div><div class="line">                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent - 1) *</div><div class="line">                   density_phi_i *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      old_displacement_divs[q_point] *</div><div class="line">                      lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_symmgrads[q_point] *</div><div class="line">                       old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                 density_phi_i *</div><div class="line">                   old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 2; the boundary terms will be added further down below. </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                          density_penalty_exponent) *</div><div class="line">                 (old_displacement_multiplier_divs[q_point] *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                     displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 3 </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (unfiltered_density_phi_i *</div><div class="line">                   filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                     [q_point] +</div><div class="line">                 unfiltered_density_phi_i *</div><div class="line">                   old_upper_slack_multiplier_values[q_point] +</div><div class="line">                 -1 * unfiltered_density_phi_i *</div><div class="line">                   old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">              <span class="comment">// Equation 4; boundary term will again be dealt with below. This equation being driven to 0 ensures that the elasticity equation is met as a constraint. </span></div><div class="line">              cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                       density_penalty_exponent) *</div><div class="line">                              (old_displacement_divs[q_point] *</div><div class="line">                                 displacement_multiplier_phi_i_div *</div><div class="line">                                 lambda_values[q_point] +</div><div class="line">                               2 * mu_values[q_point] *</div><div class="line">                                 (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                  old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 5: This equation sets the lower slack variable equal to the unfiltered density, giving a minimum density of 0. </span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (lower_slack_multiplier_phi_i *</div><div class="line">                              (old_unfiltered_density_values[q_point] -</div><div class="line">                               old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 6: This equation sets the upper slack variable equal to one minus the unfiltered density. </span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (upper_slack_multiplier_phi_i *</div><div class="line">                              (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                               old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 7: This is the difference between the density and the filter applied to the unfiltered density. This being driven to 0 by the Newton steps ensures that the filter is applied correctly. </span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (unfiltered_density_multiplier_phi_i *</div><div class="line">                              (old_density_values[q_point] -</div><div class="line">                               filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 8: This along with equation 9 give the requirement that s*z = \alpha for the barrier size alpha, and gives complementary slackness from KKT conditions when \alpha goes to 0. </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (lower_slack_phi_i *</div><div class="line">                 (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 9 </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (upper_slack_phi_i *</div><div class="line">                 (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_upper_slack_values[q_point]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                   fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        -1 *</div><div class="line">                        (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                      i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (traction *</div><div class="line">                         fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                           i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               dummy_cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             test_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> test_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingthemeritfunction"></a> </p><h4>Computing the merit function</h4>
<p>The algorithm we use herein uses a "watchdog" strategy to determine where and how far to go from the current iterate. We base the watchdog strategy on an exact \(l_1\) merit function. This function calculates the exact \(l_1\) merit of a given, putative, next iterate.</p>
<p>The merit function consists of the sum of the objective function (which is simply an integral of external forces (on the boundary of the domain) times the displacement values of a test solution (typically, the current solution plus some multiple of the Newton update), and the \(l_1\) norms of the Lagrange multiplier components of residual vectors. The following code computes these parts in turn:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div></div><!-- fragment --><p>Start with computing the objective function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">              fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                     displacement_face_values);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                   face_q_point &lt; n_face_q_points;</div><div class="line">                   ++face_q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                  traction[1] = -1.;</div><div class="line"></div><div class="line">                  objective_function_merit +=</div><div class="line">                    (traction * displacement_face_values[face_q_point]) *</div><div class="line">                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">  }</div></div><!-- fragment --><p>Then compute the residual and take the \(l_1\) norms of the components that correspond to Lagrange mulipliers. We add those to the objective function computed above, and return the sum at the bottom:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">    objective_function_merit + elasticity_constraint_merit +</div><div class="line">    filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">  <span class="keywordflow">return</span> total_merit;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Findingasearchdirection"></a> </p><h4>Finding a search direction</h4>
<p>Next up is the function that actually computes a search direction starting at the current state (passed as the first argument) and returns the resulting vector. To this end, the function first calls the functions that assemble the linear system that corresponds to the Newton system, and that solve it.</p>
<p>This function also updates the penalty multiplier in the merit function, and then returns the largest scaled feasible step. It uses the <code>calculate_max_step_sizes()</code> function to find the largest feasible step that satisfies \(s&gt;0\) and \(z&gt;0\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">{</div><div class="line">  assemble_system();</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div></div><!-- fragment --><p>Next we are going to update penalty_multiplier. In essence, a larger penalty multiplier makes us consider the constraints more. Looking at the Hessian and gradient with respect to the step we want to take with our decision variables, and comparing that to the norm of our constraint error gives us a way to ensure that our merit function is "exact" - that is, it has a minimum in the same location that the objective function does. As our merit function is exact for any penalty multiplier over some minimum value, we only keep the computed value if it increases the penalty multiplier.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">  SolutionBlocks::density,</div><div class="line">  SolutionBlocks::displacement,</div><div class="line">  SolutionBlocks::unfiltered_density,</div><div class="line">  SolutionBlocks::density_upper_slack,</div><div class="line">  SolutionBlocks::density_lower_slack};</div><div class="line"><span class="keywordtype">double</span> hess_part = 0;</div><div class="line"><span class="keywordtype">double</span> grad_part = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">      {</div><div class="line">        Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">        system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">          .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">        hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">      }</div><div class="line">    grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                 step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">  SolutionBlocks::displacement_multiplier,</div><div class="line">  SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">  SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">  SolutionBlocks::density_upper_slack_multiplier};</div><div class="line"><span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">  constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line"><span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">  test_penalty_multiplier =</div><div class="line">    (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div></div><!-- fragment --><p>Based on all of this, we can now compute step sizes for the primal and dual (Lagrange multiplier) variables. Once we have these, we scale the components of the solution vector, and that is what this function returns.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">    calculate_max_step_size(nonlinear_solution, step);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingascaledstep"></a> </p><h4>Computing a scaled step</h4>
<p>The next function then implements a back-tracking algorithm for a line search. It keeps shrinking step size until it finds a step where the merit is decreased, and then returns the new location based on the current state vector, and the direction to go into, times the step length.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">    (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">     calculate_exact_merit(state)) /</div><div class="line">    1e-4;</div><div class="line">  <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">          calculate_exact_merit(state) +</div><div class="line">            step_size * descent_requirement * merit_derivative)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size = step_size / 2;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Checkingforconvergence"></a> </p><h4>Checking for convergence</h4>
<p>The final auxiliary function in this block is the one that checks to see if the KKT conditions are sufficiently met so that the overall algorithm can lower the barrier size. It does so by computing the \(l_1\) norm of the residual, which is what <code>calculate_test_rhs()</code> computes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">            &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessingthesolution"></a> </p><h3>Postprocessing the solution</h3>
<p>The first of the postprocessing functions outputs information in a VTU file for visualization. It looks long, but it's really just the same as what was done in <a class="el" href="step_22.html">step-22</a>, for example, just with (a lot) more solution variables:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p>The second of these functions outputs the solution as an <code>.stl</code> file for 3d printing. <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files are made up of triangles and normal vectors, and we will use it to show all of those cells with a density value larger than zero by first extruding the mesh from a \(z\) value of zero to \(z=0.25\), and then generating two triangles for each face of the cells with a sufficiently large density value. The triangle nodes must go counter-clockwise when looking from the outside, and the normal vectors must be unit vectors pointing outwards, which requires a few checks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">{</div><div class="line">  static_assert(dim == 2,</div><div class="line">                <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">  std::ofstream stlfile;</div><div class="line">  stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">  <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">            SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">        {</div></div><!-- fragment --><p>We have now found a cell with a density value larger than zero. Let us start by writing out the bottom and top faces. Owing to the ordering issue mentioned above, we have to make sure that we understand whether a cell has a right- or left-handed coordinate system. We do this by interrogating the directions of the two edges starting at vertex 0 and whether they form a right-handed coordinate system.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                             cell-&gt;vertex(0),</div><div class="line">                                           cell-&gt;vertex(2) -</div><div class="line">                                             cell-&gt;vertex(0)};</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">  {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">   {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">  {</div><div class="line">    <span class="comment">// Write one side at z = 0. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Write one side at z = height. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="comment">// The cell has a left-handed set up </span></div><div class="line">  {</div><div class="line">    <span class="comment">// Write one side at z = 0. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Write one side at z = height. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --><p>Next we need to deal with the four faces of the cell, extended into the \(z\) direction. However, we only need to write these faces if either the face is on the domain boundary, or if it is the interface between a cell with density greater than 0.5, and a cell with a density less than 0.5.</p>
<div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">               face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">               ++face_number)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                cell-&gt;face(face_number);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                  (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                   (nonlinear_solution.block(</div><div class="line">                      0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                    0.5)))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                    (face-&gt;center() - cell-&gt;center());</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                  <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          0.000000e+00 +</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                          normal_vector[0] +</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[0] -</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                      0)</div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctiondrivingtheoverallalgorithm"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function driving the overall algorithm</h3>
<p>This function finally provides the overall driver logic. It is, in the grand scheme of things, a rather complicated function primarily because the optimization algorithm is difficult: It isn't just about finding a Newton direction like in <a class="el" href="step_15.html">step-15</a> and then going a fixed distance in this direction any more, but instead about (i) determining what the optimal log-barrier penalty parameter should be in the current step, (ii) a complicated algorithm to determine how far we want to go, and other ingredients. Let us see how we can break this down into smaller chunks in the following documentation.</p>
<p>The function starts out simple enough with first setting up the mesh, the <a class="el" href="classDoFHandler.html">DoFHandler</a>, and then the various linear algebra objects necessary for the following:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    setup_boundary_values();</div><div class="line">    setup_block_system();</div><div class="line">    setup_filter_matrix();</div><div class="line">  }</div></div><!-- fragment --><p>We then set a number of parameters that affect the log-barrier and line search components of the optimization algorithm:</p>
<div class="fragment"><div class="line">barrier_size                  = 25;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div></div><!-- fragment --><p>Now start the principal iteration. The overall algorithm works by using an outer loop in which we loop until either (i) the log-barrier parameter has become small enough, or (ii) we have reached convergence. In any case, we terminate if end up with too large a number of iterations. This overall structure is encoded as a <code>do { ... } while (...)</code> loop where the convergence condition is at the bottom.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div></div><!-- fragment --><p>Within this outer loop, we have an inner loop in which we try to find an update direction using the watchdog algorithm described in the introduction.</p>
<p>The general idea of the watchdog algorithm itself is this: For a maximum of <code>max_uphill_steps</code> (i.e., a loop within the "inner loop" mentioned above) attempts, we use <code>find_max_step()</code> to compute a Newton update step, and add these up in the <code>nonlinear_solution</code> vector. In each of these attempts (starting from the place reached at the end of the previous attempt), we check whether we have reached a target value of the merit function described above. The target value is computed based on where this algorithm starts (the <code>nonlinear_solution</code> at the beginning of the watchdog loop, saves as <code>watchdog_state</code>) and the first proposed direction provided by <code>find_max_step()</code> in the first go-around of this loop (the <code>k==0</code> case).</p>
<div class="fragment"><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">              &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">              &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">    <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">    <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">      {</div><div class="line">        ++iteration_number;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (k == 0)</div><div class="line">          {</div><div class="line">            first_step = update_step;</div><div class="line">            merit_derivative =</div><div class="line">              ((calculate_exact_merit(watchdog_state +</div><div class="line">                                      .0001 * first_step) -</div><div class="line">                calculate_exact_merit(watchdog_state)) /</div><div class="line">               .0001);</div><div class="line">            target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                           descent_requirement * merit_derivative;</div><div class="line">          }</div><div class="line"></div><div class="line">        nonlinear_solution += update_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">          calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                  &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                  &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">          {</div><div class="line">            watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>The next part of the algorithm then depends on whether the watchdog loop above succeeded. If it did, then we are satisfied and no further action is necessary: We just stay where we are. If, however, we took the maximal number of unsuccessful steps in the loop above, then we need to do something else, and this is what the following code block does.</p>
<p>Specifically, from the final (unsuccessful) state of the loop above, we seek one more update direction and take what is called a "stretch
 step". If that stretch state satisfies a condition involving the merit function, then we go there. On the other hand, if the stretch state is also unacceptable (as all of the watchdog steps above were), then we discard all of the watchdog steps taken above and start over again where we had started the watchdog iterations &ndash; that place was stored in the <code>watchdog_state</code> variable above. More specifically, the conditions below first test whether we take a step from <code>watchdog_state</code> in direction <code>first_step</code>, or whether we can do one more update from the stretch state to find a new place. It is possible that neither of these is actually better than the state we started from at the beginning of the watchdog algorithm, but even if that is so, that place clearly was a difficult place to be in, and getting away to start the next iteration from another place might be a useful strategy to eventually converge.</p>
<p>We keep repeating the watchdog steps above along with the logic below until this inner iteration is finally converged (or if we run up against the maximal number of iterations &ndash; where we count the number of linear solves as iterations and increment the counter every time we call <code>find_max_step()</code> since that is where the linear solve actually happens). In any case, at the end of each of these inner iterations we also output the solution in a form suitable for visualization.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    ++iteration_number;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">      compute_scaled_step(nonlinear_solution,</div><div class="line">                          update_step,</div><div class="line">                          descent_requirement);</div></div><!-- fragment --><p>If we did not get a successful watchdog step, we now need to decide between going back to where we started, or using the final state. We compare the merits of both of these locations, and then take a scaled step from whichever location is better. As the scaled step is guaranteed to lower the merit, we will end up keeping one of the two.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">             calculate_exact_merit(watchdog_state)) ||</div><div class="line">            (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            nonlinear_solution = stretch_state;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            std::cout</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                calculate_exact_merit(watchdog_state))</div><div class="line">              {</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(watchdog_state,</div><div class="line">                                      first_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                nonlinear_solution = stretch_state;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                  find_max_step();</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      stretch_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    output_results(iteration_number);</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">       (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div></div><!-- fragment --><p>At the end of the outer loop, we have to update the barrier parameter, for which we use the following formula. The rest of the function is then simply about checking the outer loop convergence condition, and if we decide to terminate computations, about writing the final "design" as an STL file for use in 3d printing, and to output some timing information.</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The remainder of the code, the <code>main()</code> function, is as usual:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="TestProblem"></a></p><h3>Test Problem</h3>
<p>The algorithms used above are tested against a traditional topology optimization problem called the Messerschmitt-Bolkow-Blohm Beam (MBB Beam).</p>
<p>This problem considers the optimal 2-d structure that can be built on a rectangle 6 units wide, and 1 unit tall. The bottom corners are fixed in place in the \(y\) direction using a zero Dirichlet boundary condition, and a downward force is applied in the center of the top of the beam by enforcing a Neumann boundary condition. The rest of the boundary is allowed to move, and has no external force applied, which takes the form of a zero Neumann boundary condition. In essence, we are asking the following question: How should we design a bridge in a way so that if the bottom left and bottom right point of the bridge are on rollers that allow these points to move horizontally but not vertically, and so that the displacement in response to the vertical force in the center is minimal.</p>
<p>While the total volume of the domain is 6 units, 3 units of material are allowed for the structure. Because of the symmetry of the problem, it could be posed on a rectangle of width 3 and height 1 by cutting the original domain in half, and using zero Dirichlet boundary conditions in the \(x\) direction along the cut edge. That said, symmetry of the solution is a good indicator that the program is working as expected, so we solved the problem on the whole domain, as shown below. <b>[Bendse2004]</b></p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.mbbgeometry.png" alt="The MBB problem domain and boundary conditions"/>
</div>
 </div><p>Using the program discussed above, we find the minimum volume of the MBB Beam and the individual components of the solution look as follows:</p>
<div class="onecolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.filtereddensity.png" alt="Filtered Density Solution"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.unfiltereddensity.png" alt="Unfiltered Density Solution"/>
</div>
 </div> </div><p>These pictures show that what we find here is in accordance with what one typically sees in other publications on the topic <b>[Bendse2004]</b>. Maybe more interestingly, the result looks like a truss bridge (except that we apply the load at the top of the trusses, rather than the bottom as in real truss bridges, akin to a "deck
truss" bridge), suggesting that the designs that have been used in bridge- building for centuries are indeed based on ideas we can now show to be optimal in some sense.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h4>Possibilities for extensions</h4>
<p>The results shown above took around 75 iterations to find, which is quite concerning given the expense in solving the large linear systems in each iteration. Looking at the evolution, it does look as though the convergence has moments of happening quickly and moments of happening slowly. We believe this to be due to both a lack of precision on when and how to decrease the boundary values, as well as our choice of merit function being sub-optimal. In the future, a LOQO barrier update replacing the monotone reduction, as well as a Markov Filter in place of a merit function will decrease the number of necessary iterations significantly.</p>
<p>The barrier decrease is most sensitive in the middle of the convergence, which is problematic, as it seems like we need it to decrease quickly, then slowly, then quickly again.</p>
<p>Secondly, the linear solver used here is just the sparse direct solver based on the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class. This works reasonably well on small problems, but the formulation of the optimization problem detailed above has quite a large number of variables and so the linear problem is not only large but also has a lot of nonzero entries in many rows, even on meshes that overall are still relatively coarse. As a consequence, the solver time dominates the computations, and more sophisticated approaches at solving the linear system are necessary.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Justin O&#39;Connor, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionComponents</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">  } <span class="comment">// namespace SolutionComponents</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionBlocks</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">  } <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>BoundaryIds</div><div class="line">  {</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">  } <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>ValueExtractors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">      displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">      SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">      SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">      SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">      SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">  } <span class="comment">// namespace ValueExtractors</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SANDTopOpt</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SANDTopOpt();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">    std::pair&lt;double, double&gt;</div><div class="line">    calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">    calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">    find_relevant_neighbors(</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">    <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">    <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         5)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , density_ratio(.5)</div><div class="line">    , density_penalty_exponent(3)</div><div class="line">    , filter_r(.251)</div><div class="line">    , penalty_multiplier(1)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              {6, 1},</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">    triangulation.refine_global(3);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">  {</div><div class="line">    boundary_values.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[x_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line"></div><div class="line">                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                                 <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">    block_component[0] = 0;</div><div class="line">    block_component[1] = 1;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">        dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">            {</div><div class="line">              coupling[displacement&lt;dim&gt; + i]</div><div class="line">                      [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">              coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                      [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for slack variables */</span></div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">      fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">    <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">      density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">    constraints.clear();</div><div class="line">    constraints.add_line(last_density_dof);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">      constraints.add_entry(last_density_dof,</div><div class="line">                            density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                            -1);</div><div class="line">    constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                         SolutionBlocks::unfiltered_density)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    nonlinear_solution.reinit(block_sizes);</div><div class="line">    system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">      nonlinear_solution.block(density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">        .add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">      nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">  {</div><div class="line"></div><div class="line">    filter_sparsity_pattern.copy_from(</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                             SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">    filter_matrix.reinit(filter_sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                filter_matrix.add(i,</div><div class="line">                                  check_cell-&gt;active_cell_index(),</div><div class="line">                                  filter_r - distance);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> denominator = 0;</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          denominator = denominator + iter-&gt;value();</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">    neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">    cells_to_check.insert(cell);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">             std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">               cells_to_check.begin(), cells_to_check.end()))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                      cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                    <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                        !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                      {</div><div class="line">                        cells_to_check.insert(neighbor);</div><div class="line">                        neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                        new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">    <span class="keywordflow">return</span> cells_to_check;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">      nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      nonlinear_solution;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        nonlinear_solution.block(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          nonlinear_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                                       q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                      displacement_multiplier_phi_j_symmgrad =</div><div class="line">                        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">                          .symmetric_gradient(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">                      fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">                      fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">                      fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">                      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">                      fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">                      fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 1 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            (density_penalty_exponent - 1) *</div><div class="line">                            std::pow(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 2) *</div><div class="line">                            density_phi_i * density_phi_j *</div><div class="line">                            (old_displacement_multiplier_divs[q_point] *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_multiplier_phi_j_div *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               old_displacement_multiplier_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                                displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 2 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (density_penalty_exponent *</div><div class="line">                         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent - 1) *</div><div class="line">                         density_phi_j *</div><div class="line">                         (old_displacement_multiplier_divs[q_point] *</div><div class="line">                            displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                          2 * mu_values[q_point] *</div><div class="line">                            (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                       + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent) *</div><div class="line">                           (displacement_multiplier_phi_j_div *</div><div class="line">                              displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                            2 * mu_values[q_point] *</div><div class="line">                              (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                               displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      );</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">                     * calculated elsewhere. */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (-1 * unfiltered_density_phi_i *</div><div class="line">                         lower_slack_multiplier_phi_j +</div><div class="line">                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        density_penalty_exponent *</div><div class="line">                          <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent - 1) *</div><div class="line">                          density_phi_j *</div><div class="line">                          (old_displacement_divs[q_point] *</div><div class="line">                             displacement_multiplier_phi_i_div *</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 * mu_values[q_point] *</div><div class="line">                             (old_displacement_symmgrads[q_point] *</div><div class="line">                              displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                        + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent) *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               displacement_multiplier_phi_i_div *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (displacement_phi_j_symmgrad *</div><div class="line">                                displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      lower_slack_multiplier_phi_i *</div><div class="line">                      (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      upper_slack_multiplier_phi_i *</div><div class="line">                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">                     * is added later */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                                         unfiltered_density_multiplier_phi_i *</div><div class="line">                                         (density_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                       + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                           old_lower_slack_multiplier_values[q_point] /</div><div class="line">                           old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                       + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                           old_upper_slack_multiplier_values[q_point] /</div><div class="line">                           old_upper_slack_values[q_point]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 cell_matrix,</div><div class="line">                                                 dummy_cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    system_rhs = calculate_test_rhs(nonlinear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">               filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             ++iter)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .add(i, j, value);</div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .add(j, i, value);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">    linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> linear_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">          fraction_to_boundary = 1 - barrier_size;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">      {</div><div class="line">        step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">        step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">          (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">          (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">             .is_non_negative());</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">             .is_non_negative());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_s)</div><div class="line">          step_size_s_low = step_size_s;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_z)</div><div class="line">          step_size_z_low = step_size_z;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_z_high = step_size_z;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">    test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      test_solution;</div><div class="line">    filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density) = 0;</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">                 * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">                 * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">                 * variables - the density, displacement, and</span></div><div class="line"><span class="comment">                 * unfiltered density. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (density_penalty_exponent *</div><div class="line">                     <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                              density_penalty_exponent - 1) *</div><div class="line">                     density_phi_i *</div><div class="line">                     (old_displacement_multiplier_divs[q_point] *</div><div class="line">                        old_displacement_divs[q_point] *</div><div class="line">                        lambda_values[q_point] +</div><div class="line">                      2 * mu_values[q_point] *</div><div class="line">                        (old_displacement_symmgrads[q_point] *</div><div class="line">                         old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                   density_phi_i *</div><div class="line">                     old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">                 * below. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent) *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                       displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 3 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (unfiltered_density_phi_i *</div><div class="line">                     filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                       [q_point] +</div><div class="line">                   unfiltered_density_phi_i *</div><div class="line">                     old_upper_slack_multiplier_values[q_point] +</div><div class="line">                   -1 * unfiltered_density_phi_i *</div><div class="line">                     old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">                 * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">                 * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">                 * a constraint. */</span></div><div class="line">                cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                         density_penalty_exponent) *</div><div class="line">                                (old_displacement_divs[q_point] *</div><div class="line">                                   displacement_multiplier_phi_i_div *</div><div class="line">                                   lambda_values[q_point] +</div><div class="line">                                 2 * mu_values[q_point] *</div><div class="line">                                   (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                    old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">                 * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">                 * giving a minimum density of 0. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (lower_slack_multiplier_phi_i *</div><div class="line">                                (old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">                 * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">                 * density. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (upper_slack_multiplier_phi_i *</div><div class="line">                                (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">                 * density and the filter applied to the</span></div><div class="line"><span class="comment">                 * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">                 * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">                 * applied correctly. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (unfiltered_density_multiplier_phi_i *</div><div class="line">                                (old_density_values[q_point] -</div><div class="line">                                 filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">                 * requirement that @f$s*z = \alpha@f$ for the barrier</span></div><div class="line"><span class="comment">                 * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">                 * from KKT conditions when @f$\alpha@f$ goes to 0. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (lower_slack_phi_i *</div><div class="line">                   (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 9 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (upper_slack_phi_i *</div><div class="line">                   (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_upper_slack_values[q_point]));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                     fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                      {</div><div class="line">                        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                        traction[1] = -1.;</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          -1 *</div><div class="line">                          (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                        i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          (traction *</div><div class="line">                           fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                             i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 dummy_cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               test_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> test_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">    {</div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                              fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                       fe,</div><div class="line">                                       face_quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                  face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">                {</div><div class="line">                  fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                  fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                    .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                         displacement_face_values);</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                       face_q_point &lt; n_face_q_points;</div><div class="line">                       ++face_q_point)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      objective_function_merit +=</div><div class="line">                        (traction * displacement_face_values[face_q_point]) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">      objective_function_merit + elasticity_constraint_merit +</div><div class="line">      filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">    <span class="keywordflow">return</span> total_merit;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">  {</div><div class="line">    assemble_system();</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">      SolutionBlocks::density,</div><div class="line">      SolutionBlocks::displacement,</div><div class="line">      SolutionBlocks::unfiltered_density,</div><div class="line">      SolutionBlocks::density_upper_slack,</div><div class="line">      SolutionBlocks::density_lower_slack};</div><div class="line">    <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">    <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">          {</div><div class="line">            Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">            system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">              .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">            hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">          }</div><div class="line">        grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                     step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">      SolutionBlocks::displacement_multiplier,</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">      SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">      SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">    <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">    <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">      test_penalty_multiplier =</div><div class="line">        (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">    penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">      calculate_max_step_size(nonlinear_solution, step);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> step;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">      (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">       calculate_exact_merit(state)) /</div><div class="line">      1e-4;</div><div class="line">    <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">            calculate_exact_merit(state) +</div><div class="line">              step_size * descent_requirement * merit_derivative)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size = step_size / 2;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">              &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">  {</div><div class="line">    static_assert(dim == 2,</div><div class="line">                  <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">    std::ofstream stlfile;</div><div class="line">    stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">    <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">              SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                                         cell-&gt;vertex(0),</div><div class="line">                                                       cell-&gt;vertex(2) -</div><div class="line">                                                         cell-&gt;vertex(0)};</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">              {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">               {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">                 face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                 ++face_number)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                  cell-&gt;face(face_number);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                    (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                     (nonlinear_solution.block(</div><div class="line">                        0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                      0.5)))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                      (face-&gt;center() - cell-&gt;center());</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                    <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            0.000000e+00 +</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                            normal_vector[0] +</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[0] -</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                        0)</div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">      setup_boundary_values();</div><div class="line">      setup_block_system();</div><div class="line">      setup_filter_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">    barrier_size                  = 25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                      &lt;&lt; iteration_number</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                      &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">            <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">            <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">            <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (k == 0)</div><div class="line">                  {</div><div class="line">                    first_step = update_step;</div><div class="line">                    merit_derivative =</div><div class="line">                      ((calculate_exact_merit(watchdog_state +</div><div class="line">                                              .0001 * first_step) -</div><div class="line">                        calculate_exact_merit(watchdog_state)) /</div><div class="line">                       .0001);</div><div class="line">                    target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                   descent_requirement * merit_derivative;</div><div class="line">                  }</div><div class="line"></div><div class="line">                nonlinear_solution += update_step;</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                  calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                          &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                          &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                  {</div><div class="line">                    watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      update_step,</div><div class="line">                                      descent_requirement);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">                     calculate_exact_merit(watchdog_state)) ||</div><div class="line">                    (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">                  {</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                    nonlinear_solution = stretch_state;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    std::cout</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                        calculate_exact_merit(watchdog_state))</div><div class="line">                      {</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(watchdog_state,</div><div class="line">                                              first_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        ++iteration_number;</div><div class="line">                        nonlinear_solution = stretch_state;</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                          find_max_step();</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(nonlinear_solution,</div><div class="line">                                              stretch_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            output_results(iteration_number);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">               (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_15.html">step-15</a> . <table
 class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic
 Material with Penalization</a><a
 href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic Material
 with Penalization</a>
 <li><a href="#ElasticityEquation">Elasticity Equation</a><a
 href="#ElasticityEquation">Elasticity Equation</a>
 <li><a href="#Makingthesolutionmeshindependent">Making the solution
 mesh-independent</a><a href="#Makingthesolutionmeshindependent">Making the
 solution mesh-independent</a>
 <li><a href="#CompleteProblemFormulation">Complete Problem
 Formulation</a><a href="#CompleteProblemFormulation">Complete Problem
 Formulation</a>
 <li><a href="#Solutionprocedure">Solution procedure</a><a
 href="#Solutionprocedure">Solution procedure</a>
 <li><a href="#Discretization">Discretization</a><a
 href="#Discretization">Discretization</a>
 <li><a href="#NonlinearAlgorithm">Nonlinear Algorithm</a><a
 href="#NonlinearAlgorithm">Nonlinear Algorithm</a>
 <li><a href="#MeritFunction">Merit Function</a><a
 href="#MeritFunction">Merit Function</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Preliminaries">Preliminaries</a><a
 href="#Preliminaries">Preliminaries</a>
 <li><a href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a><a
 href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a>
 <li><a href="#Constructorandsetupfunctions">Constructor and set-up
 functions</a><a href="#Constructorandsetupfunctions">Constructor and set-up
 functions</a>
 <li><a href="#Settingupblockmatricesandvectors">Setting up block matrices
 and vectors</a><a href="#Settingupblockmatricesandvectors">Setting up block
 matrices and vectors</a>
 <li><a href="#Creatingthefiltermatrix">Creating the filter matrix</a><a
 href="#Creatingthefiltermatrix">Creating the filter matrix</a>
 <li><a href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a><a
 href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a>
 <li><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear
 system</a><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear
 system</a>
 <li><a href="#Detailsoftheoptimizationalgorithm">Details of the
 optimization algorithm</a><a
 href="#Detailsoftheoptimizationalgorithm">Details of the optimization
 algorithm</a>
 <ul>
 <li><a href="#Computingsteplengths">Computing step lengths</a><a
 href="#Computingsteplengths">Computing step lengths</a>
 <li><a href="#Computingresiduals">Computing residuals</a><a
 href="#Computingresiduals">Computing residuals</a>
 <li><a href="#Computingthemeritfunction">Computing the merit function</a><a
 href="#Computingthemeritfunction">Computing the merit function</a>
 <li><a href="#Findingasearchdirection">Finding a search direction</a><a
 href="#Findingasearchdirection">Finding a search direction</a>
 <li><a href="#Computingascaledstep">Computing a scaled step</a><a
 href="#Computingascaledstep">Computing a scaled step</a>
 <li><a href="#Checkingforconvergence">Checking for convergence</a><a
 href="#Checkingforconvergence">Checking for convergence</a>
 </ul>
 <li><a href="#Postprocessingthesolution">Postprocessing the solution</a><a
 href="#Postprocessingthesolution">Postprocessing the solution</a>
 <li><a href="#Therunfunctiondrivingtheoverallalgorithm">The run() function
 driving the overall algorithm</a><a
 href="#Therunfunctiondrivingtheoverallalgorithm">The run() function driving
 the overall algorithm</a>
 <li><a href="#Themainfunction">The main function</a><a
 href="#Themainfunction">The main function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#TestProblem">Test Problem</a><a href="#TestProblem">Test
 Problem</a>
 <ul>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>Topology Optimization of Elastic Media is a technique used to optimize astructure that is bearing some load. Ideally, we would like to minimize themaximum stress placed on a structure by selecting a region \(E\) where material isplaced. In other words, </p><p class="formulaDsp">
\[ \text{minimize}\| \boldsymbol{\sigma} (\mathbf{u}) \|_\infty \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } |E|\leq V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0}. \]
</p>
<p> Here, \(\boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon}(\mathbf{u})\) is the stresswithin the body that is caused by the external forces \(\mathbf F\) , where we have for simplicity assumedthat the material is linear-elastic and so \(\mathbf{C}\) is the stress-strain tensor and \(\boldsymbol{\varepsilon}(\mathbf{u})=\frac{1}{2} (\nabla \mathbf{u} + (\nabla\mathbf{u})^T)\) is thesmall-deformation strain as a function of the displacement \(\mathbf{u}\)</p>
<ul>
<li>see <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a> for more on linear elasticity. In the formulation above, \(V_\text{max}\) is the maximal amount of material we are willing to provide tobuild the object. The last of the constraints is the partial differentialequation that relates stress \(\boldsymbol{\sigma}\) and forces \(\mathbf F\) and is simply thesteady-state force balance. That said, the infinity norm above creates a problem: As a function of locationof material, this objective function is necessarily not differentiable, makingprospects of optimization rather bleak. So instead, a common approach intopology optimization is to find an approximate solution by optimizing a relatedproblem: We would like to minimize the strain energy. This is ameasure of the potential energy stored in an object due to its deformation, butalso works as a measure of total deformation over the structure. <p class="formulaDsp">
\[ \text{minimize } \int_E \frac{1}{2}\boldsymbol{\sigma} : \boldsymbol{\varepsilon} dV \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \|E\| \leq V_{\max} \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} \]
</p>
 The value of the objective function is calculated using a finite element method,where the solution is the displacements. This is placed inside of a nonlinearsolver loop that solves for a vector denoting placement of material. <a class="anchor" id="SolidIsotropicMaterialwithPenalization"></a><h3>Solid Isotropic Material with Penalization</h3>
</li>
</ul>
<p>In actual practice, we can only build objects in which the material is eitherpresent, or not present, at any given point</p>
<ul>
<li>i.e., we would have an indicatorfunction \(\rho_E(\mathbf{x})\in \{0,1\}\) that describes the material-filledregion and that we want to find through the optimization problem. In this case,the optimization problem becomes combinatorial, and very expensive to solve.Instead, we use an approach called Solid Isotropic Material with Penalization,or SIMP. <b>[Bendse2004]</b> The SIMP method is based on an idea of allowing the material to exist in alocation with a density \(\rho\) between 0 and 1. A density of 0 suggests thematerial is not there, and it is not a part of the structure, while a density of1 suggests the material is present. Values between 0 and 1 do not reflect adesign we can create in the real-world, but allow us to turn the combinatorialproblem into a continuous one. One then looks at density values \(\rho\) ,with the constraint that \(0 &lt; \rho_{\min} \leq \rho \leq 1\) . The minimum value \(\rho_{\min}\) , typically chosen to be around \(10^{-3}\) , avoids the possibilityof having an infinite strain energy, but is small enough to provide accurateresults. The straightforward application of the effect of this "density" on theelasticity of the media would be to simply multiply the stiffness tensor \(\mathbf{C}_0\) of the medium by the given density, that is, \(\mathbf{C} = \rho \mathbf{C}_0\) . However, thisapproach often gives optimal solutions where density values are far from both 0and 1. As one wants to find a real-world solution, meaning the material eitheris present or it is not, a penalty is applied to these in-between values. Asimple and effective way to do this is to multiply the stiffness tensor by thedensity raised to some integer power penalty parameter \(p\) , so that \(\mathbf{C} = \rho^p \mathbf{C}_0\) . This makes density values farther away from 0 or 1 lesseffective. It has been shown that using \(p=3\) is sufficiently high to create'black-and-white' solutions: that is, one gets optimal solutions in whichmaterial is either present or not present at all points. More material should always provide a structure with a lower strain energy, and so theinequality constraint can be viewed as an equality where the total volume usedis the maximum volume. Using this density idea also allows us to reframe the volume constraint on theoptimization problem. Use of SIMP then turns the optimization problem into thefollowing: <p class="formulaDsp">
\[ \text{minimize } \int_\Omega \frac{1}{2}\boldsymbol{\sigma}(\rho) : \boldsymbol{\varepsilon}(\rho) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \int_\Omega \rho(x) d\Omega= V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ 0&lt;\rho_{\min}\leq \rho(x) \leq 1, \]
</p>
 <p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma}(\rho) + \mathbf{F} = 0 \quad \text{on } \Omega \]
</p>
 final constraint, the balance of linear momentum (which we will refer to as the elasticity equation), gives a method for finding \(\boldsymbol{\sigma}\) and \(\boldsymbol{\varepsilon}\) given the density \(\rho\) . <a class="anchor" id="ElasticityEquation"></a><h3>Elasticity Equation</h3>
</li>
</ul>
<p>The elasticity equation in the time independent limit reads </p><p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} . \]
</p>
<p> the situations we will care about, we will assume that the medium has a linear material responseand in that case, we have that </p><p class="formulaDsp">
\[ \boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon} = \rho^p \mathbf{C}_0 : \boldsymbol{\varepsilon}(\mathbf{u}) = \rho^p \mathbf{C}_0 : \left[\frac{1}{2} (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) \right] . \]
</p>
<p> everything we will do below, we will always consider the displacementfield \(\mathbf{u}\) as the only solution variable, rather than considering \(\mathbf{u}\) and \(\boldsymbol{\sigma}\) as solution variables (as is done in mixedformulations). Furthermore, we will make the assumption that the material is linear isotropic,in which case the stress-strain tensor can be expressed in terms of the Lam&eacute;parameters \(\lambda,\mu\) such that </p><p class="formulaDsp">
\begin{align} \boldsymbol{\sigma} &amp;= \rho^p (\lambda \text{tr}(\boldsymbol{\varepsilon}) \mathbf{I} + 2 \mu \boldsymbol{\varepsilon}) , \\ \sigma_{i,j} &amp;= \rho^p (\lambda \varepsilon_{k,k} \delta_{i,j} + 2 \mu \varepsilon_{i,j}) . \end{align}
</p>
<p> See <a class="el" href="step_8.html">step-8</a> for how this transformation works. Integrating the objective function by parts gives </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u}))^T d\Omega+ \int_\Omega (\nabla \cdot \boldsymbol{\sigma}(\rho)) \cdot \mathbf{u} d\Omega= \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega , \]
</p>
<p> which the linear elasticity equation can then be substituted, giving </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_\Omega \mathbf{F}\cdot \mathbf{u} d\Omega+ \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega . \]
</p>
<p> we are assuming no body forces, this simplifies further to </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega, \]
</p>
<p> is the final form of the governing equation that we'll be consideringfrom this point forward. <a class="anchor" id="Makingthesolutionmeshindependent"></a></p><h3>Making the solution mesh-independent</h3>
<p>Typically, the solutions to topology optimization problems aremesh-dependent, and as such the problem is ill-posed. This is becausefractal structures are often formed as the mesh is refined further. As the mesh gainsresolution, the optimal solution typically gains smaller and smaller structures.There are a few competing workarounds to this issue, but the most popular forfirst order optimization is the sensitivity filter, while second orderoptimization methods tend to prefer use of a density filter. As the filters affect the gradient and Hessian of the strain energy (i.e., theobjective function), the choice of filter has an effect on the solution of theproblem. The density filter as part of a second order method works byintroducing an unfiltered density, which we refer to as \(\varrho\) , and thenrequiring that the density be a convolution of the unfiltered density: </p><p class="formulaDsp">
\[ \rho = H(\varrho). \]
</p>
<p>, \(H\) is an operator so that \(\rho(\mathbf{x})\) is some kind of average ofthe values of \(\varrho\) in the area around \(\mathbf{x}\)</p>
<ul>
<li>i.e., it is a smoothedversion of \(\varrho\) . This prevents checkerboarding; the radius of the filter allows the user todefine an effective minimal beam width for the optimal structures we seek tofind. <div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.checkerboard.png" alt="Checkerboarding occurring in an MBB Beam"/>
</div>
 </div></li>
</ul>
<p><a class="anchor" id="CompleteProblemFormulation"></a></p><h3>Complete Problem Formulation</h3>
<p>The minimization problem is now </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega= V \]
</p>
 <p class="formulaDsp">
\[ 0\leq \varrho \leq 1 \]
</p>
<p>The inequality constraints are dealt with by first introducing slack variables, and second using log barriers to ensure that we obtain an interior-point method. The penalty parameter is going to be \(\alpha\), and the following slack variables are </p><ol>
<li>
<p class="startli">\(s_1\)</p>
<ul>
<li>a slack variable corresponding to the lower bound </li>
</ul>
</li>
<li>
<p class="startli">\(s_2\)</p>
<ul>
<li>a slack variable corresponding to the upper bound. </li>
</ul>
</li>
</ol>
<p>This now gives the following problem: </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}, s_1, s_2} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega = V \]
</p>
 <p class="formulaDsp">
\[ \varrho = s_1 \]
</p>
 <p class="formulaDsp">
\[ 1-\varrho = s_2 \]
</p>
<p>With these variables in place, we can then follow the usual approach to solving constrained optimization problems: We introduce a Lagrangian in which we combine the objective function and the constraints by multiplying the constraints by Lagrange multipliers. Specifically, we will use the following symbols for the Lagrange multipliers for the various constraints: </p><ol>
<li>
\(\mathbf{y}_1 \): a Lagrange multiplier corresponding to the elasticity constraint,  </li>
<li>
\(y_2\): a Lagrange multiplier corresponding to the convolution filter constraint,  </li>
<li>
\(z_1\): a Lagrange multiplier corresponding to the lower slack variable, and  </li>
<li>
\(z_2\): a Lagrange multiplier corresponding to the upper slack variable.  </li>
</ol>
<p>With these variables, the Lagrangian function reads as follows:</p>
<p class="formulaDsp">
\begin{align} \mathcal{L} =&amp; \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega - \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega- \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{y}_1):\boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_1 \right)\right) d\Omega - \int_{\partial \Omega} \mathbf{y}_1 \cdot \mathbf{t} d\partial\Omega \\ &amp; -\int_\Omega y_2 (\rho - H(\varrho)) d\Omega - \int_\Omega z_1 (\varrho-s_1) d\Omega - \int_\Omega z_2 (1 - s_2 -\varrho) d\Omega \end{align}
</p>
<p>The solution of the optimization problem then needs to satisfy what are known as the <a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">Karush-Kuhn-Tucker (KKT) conditions</a>: The derivatives of the Lagrangian with respect to all of its arguments need to be equal to zero, and because we have inequality constraints, we also have "complementarity" conditions. Since we here have an infinite-dimensional problem, these conditions all involve directional derivatives of the Lagrangian with regard to certain test functions</p>
<p>&ndash; in other words, all of these conditions have to be stated in weak form as is typically the basis for finite element methods anyway.</p>
<p>The barrier method allows us to initially weaken the "complementary
 slackness" as required by the typical KKT conditions. Typically, we would require that \(s_i z_i = 0\), but the barrier formulations give KKT conditions where \(s_i z_i = \alpha\), where \(\alpha\) is our barrier parameter. As part of the barrier method, this parameter must be driven close to 0 to give a good approximation of the original problem.</p>
<p>In the following, let us state all of these conditions where \(d_{\{\bullet\}}\) is a test function that is naturally paired with variational derivatives of the Lagrangian with respect to the \(\{\bullet\}\) function. For simplicity, we introduce \(\Gamma\) to indicate the portion of the boundary where forces are applied, and Neumann boundary conditions are used.</p>
<ol>
<li>
Stationarity: <p class="formulaDsp">
\[ \int_\Omega - d_\rho y_2 + p\rho^{p-1}d_\rho \left[\lambda (\nabla \cdot \mathbf{y}_1) (\nabla \cdot \mathbf{u}) + \mu \boldsymbol{\varepsilon}(\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall d_\rho \]
</p>
 <p class="formulaDsp">
\[ \int_\Gamma \mathbf d_\mathbf{u} \cdot \mathbf{t} d\partial\Omega+ \int_\Omega p\rho^{p} \left[\lambda (\nabla \cdot \mathbf d_\mathbf{u})( \nabla \cdot \mathbf{y}_1) + \mu \boldsymbol{\varepsilon}(\mathbf d_\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall \mathbf{d}_\mathbf{u} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega= 0\;\;\forall d_\varrho \]
</p>
  </li>
<li>
Primal Feasibility: <p class="formulaDsp">
\[ \int_\Omega \rho^{p}\lambda (\nabla \cdot \mathbf d_{\mathbf{y}_1}) (\nabla \cdot \mathbf{u}) + \rho^{p}\mu \boldsymbol{\varepsilon}(\mathbf d_{\mathbf{y}_1}) : \boldsymbol{\varepsilon}(\mathbf{u}) d\Omega - \int_\Gamma \mathbf d_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega =0 \;\;\forall \mathbf{d}_{\mathbf{y}_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_1}(\varrho - s_1) d\Omega = 0\;\;\forall d_{z_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_z}(1-\varrho-s_2) d\Omega = 0\;\;\forall d_{z_2} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{y_2}(\rho - H(\varrho)) d\Omega = 0\;\;\forall d_{y_2} \]
</p>
  </li>
<li>
Complementary Slackness: <p class="formulaDsp">
\[ \int_\Omega d_{s_1}(s_1z_1 - \alpha) d\Omega = 0 \;\;\forall d_{s_1} ,\;\;\; \alpha \to 0 \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{s_2}(s_2z_2 - \alpha) d\Omega = 0 \;\;\forall d_{s_2} ,\;\;\; \alpha \to 0 \]
</p>
  </li>
<li>
Dual Feasibility: <p class="formulaDsp">
\[ s_{1,i},s_{2,i},z_{1,i},z_{2,i} \geq 0 \;\;\;\; \forall i \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Solutionprocedure"></a></p><h3>Solution procedure</h3>
<p>The optimality conditions above are, in addition to being convoluted, of a kind that is not easy to solve: They are generally nonlinear, and some of the relationships are also inequalities. We will address the nonlinearity using a Newton method to compute search directions, and come back to how to deal with the inequalities below when talking about step length procedures.</p>
<p>Newton's method applied to the equations above results in the system of equations listed below. Therein, variational derivatives with respect to the \(\{\bullet\}\) variable are taken in the \(c_{\{\bullet\}}\) direction.</p>
<ol>
<li>
<p class="startli">Stationarity: These equations ensure we are at a critical point of the objective function when constrained.</p>
<p>Equation 1</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega-d_\rho c_{y_2} + p(p-1) \rho^{p-2} d_\rho c_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] + p \rho^{p-1} d_\rho[\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] + p \rho^{p-1} d_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \\ &amp;= -\int_\Omega -d_\rho z_1 + d_\rho z_2 - d_\rho y_2 + p\rho^{p-1}d_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 2</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y})] + \rho^{p} [\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Gamma \mathbf{d}_\mathbf{u} \cdot \mathbf{t} -\int_\Omega \rho^{p} [\lambda \nabla \cdot \mathbf{y} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(d_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 3 </p><p class="formulaDsp">
\[ \int_\Omega - d_\varrho c_{z_1} +d_\varrho c_{z_2} + H(d_\varrho)c_{y_2} d\Omega = -\int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Primal Feasibility: These equations ensure the equality constraints are met.</p>
<p>Equation 4</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_p[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] + \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Omega \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon} (\mathbf{d}_{\mathbf{y}_1})] + \int_\Gamma \mathbf{d}_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega \end{align}
</p>
<p>Equation 5 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_1}(c_\varrho - c_{s_1}) d\Omega=\int_\Omega d_{z_1} (\varrho - s_1) d\Omega \]
</p>
<p>Equation 6 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_2}(-c_\varrho-c_{s_2}) d\Omega= \int_\Omega d_{z_2} (1-\varrho-s_2) d\Omega \]
</p>
<p>Equation 7 </p><p class="formulaDsp">
\[ -\int_\Omega d_{y_2}(c_\rho - H(c_\varrho)) d\Omega=\int_\Omega d_{y_2} (\rho - H(\varrho)) d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Complementary Slackness: These equations essentially ensure the barrier is met</p>
<ul>
<li>in the final solution, we need \(s^T z = 0\).</li>
</ul>
<p>Equation 8 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_1}(c_{s_1}z_1/s_1 + c_{z_1} ) d\Omega=-\int_\Omega d_{s_1} (z_1 - \alpha/s_1) d\Omega ,\;\;\; \alpha \to 0 \]
</p>
<p>Equation 9 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_2} (c_{s_2}z_2/s_2 + c_{z_2} ) d\Omega=-\int_\Omega d_{s_2} (z_2 - \alpha/s_2) d\Omega,\;\;\; \alpha \to 0 \]
</p>
 <p class="endli"></p>
</li>
<li>
Dual Feasibility: The Lagrange multiplier on slacks and slack variables must be kept greater than 0. (This is the only part not implemented in the <code>SANDTopOpt::assemble_system()</code> function.) <p class="formulaDsp">
\[ s,z \geq 0 \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p>We use a quadrilateral mesh with \(Q_1\) elements to discretize the displacement and displacement Lagrange multiplier. Piecewise constant \(DGQ_0\) elements are used to discretize the density, unfiltered density, density slack variables, and multipliers for the slack variables and filter constraint.</p>
<p><a class="anchor" id="NonlinearAlgorithm"></a></p><h3>Nonlinear Algorithm</h3>
<p>While most of the discussion above follows traditional and well-known approaches to solving nonlinear optimization problems, it turns out that the problem is actually quite difficult to solve in practice. In particular, it is quite nonlinear and an important question is not just to find search directions \(c_{\{\bullet\}}\) as discussed above based on a Newton method, but that one needs to spend quite a lot of attention to how far one wants to go in this direction. This is often called "line search" and comes down to the question of how to choose the step length \(\alpha_k \in (0,1]\) so that we move from the current iterate \(\mathbf{x}_k\) to the next iterate \(\mathbf{x}_{k+1}=\mathbf{x}_k+\alpha_k \mathbf{x}_k\) in as efficient a way as possible. It is well understood that we need to eventually choose \(\alpha_k=1\) to realize the Newton's method's quadratic convergence; however, in the early iterations, taking such a long step might actually make things worse, either by leading to a point that has a worse objective function or at which the constraints are satisfied less well than they are at \(\mathbf{x}_k\).</p>
<p>Very complex algorithms have been proposed to deal with this issue <b>[Nocedal2009]</b> <b>[Waechter2005]</b>. Here, we implement a watchdog-search algorithm <b>[Nocedal2006]</b>. When discussing this algorithm, we will use the vector \(\mathbf{x}\) to represent all primal variables</p>
<ul>
<li>the filtered and unfiltered densities, slack variables and displacement</li>
<li>and use the vector \(\mathbf{y}\) to represent all of the dual vectors. The (incremental) solution to the nonlinear system of equations stated above will now be referred to as \(\Delta \mathbf{x}\) and \(\Delta \mathbf{y}\) instead of \(c_{\{\bullet\}}\). A merit function (explained in more detail later) is referred to here as \(\phi(\mathbf{x,\mathbf{y}})\).</li>
</ul>
<p>The watchdog algorithm applied to a subproblem with a given barrier parameter works in the following way: First, the current iteration is saved as a "watchdog" state, and the merit of the watchdog state is recorded. A maximal feasible Newton step is then taken. If the merit sufficiently decreased from the first step, this new step is accepted. If not, another maximal feasible Newton step is taken, and the merit is again compared to the watchdog merit. If after some number (typically between 5 and 8) of Newton steps, the merit did not adequately decrease, the algorithm takes a scaled Newton step from either the watchdog state or the last iteration that guarantees a sufficient decrease of the merit, and that step is accepted. Once a step is accepted, the norm of the KKT error is measured, and if it is sufficiently small, the barrier value is decreased. If it is not sufficiently small, the last accepted step is taken to be the new watchdog step, and the process is repeated.</p>
<p>Above, the "maximal feasible step" is a scaling of the Newton step in both the primal and dual variables given by</p>
<p class="formulaDsp">
\[ \beta^\mathbf{y} = \min\{1,\max \beta \text{ such that }\left(\mathbf{z}_{k+i} + \beta^\mathbf{z}_{k+i} \Delta \mathbf{z}_{k+i}\right)_j \geq \zeta \mathbf{z}_{k+i,j} \forall j\} \]
</p>
 <p class="formulaDsp">
\[ \beta^\mathbf{x} = \min\{1,\max \beta \text{ such that }\left(\mathbf{s}_{k+i} + \beta^\mathbf{s}_{k+i} \Delta \mathbf{s}_{k+i}\right)_j \geq \zeta \mathbf{s}_{k+i,j} \forall j\} \]
</p>
<p>Above, \(\zeta\) is the "fraction to boundary" that is allowed on any step. Because the derivatives become ill-conditioned near the boundary, this technique stands in for a <a href="https://en.wikipedia.org/wiki/Trust_region">trust region</a> and is necessary to ensure good approximations in the future. \(\zeta\) is taken to be \(\max\{0.8, 1-\alpha\}\), which allows movement closer to the boundary as the barrier becomes smaller. In the future, when implementing the LOQO algorithm for barrier reduction, this must be kept to 0.8 as the barrier parameter can vary wildly.</p>
<p>Separately, we need to deal with the log-barrier that we have used to enforce the positivity constraint on the slack variables \(s_1,s_2\): In the statement of the final optimization problem we solve, we have added the term </p><p class="formulaDsp">
\[ -\alpha \int_\Omega (\log(s_1) + \log(s_2)) d\Omega. \]
</p>
<p> The question is how we should choose the penalty factor \(\alpha\). As with all penalty methods, we are in reality only interested in the limit as \(\alpha\to 0\), since this is then the problem we really wanted to solve, subject to the positivity constraints on the slack variables. On the other hand, we need to choose \(\alpha\) large enough to make the problem solvable in practice. Actual implementations therefore start with a larger value of \(\alpha\) and gradually decrease it as the outer iterations proceed.</p>
<p>In the monotone method implemented here, the barrier parameter is updated whenever some level of convergence is achieved at the current barrier parameter. We use the \(l_\infty\) norm of the KKT conditions to check for convergence at each barrier size. The requirement is that \(\|KKT\|_{l_\infty} &lt; c \cdot \alpha\) where \(c\) is a constant over any barrier size and \(\alpha\) is the barrier parameter. This forces better convergence in later iterations, and is the same requirement as is used in <a href="https://coin-or.github.io/Ipopt/">IPOPT</a> (an open source software package for large-scale nonlinear optimization).</p>
<p>Here, the barrier is reduced linearly at larger values, and superlinearly at smaller values. At larger values, it is multiplied by a constant (around 0.6), and at lower values the barrier value is replaced by the barrier value raised to some exponent (around 1.2). This method has proven to be effective at keeping the subproblem solvable at large barrier values, while still allowing superlinear convergence at smaller barrier values. In practice, this looks like the following: </p><p class="formulaDsp">
\[ \alpha_{k+1} = \min\{\alpha_k^{1.2},0.6\alpha_k\} \]
</p>
<p>While taking large steps at reducing the barrier size when convergence is reached is widely used, more recent research has shown that it is typically faster to use algorithms that adaptively update barrier each iteration, i.e., methods in which we use concrete criteria at the end of each iteration to determine what the penalty parameter should be in the next iteration, rather than using reduction factors that are independent of the current solution. That said, such methods are also more complicated and we will not do this here.</p>
<p><a class="anchor" id="MeritFunction"></a></p><h3>Merit Function</h3>
<p>The algorithm outlined above makes use of a "merit function". Merit functions are used to determine whether a step from \(x_k\) to a proposed point \(x_{k+1}\) is beneficial. In unconstrained optimization problems, one can simply check this with the objective function we try to minimize, and typically uses conditions such as the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe and Goldstein conditions</a>.</p>
<p>In constrained optimization problems, the question is how to balance reduction in the objective function against a possible increase in the violation of constraints: A proposed step might make the objective function smaller but be further away from the set of points that satisfy the constraints</p>
<p>&ndash; or the other way around. This trade-off is typically resolved by using a merit function that combines the two criteria.</p>
<p>Here, we use an exact \(l_1\) merit function to test the steps:</p>
<p class="formulaDsp">
\begin{align} \phi(\mathbf{x},\mathbf{y}) =&amp; \int_{\partial \Omega} \mathbf{u}\cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega (\log(s_1) + \log(s_2)) + p \sum_i\left| \int_\Omega y_{2,i}(H(\varrho) - \rho) d\Omega \right| \\ &amp; + p \sum_i\left| \int_{\partial \Omega} \mathbf{y}_{1,i}\cdot \mathbf{t} d\partial\Omega - \int_\Omega \rho^p[\lambda \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_{1,i} + \mu \boldsymbol{\varepsilon}{\mathbf{u}}\boldsymbol{\varepsilon}{\mathbf{y}_{1,i}}] d\Omega \right| + p \sum_i\left| \int_\Omega z_{1,i}(s_1 - \varrho) d\Omega\right| + p \sum_i\left| \int_\Omega z_{2,i}(1-\varrho - s_2) d\Omega\right| \end{align}
</p>
<p>Here, \(p\) is a penalty parameter. This merit function being exact means that there exists some \(p_0\) so that for any \(p &gt; p_0\), the merit function has its minima at the same location as the original problem. This penalty parameter is updated (by recommendation of Nocedal and Wright <b>[Benson2002]</b>) as follows: </p><p class="formulaDsp">
\[ p &gt; \frac{\frac{1}{2} \mathbf{x}^T \cdot \mathbf{H} \cdot \mathbf{x} - \mathbf{x}^T \cdot \nabla f}{\|c_i\|_{l_\infty}} \quad , i \in \mathcal{E}, \]
</p>
<p> where \(\mathbf{H}\) is the Hessian of the objective function, \(\mathbf{x}\) is a vector of our decision (primal) variables, \(f\) is the objective function, and \(c_i\) is the error on a current equality constraint.</p>
<p>Our use of this method is partially due to already having most of the necessary parts calculated in finding the right hand side, but also the use of an exact merit function ensures that it is minimized in the same location as the overall problem. Recent research has shown that one can replace merit functions by what are called "filter methods", and one should consider using these instead as they prove to be more efficient.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Preliminaries"></a> </p><h3>Preliminaries</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div></div><!-- fragment --><p>Above are fairly common files to include. These also include the one for the sparse direct class <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>. This is not the most efficient way to solve large linear problems, but it will do for now.</p>
<p>As usual, we put everything into a common namespace. We then start by declaring a number of symbolic names for constants that will be used throughout this tutorial. Specifically, we have alot* of variables in this program (of course the density and the displacement, but also the unfiltered density and quite a number of Lagrange multipliers). It is easy to forget which of these variables is at which position in the solution vector, and trying to use numbers for these vector components is a prescription for bugs. Rather, we define static variables that can be used in all of these places and that have to be initialized only once. In practice, this will lead to some lengthy expressions, but they are more readable and less likely to be wrong.</p>
<p>A similar issue arises with the ordering of blocks in the system matrix and in vectors. The matrices have \(9\times 9\) blocks, and it's difficult to remember which is which. It is far easier to just use symbolic names for those as well.</p>
<p>Finally, while we're at it, we introduce symbolic names also for the boundary indicators we will use, in the same spirit as was done in <a class="el" href="step_19.html">step-19</a>.</p>
<p>In all of these cases, we declare these variables as members in a namespace. In the case of the solution components, the concrete values of these variables depend on the space dimension, so we use <a href="https://en.cppreference.com/w/cpp/language/variable_template">template variables</a> to make the value of the variable depend on a template argument in the same way as we often use template functions.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>This namespace keeps track of the first component in our finite element system that corresponds to each variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionComponents</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 dim;</div><div class="line">} <span class="comment">// namespace SolutionComponents</span></div></div><!-- fragment --><p>This is the namespace which keeps track of which block corresponds to which variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionBlocks</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">} <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>BoundaryIds</div><div class="line">{</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">} <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ValueExtractors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">    displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">    SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">    SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">    SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">    SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">} <span class="comment">// namespace ValueExtractors</span></div></div><!-- fragment --><p><a class="anchor" id="TheSANDTopOptmainclass"></a> </p><h3>The SANDTopOpt main class</h3>
<p>Next up is the main class for this problem. The majority of functions follow the usual naming schemes of tutorial programs, though there are a couple that have been broken out of what is usually called the <code>setup_system()</code> function because of their length, and there are also a number that deal with various aspects of the optimization algorithm.</p>
<p>As an added bonus, the program writes the computed design as an STL file that one can, for example, send to a 3d printer.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SANDTopOpt</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SANDTopOpt();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Most of the member variables are also standard. There are, however, a number of variables that are specifically related to the optimization algorithm (such the various scalar factors below) as well as the filter matrix to ensure that the design remains smooth.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">  <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">  <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h3>Constructor and set-up functions</h3>
<p>We initialize a <a class="el" href="classFESystem.html">FESystem</a> composed of 2 \(\times\)dim <code><a class="el" href="classFE__Q.html">FE_Q(1)</a></code> elements for the displacement variable and its Lagrange multiplier, and 7 <code><a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a></code> elements. These piecewise constant functions are for density-related variables: the density itself, the unfiltered density, the slack variables for the lower and upper bounds on the unfiltered density, and then Lagrange multipliers for the connection between filtered and unfiltered densities as well as for the inequality constraints.</p>
<p>The order in which these elements appear is documented above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       5)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , density_ratio(.5)</div><div class="line">  , density_penalty_exponent(3)</div><div class="line">  , filter_r(.251)</div><div class="line">  , penalty_multiplier(1)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p>The first step then is to create the triangulation that matches the problem description in the introduction</p>
<p>&ndash; a 6-by-1 rectangle (or a 6-by-1-by-1 box in 3d) where a force will be applied in the top center. This triangulation is then uniformly refined a number of times.</p>
<p>In contrast to nearly the entire rest of this program, this function specifically assumes that we are in 2d and will require changes if we wanted to move to 3d simulations. We ensure that nobody tries to accidentally run in 3d without such modifications through an assertion at the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            {6, 1},</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">  triangulation.refine_global(3);</div></div><!-- fragment --><p>The second step is to apply boundary indicators to parts of the boundary. The following code assigns boundary indicators to the bottom, top, left, and right boundaries of the box, respectively. The center region of the top boundary is given a separate boundary indicator: This is where we will apply the down force.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1)</div><div class="line"></div><div class="line">- 1) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0)</div><div class="line"></div><div class="line">- 3) &lt; .3))</div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the constraints due to boundary values. The bottom corners of the domain are kept in place in the \(y\) direction</p>
<p>&ndash; the bottom left also in the \(x\) direction. deal.II generally thinks of boundary values as attached to pieces of the boundary, i.e., faces, rather than individual vertices. Indeed, mathematically speaking, one can not assign boundary values to individual points for the infinite-dimensional partial differential equation. But, since we are trying to reproduce a widely used benchmark, we will do so anyway and keep in mind that we have a finite-dimensional problem for which imposing boundary conditions at a single node is valid.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">{</div><div class="line">  boundary_values.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div></div><!-- fragment --><p>Check whether the current face is on the bottom boundary, and if it is whether one of its vertices might be the bottom left or bottom right vertex:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[x_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line"></div><div class="line">                      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0)</div><div class="line"></div><div class="line">- 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                               <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Settingupblockmatricesandvectors"></a> </p><h3>Setting up block matrices and vectors</h3>
<p>The next function makes a giant 9-by-9 block matrix, and also sets up the necessary block vectors. The sparsity pattern for this matrix includes the sparsity pattern for the filter matrix. It also initializes any block vectors we will use.</p>
<p>Setting up the blocks by themselves is not overly complicated and follows what is already done in programs such as <a class="el" href="step_22.html">step-22</a>, for example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">  block_component[0] = 0;</div><div class="line">  block_component[1] = 1;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">    n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">      dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">  dsp.collect_sizes();</div></div><!-- fragment --><p>The bulk of the function is in setting up which of these blocks will actually contain anything, i.e., which variables couple with which other variables. This is cumbersome but necessary to ensure that we don't just allocate a very large number of entries for our matrix that will then end up being zero.</p>
<p>The concrete pattern you see below is something one probably has to draw once on a piece of paper, but follows in an otherwise relatively straightforward way from looking through the many terms of the bilinear form we will have to assemble in each nonlinear iteration.</p>
<p>The use of the symbolic names defined in namespace <code>SolutionComponents</code> helps understand what each of the following terms corresponds to, but it also makes the expressions lengthy and unwieldy: A term such as <code>coupling[SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;][SolutionComponents::density&lt;dim&gt;]</code> just doesn't read very well, and would either have to be split over several lines or run off the right edge of nearly every screen. As a consequence, we open a curly-brace enclosed code block in which we temporarily make the names in namespace <code>SolutionComponents</code> available without the namespace qualifier, by saying <code>using namespace SolutionComponents</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 dim + 7, 2 dim + 7);</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for displacement</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">        {</div><div class="line">          coupling[displacement&lt;dim&gt; + i]</div><div class="line">                  [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                  [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for slack variables</span></div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">}</div></div><!-- fragment --><p>Before we can create the sparsity pattern, we also have to set up constraints. Since this program does not adaptively refine the mesh, the only constraint we have is one that couples all density variables to enforce the volume constraint. This will ultimately lead to a dense sub-block of the matrix, but there is little we can do about that.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">    fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">  <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">    density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>()</div><div class="line"></div><div class="line">- 1);</div><div class="line">  constraints.clear();</div><div class="line">  constraints.add_line(last_density_dof);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>()</div><div class="line"></div><div class="line">- 1; ++i)</div><div class="line">    constraints.add_entry(last_density_dof,</div><div class="line">                          density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1);</div><div class="line">  constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">  constraints.close();</div></div><!-- fragment --><p>We can now finally create the sparsity pattern for the matrix, taking into account which variables couple with which other variables, and the constraints we have on the density.</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div></div><!-- fragment --><p>The only part of the matrix we have not dealt with is the filter matrix and its transpose. These are non-local (integral) operators for which deal.II does not currently have functions. What we will ultimately need to do is go over all cells and couple the unfiltered density on this cell to all filtered densities of neighboring cells that are less than a threshold distance away, and the other way around; for the moment, we are only concerned with building the sparsity pattern that would correspond to this kind of matrix, so we perform the equivalent loop and where later on we would write into an entry of the matrix, we now simply add an entry to the sparsity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Having so generated the "dynamic" sparsity pattern, we can finally copy it to the structure that is used to associate matrices with a sparsity pattern. Because the sparsity pattern is large and complex, we also output it into a file of its own for visualization purposes</p>
<p>&ndash; in other words, for "visual debugging".</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>What is left is to correctly size the various vectors and their blocks, as well as setting initial guesses for some of the components of the (nonlinear) solution vector. We here use the symbolic component names for individual blocks of the solution vector and, for brevity, use the same trick with <code>using namespace</code> as above:</p>
<div class="fragment"><div class="line">  nonlinear_solution.reinit(block_sizes);</div><div class="line">  system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">    nonlinear_solution.block(density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">      .add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">    nonlinear_solution.block(density_upper_slack).add(1</div><div class="line"></div><div class="line">- density_ratio);</div><div class="line">    nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefiltermatrix"></a> </p><h3>Creating the filter matrix</h3>
<p>Next up, a function that is used once at the beginning of the program: It creates a matrix \(H\) so that the filtered density vector equals \(H\) times the unfiltered density. The creation of this matrix is non-trivial, and it is used in every iteration, and so rather than reforming it as we do with the Newton matrix, it is made only once and stored separately.</p>
<p>The way this matrix is computed follows the outline used above already to form its sparsity pattern. We repeat this process here for the sparsity pattern of this separately formed matrix, and then actually build the matrix itself. You may want to check the definition of this matrix in the introduction to this program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">{</div></div><!-- fragment --><p>The sparsity pattern of the filter has already been determined and implemented in the setup_system() function. We copy the structure from the appropriate block and use it again here.</p>
<div class="fragment"><div class="line">filter_sparsity_pattern.copy_from(</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">filter_matrix.reinit(filter_sparsity_pattern);</div></div><!-- fragment --><p>Having so built the sparsity pattern, now we re-do all of these loops to actually compute the necessary values of the matrix entries:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">            cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">          <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">            {</div><div class="line">              filter_matrix.add(i,</div><div class="line">                                check_cell-&gt;active_cell_index(),</div><div class="line">                                filter_r</div><div class="line"></div><div class="line">- distance);</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>The final step is to normalize the matrix so that for each row, the sum of entries equals one.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> denominator = 0;</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        denominator = denominator + iter-&gt;value();</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function is used for building the filter matrix. We create a set of all the cell iterators within a certain radius of the cell that is input. These are the neighboring cells that will be relevant for the filter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">  neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">  cells_to_check.insert(cell);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">           std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">             cells_to_check.begin(), cells_to_check.end()))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                    cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                  <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                      !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                    {</div><div class="line">                      cells_to_check.insert(neighbor);</div><div class="line">                      neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                      new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">  <span class="keywordflow">return</span> cells_to_check;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingtheNewtonmatrix"></a> </p><h3>Assembling the Newton matrix</h3>
<p>Whereas the setup_filter_matrix function built a matrix that is the same as long as the mesh does not change (which we don't do anyway in this program), the next function builds the matrix to be solved in each iteration. This is where the magic happens. The components of the system of linear equations describing Newton's method for finding the solution of the KKT conditions are implemented here.</p>
<p>The top of the function is as in most of these functions and just sets up all sorts of variables necessary for the actual assembly, including a whole bunch of extractors. The entire set up should look familiar, though somewhat lengthier, if you've previously looked at <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div></div><!-- fragment --><p>At this point, we apply the filter to the unfiltered density, and apply the adjoint (transpose) operation to the unfiltered density multiplier, both to the current best guess for the nonlinear solution. We use this later to tell us how far off our filtered density is from the filter applied to the unfiltered density. That is because while at the solution of the nonlinear problem, we have \(\rho=H\varrho\), but at intermediate iterations, we in general have \(\rho^k\neq H\varrho^k\) and the "residual" \(\rho^k-H\varrho^k\) will then appear as the right hand side of one of the Newton update equations that we compute below.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"></div><div class="line">filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                      SolutionBlocks::unfiltered_density),</div><div class="line">                    nonlinear_solution.block(</div><div class="line">                      SolutionBlocks::unfiltered_density));</div><div class="line">filter_matrix.Tvmult(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">  nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">  n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">  n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>ValueExtractors;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">    mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div></div><!-- fragment --><p>As part of the construction of our system matrix, we need to retrieve values from our current guess at the solution. The following lines of code retrieve the needed values.</p>
<div class="fragment"><div class="line">fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                              old_density_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_divs);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">  nonlinear_solution, old_displacement_symmgrads);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">  .get_function_symmetric_gradients(</div><div class="line">    nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_values);</div><div class="line">fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_values);</div><div class="line">fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filtered_unfiltered_density_solution,</div><div class="line">  filtered_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We need several more values corresponding to the test functions coming from the first derivatives taken from the Lagrangian, that is the \(d_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">      fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">      fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      displacement_multiplier_phi_i_symmgrad =</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">          i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                          q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">      fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                           q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div></div><!-- fragment --><p>Finally, we need values that come from the second round of derivatives taken from the Lagrangian, the \(c_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">  fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                   q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">  fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  displacement_multiplier_phi_j_symmgrad =</div><div class="line">    fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">      .symmetric_gradient(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">  fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">  fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">  fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">  fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">  fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div></div><!-- fragment --><p>This is where the actual work starts. In the following, we will build all of the terms of the matrix</p>
<p>&ndash; they are numerous and not entirely self-explanatory, also depending on the previous solutions and its derivatives (which we have already evaluated above and put into the variables called <code>old_*</code>). To understand what each of these terms corresponds to, you will want to look at the explicit form of these terms in the introduction above.</p>
<p>The right hand sides of the equations being driven to 0 give all the KKT conditions for finding a local minimum</p>
<p>&ndash; the descriptions of what each individual equation are given with the computations of the right hand side.</p>
<div class="fragment"><div class="line">                  <span class="comment">// Equation 1</span></div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point)</div><div class="line">                    (</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-density_phi_i unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                      + density_penalty_exponent</div><div class="line">                          (density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent</div><div class="line"></div><div class="line">- 2)</div><div class="line">                          density_phi_i density_phi_j</div><div class="line">                          (old_displacement_multiplier_divs[q_point]</div><div class="line">                             old_displacement_divs[q_point]</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (old_displacement_symmgrads[q_point]</div><div class="line">                              old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                      + density_penalty_exponent</div><div class="line">                          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                          density_phi_i</div><div class="line">                          (displacement_multiplier_phi_j_div</div><div class="line">                             old_displacement_divs[q_point]</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (old_displacement_symmgrads[q_point]</div><div class="line">                              displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                      + density_penalty_exponent</div><div class="line">                          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                          density_phi_i</div><div class="line">                          (displacement_phi_j_div</div><div class="line">                             old_displacement_multiplier_divs[q_point]</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (old_displacement_multiplier_symmgrads[q_point]</div><div class="line">                              displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 2</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (density_penalty_exponent</div><div class="line">                       <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                       density_phi_j</div><div class="line">                       (old_displacement_multiplier_divs[q_point]</div><div class="line">                          displacement_phi_i_div lambda_values[q_point] +</div><div class="line">                        2 mu_values[q_point]</div><div class="line">                          (old_displacement_multiplier_symmgrads[q_point]</div><div class="line">                           displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                     + <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                density_penalty_exponent)</div><div class="line">                         (displacement_multiplier_phi_j_div</div><div class="line">                            displacement_phi_i_div lambda_values[q_point] +</div><div class="line">                          2 mu_values[q_point]</div><div class="line">                            (displacement_multiplier_phi_j_symmgrad</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                    );</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 3, which has to do with the filter and which is calculated elsewhere.</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (-1 unfiltered_density_phi_i</div><div class="line">                       lower_slack_multiplier_phi_j +</div><div class="line">                     unfiltered_density_phi_i upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                  <span class="comment">// Equation 4: Primal feasibility</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (</div><div class="line"></div><div class="line">                      density_penalty_exponent</div><div class="line">                        <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                 density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                        density_phi_j</div><div class="line">                        (old_displacement_divs[q_point]</div><div class="line">                           displacement_multiplier_phi_i_div</div><div class="line">                           lambda_values[q_point] +</div><div class="line">                         2 mu_values[q_point]</div><div class="line">                           (old_displacement_symmgrads[q_point]</div><div class="line">                            displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      + <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                 density_penalty_exponent)</div><div class="line">                          (displacement_phi_j_div</div><div class="line">                             displacement_multiplier_phi_i_div</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (displacement_phi_j_symmgrad</div><div class="line">                              displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 5: Primal feasibility</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                    lower_slack_multiplier_phi_i</div><div class="line">                    (unfiltered_density_phi_j</div><div class="line"></div><div class="line">- lower_slack_phi_j);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 6: Primal feasibility</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                    upper_slack_multiplier_phi_i</div><div class="line">                    (-1 unfiltered_density_phi_j</div><div class="line"></div><div class="line">- upper_slack_phi_j);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 7: Primal feasibility</span></div><div class="line"></div><div class="line">- the part with the filter is added later</div><div class="line">                  cell_matrix(i, j) +=</div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                                       unfiltered_density_multiplier_phi_i</div><div class="line">                                       (density_phi_j);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 8: Complementary slackness</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (lower_slack_phi_i lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                     + lower_slack_phi_i lower_slack_phi_j</div><div class="line">                         old_lower_slack_multiplier_values[q_point] /</div><div class="line">                         old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 9: Complementary slackness</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (upper_slack_phi_i upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                     + upper_slack_phi_i upper_slack_phi_j</div><div class="line">                         old_upper_slack_multiplier_values[q_point] /</div><div class="line">                         old_upper_slack_values[q_point]);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div></div><!-- fragment --><p>Now that we have everything assembled, all we have to do is deal with the effect of (Dirichlet) boundary conditions and other constraints. We incorporate the former locally with just the contributions from the current cell, and then let the AffineConstraint class deal with the latter while copying contributions from the current cell into the global linear system:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                           local_dof_indices,</div><div class="line">                                           cell_matrix,</div><div class="line">                                           dummy_cell_rhs,</div><div class="line">                                           <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Having accumulated all of the terms that belong into the Newton matrix, we now also have to compute the terms for the right hand side (i.e., the negative residual). We already do this in another function, and so we call that here:</p>
<div class="fragment"><div class="line">system_rhs = calculate_test_rhs(nonlinear_solution);</div></div><!-- fragment --><p>Here we use the filter matrix we have already constructed. We only need to integrate this filter applied to test functions, which are piecewise constant, and so the integration becomes a simple multiplication by the measure of the cell. Iterating over the pre-made filter matrix allows us to use the information about which cells are in or out of the filter without repeatedly checking neighbor cells again.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">             filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           ++iter)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() cell-&gt;measure();</div><div class="line"></div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                   SolutionBlocks::unfiltered_density)</div><div class="line">            .add(i, j, value);</div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density,</div><div class="line">                   SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">            .add(j, i, value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvingtheNewtonlinearsystem"></a> </p><h3>Solving the Newton linear system</h3>
<p>We will need to solve a linear system in each iteration. We use a direct solver, for now</p>
<p>&ndash; this is clearly not an efficient choice for a matrix that has so many non-zeroes, and it will not scale to anything interesting. For "real" applications, we will need an iterative solver but the complexity of the system means that an iterative solver algorithm will take a good deal of work. Because this is not the focus of the current program, we simply stick with the direct solver we have here</p>
<p>&ndash; the function follows the same structure as used in <a class="el" href="step_29.html">step-29</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">  linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> linear_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Detailsoftheoptimizationalgorithm"></a> </p><h3>Details of the optimization algorithm</h3>
<p>The next several functions deal with specific parts of the optimization algorithm, most notably with deciding whether the direction computed by solving the linearized (Newton) system is viable and, if so, how far we want to go in this direction.</p>
<p><a class="anchor" id="Computingsteplengths"></a> </p><h4>Computing step lengths</h4>
<p>We start with a function that does a binary search to figure out the maximum step that meets the dual feasibility</p>
<p>&ndash; that is, how far can we go so that \(s&gt;0\) and \(z&gt;0\). The function returns a pair of values, one each for the \(s\) and \(z\) slack variables.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1.</div><div class="line"></div><div class="line">- 1e-5;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1</div><div class="line"></div><div class="line">- barrier_size)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (1</div><div class="line"></div><div class="line">- barrier_size &lt; max_fraction_to_boundary)</div><div class="line">        fraction_to_boundary = 1</div><div class="line"></div><div class="line">- barrier_size;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">    {</div><div class="line">      step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">      step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">        (fraction_to_boundary state) + (step_size_s step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">        (fraction_to_boundary state) + (step_size_z step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">           .is_non_negative());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">           .is_non_negative());</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_s)</div><div class="line">        step_size_s_low = step_size_s;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_z)</div><div class="line">        step_size_z_low = step_size_z;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_z_high = step_size_z;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingresiduals"></a> </p><h4>Computing residuals</h4>
<p>The next function computes a right hand side vector linearized around a "test solution vector" that we can use to look at the magnitude of the KKT conditions. This is then used for testing the convergence before shrinking the barrier size, as well as in the calculation of the \(l_1\) merit.</p>
<p>The function is lengthy and complicated, but it is really just a copy of the right hand side part of what the <code>assemble_system()</code> function above did.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>We first create a zero vector with size and blocking of system_rhs</p>
<div class="fragment"><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">  test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">    test_solution;</div><div class="line">  filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density) = 0;</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">  filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density),</div><div class="line">                      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density));</div><div class="line">  filter_matrix.Tvmult(</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">    test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">    n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">      mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">      fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                    old_density_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_divs);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">        test_solution, old_displacement_symmgrads);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_multiplier_values);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_multiplier_divs);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">        .get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_values);</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_multiplier_values);</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_values);</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filtered_unfiltered_density_solution,</div><div class="line">        filtered_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                displacement_multiplier_phi_i_symmgrad =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                    i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                    q_point);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                     q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 1: This equation, along with equations 2 and 3, are the variational derivatives of the Lagrangian with respect to the decision variables</span></div><div class="line"></div><div class="line">- the density, displacement, and unfiltered density.</div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point)</div><div class="line">                (density_penalty_exponent</div><div class="line">                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                   density_phi_i</div><div class="line">                   (old_displacement_multiplier_divs[q_point]</div><div class="line">                      old_displacement_divs[q_point]</div><div class="line">                      lambda_values[q_point] +</div><div class="line">                    2 mu_values[q_point]</div><div class="line">                      (old_displacement_symmgrads[q_point]</div><div class="line">                       old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">-</div><div class="line">                 density_phi_i</div><div class="line">                   old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 2; the boundary terms will be added further down below.</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (<a class="code" href="namespacestd.html">std</a>::pow(old_density_values[q_point],</div><div class="line">                          density_penalty_exponent)</div><div class="line">                 (old_displacement_multiplier_divs[q_point]</div><div class="line">                    displacement_phi_i_div lambda_values[q_point] +</div><div class="line">                  2 mu_values[q_point]</div><div class="line">                    (old_displacement_multiplier_symmgrads[q_point]</div><div class="line">                     displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 3</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (unfiltered_density_phi_i</div><div class="line">                   filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                     [q_point] +</div><div class="line">                 unfiltered_density_phi_i</div><div class="line">                   old_upper_slack_multiplier_values[q_point] +</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 unfiltered_density_phi_i</div><div class="line">                   old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">              <span class="comment">// Equation 4; boundary term will again be dealt with below. This equation being driven to 0 ensures that the elasticity equation is met as a constraint.</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                             (<a class="code" href="namespacestd.html">std</a>::pow(old_density_values[q_point],</div><div class="line">                                       density_penalty_exponent)</div><div class="line">                              (old_displacement_divs[q_point]</div><div class="line">                                 displacement_multiplier_phi_i_div</div><div class="line">                                 lambda_values[q_point] +</div><div class="line">                               2 mu_values[q_point]</div><div class="line">                                 (displacement_multiplier_phi_i_symmgrad</div><div class="line">                                  old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 5: This equation sets the lower slack variable equal to the unfiltered density, giving a minimum density of 0.</span></div><div class="line">              cell_rhs(i) += fe_values.JxW(q_point)</div><div class="line">                             (lower_slack_multiplier_phi_i</div><div class="line">                              (old_unfiltered_density_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                               old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 6: This equation sets the upper slack variable equal to one minus the unfiltered density.</span></div><div class="line">              cell_rhs(i) += fe_values.JxW(q_point)</div><div class="line">                             (upper_slack_multiplier_phi_i</div><div class="line">                              (1</div><div class="line"></div><div class="line">- old_unfiltered_density_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                               old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 7: This is the difference between the density and the filter applied to the unfiltered density. This being driven to 0 by the Newton steps ensures that the filter is applied correctly.</span></div><div class="line">              cell_rhs(i) += fe_values.JxW(q_point)</div><div class="line">                             (unfiltered_density_multiplier_phi_i</div><div class="line">                              (old_density_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                               filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 8: This along with equation 9 give the requirement that s*z = \alpha for the barrier size alpha, and gives complementary slackness from KKT conditions when \alpha goes to 0.</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (lower_slack_phi_i</div><div class="line">                 (old_lower_slack_multiplier_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                  barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 9</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (upper_slack_phi_i</div><div class="line">                 (old_upper_slack_multiplier_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                  barrier_size / old_upper_slack_values[q_point]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      for (const auto &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                   fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] =</div><div class="line"></div><div class="line">-1.;</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1</div><div class="line">                        (traction fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                      i, face_q_point))</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (traction</div><div class="line">                         fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                           i, face_q_point))</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               dummy_cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             test_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> test_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingthemeritfunction"></a> </p><h4>Computing the merit function</h4>
<p>The algorithm we use herein uses a "watchdog" strategy to determine where and how far to go from the current iterate. We base the watchdog strategy on an exact \(l_1\) merit function. This function calculates the exact \(l_1\) merit of a given, putative, next iterate.</p>
<p>The merit function consists of the sum of the objective function (which is simply an integral of external forces (on the boundary of the domain) times the displacement values of a test solution (typically, the current solution plus some multiple of the Newton update), and the \(l_1\) norms of the Lagrange multiplier components of residual vectors. The following code computes these parts in turn:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div></div><!-- fragment --><p>Start with computing the objective function:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                  .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                       displacement_face_values);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                     face_q_point &lt; n_face_q_points;</div><div class="line">                     ++face_q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                    traction[1] =</div><div class="line"></div><div class="line">-1.;</div><div class="line"></div><div class="line">                    objective_function_merit +=</div><div class="line">                      (traction displacement_face_values[face_q_point])</div><div class="line">                      fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      objective_function_merit =</div><div class="line">        objective_function_merit</div><div class="line"></div><div class="line">-</div><div class="line">        barrier_size cell-&gt;measure()</div><div class="line">          <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">            SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      objective_function_merit =</div><div class="line">        objective_function_merit</div><div class="line"></div><div class="line">-</div><div class="line">        barrier_size cell-&gt;measure()</div><div class="line">          <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">            SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">    }</div></div><!-- fragment --><p>Then compute the residual and take the \(l_1\) norms of the components that correspond to Lagrange mulipliers. We add those to the objective function computed above, and return the sum at the bottom:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">    objective_function_merit + elasticity_constraint_merit +</div><div class="line">    filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">  <span class="keywordflow">return</span> total_merit;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Findingasearchdirection"></a> </p><h4>Finding a search direction</h4>
<p>Next up is the function that actually computes a search direction starting at the current state (passed as the first argument) and returns the resulting vector. To this end, the function first calls the functions that assemble the linear system that corresponds to the Newton system, and that solve it.</p>
<p>This function also updates the penalty multiplier in the merit function, and then returns the largest scaled feasible step. It uses the <code>calculate_max_step_sizes()</code> function to find the largest feasible step that satisfies \(s&gt;0\) and \(z&gt;0\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">{</div><div class="line">  assemble_system();</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div></div><!-- fragment --><p>Next we are going to update penalty_multiplier. In essence, a larger penalty multiplier makes us consider the constraints more. Looking at the Hessian and gradient with respect to the step we want to take with our decision variables, and comparing that to the norm of our constraint error gives us a way to ensure that our merit function is "exact"</p>
<ul>
<li>that is, it has a minimum in the same location that the objective function does. As our merit function is exact for any penalty multiplier over some minimum value, we only keep the computed value if it increases the penalty multiplier.</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">    SolutionBlocks::density,</div><div class="line">    SolutionBlocks::displacement,</div><div class="line">    SolutionBlocks::unfiltered_density,</div><div class="line">    SolutionBlocks::density_upper_slack,</div><div class="line">    SolutionBlocks::density_lower_slack};</div><div class="line">  <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">  <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">        {</div><div class="line">          Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">          system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">            .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">          hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) temp_vector;</div><div class="line">        }</div><div class="line">      grad_part</div><div class="line"></div><div class="line">-= system_rhs.block(decision_variable_i)</div><div class="line">                   step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">    SolutionBlocks::displacement_multiplier,</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">    SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">    SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">  <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">    constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">  <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">    test_penalty_multiplier =</div><div class="line">      (grad_part + .5 hess_part) / (.05 constraint_norm);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    test_penalty_multiplier = (grad_part) / (.05 constraint_norm);</div><div class="line"></div><div class="line">  penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div></div><!-- fragment --><p>Based on all of this, we can now compute step sizes for the primal and dual (Lagrange multiplier) variables. Once we have these, we scale the components of the solution vector, and that is what this function returns.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">    calculate_max_step_size(nonlinear_solution, step);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier)= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier)= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)= step_size_z;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingascaledstep"></a> </p><h4>Computing a scaled step</h4>
<p>The next function then implements a back-tracking algorithm for a line search. It keeps shrinking step size until it finds a step where the merit is decreased, and then returns the new location based on the current state vector, and the direction to go into, times the step length.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">    (calculate_exact_merit(state + 1e-4 max_step)</div><div class="line"></div><div class="line">-</div><div class="line">     calculate_exact_merit(state)) /</div><div class="line">    1e-4;</div><div class="line">  <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size max_step) &lt;</div><div class="line">          calculate_exact_merit(state) +</div><div class="line">            step_size descent_requirement merit_derivative)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size = step_size / 2;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> state + (step_size max_step);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Checkingforconvergence"></a> </p><h4>Checking for convergence</h4>
<p>The final auxiliary function in this block is the one that checks to see if the KKT conditions are sufficiently met so that the overall algorithm can lower the barrier size. It does so by computing the \(l_1\) norm of the residual, which is what <code>calculate_test_rhs()</code> computes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition barrier_size;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">            &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessingthesolution"></a> </p><h3>Postprocessing the solution</h3>
<p>The first of the postprocessing functions outputs information in a VTU file for visualization. It looks long, but it's really just the same as what was done in <a class="el" href="step_22.html">step-22</a>, for example, just with (a lot) more solution variables:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p>The second of these functions outputs the solution as an <code>.stl</code> file for 3d printing. <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files are made up of triangles and normal vectors, and we will use it to show all of those cells with a density value larger than zero by first extruding the mesh from a \(z\) value of zero to \(z=0.25\), and then generating two triangles for each face of the cells with a sufficiently large density value. The triangle nodes must go counter-clockwise when looking from the outside, and the normal vectors must be unit vectors pointing outwards, which requires a few checks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">{</div><div class="line">  static_assert(dim == 2,</div><div class="line">                <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">  std::ofstream stlfile;</div><div class="line">  stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">  <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">            SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">        {</div></div><!-- fragment --><p>We have now found a cell with a density value larger than zero. Let us start by writing out the bottom and top faces. Owing to the ordering issue mentioned above, we have to make sure that we understand whether a cell has a right- or left-handed coordinate system. We do this by interrogating the directions of the two edges starting at vertex 0 and whether they form a right-handed coordinate system.</p>
<div class="fragment"><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1)</div><div class="line"></div><div class="line">-</div><div class="line">                                                       cell-&gt;vertex(0),</div><div class="line">                                                     cell-&gt;vertex(2)</div><div class="line"></div><div class="line">-</div><div class="line">                                                       cell-&gt;vertex(0)};</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">            {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">             {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">            {</div><div class="line">              <span class="comment">// Write one side at z = 0.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">              <span class="comment">// Write one side at z = height.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span> <span class="comment">// The cell has a left-handed set up</span></div><div class="line">            {</div><div class="line">              <span class="comment">// Write one side at z = 0.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">              <span class="comment">// Write one side at z = height.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">            }</div></div><!-- fragment --><p>Next we need to deal with the four faces of the cell, extended into the \(z\) direction. However, we only need to write these faces if either the face is on the domain boundary, or if it is the interface between a cell with density greater than 0.5, and a cell with a density less than 0.5.</p>
<div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">               face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">               ++face_number)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                cell-&gt;face(face_number);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                  (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                   (nonlinear_solution.block(</div><div class="line">                      0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                    0.5)))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                    (face-&gt;center()</div><div class="line"></div><div class="line">- cell-&gt;center());</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                  <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0])</div><div class="line">                          (face-&gt;vertex(1)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1])</div><div class="line">                          0.000000e+00 +</div><div class="line">                        (face-&gt;vertex(0)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1]) (0</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          normal_vector[0] +</div><div class="line">                        (height</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          (face-&gt;vertex(1)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0])</div><div class="line">                          normal_vector[1]</div><div class="line"></div><div class="line">-</div><div class="line">                        (face-&gt;vertex(0)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0]) (0</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          normal_vector[1]</div><div class="line"></div><div class="line">-</div><div class="line">                        (face-&gt;vertex(0)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1])</div><div class="line">                          (face-&gt;vertex(1)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0])</div><div class="line">                          normal_vector[0]</div><div class="line"></div><div class="line">-</div><div class="line">                        (height</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          (face-&gt;vertex(1)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1]) 0 &gt;</div><div class="line">                      0)</div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctiondrivingtheoverallalgorithm"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function driving the overall algorithm</h3>
<p>This function finally provides the overall driver logic. It is, in the grand scheme of things, a rather complicated function primarily because the optimization algorithm is difficult: It isn't just about finding a Newton direction like in <a class="el" href="step_15.html">step-15</a> and then going a fixed distance in this direction any more, but instead about (i) determining what the optimal log-barrier penalty parameter should be in the current step, (ii) a complicated algorithm to determine how far we want to go, and other ingredients. Let us see how we can break this down into smaller chunks in the following documentation.</p>
<p>The function starts out simple enough with first setting up the mesh, the <a class="el" href="classDoFHandler.html">DoFHandler</a>, and then the various linear algebra objects necessary for the following:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    setup_boundary_values();</div><div class="line">    setup_block_system();</div><div class="line">    setup_filter_matrix();</div><div class="line">  }</div></div><!-- fragment --><p>We then set a number of parameters that affect the log-barrier and line search components of the optimization algorithm:</p>
<div class="fragment"><div class="line">barrier_size                  = 25;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div></div><!-- fragment --><p>Now start the principal iteration. The overall algorithm works by using an outer loop in which we loop until either (i) the log-barrier parameter has become small enough, or (ii) we have reached convergence. In any case, we terminate if end up with too large a number of iterations. This overall structure is encoded as a <code>do { ... } while (...)</code> loop where the convergence condition is at the bottom.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div></div><!-- fragment --><p>Within this outer loop, we have an inner loop in which we try to find an update direction using the watchdog algorithm described in the introduction.</p>
<p>The general idea of the watchdog algorithm itself is this: For a maximum of <code>max_uphill_steps</code> (i.e., a loop within the "inner loop" mentioned above) attempts, we use <code>find_max_step()</code> to compute a Newton update step, and add these up in the <code>nonlinear_solution</code> vector. In each of these attempts (starting from the place reached at the end of the previous attempt), we check whether we have reached a target value of the merit function described above. The target value is computed based on where this algorithm starts (the <code>nonlinear_solution</code> at the beginning of the watchdog loop, saves as <code>watchdog_state</code>) and the first proposed direction provided by <code>find_max_step()</code> in the first go-around of this loop (the <code>k==0</code> case).</p>
<div class="fragment"><div class="line">      <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                    &lt;&lt; iteration_number</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                    &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">          <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">          <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">          <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">            {</div><div class="line">              ++iteration_number;</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (k == 0)</div><div class="line">                {</div><div class="line">                  first_step = update_step;</div><div class="line">                  merit_derivative =</div><div class="line">                    ((calculate_exact_merit(watchdog_state +</div><div class="line">                                            .0001 first_step)</div><div class="line"></div><div class="line">-</div><div class="line">                      calculate_exact_merit(watchdog_state)) /</div><div class="line">                     .0001);</div><div class="line">                  target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                 descent_requirement merit_derivative;</div><div class="line">                }</div><div class="line"></div><div class="line">              nonlinear_solution += update_step;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                        &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                        &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                {</div><div class="line">                  watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                  std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                            &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div></div><!-- fragment --><p>The next part of the algorithm then depends on whether the watchdog loop above succeeded. If it did, then we are satisfied and no further action is necessary: We just stay where we are. If, however, we took the maximal number of unsuccessful steps in the loop above, then we need to do something else, and this is what the following code block does.</p>
<p>Specifically, from the final (unsuccessful) state of the loop above, we seek one more update direction and take what is called a "stretch step". If that stretch state satisfies a condition involving the merit function, then we go there. On the other hand, if the stretch state is also unacceptable (as all of the watchdog steps above were), then we discard all of the watchdog steps taken above and start over again where we had started the watchdog iterations</p>
<p>&ndash; that place was stored in the <code>watchdog_state</code> variable above. More specifically, the conditions below first test whether we take a step from <code>watchdog_state</code> in direction <code>first_step</code>, or whether we can do one more update from the stretch state to find a new place. It is possible that neither of these is actually better than the state we started from at the beginning of the watchdog algorithm, but even if that is so, that place clearly was a difficult place to be in, and getting away to start the next iteration from another place might be a useful strategy to eventually converge.</p>
<p>We keep repeating the watchdog steps above along with the logic below until this inner iteration is finally converged (or if we run up against the maximal number of iterations</p>
<p>&ndash; where we count the number of linear solves as iterations and increment the counter every time we call <code>find_max_step()</code> since that is where the linear solve actually happens). In any case, at the end of each of these inner iterations we also output the solution in a form suitable for visualization.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    ++iteration_number;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">      compute_scaled_step(nonlinear_solution,</div><div class="line">                          update_step,</div><div class="line">                          descent_requirement);</div></div><!-- fragment --><p>If we did not get a successful watchdog step, we now need to decide between going back to where we started, or using the final state. We compare the merits of both of these locations, and then take a scaled step from whichever location is better. As the scaled step is guaranteed to lower the merit, we will end up keeping one of the two.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">             calculate_exact_merit(watchdog_state)) ||</div><div class="line">            (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            nonlinear_solution = stretch_state;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            std::cout</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                calculate_exact_merit(watchdog_state))</div><div class="line">              {</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(watchdog_state,</div><div class="line">                                      first_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                nonlinear_solution = stretch_state;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                  find_max_step();</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      stretch_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    output_results(iteration_number);</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">       (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div></div><!-- fragment --><p>At the end of the outer loop, we have to update the barrier parameter, for which we use the following formula. The rest of the function is then simply about checking the outer loop convergence condition, and if we decide to terminate computations, about writing the final "design" as an STL file for use in 3d printing, and to output some timing information.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">      barrier_size =</div><div class="line">        <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size barrier_size_multiplier,</div><div class="line">                          std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                 min_barrier_size);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">          (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">         (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">  write_as_stl();</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">}</div><div class="line">} <span class="comment">// namespace SAND</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The remainder of the code, the <code>main()</code> function, is as usual:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">    elastic_problem_2d.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="TestProblem"></a></p><h3>Test Problem</h3>
<p>The algorithms used above are tested against a traditional topology optimization problem called the Messerschmitt-Bolkow-Blohm Beam (MBB Beam).</p>
<p>This problem considers the optimal 2-d structure that can be built on a rectangle 6 units wide, and 1 unit tall. The bottom corners are fixed in place in the \(y\) direction using a zero Dirichlet boundary condition, and a downward force is applied in the center of the top of the beam by enforcing a Neumann boundary condition. The rest of the boundary is allowed to move, and has no external force applied, which takes the form of a zero Neumann boundary condition. In essence, we are asking the following question: How should we design a bridge in a way so that if the bottom left and bottom right point of the bridge are on rollers that allow these points to move horizontally but not vertically, and so that the displacement in response to the vertical force in the center is minimal.</p>
<p>While the total volume of the domain is 6 units, 3 units of material are allowed for the structure. Because of the symmetry of the problem, it could be posed on a rectangle of width 3 and height 1 by cutting the original domain in half, and using zero Dirichlet boundary conditions in the \(x\) direction along the cut edge. That said, symmetry of the solution is a good indicator that the program is working as expected, so we solved the problem on the whole domain, as shown below. <b>[Bendse2004]</b></p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.mbbgeometry.png" alt="The MBB problem domain and boundary conditions"/>
</div>
 </div><p>Using the program discussed above, we find the minimum volume of the MBB Beam and the individual components of the solution look as follows:</p>
<div class="onecolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.filtereddensity.png" alt="Filtered Density Solution"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.unfiltereddensity.png" alt="Unfiltered Density Solution"/>
</div>
 </div> </div><p>These pictures show that what we find here is in accordance with what onetypically sees in other publications on the topic <b>[Bendse2004]</b> . Maybe more interestingly, theresult looks like a truss bridge (except that we apply the load at the top ofthe trusses, rather than the bottom as in real truss bridges, akin to a "decktruss" bridge), suggesting that the designs that have been used in bridge-building for centuries are indeed based on ideas we can now show to be optimalin some sense.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h4>Possibilities for extensions</h4>
<p>The results shown above took around 75 iterations to find, which is quiteconcerning given the expense in solving the large linear systems in eachiteration. Looking at the evolution, it does look as though the convergence hasmoments of happening quickly and moments of happening slowly. We believe this tobe due to both a lack of precision on when and how to decrease the boundaryvalues, as well as our choice of merit function being sub-optimal. In the future,a LOQO barrier update replacing the monotone reduction, as well as a MarkovFilter in place of a merit function will decrease the number of necessaryiterations significantly. The barrier decrease is most sensitive in the middle of the convergence, whichis problematic, as it seems like we need it to decrease quickly, then slowly,then quickly again. Secondly, the linear solver used here is just the sparse direct solver based onthe <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class. This works reasonably well on small problems,but the formulation of the optimization problem detailed above has quite a largenumber of variables and so the linear problem is not only large but also has alot of nonzero entries in many rows, even on meshes that overall are stillrelatively coarse. As a consequence, the solver time dominates thecomputations, and more sophisticated approaches at solving the linear systemare necessary.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Justin O&#39;Connor, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionComponents</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">  } <span class="comment">// namespace SolutionComponents</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionBlocks</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">  } <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>BoundaryIds</div><div class="line">  {</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">  } <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>ValueExtractors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">      displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">      SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">      SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">      SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">      SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">  } <span class="comment">// namespace ValueExtractors</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SANDTopOpt</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SANDTopOpt();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">    std::pair&lt;double, double&gt;</div><div class="line">    calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">    calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">    find_relevant_neighbors(</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">    <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">    <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         5)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , density_ratio(.5)</div><div class="line">    , density_penalty_exponent(3)</div><div class="line">    , filter_r(.251)</div><div class="line">    , penalty_multiplier(1)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              {6, 1},</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">    triangulation.refine_global(3);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">  {</div><div class="line">    boundary_values.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[x_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line"></div><div class="line">                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                                 <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">    block_component[0] = 0;</div><div class="line">    block_component[1] = 1;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">        dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">            {</div><div class="line">              coupling[displacement&lt;dim&gt; + i]</div><div class="line">                      [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">              coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                      [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for slack variables */</span></div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">      fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">    <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">      density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">    constraints.clear();</div><div class="line">    constraints.add_line(last_density_dof);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">      constraints.add_entry(last_density_dof,</div><div class="line">                            density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                            -1);</div><div class="line">    constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                         SolutionBlocks::unfiltered_density)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    nonlinear_solution.reinit(block_sizes);</div><div class="line">    system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">      nonlinear_solution.block(density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">        .add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">      nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">  {</div><div class="line"></div><div class="line">    filter_sparsity_pattern.copy_from(</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                             SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">    filter_matrix.reinit(filter_sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                filter_matrix.add(i,</div><div class="line">                                  check_cell-&gt;active_cell_index(),</div><div class="line">                                  filter_r - distance);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> denominator = 0;</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          denominator = denominator + iter-&gt;value();</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">    neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">    cells_to_check.insert(cell);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">             std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">               cells_to_check.begin(), cells_to_check.end()))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                      cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                    <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                        !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                      {</div><div class="line">                        cells_to_check.insert(neighbor);</div><div class="line">                        neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                        new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">    <span class="keywordflow">return</span> cells_to_check;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">      nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      nonlinear_solution;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        nonlinear_solution.block(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          nonlinear_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                                       q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                      displacement_multiplier_phi_j_symmgrad =</div><div class="line">                        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">                          .symmetric_gradient(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">                      fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">                      fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">                      fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">                      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">                      fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">                      fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 1 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            (density_penalty_exponent - 1) *</div><div class="line">                            std::pow(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 2) *</div><div class="line">                            density_phi_i * density_phi_j *</div><div class="line">                            (old_displacement_multiplier_divs[q_point] *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_multiplier_phi_j_div *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               old_displacement_multiplier_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                                displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 2 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (density_penalty_exponent *</div><div class="line">                         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent - 1) *</div><div class="line">                         density_phi_j *</div><div class="line">                         (old_displacement_multiplier_divs[q_point] *</div><div class="line">                            displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                          2 * mu_values[q_point] *</div><div class="line">                            (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                       + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent) *</div><div class="line">                           (displacement_multiplier_phi_j_div *</div><div class="line">                              displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                            2 * mu_values[q_point] *</div><div class="line">                              (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                               displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      );</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">                     * calculated elsewhere. */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (-1 * unfiltered_density_phi_i *</div><div class="line">                         lower_slack_multiplier_phi_j +</div><div class="line">                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        density_penalty_exponent *</div><div class="line">                          <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent - 1) *</div><div class="line">                          density_phi_j *</div><div class="line">                          (old_displacement_divs[q_point] *</div><div class="line">                             displacement_multiplier_phi_i_div *</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 * mu_values[q_point] *</div><div class="line">                             (old_displacement_symmgrads[q_point] *</div><div class="line">                              displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                        + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent) *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               displacement_multiplier_phi_i_div *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (displacement_phi_j_symmgrad *</div><div class="line">                                displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      lower_slack_multiplier_phi_i *</div><div class="line">                      (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      upper_slack_multiplier_phi_i *</div><div class="line">                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">                     * is added later */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                                         unfiltered_density_multiplier_phi_i *</div><div class="line">                                         (density_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                       + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                           old_lower_slack_multiplier_values[q_point] /</div><div class="line">                           old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                       + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                           old_upper_slack_multiplier_values[q_point] /</div><div class="line">                           old_upper_slack_values[q_point]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 cell_matrix,</div><div class="line">                                                 dummy_cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    system_rhs = calculate_test_rhs(nonlinear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">               filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             ++iter)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .add(i, j, value);</div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .add(j, i, value);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">    linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> linear_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">          fraction_to_boundary = 1 - barrier_size;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">      {</div><div class="line">        step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">        step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">          (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">          (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">             .is_non_negative());</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">             .is_non_negative());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_s)</div><div class="line">          step_size_s_low = step_size_s;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_z)</div><div class="line">          step_size_z_low = step_size_z;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_z_high = step_size_z;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">    test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      test_solution;</div><div class="line">    filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density) = 0;</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">                 * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">                 * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">                 * variables - the density, displacement, and</span></div><div class="line"><span class="comment">                 * unfiltered density. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (density_penalty_exponent *</div><div class="line">                     <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                              density_penalty_exponent - 1) *</div><div class="line">                     density_phi_i *</div><div class="line">                     (old_displacement_multiplier_divs[q_point] *</div><div class="line">                        old_displacement_divs[q_point] *</div><div class="line">                        lambda_values[q_point] +</div><div class="line">                      2 * mu_values[q_point] *</div><div class="line">                        (old_displacement_symmgrads[q_point] *</div><div class="line">                         old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                   density_phi_i *</div><div class="line">                     old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">                 * below. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent) *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                       displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 3 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (unfiltered_density_phi_i *</div><div class="line">                     filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                       [q_point] +</div><div class="line">                   unfiltered_density_phi_i *</div><div class="line">                     old_upper_slack_multiplier_values[q_point] +</div><div class="line">                   -1 * unfiltered_density_phi_i *</div><div class="line">                     old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">                 * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">                 * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">                 * a constraint. */</span></div><div class="line">                cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                         density_penalty_exponent) *</div><div class="line">                                (old_displacement_divs[q_point] *</div><div class="line">                                   displacement_multiplier_phi_i_div *</div><div class="line">                                   lambda_values[q_point] +</div><div class="line">                                 2 * mu_values[q_point] *</div><div class="line">                                   (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                    old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">                 * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">                 * giving a minimum density of 0. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (lower_slack_multiplier_phi_i *</div><div class="line">                                (old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">                 * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">                 * density. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (upper_slack_multiplier_phi_i *</div><div class="line">                                (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">                 * density and the filter applied to the</span></div><div class="line"><span class="comment">                 * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">                 * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">                 * applied correctly. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (unfiltered_density_multiplier_phi_i *</div><div class="line">                                (old_density_values[q_point] -</div><div class="line">                                 filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">                 * requirement that @f$s*z = \alpha@f$ for the barrier</span></div><div class="line"><span class="comment">                 * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">                 * from KKT conditions when @f$\alpha@f$ goes to 0. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (lower_slack_phi_i *</div><div class="line">                   (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 9 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (upper_slack_phi_i *</div><div class="line">                   (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_upper_slack_values[q_point]));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                     fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                      {</div><div class="line">                        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                        traction[1] = -1.;</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          -1 *</div><div class="line">                          (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                        i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          (traction *</div><div class="line">                           fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                             i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 dummy_cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               test_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> test_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">    {</div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                              fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                       fe,</div><div class="line">                                       face_quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                  face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">                {</div><div class="line">                  fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                  fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                    .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                         displacement_face_values);</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                       face_q_point &lt; n_face_q_points;</div><div class="line">                       ++face_q_point)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      objective_function_merit +=</div><div class="line">                        (traction * displacement_face_values[face_q_point]) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">      objective_function_merit + elasticity_constraint_merit +</div><div class="line">      filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">    <span class="keywordflow">return</span> total_merit;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">  {</div><div class="line">    assemble_system();</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">      SolutionBlocks::density,</div><div class="line">      SolutionBlocks::displacement,</div><div class="line">      SolutionBlocks::unfiltered_density,</div><div class="line">      SolutionBlocks::density_upper_slack,</div><div class="line">      SolutionBlocks::density_lower_slack};</div><div class="line">    <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">    <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">          {</div><div class="line">            Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">            system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">              .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">            hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">          }</div><div class="line">        grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                     step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">      SolutionBlocks::displacement_multiplier,</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">      SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">      SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">    <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">    <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">      test_penalty_multiplier =</div><div class="line">        (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">    penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">      calculate_max_step_size(nonlinear_solution, step);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> step;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">      (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">       calculate_exact_merit(state)) /</div><div class="line">      1e-4;</div><div class="line">    <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">            calculate_exact_merit(state) +</div><div class="line">              step_size * descent_requirement * merit_derivative)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size = step_size / 2;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">              &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">  {</div><div class="line">    static_assert(dim == 2,</div><div class="line">                  <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">    std::ofstream stlfile;</div><div class="line">    stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">    <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">              SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                                         cell-&gt;vertex(0),</div><div class="line">                                                       cell-&gt;vertex(2) -</div><div class="line">                                                         cell-&gt;vertex(0)};</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">              {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">               {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">                 face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                 ++face_number)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                  cell-&gt;face(face_number);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                    (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                     (nonlinear_solution.block(</div><div class="line">                        0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                      0.5)))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                      (face-&gt;center() - cell-&gt;center());</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                    <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            0.000000e+00 +</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                            normal_vector[0] +</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[0] -</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                        0)</div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">      setup_boundary_values();</div><div class="line">      setup_block_system();</div><div class="line">      setup_filter_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">    barrier_size                  = 25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                      &lt;&lt; iteration_number</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                      &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">            <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">            <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">            <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (k == 0)</div><div class="line">                  {</div><div class="line">                    first_step = update_step;</div><div class="line">                    merit_derivative =</div><div class="line">                      ((calculate_exact_merit(watchdog_state +</div><div class="line">                                              .0001 * first_step) -</div><div class="line">                        calculate_exact_merit(watchdog_state)) /</div><div class="line">                       .0001);</div><div class="line">                    target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                   descent_requirement * merit_derivative;</div><div class="line">                  }</div><div class="line"></div><div class="line">                nonlinear_solution += update_step;</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                  calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                          &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                          &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                  {</div><div class="line">                    watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      update_step,</div><div class="line">                                      descent_requirement);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">                     calculate_exact_merit(watchdog_state)) ||</div><div class="line">                    (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">                  {</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                    nonlinear_solution = stretch_state;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    std::cout</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                        calculate_exact_merit(watchdog_state))</div><div class="line">                      {</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(watchdog_state,</div><div class="line">                                              first_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        ++iteration_number;</div><div class="line">                        nonlinear_solution = stretch_state;</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                          find_max_step();</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(nonlinear_solution,</div><div class="line">                                              stretch_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            output_results(iteration_number);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">               (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic Material with Penalization</a>
        <li><a href="#ElasticityEquation">Elasticity Equation</a>
        <li><a href="#Makingthesolutionmeshindependent">Making the solution mesh-independent</a>
        <li><a href="#CompleteProblemFormulation">Complete Problem Formulation</a>
        <li><a href="#Solutionprocedure">Solution procedure</a>
        <li><a href="#Discretization">Discretization</a>
        <li><a href="#NonlinearAlgorithm">Nonlinear Algorithm</a>
        <li><a href="#MeritFunction">Merit Function</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Preliminaries">Preliminaries</a>
        <li><a href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a>
        <li><a href="#Constructorandsetupfunctions">Constructor and set-up functions</a>
        <li><a href="#Settingupblockmatricesandvectors">Setting up block matrices and vectors</a>
        <li><a href="#Creatingthefiltermatrix">Creating the filter matrix</a>
        <li><a href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a>
        <li><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear system</a>
        <li><a href="#Detailsoftheoptimizationalgorithm">Details of the optimization algorithm</a>
      <ul>
        <li><a href="#Computingsteplengths">Computing step lengths</a>
        <li><a href="#Computingresiduals">Computing residuals</a>
        <li><a href="#Computingthemeritfunction">Computing the merit function</a>
        <li><a href="#Findingasearchdirection">Finding a search direction</a>
        <li><a href="#Computingascaledstep">Computing a scaled step</a>
        <li><a href="#Checkingforconvergence">Checking for convergence</a>
      </ul>
        <li><a href="#Postprocessingthesolution">Postprocessing the solution</a>
        <li><a href="#Therunfunctiondrivingtheoverallalgorithm">The run() function driving the overall algorithm</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#TestProblem">Test Problem</a>
      <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-79/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>弹性介质的拓扑优化是一种用于优化承受某种载荷的结构的技术。理想情况下，我们希望通过选择一个放置材料的区域 \(E\) ，使置于结构上的最大应力最小化。换句话说。</p>
<p class="formulaDsp">
\[ \text{minimize}\| \boldsymbol{\sigma} (\mathbf{u}) \|_\infty \]
</p>
<p class="formulaDsp">
\[ \text{subject to } |E|\leq V_{\max}, \]
</p>
<p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0}. \]
</p>
<p>这里， \(\boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon}(\mathbf{u})\) 是由外力 \(\mathbf F\) 引起的体内应力，为了简单起见，我们假设材料是线性弹性的，因此 \(\mathbf{C}\) 是应力-应变张量， \(\boldsymbol{\varepsilon}(\mathbf{u})=\frac{1}{2} (\nabla \mathbf{u} + (\nabla\mathbf{u})^T)\) 是作为位移 \(\mathbf{u}\) 函数的小变形应变&ndash;关于线性弹性的详情，见步骤8 和步骤17。在上面的表述中， \(V_\text{max}\) 是我们愿意为构建物体提供的最大材料量。最后一个约束条件是与应力 \(\boldsymbol{\sigma}\) 和力 \(\mathbf F\) 有关的偏微分方程，它只是稳态力平衡。</p>
<p>也就是说，上面的无穷大准则产生了一个问题：作为材料位置的函数，这个目标函数必然是不可微分的，使优化的前景相当暗淡。因此，取而代之的是，拓扑优化的一个常见方法是通过优化一个相关的问题来找到一个近似的解决方案：我们希望最小化应变能量。这是对物体因变形而储存的势能的衡量，同时也是对结构总变形的衡量。</p>
<p class="formulaDsp">
\[ \text{minimize } \int_E \frac{1}{2}\boldsymbol{\sigma} : \boldsymbol{\varepsilon} dV \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \|E\| \leq V_{\max} \]
</p>
<p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} \]
</p>
<p>目标函数的值是用有限元方法计算的，其中的解决方案是位移。这被放置在一个非线性求解器的循环中，求解一个表示材料放置的向量。</p>
<p><a class="anchor" id="SolidIsotropicMaterialwithPenalization"></a></p><h3>Solid Isotropic Material with Penalization</h3>
<p>在实际操作中，我们只能建造材料在任何给定的点上要么存在，要么不存在的物体&ndash;也就是说，我们会有一个描述材料填充区域的指标函数 \(\rho_E(\mathbf{x})\in \{0,1\}\) ，并且我们想通过优化问题找到这个指标。在这种情况下，优化问题变成了组合性的，而且解决起来非常昂贵。取而代之的是，我们使用一种叫做各向同性的固体材料与惩罚的方法，或SIMP。 <b>[Bendse2004]</b></p>
<p>SIMP方法是基于一个想法，即允许材料存在于密度 \(\rho\) 在0和1之间的位置。密度为0表明材料不存在，它不是结构的一部分，而密度为1表明材料存在。0和1之间的值并不反映我们在现实世界中可以创造的设计，但允许我们将组合问题变成一个连续问题。然后我们看一下密度值 \(\rho\) ，约束条件是 \(0 &lt; \rho_{\min} \leq \rho \leq 1\) 。最小值 \(\rho_{\min}\) ，通常选择在 \(10^{-3}\) 左右，避免了出现无限应变能量的可能性，但小到足以提供准确的结果。</p>
<p>这种 "密度 "对介质弹性的影响的直接应用是简单地将介质的刚度张量 \(\mathbf{C}_0\) 乘以给定的密度，即 \(\mathbf{C} = \rho \mathbf{C}_0\) 。然而，这种方法经常给出密度值离0和1都很远的最佳解决方案。由于人们希望找到一个现实世界的解决方案，即材料要么存在，要么不存在，因此对这些介于两者之间的值进行惩罚。一个简单有效的方法是将刚度张量乘以密度，并将其提高到某个整数功率的惩罚参数 \(p\) ，因此 \(\mathbf{C} = \rho^p \mathbf{C}_0\) 。这使得远离0或1的密度值变得不那么有效。已经证明，使用 \(p=3\) 足够高，可以产生'黑白'的解决方案：也就是说，可以得到最佳的解决方案，其中材料在所有点上要么存在，要么不存在。</p>
<p>更多的材料应该总是提供一个具有较低应变能量的结构，因此不等式约束可以被看作是一个等式，其中使用的总体积是最大体积。</p>
<p>使用这种密度思想也使我们能够重新构建优化问题的体积约束。使用SIMP后，优化问题就变成了以下内容。</p>
<p class="formulaDsp">
\[ \text{minimize } \int_\Omega \frac{1}{2}\boldsymbol{\sigma}(\rho) : \boldsymbol{\varepsilon}(\rho) d\Omega \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \int_\Omega \rho(x) d\Omega= V_{\max}, \]
</p>
<p class="formulaDsp">
\[ 0&lt;\rho_{\min}\leq \rho(x) \leq 1, \]
</p>
<p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma}(\rho) + \mathbf{F} = 0 \quad \text{on } \Omega \]
</p>
<p>最后一个约束，即线性动量的平衡（我们将称之为弹性方程），给出了一种在给定密度 \(\boldsymbol{\sigma}\) 和 \(\boldsymbol{\varepsilon}\) 的情况下寻找 \(\rho\) 的方法。</p>
<p><a class="anchor" id="ElasticityEquation"></a></p><h3>Elasticity Equation</h3>
<p>在与时间无关的极限中，弹性方程为</p>
<p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} . \]
</p>
<p>在我们将关注的情况下，我们将假设介质具有线性材料响应，在这种情况下，我们有</p>
<p class="formulaDsp">
\[ \boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon} = \rho^p \mathbf{C}_0 : \boldsymbol{\varepsilon}(\mathbf{u}) = \rho^p \mathbf{C}_0 : \left[\frac{1}{2} (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) \right] . \]
</p>
<p>在我们下面要做的一切中，我们将始终把位移场 \(\mathbf{u}\) 视为唯一的解变量，而不是把 \(\mathbf{u}\) 和 \(\boldsymbol{\sigma}\) 视为解变量（像在混合公式中那样）。</p>
<p>此外，我们将假设材料是线性各向同性的，在这种情况下，应力-应变张量可以用Lam&eacute;参数 \(\lambda,\mu\) 来表示，例如</p>
<p class="formulaDsp">
\begin{align} \boldsymbol{\sigma} &amp;= \rho^p (\lambda \text{tr}(\boldsymbol{\varepsilon}) \mathbf{I} + 2 \mu \boldsymbol{\varepsilon}) , \\ \sigma_{i,j} &amp;= \rho^p (\lambda \varepsilon_{k,k} \delta_{i,j} + 2 \mu \varepsilon_{i,j}) . \end{align}
</p>
<p>参见步骤8，了解这种转变的原理。</p>
<p>对目标函数进行分项积分，得到</p>
<p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u}))^T d\Omega+ \int_\Omega (\nabla \cdot \boldsymbol{\sigma}(\rho)) \cdot \mathbf{u} d\Omega= \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega , \]
</p>
<p>然后将线性弹性方程代入其中，可以得到</p>
<p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_\Omega \mathbf{F}\cdot \mathbf{u} d\Omega+ \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega . \]
</p>
<p>因为我们假设没有身体的力量，这进一步简化为</p>
<p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega, \]
</p>
<p>这就是我们从现在开始要考虑的治理方程的最终形式。</p>
<p><a class="anchor" id="Makingthesolutionmeshindependent"></a></p><h3>Making the solution mesh-independent</h3>
<p>通常情况下，拓扑优化问题的解决方案是依赖于网格的，因此问题是不成立的。这是因为随着网格的进一步细化，往往会形成分形结构。随着网格分辨率的提高，最优解通常会获得越来越小的结构。对于这个问题，有一些相互竞争的解决方法，但对于一阶优化来说，最流行的是灵敏度滤波器，而二阶优化方法则倾向于使用密度滤波器。</p>
<p>由于滤波器会影响应变能量的梯度和Hessian（即目标函数），所以滤波器的选择会对问题的解决产生影响。作为二阶方法的一部分，密度滤波器的工作原理是引入一个未经过滤的密度，我们称之为 \(\varrho\) ，然后要求密度是未经过滤的密度的卷积。</p>
<p class="formulaDsp">
\[ \rho = H(\varrho). \]
</p>
<p>这里， \(H\) 是一个运算符，因此 \(\rho(\mathbf{x})\) 是 \(\varrho\) 在 \(\mathbf{x}\) 周围区域的某种平均值 &ndash; 即，它是 \(\varrho\) 的平滑版本。</p>
<p>这可以防止棋盘效应；滤波器的半径允许用户为我们寻求的最佳结构定义一个有效的最小光束宽度。</p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.checkerboard.png" alt="Checkerboarding occurring in an MBB Beam"/>
</div>
 </div><p><a class="anchor" id="CompleteProblemFormulation"></a></p><h3>Complete Problem Formulation</h3>
<p>现在的最小化问题是</p>
<p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho d\Omega= V \]
</p>
<p class="formulaDsp">
\[ 0\leq \varrho \leq 1 \]
</p>
<p>处理不等式约束的方法是，首先引入松弛变量，其次使用对数障碍来确保我们得到一个内点方法。惩罚参数将是 \(\alpha\) ，下面的松弛变量是</p><ol>
<li>
\(s_1\) -对应于下限的松弛变量  </li>
<li>
\(s_2\) -对应于上限的松弛变量。  </li>
</ol>
<p>现在得出以下问题。</p>
<p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}, s_1, s_2} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho d\Omega = V \]
</p>
<p class="formulaDsp">
\[ \varrho = s_1 \]
</p>
<p class="formulaDsp">
\[ 1-\varrho = s_2 \]
</p>
<p>有了这些变量，我们就可以按照通常的方法来解决限制性优化问题。我们引入一个拉格朗日，通过将约束条件乘以拉格朗日乘数，将目标函数和约束条件结合起来。具体来说，我们将使用以下符号表示各种约束条件的拉格朗日乘数。</p><ol>
<li>
\(\mathbf{y}_1 \) ：对应于弹性约束的拉格朗日乘数，  </li>
<li>
\(y_2\) ：对应于卷积过滤器约束的拉格朗日乘数，  </li>
<li>
\(z_1\) ：对应于下层松弛变量的拉格朗日乘数，以及  </li>
<li>
\(z_2\) ：对应于上限松弛变量的拉格朗日乘数。  </li>
</ol>
<p>有了这些变量，拉格朗日函数的内容如下。</p>
<p class="formulaDsp">
\begin{align} \mathcal{L} =&amp; \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega - \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega- \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{y}_1):\boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_1 \right)\right) d\Omega - \int_{\partial \Omega} \mathbf{y}_1 \cdot \mathbf{t} d\partial\Omega \\ &amp; -\int_\Omega y_2 (\rho - H(\varrho)) d\Omega - \int_\Omega z_1 (\varrho-s_1) d\Omega - \int_\Omega z_2 (1 - s_2 -\varrho) d\Omega \end{align}
</p>
<p>然后优化问题的解决方案需要满足所谓的[Karush-Kuhn-Tucker（KKT）条件]（https://en.wikipedia.org/wiki/KarushE2%80%93KuhnE2%80%93Tucker_conditions）。拉格朗日相对于其所有参数的导数需要等于零，而且由于我们有不等式约束，我们也有 "互补性 "条件。由于我们这里有一个无穷大的问题，这些条件都涉及到拉格朗日相对于某些测试函数的方向性导数&ndash;换句话说，所有这些条件都必须以弱形式表述，因为这通常是有限元方法的基础。</p>
<p>障碍法允许我们最初削弱典型的KKT条件所要求的 "补充松弛"。通常情况下，我们会要求 \(s_i z_i = 0\) ，但屏障公式给出的KKT条件是 \(s_i z_i = \alpha\) ，其中 \(\alpha\) 是我们的屏障参数。作为障碍法的一部分，这个参数必须被驱动到接近0，以便对原始问题有一个良好的近似。</p>
<p>在下文中，让我们陈述所有这些条件，其中 \(d_{\{\bullet\}}\) 是一个测试函数，它与拉格朗日相对于 \(\{\bullet\}\) 函数的变异导数自然成对。为了简单起见，我们引入 \(\Gamma\) 来表示边界上受力的部分，并使用诺伊曼边界条件。</p>
<ol>
<li>
<p class="startli">静止性。</p>
<p class="formulaDsp">
\[ \int_\Omega - d_\rho y_2 + p\rho^{p-1}d_\rho \left[\lambda (\nabla \cdot \mathbf{y}_1) (\nabla \cdot \mathbf{u}) + \mu \boldsymbol{\varepsilon}(\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall d_\rho \]
</p>
<p class="formulaDsp">
\[ \int_\Gamma \mathbf d_\mathbf{u} \cdot \mathbf{t} d\partial\Omega+ \int_\Omega p\rho^{p} \left[\lambda (\nabla \cdot \mathbf d_\mathbf{u})( \nabla \cdot \mathbf{y}_1) + \mu \boldsymbol{\varepsilon}(\mathbf d_\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall \mathbf{d}_\mathbf{u} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega= 0\;\;\forall d_\varrho \]
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">原始的可行性。</p>
<p class="formulaDsp">
\[ \int_\Omega \rho^{p}\lambda (\nabla \cdot \mathbf d_{\mathbf{y}_1}) (\nabla \cdot \mathbf{u}) + \rho^{p}\mu \boldsymbol{\varepsilon}(\mathbf d_{\mathbf{y}_1}) : \boldsymbol{\varepsilon}(\mathbf{u}) d\Omega - \int_\Gamma \mathbf d_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega =0 \;\;\forall \mathbf{d}_{\mathbf{y}_1} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{z_1}(\varrho - s_1) d\Omega = 0\;\;\forall d_{z_1} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{z_z}(1-\varrho-s_2) d\Omega = 0\;\;\forall d_{z_2} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{y_2}(\rho - H(\varrho)) d\Omega = 0\;\;\forall d_{y_2} \]
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">互补性松弛。</p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_1}(s_1z_1 - \alpha) d\Omega = 0 \;\;\forall d_{s_1} ,\;\;\; \alpha \to 0 \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_2}(s_2z_2 - \alpha) d\Omega = 0 \;\;\forall d_{s_2} ,\;\;\; \alpha \to 0 \]
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">双重可行性。</p>
<p class="formulaDsp">
\[ s_{1,i},s_{2,i},z_{1,i},z_{2,i} \geq 0 \;\;\;\; \forall i \]
</p>
<p class="endli"></p>
</li>
</ol>
<p>。</p>
<p><a class="anchor" id="Solutionprocedure"></a></p><h3>Solution procedure</h3>
<p>上面的优化条件除了复杂之外，还属于不容易解决的类型。它们通常是非线性的，而且有些关系也是不等式的。我们将使用牛顿方法计算搜索方向来解决非线性问题，并在下面讨论步长程序时再来讨论如何处理不等式问题。</p>
<p>牛顿方法应用于上述方程的结果是下面列出的方程组。其中，关于 \(\{\bullet\}\) 变量的变异导数在 \(c_{\{\bullet\}}\) 方向取值。</p>
<ol>
<li>
<p class="startli">静止性。这些方程确保我们在受约束时处于目标函数的临界点。</p>
<p>方程式1</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega-d_\rho c_{y_2} + p(p-1) \rho^{p-2} d_\rho c_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] + p \rho^{p-1} d_\rho[\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] + p \rho^{p-1} d_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \\ &amp;= -\int_\Omega -d_\rho z_1 + d_\rho z_2 - d_\rho y_2 + p\rho^{p-1}d_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>方程式2</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y})] + \rho^{p} [\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Gamma \mathbf{d}_\mathbf{u} \cdot \mathbf{t} -\int_\Omega \rho^{p} [\lambda \nabla \cdot \mathbf{y} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(d_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>方程3</p>
<p class="formulaDsp">
\[ \int_\Omega - d_\varrho c_{z_1} +d_\varrho c_{z_2} + H(d_\varrho)c_{y_2} d\Omega = -\int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega \]
</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">原始可行性。这些方程保证了平等约束的满足。</p>
<p>方程4</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_p[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] + \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Omega \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon} (\mathbf{d}_{\mathbf{y}_1})] + \int_\Gamma \mathbf{d}_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega \end{align}
</p>
<p>方程5</p>
<p class="formulaDsp">
\[ -\int_\Omega d_{z_1}(c_\varrho - c_{s_1}) d\Omega=\int_\Omega d_{z_1} (\varrho - s_1) d\Omega \]
</p>
<p>方程6</p>
<p class="formulaDsp">
\[ -\int_\Omega d_{z_2}(-c_\varrho-c_{s_2}) d\Omega= \int_\Omega d_{z_2} (1-\varrho-s_2) d\Omega \]
</p>
<p>方程7</p>
<p class="formulaDsp">
\[ -\int_\Omega d_{y_2}(c_\rho - H(c_\varrho)) d\Omega=\int_\Omega d_{y_2} (\rho - H(\varrho)) d\Omega \]
</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">互补松弛性。这些方程基本上确保了障碍的满足&ndash;在最终的解决方案中，我们需要 \(s^T z = 0\) 。</p>
<p>方程8</p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_1}(c_{s_1}z_1/s_1 + c_{z_1} ) d\Omega=-\int_\Omega d_{s_1} (z_1 - \alpha/s_1) d\Omega ,\;\;\; \alpha \to 0 \]
</p>
<p>方程9</p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_2} (c_{s_2}z_2/s_2 + c_{z_2} ) d\Omega=-\int_\Omega d_{s_2} (z_2 - \alpha/s_2) d\Omega,\;\;\; \alpha \to 0 \]
</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">双重可行性。松弛和松弛变量的拉格朗日乘数必须保持大于0。（这是唯一没有在 <code>SANDTopOpt::assemble_system()</code> 函数中实现的部分）。</p>
<p class="formulaDsp">
\[ s,z \geq 0 \]
</p>
<p class="endli"></p>
</li>
</ol>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p>我们使用带有 \(Q_1\) 元素的四边形网格来离散位移和位移Lagrange乘数。分片常数 \(DGQ_0\) 元素被用来离散密度、未过滤密度、密度松弛变量以及松弛变量和过滤约束的乘数。</p>
<p><a class="anchor" id="NonlinearAlgorithm"></a></p><h3>Nonlinear Algorithm</h3>
<p>虽然上面的大部分讨论都是按照传统的和众所周知的方法来解决非线性优化问题，但事实证明，这个问题在实践中其实是相当难解决的。特别是，它是相当非线性的，一个重要的问题不仅仅是像上面讨论的基于牛顿方法的搜索方向 \(c_{\{\bullet\}}\) ，而是人们需要花相当多的注意力在这个方向上要走多远。这通常被称为 "线搜索"，归结为如何选择步长 \(\alpha_k \in (0,1]\) 的问题，以便我们以尽可能有效的方式从当前迭代 \(\mathbf{x}_k\) 移动到下一个迭代 \(\mathbf{x}_{k+1}=\mathbf{x}_k+\alpha_k \mathbf{x}_k\) 。众所周知，我们最终需要选择 \(\alpha_k=1\) 来实现牛顿方法的二次收敛；然而，在早期迭代中，采取如此长的步长实际上可能会使事情变得更糟，要么导致一个目标函数更差的点，要么在这个点上的约束条件的满足程度不如在 \(\mathbf{x}_k\) 时。</p>
<p>已经提出了非常复杂的算法来处理这个问题 <b>[Nocedal2009]</b> <b>[Waechter2005]</b> 。在这里，我们实现了一个看门狗搜索算法 <b>[Nocedal2006]</b> 。在讨论这个算法时，我们将使用向量 \(\mathbf{x}\) 来表示所有的原始变量&ndash;过滤和未过滤的密度、松弛变量和位移，并使用向量 \(\mathbf{y}\) 来表示所有的对偶向量。上述非线性方程组的（增量）解决方案现在将被称为 \(\Delta \mathbf{x}\) 和 \(\Delta \mathbf{y}\) ，而不是 \(c_{\{\bullet\}}\) 。一个优点函数（后面有详细解释）在这里被称为 \(\phi(\mathbf{x,\mathbf{y}})\) 。</p>
<p>应用于具有给定障碍参数的子问题的看门狗算法以如下方式工作。首先，当前迭代被保存为 "看门狗 "状态，并记录看门狗状态的优点。然后采取一个最大的可行的牛顿步骤。如果功绩比第一步充分减少，则接受这个新步骤。如果不是，则采取另一个最大可行的牛顿步骤，并再次将功绩与看门狗的功绩进行比较。如果经过一定数量（通常在5到8之间）的牛顿步骤后，功绩没有充分减少，算法从看门狗状态或最后一次迭代中选择一个缩放的牛顿步骤，以保证功绩充分减少，该步骤被接受。一旦一个步骤被接受，就会测量KKT误差的规范，如果它足够小，就会减少障碍值。如果不够小，则将最后接受的步骤作为新的看门狗步骤，并重复这一过程。</p>
<p>以上，"最大可行步长 "是对牛顿步长在原始变量和对偶变量中的一个缩放，其公式为</p>
<p class="formulaDsp">
\[ \beta^\mathbf{y} = \min\{1,\max \beta \text{ such that }\left(\mathbf{z}_{k+i} + \beta^\mathbf{z}_{k+i} \Delta \mathbf{z}_{k+i}\right)_j \geq \zeta \mathbf{z}_{k+i,j} \forall j\} \]
</p>
<p class="formulaDsp">
\[ \beta^\mathbf{x} = \min\{1,\max \beta \text{ such that }\left(\mathbf{s}_{k+i} + \beta^\mathbf{s}_{k+i} \Delta \mathbf{s}_{k+i}\right)_j \geq \zeta \mathbf{s}_{k+i,j} \forall j\} \]
</p>
<p>以上， \(\zeta\) 是任何步骤上允许的 "到边界的分数"。由于导数在边界附近变得条件不良，这种技术代表了<a href="https://en.wikipedia.org/wiki/Trust_region">信任区域</a>，对于确保未来的良好近似是必要的。 \(\zeta\) 被认为是 \(\max\{0.8, 1-\alpha\}\) ，这允许随着障碍物变小而向边界靠近。未来，在实施减少障碍物的LOQO算法时，必须将其保持在0.8，因为障碍物参数可能变化很大。</p>
<p>另外，我们需要处理我们用来强制执行松弛变量的正性约束的对数障碍 \(s_1,s_2\) ：在我们解决的最终优化问题的声明中，我们添加了术语</p>
<p class="formulaDsp">
\[ -\alpha \int_\Omega (\log(s_1) + \log(s_2)) d\Omega. \]
</p>
<p>问题是我们应该如何选择惩罚因子 \(\alpha\) 。与所有的惩罚方法一样，我们实际上只对极限 \(\alpha\to 0\) 感兴趣，因为这才是我们真正想要解决的问题，受松弛变量的正性约束。另一方面，我们需要选择足够大的 \(\alpha\) 来使问题在实践中可以解决。因此，实际的实现从较大的 \(\alpha\) 值开始，并随着外迭代的进行而逐渐减小它。</p>
<p>在这里实现的单调方法中，每当在当前的障碍参数下达到某种程度的收敛时，就会更新障碍参数。我们使用KKT条件的 \(l_\infty\) 准则来检查每个障碍大小的收敛情况。要求是 \(\|KKT\|_{l_\infty} &lt; c \cdot \alpha\) ，其中 \(c\) 是任何障碍大小的常数， \(\alpha\) 是障碍参数。这迫使在以后的迭代中更好地收敛，这与<a href="https://coin-or.github.io/Ipopt/">IPOPT</a>（一个用于大规模非线性优化的开源软件包）中的要求相同。</p>
<p>在这里，障碍值在较大的数值下是线性减少的，在较小的数值下是超线性的。在较大的数值下，它被乘以一个常数（大约0.6），而在较低的数值下，障碍值被提高到某个指数（大约1.2）的障碍值所取代。事实证明，这种方法能够有效地保持大障碍值下子问题的可解性，同时在较小的障碍值下仍然允许超线性收敛。在实践中，这看起来像以下情况。</p>
<p class="formulaDsp">
\[ \alpha_{k+1} = \min\{\alpha_k^{1.2},0.6\alpha_k\} \]
</p>
<p>虽然在达到收敛时大步减少障碍物的大小被广泛使用，但最近的研究表明，通常使用每次迭代自适应更新障碍物的算法会更快，也就是说，我们在每次迭代结束时使用具体的标准来决定下一次迭代中的惩罚参数应该是什么，而不是使用独立于当前解决方案的减少因素。也就是说，这样的方法也比较复杂，我们在此不做介绍。</p>
<p><a class="anchor" id="MeritFunction"></a></p><h3>Merit Function</h3>
<p>上面概述的算法利用了 "优点函数"。功绩函数用于确定从 \(x_k\) 到建议点 \(x_{k+1}\) 的一步是否有利。在无约束的优化问题中，人们可以简单地用我们试图最小化的目标函数来检查，通常使用[沃尔夫和戈尔茨坦条件]（https://en.wikipedia.org/wiki/Wolfe_conditions）等条件。</p>
<p>在有约束的优化问题中，问题是如何平衡目标函数的减少和可能增加的对约束的违反。一个建议的步骤可能会使目标函数变小，但离满足约束条件的点集更远，或者相反。这种权衡通常通过使用结合这两个标准的优点函数来解决。</p>
<p>在这里，我们使用一个精确的 \(l_1\) 功绩函数来测试步骤。</p>
<p class="formulaDsp">
\begin{align} \phi(\mathbf{x},\mathbf{y}) =&amp; \int_{\partial \Omega} \mathbf{u}\cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega (\log(s_1) + \log(s_2)) + p \sum_i\left| \int_\Omega y_{2,i}(H(\varrho) - \rho) d\Omega \right| \\ &amp; + p \sum_i\left| \int_{\partial \Omega} \mathbf{y}_{1,i}\cdot \mathbf{t} d\partial\Omega - \int_\Omega \rho^p[\lambda \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_{1,i} + \mu \boldsymbol{\varepsilon}{\mathbf{u}}\boldsymbol{\varepsilon}{\mathbf{y}_{1,i}}] d\Omega \right| + p \sum_i\left| \int_\Omega z_{1,i}(s_1 - \varrho) d\Omega\right| + p \sum_i\left| \int_\Omega z_{2,i}(1-\varrho - s_2) d\Omega\right| \end{align}
</p>
<p>这里， \(p\) 是一个惩罚参数。这个优点函数是精确的，意味着存在一些 \(p_0\) ，以便对于任何 \(p &gt; p_0\) ，优点函数的最小值与原始问题的位置相同。这个惩罚参数被更新（根据Nocedal和Wright <b>[Benson2002]</b> 的建议），如下。</p>
<p class="formulaDsp">
\[ p &gt; \frac{\frac{1}{2} \mathbf{x}^T \cdot \mathbf{H} \cdot \mathbf{x} - \mathbf{x}^T \cdot \nabla f}{\|c_i\|_{l_\infty}} \quad , i \in \mathcal{E}, \]
</p>
<p>其中 \(\mathbf{H}\) 是目标函数的Hessian， \(\mathbf{x}\) 是我们的决策（原始）变量的矢量， \(f\) 是目标函数， \(c_i\) 是当前平等约束的误差。</p>
<p>我们使用这种方法的部分原因是在寻找右手边时已经计算了大部分必要的部分，而且使用精确的优点函数可以确保它在与整个问题相同的位置被最小化。最近的研究表明，人们可以用所谓的 "滤波方法 "代替优点函数，人们应该考虑使用这些方法，因为它们被证明是更有效的。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Preliminaries"></a> </p><h3>Preliminaries</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div></div><!-- fragment --><p>Above are fairly common files to include. These also include the one for the sparse direct class <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>. This is not the most efficient way to solve large linear problems, but it will do for now.</p>
<p>As usual, we put everything into a common namespace. We then start by declaring a number of symbolic names for constants that will be used throughout this tutorial. Specifically, we have a <em>lot</em> of variables in this program (of course the density and the displacement, but also the unfiltered density and quite a number of Lagrange multipliers). It is easy to forget which of these variables is at which position in the solution vector, and trying to use numbers for these vector components is a prescription for bugs. Rather, we define static variables that can be used in all of these places and that have to be initialized only once. In practice, this will lead to some lengthy expressions, but they are more readable and less likely to be wrong.</p>
<p>A similar issue arises with the ordering of blocks in the system matrix and in vectors. The matrices have \(9\times 9\) blocks, and it's difficult to remember which is which. It is far easier to just use symbolic names for those as well.</p>
<p>Finally, while we're at it, we introduce symbolic names also for the boundary indicators we will use, in the same spirit as was done in <a class="el" href="step_19.html">step-19</a>.</p>
<p>In all of these cases, we declare these variables as members in a namespace. In the case of the solution components, the concrete values of these variables depend on the space dimension, so we use <a href="https://en.cppreference.com/w/cpp/language/variable_template">template variables</a> to make the value of the variable depend on a template argument in the same way as we often use template functions.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>This namespace keeps track of the first component in our finite element system that corresponds to each variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionComponents</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">} <span class="comment">// namespace SolutionComponents</span></div></div><!-- fragment --><p>This is the namespace which keeps track of which block corresponds to which variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionBlocks</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">} <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>BoundaryIds</div><div class="line">{</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">} <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ValueExtractors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">    displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">    SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">    SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">    SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">    SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">} <span class="comment">// namespace ValueExtractors</span></div></div><!-- fragment --><p><a class="anchor" id="TheSANDTopOptmainclass"></a> </p><h3>The SANDTopOpt main class</h3>
<p>Next up is the main class for this problem. The majority of functions follow the usual naming schemes of tutorial programs, though there are a couple that have been broken out of what is usually called the <code>setup_system()</code> function because of their length, and there are also a number that deal with various aspects of the optimization algorithm.</p>
<p>As an added bonus, the program writes the computed design as an STL file that one can, for example, send to a 3d printer.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SANDTopOpt</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SANDTopOpt();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Most of the member variables are also standard. There are, however, a number of variables that are specifically related to the optimization algorithm (such the various scalar factors below) as well as the filter matrix to ensure that the design remains smooth.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">  <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">  <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h3>Constructor and set-up functions</h3>
<p>We initialize a <a class="el" href="classFESystem.html">FESystem</a> composed of 2 \(\times\)dim <code><a class="el" href="classFE__Q.html">FE_Q(1)</a></code> elements for the displacement variable and its Lagrange multiplier, and 7 <code><a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a></code> elements. These piecewise constant functions are for density-related variables: the density itself, the unfiltered density, the slack variables for the lower and upper bounds on the unfiltered density, and then Lagrange multipliers for the connection between filtered and unfiltered densities as well as for the inequality constraints.</p>
<p>The order in which these elements appear is documented above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       5)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , density_ratio(.5)</div><div class="line">  , density_penalty_exponent(3)</div><div class="line">  , filter_r(.251)</div><div class="line">  , penalty_multiplier(1)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p>The first step then is to create the triangulation that matches the problem description in the introduction &ndash; a 6-by-1 rectangle (or a 6-by-1-by-1 box in 3d) where a force will be applied in the top center. This triangulation is then uniformly refined a number of times.</p>
<p>In contrast to nearly the entire rest of this program, this function specifically assumes that we are in 2d and will require changes if we wanted to move to 3d simulations. We ensure that nobody tries to accidentally run in 3d without such modifications through an assertion at the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            {6, 1},</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">  triangulation.refine_global(3);</div></div><!-- fragment --><p>The second step is to apply boundary indicators to parts of the boundary. The following code assigns boundary indicators to the bottom, top, left, and right boundaries of the box, respectively. The center region of the top boundary is given a separate boundary indicator: This is where we will apply the down force.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the constraints due to boundary values. The bottom corners of the domain are kept in place in the \(y\) direction &ndash; the bottom left also in the \(x\) direction. deal.II generally thinks of boundary values as attached to pieces of the boundary, i.e., faces, rather than individual vertices. Indeed, mathematically speaking, one can not assign boundary values to individual points for the infinite-dimensional partial differential equation. But, since we are trying to reproduce a widely used benchmark, we will do so anyway and keep in mind that we have a finite-dimensional problem for which imposing boundary conditions at a single node is valid.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">{</div><div class="line">  boundary_values.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div></div><!-- fragment --><p>Check whether the current face is on the bottom boundary, and if it is whether one of its vertices might be the bottom left or bottom right vertex:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[x_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line"></div><div class="line">                      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                               <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Settingupblockmatricesandvectors"></a> </p><h3>Setting up block matrices and vectors</h3>
<p>The next function makes a giant 9-by-9 block matrix, and also sets up the necessary block vectors. The sparsity pattern for this matrix includes the sparsity pattern for the filter matrix. It also initializes any block vectors we will use.</p>
<p>Setting up the blocks by themselves is not overly complicated and follows what is already done in programs such as <a class="el" href="step_22.html">step-22</a>, for example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">  block_component[0] = 0;</div><div class="line">  block_component[1] = 1;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">    n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">      dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">  dsp.collect_sizes();</div></div><!-- fragment --><p>The bulk of the function is in setting up which of these blocks will actually contain anything, i.e., which variables couple with which other variables. This is cumbersome but necessary to ensure that we don't just allocate a very large number of entries for our matrix that will then end up being zero.</p>
<p>The concrete pattern you see below is something one probably has to draw once on a piece of paper, but follows in an otherwise relatively straightforward way from looking through the many terms of the bilinear form we will have to assemble in each nonlinear iteration.</p>
<p>The use of the symbolic names defined in namespace <code>SolutionComponents</code> helps understand what each of the following terms corresponds to, but it also makes the expressions lengthy and unwieldy: A term such as <code>coupling[SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;][SolutionComponents::density&lt;dim&gt;]</code> just doesn't read very well, and would either have to be split over several lines or run off the right edge of nearly every screen. As a consequence, we open a curly-brace enclosed code block in which we temporarily make the names in namespace <code>SolutionComponents</code> available without the namespace qualifier, by saying <code>using namespace SolutionComponents</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">        {</div><div class="line">          coupling[displacement&lt;dim&gt; + i]</div><div class="line">                  [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                  [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">/* Coupling for slack variables */</span></div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">}</div></div><!-- fragment --><p>Before we can create the sparsity pattern, we also have to set up constraints. Since this program does not adaptively refine the mesh, the only constraint we have is one that couples all density variables to enforce the volume constraint. This will ultimately lead to a dense sub-block of the matrix, but there is little we can do about that.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">  fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line"><a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">  density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">constraints.clear();</div><div class="line">constraints.add_line(last_density_dof);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">  constraints.add_entry(last_density_dof,</div><div class="line">                        density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                        -1);</div><div class="line">constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">constraints.close();</div></div><!-- fragment --><p>We can now finally create the sparsity pattern for the matrix, taking into account which variables couple with which other variables, and the constraints we have on the density.</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div></div><!-- fragment --><p>The only part of the matrix we have not dealt with is the filter matrix and its transpose. These are non-local (integral) operators for which deal.II does not currently have functions. What we will ultimately need to do is go over all cells and couple the unfiltered density on this cell to all filtered densities of neighboring cells that are less than a threshold distance away, and the other way around; for the moment, we are only concerned with building the sparsity pattern that would correspond to this kind of matrix, so we perform the equivalent loop and where later on we would write into an entry of the matrix, we now simply add an entry to the sparsity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Having so generated the "dynamic" sparsity pattern, we can finally copy it to the structure that is used to associate matrices with a sparsity pattern. Because the sparsity pattern is large and complex, we also output it into a file of its own for visualization purposes &ndash; in other words, for "visual debugging".</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>What is left is to correctly size the various vectors and their blocks, as well as setting initial guesses for some of the components of the (nonlinear) solution vector. We here use the symbolic component names for individual blocks of the solution vector and, for brevity, use the same trick with <code>using namespace</code> as above:</p>
<div class="fragment"><div class="line">  nonlinear_solution.reinit(block_sizes);</div><div class="line">  system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">    nonlinear_solution.block(density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">      .add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">    nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">    nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefiltermatrix"></a> </p><h3>Creating the filter matrix</h3>
<p>Next up, a function that is used once at the beginning of the program: It creates a matrix \(H\) so that the filtered density vector equals \(H\) times the unfiltered density. The creation of this matrix is non-trivial, and it is used in every iteration, and so rather than reforming it as we do with the Newton matrix, it is made only once and stored separately.</p>
<p>The way this matrix is computed follows the outline used above already to form its sparsity pattern. We repeat this process here for the sparsity pattern of this separately formed matrix, and then actually build the matrix itself. You may want to check the definition of this matrix in the introduction to this program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">{</div></div><!-- fragment --><p>The sparsity pattern of the filter has already been determined and implemented in the setup_system() function. We copy the structure from the appropriate block and use it again here.</p>
<div class="fragment"><div class="line">filter_sparsity_pattern.copy_from(</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">filter_matrix.reinit(filter_sparsity_pattern);</div></div><!-- fragment --><p>Having so built the sparsity pattern, now we re-do all of these loops to actually compute the necessary values of the matrix entries:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            filter_matrix.add(i,</div><div class="line">                              check_cell-&gt;active_cell_index(),</div><div class="line">                              filter_r - distance);</div><div class="line">            </div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The final step is to normalize the matrix so that for each row, the sum of entries equals one.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> denominator = 0;</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        denominator = denominator + iter-&gt;value();</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function is used for building the filter matrix. We create a set of all the cell iterators within a certain radius of the cell that is input. These are the neighboring cells that will be relevant for the filter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">  neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">  cells_to_check.insert(cell);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">           std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">             cells_to_check.begin(), cells_to_check.end()))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                    cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                  <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                      !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                    {</div><div class="line">                      cells_to_check.insert(neighbor);</div><div class="line">                      neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                      new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">  <span class="keywordflow">return</span> cells_to_check;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingtheNewtonmatrix"></a> </p><h3>Assembling the Newton matrix</h3>
<p>Whereas the setup_filter_matrix function built a matrix that is the same as long as the mesh does not change (which we don't do anyway in this program), the next function builds the matrix to be solved in each iteration. This is where the magic happens. The components of the system of linear equations describing Newton's method for finding the solution of the KKT conditions are implemented here.</p>
<p>The top of the function is as in most of these functions and just sets up all sorts of variables necessary for the actual assembly, including a whole bunch of extractors. The entire set up should look familiar, though somewhat lengthier, if you've previously looked at <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div></div><!-- fragment --><p>At this point, we apply the filter to the unfiltered density, and apply the adjoint (transpose) operation to the unfiltered density multiplier, both to the current best guess for the nonlinear solution. We use this later to tell us how far off our filtered density is from the filter applied to the unfiltered density. That is because while at the solution of the nonlinear problem, we have \(\rho=H\varrho\), but at intermediate iterations, we in general have \(\rho^k\neq H\varrho^k\) and the "residual" \(\rho^k-H\varrho^k\) will then appear as the right hand side of one of the Newton update equations that we compute below.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"></div><div class="line">filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                      SolutionBlocks::unfiltered_density),</div><div class="line">                    nonlinear_solution.block(</div><div class="line">                      SolutionBlocks::unfiltered_density));</div><div class="line">filter_matrix.Tvmult(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">  nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">  n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">  n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>ValueExtractors;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">    mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div></div><!-- fragment --><p>As part of the construction of our system matrix, we need to retrieve values from our current guess at the solution. The following lines of code retrieve the needed values.</p>
<div class="fragment"><div class="line">fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                              old_density_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_divs);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">  nonlinear_solution, old_displacement_symmgrads);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">  .get_function_symmetric_gradients(</div><div class="line">    nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_values);</div><div class="line">fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_values);</div><div class="line">fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filtered_unfiltered_density_solution,</div><div class="line">  filtered_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We need several more values corresponding to the test functions coming from the first derivatives taken from the Lagrangian, that is the \(d_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">      fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">      fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      displacement_multiplier_phi_i_symmgrad =</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">          i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                          q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">      fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                           q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div></div><!-- fragment --><p>Finally, we need values that come from the second round of derivatives taken from the Lagrangian, the \(c_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">  fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                   q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">  fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  displacement_multiplier_phi_j_symmgrad =</div><div class="line">    fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">      .symmetric_gradient(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">  fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">  fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">  fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">  fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">  fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div></div><!-- fragment --><p>This is where the actual work starts. In the following, we will build all of the terms of the matrix &ndash; they are numerous and not entirely self-explanatory, also depending on the previous solutions and its derivatives (which we have already evaluated above and put into the variables called <code>old_*</code>). To understand what each of these terms corresponds to, you will want to look at the explicit form of these terms in the introduction above.</p>
<p>The right hand sides of the equations being driven to 0 give all the KKT conditions for finding a local minimum &ndash; the descriptions of what each individual equation are given with the computations of the right hand side.</p>
<div class="fragment"><div class="line">          <span class="comment">/* Equation 1 */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  (density_penalty_exponent - 1) *</div><div class="line">                  std::pow(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 2) *</div><div class="line">                  density_phi_i * density_phi_j *</div><div class="line">                  (old_displacement_multiplier_divs[q_point] *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_multiplier_phi_j_div *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     old_displacement_multiplier_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                      displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 2 */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (density_penalty_exponent *</div><div class="line">               <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent - 1) *</div><div class="line">               density_phi_j *</div><div class="line">               (old_displacement_multiplier_divs[q_point] *</div><div class="line">                  displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                2 * mu_values[q_point] *</div><div class="line">                  (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                   displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">             + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent) *</div><div class="line">                 (displacement_multiplier_phi_j_div *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                     displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">            );</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">           * calculated elsewhere. */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (-1 * unfiltered_density_phi_i *</div><div class="line">               lower_slack_multiplier_phi_j +</div><div class="line">             unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">          <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              density_penalty_exponent *</div><div class="line">                <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent - 1) *</div><div class="line">                density_phi_j *</div><div class="line">                (old_displacement_divs[q_point] *</div><div class="line">                   displacement_multiplier_phi_i_div *</div><div class="line">                   lambda_values[q_point] +</div><div class="line">                 2 * mu_values[q_point] *</div><div class="line">                   (old_displacement_symmgrads[q_point] *</div><div class="line">                    displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">              + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent) *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     displacement_multiplier_phi_i_div *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (displacement_phi_j_symmgrad *</div><div class="line">                      displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            lower_slack_multiplier_phi_i *</div><div class="line">            (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            upper_slack_multiplier_phi_i *</div><div class="line">            (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">           * is added later */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               unfiltered_density_multiplier_phi_i *</div><div class="line">                               (density_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">             + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                 old_lower_slack_multiplier_values[q_point] /</div><div class="line">                 old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">             + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                 old_upper_slack_multiplier_values[q_point] /</div><div class="line">                 old_upper_slack_values[q_point]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have everything assembled, all we have to do is deal with the effect of (Dirichlet) boundary conditions and other constraints. We incorporate the former locally with just the contributions from the current cell, and then let the AffineConstraint class deal with the latter while copying contributions from the current cell into the global linear system:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                           local_dof_indices,</div><div class="line">                                           cell_matrix,</div><div class="line">                                           dummy_cell_rhs,</div><div class="line">                                           <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Having accumulated all of the terms that belong into the Newton matrix, we now also have to compute the terms for the right hand side (i.e., the negative residual). We already do this in another function, and so we call that here:</p>
<div class="fragment"><div class="line">system_rhs = calculate_test_rhs(nonlinear_solution);</div></div><!-- fragment --><p>Here we use the filter matrix we have already constructed. We only need to integrate this filter applied to test functions, which are piecewise constant, and so the integration becomes a simple multiplication by the measure of the cell. Iterating over the pre-made filter matrix allows us to use the information about which cells are in or out of the filter without repeatedly checking neighbor cells again.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">             filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           ++iter)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                   SolutionBlocks::unfiltered_density)</div><div class="line">            .add(i, j, value);</div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density,</div><div class="line">                   SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">            .add(j, i, value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvingtheNewtonlinearsystem"></a> </p><h3>Solving the Newton linear system</h3>
<p>We will need to solve a linear system in each iteration. We use a direct solver, for now &ndash; this is clearly not an efficient choice for a matrix that has so many non-zeroes, and it will not scale to anything interesting. For "real" applications, we will need an iterative solver but the complexity of the system means that an iterative solver algorithm will take a good deal of work. Because this is not the focus of the current program, we simply stick with the direct solver we have here &ndash; the function follows the same structure as used in <a class="el" href="step_29.html">step-29</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">  linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> linear_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Detailsoftheoptimizationalgorithm"></a> </p><h3>Details of the optimization algorithm</h3>
<p>The next several functions deal with specific parts of the optimization algorithm, most notably with deciding whether the direction computed by solving the linearized (Newton) system is viable and, if so, how far we want to go in this direction.</p>
<p><a class="anchor" id="Computingsteplengths"></a> </p><h4>Computing step lengths</h4>
<p>We start with a function that does a binary search to figure out the maximum step that meets the dual feasibility &ndash; that is, how far can we go so that \(s&gt;0\) and \(z&gt;0\). The function returns a pair of values, one each for the \(s\) and \(z\) slack variables.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">        fraction_to_boundary = 1 - barrier_size;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">    {</div><div class="line">      step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">      step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">        (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">        (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">           .is_non_negative());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">           .is_non_negative());</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_s)</div><div class="line">        step_size_s_low = step_size_s;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_z)</div><div class="line">        step_size_z_low = step_size_z;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_z_high = step_size_z;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingresiduals"></a> </p><h4>Computing residuals</h4>
<p>The next function computes a right hand side vector linearized around a "test solution vector" that we can use to look at the magnitude of the KKT conditions. This is then used for testing the convergence before shrinking the barrier size, as well as in the calculation of the \(l_1\) merit.</p>
<p>The function is lengthy and complicated, but it is really just a copy of the right hand side part of what the <code>assemble_system()</code> function above did.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>We first create a zero vector with size and blocking of system_rhs</p>
<div class="fragment"><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">  test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">    test_solution;</div><div class="line">  filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density) = 0;</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">  filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density),</div><div class="line">                      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density));</div><div class="line">  filter_matrix.Tvmult(</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">    test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">    n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">      mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">      fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                    old_density_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_divs);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">        test_solution, old_displacement_symmgrads);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_multiplier_values);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_multiplier_divs);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">        .get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_values);</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_multiplier_values);</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_values);</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filtered_unfiltered_density_solution,</div><div class="line">        filtered_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                displacement_multiplier_phi_i_symmgrad =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                    i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                    q_point);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                     q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">               * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">               * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">               * variables - the density, displacement, and</span></div><div class="line"><span class="comment">               * unfiltered density. */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (density_penalty_exponent *</div><div class="line">                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent - 1) *</div><div class="line">                   density_phi_i *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      old_displacement_divs[q_point] *</div><div class="line">                      lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_symmgrads[q_point] *</div><div class="line">                       old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                 density_phi_i *</div><div class="line">                   old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">               * below. */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                          density_penalty_exponent) *</div><div class="line">                 (old_displacement_multiplier_divs[q_point] *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                     displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 3 */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (unfiltered_density_phi_i *</div><div class="line">                   filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                     [q_point] +</div><div class="line">                 unfiltered_density_phi_i *</div><div class="line">                   old_upper_slack_multiplier_values[q_point] +</div><div class="line">                 -1 * unfiltered_density_phi_i *</div><div class="line">                   old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">              <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">               * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">               * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">               * a constraint. */</span></div><div class="line">              cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                       density_penalty_exponent) *</div><div class="line">                              (old_displacement_divs[q_point] *</div><div class="line">                                 displacement_multiplier_phi_i_div *</div><div class="line">                                 lambda_values[q_point] +</div><div class="line">                               2 * mu_values[q_point] *</div><div class="line">                                 (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                  old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">               * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">               * giving a minimum density of 0. */</span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (lower_slack_multiplier_phi_i *</div><div class="line">                              (old_unfiltered_density_values[q_point] -</div><div class="line">                               old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">               * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">               * density. */</span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (upper_slack_multiplier_phi_i *</div><div class="line">                              (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                               old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">               * density and the filter applied to the</span></div><div class="line"><span class="comment">               * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">               * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">               * applied correctly. */</span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (unfiltered_density_multiplier_phi_i *</div><div class="line">                              (old_density_values[q_point] -</div><div class="line">                               filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">               * requirement that s*z = \alpha for the barrier</span></div><div class="line"><span class="comment">               * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">               * from KKT conditions when \alpha goes to 0. */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (lower_slack_phi_i *</div><div class="line">                 (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 9 */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (upper_slack_phi_i *</div><div class="line">                 (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_upper_slack_values[q_point]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                   fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        -1 *</div><div class="line">                        (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                      i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (traction *</div><div class="line">                         fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                           i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               dummy_cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             test_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> test_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingthemeritfunction"></a> </p><h4>Computing the merit function</h4>
<p>The algorithm we use herein uses a "watchdog" strategy to determine where and how far to go from the current iterate. We base the watchdog strategy on an exact \(l_1\) merit function. This function calculates the exact \(l_1\) merit of a given, putative, next iterate.</p>
<p>The merit function consists of the sum of the objective function (which is simply an integral of external forces (on the boundary of the domain) times the displacement values of a test solution (typically, the current solution plus some multiple of the Newton update), and the \(l_1\) norms of the Lagrange multiplier components of residual vectors. The following code computes these parts in turn:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div></div><!-- fragment --><p>Start with computing the objective function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">              fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                     displacement_face_values);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                   face_q_point &lt; n_face_q_points;</div><div class="line">                   ++face_q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                  traction[1] = -1.;</div><div class="line"></div><div class="line">                  objective_function_merit +=</div><div class="line">                    (traction * displacement_face_values[face_q_point]) *</div><div class="line">                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">  }</div></div><!-- fragment --><p>Then compute the residual and take the \(l_1\) norms of the components that correspond to Lagrange mulipliers. We add those to the objective function computed above, and return the sum at the bottom:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">    objective_function_merit + elasticity_constraint_merit +</div><div class="line">    filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">  <span class="keywordflow">return</span> total_merit;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Findingasearchdirection"></a> </p><h4>Finding a search direction</h4>
<p>Next up is the function that actually computes a search direction starting at the current state (passed as the first argument) and returns the resulting vector. To this end, the function first calls the functions that assemble the linear system that corresponds to the Newton system, and that solve it.</p>
<p>This function also updates the penalty multiplier in the merit function, and then returns the largest scaled feasible step. It uses the <code>calculate_max_step_sizes()</code> function to find the largest feasible step that satisfies \(s&gt;0\) and \(z&gt;0\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">{</div><div class="line">  assemble_system();</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div></div><!-- fragment --><p>Next we are going to update penalty_multiplier. In essence, a larger penalty multiplier makes us consider the constraints more. Looking at the Hessian and gradient with respect to the step we want to take with our decision variables, and comparing that to the norm of our constraint error gives us a way to ensure that our merit function is "exact" - that is, it has a minimum in the same location that the objective function does. As our merit function is exact for any penalty multiplier over some minimum value, we only keep the computed value if it increases the penalty multiplier.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">  SolutionBlocks::density,</div><div class="line">  SolutionBlocks::displacement,</div><div class="line">  SolutionBlocks::unfiltered_density,</div><div class="line">  SolutionBlocks::density_upper_slack,</div><div class="line">  SolutionBlocks::density_lower_slack};</div><div class="line"><span class="keywordtype">double</span> hess_part = 0;</div><div class="line"><span class="keywordtype">double</span> grad_part = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">      {</div><div class="line">        Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">        system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">          .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">        hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">      }</div><div class="line">    grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                 step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">  SolutionBlocks::displacement_multiplier,</div><div class="line">  SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">  SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">  SolutionBlocks::density_upper_slack_multiplier};</div><div class="line"><span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">  constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line"><span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">  test_penalty_multiplier =</div><div class="line">    (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div></div><!-- fragment --><p>Based on all of this, we can now compute step sizes for the primal and dual (Lagrange multiplier) variables. Once we have these, we scale the components of the solution vector, and that is what this function returns.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">    calculate_max_step_size(nonlinear_solution, step);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingascaledstep"></a> </p><h4>Computing a scaled step</h4>
<p>The next function then implements a back-tracking algorithm for a line search. It keeps shrinking step size until it finds a step where the merit is decreased, and then returns the new location based on the current state vector, and the direction to go into, times the step length.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">    (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">     calculate_exact_merit(state)) /</div><div class="line">    1e-4;</div><div class="line">  <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">          calculate_exact_merit(state) +</div><div class="line">            step_size * descent_requirement * merit_derivative)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size = step_size / 2;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Checkingforconvergence"></a> </p><h4>Checking for convergence</h4>
<p>The final auxiliary function in this block is the one that checks to see if the KKT conditions are sufficiently met so that the overall algorithm can lower the barrier size. It does so by computing the \(l_1\) norm of the residual, which is what <code>calculate_test_rhs()</code> computes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">            &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessingthesolution"></a> </p><h3>Postprocessing the solution</h3>
<p>The first of the postprocessing functions outputs information in a VTU file for visualization. It looks long, but it's really just the same as what was done in <a class="el" href="step_22.html">step-22</a>, for example, just with (a lot) more solution variables:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p>The second of these functions outputs the solution as an <code>.stl</code> file for 3d printing. <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files are made up of triangles and normal vectors, and we will use it to show all of those cells with a density value larger than zero by first extruding the mesh from a \(z\) value of zero to \(z=0.25\), and then generating two triangles for each face of the cells with a sufficiently large density value. The triangle nodes must go counter-clockwise when looking from the outside, and the normal vectors must be unit vectors pointing outwards, which requires a few checks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">{</div><div class="line">  static_assert(dim == 2,</div><div class="line">                <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">  std::ofstream stlfile;</div><div class="line">  stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">  <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">            SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">        {</div></div><!-- fragment --><p>We have now found a cell with a density value larger than zero. Let us start by writing out the bottom and top faces. Owing to the ordering issue mentioned above, we have to make sure that we understand whether a cell has a right- or left-handed coordinate system. We do this by interrogating the directions of the two edges starting at vertex 0 and whether they form a right-handed coordinate system.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                             cell-&gt;vertex(0),</div><div class="line">                                           cell-&gt;vertex(2) -</div><div class="line">                                             cell-&gt;vertex(0)};</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">  {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">   {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">  {</div><div class="line">    <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Write one side at z = height. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">  {</div><div class="line">    <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Write one side at z = height. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --><p>Next we need to deal with the four faces of the cell, extended into the \(z\) direction. However, we only need to write these faces if either the face is on the domain boundary, or if it is the interface between a cell with density greater than 0.5, and a cell with a density less than 0.5.</p>
<div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">               face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">               ++face_number)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                cell-&gt;face(face_number);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                  (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                   (nonlinear_solution.block(</div><div class="line">                      0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                    0.5)))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                    (face-&gt;center() - cell-&gt;center());</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                  <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          0.000000e+00 +</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                          normal_vector[0] +</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[0] -</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                      0)</div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctiondrivingtheoverallalgorithm"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function driving the overall algorithm</h3>
<p>This function finally provides the overall driver logic. It is, in the grand scheme of things, a rather complicated function primarily because the optimization algorithm is difficult: It isn't just about finding a Newton direction like in <a class="el" href="step_15.html">step-15</a> and then going a fixed distance in this direction any more, but instead about (i) determining what the optimal log-barrier penalty parameter should be in the current step, (ii) a complicated algorithm to determine how far we want to go, and other ingredients. Let us see how we can break this down into smaller chunks in the following documentation.</p>
<p>The function starts out simple enough with first setting up the mesh, the <a class="el" href="classDoFHandler.html">DoFHandler</a>, and then the various linear algebra objects necessary for the following:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    setup_boundary_values();</div><div class="line">    setup_block_system();</div><div class="line">    setup_filter_matrix();</div><div class="line">  }</div></div><!-- fragment --><p>We then set a number of parameters that affect the log-barrier and line search components of the optimization algorithm:</p>
<div class="fragment"><div class="line">barrier_size                  = 25;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div></div><!-- fragment --><p>Now start the principal iteration. The overall algorithm works by using an outer loop in which we loop until either (i) the log-barrier parameter has become small enough, or (ii) we have reached convergence. In any case, we terminate if end up with too large a number of iterations. This overall structure is encoded as a <code>do { ... } while (...)</code> loop where the convergence condition is at the bottom.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div></div><!-- fragment --><p>Within this outer loop, we have an inner loop in which we try to find an update direction using the watchdog algorithm described in the introduction.</p>
<p>The general idea of the watchdog algorithm itself is this: For a maximum of <code>max_uphill_steps</code> (i.e., a loop within the "inner loop" mentioned above) attempts, we use <code>find_max_step()</code> to compute a Newton update step, and add these up in the <code>nonlinear_solution</code> vector. In each of these attempts (starting from the place reached at the end of the previous attempt), we check whether we have reached a target value of the merit function described above. The target value is computed based on where this algorithm starts (the <code>nonlinear_solution</code> at the beginning of the watchdog loop, saves as <code>watchdog_state</code>) and the first proposed direction provided by <code>find_max_step()</code> in the first go-around of this loop (the <code>k==0</code> case).</p>
<div class="fragment"><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">              &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">              &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">    <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">    <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">      {</div><div class="line">        ++iteration_number;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (k == 0)</div><div class="line">          {</div><div class="line">            first_step = update_step;</div><div class="line">            merit_derivative =</div><div class="line">              ((calculate_exact_merit(watchdog_state +</div><div class="line">                                      .0001 * first_step) -</div><div class="line">                calculate_exact_merit(watchdog_state)) /</div><div class="line">               .0001);</div><div class="line">            target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                           descent_requirement * merit_derivative;</div><div class="line">          }</div><div class="line"></div><div class="line">        nonlinear_solution += update_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">          calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                  &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                  &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">          {</div><div class="line">            watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>The next part of the algorithm then depends on whether the watchdog loop above succeeded. If it did, then we are satisfied and no further action is necessary: We just stay where we are. If, however, we took the maximal number of unsuccessful steps in the loop above, then we need to do something else, and this is what the following code block does.</p>
<p>Specifically, from the final (unsuccessful) state of the loop above, we seek one more update direction and take what is called a "stretch
   step". If that stretch state satisfies a condition involving the merit function, then we go there. On the other hand, if the stretch state is also unacceptable (as all of the watchdog steps above were), then we discard all of the watchdog steps taken above and start over again where we had started the watchdog iterations &ndash; that place was stored in the <code>watchdog_state</code> variable above. More specifically, the conditions below first test whether we take a step from <code>watchdog_state</code> in direction <code>first_step</code>, or whether we can do one more update from the stretch state to find a new place. It is possible that neither of these is actually better than the state we started from at the beginning of the watchdog algorithm, but even if that is so, that place clearly was a difficult place to be in, and getting away to start the next iteration from another place might be a useful strategy to eventually converge.</p>
<p>We keep repeating the watchdog steps above along with the logic below until this inner iteration is finally converged (or if we run up against the maximal number of iterations &ndash; where we count the number of linear solves as iterations and increment the counter every time we call <code>find_max_step()</code> since that is where the linear solve actually happens). In any case, at the end of each of these inner iterations we also output the solution in a form suitable for visualization.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    ++iteration_number;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">      compute_scaled_step(nonlinear_solution,</div><div class="line">                          update_step,</div><div class="line">                          descent_requirement);</div></div><!-- fragment --><p>If we did not get a successful watchdog step, we now need to decide between going back to where we started, or using the final state. We compare the merits of both of these locations, and then take a scaled step from whichever location is better. As the scaled step is guaranteed to lower the merit, we will end up keeping one of the two.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">             calculate_exact_merit(watchdog_state)) ||</div><div class="line">            (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            nonlinear_solution = stretch_state;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            std::cout</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                calculate_exact_merit(watchdog_state))</div><div class="line">              {</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(watchdog_state,</div><div class="line">                                      first_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                nonlinear_solution = stretch_state;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                  find_max_step();</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      stretch_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    output_results(iteration_number);</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">       (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div></div><!-- fragment --><p>At the end of the outer loop, we have to update the barrier parameter, for which we use the following formula. The rest of the function is then simply about checking the outer loop convergence condition, and if we decide to terminate computations, about writing the final "design" as an STL file for use in 3d printing, and to output some timing information.</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The remainder of the code, the <code>main()</code> function, is as usual:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-79/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="TestProblem"></a></p><h3>Test Problem</h3>
<p>上面使用的算法是针对一个传统的拓扑优化问题进行测试的，这个问题叫做Messerschmitt-Bolkow-Blohm Beam（MBB Beam）。</p>
<p>这个问题考虑的是在一个6个单位宽、1个单位高的矩形上可以建立的最佳二维结构。底部的角在 \(y\) 方向用零Dirichlet边界条件固定住，通过强制执行Neumann边界条件在梁的顶部中心施加一个向下的力。边界的其余部分被允许移动，并且没有施加任何外力，这采取了零诺伊曼边界条件的形式。从本质上讲，我们提出了以下问题。我们应该如何设计一座桥，使桥的左下角和右下角的点在滚轮上，允许这些点在水平方向上移动，但不允许在垂直方向上移动，从而使响应于中心的垂直力的位移最小。</p>
<p>虽然领域的总体积是6个单位，但结构允许有3个单位的材料。由于问题的对称性，可以在一个宽为3、高为1的矩形上提出，方法是将原域切成两半，并沿切边在 \(x\) 方向使用零迪里希特边界条件。也就是说，解决方案的对称性是一个很好的指标，表明程序正在按预期工作，所以我们在整个领域上解决问题，如下图所示。 <b>[Bendse2004]</b></p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.mbbgeometry.png" alt="MBB问题域和边界条件"/>
</div>
 </div><p>使用上面讨论的程序，我们找到了MBB梁的最小体积，解决方案的各个组成部分看起来如下。</p>
<div class="onecolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.filtereddensity.png" alt="过滤的密度溶液"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.unfiltereddensity.png" alt="未过滤的密度溶液"/>
</div>
 </div> </div><p>这些图片表明，我们在这里发现的情况与人们通常在关于该主题的其他出版物中看到的情况相一致 <b>[Bendse2004]</b> 。也许更有趣的是，结果看起来像一座桁架桥（除了我们在桁架的顶部施加负载，而不是像真正的桁架桥那样在底部施加负载，类似于 "桥面桁架 "桥），这表明几个世纪以来一直用于桥梁建设的设计确实是基于我们现在可以证明在某种意义上是最佳的想法。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h4>Possibilities for extensions</h4>
<p>上面显示的结果花了大约75次迭代才找到，考虑到在每次迭代中解决大型线性系统的费用，这相当令人担忧。看一下演化过程，收敛确实有快速发生和缓慢发生的时候。我们认为这是由于在何时和如何减少边界值方面缺乏精确性，以及我们对优点函数的选择不够理想。在未来，用LOQO障碍更新代替单调还原，以及用马尔科夫滤波器代替优点函数，将大大减少必要的迭代次数。</p>
<p>障碍物的减少在收敛的中间阶段最为敏感，这是有问题的，因为我们似乎需要它快速减少，然后缓慢减少，然后又快速减少。</p>
<p>其次，这里使用的线性求解器只是基于SparseDirectUMFPACK类的稀疏直接求解器。这在小问题上效果还不错，但是上面详述的优化问题的表述有相当多的变量，因此线性问题不仅大，而且在许多行中有很多非零项，即使在总体上仍然比较粗糙的网格上。因此，解算器的时间在计算中占主导地位，需要采用更复杂的方法来解决线性系统。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Justin O&#39;Connor, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionComponents</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">  } <span class="comment">// namespace SolutionComponents</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionBlocks</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">  } <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>BoundaryIds</div><div class="line">  {</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">  } <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>ValueExtractors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">      displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">      SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">      SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">      SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">      SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">  } <span class="comment">// namespace ValueExtractors</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SANDTopOpt</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SANDTopOpt();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">    std::pair&lt;double, double&gt;</div><div class="line">    calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">    calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">    find_relevant_neighbors(</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">    <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">    <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         5)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , density_ratio(.5)</div><div class="line">    , density_penalty_exponent(3)</div><div class="line">    , filter_r(.251)</div><div class="line">    , penalty_multiplier(1)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              {6, 1},</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">    triangulation.refine_global(3);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">  {</div><div class="line">    boundary_values.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[x_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line"></div><div class="line">                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                                 <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">    block_component[0] = 0;</div><div class="line">    block_component[1] = 1;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">        dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">            {</div><div class="line">              coupling[displacement&lt;dim&gt; + i]</div><div class="line">                      [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">              coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                      [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for slack variables */</span></div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">      fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">    <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">      density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">    constraints.clear();</div><div class="line">    constraints.add_line(last_density_dof);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">      constraints.add_entry(last_density_dof,</div><div class="line">                            density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                            -1);</div><div class="line">    constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                         SolutionBlocks::unfiltered_density)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    nonlinear_solution.reinit(block_sizes);</div><div class="line">    system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">      nonlinear_solution.block(density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">        .add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">      nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">  {</div><div class="line"></div><div class="line">    filter_sparsity_pattern.copy_from(</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                             SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">    filter_matrix.reinit(filter_sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                filter_matrix.add(i,</div><div class="line">                                  check_cell-&gt;active_cell_index(),</div><div class="line">                                  filter_r - distance);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> denominator = 0;</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          denominator = denominator + iter-&gt;value();</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">    neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">    cells_to_check.insert(cell);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">             std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">               cells_to_check.begin(), cells_to_check.end()))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                      cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                    <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                        !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                      {</div><div class="line">                        cells_to_check.insert(neighbor);</div><div class="line">                        neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                        new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">    <span class="keywordflow">return</span> cells_to_check;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">      nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      nonlinear_solution;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        nonlinear_solution.block(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          nonlinear_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                                       q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                      displacement_multiplier_phi_j_symmgrad =</div><div class="line">                        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">                          .symmetric_gradient(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">                      fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">                      fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">                      fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">                      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">                      fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">                      fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 1 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            (density_penalty_exponent - 1) *</div><div class="line">                            std::pow(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 2) *</div><div class="line">                            density_phi_i * density_phi_j *</div><div class="line">                            (old_displacement_multiplier_divs[q_point] *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_multiplier_phi_j_div *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               old_displacement_multiplier_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                                displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 2 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (density_penalty_exponent *</div><div class="line">                         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent - 1) *</div><div class="line">                         density_phi_j *</div><div class="line">                         (old_displacement_multiplier_divs[q_point] *</div><div class="line">                            displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                          2 * mu_values[q_point] *</div><div class="line">                            (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                       + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent) *</div><div class="line">                           (displacement_multiplier_phi_j_div *</div><div class="line">                              displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                            2 * mu_values[q_point] *</div><div class="line">                              (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                               displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      );</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">                     * calculated elsewhere. */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (-1 * unfiltered_density_phi_i *</div><div class="line">                         lower_slack_multiplier_phi_j +</div><div class="line">                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        density_penalty_exponent *</div><div class="line">                          <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent - 1) *</div><div class="line">                          density_phi_j *</div><div class="line">                          (old_displacement_divs[q_point] *</div><div class="line">                             displacement_multiplier_phi_i_div *</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 * mu_values[q_point] *</div><div class="line">                             (old_displacement_symmgrads[q_point] *</div><div class="line">                              displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                        + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent) *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               displacement_multiplier_phi_i_div *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (displacement_phi_j_symmgrad *</div><div class="line">                                displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      lower_slack_multiplier_phi_i *</div><div class="line">                      (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      upper_slack_multiplier_phi_i *</div><div class="line">                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">                     * is added later */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                                         unfiltered_density_multiplier_phi_i *</div><div class="line">                                         (density_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                       + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                           old_lower_slack_multiplier_values[q_point] /</div><div class="line">                           old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                       + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                           old_upper_slack_multiplier_values[q_point] /</div><div class="line">                           old_upper_slack_values[q_point]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 cell_matrix,</div><div class="line">                                                 dummy_cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    system_rhs = calculate_test_rhs(nonlinear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">               filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             ++iter)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .add(i, j, value);</div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .add(j, i, value);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">    linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> linear_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">          fraction_to_boundary = 1 - barrier_size;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">      {</div><div class="line">        step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">        step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">          (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">          (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">             .is_non_negative());</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">             .is_non_negative());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_s)</div><div class="line">          step_size_s_low = step_size_s;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_z)</div><div class="line">          step_size_z_low = step_size_z;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_z_high = step_size_z;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">    test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      test_solution;</div><div class="line">    filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density) = 0;</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">                 * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">                 * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">                 * variables - the density, displacement, and</span></div><div class="line"><span class="comment">                 * unfiltered density. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (density_penalty_exponent *</div><div class="line">                     <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                              density_penalty_exponent - 1) *</div><div class="line">                     density_phi_i *</div><div class="line">                     (old_displacement_multiplier_divs[q_point] *</div><div class="line">                        old_displacement_divs[q_point] *</div><div class="line">                        lambda_values[q_point] +</div><div class="line">                      2 * mu_values[q_point] *</div><div class="line">                        (old_displacement_symmgrads[q_point] *</div><div class="line">                         old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                   density_phi_i *</div><div class="line">                     old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">                 * below. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent) *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                       displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 3 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (unfiltered_density_phi_i *</div><div class="line">                     filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                       [q_point] +</div><div class="line">                   unfiltered_density_phi_i *</div><div class="line">                     old_upper_slack_multiplier_values[q_point] +</div><div class="line">                   -1 * unfiltered_density_phi_i *</div><div class="line">                     old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">                 * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">                 * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">                 * a constraint. */</span></div><div class="line">                cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                         density_penalty_exponent) *</div><div class="line">                                (old_displacement_divs[q_point] *</div><div class="line">                                   displacement_multiplier_phi_i_div *</div><div class="line">                                   lambda_values[q_point] +</div><div class="line">                                 2 * mu_values[q_point] *</div><div class="line">                                   (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                    old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">                 * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">                 * giving a minimum density of 0. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (lower_slack_multiplier_phi_i *</div><div class="line">                                (old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">                 * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">                 * density. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (upper_slack_multiplier_phi_i *</div><div class="line">                                (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">                 * density and the filter applied to the</span></div><div class="line"><span class="comment">                 * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">                 * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">                 * applied correctly. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (unfiltered_density_multiplier_phi_i *</div><div class="line">                                (old_density_values[q_point] -</div><div class="line">                                 filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">                 * requirement that @f$s*z = \alpha@f$ for the barrier</span></div><div class="line"><span class="comment">                 * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">                 * from KKT conditions when @f$\alpha@f$ goes to 0. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (lower_slack_phi_i *</div><div class="line">                   (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 9 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (upper_slack_phi_i *</div><div class="line">                   (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_upper_slack_values[q_point]));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                     fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                      {</div><div class="line">                        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                        traction[1] = -1.;</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          -1 *</div><div class="line">                          (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                        i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          (traction *</div><div class="line">                           fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                             i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 dummy_cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               test_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> test_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">    {</div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                              fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                       fe,</div><div class="line">                                       face_quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                  face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">                {</div><div class="line">                  fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                  fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                    .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                         displacement_face_values);</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                       face_q_point &lt; n_face_q_points;</div><div class="line">                       ++face_q_point)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      objective_function_merit +=</div><div class="line">                        (traction * displacement_face_values[face_q_point]) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">      objective_function_merit + elasticity_constraint_merit +</div><div class="line">      filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">    <span class="keywordflow">return</span> total_merit;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">  {</div><div class="line">    assemble_system();</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">      SolutionBlocks::density,</div><div class="line">      SolutionBlocks::displacement,</div><div class="line">      SolutionBlocks::unfiltered_density,</div><div class="line">      SolutionBlocks::density_upper_slack,</div><div class="line">      SolutionBlocks::density_lower_slack};</div><div class="line">    <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">    <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">          {</div><div class="line">            Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">            system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">              .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">            hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">          }</div><div class="line">        grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                     step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">      SolutionBlocks::displacement_multiplier,</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">      SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">      SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">    <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">    <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">      test_penalty_multiplier =</div><div class="line">        (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">    penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">      calculate_max_step_size(nonlinear_solution, step);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> step;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">      (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">       calculate_exact_merit(state)) /</div><div class="line">      1e-4;</div><div class="line">    <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">            calculate_exact_merit(state) +</div><div class="line">              step_size * descent_requirement * merit_derivative)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size = step_size / 2;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">              &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">  {</div><div class="line">    static_assert(dim == 2,</div><div class="line">                  <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">    std::ofstream stlfile;</div><div class="line">    stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">    <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">              SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                                         cell-&gt;vertex(0),</div><div class="line">                                                       cell-&gt;vertex(2) -</div><div class="line">                                                         cell-&gt;vertex(0)};</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">              {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">               {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">                 face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                 ++face_number)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                  cell-&gt;face(face_number);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                    (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                     (nonlinear_solution.block(</div><div class="line">                        0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                      0.5)))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                      (face-&gt;center() - cell-&gt;center());</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                    <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            0.000000e+00 +</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                            normal_vector[0] +</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[0] -</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                        0)</div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">      setup_boundary_values();</div><div class="line">      setup_block_system();</div><div class="line">      setup_filter_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">    barrier_size                  = 25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                      &lt;&lt; iteration_number</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                      &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">            <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">            <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">            <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (k == 0)</div><div class="line">                  {</div><div class="line">                    first_step = update_step;</div><div class="line">                    merit_derivative =</div><div class="line">                      ((calculate_exact_merit(watchdog_state +</div><div class="line">                                              .0001 * first_step) -</div><div class="line">                        calculate_exact_merit(watchdog_state)) /</div><div class="line">                       .0001);</div><div class="line">                    target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                   descent_requirement * merit_derivative;</div><div class="line">                  }</div><div class="line"></div><div class="line">                nonlinear_solution += update_step;</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                  calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                          &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                          &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                  {</div><div class="line">                    watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      update_step,</div><div class="line">                                      descent_requirement);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">                     calculate_exact_merit(watchdog_state)) ||</div><div class="line">                    (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">                  {</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                    nonlinear_solution = stretch_state;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    std::cout</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                        calculate_exact_merit(watchdog_state))</div><div class="line">                      {</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(watchdog_state,</div><div class="line">                                              first_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        ++iteration_number;</div><div class="line">                        nonlinear_solution = stretch_state;</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                          find_max_step();</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(nonlinear_solution,</div><div class="line">                                              stretch_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            output_results(iteration_number);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">               (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
