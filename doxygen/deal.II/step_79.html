<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_79.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-79 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-79 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic Material with Penalization</a>
        <li><a href="#ElasticityEquation">Elasticity Equation</a>
        <li><a href="#Makingthesolutionmeshindependent">Making the solution mesh-independent</a>
        <li><a href="#CompleteProblemFormulation">Complete Problem Formulation</a>
        <li><a href="#Solutionprocedure">Solution procedure</a>
        <li><a href="#Discretization">Discretization</a>
        <li><a href="#NonlinearAlgorithm">Nonlinear Algorithm</a>
        <li><a href="#MeritFunction">Merit Function</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Preliminaries">Preliminaries</a>
        <li><a href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a>
        <li><a href="#Constructorandsetupfunctions">Constructor and set-up functions</a>
        <li><a href="#Settingupblockmatricesandvectors">Setting up block matrices and vectors</a>
        <li><a href="#Creatingthefiltermatrix">Creating the filter matrix</a>
        <li><a href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a>
        <li><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear system</a>
        <li><a href="#Detailsoftheoptimizationalgorithm">Details of the optimization algorithm</a>
      <ul>
        <li><a href="#Computingsteplengths">Computing step lengths</a>
        <li><a href="#Computingresiduals">Computing residuals</a>
        <li><a href="#Computingthemeritfunction">Computing the merit function</a>
        <li><a href="#Findingasearchdirection">Finding a search direction</a>
        <li><a href="#Computingascaledstep">Computing a scaled step</a>
        <li><a href="#Checkingforconvergence">Checking for convergence</a>
      </ul>
        <li><a href="#Postprocessingthesolution">Postprocessing the solution</a>
        <li><a href="#Therunfunctiondrivingtheoverallalgorithm">The run() function driving the overall algorithm</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#TestProblem">Test Problem</a>
      <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>Topology Optimization of Elastic Media is a technique used to optimize a structure that is bearing some load. Ideally, we would like to minimize the maximum stress placed on a structure by selecting a region \(E\) where material is placed. In other words, </p><p class="formulaDsp">
\[ \text{minimize}\| \boldsymbol{\sigma} (\mathbf{u}) \|_\infty \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } |E|\leq V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0}. \]
</p>
<p>Here, \(\boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon}(\mathbf{u})\) is the stress within the body that is caused by the external forces \(\mathbf F\), where we have for simplicity assumed that the material is linear-elastic and so \(\mathbf{C}\) is the stress-strain tensor and \(\boldsymbol{\varepsilon}(\mathbf{u})=\frac{1}{2} (\nabla \mathbf{u} + (\nabla\mathbf{u})^T)\) is the small-deformation strain as a function of the displacement \(\mathbf{u}\) &ndash; see <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a> for more on linear elasticity. In the formulation above, \(V_\text{max}\) is the maximal amount of material we are willing to provide to build the object. The last of the constraints is the partial differential equation that relates stress \(\boldsymbol{\sigma}\) and forces \(\mathbf F\) and is simply the steady-state force balance.</p>
<p>That said, the infinity norm above creates a problem: As a function of location of material, this objective function is necessarily not differentiable, making prospects of optimization rather bleak. So instead, a common approach in topology optimization is to find an approximate solution by optimizing a related problem: We would like to minimize the strain energy. This is a measure of the potential energy stored in an object due to its deformation, but also works as a measure of total deformation over the structure.</p>
<p class="formulaDsp">
\[ \text{minimize } \int_E \frac{1}{2}\boldsymbol{\sigma} : \boldsymbol{\varepsilon} dV \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \|E\| \leq V_{\max} \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} \]
</p>
<p>The value of the objective function is calculated using a finite element method, where the solution is the displacements. This is placed inside of a nonlinear solver loop that solves for a vector denoting placement of material.</p>
<p><a class="anchor" id="SolidIsotropicMaterialwithPenalization"></a></p><h3>Solid Isotropic Material with Penalization</h3>
<p>In actual practice, we can only build objects in which the material is either present, or not present, at any given point &ndash; i.e., we would have an indicator function \(\rho_E(\mathbf{x})\in \{0,1\}\) that describes the material-filled region and that we want to find through the optimization problem. In this case, the optimization problem becomes combinatorial, and very expensive to solve. Instead, we use an approach called Solid Isotropic Material with Penalization, or SIMP. <b>[Bendse2004]</b></p>
<p>The SIMP method is based on an idea of allowing the material to exist in a location with a density \(\rho\) between 0 and 1. A density of 0 suggests the material is not there, and it is not a part of the structure, while a density of 1 suggests the material is present. Values between 0 and 1 do not reflect a design we can create in the real-world, but allow us to turn the combinatorial problem into a continuous one. One then looks at density values \(\rho\), with the constraint that \(0 &lt; \rho_{\min} \leq \rho \leq 1\). The minimum value \(\rho_{\min}\), typically chosen to be around \(10^{-3}\), avoids the possibility of having an infinite strain energy, but is small enough to provide accurate results.</p>
<p>The straightforward application of the effect of this "density" on the elasticity of the media would be to simply multiply the stiffness tensor \(\mathbf{C}_0\) of the medium by the given density, that is, \(\mathbf{C} = \rho \mathbf{C}_0\). However, this approach often gives optimal solutions where density values are far from both 0 and 1. As one wants to find a real-world solution, meaning the material either is present or it is not, a penalty is applied to these in-between values. A simple and effective way to do this is to multiply the stiffness tensor by the density raised to some integer power penalty parameter \(p\), so that \(\mathbf{C} = \rho^p \mathbf{C}_0\). This makes density values farther away from 0 or 1 less effective. It has been shown that using \(p=3\) is sufficiently high to create 'black-and-white' solutions: that is, one gets optimal solutions in which material is either present or not present at all points.</p>
<p>More material should always provide a structure with a lower strain energy, and so the inequality constraint can be viewed as an equality where the total volume used is the maximum volume.</p>
<p>Using this density idea also allows us to reframe the volume constraint on the optimization problem. Use of SIMP then turns the optimization problem into the following:</p>
<p class="formulaDsp">
\[ \text{minimize } \int_\Omega \frac{1}{2}\boldsymbol{\sigma}(\rho) : \boldsymbol{\varepsilon}(\rho) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \int_\Omega \rho(x) d\Omega= V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ 0&lt;\rho_{\min}\leq \rho(x) \leq 1, \]
</p>
 <p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma}(\rho) + \mathbf{F} = 0 \quad \text{on } \Omega \]
</p>
<p> The final constraint, the balance of linear momentum (which we will refer to as the elasticity equation), gives a method for finding \(\boldsymbol{\sigma}\) and \(\boldsymbol{\varepsilon}\) given the density \(\rho\).</p>
<p><a class="anchor" id="ElasticityEquation"></a></p><h3>Elasticity Equation</h3>
<p>The elasticity equation in the time independent limit reads </p><p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} . \]
</p>
<p> In the situations we will care about, we will assume that the medium has a linear material response and in that case, we have that </p><p class="formulaDsp">
\[ \boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon} = \rho^p \mathbf{C}_0 : \boldsymbol{\varepsilon}(\mathbf{u}) = \rho^p \mathbf{C}_0 : \left[\frac{1}{2} (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) \right] . \]
</p>
<p> In everything we will do below, we will always consider the displacement field \(\mathbf{u}\) as the only solution variable, rather than considering \(\mathbf{u}\) and \(\boldsymbol{\sigma}\) as solution variables (as is done in mixed formulations).</p>
<p>Furthermore, we will make the assumption that the material is linear isotropic, in which case the stress-strain tensor can be expressed in terms of the Lam&eacute; parameters \(\lambda,\mu\) such that </p><p class="formulaDsp">
\begin{align} \boldsymbol{\sigma} &amp;= \rho^p (\lambda \text{tr}(\boldsymbol{\varepsilon}) \mathbf{I} + 2 \mu \boldsymbol{\varepsilon}) , \\ \sigma_{i,j} &amp;= \rho^p (\lambda \varepsilon_{k,k} \delta_{i,j} + 2 \mu \varepsilon_{i,j}) . \end{align}
</p>
<p> See <a class="el" href="step_8.html">step-8</a> for how this transformation works.</p>
<p>Integrating the objective function by parts gives </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u}))^T d\Omega+ \int_\Omega (\nabla \cdot \boldsymbol{\sigma}(\rho)) \cdot \mathbf{u} d\Omega= \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega , \]
</p>
<p> into which the linear elasticity equation can then be substituted, giving </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_\Omega \mathbf{F}\cdot \mathbf{u} d\Omega+ \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega . \]
</p>
<p> Because we are assuming no body forces, this simplifies further to </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega, \]
</p>
<p> which is the final form of the governing equation that we'll be considering from this point forward.</p>
<p><a class="anchor" id="Makingthesolutionmeshindependent"></a></p><h3>Making the solution mesh-independent</h3>
<p>Typically, the solutions to topology optimization problems are mesh-dependent, and as such the problem is ill-posed. This is because fractal structures are often formed as the mesh is refined further. As the mesh gains resolution, the optimal solution typically gains smaller and smaller structures. There are a few competing workarounds to this issue, but the most popular for first order optimization is the sensitivity filter, while second order optimization methods tend to prefer use of a density filter.</p>
<p>As the filters affect the gradient and Hessian of the strain energy (i.e., the objective function), the choice of filter has an effect on the solution of the problem. The density filter as part of a second order method works by introducing an unfiltered density, which we refer to as \(\varrho\), and then requiring that the density be a convolution of the unfiltered density: </p><p class="formulaDsp">
\[ \rho = H(\varrho). \]
</p>
<p> Here, \(H\) is an operator so that \(\rho(\mathbf{x})\) is some kind of average of the values of \(\varrho\) in the area around \(\mathbf{x}\) &ndash; i.e., it is a smoothed version of \(\varrho\).</p>
<p>This prevents checkerboarding; the radius of the filter allows the user to define an effective minimal beam width for the optimal structures we seek to find.</p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.checkerboard.png" alt="Checkerboarding occurring in an MBB Beam"/>
</div>
 </div><p><a class="anchor" id="CompleteProblemFormulation"></a></p><h3>Complete Problem Formulation</h3>
<p>The minimization problem is now </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega= V \]
</p>
 <p class="formulaDsp">
\[ 0\leq \varrho \leq 1 \]
</p>
<p>The inequality constraints are dealt with by first introducing slack variables, and second using log barriers to ensure that we obtain an interior-point method. The penalty parameter is going to be \(\alpha\), and the following slack variables are </p><ol>
<li>
\(s_1\) - a slack variable corresponding to the lower bound </li>
<li>
\(s_2\) - a slack variable corresponding to the upper bound. </li>
</ol>
<p>This now gives the following problem: </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}, s_1, s_2} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega = V \]
</p>
 <p class="formulaDsp">
\[ \varrho = s_1 \]
</p>
 <p class="formulaDsp">
\[ 1-\varrho = s_2 \]
</p>
<p>With these variables in place, we can then follow the usual approach to solving constrained optimization problems: We introduce a Lagrangian in which we combine the objective function and the constraints by multiplying the constraints by Lagrange multipliers. Specifically, we will use the following symbols for the Lagrange multipliers for the various constraints: </p><ol>
<li>
\(\mathbf{y}_1 \): a Lagrange multiplier corresponding to the elasticity constraint,  </li>
<li>
\(y_2\): a Lagrange multiplier corresponding to the convolution filter constraint,  </li>
<li>
\(z_1\): a Lagrange multiplier corresponding to the lower slack variable, and  </li>
<li>
\(z_2\): a Lagrange multiplier corresponding to the upper slack variable.  </li>
</ol>
<p>With these variables, the Lagrangian function reads as follows:</p>
<p class="formulaDsp">
\begin{align} \mathcal{L} =&amp; \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega - \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega- \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{y}_1):\boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_1 \right)\right) d\Omega - \int_{\partial \Omega} \mathbf{y}_1 \cdot \mathbf{t} d\partial\Omega \\ &amp; -\int_\Omega y_2 (\rho - H(\varrho)) d\Omega - \int_\Omega z_1 (\varrho-s_1) d\Omega - \int_\Omega z_2 (1 - s_2 -\varrho) d\Omega \end{align}
</p>
<p>The solution of the optimization problem then needs to satisfy what are known as the <a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">Karush-Kuhn-Tucker (KKT) conditions</a>: The derivatives of the Lagrangian with respect to all of its arguments need to be equal to zero, and because we have inequality constraints, we also have "complementarity" conditions. Since we here have an infinite-dimensional problem, these conditions all involve directional derivatives of the Lagrangian with regard to certain test functions &ndash; in other words, all of these conditions have to be stated in weak form as is typically the basis for finite element methods anyway.</p>
<p>The barrier method allows us to initially weaken the "complementary slackness" as required by the typical KKT conditions. Typically, we would require that \(s_i z_i = 0\), but the barrier formulations give KKT conditions where \(s_i z_i = \alpha\), where \(\alpha\) is our barrier parameter. As part of the barrier method, this parameter must be driven close to 0 to give a good approximation of the original problem.</p>
<p>In the following, let us state all of these conditions where \(d_{\{\bullet\}}\) is a test function that is naturally paired with variational derivatives of the Lagrangian with respect to the \(\{\bullet\}\) function. For simplicity, we introduce \(\Gamma\) to indicate the portion of the boundary where forces are applied, and Neumann boundary conditions are used.</p>
<ol>
<li>
Stationarity: <p class="formulaDsp">
\[ \int_\Omega - d_\rho y_2 + p\rho^{p-1}d_\rho \left[\lambda (\nabla \cdot \mathbf{y}_1) (\nabla \cdot \mathbf{u}) + \mu \boldsymbol{\varepsilon}(\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall d_\rho \]
</p>
 <p class="formulaDsp">
\[ \int_\Gamma \mathbf d_\mathbf{u} \cdot \mathbf{t} d\partial\Omega+ \int_\Omega p\rho^{p} \left[\lambda (\nabla \cdot \mathbf d_\mathbf{u})( \nabla \cdot \mathbf{y}_1) + \mu \boldsymbol{\varepsilon}(\mathbf d_\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall \mathbf{d}_\mathbf{u} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega= 0\;\;\forall d_\varrho \]
</p>
  </li>
<li>
Primal Feasibility: <p class="formulaDsp">
\[ \int_\Omega \rho^{p}\lambda (\nabla \cdot \mathbf d_{\mathbf{y}_1}) (\nabla \cdot \mathbf{u}) + \rho^{p}\mu \boldsymbol{\varepsilon}(\mathbf d_{\mathbf{y}_1}) : \boldsymbol{\varepsilon}(\mathbf{u}) d\Omega - \int_\Gamma \mathbf d_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega =0 \;\;\forall \mathbf{d}_{\mathbf{y}_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_1}(\varrho - s_1) d\Omega = 0\;\;\forall d_{z_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_z}(1-\varrho-s_2) d\Omega = 0\;\;\forall d_{z_2} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{y_2}(\rho - H(\varrho)) d\Omega = 0\;\;\forall d_{y_2} \]
</p>
  </li>
<li>
Complementary Slackness: <p class="formulaDsp">
\[ \int_\Omega d_{s_1}(s_1z_1 - \alpha) d\Omega = 0 \;\;\forall d_{s_1} ,\;\;\; \alpha \to 0 \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{s_2}(s_2z_2 - \alpha) d\Omega = 0 \;\;\forall d_{s_2} ,\;\;\; \alpha \to 0 \]
</p>
  </li>
<li>
Dual Feasibility: <p class="formulaDsp">
\[ s_{1,i},s_{2,i},z_{1,i},z_{2,i} \geq 0 \;\;\;\; \forall i \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Solutionprocedure"></a></p><h3>Solution procedure</h3>
<p>The optimality conditions above are, in addition to being convoluted, of a kind that is not easy to solve: They are generally nonlinear, and some of the relationships are also inequalities. We will address the nonlinearity using a Newton method to compute search directions, and come back to how to deal with the inequalities below when talking about step length procedures.</p>
<p>Newton's method applied to the equations above results in the system of equations listed below. Therein, variational derivatives with respect to the \(\{\bullet\}\) variable are taken in the \(c_{\{\bullet\}}\) direction.</p>
<ol>
<li>
<p class="startli">Stationarity: These equations ensure we are at a critical point of the objective function when constrained.</p>
<p>Equation 1 </p><p class="formulaDsp">
\begin{align} &amp;\int_\Omega-d_\rho c_{y_2} + p(p-1) \rho^{p-2} d_\rho c_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] + p \rho^{p-1} d_\rho[\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] + p \rho^{p-1} d_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \\ &amp;= -\int_\Omega -d_\rho z_1 + d_\rho z_2 - d_\rho y_2 + p\rho^{p-1}d_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 2 </p><p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y})] + \rho^{p} [\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Gamma \mathbf{d}_\mathbf{u} \cdot \mathbf{t} -\int_\Omega \rho^{p} [\lambda \nabla \cdot \mathbf{y} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(d_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 3 </p><p class="formulaDsp">
\[ \int_\Omega - d_\varrho c_{z_1} +d_\varrho c_{z_2} + H(d_\varrho)c_{y_2} d\Omega = -\int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Primal Feasibility: These equations ensure the equality constraints are met.</p>
<p>Equation 4 </p><p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_p[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] + \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Omega \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon} (\mathbf{d}_{\mathbf{y}_1})] + \int_\Gamma \mathbf{d}_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega \end{align}
</p>
<p>Equation 5 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_1}(c_\varrho - c_{s_1}) d\Omega=\int_\Omega d_{z_1} (\varrho - s_1) d\Omega \]
</p>
<p>Equation 6 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_2}(-c_\varrho-c_{s_2}) d\Omega= \int_\Omega d_{z_2} (1-\varrho-s_2) d\Omega \]
</p>
<p>Equation 7 </p><p class="formulaDsp">
\[ -\int_\Omega d_{y_2}(c_\rho - H(c_\varrho)) d\Omega=\int_\Omega d_{y_2} (\rho - H(\varrho)) d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Complementary Slackness: These equations essentially ensure the barrier is met - in the final solution, we need \(s^T z = 0\).</p>
<p>Equation 8 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_1}(c_{s_1}z_1/s_1 + c_{z_1} ) d\Omega=-\int_\Omega d_{s_1} (z_1 - \alpha/s_1) d\Omega ,\;\;\; \alpha \to 0 \]
</p>
<p>Equation 9 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_2} (c_{s_2}z_2/s_2 + c_{z_2} ) d\Omega=-\int_\Omega d_{s_2} (z_2 - \alpha/s_2) d\Omega,\;\;\; \alpha \to 0 \]
</p>
 <p class="endli"></p>
</li>
<li>
Dual Feasibility: The Lagrange multiplier on slacks and slack variables must be kept greater than 0. (This is the only part not implemented in the <code>SANDTopOpt::assemble_system()</code> function.) <p class="formulaDsp">
\[ s,z \geq 0 \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p>We use a quadrilateral mesh with \(Q_1\) elements to discretize the displacement and displacement Lagrange multiplier. Piecewise constant \(DGQ_0\) elements are used to discretize the density, unfiltered density, density slack variables, and multipliers for the slack variables and filter constraint.</p>
<p><a class="anchor" id="NonlinearAlgorithm"></a></p><h3>Nonlinear Algorithm</h3>
<p>While most of the discussion above follows traditional and well-known approaches to solving nonlinear optimization problems, it turns out that the problem is actually quite difficult to solve in practice. In particular, it is quite nonlinear and an important question is not just to find search directions \(c_{\{\bullet\}}\) as discussed above based on a Newton method, but that one needs to spend quite a lot of attention to how far one wants to go in this direction. This is often called "line search" and comes down to the question of how to choose the step length \(\alpha_k \in (0,1]\) so that we move from the current iterate \(\mathbf{x}_k\) to the next iterate \(\mathbf{x}_{k+1}=\mathbf{x}_k+\alpha_k \mathbf{x}_k\) in as efficient a way as possible. It is well understood that we need to eventually choose \(\alpha_k=1\) to realize the Newton's method's quadratic convergence; however, in the early iterations, taking such a long step might actually make things worse, either by leading to a point that has a worse objective function or at which the constraints are satisfied less well than they are at \(\mathbf{x}_k\).</p>
<p>Very complex algorithms have been proposed to deal with this issue <b>[Nocedal2009]</b> <b>[Waechter2005]</b>. Here, we implement a watchdog-search algorithm <b>[Nocedal2006]</b>. When discussing this algorithm, we will use the vector \(\mathbf{x}\) to represent all primal variables - the filtered and unfiltered densities, slack variables and displacement - and use the vector \(\mathbf{y}\) to represent all of the dual vectors. The (incremental) solution to the nonlinear system of equations stated above will now be referred to as \(\Delta \mathbf{x}\) and \(\Delta \mathbf{y}\) instead of \(c_{\{\bullet\}}\). A merit function (explained in more detail later) is referred to here as \(\phi(\mathbf{x,\mathbf{y}})\).</p>
<p>The watchdog algorithm applied to a subproblem with a given barrier parameter works in the following way: First, the current iteration is saved as a "watchdog" state, and the merit of the watchdog state is recorded. A maximal feasible Newton step is then taken. If the merit sufficiently decreased from the first step, this new step is accepted. If not, another maximal feasible Newton step is taken, and the merit is again compared to the watchdog merit. If after some number (typically between 5 and 8) of Newton steps, the merit did not adequately decrease, the algorithm takes a scaled Newton step from either the watchdog state or the last iteration that guarantees a sufficient decrease of the merit, and that step is accepted. Once a step is accepted, the norm of the KKT error is measured, and if it is sufficiently small, the barrier value is decreased. If it is not sufficiently small, the last accepted step is taken to be the new watchdog step, and the process is repeated.</p>
<p>Above, the "maximal feasible step" is a scaling of the Newton step in both the primal and dual variables given by</p>
<p class="formulaDsp">
\[ \beta^\mathbf{y} = \min\{1,\max \beta \text{ such that }\left(\mathbf{z}_{k+i} + \beta^\mathbf{z}_{k+i} \Delta \mathbf{z}_{k+i}\right)_j \geq \zeta \mathbf{z}_{k+i,j} \forall j\} \]
</p>
 <p class="formulaDsp">
\[ \beta^\mathbf{x} = \min\{1,\max \beta \text{ such that }\left(\mathbf{s}_{k+i} + \beta^\mathbf{s}_{k+i} \Delta \mathbf{s}_{k+i}\right)_j \geq \zeta \mathbf{s}_{k+i,j} \forall j\} \]
</p>
<p>Above, \(\zeta\) is the "fraction to boundary" that is allowed on any step. Because the derivatives become ill-conditioned near the boundary, this technique stands in for a <a href="https://en.wikipedia.org/wiki/Trust_region">trust region</a> and is necessary to ensure good approximations in the future. \(\zeta\) is taken to be \(\max\{0.8, 1-\alpha\}\), which allows movement closer to the boundary as the barrier becomes smaller. In the future, when implementing the LOQO algorithm for barrier reduction, this must be kept to 0.8 as the barrier parameter can vary wildly.</p>
<p>Separately, we need to deal with the log-barrier that we have used to enforce the positivity constraint on the slack variables \(s_1,s_2\): In the statement of the final optimization problem we solve, we have added the term </p><p class="formulaDsp">
\[ -\alpha \int_\Omega (\log(s_1) + \log(s_2)) d\Omega. \]
</p>
<p> The question is how we should choose the penalty factor \(\alpha\). As with all penalty methods, we are in reality only interested in the limit as \(\alpha\to 0\), since this is then the problem we really wanted to solve, subject to the positivity constraints on the slack variables. On the other hand, we need to choose \(\alpha\) large enough to make the problem solvable in practice. Actual implementations therefore start with a larger value of \(\alpha\) and gradually decrease it as the outer iterations proceed.</p>
<p>In the monotone method implemented here, the barrier parameter is updated whenever some level of convergence is achieved at the current barrier parameter. We use the \(l_\infty\) norm of the KKT conditions to check for convergence at each barrier size. The requirement is that \(\|KKT\|_{l_\infty} &lt; c \cdot \alpha\) where \(c\) is a constant over any barrier size and \(\alpha\) is the barrier parameter. This forces better convergence in later iterations, and is the same requirement as is used in <a href="https://coin-or.github.io/Ipopt/">IPOPT</a> (an open source software package for large-scale nonlinear optimization).</p>
<p>Here, the barrier is reduced linearly at larger values, and superlinearly at smaller values. At larger values, it is multiplied by a constant (around 0.6), and at lower values the barrier value is replaced by the barrier value raised to some exponent (around 1.2). This method has proven to be effective at keeping the subproblem solvable at large barrier values, while still allowing superlinear convergence at smaller barrier values. In practice, this looks like the following: </p><p class="formulaDsp">
\[ \alpha_{k+1} = \min\{\alpha_k^{1.2},0.6\alpha_k\} \]
</p>
<p>While taking large steps at reducing the barrier size when convergence is reached is widely used, more recent research has shown that it is typically faster to use algorithms that adaptively update barrier each iteration, i.e., methods in which we use concrete criteria at the end of each iteration to determine what the penalty parameter should be in the next iteration, rather than using reduction factors that are independent of the current solution. That said, such methods are also more complicated and we will not do this here.</p>
<p><a class="anchor" id="MeritFunction"></a></p><h3>Merit Function</h3>
<p>The algorithm outlined above makes use of a "merit function". Merit functions are used to determine whether a step from \(x_k\) to a proposed point \(x_{k+1}\) is beneficial. In unconstrained optimization problems, one can simply check this with the objective function we try to minimize, and typically uses conditions such as the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe and Goldstein conditions</a>.</p>
<p>In constrained optimization problems, the question is how to balance reduction in the objective function against a possible increase in the violation of constraints: A proposed step might make the objective function smaller but be further away from the set of points that satisfy the constraints &ndash; or the other way around. This trade-off is typically resolved by using a merit function that combines the two criteria.</p>
<p>Here, we use an exact \(l_1\) merit function to test the steps: </p><p class="formulaDsp">
\begin{align} \phi(\mathbf{x},\mathbf{y}) =&amp; \int_{\partial \Omega} \mathbf{u}\cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega (\log(s_1) + \log(s_2)) + p \sum_i\left| \int_\Omega y_{2,i}(H(\varrho) - \rho) d\Omega \right| \\ &amp; + p \sum_i\left| \int_{\partial \Omega} \mathbf{y}_{1,i}\cdot \mathbf{t} d\partial\Omega - \int_\Omega \rho^p[\lambda \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_{1,i} + \mu \boldsymbol{\varepsilon}{\mathbf{u}}\boldsymbol{\varepsilon}{\mathbf{y}_{1,i}}] d\Omega \right| + p \sum_i\left| \int_\Omega z_{1,i}(s_1 - \varrho) d\Omega\right| + p \sum_i\left| \int_\Omega z_{2,i}(1-\varrho - s_2) d\Omega\right| \end{align}
</p>
<p>Here, \(p\) is a penalty parameter. This merit function being exact means that there exists some \(p_0\) so that for any \(p &gt; p_0\), the merit function has its minima at the same location as the original problem. This penalty parameter is updated (by recommendation of Nocedal and Wright <b>[Benson2002]</b>) as follows: </p><p class="formulaDsp">
\[ p &gt; \frac{\frac{1}{2} \mathbf{x}^T \cdot \mathbf{H} \cdot \mathbf{x} - \mathbf{x}^T \cdot \nabla f}{\|c_i\|_{l_\infty}} \quad , i \in \mathcal{E}, \]
</p>
<p> where \(\mathbf{H}\) is the Hessian of the objective function, \(\mathbf{x}\) is a vector of our decision (primal) variables, \(f\) is the objective function, and \(c_i\) is the error on a current equality constraint.</p>
<p>Our use of this method is partially due to already having most of the necessary parts calculated in finding the right hand side, but also the use of an exact merit function ensures that it is minimized in the same location as the overall problem. Recent research has shown that one can replace merit functions by what are called "filter methods", and one should consider using these instead as they prove to be more efficient.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Preliminaries"></a> </p><h3>Preliminaries</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div></div><!-- fragment --><p>Above are fairly common files to include. These also include the one for the sparse direct class <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>. This is not the most efficient way to solve large linear problems, but it will do for now.</p>
<p>As usual, we put everything into a common namespace. We then start by declaring a number of symbolic names for constants that will be used throughout this tutorial. Specifically, we have a <em>lot</em> of variables in this program (of course the density and the displacement, but also the unfiltered density and quite a number of Lagrange multipliers). It is easy to forget which of these variables is at which position in the solution vector, and trying to use numbers for these vector components is a prescription for bugs. Rather, we define static variables that can be used in all of these places and that have to be initialized only once. In practice, this will lead to some lengthy expressions, but they are more readable and less likely to be wrong.</p>
<p>A similar issue arises with the ordering of blocks in the system matrix and in vectors. The matrices have \(9\times 9\) blocks, and it's difficult to remember which is which. It is far easier to just use symbolic names for those as well.</p>
<p>Finally, while we're at it, we introduce symbolic names also for the boundary indicators we will use, in the same spirit as was done in <a class="el" href="step_19.html">step-19</a>.</p>
<p>In all of these cases, we declare these variables as members in a namespace. In the case of the solution components, the concrete values of these variables depend on the space dimension, so we use <a href="https://en.cppreference.com/w/cpp/language/variable_template">template variables</a> to make the value of the variable depend on a template argument in the same way as we often use template functions.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>This namespace keeps track of the first component in our finite element system that corresponds to each variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionComponents</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">} <span class="comment">// namespace SolutionComponents</span></div></div><!-- fragment --><p>This is the namespace which keeps track of which block corresponds to which variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionBlocks</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">} <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>BoundaryIds</div><div class="line">{</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">} <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ValueExtractors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">    displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">    SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">    SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">    SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">    SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">} <span class="comment">// namespace ValueExtractors</span></div></div><!-- fragment --><p><a class="anchor" id="TheSANDTopOptmainclass"></a> </p><h3>The SANDTopOpt main class</h3>
<p>Next up is the main class for this problem. The majority of functions follow the usual naming schemes of tutorial programs, though there are a couple that have been broken out of what is usually called the <code>setup_system()</code> function because of their length, and there are also a number that deal with various aspects of the optimization algorithm.</p>
<p>As an added bonus, the program writes the computed design as an STL file that one can, for example, send to a 3d printer.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SANDTopOpt</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SANDTopOpt();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Most of the member variables are also standard. There are, however, a number of variables that are specifically related to the optimization algorithm (such the various scalar factors below) as well as the filter matrix to ensure that the design remains smooth.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">  <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">  <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h3>Constructor and set-up functions</h3>
<p>We initialize a <a class="el" href="classFESystem.html">FESystem</a> composed of 2 \(\times\)dim <code><a class="el" href="classFE__Q.html">FE_Q(1)</a></code> elements for the displacement variable and its Lagrange multiplier, and 7 <code><a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a></code> elements. These piecewise constant functions are for density-related variables: the density itself, the unfiltered density, the slack variables for the lower and upper bounds on the unfiltered density, and then Lagrange multipliers for the connection between filtered and unfiltered densities as well as for the inequality constraints.</p>
<p>The order in which these elements appear is documented above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       5)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , density_ratio(.5)</div><div class="line">  , density_penalty_exponent(3)</div><div class="line">  , filter_r(.251)</div><div class="line">  , penalty_multiplier(1)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p>The first step then is to create the triangulation that matches the problem description in the introduction &ndash; a 6-by-1 rectangle (or a 6-by-1-by-1 box in 3d) where a force will be applied in the top center. This triangulation is then uniformly refined a number of times.</p>
<p>In contrast to nearly the entire rest of this program, this function specifically assumes that we are in 2d and will require changes if we wanted to move to 3d simulations. We ensure that nobody tries to accidentally run in 3d without such modifications through an assertion at the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            {6, 1},</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">  triangulation.refine_global(3);</div></div><!-- fragment --><p>The second step is to apply boundary indicators to parts of the boundary. The following code assigns boundary indicators to the bottom, top, left, and right boundaries of the box, respectively. The center region of the top boundary is given a separate boundary indicator: This is where we will apply the down force.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the constraints due to boundary values. The bottom corners of the domain are kept in place in the \(y\) direction &ndash; the bottom left also in the \(x\) direction. deal.II generally thinks of boundary values as attached to pieces of the boundary, i.e., faces, rather than individual vertices. Indeed, mathematically speaking, one can not assign boundary values to individual points for the infinite-dimensional partial differential equation. But, since we are trying to reproduce a widely used benchmark, we will do so anyway and keep in mind that we have a finite-dimensional problem for which imposing boundary conditions at a single node is valid.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">{</div><div class="line">  boundary_values.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div></div><!-- fragment --><p>Check whether the current face is on the bottom boundary, and if it is whether one of its vertices might be the bottom left or bottom right vertex:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[x_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line"></div><div class="line">                      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                               <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Settingupblockmatricesandvectors"></a> </p><h3>Setting up block matrices and vectors</h3>
<p>The next function makes a giant 9-by-9 block matrix, and also sets up the necessary block vectors. The sparsity pattern for this matrix includes the sparsity pattern for the filter matrix. It also initializes any block vectors we will use.</p>
<p>Setting up the blocks by themselves is not overly complicated and follows what is already done in programs such as <a class="el" href="step_22.html">step-22</a>, for example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">  block_component[0] = 0;</div><div class="line">  block_component[1] = 1;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">    n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">      dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">  dsp.collect_sizes();</div></div><!-- fragment --><p>The bulk of the function is in setting up which of these blocks will actually contain anything, i.e., which variables couple with which other variables. This is cumbersome but necessary to ensure that we don't just allocate a very large number of entries for our matrix that will then end up being zero.</p>
<p>The concrete pattern you see below is something one probably has to draw once on a piece of paper, but follows in an otherwise relatively straightforward way from looking through the many terms of the bilinear form we will have to assemble in each nonlinear iteration.</p>
<p>The use of the symbolic names defined in namespace <code>SolutionComponents</code> helps understand what each of the following terms corresponds to, but it also makes the expressions lengthy and unwieldy: A term such as <code>coupling[SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;][SolutionComponents::density&lt;dim&gt;]</code> just doesn't read very well, and would either have to be split over several lines or run off the right edge of nearly every screen. As a consequence, we open a curly-brace enclosed code block in which we temporarily make the names in namespace <code>SolutionComponents</code> available without the namespace qualifier, by saying <code>using namespace SolutionComponents</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for displacement </span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">        {</div><div class="line">          coupling[displacement&lt;dim&gt; + i]</div><div class="line">                  [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                  [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for slack variables </span></div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">}</div></div><!-- fragment --><p>Before we can create the sparsity pattern, we also have to set up constraints. Since this program does not adaptively refine the mesh, the only constraint we have is one that couples all density variables to enforce the volume constraint. This will ultimately lead to a dense sub-block of the matrix, but there is little we can do about that.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">  fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line"><a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">  density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">constraints.clear();</div><div class="line">constraints.add_line(last_density_dof);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">  constraints.add_entry(last_density_dof,</div><div class="line">                        density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                        -1);</div><div class="line">constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">constraints.close();</div></div><!-- fragment --><p>We can now finally create the sparsity pattern for the matrix, taking into account which variables couple with which other variables, and the constraints we have on the density.</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div></div><!-- fragment --><p>The only part of the matrix we have not dealt with is the filter matrix and its transpose. These are non-local (integral) operators for which deal.II does not currently have functions. What we will ultimately need to do is go over all cells and couple the unfiltered density on this cell to all filtered densities of neighboring cells that are less than a threshold distance away, and the other way around; for the moment, we are only concerned with building the sparsity pattern that would correspond to this kind of matrix, so we perform the equivalent loop and where later on we would write into an entry of the matrix, we now simply add an entry to the sparsity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Having so generated the "dynamic" sparsity pattern, we can finally copy it to the structure that is used to associate matrices with a sparsity pattern. Because the sparsity pattern is large and complex, we also output it into a file of its own for visualization purposes &ndash; in other words, for "visual debugging".</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>What is left is to correctly size the various vectors and their blocks, as well as setting initial guesses for some of the components of the (nonlinear) solution vector. We here use the symbolic component names for individual blocks of the solution vector and, for brevity, use the same trick with <code>using namespace</code> as above:</p>
<div class="fragment"><div class="line">  nonlinear_solution.reinit(block_sizes);</div><div class="line">  system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">    nonlinear_solution.block(density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">      .add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">    nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">    nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefiltermatrix"></a> </p><h3>Creating the filter matrix</h3>
<p>Next up, a function that is used once at the beginning of the program: It creates a matrix \(H\) so that the filtered density vector equals \(H\) times the unfiltered density. The creation of this matrix is non-trivial, and it is used in every iteration, and so rather than reforming it as we do with the Newton matrix, it is made only once and stored separately.</p>
<p>The way this matrix is computed follows the outline used above already to form its sparsity pattern. We repeat this process here for the sparsity pattern of this separately formed matrix, and then actually build the matrix itself. You may want to check the definition of this matrix in the introduction to this program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">{</div></div><!-- fragment --><p>The sparsity pattern of the filter has already been determined and implemented in the setup_system() function. We copy the structure from the appropriate block and use it again here.</p>
<div class="fragment"><div class="line">filter_sparsity_pattern.copy_from(</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">filter_matrix.reinit(filter_sparsity_pattern);</div></div><!-- fragment --><p>Having so built the sparsity pattern, now we re-do all of these loops to actually compute the necessary values of the matrix entries:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            filter_matrix.add(i,</div><div class="line">                              check_cell-&gt;active_cell_index(),</div><div class="line">                              filter_r - distance);</div><div class="line">            </div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The final step is to normalize the matrix so that for each row, the sum of entries equals one.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> denominator = 0;</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        denominator = denominator + iter-&gt;value();</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function is used for building the filter matrix. We create a set of all the cell iterators within a certain radius of the cell that is input. These are the neighboring cells that will be relevant for the filter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">  neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">  cells_to_check.insert(cell);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">           std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">             cells_to_check.begin(), cells_to_check.end()))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                    cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                  <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                      !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                    {</div><div class="line">                      cells_to_check.insert(neighbor);</div><div class="line">                      neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                      new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">  <span class="keywordflow">return</span> cells_to_check;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingtheNewtonmatrix"></a> </p><h3>Assembling the Newton matrix</h3>
<p>Whereas the setup_filter_matrix function built a matrix that is the same as long as the mesh does not change (which we don't do anyway in this program), the next function builds the matrix to be solved in each iteration. This is where the magic happens. The components of the system of linear equations describing Newton's method for finding the solution of the KKT conditions are implemented here.</p>
<p>The top of the function is as in most of these functions and just sets up all sorts of variables necessary for the actual assembly, including a whole bunch of extractors. The entire set up should look familiar, though somewhat lengthier, if you've previously looked at <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div></div><!-- fragment --><p>At this point, we apply the filter to the unfiltered density, and apply the adjoint (transpose) operation to the unfiltered density multiplier, both to the current best guess for the nonlinear solution. We use this later to tell us how far off our filtered density is from the filter applied to the unfiltered density. That is because while at the solution of the nonlinear problem, we have \(\rho=H\varrho\), but at intermediate iterations, we in general have \(\rho^k\neq H\varrho^k\) and the "residual" \(\rho^k-H\varrho^k\) will then appear as the right hand side of one of the Newton update equations that we compute below.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"></div><div class="line">filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                      SolutionBlocks::unfiltered_density),</div><div class="line">                    nonlinear_solution.block(</div><div class="line">                      SolutionBlocks::unfiltered_density));</div><div class="line">filter_matrix.Tvmult(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">  nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">  n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">  n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>ValueExtractors;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">    mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div></div><!-- fragment --><p>As part of the construction of our system matrix, we need to retrieve values from our current guess at the solution. The following lines of code retrieve the needed values.</p>
<div class="fragment"><div class="line">fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                              old_density_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_divs);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">  nonlinear_solution, old_displacement_symmgrads);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">  .get_function_symmetric_gradients(</div><div class="line">    nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_values);</div><div class="line">fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_values);</div><div class="line">fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filtered_unfiltered_density_solution,</div><div class="line">  filtered_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We need several more values corresponding to the test functions coming from the first derivatives taken from the Lagrangian, that is the \(d_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">      fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">      fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      displacement_multiplier_phi_i_symmgrad =</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">          i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                          q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">      fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                           q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div></div><!-- fragment --><p>Finally, we need values that come from the second round of derivatives taken from the Lagrangian, the \(c_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">  fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                   q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">  fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  displacement_multiplier_phi_j_symmgrad =</div><div class="line">    fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">      .symmetric_gradient(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">  fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">  fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">  fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">  fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">  fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div></div><!-- fragment --><p>This is where the actual work starts. In the following, we will build all of the terms of the matrix &ndash; they are numerous and not entirely self-explanatory, also depending on the previous solutions and its derivatives (which we have already evaluated above and put into the variables called <code>old_*</code>). To understand what each of these terms corresponds to, you will want to look at the explicit form of these terms in the introduction above.</p>
<p>The right hand sides of the equations being driven to 0 give all the KKT conditions for finding a local minimum &ndash; the descriptions of what each individual equation are given with the computations of the right hand side.</p>
<div class="fragment"><div class="line">          <span class="comment">// Equation 1 </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  (density_penalty_exponent - 1) *</div><div class="line">                  std::pow(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 2) *</div><div class="line">                  density_phi_i * density_phi_j *</div><div class="line">                  (old_displacement_multiplier_divs[q_point] *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_multiplier_phi_j_div *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     old_displacement_multiplier_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                      displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">// Equation 2 </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (density_penalty_exponent *</div><div class="line">               <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent - 1) *</div><div class="line">               density_phi_j *</div><div class="line">               (old_displacement_multiplier_divs[q_point] *</div><div class="line">                  displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                2 * mu_values[q_point] *</div><div class="line">                  (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                   displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">             + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent) *</div><div class="line">                 (displacement_multiplier_phi_j_div *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                     displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">            );</div><div class="line"></div><div class="line">          <span class="comment">// Equation 3, which has to do with the filter and which is calculated elsewhere. </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (-1 * unfiltered_density_phi_i *</div><div class="line">               lower_slack_multiplier_phi_j +</div><div class="line">             unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">          <span class="comment">// Equation 4: Primal feasibility </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              density_penalty_exponent *</div><div class="line">                <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent - 1) *</div><div class="line">                density_phi_j *</div><div class="line">                (old_displacement_divs[q_point] *</div><div class="line">                   displacement_multiplier_phi_i_div *</div><div class="line">                   lambda_values[q_point] +</div><div class="line">                 2 * mu_values[q_point] *</div><div class="line">                   (old_displacement_symmgrads[q_point] *</div><div class="line">                    displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">              + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent) *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     displacement_multiplier_phi_i_div *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (displacement_phi_j_symmgrad *</div><div class="line">                      displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">// Equation 5: Primal feasibility </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            lower_slack_multiplier_phi_i *</div><div class="line">            (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 6: Primal feasibility </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            upper_slack_multiplier_phi_i *</div><div class="line">            (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 7: Primal feasibility - the part with the filter is added later </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               unfiltered_density_multiplier_phi_i *</div><div class="line">                               (density_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 8: Complementary slackness </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">             + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                 old_lower_slack_multiplier_values[q_point] /</div><div class="line">                 old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">          <span class="comment">// Equation 9: Complementary slackness </span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">             + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                 old_upper_slack_multiplier_values[q_point] /</div><div class="line">                 old_upper_slack_values[q_point]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have everything assembled, all we have to do is deal with the effect of (Dirichlet) boundary conditions and other constraints. We incorporate the former locally with just the contributions from the current cell, and then let the AffineConstraint class deal with the latter while copying contributions from the current cell into the global linear system:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                           local_dof_indices,</div><div class="line">                                           cell_matrix,</div><div class="line">                                           dummy_cell_rhs,</div><div class="line">                                           <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Having accumulated all of the terms that belong into the Newton matrix, we now also have to compute the terms for the right hand side (i.e., the negative residual). We already do this in another function, and so we call that here:</p>
<div class="fragment"><div class="line">system_rhs = calculate_test_rhs(nonlinear_solution);</div></div><!-- fragment --><p>Here we use the filter matrix we have already constructed. We only need to integrate this filter applied to test functions, which are piecewise constant, and so the integration becomes a simple multiplication by the measure of the cell. Iterating over the pre-made filter matrix allows us to use the information about which cells are in or out of the filter without repeatedly checking neighbor cells again.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">             filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           ++iter)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                   SolutionBlocks::unfiltered_density)</div><div class="line">            .add(i, j, value);</div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density,</div><div class="line">                   SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">            .add(j, i, value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvingtheNewtonlinearsystem"></a> </p><h3>Solving the Newton linear system</h3>
<p>We will need to solve a linear system in each iteration. We use a direct solver, for now &ndash; this is clearly not an efficient choice for a matrix that has so many non-zeroes, and it will not scale to anything interesting. For "real" applications, we will need an iterative solver but the complexity of the system means that an iterative solver algorithm will take a good deal of work. Because this is not the focus of the current program, we simply stick with the direct solver we have here &ndash; the function follows the same structure as used in <a class="el" href="step_29.html">step-29</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">  linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> linear_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Detailsoftheoptimizationalgorithm"></a> </p><h3>Details of the optimization algorithm</h3>
<p>The next several functions deal with specific parts of the optimization algorithm, most notably with deciding whether the direction computed by solving the linearized (Newton) system is viable and, if so, how far we want to go in this direction.</p>
<p><a class="anchor" id="Computingsteplengths"></a> </p><h4>Computing step lengths</h4>
<p>We start with a function that does a binary search to figure out the maximum step that meets the dual feasibility &ndash; that is, how far can we go so that \(s&gt;0\) and \(z&gt;0\). The function returns a pair of values, one each for the \(s\) and \(z\) slack variables.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">        fraction_to_boundary = 1 - barrier_size;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">    {</div><div class="line">      step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">      step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">        (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">        (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">           .is_non_negative());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">           .is_non_negative());</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_s)</div><div class="line">        step_size_s_low = step_size_s;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_z)</div><div class="line">        step_size_z_low = step_size_z;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_z_high = step_size_z;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingresiduals"></a> </p><h4>Computing residuals</h4>
<p>The next function computes a right hand side vector linearized around a "test solution vector" that we can use to look at the magnitude of the KKT conditions. This is then used for testing the convergence before shrinking the barrier size, as well as in the calculation of the \(l_1\) merit.</p>
<p>The function is lengthy and complicated, but it is really just a copy of the right hand side part of what the <code>assemble_system()</code> function above did.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>We first create a zero vector with size and blocking of system_rhs</p>
<div class="fragment"><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">  test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">    test_solution;</div><div class="line">  filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density) = 0;</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">  filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density),</div><div class="line">                      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density));</div><div class="line">  filter_matrix.Tvmult(</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">    test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">    n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">      mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">      fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                    old_density_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_divs);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">        test_solution, old_displacement_symmgrads);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_multiplier_values);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_multiplier_divs);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">        .get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_values);</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_multiplier_values);</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_values);</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filtered_unfiltered_density_solution,</div><div class="line">        filtered_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                displacement_multiplier_phi_i_symmgrad =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                    i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                    q_point);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                     q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 1: This equation, along with equations 2 and 3, are the variational derivatives of the Lagrangian with respect to the decision variables - the density, displacement, and unfiltered density. </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (density_penalty_exponent *</div><div class="line">                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent - 1) *</div><div class="line">                   density_phi_i *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      old_displacement_divs[q_point] *</div><div class="line">                      lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_symmgrads[q_point] *</div><div class="line">                       old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                 density_phi_i *</div><div class="line">                   old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 2; the boundary terms will be added further down below. </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                          density_penalty_exponent) *</div><div class="line">                 (old_displacement_multiplier_divs[q_point] *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                     displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 3 </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (unfiltered_density_phi_i *</div><div class="line">                   filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                     [q_point] +</div><div class="line">                 unfiltered_density_phi_i *</div><div class="line">                   old_upper_slack_multiplier_values[q_point] +</div><div class="line">                 -1 * unfiltered_density_phi_i *</div><div class="line">                   old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">              <span class="comment">// Equation 4; boundary term will again be dealt with below. This equation being driven to 0 ensures that the elasticity equation is met as a constraint. </span></div><div class="line">              cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                       density_penalty_exponent) *</div><div class="line">                              (old_displacement_divs[q_point] *</div><div class="line">                                 displacement_multiplier_phi_i_div *</div><div class="line">                                 lambda_values[q_point] +</div><div class="line">                               2 * mu_values[q_point] *</div><div class="line">                                 (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                  old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 5: This equation sets the lower slack variable equal to the unfiltered density, giving a minimum density of 0. </span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (lower_slack_multiplier_phi_i *</div><div class="line">                              (old_unfiltered_density_values[q_point] -</div><div class="line">                               old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 6: This equation sets the upper slack variable equal to one minus the unfiltered density. </span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (upper_slack_multiplier_phi_i *</div><div class="line">                              (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                               old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 7: This is the difference between the density and the filter applied to the unfiltered density. This being driven to 0 by the Newton steps ensures that the filter is applied correctly. </span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (unfiltered_density_multiplier_phi_i *</div><div class="line">                              (old_density_values[q_point] -</div><div class="line">                               filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 8: This along with equation 9 give the requirement that s*z = \alpha for the barrier size alpha, and gives complementary slackness from KKT conditions when \alpha goes to 0. </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (lower_slack_phi_i *</div><div class="line">                 (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 9 </span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (upper_slack_phi_i *</div><div class="line">                 (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_upper_slack_values[q_point]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                   fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        -1 *</div><div class="line">                        (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                      i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (traction *</div><div class="line">                         fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                           i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               dummy_cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             test_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> test_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingthemeritfunction"></a> </p><h4>Computing the merit function</h4>
<p>The algorithm we use herein uses a "watchdog" strategy to determine where and how far to go from the current iterate. We base the watchdog strategy on an exact \(l_1\) merit function. This function calculates the exact \(l_1\) merit of a given, putative, next iterate.</p>
<p>The merit function consists of the sum of the objective function (which is simply an integral of external forces (on the boundary of the domain) times the displacement values of a test solution (typically, the current solution plus some multiple of the Newton update), and the \(l_1\) norms of the Lagrange multiplier components of residual vectors. The following code computes these parts in turn:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div></div><!-- fragment --><p>Start with computing the objective function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">              fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                     displacement_face_values);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                   face_q_point &lt; n_face_q_points;</div><div class="line">                   ++face_q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                  traction[1] = -1.;</div><div class="line"></div><div class="line">                  objective_function_merit +=</div><div class="line">                    (traction * displacement_face_values[face_q_point]) *</div><div class="line">                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">  }</div></div><!-- fragment --><p>Then compute the residual and take the \(l_1\) norms of the components that correspond to Lagrange mulipliers. We add those to the objective function computed above, and return the sum at the bottom:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">    objective_function_merit + elasticity_constraint_merit +</div><div class="line">    filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">  <span class="keywordflow">return</span> total_merit;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Findingasearchdirection"></a> </p><h4>Finding a search direction</h4>
<p>Next up is the function that actually computes a search direction starting at the current state (passed as the first argument) and returns the resulting vector. To this end, the function first calls the functions that assemble the linear system that corresponds to the Newton system, and that solve it.</p>
<p>This function also updates the penalty multiplier in the merit function, and then returns the largest scaled feasible step. It uses the <code>calculate_max_step_sizes()</code> function to find the largest feasible step that satisfies \(s&gt;0\) and \(z&gt;0\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">{</div><div class="line">  assemble_system();</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div></div><!-- fragment --><p>Next we are going to update penalty_multiplier. In essence, a larger penalty multiplier makes us consider the constraints more. Looking at the Hessian and gradient with respect to the step we want to take with our decision variables, and comparing that to the norm of our constraint error gives us a way to ensure that our merit function is "exact" - that is, it has a minimum in the same location that the objective function does. As our merit function is exact for any penalty multiplier over some minimum value, we only keep the computed value if it increases the penalty multiplier.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">  SolutionBlocks::density,</div><div class="line">  SolutionBlocks::displacement,</div><div class="line">  SolutionBlocks::unfiltered_density,</div><div class="line">  SolutionBlocks::density_upper_slack,</div><div class="line">  SolutionBlocks::density_lower_slack};</div><div class="line"><span class="keywordtype">double</span> hess_part = 0;</div><div class="line"><span class="keywordtype">double</span> grad_part = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">      {</div><div class="line">        Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">        system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">          .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">        hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">      }</div><div class="line">    grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                 step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">  SolutionBlocks::displacement_multiplier,</div><div class="line">  SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">  SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">  SolutionBlocks::density_upper_slack_multiplier};</div><div class="line"><span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">  constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line"><span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">  test_penalty_multiplier =</div><div class="line">    (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div></div><!-- fragment --><p>Based on all of this, we can now compute step sizes for the primal and dual (Lagrange multiplier) variables. Once we have these, we scale the components of the solution vector, and that is what this function returns.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">    calculate_max_step_size(nonlinear_solution, step);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingascaledstep"></a> </p><h4>Computing a scaled step</h4>
<p>The next function then implements a back-tracking algorithm for a line search. It keeps shrinking step size until it finds a step where the merit is decreased, and then returns the new location based on the current state vector, and the direction to go into, times the step length.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">    (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">     calculate_exact_merit(state)) /</div><div class="line">    1e-4;</div><div class="line">  <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">          calculate_exact_merit(state) +</div><div class="line">            step_size * descent_requirement * merit_derivative)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size = step_size / 2;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Checkingforconvergence"></a> </p><h4>Checking for convergence</h4>
<p>The final auxiliary function in this block is the one that checks to see if the KKT conditions are sufficiently met so that the overall algorithm can lower the barrier size. It does so by computing the \(l_1\) norm of the residual, which is what <code>calculate_test_rhs()</code> computes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">            &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessingthesolution"></a> </p><h3>Postprocessing the solution</h3>
<p>The first of the postprocessing functions outputs information in a VTU file for visualization. It looks long, but it's really just the same as what was done in <a class="el" href="step_22.html">step-22</a>, for example, just with (a lot) more solution variables:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p>The second of these functions outputs the solution as an <code>.stl</code> file for 3d printing. <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files are made up of triangles and normal vectors, and we will use it to show all of those cells with a density value larger than zero by first extruding the mesh from a \(z\) value of zero to \(z=0.25\), and then generating two triangles for each face of the cells with a sufficiently large density value. The triangle nodes must go counter-clockwise when looking from the outside, and the normal vectors must be unit vectors pointing outwards, which requires a few checks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">{</div><div class="line">  static_assert(dim == 2,</div><div class="line">                <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">  std::ofstream stlfile;</div><div class="line">  stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">  <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">            SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">        {</div></div><!-- fragment --><p>We have now found a cell with a density value larger than zero. Let us start by writing out the bottom and top faces. Owing to the ordering issue mentioned above, we have to make sure that we understand whether a cell has a right- or left-handed coordinate system. We do this by interrogating the directions of the two edges starting at vertex 0 and whether they form a right-handed coordinate system.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                             cell-&gt;vertex(0),</div><div class="line">                                           cell-&gt;vertex(2) -</div><div class="line">                                             cell-&gt;vertex(0)};</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">  {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">   {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">  {</div><div class="line">    <span class="comment">// Write one side at z = 0. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Write one side at z = height. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="comment">// The cell has a left-handed set up </span></div><div class="line">  {</div><div class="line">    <span class="comment">// Write one side at z = 0. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Write one side at z = height. </span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --><p>Next we need to deal with the four faces of the cell, extended into the \(z\) direction. However, we only need to write these faces if either the face is on the domain boundary, or if it is the interface between a cell with density greater than 0.5, and a cell with a density less than 0.5.</p>
<div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">               face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">               ++face_number)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                cell-&gt;face(face_number);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                  (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                   (nonlinear_solution.block(</div><div class="line">                      0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                    0.5)))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                    (face-&gt;center() - cell-&gt;center());</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                  <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          0.000000e+00 +</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                          normal_vector[0] +</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[0] -</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                      0)</div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctiondrivingtheoverallalgorithm"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function driving the overall algorithm</h3>
<p>This function finally provides the overall driver logic. It is, in the grand scheme of things, a rather complicated function primarily because the optimization algorithm is difficult: It isn't just about finding a Newton direction like in <a class="el" href="step_15.html">step-15</a> and then going a fixed distance in this direction any more, but instead about (i) determining what the optimal log-barrier penalty parameter should be in the current step, (ii) a complicated algorithm to determine how far we want to go, and other ingredients. Let us see how we can break this down into smaller chunks in the following documentation.</p>
<p>The function starts out simple enough with first setting up the mesh, the <a class="el" href="classDoFHandler.html">DoFHandler</a>, and then the various linear algebra objects necessary for the following:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    setup_boundary_values();</div><div class="line">    setup_block_system();</div><div class="line">    setup_filter_matrix();</div><div class="line">  }</div></div><!-- fragment --><p>We then set a number of parameters that affect the log-barrier and line search components of the optimization algorithm:</p>
<div class="fragment"><div class="line">barrier_size                  = 25;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div></div><!-- fragment --><p>Now start the principal iteration. The overall algorithm works by using an outer loop in which we loop until either (i) the log-barrier parameter has become small enough, or (ii) we have reached convergence. In any case, we terminate if end up with too large a number of iterations. This overall structure is encoded as a <code>do { ... } while (...)</code> loop where the convergence condition is at the bottom.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div></div><!-- fragment --><p>Within this outer loop, we have an inner loop in which we try to find an update direction using the watchdog algorithm described in the introduction.</p>
<p>The general idea of the watchdog algorithm itself is this: For a maximum of <code>max_uphill_steps</code> (i.e., a loop within the "inner loop" mentioned above) attempts, we use <code>find_max_step()</code> to compute a Newton update step, and add these up in the <code>nonlinear_solution</code> vector. In each of these attempts (starting from the place reached at the end of the previous attempt), we check whether we have reached a target value of the merit function described above. The target value is computed based on where this algorithm starts (the <code>nonlinear_solution</code> at the beginning of the watchdog loop, saves as <code>watchdog_state</code>) and the first proposed direction provided by <code>find_max_step()</code> in the first go-around of this loop (the <code>k==0</code> case).</p>
<div class="fragment"><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">              &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">              &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">    <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">    <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">      {</div><div class="line">        ++iteration_number;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (k == 0)</div><div class="line">          {</div><div class="line">            first_step = update_step;</div><div class="line">            merit_derivative =</div><div class="line">              ((calculate_exact_merit(watchdog_state +</div><div class="line">                                      .0001 * first_step) -</div><div class="line">                calculate_exact_merit(watchdog_state)) /</div><div class="line">               .0001);</div><div class="line">            target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                           descent_requirement * merit_derivative;</div><div class="line">          }</div><div class="line"></div><div class="line">        nonlinear_solution += update_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">          calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                  &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                  &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">          {</div><div class="line">            watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>The next part of the algorithm then depends on whether the watchdog loop above succeeded. If it did, then we are satisfied and no further action is necessary: We just stay where we are. If, however, we took the maximal number of unsuccessful steps in the loop above, then we need to do something else, and this is what the following code block does.</p>
<p>Specifically, from the final (unsuccessful) state of the loop above, we seek one more update direction and take what is called a "stretch
 step". If that stretch state satisfies a condition involving the merit function, then we go there. On the other hand, if the stretch state is also unacceptable (as all of the watchdog steps above were), then we discard all of the watchdog steps taken above and start over again where we had started the watchdog iterations &ndash; that place was stored in the <code>watchdog_state</code> variable above. More specifically, the conditions below first test whether we take a step from <code>watchdog_state</code> in direction <code>first_step</code>, or whether we can do one more update from the stretch state to find a new place. It is possible that neither of these is actually better than the state we started from at the beginning of the watchdog algorithm, but even if that is so, that place clearly was a difficult place to be in, and getting away to start the next iteration from another place might be a useful strategy to eventually converge.</p>
<p>We keep repeating the watchdog steps above along with the logic below until this inner iteration is finally converged (or if we run up against the maximal number of iterations &ndash; where we count the number of linear solves as iterations and increment the counter every time we call <code>find_max_step()</code> since that is where the linear solve actually happens). In any case, at the end of each of these inner iterations we also output the solution in a form suitable for visualization.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    ++iteration_number;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">      compute_scaled_step(nonlinear_solution,</div><div class="line">                          update_step,</div><div class="line">                          descent_requirement);</div></div><!-- fragment --><p>If we did not get a successful watchdog step, we now need to decide between going back to where we started, or using the final state. We compare the merits of both of these locations, and then take a scaled step from whichever location is better. As the scaled step is guaranteed to lower the merit, we will end up keeping one of the two.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">             calculate_exact_merit(watchdog_state)) ||</div><div class="line">            (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            nonlinear_solution = stretch_state;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            std::cout</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                calculate_exact_merit(watchdog_state))</div><div class="line">              {</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(watchdog_state,</div><div class="line">                                      first_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                nonlinear_solution = stretch_state;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                  find_max_step();</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      stretch_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    output_results(iteration_number);</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">       (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div></div><!-- fragment --><p>At the end of the outer loop, we have to update the barrier parameter, for which we use the following formula. The rest of the function is then simply about checking the outer loop convergence condition, and if we decide to terminate computations, about writing the final "design" as an STL file for use in 3d printing, and to output some timing information.</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The remainder of the code, the <code>main()</code> function, is as usual:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="TestProblem"></a></p><h3>Test Problem</h3>
<p>The algorithms used above are tested against a traditional topology optimization problem called the Messerschmitt-Bolkow-Blohm Beam (MBB Beam).</p>
<p>This problem considers the optimal 2-d structure that can be built on a rectangle 6 units wide, and 1 unit tall. The bottom corners are fixed in place in the \(y\) direction using a zero Dirichlet boundary condition, and a downward force is applied in the center of the top of the beam by enforcing a Neumann boundary condition. The rest of the boundary is allowed to move, and has no external force applied, which takes the form of a zero Neumann boundary condition. In essence, we are asking the following question: How should we design a bridge in a way so that if the bottom left and bottom right point of the bridge are on rollers that allow these points to move horizontally but not vertically, and so that the displacement in response to the vertical force in the center is minimal.</p>
<p>While the total volume of the domain is 6 units, 3 units of material are allowed for the structure. Because of the symmetry of the problem, it could be posed on a rectangle of width 3 and height 1 by cutting the original domain in half, and using zero Dirichlet boundary conditions in the \(x\) direction along the cut edge. That said, symmetry of the solution is a good indicator that the program is working as expected, so we solved the problem on the whole domain, as shown below. <b>[Bendse2004]</b></p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.mbbgeometry.png" alt="The MBB problem domain and boundary conditions"/>
</div>
 </div><p>Using the program discussed above, we find the minimum volume of the MBB Beam and the individual components of the solution look as follows:</p>
<div class="onecolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.filtereddensity.png" alt="Filtered Density Solution"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.unfiltereddensity.png" alt="Unfiltered Density Solution"/>
</div>
 </div> </div><p>These pictures show that what we find here is in accordance with what one typically sees in other publications on the topic <b>[Bendse2004]</b>. Maybe more interestingly, the result looks like a truss bridge (except that we apply the load at the top of the trusses, rather than the bottom as in real truss bridges, akin to a "deck
truss" bridge), suggesting that the designs that have been used in bridge- building for centuries are indeed based on ideas we can now show to be optimal in some sense.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h4>Possibilities for extensions</h4>
<p>The results shown above took around 75 iterations to find, which is quite concerning given the expense in solving the large linear systems in each iteration. Looking at the evolution, it does look as though the convergence has moments of happening quickly and moments of happening slowly. We believe this to be due to both a lack of precision on when and how to decrease the boundary values, as well as our choice of merit function being sub-optimal. In the future, a LOQO barrier update replacing the monotone reduction, as well as a Markov Filter in place of a merit function will decrease the number of necessary iterations significantly.</p>
<p>The barrier decrease is most sensitive in the middle of the convergence, which is problematic, as it seems like we need it to decrease quickly, then slowly, then quickly again.</p>
<p>Secondly, the linear solver used here is just the sparse direct solver based on the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class. This works reasonably well on small problems, but the formulation of the optimization problem detailed above has quite a large number of variables and so the linear problem is not only large but also has a lot of nonzero entries in many rows, even on meshes that overall are still relatively coarse. As a consequence, the solver time dominates the computations, and more sophisticated approaches at solving the linear system are necessary.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Justin O&#39;Connor, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionComponents</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">  } <span class="comment">// namespace SolutionComponents</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionBlocks</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">  } <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>BoundaryIds</div><div class="line">  {</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">  } <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>ValueExtractors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">      displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">      SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">      SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">      SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">      SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">  } <span class="comment">// namespace ValueExtractors</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SANDTopOpt</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SANDTopOpt();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">    std::pair&lt;double, double&gt;</div><div class="line">    calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">    calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">    find_relevant_neighbors(</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">    <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">    <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         5)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , density_ratio(.5)</div><div class="line">    , density_penalty_exponent(3)</div><div class="line">    , filter_r(.251)</div><div class="line">    , penalty_multiplier(1)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              {6, 1},</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">    triangulation.refine_global(3);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">  {</div><div class="line">    boundary_values.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[x_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line"></div><div class="line">                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                                 <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">    block_component[0] = 0;</div><div class="line">    block_component[1] = 1;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">        dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">            {</div><div class="line">              coupling[displacement&lt;dim&gt; + i]</div><div class="line">                      [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">              coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                      [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for slack variables */</span></div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">      fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">    <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">      density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">    constraints.clear();</div><div class="line">    constraints.add_line(last_density_dof);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">      constraints.add_entry(last_density_dof,</div><div class="line">                            density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                            -1);</div><div class="line">    constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                         SolutionBlocks::unfiltered_density)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    nonlinear_solution.reinit(block_sizes);</div><div class="line">    system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">      nonlinear_solution.block(density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">        .add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">      nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">  {</div><div class="line"></div><div class="line">    filter_sparsity_pattern.copy_from(</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                             SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">    filter_matrix.reinit(filter_sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                filter_matrix.add(i,</div><div class="line">                                  check_cell-&gt;active_cell_index(),</div><div class="line">                                  filter_r - distance);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> denominator = 0;</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          denominator = denominator + iter-&gt;value();</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">    neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">    cells_to_check.insert(cell);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">             std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">               cells_to_check.begin(), cells_to_check.end()))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                      cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                    <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                        !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                      {</div><div class="line">                        cells_to_check.insert(neighbor);</div><div class="line">                        neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                        new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">    <span class="keywordflow">return</span> cells_to_check;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">      nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      nonlinear_solution;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        nonlinear_solution.block(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          nonlinear_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                                       q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                      displacement_multiplier_phi_j_symmgrad =</div><div class="line">                        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">                          .symmetric_gradient(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">                      fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">                      fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">                      fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">                      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">                      fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">                      fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 1 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            (density_penalty_exponent - 1) *</div><div class="line">                            std::pow(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 2) *</div><div class="line">                            density_phi_i * density_phi_j *</div><div class="line">                            (old_displacement_multiplier_divs[q_point] *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_multiplier_phi_j_div *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               old_displacement_multiplier_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                                displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 2 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (density_penalty_exponent *</div><div class="line">                         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent - 1) *</div><div class="line">                         density_phi_j *</div><div class="line">                         (old_displacement_multiplier_divs[q_point] *</div><div class="line">                            displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                          2 * mu_values[q_point] *</div><div class="line">                            (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                       + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent) *</div><div class="line">                           (displacement_multiplier_phi_j_div *</div><div class="line">                              displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                            2 * mu_values[q_point] *</div><div class="line">                              (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                               displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      );</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">                     * calculated elsewhere. */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (-1 * unfiltered_density_phi_i *</div><div class="line">                         lower_slack_multiplier_phi_j +</div><div class="line">                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        density_penalty_exponent *</div><div class="line">                          <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent - 1) *</div><div class="line">                          density_phi_j *</div><div class="line">                          (old_displacement_divs[q_point] *</div><div class="line">                             displacement_multiplier_phi_i_div *</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 * mu_values[q_point] *</div><div class="line">                             (old_displacement_symmgrads[q_point] *</div><div class="line">                              displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                        + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent) *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               displacement_multiplier_phi_i_div *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (displacement_phi_j_symmgrad *</div><div class="line">                                displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      lower_slack_multiplier_phi_i *</div><div class="line">                      (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      upper_slack_multiplier_phi_i *</div><div class="line">                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">                     * is added later */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                                         unfiltered_density_multiplier_phi_i *</div><div class="line">                                         (density_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                       + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                           old_lower_slack_multiplier_values[q_point] /</div><div class="line">                           old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                       + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                           old_upper_slack_multiplier_values[q_point] /</div><div class="line">                           old_upper_slack_values[q_point]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 cell_matrix,</div><div class="line">                                                 dummy_cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    system_rhs = calculate_test_rhs(nonlinear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">               filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             ++iter)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .add(i, j, value);</div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .add(j, i, value);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">    linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> linear_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">          fraction_to_boundary = 1 - barrier_size;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">      {</div><div class="line">        step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">        step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">          (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">          (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">             .is_non_negative());</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">             .is_non_negative());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_s)</div><div class="line">          step_size_s_low = step_size_s;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_z)</div><div class="line">          step_size_z_low = step_size_z;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_z_high = step_size_z;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">    test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      test_solution;</div><div class="line">    filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density) = 0;</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">                 * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">                 * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">                 * variables - the density, displacement, and</span></div><div class="line"><span class="comment">                 * unfiltered density. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (density_penalty_exponent *</div><div class="line">                     <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                              density_penalty_exponent - 1) *</div><div class="line">                     density_phi_i *</div><div class="line">                     (old_displacement_multiplier_divs[q_point] *</div><div class="line">                        old_displacement_divs[q_point] *</div><div class="line">                        lambda_values[q_point] +</div><div class="line">                      2 * mu_values[q_point] *</div><div class="line">                        (old_displacement_symmgrads[q_point] *</div><div class="line">                         old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                   density_phi_i *</div><div class="line">                     old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">                 * below. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent) *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                       displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 3 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (unfiltered_density_phi_i *</div><div class="line">                     filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                       [q_point] +</div><div class="line">                   unfiltered_density_phi_i *</div><div class="line">                     old_upper_slack_multiplier_values[q_point] +</div><div class="line">                   -1 * unfiltered_density_phi_i *</div><div class="line">                     old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">                 * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">                 * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">                 * a constraint. */</span></div><div class="line">                cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                         density_penalty_exponent) *</div><div class="line">                                (old_displacement_divs[q_point] *</div><div class="line">                                   displacement_multiplier_phi_i_div *</div><div class="line">                                   lambda_values[q_point] +</div><div class="line">                                 2 * mu_values[q_point] *</div><div class="line">                                   (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                    old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">                 * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">                 * giving a minimum density of 0. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (lower_slack_multiplier_phi_i *</div><div class="line">                                (old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">                 * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">                 * density. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (upper_slack_multiplier_phi_i *</div><div class="line">                                (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">                 * density and the filter applied to the</span></div><div class="line"><span class="comment">                 * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">                 * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">                 * applied correctly. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (unfiltered_density_multiplier_phi_i *</div><div class="line">                                (old_density_values[q_point] -</div><div class="line">                                 filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">                 * requirement that @f$s*z = \alpha@f$ for the barrier</span></div><div class="line"><span class="comment">                 * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">                 * from KKT conditions when @f$\alpha@f$ goes to 0. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (lower_slack_phi_i *</div><div class="line">                   (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 9 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (upper_slack_phi_i *</div><div class="line">                   (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_upper_slack_values[q_point]));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                     fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                      {</div><div class="line">                        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                        traction[1] = -1.;</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          -1 *</div><div class="line">                          (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                        i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          (traction *</div><div class="line">                           fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                             i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 dummy_cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               test_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> test_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">    {</div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                              fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                       fe,</div><div class="line">                                       face_quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                  face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">                {</div><div class="line">                  fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                  fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                    .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                         displacement_face_values);</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                       face_q_point &lt; n_face_q_points;</div><div class="line">                       ++face_q_point)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      objective_function_merit +=</div><div class="line">                        (traction * displacement_face_values[face_q_point]) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">      objective_function_merit + elasticity_constraint_merit +</div><div class="line">      filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">    <span class="keywordflow">return</span> total_merit;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">  {</div><div class="line">    assemble_system();</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">      SolutionBlocks::density,</div><div class="line">      SolutionBlocks::displacement,</div><div class="line">      SolutionBlocks::unfiltered_density,</div><div class="line">      SolutionBlocks::density_upper_slack,</div><div class="line">      SolutionBlocks::density_lower_slack};</div><div class="line">    <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">    <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">          {</div><div class="line">            Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">            system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">              .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">            hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">          }</div><div class="line">        grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                     step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">      SolutionBlocks::displacement_multiplier,</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">      SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">      SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">    <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">    <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">      test_penalty_multiplier =</div><div class="line">        (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">    penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">      calculate_max_step_size(nonlinear_solution, step);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> step;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">      (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">       calculate_exact_merit(state)) /</div><div class="line">      1e-4;</div><div class="line">    <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">            calculate_exact_merit(state) +</div><div class="line">              step_size * descent_requirement * merit_derivative)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size = step_size / 2;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">              &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">  {</div><div class="line">    static_assert(dim == 2,</div><div class="line">                  <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">    std::ofstream stlfile;</div><div class="line">    stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">    <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">              SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                                         cell-&gt;vertex(0),</div><div class="line">                                                       cell-&gt;vertex(2) -</div><div class="line">                                                         cell-&gt;vertex(0)};</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">              {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">               {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">                 face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                 ++face_number)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                  cell-&gt;face(face_number);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                    (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                     (nonlinear_solution.block(</div><div class="line">                        0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                      0.5)))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                      (face-&gt;center() - cell-&gt;center());</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                    <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            0.000000e+00 +</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                            normal_vector[0] +</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[0] -</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                        0)</div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">      setup_boundary_values();</div><div class="line">      setup_block_system();</div><div class="line">      setup_filter_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">    barrier_size                  = 25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                      &lt;&lt; iteration_number</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                      &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">            <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">            <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">            <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (k == 0)</div><div class="line">                  {</div><div class="line">                    first_step = update_step;</div><div class="line">                    merit_derivative =</div><div class="line">                      ((calculate_exact_merit(watchdog_state +</div><div class="line">                                              .0001 * first_step) -</div><div class="line">                        calculate_exact_merit(watchdog_state)) /</div><div class="line">                       .0001);</div><div class="line">                    target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                   descent_requirement * merit_derivative;</div><div class="line">                  }</div><div class="line"></div><div class="line">                nonlinear_solution += update_step;</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                  calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                          &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                          &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                  {</div><div class="line">                    watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      update_step,</div><div class="line">                                      descent_requirement);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">                     calculate_exact_merit(watchdog_state)) ||</div><div class="line">                    (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">                  {</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                    nonlinear_solution = stretch_state;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    std::cout</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                        calculate_exact_merit(watchdog_state))</div><div class="line">                      {</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(watchdog_state,</div><div class="line">                                              first_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        ++iteration_number;</div><div class="line">                        nonlinear_solution = stretch_state;</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                          find_max_step();</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(nonlinear_solution,</div><div class="line">                                              stretch_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            output_results(iteration_number);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">               (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_15.html">step-15</a> . <table
 class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic
 Material with Penalization</a><a
 href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic Material
 with Penalization</a>
 <li><a href="#ElasticityEquation">Elasticity Equation</a><a
 href="#ElasticityEquation">Elasticity Equation</a>
 <li><a href="#Makingthesolutionmeshindependent">Making the solution
 mesh-independent</a><a href="#Makingthesolutionmeshindependent">Making the
 solution mesh-independent</a>
 <li><a href="#CompleteProblemFormulation">Complete Problem
 Formulation</a><a href="#CompleteProblemFormulation">Complete Problem
 Formulation</a>
 <li><a href="#Solutionprocedure">Solution procedure</a><a
 href="#Solutionprocedure">Solution procedure</a>
 <li><a href="#Discretization">Discretization</a><a
 href="#Discretization">Discretization</a>
 <li><a href="#NonlinearAlgorithm">Nonlinear Algorithm</a><a
 href="#NonlinearAlgorithm">Nonlinear Algorithm</a>
 <li><a href="#MeritFunction">Merit Function</a><a
 href="#MeritFunction">Merit Function</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Preliminaries">Preliminaries</a><a
 href="#Preliminaries">Preliminaries</a>
 <li><a href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a><a
 href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a>
 <li><a href="#Constructorandsetupfunctions">Constructor and set-up
 functions</a><a href="#Constructorandsetupfunctions">Constructor and set-up
 functions</a>
 <li><a href="#Settingupblockmatricesandvectors">Setting up block matrices
 and vectors</a><a href="#Settingupblockmatricesandvectors">Setting up block
 matrices and vectors</a>
 <li><a href="#Creatingthefiltermatrix">Creating the filter matrix</a><a
 href="#Creatingthefiltermatrix">Creating the filter matrix</a>
 <li><a href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a><a
 href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a>
 <li><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear
 system</a><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear
 system</a>
 <li><a href="#Detailsoftheoptimizationalgorithm">Details of the
 optimization algorithm</a><a
 href="#Detailsoftheoptimizationalgorithm">Details of the optimization
 algorithm</a>
 <ul>
 <li><a href="#Computingsteplengths">Computing step lengths</a><a
 href="#Computingsteplengths">Computing step lengths</a>
 <li><a href="#Computingresiduals">Computing residuals</a><a
 href="#Computingresiduals">Computing residuals</a>
 <li><a href="#Computingthemeritfunction">Computing the merit function</a><a
 href="#Computingthemeritfunction">Computing the merit function</a>
 <li><a href="#Findingasearchdirection">Finding a search direction</a><a
 href="#Findingasearchdirection">Finding a search direction</a>
 <li><a href="#Computingascaledstep">Computing a scaled step</a><a
 href="#Computingascaledstep">Computing a scaled step</a>
 <li><a href="#Checkingforconvergence">Checking for convergence</a><a
 href="#Checkingforconvergence">Checking for convergence</a>
 </ul>
 <li><a href="#Postprocessingthesolution">Postprocessing the solution</a><a
 href="#Postprocessingthesolution">Postprocessing the solution</a>
 <li><a href="#Therunfunctiondrivingtheoverallalgorithm">The run() function
 driving the overall algorithm</a><a
 href="#Therunfunctiondrivingtheoverallalgorithm">The run() function driving
 the overall algorithm</a>
 <li><a href="#Themainfunction">The main function</a><a
 href="#Themainfunction">The main function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#TestProblem">Test Problem</a><a href="#TestProblem">Test
 Problem</a>
 <ul>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>Topology Optimization of Elastic Media is a technique used to optimize astructure that is bearing some load. Ideally, we would like to minimize themaximum stress placed on a structure by selecting a region \(E\) where material isplaced. In other words, </p><p class="formulaDsp">
\[ \text{minimize}\| \boldsymbol{\sigma} (\mathbf{u}) \|_\infty \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } |E|\leq V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0}. \]
</p>
<p> Here, \(\boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon}(\mathbf{u})\) is the stresswithin the body that is caused by the external forces \(\mathbf F\) , where we have for simplicity assumedthat the material is linear-elastic and so \(\mathbf{C}\) is the stress-strain tensor and \(\boldsymbol{\varepsilon}(\mathbf{u})=\frac{1}{2} (\nabla \mathbf{u} + (\nabla\mathbf{u})^T)\) is thesmall-deformation strain as a function of the displacement \(\mathbf{u}\)</p>
<ul>
<li>see <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a> for more on linear elasticity. In the formulation above, \(V_\text{max}\) is the maximal amount of material we are willing to provide tobuild the object. The last of the constraints is the partial differentialequation that relates stress \(\boldsymbol{\sigma}\) and forces \(\mathbf F\) and is simply thesteady-state force balance. That said, the infinity norm above creates a problem: As a function of locationof material, this objective function is necessarily not differentiable, makingprospects of optimization rather bleak. So instead, a common approach intopology optimization is to find an approximate solution by optimizing a relatedproblem: We would like to minimize the strain energy. This is ameasure of the potential energy stored in an object due to its deformation, butalso works as a measure of total deformation over the structure. <p class="formulaDsp">
\[ \text{minimize } \int_E \frac{1}{2}\boldsymbol{\sigma} : \boldsymbol{\varepsilon} dV \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \|E\| \leq V_{\max} \]
</p>
 <p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} \]
</p>
 The value of the objective function is calculated using a finite element method,where the solution is the displacements. This is placed inside of a nonlinearsolver loop that solves for a vector denoting placement of material. <a class="anchor" id="SolidIsotropicMaterialwithPenalization"></a><h3>Solid Isotropic Material with Penalization</h3>
</li>
</ul>
<p>In actual practice, we can only build objects in which the material is eitherpresent, or not present, at any given point</p>
<ul>
<li>i.e., we would have an indicatorfunction \(\rho_E(\mathbf{x})\in \{0,1\}\) that describes the material-filledregion and that we want to find through the optimization problem. In this case,the optimization problem becomes combinatorial, and very expensive to solve.Instead, we use an approach called Solid Isotropic Material with Penalization,or SIMP. <b>[Bendse2004]</b> The SIMP method is based on an idea of allowing the material to exist in alocation with a density \(\rho\) between 0 and 1. A density of 0 suggests thematerial is not there, and it is not a part of the structure, while a density of1 suggests the material is present. Values between 0 and 1 do not reflect adesign we can create in the real-world, but allow us to turn the combinatorialproblem into a continuous one. One then looks at density values \(\rho\) ,with the constraint that \(0 &lt; \rho_{\min} \leq \rho \leq 1\) . The minimum value \(\rho_{\min}\) , typically chosen to be around \(10^{-3}\) , avoids the possibilityof having an infinite strain energy, but is small enough to provide accurateresults. The straightforward application of the effect of this "density" on theelasticity of the media would be to simply multiply the stiffness tensor \(\mathbf{C}_0\) of the medium by the given density, that is, \(\mathbf{C} = \rho \mathbf{C}_0\) . However, thisapproach often gives optimal solutions where density values are far from both 0and 1. As one wants to find a real-world solution, meaning the material eitheris present or it is not, a penalty is applied to these in-between values. Asimple and effective way to do this is to multiply the stiffness tensor by thedensity raised to some integer power penalty parameter \(p\) , so that \(\mathbf{C} = \rho^p \mathbf{C}_0\) . This makes density values farther away from 0 or 1 lesseffective. It has been shown that using \(p=3\) is sufficiently high to create'black-and-white' solutions: that is, one gets optimal solutions in whichmaterial is either present or not present at all points. More material should always provide a structure with a lower strain energy, and so theinequality constraint can be viewed as an equality where the total volume usedis the maximum volume. Using this density idea also allows us to reframe the volume constraint on theoptimization problem. Use of SIMP then turns the optimization problem into thefollowing: <p class="formulaDsp">
\[ \text{minimize } \int_\Omega \frac{1}{2}\boldsymbol{\sigma}(\rho) : \boldsymbol{\varepsilon}(\rho) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \int_\Omega \rho(x) d\Omega= V_{\max}, \]
</p>
 <p class="formulaDsp">
\[ 0&lt;\rho_{\min}\leq \rho(x) \leq 1, \]
</p>
 <p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma}(\rho) + \mathbf{F} = 0 \quad \text{on } \Omega \]
</p>
 final constraint, the balance of linear momentum (which we will refer to as the elasticity equation), gives a method for finding \(\boldsymbol{\sigma}\) and \(\boldsymbol{\varepsilon}\) given the density \(\rho\) . <a class="anchor" id="ElasticityEquation"></a><h3>Elasticity Equation</h3>
</li>
</ul>
<p>The elasticity equation in the time independent limit reads </p><p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} . \]
</p>
<p> the situations we will care about, we will assume that the medium has a linear material responseand in that case, we have that </p><p class="formulaDsp">
\[ \boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon} = \rho^p \mathbf{C}_0 : \boldsymbol{\varepsilon}(\mathbf{u}) = \rho^p \mathbf{C}_0 : \left[\frac{1}{2} (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) \right] . \]
</p>
<p> everything we will do below, we will always consider the displacementfield \(\mathbf{u}\) as the only solution variable, rather than considering \(\mathbf{u}\) and \(\boldsymbol{\sigma}\) as solution variables (as is done in mixedformulations). Furthermore, we will make the assumption that the material is linear isotropic,in which case the stress-strain tensor can be expressed in terms of the Lam&eacute;parameters \(\lambda,\mu\) such that </p><p class="formulaDsp">
\begin{align} \boldsymbol{\sigma} &amp;= \rho^p (\lambda \text{tr}(\boldsymbol{\varepsilon}) \mathbf{I} + 2 \mu \boldsymbol{\varepsilon}) , \\ \sigma_{i,j} &amp;= \rho^p (\lambda \varepsilon_{k,k} \delta_{i,j} + 2 \mu \varepsilon_{i,j}) . \end{align}
</p>
<p> See <a class="el" href="step_8.html">step-8</a> for how this transformation works. Integrating the objective function by parts gives </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u}))^T d\Omega+ \int_\Omega (\nabla \cdot \boldsymbol{\sigma}(\rho)) \cdot \mathbf{u} d\Omega= \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega , \]
</p>
<p> which the linear elasticity equation can then be substituted, giving </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_\Omega \mathbf{F}\cdot \mathbf{u} d\Omega+ \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega . \]
</p>
<p> we are assuming no body forces, this simplifies further to </p><p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega, \]
</p>
<p> is the final form of the governing equation that we'll be consideringfrom this point forward. <a class="anchor" id="Makingthesolutionmeshindependent"></a></p><h3>Making the solution mesh-independent</h3>
<p>Typically, the solutions to topology optimization problems aremesh-dependent, and as such the problem is ill-posed. This is becausefractal structures are often formed as the mesh is refined further. As the mesh gainsresolution, the optimal solution typically gains smaller and smaller structures.There are a few competing workarounds to this issue, but the most popular forfirst order optimization is the sensitivity filter, while second orderoptimization methods tend to prefer use of a density filter. As the filters affect the gradient and Hessian of the strain energy (i.e., theobjective function), the choice of filter has an effect on the solution of theproblem. The density filter as part of a second order method works byintroducing an unfiltered density, which we refer to as \(\varrho\) , and thenrequiring that the density be a convolution of the unfiltered density: </p><p class="formulaDsp">
\[ \rho = H(\varrho). \]
</p>
<p>, \(H\) is an operator so that \(\rho(\mathbf{x})\) is some kind of average ofthe values of \(\varrho\) in the area around \(\mathbf{x}\)</p>
<ul>
<li>i.e., it is a smoothedversion of \(\varrho\) . This prevents checkerboarding; the radius of the filter allows the user todefine an effective minimal beam width for the optimal structures we seek tofind. <div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.checkerboard.png" alt="Checkerboarding occurring in an MBB Beam"/>
</div>
 </div></li>
</ul>
<p><a class="anchor" id="CompleteProblemFormulation"></a></p><h3>Complete Problem Formulation</h3>
<p>The minimization problem is now </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega= V \]
</p>
 <p class="formulaDsp">
\[ 0\leq \varrho \leq 1 \]
</p>
<p>The inequality constraints are dealt with by first introducing slack variables, and second using log barriers to ensure that we obtain an interior-point method. The penalty parameter is going to be \(\alpha\), and the following slack variables are </p><ol>
<li>
<p class="startli">\(s_1\)</p>
<ul>
<li>a slack variable corresponding to the lower bound </li>
</ul>
</li>
<li>
<p class="startli">\(s_2\)</p>
<ul>
<li>a slack variable corresponding to the upper bound. </li>
</ul>
</li>
</ol>
<p>This now gives the following problem: </p><p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}, s_1, s_2} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega \]
</p>
 <p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega \rho d\Omega = V \]
</p>
 <p class="formulaDsp">
\[ \varrho = s_1 \]
</p>
 <p class="formulaDsp">
\[ 1-\varrho = s_2 \]
</p>
<p>With these variables in place, we can then follow the usual approach to solving constrained optimization problems: We introduce a Lagrangian in which we combine the objective function and the constraints by multiplying the constraints by Lagrange multipliers. Specifically, we will use the following symbols for the Lagrange multipliers for the various constraints: </p><ol>
<li>
\(\mathbf{y}_1 \): a Lagrange multiplier corresponding to the elasticity constraint,  </li>
<li>
\(y_2\): a Lagrange multiplier corresponding to the convolution filter constraint,  </li>
<li>
\(z_1\): a Lagrange multiplier corresponding to the lower slack variable, and  </li>
<li>
\(z_2\): a Lagrange multiplier corresponding to the upper slack variable.  </li>
</ol>
<p>With these variables, the Lagrangian function reads as follows:</p>
<p class="formulaDsp">
\begin{align} \mathcal{L} =&amp; \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega - \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega- \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{y}_1):\boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_1 \right)\right) d\Omega - \int_{\partial \Omega} \mathbf{y}_1 \cdot \mathbf{t} d\partial\Omega \\ &amp; -\int_\Omega y_2 (\rho - H(\varrho)) d\Omega - \int_\Omega z_1 (\varrho-s_1) d\Omega - \int_\Omega z_2 (1 - s_2 -\varrho) d\Omega \end{align}
</p>
<p>The solution of the optimization problem then needs to satisfy what are known as the <a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">Karush-Kuhn-Tucker (KKT) conditions</a>: The derivatives of the Lagrangian with respect to all of its arguments need to be equal to zero, and because we have inequality constraints, we also have "complementarity" conditions. Since we here have an infinite-dimensional problem, these conditions all involve directional derivatives of the Lagrangian with regard to certain test functions</p>
<p>&ndash; in other words, all of these conditions have to be stated in weak form as is typically the basis for finite element methods anyway.</p>
<p>The barrier method allows us to initially weaken the "complementary
 slackness" as required by the typical KKT conditions. Typically, we would require that \(s_i z_i = 0\), but the barrier formulations give KKT conditions where \(s_i z_i = \alpha\), where \(\alpha\) is our barrier parameter. As part of the barrier method, this parameter must be driven close to 0 to give a good approximation of the original problem.</p>
<p>In the following, let us state all of these conditions where \(d_{\{\bullet\}}\) is a test function that is naturally paired with variational derivatives of the Lagrangian with respect to the \(\{\bullet\}\) function. For simplicity, we introduce \(\Gamma\) to indicate the portion of the boundary where forces are applied, and Neumann boundary conditions are used.</p>
<ol>
<li>
Stationarity: <p class="formulaDsp">
\[ \int_\Omega - d_\rho y_2 + p\rho^{p-1}d_\rho \left[\lambda (\nabla \cdot \mathbf{y}_1) (\nabla \cdot \mathbf{u}) + \mu \boldsymbol{\varepsilon}(\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall d_\rho \]
</p>
 <p class="formulaDsp">
\[ \int_\Gamma \mathbf d_\mathbf{u} \cdot \mathbf{t} d\partial\Omega+ \int_\Omega p\rho^{p} \left[\lambda (\nabla \cdot \mathbf d_\mathbf{u})( \nabla \cdot \mathbf{y}_1) + \mu \boldsymbol{\varepsilon}(\mathbf d_\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall \mathbf{d}_\mathbf{u} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega= 0\;\;\forall d_\varrho \]
</p>
  </li>
<li>
Primal Feasibility: <p class="formulaDsp">
\[ \int_\Omega \rho^{p}\lambda (\nabla \cdot \mathbf d_{\mathbf{y}_1}) (\nabla \cdot \mathbf{u}) + \rho^{p}\mu \boldsymbol{\varepsilon}(\mathbf d_{\mathbf{y}_1}) : \boldsymbol{\varepsilon}(\mathbf{u}) d\Omega - \int_\Gamma \mathbf d_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega =0 \;\;\forall \mathbf{d}_{\mathbf{y}_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_1}(\varrho - s_1) d\Omega = 0\;\;\forall d_{z_1} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{z_z}(1-\varrho-s_2) d\Omega = 0\;\;\forall d_{z_2} \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{y_2}(\rho - H(\varrho)) d\Omega = 0\;\;\forall d_{y_2} \]
</p>
  </li>
<li>
Complementary Slackness: <p class="formulaDsp">
\[ \int_\Omega d_{s_1}(s_1z_1 - \alpha) d\Omega = 0 \;\;\forall d_{s_1} ,\;\;\; \alpha \to 0 \]
</p>
 <p class="formulaDsp">
\[ \int_\Omega d_{s_2}(s_2z_2 - \alpha) d\Omega = 0 \;\;\forall d_{s_2} ,\;\;\; \alpha \to 0 \]
</p>
  </li>
<li>
Dual Feasibility: <p class="formulaDsp">
\[ s_{1,i},s_{2,i},z_{1,i},z_{2,i} \geq 0 \;\;\;\; \forall i \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Solutionprocedure"></a></p><h3>Solution procedure</h3>
<p>The optimality conditions above are, in addition to being convoluted, of a kind that is not easy to solve: They are generally nonlinear, and some of the relationships are also inequalities. We will address the nonlinearity using a Newton method to compute search directions, and come back to how to deal with the inequalities below when talking about step length procedures.</p>
<p>Newton's method applied to the equations above results in the system of equations listed below. Therein, variational derivatives with respect to the \(\{\bullet\}\) variable are taken in the \(c_{\{\bullet\}}\) direction.</p>
<ol>
<li>
<p class="startli">Stationarity: These equations ensure we are at a critical point of the objective function when constrained.</p>
<p>Equation 1</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega-d_\rho c_{y_2} + p(p-1) \rho^{p-2} d_\rho c_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] + p \rho^{p-1} d_\rho[\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] + p \rho^{p-1} d_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \\ &amp;= -\int_\Omega -d_\rho z_1 + d_\rho z_2 - d_\rho y_2 + p\rho^{p-1}d_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 2</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y})] + \rho^{p} [\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Gamma \mathbf{d}_\mathbf{u} \cdot \mathbf{t} -\int_\Omega \rho^{p} [\lambda \nabla \cdot \mathbf{y} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(d_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>Equation 3 </p><p class="formulaDsp">
\[ \int_\Omega - d_\varrho c_{z_1} +d_\varrho c_{z_2} + H(d_\varrho)c_{y_2} d\Omega = -\int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Primal Feasibility: These equations ensure the equality constraints are met.</p>
<p>Equation 4</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_p[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] + \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Omega \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon} (\mathbf{d}_{\mathbf{y}_1})] + \int_\Gamma \mathbf{d}_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega \end{align}
</p>
<p>Equation 5 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_1}(c_\varrho - c_{s_1}) d\Omega=\int_\Omega d_{z_1} (\varrho - s_1) d\Omega \]
</p>
<p>Equation 6 </p><p class="formulaDsp">
\[ -\int_\Omega d_{z_2}(-c_\varrho-c_{s_2}) d\Omega= \int_\Omega d_{z_2} (1-\varrho-s_2) d\Omega \]
</p>
<p>Equation 7 </p><p class="formulaDsp">
\[ -\int_\Omega d_{y_2}(c_\rho - H(c_\varrho)) d\Omega=\int_\Omega d_{y_2} (\rho - H(\varrho)) d\Omega \]
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Complementary Slackness: These equations essentially ensure the barrier is met</p>
<ul>
<li>in the final solution, we need \(s^T z = 0\).</li>
</ul>
<p>Equation 8 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_1}(c_{s_1}z_1/s_1 + c_{z_1} ) d\Omega=-\int_\Omega d_{s_1} (z_1 - \alpha/s_1) d\Omega ,\;\;\; \alpha \to 0 \]
</p>
<p>Equation 9 </p><p class="formulaDsp">
\[ \int_\Omega d_{s_2} (c_{s_2}z_2/s_2 + c_{z_2} ) d\Omega=-\int_\Omega d_{s_2} (z_2 - \alpha/s_2) d\Omega,\;\;\; \alpha \to 0 \]
</p>
 <p class="endli"></p>
</li>
<li>
Dual Feasibility: The Lagrange multiplier on slacks and slack variables must be kept greater than 0. (This is the only part not implemented in the <code>SANDTopOpt::assemble_system()</code> function.) <p class="formulaDsp">
\[ s,z \geq 0 \]
</p>
  </li>
</ol>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p>We use a quadrilateral mesh with \(Q_1\) elements to discretize the displacement and displacement Lagrange multiplier. Piecewise constant \(DGQ_0\) elements are used to discretize the density, unfiltered density, density slack variables, and multipliers for the slack variables and filter constraint.</p>
<p><a class="anchor" id="NonlinearAlgorithm"></a></p><h3>Nonlinear Algorithm</h3>
<p>While most of the discussion above follows traditional and well-known approaches to solving nonlinear optimization problems, it turns out that the problem is actually quite difficult to solve in practice. In particular, it is quite nonlinear and an important question is not just to find search directions \(c_{\{\bullet\}}\) as discussed above based on a Newton method, but that one needs to spend quite a lot of attention to how far one wants to go in this direction. This is often called "line search" and comes down to the question of how to choose the step length \(\alpha_k \in (0,1]\) so that we move from the current iterate \(\mathbf{x}_k\) to the next iterate \(\mathbf{x}_{k+1}=\mathbf{x}_k+\alpha_k \mathbf{x}_k\) in as efficient a way as possible. It is well understood that we need to eventually choose \(\alpha_k=1\) to realize the Newton's method's quadratic convergence; however, in the early iterations, taking such a long step might actually make things worse, either by leading to a point that has a worse objective function or at which the constraints are satisfied less well than they are at \(\mathbf{x}_k\).</p>
<p>Very complex algorithms have been proposed to deal with this issue <b>[Nocedal2009]</b> <b>[Waechter2005]</b>. Here, we implement a watchdog-search algorithm <b>[Nocedal2006]</b>. When discussing this algorithm, we will use the vector \(\mathbf{x}\) to represent all primal variables</p>
<ul>
<li>the filtered and unfiltered densities, slack variables and displacement</li>
<li>and use the vector \(\mathbf{y}\) to represent all of the dual vectors. The (incremental) solution to the nonlinear system of equations stated above will now be referred to as \(\Delta \mathbf{x}\) and \(\Delta \mathbf{y}\) instead of \(c_{\{\bullet\}}\). A merit function (explained in more detail later) is referred to here as \(\phi(\mathbf{x,\mathbf{y}})\).</li>
</ul>
<p>The watchdog algorithm applied to a subproblem with a given barrier parameter works in the following way: First, the current iteration is saved as a "watchdog" state, and the merit of the watchdog state is recorded. A maximal feasible Newton step is then taken. If the merit sufficiently decreased from the first step, this new step is accepted. If not, another maximal feasible Newton step is taken, and the merit is again compared to the watchdog merit. If after some number (typically between 5 and 8) of Newton steps, the merit did not adequately decrease, the algorithm takes a scaled Newton step from either the watchdog state or the last iteration that guarantees a sufficient decrease of the merit, and that step is accepted. Once a step is accepted, the norm of the KKT error is measured, and if it is sufficiently small, the barrier value is decreased. If it is not sufficiently small, the last accepted step is taken to be the new watchdog step, and the process is repeated.</p>
<p>Above, the "maximal feasible step" is a scaling of the Newton step in both the primal and dual variables given by</p>
<p class="formulaDsp">
\[ \beta^\mathbf{y} = \min\{1,\max \beta \text{ such that }\left(\mathbf{z}_{k+i} + \beta^\mathbf{z}_{k+i} \Delta \mathbf{z}_{k+i}\right)_j \geq \zeta \mathbf{z}_{k+i,j} \forall j\} \]
</p>
 <p class="formulaDsp">
\[ \beta^\mathbf{x} = \min\{1,\max \beta \text{ such that }\left(\mathbf{s}_{k+i} + \beta^\mathbf{s}_{k+i} \Delta \mathbf{s}_{k+i}\right)_j \geq \zeta \mathbf{s}_{k+i,j} \forall j\} \]
</p>
<p>Above, \(\zeta\) is the "fraction to boundary" that is allowed on any step. Because the derivatives become ill-conditioned near the boundary, this technique stands in for a <a href="https://en.wikipedia.org/wiki/Trust_region">trust region</a> and is necessary to ensure good approximations in the future. \(\zeta\) is taken to be \(\max\{0.8, 1-\alpha\}\), which allows movement closer to the boundary as the barrier becomes smaller. In the future, when implementing the LOQO algorithm for barrier reduction, this must be kept to 0.8 as the barrier parameter can vary wildly.</p>
<p>Separately, we need to deal with the log-barrier that we have used to enforce the positivity constraint on the slack variables \(s_1,s_2\): In the statement of the final optimization problem we solve, we have added the term </p><p class="formulaDsp">
\[ -\alpha \int_\Omega (\log(s_1) + \log(s_2)) d\Omega. \]
</p>
<p> The question is how we should choose the penalty factor \(\alpha\). As with all penalty methods, we are in reality only interested in the limit as \(\alpha\to 0\), since this is then the problem we really wanted to solve, subject to the positivity constraints on the slack variables. On the other hand, we need to choose \(\alpha\) large enough to make the problem solvable in practice. Actual implementations therefore start with a larger value of \(\alpha\) and gradually decrease it as the outer iterations proceed.</p>
<p>In the monotone method implemented here, the barrier parameter is updated whenever some level of convergence is achieved at the current barrier parameter. We use the \(l_\infty\) norm of the KKT conditions to check for convergence at each barrier size. The requirement is that \(\|KKT\|_{l_\infty} &lt; c \cdot \alpha\) where \(c\) is a constant over any barrier size and \(\alpha\) is the barrier parameter. This forces better convergence in later iterations, and is the same requirement as is used in <a href="https://coin-or.github.io/Ipopt/">IPOPT</a> (an open source software package for large-scale nonlinear optimization).</p>
<p>Here, the barrier is reduced linearly at larger values, and superlinearly at smaller values. At larger values, it is multiplied by a constant (around 0.6), and at lower values the barrier value is replaced by the barrier value raised to some exponent (around 1.2). This method has proven to be effective at keeping the subproblem solvable at large barrier values, while still allowing superlinear convergence at smaller barrier values. In practice, this looks like the following: </p><p class="formulaDsp">
\[ \alpha_{k+1} = \min\{\alpha_k^{1.2},0.6\alpha_k\} \]
</p>
<p>While taking large steps at reducing the barrier size when convergence is reached is widely used, more recent research has shown that it is typically faster to use algorithms that adaptively update barrier each iteration, i.e., methods in which we use concrete criteria at the end of each iteration to determine what the penalty parameter should be in the next iteration, rather than using reduction factors that are independent of the current solution. That said, such methods are also more complicated and we will not do this here.</p>
<p><a class="anchor" id="MeritFunction"></a></p><h3>Merit Function</h3>
<p>The algorithm outlined above makes use of a "merit function". Merit functions are used to determine whether a step from \(x_k\) to a proposed point \(x_{k+1}\) is beneficial. In unconstrained optimization problems, one can simply check this with the objective function we try to minimize, and typically uses conditions such as the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe and Goldstein conditions</a>.</p>
<p>In constrained optimization problems, the question is how to balance reduction in the objective function against a possible increase in the violation of constraints: A proposed step might make the objective function smaller but be further away from the set of points that satisfy the constraints</p>
<p>&ndash; or the other way around. This trade-off is typically resolved by using a merit function that combines the two criteria.</p>
<p>Here, we use an exact \(l_1\) merit function to test the steps:</p>
<p class="formulaDsp">
\begin{align} \phi(\mathbf{x},\mathbf{y}) =&amp; \int_{\partial \Omega} \mathbf{u}\cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega (\log(s_1) + \log(s_2)) + p \sum_i\left| \int_\Omega y_{2,i}(H(\varrho) - \rho) d\Omega \right| \\ &amp; + p \sum_i\left| \int_{\partial \Omega} \mathbf{y}_{1,i}\cdot \mathbf{t} d\partial\Omega - \int_\Omega \rho^p[\lambda \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_{1,i} + \mu \boldsymbol{\varepsilon}{\mathbf{u}}\boldsymbol{\varepsilon}{\mathbf{y}_{1,i}}] d\Omega \right| + p \sum_i\left| \int_\Omega z_{1,i}(s_1 - \varrho) d\Omega\right| + p \sum_i\left| \int_\Omega z_{2,i}(1-\varrho - s_2) d\Omega\right| \end{align}
</p>
<p>Here, \(p\) is a penalty parameter. This merit function being exact means that there exists some \(p_0\) so that for any \(p &gt; p_0\), the merit function has its minima at the same location as the original problem. This penalty parameter is updated (by recommendation of Nocedal and Wright <b>[Benson2002]</b>) as follows: </p><p class="formulaDsp">
\[ p &gt; \frac{\frac{1}{2} \mathbf{x}^T \cdot \mathbf{H} \cdot \mathbf{x} - \mathbf{x}^T \cdot \nabla f}{\|c_i\|_{l_\infty}} \quad , i \in \mathcal{E}, \]
</p>
<p> where \(\mathbf{H}\) is the Hessian of the objective function, \(\mathbf{x}\) is a vector of our decision (primal) variables, \(f\) is the objective function, and \(c_i\) is the error on a current equality constraint.</p>
<p>Our use of this method is partially due to already having most of the necessary parts calculated in finding the right hand side, but also the use of an exact merit function ensures that it is minimized in the same location as the overall problem. Recent research has shown that one can replace merit functions by what are called "filter methods", and one should consider using these instead as they prove to be more efficient.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Preliminaries"></a> </p><h3>Preliminaries</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div></div><!-- fragment --><p>Above are fairly common files to include. These also include the one for the sparse direct class <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>. This is not the most efficient way to solve large linear problems, but it will do for now.</p>
<p>As usual, we put everything into a common namespace. We then start by declaring a number of symbolic names for constants that will be used throughout this tutorial. Specifically, we have alot* of variables in this program (of course the density and the displacement, but also the unfiltered density and quite a number of Lagrange multipliers). It is easy to forget which of these variables is at which position in the solution vector, and trying to use numbers for these vector components is a prescription for bugs. Rather, we define static variables that can be used in all of these places and that have to be initialized only once. In practice, this will lead to some lengthy expressions, but they are more readable and less likely to be wrong.</p>
<p>A similar issue arises with the ordering of blocks in the system matrix and in vectors. The matrices have \(9\times 9\) blocks, and it's difficult to remember which is which. It is far easier to just use symbolic names for those as well.</p>
<p>Finally, while we're at it, we introduce symbolic names also for the boundary indicators we will use, in the same spirit as was done in <a class="el" href="step_19.html">step-19</a>.</p>
<p>In all of these cases, we declare these variables as members in a namespace. In the case of the solution components, the concrete values of these variables depend on the space dimension, so we use <a href="https://en.cppreference.com/w/cpp/language/variable_template">template variables</a> to make the value of the variable depend on a template argument in the same way as we often use template functions.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>This namespace keeps track of the first component in our finite element system that corresponds to each variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionComponents</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 dim;</div><div class="line">} <span class="comment">// namespace SolutionComponents</span></div></div><!-- fragment --><p>This is the namespace which keeps track of which block corresponds to which variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionBlocks</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">} <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>BoundaryIds</div><div class="line">{</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">} <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ValueExtractors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">    displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">    SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">    SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">    SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">    SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">} <span class="comment">// namespace ValueExtractors</span></div></div><!-- fragment --><p><a class="anchor" id="TheSANDTopOptmainclass"></a> </p><h3>The SANDTopOpt main class</h3>
<p>Next up is the main class for this problem. The majority of functions follow the usual naming schemes of tutorial programs, though there are a couple that have been broken out of what is usually called the <code>setup_system()</code> function because of their length, and there are also a number that deal with various aspects of the optimization algorithm.</p>
<p>As an added bonus, the program writes the computed design as an STL file that one can, for example, send to a 3d printer.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SANDTopOpt</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SANDTopOpt();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Most of the member variables are also standard. There are, however, a number of variables that are specifically related to the optimization algorithm (such the various scalar factors below) as well as the filter matrix to ensure that the design remains smooth.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">  <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">  <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h3>Constructor and set-up functions</h3>
<p>We initialize a <a class="el" href="classFESystem.html">FESystem</a> composed of 2 \(\times\)dim <code><a class="el" href="classFE__Q.html">FE_Q(1)</a></code> elements for the displacement variable and its Lagrange multiplier, and 7 <code><a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a></code> elements. These piecewise constant functions are for density-related variables: the density itself, the unfiltered density, the slack variables for the lower and upper bounds on the unfiltered density, and then Lagrange multipliers for the connection between filtered and unfiltered densities as well as for the inequality constraints.</p>
<p>The order in which these elements appear is documented above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       5)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , density_ratio(.5)</div><div class="line">  , density_penalty_exponent(3)</div><div class="line">  , filter_r(.251)</div><div class="line">  , penalty_multiplier(1)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p>The first step then is to create the triangulation that matches the problem description in the introduction</p>
<p>&ndash; a 6-by-1 rectangle (or a 6-by-1-by-1 box in 3d) where a force will be applied in the top center. This triangulation is then uniformly refined a number of times.</p>
<p>In contrast to nearly the entire rest of this program, this function specifically assumes that we are in 2d and will require changes if we wanted to move to 3d simulations. We ensure that nobody tries to accidentally run in 3d without such modifications through an assertion at the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            {6, 1},</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">  triangulation.refine_global(3);</div></div><!-- fragment --><p>The second step is to apply boundary indicators to parts of the boundary. The following code assigns boundary indicators to the bottom, top, left, and right boundaries of the box, respectively. The center region of the top boundary is given a separate boundary indicator: This is where we will apply the down force.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1)</div><div class="line"></div><div class="line">- 1) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0)</div><div class="line"></div><div class="line">- 3) &lt; .3))</div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the constraints due to boundary values. The bottom corners of the domain are kept in place in the \(y\) direction</p>
<p>&ndash; the bottom left also in the \(x\) direction. deal.II generally thinks of boundary values as attached to pieces of the boundary, i.e., faces, rather than individual vertices. Indeed, mathematically speaking, one can not assign boundary values to individual points for the infinite-dimensional partial differential equation. But, since we are trying to reproduce a widely used benchmark, we will do so anyway and keep in mind that we have a finite-dimensional problem for which imposing boundary conditions at a single node is valid.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">{</div><div class="line">  boundary_values.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div></div><!-- fragment --><p>Check whether the current face is on the bottom boundary, and if it is whether one of its vertices might be the bottom left or bottom right vertex:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[x_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line"></div><div class="line">                      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0)</div><div class="line"></div><div class="line">- 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                               <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1)</div><div class="line"></div><div class="line">- 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Settingupblockmatricesandvectors"></a> </p><h3>Setting up block matrices and vectors</h3>
<p>The next function makes a giant 9-by-9 block matrix, and also sets up the necessary block vectors. The sparsity pattern for this matrix includes the sparsity pattern for the filter matrix. It also initializes any block vectors we will use.</p>
<p>Setting up the blocks by themselves is not overly complicated and follows what is already done in programs such as <a class="el" href="step_22.html">step-22</a>, for example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">  block_component[0] = 0;</div><div class="line">  block_component[1] = 1;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">    n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">      dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">  dsp.collect_sizes();</div></div><!-- fragment --><p>The bulk of the function is in setting up which of these blocks will actually contain anything, i.e., which variables couple with which other variables. This is cumbersome but necessary to ensure that we don't just allocate a very large number of entries for our matrix that will then end up being zero.</p>
<p>The concrete pattern you see below is something one probably has to draw once on a piece of paper, but follows in an otherwise relatively straightforward way from looking through the many terms of the bilinear form we will have to assemble in each nonlinear iteration.</p>
<p>The use of the symbolic names defined in namespace <code>SolutionComponents</code> helps understand what each of the following terms corresponds to, but it also makes the expressions lengthy and unwieldy: A term such as <code>coupling[SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;][SolutionComponents::density&lt;dim&gt;]</code> just doesn't read very well, and would either have to be split over several lines or run off the right edge of nearly every screen. As a consequence, we open a curly-brace enclosed code block in which we temporarily make the names in namespace <code>SolutionComponents</code> available without the namespace qualifier, by saying <code>using namespace SolutionComponents</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 dim + 7, 2 dim + 7);</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for displacement</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">        {</div><div class="line">          coupling[displacement&lt;dim&gt; + i]</div><div class="line">                  [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                  [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Coupling for slack variables</span></div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">}</div></div><!-- fragment --><p>Before we can create the sparsity pattern, we also have to set up constraints. Since this program does not adaptively refine the mesh, the only constraint we have is one that couples all density variables to enforce the volume constraint. This will ultimately lead to a dense sub-block of the matrix, but there is little we can do about that.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">    fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">  <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">    density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>()</div><div class="line"></div><div class="line">- 1);</div><div class="line">  constraints.clear();</div><div class="line">  constraints.add_line(last_density_dof);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>()</div><div class="line"></div><div class="line">- 1; ++i)</div><div class="line">    constraints.add_entry(last_density_dof,</div><div class="line">                          density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1);</div><div class="line">  constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">  constraints.close();</div></div><!-- fragment --><p>We can now finally create the sparsity pattern for the matrix, taking into account which variables couple with which other variables, and the constraints we have on the density.</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div></div><!-- fragment --><p>The only part of the matrix we have not dealt with is the filter matrix and its transpose. These are non-local (integral) operators for which deal.II does not currently have functions. What we will ultimately need to do is go over all cells and couple the unfiltered density on this cell to all filtered densities of neighboring cells that are less than a threshold distance away, and the other way around; for the moment, we are only concerned with building the sparsity pattern that would correspond to this kind of matrix, so we perform the equivalent loop and where later on we would write into an entry of the matrix, we now simply add an entry to the sparsity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Having so generated the "dynamic" sparsity pattern, we can finally copy it to the structure that is used to associate matrices with a sparsity pattern. Because the sparsity pattern is large and complex, we also output it into a file of its own for visualization purposes</p>
<p>&ndash; in other words, for "visual debugging".</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>What is left is to correctly size the various vectors and their blocks, as well as setting initial guesses for some of the components of the (nonlinear) solution vector. We here use the symbolic component names for individual blocks of the solution vector and, for brevity, use the same trick with <code>using namespace</code> as above:</p>
<div class="fragment"><div class="line">  nonlinear_solution.reinit(block_sizes);</div><div class="line">  system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">    nonlinear_solution.block(density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">      .add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">    nonlinear_solution.block(density_upper_slack).add(1</div><div class="line"></div><div class="line">- density_ratio);</div><div class="line">    nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefiltermatrix"></a> </p><h3>Creating the filter matrix</h3>
<p>Next up, a function that is used once at the beginning of the program: It creates a matrix \(H\) so that the filtered density vector equals \(H\) times the unfiltered density. The creation of this matrix is non-trivial, and it is used in every iteration, and so rather than reforming it as we do with the Newton matrix, it is made only once and stored separately.</p>
<p>The way this matrix is computed follows the outline used above already to form its sparsity pattern. We repeat this process here for the sparsity pattern of this separately formed matrix, and then actually build the matrix itself. You may want to check the definition of this matrix in the introduction to this program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">{</div></div><!-- fragment --><p>The sparsity pattern of the filter has already been determined and implemented in the setup_system() function. We copy the structure from the appropriate block and use it again here.</p>
<div class="fragment"><div class="line">filter_sparsity_pattern.copy_from(</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">filter_matrix.reinit(filter_sparsity_pattern);</div></div><!-- fragment --><p>Having so built the sparsity pattern, now we re-do all of these loops to actually compute the necessary values of the matrix entries:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">            cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">          <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">            {</div><div class="line">              filter_matrix.add(i,</div><div class="line">                                check_cell-&gt;active_cell_index(),</div><div class="line">                                filter_r</div><div class="line"></div><div class="line">- distance);</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>The final step is to normalize the matrix so that for each row, the sum of entries equals one.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> denominator = 0;</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        denominator = denominator + iter-&gt;value();</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function is used for building the filter matrix. We create a set of all the cell iterators within a certain radius of the cell that is input. These are the neighboring cells that will be relevant for the filter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">  neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">  cells_to_check.insert(cell);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">           std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">             cells_to_check.begin(), cells_to_check.end()))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                    cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                  <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                      !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                    {</div><div class="line">                      cells_to_check.insert(neighbor);</div><div class="line">                      neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                      new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">  <span class="keywordflow">return</span> cells_to_check;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingtheNewtonmatrix"></a> </p><h3>Assembling the Newton matrix</h3>
<p>Whereas the setup_filter_matrix function built a matrix that is the same as long as the mesh does not change (which we don't do anyway in this program), the next function builds the matrix to be solved in each iteration. This is where the magic happens. The components of the system of linear equations describing Newton's method for finding the solution of the KKT conditions are implemented here.</p>
<p>The top of the function is as in most of these functions and just sets up all sorts of variables necessary for the actual assembly, including a whole bunch of extractors. The entire set up should look familiar, though somewhat lengthier, if you've previously looked at <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div></div><!-- fragment --><p>At this point, we apply the filter to the unfiltered density, and apply the adjoint (transpose) operation to the unfiltered density multiplier, both to the current best guess for the nonlinear solution. We use this later to tell us how far off our filtered density is from the filter applied to the unfiltered density. That is because while at the solution of the nonlinear problem, we have \(\rho=H\varrho\), but at intermediate iterations, we in general have \(\rho^k\neq H\varrho^k\) and the "residual" \(\rho^k-H\varrho^k\) will then appear as the right hand side of one of the Newton update equations that we compute below.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"></div><div class="line">filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                      SolutionBlocks::unfiltered_density),</div><div class="line">                    nonlinear_solution.block(</div><div class="line">                      SolutionBlocks::unfiltered_density));</div><div class="line">filter_matrix.Tvmult(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">  nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">  n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">  n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>ValueExtractors;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">    mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div></div><!-- fragment --><p>As part of the construction of our system matrix, we need to retrieve values from our current guess at the solution. The following lines of code retrieve the needed values.</p>
<div class="fragment"><div class="line">fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                              old_density_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_divs);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">  nonlinear_solution, old_displacement_symmgrads);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">  .get_function_symmetric_gradients(</div><div class="line">    nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_values);</div><div class="line">fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_values);</div><div class="line">fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filtered_unfiltered_density_solution,</div><div class="line">  filtered_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We need several more values corresponding to the test functions coming from the first derivatives taken from the Lagrangian, that is the \(d_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">      fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">      fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      displacement_multiplier_phi_i_symmgrad =</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">          i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                          q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">      fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                           q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div></div><!-- fragment --><p>Finally, we need values that come from the second round of derivatives taken from the Lagrangian, the \(c_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">  fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                   q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">  fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  displacement_multiplier_phi_j_symmgrad =</div><div class="line">    fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">      .symmetric_gradient(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">  fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">  fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">  fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">  fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">  fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div></div><!-- fragment --><p>This is where the actual work starts. In the following, we will build all of the terms of the matrix</p>
<p>&ndash; they are numerous and not entirely self-explanatory, also depending on the previous solutions and its derivatives (which we have already evaluated above and put into the variables called <code>old_*</code>). To understand what each of these terms corresponds to, you will want to look at the explicit form of these terms in the introduction above.</p>
<p>The right hand sides of the equations being driven to 0 give all the KKT conditions for finding a local minimum</p>
<p>&ndash; the descriptions of what each individual equation are given with the computations of the right hand side.</p>
<div class="fragment"><div class="line">                  <span class="comment">// Equation 1</span></div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point)</div><div class="line">                    (</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-density_phi_i unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                      + density_penalty_exponent</div><div class="line">                          (density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent</div><div class="line"></div><div class="line">- 2)</div><div class="line">                          density_phi_i density_phi_j</div><div class="line">                          (old_displacement_multiplier_divs[q_point]</div><div class="line">                             old_displacement_divs[q_point]</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (old_displacement_symmgrads[q_point]</div><div class="line">                              old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                      + density_penalty_exponent</div><div class="line">                          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                          density_phi_i</div><div class="line">                          (displacement_multiplier_phi_j_div</div><div class="line">                             old_displacement_divs[q_point]</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (old_displacement_symmgrads[q_point]</div><div class="line">                              displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                      + density_penalty_exponent</div><div class="line">                          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                          density_phi_i</div><div class="line">                          (displacement_phi_j_div</div><div class="line">                             old_displacement_multiplier_divs[q_point]</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (old_displacement_multiplier_symmgrads[q_point]</div><div class="line">                              displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 2</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (density_penalty_exponent</div><div class="line">                       <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                       density_phi_j</div><div class="line">                       (old_displacement_multiplier_divs[q_point]</div><div class="line">                          displacement_phi_i_div lambda_values[q_point] +</div><div class="line">                        2 mu_values[q_point]</div><div class="line">                          (old_displacement_multiplier_symmgrads[q_point]</div><div class="line">                           displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                     + <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                density_penalty_exponent)</div><div class="line">                         (displacement_multiplier_phi_j_div</div><div class="line">                            displacement_phi_i_div lambda_values[q_point] +</div><div class="line">                          2 mu_values[q_point]</div><div class="line">                            (displacement_multiplier_phi_j_symmgrad</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                    );</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 3, which has to do with the filter and which is calculated elsewhere.</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (-1 unfiltered_density_phi_i</div><div class="line">                       lower_slack_multiplier_phi_j +</div><div class="line">                     unfiltered_density_phi_i upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                  <span class="comment">// Equation 4: Primal feasibility</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (</div><div class="line"></div><div class="line">                      density_penalty_exponent</div><div class="line">                        <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                 density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                        density_phi_j</div><div class="line">                        (old_displacement_divs[q_point]</div><div class="line">                           displacement_multiplier_phi_i_div</div><div class="line">                           lambda_values[q_point] +</div><div class="line">                         2 mu_values[q_point]</div><div class="line">                           (old_displacement_symmgrads[q_point]</div><div class="line">                            displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      + <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(old_density_values[q_point],</div><div class="line">                                 density_penalty_exponent)</div><div class="line">                          (displacement_phi_j_div</div><div class="line">                             displacement_multiplier_phi_i_div</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 mu_values[q_point]</div><div class="line">                             (displacement_phi_j_symmgrad</div><div class="line">                              displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 5: Primal feasibility</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                    lower_slack_multiplier_phi_i</div><div class="line">                    (unfiltered_density_phi_j</div><div class="line"></div><div class="line">- lower_slack_phi_j);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 6: Primal feasibility</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                    upper_slack_multiplier_phi_i</div><div class="line">                    (-1 unfiltered_density_phi_j</div><div class="line"></div><div class="line">- upper_slack_phi_j);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 7: Primal feasibility</span></div><div class="line"></div><div class="line">- the part with the filter is added later</div><div class="line">                  cell_matrix(i, j) +=</div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                                       unfiltered_density_multiplier_phi_i</div><div class="line">                                       (density_phi_j);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 8: Complementary slackness</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (lower_slack_phi_i lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                     + lower_slack_phi_i lower_slack_phi_j</div><div class="line">                         old_lower_slack_multiplier_values[q_point] /</div><div class="line">                         old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                  <span class="comment">// Equation 9: Complementary slackness</span></div><div class="line">                  cell_matrix(i, j) +=</div><div class="line">                    fe_values.JxW(q_point)</div><div class="line">                    (upper_slack_phi_i upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                     + upper_slack_phi_i upper_slack_phi_j</div><div class="line">                         old_upper_slack_multiplier_values[q_point] /</div><div class="line">                         old_upper_slack_values[q_point]);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div></div><!-- fragment --><p>Now that we have everything assembled, all we have to do is deal with the effect of (Dirichlet) boundary conditions and other constraints. We incorporate the former locally with just the contributions from the current cell, and then let the AffineConstraint class deal with the latter while copying contributions from the current cell into the global linear system:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                           local_dof_indices,</div><div class="line">                                           cell_matrix,</div><div class="line">                                           dummy_cell_rhs,</div><div class="line">                                           <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Having accumulated all of the terms that belong into the Newton matrix, we now also have to compute the terms for the right hand side (i.e., the negative residual). We already do this in another function, and so we call that here:</p>
<div class="fragment"><div class="line">system_rhs = calculate_test_rhs(nonlinear_solution);</div></div><!-- fragment --><p>Here we use the filter matrix we have already constructed. We only need to integrate this filter applied to test functions, which are piecewise constant, and so the integration becomes a simple multiplication by the measure of the cell. Iterating over the pre-made filter matrix allows us to use the information about which cells are in or out of the filter without repeatedly checking neighbor cells again.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">             filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           ++iter)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() cell-&gt;measure();</div><div class="line"></div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                   SolutionBlocks::unfiltered_density)</div><div class="line">            .add(i, j, value);</div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density,</div><div class="line">                   SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">            .add(j, i, value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvingtheNewtonlinearsystem"></a> </p><h3>Solving the Newton linear system</h3>
<p>We will need to solve a linear system in each iteration. We use a direct solver, for now</p>
<p>&ndash; this is clearly not an efficient choice for a matrix that has so many non-zeroes, and it will not scale to anything interesting. For "real" applications, we will need an iterative solver but the complexity of the system means that an iterative solver algorithm will take a good deal of work. Because this is not the focus of the current program, we simply stick with the direct solver we have here</p>
<p>&ndash; the function follows the same structure as used in <a class="el" href="step_29.html">step-29</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">  linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> linear_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Detailsoftheoptimizationalgorithm"></a> </p><h3>Details of the optimization algorithm</h3>
<p>The next several functions deal with specific parts of the optimization algorithm, most notably with deciding whether the direction computed by solving the linearized (Newton) system is viable and, if so, how far we want to go in this direction.</p>
<p><a class="anchor" id="Computingsteplengths"></a> </p><h4>Computing step lengths</h4>
<p>We start with a function that does a binary search to figure out the maximum step that meets the dual feasibility</p>
<p>&ndash; that is, how far can we go so that \(s&gt;0\) and \(z&gt;0\). The function returns a pair of values, one each for the \(s\) and \(z\) slack variables.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1.</div><div class="line"></div><div class="line">- 1e-5;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1</div><div class="line"></div><div class="line">- barrier_size)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (1</div><div class="line"></div><div class="line">- barrier_size &lt; max_fraction_to_boundary)</div><div class="line">        fraction_to_boundary = 1</div><div class="line"></div><div class="line">- barrier_size;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">    {</div><div class="line">      step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">      step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">        (fraction_to_boundary state) + (step_size_s step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">        (fraction_to_boundary state) + (step_size_z step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">           .is_non_negative());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">           .is_non_negative());</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_s)</div><div class="line">        step_size_s_low = step_size_s;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_z)</div><div class="line">        step_size_z_low = step_size_z;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_z_high = step_size_z;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingresiduals"></a> </p><h4>Computing residuals</h4>
<p>The next function computes a right hand side vector linearized around a "test solution vector" that we can use to look at the magnitude of the KKT conditions. This is then used for testing the convergence before shrinking the barrier size, as well as in the calculation of the \(l_1\) merit.</p>
<p>The function is lengthy and complicated, but it is really just a copy of the right hand side part of what the <code>assemble_system()</code> function above did.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>We first create a zero vector with size and blocking of system_rhs</p>
<div class="fragment"><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">  test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">    test_solution;</div><div class="line">  filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density) = 0;</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">  filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density),</div><div class="line">                      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density));</div><div class="line">  filter_matrix.Tvmult(</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">    test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">    n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">      mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">      fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                    old_density_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_divs);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">        test_solution, old_displacement_symmgrads);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_multiplier_values);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_multiplier_divs);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">        .get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_values);</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_multiplier_values);</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_values);</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filtered_unfiltered_density_solution,</div><div class="line">        filtered_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                displacement_multiplier_phi_i_symmgrad =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                    i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                    q_point);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                     q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 1: This equation, along with equations 2 and 3, are the variational derivatives of the Lagrangian with respect to the decision variables</span></div><div class="line"></div><div class="line">- the density, displacement, and unfiltered density.</div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point)</div><div class="line">                (density_penalty_exponent</div><div class="line">                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent</div><div class="line"></div><div class="line">- 1)</div><div class="line">                   density_phi_i</div><div class="line">                   (old_displacement_multiplier_divs[q_point]</div><div class="line">                      old_displacement_divs[q_point]</div><div class="line">                      lambda_values[q_point] +</div><div class="line">                    2 mu_values[q_point]</div><div class="line">                      (old_displacement_symmgrads[q_point]</div><div class="line">                       old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">-</div><div class="line">                 density_phi_i</div><div class="line">                   old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">              <span class="comment">// Equation 2; the boundary terms will be added further down below.</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (<a class="code" href="namespacestd.html">std</a>::pow(old_density_values[q_point],</div><div class="line">                          density_penalty_exponent)</div><div class="line">                 (old_displacement_multiplier_divs[q_point]</div><div class="line">                    displacement_phi_i_div lambda_values[q_point] +</div><div class="line">                  2 mu_values[q_point]</div><div class="line">                    (old_displacement_multiplier_symmgrads[q_point]</div><div class="line">                     displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 3</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (unfiltered_density_phi_i</div><div class="line">                   filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                     [q_point] +</div><div class="line">                 unfiltered_density_phi_i</div><div class="line">                   old_upper_slack_multiplier_values[q_point] +</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 unfiltered_density_phi_i</div><div class="line">                   old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">              <span class="comment">// Equation 4; boundary term will again be dealt with below. This equation being driven to 0 ensures that the elasticity equation is met as a constraint.</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                             (<a class="code" href="namespacestd.html">std</a>::pow(old_density_values[q_point],</div><div class="line">                                       density_penalty_exponent)</div><div class="line">                              (old_displacement_divs[q_point]</div><div class="line">                                 displacement_multiplier_phi_i_div</div><div class="line">                                 lambda_values[q_point] +</div><div class="line">                               2 mu_values[q_point]</div><div class="line">                                 (displacement_multiplier_phi_i_symmgrad</div><div class="line">                                  old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 5: This equation sets the lower slack variable equal to the unfiltered density, giving a minimum density of 0.</span></div><div class="line">              cell_rhs(i) += fe_values.JxW(q_point)</div><div class="line">                             (lower_slack_multiplier_phi_i</div><div class="line">                              (old_unfiltered_density_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                               old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 6: This equation sets the upper slack variable equal to one minus the unfiltered density.</span></div><div class="line">              cell_rhs(i) += fe_values.JxW(q_point)</div><div class="line">                             (upper_slack_multiplier_phi_i</div><div class="line">                              (1</div><div class="line"></div><div class="line">- old_unfiltered_density_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                               old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 7: This is the difference between the density and the filter applied to the unfiltered density. This being driven to 0 by the Newton steps ensures that the filter is applied correctly.</span></div><div class="line">              cell_rhs(i) += fe_values.JxW(q_point)</div><div class="line">                             (unfiltered_density_multiplier_phi_i</div><div class="line">                              (old_density_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                               filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 8: This along with equation 9 give the requirement that s*z = \alpha for the barrier size alpha, and gives complementary slackness from KKT conditions when \alpha goes to 0.</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (lower_slack_phi_i</div><div class="line">                 (old_lower_slack_multiplier_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                  barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">// Equation 9</span></div><div class="line">              cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1 fe_values.JxW(q_point)</div><div class="line">                (upper_slack_phi_i</div><div class="line">                 (old_upper_slack_multiplier_values[q_point]</div><div class="line"></div><div class="line">-</div><div class="line">                  barrier_size / old_upper_slack_values[q_point]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      for (const auto &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                   fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] =</div><div class="line"></div><div class="line">-1.;</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1</div><div class="line">                        (traction fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                      i, face_q_point))</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (traction</div><div class="line">                         fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                           i, face_q_point))</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               dummy_cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             test_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> test_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingthemeritfunction"></a> </p><h4>Computing the merit function</h4>
<p>The algorithm we use herein uses a "watchdog" strategy to determine where and how far to go from the current iterate. We base the watchdog strategy on an exact \(l_1\) merit function. This function calculates the exact \(l_1\) merit of a given, putative, next iterate.</p>
<p>The merit function consists of the sum of the objective function (which is simply an integral of external forces (on the boundary of the domain) times the displacement values of a test solution (typically, the current solution plus some multiple of the Newton update), and the \(l_1\) norms of the Lagrange multiplier components of residual vectors. The following code computes these parts in turn:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div></div><!-- fragment --><p>Start with computing the objective function:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                  .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                       displacement_face_values);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                     face_q_point &lt; n_face_q_points;</div><div class="line">                     ++face_q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                    traction[1] =</div><div class="line"></div><div class="line">-1.;</div><div class="line"></div><div class="line">                    objective_function_merit +=</div><div class="line">                      (traction displacement_face_values[face_q_point])</div><div class="line">                      fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      objective_function_merit =</div><div class="line">        objective_function_merit</div><div class="line"></div><div class="line">-</div><div class="line">        barrier_size cell-&gt;measure()</div><div class="line">          <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">            SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      objective_function_merit =</div><div class="line">        objective_function_merit</div><div class="line"></div><div class="line">-</div><div class="line">        barrier_size cell-&gt;measure()</div><div class="line">          <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">            SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">    }</div></div><!-- fragment --><p>Then compute the residual and take the \(l_1\) norms of the components that correspond to Lagrange mulipliers. We add those to the objective function computed above, and return the sum at the bottom:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">    penalty_multiplier</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">    objective_function_merit + elasticity_constraint_merit +</div><div class="line">    filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">  <span class="keywordflow">return</span> total_merit;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Findingasearchdirection"></a> </p><h4>Finding a search direction</h4>
<p>Next up is the function that actually computes a search direction starting at the current state (passed as the first argument) and returns the resulting vector. To this end, the function first calls the functions that assemble the linear system that corresponds to the Newton system, and that solve it.</p>
<p>This function also updates the penalty multiplier in the merit function, and then returns the largest scaled feasible step. It uses the <code>calculate_max_step_sizes()</code> function to find the largest feasible step that satisfies \(s&gt;0\) and \(z&gt;0\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">{</div><div class="line">  assemble_system();</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div></div><!-- fragment --><p>Next we are going to update penalty_multiplier. In essence, a larger penalty multiplier makes us consider the constraints more. Looking at the Hessian and gradient with respect to the step we want to take with our decision variables, and comparing that to the norm of our constraint error gives us a way to ensure that our merit function is "exact"</p>
<ul>
<li>that is, it has a minimum in the same location that the objective function does. As our merit function is exact for any penalty multiplier over some minimum value, we only keep the computed value if it increases the penalty multiplier.</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">    SolutionBlocks::density,</div><div class="line">    SolutionBlocks::displacement,</div><div class="line">    SolutionBlocks::unfiltered_density,</div><div class="line">    SolutionBlocks::density_upper_slack,</div><div class="line">    SolutionBlocks::density_lower_slack};</div><div class="line">  <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">  <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">        {</div><div class="line">          Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">          system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">            .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">          hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) temp_vector;</div><div class="line">        }</div><div class="line">      grad_part</div><div class="line"></div><div class="line">-= system_rhs.block(decision_variable_i)</div><div class="line">                   step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">    SolutionBlocks::displacement_multiplier,</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">    SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">    SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">  <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">    constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">  <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">    test_penalty_multiplier =</div><div class="line">      (grad_part + .5 hess_part) / (.05 constraint_norm);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    test_penalty_multiplier = (grad_part) / (.05 constraint_norm);</div><div class="line"></div><div class="line">  penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div></div><!-- fragment --><p>Based on all of this, we can now compute step sizes for the primal and dual (Lagrange multiplier) variables. Once we have these, we scale the components of the solution vector, and that is what this function returns.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">    calculate_max_step_size(nonlinear_solution, step);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier)= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier)= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)= step_size_z;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingascaledstep"></a> </p><h4>Computing a scaled step</h4>
<p>The next function then implements a back-tracking algorithm for a line search. It keeps shrinking step size until it finds a step where the merit is decreased, and then returns the new location based on the current state vector, and the direction to go into, times the step length.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">    (calculate_exact_merit(state + 1e-4 max_step)</div><div class="line"></div><div class="line">-</div><div class="line">     calculate_exact_merit(state)) /</div><div class="line">    1e-4;</div><div class="line">  <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size max_step) &lt;</div><div class="line">          calculate_exact_merit(state) +</div><div class="line">            step_size descent_requirement merit_derivative)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size = step_size / 2;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> state + (step_size max_step);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Checkingforconvergence"></a> </p><h4>Checking for convergence</h4>
<p>The final auxiliary function in this block is the one that checks to see if the KKT conditions are sufficiently met so that the overall algorithm can lower the barrier size. It does so by computing the \(l_1\) norm of the residual, which is what <code>calculate_test_rhs()</code> computes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition barrier_size;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">            &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessingthesolution"></a> </p><h3>Postprocessing the solution</h3>
<p>The first of the postprocessing functions outputs information in a VTU file for visualization. It looks long, but it's really just the same as what was done in <a class="el" href="step_22.html">step-22</a>, for example, just with (a lot) more solution variables:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p>The second of these functions outputs the solution as an <code>.stl</code> file for 3d printing. <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files are made up of triangles and normal vectors, and we will use it to show all of those cells with a density value larger than zero by first extruding the mesh from a \(z\) value of zero to \(z=0.25\), and then generating two triangles for each face of the cells with a sufficiently large density value. The triangle nodes must go counter-clockwise when looking from the outside, and the normal vectors must be unit vectors pointing outwards, which requires a few checks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">{</div><div class="line">  static_assert(dim == 2,</div><div class="line">                <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">  std::ofstream stlfile;</div><div class="line">  stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">  <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">            SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">        {</div></div><!-- fragment --><p>We have now found a cell with a density value larger than zero. Let us start by writing out the bottom and top faces. Owing to the ordering issue mentioned above, we have to make sure that we understand whether a cell has a right- or left-handed coordinate system. We do this by interrogating the directions of the two edges starting at vertex 0 and whether they form a right-handed coordinate system.</p>
<div class="fragment"><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1)</div><div class="line"></div><div class="line">-</div><div class="line">                                                       cell-&gt;vertex(0),</div><div class="line">                                                     cell-&gt;vertex(2)</div><div class="line"></div><div class="line">-</div><div class="line">                                                       cell-&gt;vertex(0)};</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">            {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">             {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">            {</div><div class="line">              <span class="comment">// Write one side at z = 0.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">              <span class="comment">// Write one side at z = height.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span> <span class="comment">// The cell has a left-handed set up</span></div><div class="line">            {</div><div class="line">              <span class="comment">// Write one side at z = 0.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div><div class="line"></div><div class="line">-1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">              <span class="comment">// Write one side at z = height.</span></div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                      &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">              stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">            }</div></div><!-- fragment --><p>Next we need to deal with the four faces of the cell, extended into the \(z\) direction. However, we only need to write these faces if either the face is on the domain boundary, or if it is the interface between a cell with density greater than 0.5, and a cell with a density less than 0.5.</p>
<div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">               face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">               ++face_number)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                cell-&gt;face(face_number);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                  (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                   (nonlinear_solution.block(</div><div class="line">                      0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                    0.5)))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                    (face-&gt;center()</div><div class="line"></div><div class="line">- cell-&gt;center());</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                  <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0])</div><div class="line">                          (face-&gt;vertex(1)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1])</div><div class="line">                          0.000000e+00 +</div><div class="line">                        (face-&gt;vertex(0)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1]) (0</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          normal_vector[0] +</div><div class="line">                        (height</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          (face-&gt;vertex(1)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0])</div><div class="line">                          normal_vector[1]</div><div class="line"></div><div class="line">-</div><div class="line">                        (face-&gt;vertex(0)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0]) (0</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          normal_vector[1]</div><div class="line"></div><div class="line">-</div><div class="line">                        (face-&gt;vertex(0)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1])</div><div class="line">                          (face-&gt;vertex(1)[0]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[0])</div><div class="line">                          normal_vector[0]</div><div class="line"></div><div class="line">-</div><div class="line">                        (height</div><div class="line"></div><div class="line">- 0)</div><div class="line">                          (face-&gt;vertex(1)[1]</div><div class="line"></div><div class="line">- face-&gt;vertex(0)[1]) 0 &gt;</div><div class="line">                      0)</div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctiondrivingtheoverallalgorithm"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function driving the overall algorithm</h3>
<p>This function finally provides the overall driver logic. It is, in the grand scheme of things, a rather complicated function primarily because the optimization algorithm is difficult: It isn't just about finding a Newton direction like in <a class="el" href="step_15.html">step-15</a> and then going a fixed distance in this direction any more, but instead about (i) determining what the optimal log-barrier penalty parameter should be in the current step, (ii) a complicated algorithm to determine how far we want to go, and other ingredients. Let us see how we can break this down into smaller chunks in the following documentation.</p>
<p>The function starts out simple enough with first setting up the mesh, the <a class="el" href="classDoFHandler.html">DoFHandler</a>, and then the various linear algebra objects necessary for the following:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    setup_boundary_values();</div><div class="line">    setup_block_system();</div><div class="line">    setup_filter_matrix();</div><div class="line">  }</div></div><!-- fragment --><p>We then set a number of parameters that affect the log-barrier and line search components of the optimization algorithm:</p>
<div class="fragment"><div class="line">barrier_size                  = 25;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div></div><!-- fragment --><p>Now start the principal iteration. The overall algorithm works by using an outer loop in which we loop until either (i) the log-barrier parameter has become small enough, or (ii) we have reached convergence. In any case, we terminate if end up with too large a number of iterations. This overall structure is encoded as a <code>do { ... } while (...)</code> loop where the convergence condition is at the bottom.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div></div><!-- fragment --><p>Within this outer loop, we have an inner loop in which we try to find an update direction using the watchdog algorithm described in the introduction.</p>
<p>The general idea of the watchdog algorithm itself is this: For a maximum of <code>max_uphill_steps</code> (i.e., a loop within the "inner loop" mentioned above) attempts, we use <code>find_max_step()</code> to compute a Newton update step, and add these up in the <code>nonlinear_solution</code> vector. In each of these attempts (starting from the place reached at the end of the previous attempt), we check whether we have reached a target value of the merit function described above. The target value is computed based on where this algorithm starts (the <code>nonlinear_solution</code> at the beginning of the watchdog loop, saves as <code>watchdog_state</code>) and the first proposed direction provided by <code>find_max_step()</code> in the first go-around of this loop (the <code>k==0</code> case).</p>
<div class="fragment"><div class="line">      <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                    &lt;&lt; iteration_number</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                    &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">          <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">          <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">          <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">            {</div><div class="line">              ++iteration_number;</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (k == 0)</div><div class="line">                {</div><div class="line">                  first_step = update_step;</div><div class="line">                  merit_derivative =</div><div class="line">                    ((calculate_exact_merit(watchdog_state +</div><div class="line">                                            .0001 first_step)</div><div class="line"></div><div class="line">-</div><div class="line">                      calculate_exact_merit(watchdog_state)) /</div><div class="line">                     .0001);</div><div class="line">                  target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                 descent_requirement merit_derivative;</div><div class="line">                }</div><div class="line"></div><div class="line">              nonlinear_solution += update_step;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                        &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                        &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                {</div><div class="line">                  watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                  std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                            &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div></div><!-- fragment --><p>The next part of the algorithm then depends on whether the watchdog loop above succeeded. If it did, then we are satisfied and no further action is necessary: We just stay where we are. If, however, we took the maximal number of unsuccessful steps in the loop above, then we need to do something else, and this is what the following code block does.</p>
<p>Specifically, from the final (unsuccessful) state of the loop above, we seek one more update direction and take what is called a "stretch step". If that stretch state satisfies a condition involving the merit function, then we go there. On the other hand, if the stretch state is also unacceptable (as all of the watchdog steps above were), then we discard all of the watchdog steps taken above and start over again where we had started the watchdog iterations</p>
<p>&ndash; that place was stored in the <code>watchdog_state</code> variable above. More specifically, the conditions below first test whether we take a step from <code>watchdog_state</code> in direction <code>first_step</code>, or whether we can do one more update from the stretch state to find a new place. It is possible that neither of these is actually better than the state we started from at the beginning of the watchdog algorithm, but even if that is so, that place clearly was a difficult place to be in, and getting away to start the next iteration from another place might be a useful strategy to eventually converge.</p>
<p>We keep repeating the watchdog steps above along with the logic below until this inner iteration is finally converged (or if we run up against the maximal number of iterations</p>
<p>&ndash; where we count the number of linear solves as iterations and increment the counter every time we call <code>find_max_step()</code> since that is where the linear solve actually happens). In any case, at the end of each of these inner iterations we also output the solution in a form suitable for visualization.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    ++iteration_number;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">      compute_scaled_step(nonlinear_solution,</div><div class="line">                          update_step,</div><div class="line">                          descent_requirement);</div></div><!-- fragment --><p>If we did not get a successful watchdog step, we now need to decide between going back to where we started, or using the final state. We compare the merits of both of these locations, and then take a scaled step from whichever location is better. As the scaled step is guaranteed to lower the merit, we will end up keeping one of the two.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">             calculate_exact_merit(watchdog_state)) ||</div><div class="line">            (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            nonlinear_solution = stretch_state;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            std::cout</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                calculate_exact_merit(watchdog_state))</div><div class="line">              {</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(watchdog_state,</div><div class="line">                                      first_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                nonlinear_solution = stretch_state;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                  find_max_step();</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      stretch_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    output_results(iteration_number);</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">       (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div></div><!-- fragment --><p>At the end of the outer loop, we have to update the barrier parameter, for which we use the following formula. The rest of the function is then simply about checking the outer loop convergence condition, and if we decide to terminate computations, about writing the final "design" as an STL file for use in 3d printing, and to output some timing information.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">      barrier_size =</div><div class="line">        <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size barrier_size_multiplier,</div><div class="line">                          std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                 min_barrier_size);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">          (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">         (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">  write_as_stl();</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">}</div><div class="line">} <span class="comment">// namespace SAND</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The remainder of the code, the <code>main()</code> function, is as usual:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">    elastic_problem_2d.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="TestProblem"></a></p><h3>Test Problem</h3>
<p>The algorithms used above are tested against a traditional topology optimization problem called the Messerschmitt-Bolkow-Blohm Beam (MBB Beam).</p>
<p>This problem considers the optimal 2-d structure that can be built on a rectangle 6 units wide, and 1 unit tall. The bottom corners are fixed in place in the \(y\) direction using a zero Dirichlet boundary condition, and a downward force is applied in the center of the top of the beam by enforcing a Neumann boundary condition. The rest of the boundary is allowed to move, and has no external force applied, which takes the form of a zero Neumann boundary condition. In essence, we are asking the following question: How should we design a bridge in a way so that if the bottom left and bottom right point of the bridge are on rollers that allow these points to move horizontally but not vertically, and so that the displacement in response to the vertical force in the center is minimal.</p>
<p>While the total volume of the domain is 6 units, 3 units of material are allowed for the structure. Because of the symmetry of the problem, it could be posed on a rectangle of width 3 and height 1 by cutting the original domain in half, and using zero Dirichlet boundary conditions in the \(x\) direction along the cut edge. That said, symmetry of the solution is a good indicator that the program is working as expected, so we solved the problem on the whole domain, as shown below. <b>[Bendse2004]</b></p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.mbbgeometry.png" alt="The MBB problem domain and boundary conditions"/>
</div>
 </div><p>Using the program discussed above, we find the minimum volume of the MBB Beam and the individual components of the solution look as follows:</p>
<div class="onecolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.filtereddensity.png" alt="Filtered Density Solution"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.unfiltereddensity.png" alt="Unfiltered Density Solution"/>
</div>
 </div> </div><p>These pictures show that what we find here is in accordance with what onetypically sees in other publications on the topic <b>[Bendse2004]</b> . Maybe more interestingly, theresult looks like a truss bridge (except that we apply the load at the top ofthe trusses, rather than the bottom as in real truss bridges, akin to a "decktruss" bridge), suggesting that the designs that have been used in bridge-building for centuries are indeed based on ideas we can now show to be optimalin some sense.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h4>Possibilities for extensions</h4>
<p>The results shown above took around 75 iterations to find, which is quiteconcerning given the expense in solving the large linear systems in eachiteration. Looking at the evolution, it does look as though the convergence hasmoments of happening quickly and moments of happening slowly. We believe this tobe due to both a lack of precision on when and how to decrease the boundaryvalues, as well as our choice of merit function being sub-optimal. In the future,a LOQO barrier update replacing the monotone reduction, as well as a MarkovFilter in place of a merit function will decrease the number of necessaryiterations significantly. The barrier decrease is most sensitive in the middle of the convergence, whichis problematic, as it seems like we need it to decrease quickly, then slowly,then quickly again. Secondly, the linear solver used here is just the sparse direct solver based onthe <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class. This works reasonably well on small problems,but the formulation of the optimization problem detailed above has quite a largenumber of variables and so the linear problem is not only large but also has alot of nonzero entries in many rows, even on meshes that overall are stillrelatively coarse. As a consequence, the solver time dominates thecomputations, and more sophisticated approaches at solving the linear systemare necessary.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Justin O&#39;Connor, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionComponents</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">  } <span class="comment">// namespace SolutionComponents</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionBlocks</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">  } <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>BoundaryIds</div><div class="line">  {</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">  } <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>ValueExtractors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">      displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">      SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">      SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">      SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">      SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">  } <span class="comment">// namespace ValueExtractors</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SANDTopOpt</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SANDTopOpt();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">    std::pair&lt;double, double&gt;</div><div class="line">    calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">    calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">    find_relevant_neighbors(</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">    <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">    <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         5)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , density_ratio(.5)</div><div class="line">    , density_penalty_exponent(3)</div><div class="line">    , filter_r(.251)</div><div class="line">    , penalty_multiplier(1)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              {6, 1},</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">    triangulation.refine_global(3);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">  {</div><div class="line">    boundary_values.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[x_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line"></div><div class="line">                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                                 <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">    block_component[0] = 0;</div><div class="line">    block_component[1] = 1;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">        dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">            {</div><div class="line">              coupling[displacement&lt;dim&gt; + i]</div><div class="line">                      [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">              coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                      [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for slack variables */</span></div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">      fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">    <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">      density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">    constraints.clear();</div><div class="line">    constraints.add_line(last_density_dof);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">      constraints.add_entry(last_density_dof,</div><div class="line">                            density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                            -1);</div><div class="line">    constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                         SolutionBlocks::unfiltered_density)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    nonlinear_solution.reinit(block_sizes);</div><div class="line">    system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">      nonlinear_solution.block(density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">        .add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">      nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">  {</div><div class="line"></div><div class="line">    filter_sparsity_pattern.copy_from(</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                             SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">    filter_matrix.reinit(filter_sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                filter_matrix.add(i,</div><div class="line">                                  check_cell-&gt;active_cell_index(),</div><div class="line">                                  filter_r - distance);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> denominator = 0;</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          denominator = denominator + iter-&gt;value();</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">    neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">    cells_to_check.insert(cell);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">             std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">               cells_to_check.begin(), cells_to_check.end()))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                      cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                    <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                        !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                      {</div><div class="line">                        cells_to_check.insert(neighbor);</div><div class="line">                        neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                        new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">    <span class="keywordflow">return</span> cells_to_check;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">      nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      nonlinear_solution;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        nonlinear_solution.block(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          nonlinear_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                                       q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                      displacement_multiplier_phi_j_symmgrad =</div><div class="line">                        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">                          .symmetric_gradient(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">                      fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">                      fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">                      fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">                      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">                      fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">                      fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 1 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            (density_penalty_exponent - 1) *</div><div class="line">                            std::pow(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 2) *</div><div class="line">                            density_phi_i * density_phi_j *</div><div class="line">                            (old_displacement_multiplier_divs[q_point] *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_multiplier_phi_j_div *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               old_displacement_multiplier_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                                displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 2 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (density_penalty_exponent *</div><div class="line">                         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent - 1) *</div><div class="line">                         density_phi_j *</div><div class="line">                         (old_displacement_multiplier_divs[q_point] *</div><div class="line">                            displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                          2 * mu_values[q_point] *</div><div class="line">                            (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                       + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent) *</div><div class="line">                           (displacement_multiplier_phi_j_div *</div><div class="line">                              displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                            2 * mu_values[q_point] *</div><div class="line">                              (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                               displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      );</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">                     * calculated elsewhere. */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (-1 * unfiltered_density_phi_i *</div><div class="line">                         lower_slack_multiplier_phi_j +</div><div class="line">                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        density_penalty_exponent *</div><div class="line">                          <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent - 1) *</div><div class="line">                          density_phi_j *</div><div class="line">                          (old_displacement_divs[q_point] *</div><div class="line">                             displacement_multiplier_phi_i_div *</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 * mu_values[q_point] *</div><div class="line">                             (old_displacement_symmgrads[q_point] *</div><div class="line">                              displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                        + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent) *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               displacement_multiplier_phi_i_div *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (displacement_phi_j_symmgrad *</div><div class="line">                                displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      lower_slack_multiplier_phi_i *</div><div class="line">                      (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      upper_slack_multiplier_phi_i *</div><div class="line">                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">                     * is added later */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                                         unfiltered_density_multiplier_phi_i *</div><div class="line">                                         (density_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                       + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                           old_lower_slack_multiplier_values[q_point] /</div><div class="line">                           old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                       + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                           old_upper_slack_multiplier_values[q_point] /</div><div class="line">                           old_upper_slack_values[q_point]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 cell_matrix,</div><div class="line">                                                 dummy_cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    system_rhs = calculate_test_rhs(nonlinear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">               filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             ++iter)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .add(i, j, value);</div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .add(j, i, value);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">    linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> linear_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">          fraction_to_boundary = 1 - barrier_size;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">      {</div><div class="line">        step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">        step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">          (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">          (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">             .is_non_negative());</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">             .is_non_negative());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_s)</div><div class="line">          step_size_s_low = step_size_s;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_z)</div><div class="line">          step_size_z_low = step_size_z;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_z_high = step_size_z;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">    test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      test_solution;</div><div class="line">    filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density) = 0;</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">                 * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">                 * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">                 * variables - the density, displacement, and</span></div><div class="line"><span class="comment">                 * unfiltered density. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (density_penalty_exponent *</div><div class="line">                     <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                              density_penalty_exponent - 1) *</div><div class="line">                     density_phi_i *</div><div class="line">                     (old_displacement_multiplier_divs[q_point] *</div><div class="line">                        old_displacement_divs[q_point] *</div><div class="line">                        lambda_values[q_point] +</div><div class="line">                      2 * mu_values[q_point] *</div><div class="line">                        (old_displacement_symmgrads[q_point] *</div><div class="line">                         old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                   density_phi_i *</div><div class="line">                     old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">                 * below. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent) *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                       displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 3 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (unfiltered_density_phi_i *</div><div class="line">                     filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                       [q_point] +</div><div class="line">                   unfiltered_density_phi_i *</div><div class="line">                     old_upper_slack_multiplier_values[q_point] +</div><div class="line">                   -1 * unfiltered_density_phi_i *</div><div class="line">                     old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">                 * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">                 * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">                 * a constraint. */</span></div><div class="line">                cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                         density_penalty_exponent) *</div><div class="line">                                (old_displacement_divs[q_point] *</div><div class="line">                                   displacement_multiplier_phi_i_div *</div><div class="line">                                   lambda_values[q_point] +</div><div class="line">                                 2 * mu_values[q_point] *</div><div class="line">                                   (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                    old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">                 * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">                 * giving a minimum density of 0. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (lower_slack_multiplier_phi_i *</div><div class="line">                                (old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">                 * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">                 * density. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (upper_slack_multiplier_phi_i *</div><div class="line">                                (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">                 * density and the filter applied to the</span></div><div class="line"><span class="comment">                 * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">                 * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">                 * applied correctly. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (unfiltered_density_multiplier_phi_i *</div><div class="line">                                (old_density_values[q_point] -</div><div class="line">                                 filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">                 * requirement that @f$s*z = \alpha@f$ for the barrier</span></div><div class="line"><span class="comment">                 * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">                 * from KKT conditions when @f$\alpha@f$ goes to 0. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (lower_slack_phi_i *</div><div class="line">                   (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 9 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (upper_slack_phi_i *</div><div class="line">                   (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_upper_slack_values[q_point]));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                     fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                      {</div><div class="line">                        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                        traction[1] = -1.;</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          -1 *</div><div class="line">                          (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                        i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          (traction *</div><div class="line">                           fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                             i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 dummy_cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               test_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> test_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">    {</div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                              fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                       fe,</div><div class="line">                                       face_quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                  face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">                {</div><div class="line">                  fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                  fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                    .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                         displacement_face_values);</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                       face_q_point &lt; n_face_q_points;</div><div class="line">                       ++face_q_point)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      objective_function_merit +=</div><div class="line">                        (traction * displacement_face_values[face_q_point]) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">      objective_function_merit + elasticity_constraint_merit +</div><div class="line">      filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">    <span class="keywordflow">return</span> total_merit;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">  {</div><div class="line">    assemble_system();</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">      SolutionBlocks::density,</div><div class="line">      SolutionBlocks::displacement,</div><div class="line">      SolutionBlocks::unfiltered_density,</div><div class="line">      SolutionBlocks::density_upper_slack,</div><div class="line">      SolutionBlocks::density_lower_slack};</div><div class="line">    <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">    <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">          {</div><div class="line">            Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">            system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">              .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">            hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">          }</div><div class="line">        grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                     step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">      SolutionBlocks::displacement_multiplier,</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">      SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">      SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">    <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">    <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">      test_penalty_multiplier =</div><div class="line">        (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">    penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">      calculate_max_step_size(nonlinear_solution, step);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> step;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">      (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">       calculate_exact_merit(state)) /</div><div class="line">      1e-4;</div><div class="line">    <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">            calculate_exact_merit(state) +</div><div class="line">              step_size * descent_requirement * merit_derivative)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size = step_size / 2;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">              &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">  {</div><div class="line">    static_assert(dim == 2,</div><div class="line">                  <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">    std::ofstream stlfile;</div><div class="line">    stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">    <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">              SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                                         cell-&gt;vertex(0),</div><div class="line">                                                       cell-&gt;vertex(2) -</div><div class="line">                                                         cell-&gt;vertex(0)};</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">              {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">               {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">                 face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                 ++face_number)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                  cell-&gt;face(face_number);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                    (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                     (nonlinear_solution.block(</div><div class="line">                        0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                      0.5)))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                      (face-&gt;center() - cell-&gt;center());</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                    <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            0.000000e+00 +</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                            normal_vector[0] +</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[0] -</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                        0)</div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">      setup_boundary_values();</div><div class="line">      setup_block_system();</div><div class="line">      setup_filter_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">    barrier_size                  = 25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                      &lt;&lt; iteration_number</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                      &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">            <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">            <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">            <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (k == 0)</div><div class="line">                  {</div><div class="line">                    first_step = update_step;</div><div class="line">                    merit_derivative =</div><div class="line">                      ((calculate_exact_merit(watchdog_state +</div><div class="line">                                              .0001 * first_step) -</div><div class="line">                        calculate_exact_merit(watchdog_state)) /</div><div class="line">                       .0001);</div><div class="line">                    target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                   descent_requirement * merit_derivative;</div><div class="line">                  }</div><div class="line"></div><div class="line">                nonlinear_solution += update_step;</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                  calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                          &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                          &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                  {</div><div class="line">                    watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      update_step,</div><div class="line">                                      descent_requirement);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">                     calculate_exact_merit(watchdog_state)) ||</div><div class="line">                    (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">                  {</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                    nonlinear_solution = stretch_state;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    std::cout</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                        calculate_exact_merit(watchdog_state))</div><div class="line">                      {</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(watchdog_state,</div><div class="line">                                              first_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        ++iteration_number;</div><div class="line">                        nonlinear_solution = stretch_state;</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                          find_max_step();</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(nonlinear_solution,</div><div class="line">                                              stretch_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            output_results(iteration_number);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">               (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#SolidIsotropicMaterialwithPenalization">Solid Isotropic Material with Penalization</a>
        <li><a href="#ElasticityEquation">Elasticity Equation</a>
        <li><a href="#Makingthesolutionmeshindependent">Making the solution mesh-independent</a>
        <li><a href="#CompleteProblemFormulation">Complete Problem Formulation</a>
        <li><a href="#Solutionprocedure">Solution procedure</a>
        <li><a href="#Discretization">Discretization</a>
        <li><a href="#NonlinearAlgorithm">Nonlinear Algorithm</a>
        <li><a href="#MeritFunction">Merit Function</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Preliminaries">Preliminaries</a>
        <li><a href="#TheSANDTopOptmainclass">The SANDTopOpt main class</a>
        <li><a href="#Constructorandsetupfunctions">Constructor and set-up functions</a>
        <li><a href="#Settingupblockmatricesandvectors">Setting up block matrices and vectors</a>
        <li><a href="#Creatingthefiltermatrix">Creating the filter matrix</a>
        <li><a href="#AssemblingtheNewtonmatrix">Assembling the Newton matrix</a>
        <li><a href="#SolvingtheNewtonlinearsystem">Solving the Newton linear system</a>
        <li><a href="#Detailsoftheoptimizationalgorithm">Details of the optimization algorithm</a>
      <ul>
        <li><a href="#Computingsteplengths">Computing step lengths</a>
        <li><a href="#Computingresiduals">Computing residuals</a>
        <li><a href="#Computingthemeritfunction">Computing the merit function</a>
        <li><a href="#Findingasearchdirection">Finding a search direction</a>
        <li><a href="#Computingascaledstep">Computing a scaled step</a>
        <li><a href="#Checkingforconvergence">Checking for convergence</a>
      </ul>
        <li><a href="#Postprocessingthesolution">Postprocessing the solution</a>
        <li><a href="#Therunfunctiondrivingtheoverallalgorithm">The run() function driving the overall algorithm</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#TestProblem">Test Problem</a>
      <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-79/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p> \(E\) </p>
<p class="formulaDsp">
\[ \text{minimize}\| \boldsymbol{\sigma} (\mathbf{u}) \|_\infty \]
</p>
<p class="formulaDsp">
\[ \text{subject to } |E|\leq V_{\max}, \]
</p>
<p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0}. \]
</p>
<p> \(\boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon}(\mathbf{u})\)  \(\mathbf F\)  \(\mathbf{C}\) - \(\boldsymbol{\varepsilon}(\mathbf{u})=\frac{1}{2} (\nabla \mathbf{u} + (\nabla\mathbf{u})^T)\)  \(\mathbf{u}\) &ndash;8 17 \(V_\text{max}\)  \(\boldsymbol{\sigma}\)  \(\mathbf F\) </p>
<p></p>
<p class="formulaDsp">
\[ \text{minimize } \int_E \frac{1}{2}\boldsymbol{\sigma} : \boldsymbol{\varepsilon} dV \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \|E\| \leq V_{\max} \]
</p>
<p class="formulaDsp">
\[ \text{and } \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} \]
</p>
<p></p>
<p><a class="anchor" id="SolidIsotropicMaterialwithPenalization"></a></p><h3>Solid Isotropic Material with Penalization</h3>
<p>&ndash; \(\rho_E(\mathbf{x})\in \{0,1\}\) SIMP <b>[Bendse2004]</b></p>
<p>SIMP \(\rho\) 010101 \(\rho\)  \(0 &lt; \rho_{\min} \leq \rho \leq 1\)  \(\rho_{\min}\)  \(10^{-3}\) </p>
<p> " " \(\mathbf{C}_0\)  \(\mathbf{C} = \rho \mathbf{C}_0\) 01 \(p\)  \(\mathbf{C} = \rho^p \mathbf{C}_0\) 01 \(p=3\) ''</p>
<p></p>
<p>SIMP</p>
<p class="formulaDsp">
\[ \text{minimize } \int_\Omega \frac{1}{2}\boldsymbol{\sigma}(\rho) : \boldsymbol{\varepsilon}(\rho) d\Omega \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \int_\Omega \rho(x) d\Omega= V_{\max}, \]
</p>
<p class="formulaDsp">
\[ 0&lt;\rho_{\min}\leq \rho(x) \leq 1, \]
</p>
<p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma}(\rho) + \mathbf{F} = 0 \quad \text{on } \Omega \]
</p>
<p> \(\boldsymbol{\sigma}\)  \(\boldsymbol{\varepsilon}\)  \(\rho\) </p>
<p><a class="anchor" id="ElasticityEquation"></a></p><h3>Elasticity Equation</h3>
<p></p>
<p class="formulaDsp">
\[ \nabla \cdot \boldsymbol{\sigma} + \mathbf{F} = \mathbf{0} . \]
</p>
<p></p>
<p class="formulaDsp">
\[ \boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\varepsilon} = \rho^p \mathbf{C}_0 : \boldsymbol{\varepsilon}(\mathbf{u}) = \rho^p \mathbf{C}_0 : \left[\frac{1}{2} (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) \right] . \]
</p>
<p> \(\mathbf{u}\)  \(\mathbf{u}\)  \(\boldsymbol{\sigma}\) </p>
<p>-Lam&eacute; \(\lambda,\mu\) </p>
<p class="formulaDsp">
\begin{align} \boldsymbol{\sigma} &amp;= \rho^p (\lambda \text{tr}(\boldsymbol{\varepsilon}) \mathbf{I} + 2 \mu \boldsymbol{\varepsilon}) , \\ \sigma_{i,j} &amp;= \rho^p (\lambda \varepsilon_{k,k} \delta_{i,j} + 2 \mu \varepsilon_{i,j}) . \end{align}
</p>
<p>8</p>
<p></p>
<p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u}))^T d\Omega+ \int_\Omega (\nabla \cdot \boldsymbol{\sigma}(\rho)) \cdot \mathbf{u} d\Omega= \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega , \]
</p>
<p></p>
<p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_\Omega \mathbf{F}\cdot \mathbf{u} d\Omega+ \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega . \]
</p>
<p></p>
<p class="formulaDsp">
\[ \int_\Omega \boldsymbol{\sigma}(\rho) : (\nabla \mathbf{u} + (\nabla \mathbf{u})^T) d\Omega = \int_{\partial \Omega} \mathbf{t} \cdot \mathbf{u} d\partial\Omega, \]
</p>
<p></p>
<p><a class="anchor" id="Makingthesolutionmeshindependent"></a></p><h3>Making the solution mesh-independent</h3>
<p></p>
<p>Hessian \(\varrho\) </p>
<p class="formulaDsp">
\[ \rho = H(\varrho). \]
</p>
<p> \(H\)  \(\rho(\mathbf{x})\)  \(\varrho\)  \(\mathbf{x}\)  &ndash;  \(\varrho\) </p>
<p></p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.checkerboard.png" alt="Checkerboarding occurring in an MBB Beam"/>
</div>
 </div><p><a class="anchor" id="CompleteProblemFormulation"></a></p><h3>Complete Problem Formulation</h3>
<p></p>
<p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho d\Omega= V \]
</p>
<p class="formulaDsp">
\[ 0\leq \varrho \leq 1 \]
</p>
<p> \(\alpha\) </p><ol>
<li>
\(s_1\) -  </li>
<li>
\(s_2\) -  </li>
</ol>
<p></p>
<p class="formulaDsp">
\[ \min_{\rho,\varrho,\mathbf{u}, s_1, s_2} \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega \]
</p>
<p class="formulaDsp">
\[ \text{subject to } \rho = H(\varrho) \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{v}): \boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{v} \right) \right) d\Omega = \int_{\partial \Omega} \mathbf{v} \cdot \mathbf{t} d\partial\Omega \]
</p>
<p class="formulaDsp">
\[ \int_\Omega \rho d\Omega = V \]
</p>
<p class="formulaDsp">
\[ \varrho = s_1 \]
</p>
<p class="formulaDsp">
\[ 1-\varrho = s_2 \]
</p>
<p></p><ol>
<li>
\(\mathbf{y}_1 \)   </li>
<li>
\(y_2\)   </li>
<li>
\(z_1\)   </li>
<li>
\(z_2\)   </li>
</ol>
<p></p>
<p class="formulaDsp">
\begin{align} \mathcal{L} =&amp; \int_{\partial\Omega} \mathbf{u} \cdot \mathbf{t} d\partial\Omega - \alpha \int_\Omega \left(\log(s_1) + \log(s_2)\right) d\Omega- \int_\Omega \rho^p \left(\frac{\mu}{2}\left(\boldsymbol{\varepsilon}(\mathbf{y}_1):\boldsymbol{\varepsilon}(\mathbf{u})) \right) + \lambda \left( \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_1 \right)\right) d\Omega - \int_{\partial \Omega} \mathbf{y}_1 \cdot \mathbf{t} d\partial\Omega \\ &amp; -\int_\Omega y_2 (\rho - H(\varrho)) d\Omega - \int_\Omega z_1 (\varrho-s_1) d\Omega - \int_\Omega z_2 (1 - s_2 -\varrho) d\Omega \end{align}
</p>
<p>[Karush-Kuhn-TuckerKKT]https://en.wikipedia.org/wiki/KarushE2%80%93KuhnE2%80%93Tucker_conditions " "&ndash;</p>
<p>KKT "" \(s_i z_i = 0\) KKT \(s_i z_i = \alpha\)  \(\alpha\) 0</p>
<p> \(d_{\{\bullet\}}\)  \(\{\bullet\}\)  \(\Gamma\) </p>
<ol>
<li>
<p class="startli"></p>
<p class="formulaDsp">
\[ \int_\Omega - d_\rho y_2 + p\rho^{p-1}d_\rho \left[\lambda (\nabla \cdot \mathbf{y}_1) (\nabla \cdot \mathbf{u}) + \mu \boldsymbol{\varepsilon}(\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall d_\rho \]
</p>
<p class="formulaDsp">
\[ \int_\Gamma \mathbf d_\mathbf{u} \cdot \mathbf{t} d\partial\Omega+ \int_\Omega p\rho^{p} \left[\lambda (\nabla \cdot \mathbf d_\mathbf{u})( \nabla \cdot \mathbf{y}_1) + \mu \boldsymbol{\varepsilon}(\mathbf d_\mathbf{u}):\boldsymbol{\varepsilon}(\mathbf{y}_1)\right] d\Omega=0\;\; \forall \mathbf{d}_\mathbf{u} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega= 0\;\;\forall d_\varrho \]
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="formulaDsp">
\[ \int_\Omega \rho^{p}\lambda (\nabla \cdot \mathbf d_{\mathbf{y}_1}) (\nabla \cdot \mathbf{u}) + \rho^{p}\mu \boldsymbol{\varepsilon}(\mathbf d_{\mathbf{y}_1}) : \boldsymbol{\varepsilon}(\mathbf{u}) d\Omega - \int_\Gamma \mathbf d_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega =0 \;\;\forall \mathbf{d}_{\mathbf{y}_1} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{z_1}(\varrho - s_1) d\Omega = 0\;\;\forall d_{z_1} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{z_z}(1-\varrho-s_2) d\Omega = 0\;\;\forall d_{z_2} \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{y_2}(\rho - H(\varrho)) d\Omega = 0\;\;\forall d_{y_2} \]
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_1}(s_1z_1 - \alpha) d\Omega = 0 \;\;\forall d_{s_1} ,\;\;\; \alpha \to 0 \]
</p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_2}(s_2z_2 - \alpha) d\Omega = 0 \;\;\forall d_{s_2} ,\;\;\; \alpha \to 0 \]
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="formulaDsp">
\[ s_{1,i},s_{2,i},z_{1,i},z_{2,i} \geq 0 \;\;\;\; \forall i \]
</p>
<p class="endli"></p>
</li>
</ol>
<p></p>
<p><a class="anchor" id="Solutionprocedure"></a></p><h3>Solution procedure</h3>
<p></p>
<p> \(\{\bullet\}\)  \(c_{\{\bullet\}}\) </p>
<ol>
<li>
<p class="startli"></p>
<p>1</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega-d_\rho c_{y_2} + p(p-1) \rho^{p-2} d_\rho c_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] + p \rho^{p-1} d_\rho[\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] + p \rho^{p-1} d_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \\ &amp;= -\int_\Omega -d_\rho z_1 + d_\rho z_2 - d_\rho y_2 + p\rho^{p-1}d_\rho [\lambda \nabla \cdot \mathbf{y}_1 \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon} (\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>2</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_\rho [\lambda \nabla \cdot {\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{y})] + \rho^{p} [\lambda \nabla \cdot \mathbf{c}_{\mathbf{y}_1} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{d}_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{c}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Gamma \mathbf{d}_\mathbf{u} \cdot \mathbf{t} -\int_\Omega \rho^{p} [\lambda \nabla \cdot \mathbf{y} \nabla \cdot \mathbf{d}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(d_\mathbf{u})\boldsymbol{\varepsilon}(\mathbf{y}_1)] d\Omega \end{align}
</p>
<p>3</p>
<p class="formulaDsp">
\[ \int_\Omega - d_\varrho c_{z_1} +d_\varrho c_{z_2} + H(d_\varrho)c_{y_2} d\Omega = -\int_\Omega -d_\varrho z_1 + d_\varrho z_2 + H(d_\varrho)y_2 d\Omega \]
</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>4</p>
<p class="formulaDsp">
\begin{align} &amp;\int_\Omega p \rho^{p-1} c_p[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] + \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{c}_\mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{c}_\mathbf{u}) \boldsymbol{\varepsilon}(\mathbf{d}_{\mathbf{y}_1})] d\Omega \\ &amp;= -\int_\Omega \rho^{p}[\lambda \nabla \cdot \mathbf{d}_{\mathbf{y}_1} \nabla \cdot \mathbf{u} + \mu \boldsymbol{\varepsilon}(\mathbf{u}) \boldsymbol{\varepsilon} (\mathbf{d}_{\mathbf{y}_1})] + \int_\Gamma \mathbf{d}_{\mathbf{y}_1} \cdot \mathbf{t} d\partial\Omega \end{align}
</p>
<p>5</p>
<p class="formulaDsp">
\[ -\int_\Omega d_{z_1}(c_\varrho - c_{s_1}) d\Omega=\int_\Omega d_{z_1} (\varrho - s_1) d\Omega \]
</p>
<p>6</p>
<p class="formulaDsp">
\[ -\int_\Omega d_{z_2}(-c_\varrho-c_{s_2}) d\Omega= \int_\Omega d_{z_2} (1-\varrho-s_2) d\Omega \]
</p>
<p>7</p>
<p class="formulaDsp">
\[ -\int_\Omega d_{y_2}(c_\rho - H(c_\varrho)) d\Omega=\int_\Omega d_{y_2} (\rho - H(\varrho)) d\Omega \]
</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">&ndash; \(s^T z = 0\) </p>
<p>8</p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_1}(c_{s_1}z_1/s_1 + c_{z_1} ) d\Omega=-\int_\Omega d_{s_1} (z_1 - \alpha/s_1) d\Omega ,\;\;\; \alpha \to 0 \]
</p>
<p>9</p>
<p class="formulaDsp">
\[ \int_\Omega d_{s_2} (c_{s_2}z_2/s_2 + c_{z_2} ) d\Omega=-\int_\Omega d_{s_2} (z_2 - \alpha/s_2) d\Omega,\;\;\; \alpha \to 0 \]
</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">0 <code>SANDTopOpt::assemble_system()</code> </p>
<p class="formulaDsp">
\[ s,z \geq 0 \]
</p>
<p class="endli"></p>
</li>
</ol>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p> \(Q_1\) Lagrange \(DGQ_0\) </p>
<p><a class="anchor" id="NonlinearAlgorithm"></a></p><h3>Nonlinear Algorithm</h3>
<p> \(c_{\{\bullet\}}\)  "" \(\alpha_k \in (0,1]\)  \(\mathbf{x}_k\)  \(\mathbf{x}_{k+1}=\mathbf{x}_k+\alpha_k \mathbf{x}_k\)  \(\alpha_k=1\)  \(\mathbf{x}_k\) </p>
<p> <b>[Nocedal2009]</b> <b>[Waechter2005]</b>  <b>[Nocedal2006]</b>  \(\mathbf{x}\) &ndash; \(\mathbf{y}\)  \(\Delta \mathbf{x}\)  \(\Delta \mathbf{y}\)  \(c_{\{\bullet\}}\)  \(\phi(\mathbf{x,\mathbf{y}})\) </p>
<p> " "58KKT</p>
<p>" "</p>
<p class="formulaDsp">
\[ \beta^\mathbf{y} = \min\{1,\max \beta \text{ such that }\left(\mathbf{z}_{k+i} + \beta^\mathbf{z}_{k+i} \Delta \mathbf{z}_{k+i}\right)_j \geq \zeta \mathbf{z}_{k+i,j} \forall j\} \]
</p>
<p class="formulaDsp">
\[ \beta^\mathbf{x} = \min\{1,\max \beta \text{ such that }\left(\mathbf{s}_{k+i} + \beta^\mathbf{s}_{k+i} \Delta \mathbf{s}_{k+i}\right)_j \geq \zeta \mathbf{s}_{k+i,j} \forall j\} \]
</p>
<p> \(\zeta\)  ""<a href="https://en.wikipedia.org/wiki/Trust_region"></a> \(\zeta\)  \(\max\{0.8, 1-\alpha\}\) LOQO0.8</p>
<p> \(s_1,s_2\) </p>
<p class="formulaDsp">
\[ -\alpha \int_\Omega (\log(s_1) + \log(s_2)) d\Omega. \]
</p>
<p> \(\alpha\)  \(\alpha\to 0\)  \(\alpha\)  \(\alpha\) </p>
<p>KKT \(l_\infty\)  \(\|KKT\|_{l_\infty} &lt; c \cdot \alpha\)  \(c\)  \(\alpha\) <a href="https://coin-or.github.io/Ipopt/">IPOPT</a></p>
<p>0.61.2</p>
<p class="formulaDsp">
\[ \alpha_{k+1} = \min\{\alpha_k^{1.2},0.6\alpha_k\} \]
</p>
<p></p>
<p><a class="anchor" id="MeritFunction"></a></p><h3>Merit Function</h3>
<p> "" \(x_k\)  \(x_{k+1}\) []https://en.wikipedia.org/wiki/Wolfe_conditions</p>
<p></p>
<p> \(l_1\) </p>
<p class="formulaDsp">
\begin{align} \phi(\mathbf{x},\mathbf{y}) =&amp; \int_{\partial \Omega} \mathbf{u}\cdot \mathbf{t} d\partial\Omega- \alpha \int_\Omega (\log(s_1) + \log(s_2)) + p \sum_i\left| \int_\Omega y_{2,i}(H(\varrho) - \rho) d\Omega \right| \\ &amp; + p \sum_i\left| \int_{\partial \Omega} \mathbf{y}_{1,i}\cdot \mathbf{t} d\partial\Omega - \int_\Omega \rho^p[\lambda \nabla \cdot \mathbf{u} \nabla \cdot \mathbf{y}_{1,i} + \mu \boldsymbol{\varepsilon}{\mathbf{u}}\boldsymbol{\varepsilon}{\mathbf{y}_{1,i}}] d\Omega \right| + p \sum_i\left| \int_\Omega z_{1,i}(s_1 - \varrho) d\Omega\right| + p \sum_i\left| \int_\Omega z_{2,i}(1-\varrho - s_2) d\Omega\right| \end{align}
</p>
<p> \(p\)  \(p_0\)  \(p &gt; p_0\) NocedalWright <b>[Benson2002]</b> </p>
<p class="formulaDsp">
\[ p &gt; \frac{\frac{1}{2} \mathbf{x}^T \cdot \mathbf{H} \cdot \mathbf{x} - \mathbf{x}^T \cdot \nabla f}{\|c_i\|_{l_\infty}} \quad , i \in \mathcal{E}, \]
</p>
<p> \(\mathbf{H}\) Hessian \(\mathbf{x}\)  \(f\)  \(c_i\) </p>
<p> " "</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Preliminaries"></a> </p><h3>Preliminaries</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div></div><!-- fragment --><p>Above are fairly common files to include. These also include the one for the sparse direct class <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>. This is not the most efficient way to solve large linear problems, but it will do for now.</p>
<p>As usual, we put everything into a common namespace. We then start by declaring a number of symbolic names for constants that will be used throughout this tutorial. Specifically, we have a <em>lot</em> of variables in this program (of course the density and the displacement, but also the unfiltered density and quite a number of Lagrange multipliers). It is easy to forget which of these variables is at which position in the solution vector, and trying to use numbers for these vector components is a prescription for bugs. Rather, we define static variables that can be used in all of these places and that have to be initialized only once. In practice, this will lead to some lengthy expressions, but they are more readable and less likely to be wrong.</p>
<p>A similar issue arises with the ordering of blocks in the system matrix and in vectors. The matrices have \(9\times 9\) blocks, and it's difficult to remember which is which. It is far easier to just use symbolic names for those as well.</p>
<p>Finally, while we're at it, we introduce symbolic names also for the boundary indicators we will use, in the same spirit as was done in <a class="el" href="step_19.html">step-19</a>.</p>
<p>In all of these cases, we declare these variables as members in a namespace. In the case of the solution components, the concrete values of these variables depend on the space dimension, so we use <a href="https://en.cppreference.com/w/cpp/language/variable_template">template variables</a> to make the value of the variable depend on a template argument in the same way as we often use template functions.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>This namespace keeps track of the first component in our finite element system that corresponds to each variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionComponents</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">} <span class="comment">// namespace SolutionComponents</span></div></div><!-- fragment --><p>This is the namespace which keeps track of which block corresponds to which variable.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SolutionBlocks</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">} <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>BoundaryIds</div><div class="line">{</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">  constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">} <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ValueExtractors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">    displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">    SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">    SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">    SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">    density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">    SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">} <span class="comment">// namespace ValueExtractors</span></div></div><!-- fragment --><p><a class="anchor" id="TheSANDTopOptmainclass"></a> </p><h3>The SANDTopOpt main class</h3>
<p>Next up is the main class for this problem. The majority of functions follow the usual naming schemes of tutorial programs, though there are a couple that have been broken out of what is usually called the <code>setup_system()</code> function because of their length, and there are also a number that deal with various aspects of the optimization algorithm.</p>
<p>As an added bonus, the program writes the computed design as an STL file that one can, for example, send to a 3d printer.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SANDTopOpt</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SANDTopOpt();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Most of the member variables are also standard. There are, however, a number of variables that are specifically related to the optimization algorithm (such the various scalar factors below) as well as the filter matrix to ensure that the design remains smooth.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">  <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">  <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h3>Constructor and set-up functions</h3>
<p>We initialize a <a class="el" href="classFESystem.html">FESystem</a> composed of 2 \(\times\)dim <code><a class="el" href="classFE__Q.html">FE_Q(1)</a></code> elements for the displacement variable and its Lagrange multiplier, and 7 <code><a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a></code> elements. These piecewise constant functions are for density-related variables: the density itself, the unfiltered density, the slack variables for the lower and upper bounds on the unfiltered density, and then Lagrange multipliers for the connection between filtered and unfiltered densities as well as for the inequality constraints.</p>
<p>The order in which these elements appear is documented above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       1,</div><div class="line">       (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">       5)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , density_ratio(.5)</div><div class="line">  , density_penalty_exponent(3)</div><div class="line">  , filter_r(.251)</div><div class="line">  , penalty_multiplier(1)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p>The first step then is to create the triangulation that matches the problem description in the introduction &ndash; a 6-by-1 rectangle (or a 6-by-1-by-1 box in 3d) where a force will be applied in the top center. This triangulation is then uniformly refined a number of times.</p>
<p>In contrast to nearly the entire rest of this program, this function specifically assumes that we are in 2d and will require changes if we wanted to move to 3d simulations. We ensure that nobody tries to accidentally run in 3d without such modifications through an assertion at the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            {6, 1},</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">  triangulation.refine_global(3);</div></div><!-- fragment --><p>The second step is to apply boundary indicators to parts of the boundary. The following code assigns boundary indicators to the bottom, top, left, and right boundaries of the box, respectively. The center region of the top boundary is given a separate boundary indicator: This is where we will apply the down force.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the constraints due to boundary values. The bottom corners of the domain are kept in place in the \(y\) direction &ndash; the bottom left also in the \(x\) direction. deal.II generally thinks of boundary values as attached to pieces of the boundary, i.e., faces, rather than individual vertices. Indeed, mathematically speaking, one can not assign boundary values to individual points for the infinite-dimensional partial differential equation. But, since we are trying to reproduce a widely used benchmark, we will do so anyway and keep in mind that we have a finite-dimensional problem for which imposing boundary conditions at a single node is valid.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">{</div><div class="line">  boundary_values.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div></div><!-- fragment --><p>Check whether the current face is on the bottom boundary, and if it is whether one of its vertices might be the bottom left or bottom right vertex:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[x_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line"></div><div class="line">                      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                               <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                          <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                            cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                          boundary_values[y_displacement]            = 0;</div><div class="line">                          boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Settingupblockmatricesandvectors"></a> </p><h3>Setting up block matrices and vectors</h3>
<p>The next function makes a giant 9-by-9 block matrix, and also sets up the necessary block vectors. The sparsity pattern for this matrix includes the sparsity pattern for the filter matrix. It also initializes any block vectors we will use.</p>
<p>Setting up the blocks by themselves is not overly complicated and follows what is already done in programs such as <a class="el" href="step_22.html">step-22</a>, for example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">  block_component[0] = 0;</div><div class="line">  block_component[1] = 1;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">    n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">      dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">  dsp.collect_sizes();</div></div><!-- fragment --><p>The bulk of the function is in setting up which of these blocks will actually contain anything, i.e., which variables couple with which other variables. This is cumbersome but necessary to ensure that we don't just allocate a very large number of entries for our matrix that will then end up being zero.</p>
<p>The concrete pattern you see below is something one probably has to draw once on a piece of paper, but follows in an otherwise relatively straightforward way from looking through the many terms of the bilinear form we will have to assemble in each nonlinear iteration.</p>
<p>The use of the symbolic names defined in namespace <code>SolutionComponents</code> helps understand what each of the following terms corresponds to, but it also makes the expressions lengthy and unwieldy: A term such as <code>coupling[SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;][SolutionComponents::density&lt;dim&gt;]</code> just doesn't read very well, and would either have to be split over several lines or run off the right edge of nearly every screen. As a consequence, we open a curly-brace enclosed code block in which we temporarily make the names in namespace <code>SolutionComponents</code> available without the namespace qualifier, by saying <code>using namespace SolutionComponents</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">  coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">        {</div><div class="line">          coupling[displacement&lt;dim&gt; + i]</div><div class="line">                  [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                  [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">/* Coupling for slack variables */</span></div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">          [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">}</div></div><!-- fragment --><p>Before we can create the sparsity pattern, we also have to set up constraints. Since this program does not adaptively refine the mesh, the only constraint we have is one that couples all density variables to enforce the volume constraint. This will ultimately lead to a dense sub-block of the matrix, but there is little we can do about that.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">  fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line"><a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">  density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">constraints.clear();</div><div class="line">constraints.add_line(last_density_dof);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">  constraints.add_entry(last_density_dof,</div><div class="line">                        density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                        -1);</div><div class="line">constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">constraints.close();</div></div><!-- fragment --><p>We can now finally create the sparsity pattern for the matrix, taking into account which variables couple with which other variables, and the constraints we have on the density.</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div></div><!-- fragment --><p>The only part of the matrix we have not dealt with is the filter matrix and its transpose. These are non-local (integral) operators for which deal.II does not currently have functions. What we will ultimately need to do is go over all cells and couple the unfiltered density on this cell to all filtered densities of neighboring cells that are less than a threshold distance away, and the other way around; for the moment, we are only concerned with building the sparsity pattern that would correspond to this kind of matrix, so we perform the equivalent loop and where later on we would write into an entry of the matrix, we now simply add an entry to the sparsity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">            dsp</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Having so generated the "dynamic" sparsity pattern, we can finally copy it to the structure that is used to associate matrices with a sparsity pattern. Because the sparsity pattern is large and complex, we also output it into a file of its own for visualization purposes &ndash; in other words, for "visual debugging".</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>What is left is to correctly size the various vectors and their blocks, as well as setting initial guesses for some of the components of the (nonlinear) solution vector. We here use the symbolic component names for individual blocks of the solution vector and, for brevity, use the same trick with <code>using namespace</code> as above:</p>
<div class="fragment"><div class="line">  nonlinear_solution.reinit(block_sizes);</div><div class="line">  system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">    nonlinear_solution.block(density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">    nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">      .add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">    nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">    nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">    nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefiltermatrix"></a> </p><h3>Creating the filter matrix</h3>
<p>Next up, a function that is used once at the beginning of the program: It creates a matrix \(H\) so that the filtered density vector equals \(H\) times the unfiltered density. The creation of this matrix is non-trivial, and it is used in every iteration, and so rather than reforming it as we do with the Newton matrix, it is made only once and stored separately.</p>
<p>The way this matrix is computed follows the outline used above already to form its sparsity pattern. We repeat this process here for the sparsity pattern of this separately formed matrix, and then actually build the matrix itself. You may want to check the definition of this matrix in the introduction to this program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">{</div></div><!-- fragment --><p>The sparsity pattern of the filter has already been determined and implemented in the setup_system() function. We copy the structure from the appropriate block and use it again here.</p>
<div class="fragment"><div class="line">filter_sparsity_pattern.copy_from(</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">filter_matrix.reinit(filter_sparsity_pattern);</div></div><!-- fragment --><p>Having so built the sparsity pattern, now we re-do all of these loops to actually compute the necessary values of the matrix entries:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">          cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">        <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">          {</div><div class="line">            filter_matrix.add(i,</div><div class="line">                              check_cell-&gt;active_cell_index(),</div><div class="line">                              filter_r - distance);</div><div class="line">            </div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The final step is to normalize the matrix so that for each row, the sum of entries equals one.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> denominator = 0;</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        denominator = denominator + iter-&gt;value();</div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           iter++)</div><div class="line">        iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function is used for building the filter matrix. We create a set of all the cell iterators within a certain radius of the cell that is input. These are the neighboring cells that will be relevant for the filter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">  neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">  cells_to_check.insert(cell);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">           std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">             cells_to_check.begin(), cells_to_check.end()))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                    cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                  <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                      !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                    {</div><div class="line">                      cells_to_check.insert(neighbor);</div><div class="line">                      neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                      new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">  <span class="keywordflow">return</span> cells_to_check;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingtheNewtonmatrix"></a> </p><h3>Assembling the Newton matrix</h3>
<p>Whereas the setup_filter_matrix function built a matrix that is the same as long as the mesh does not change (which we don't do anyway in this program), the next function builds the matrix to be solved in each iteration. This is where the magic happens. The components of the system of linear equations describing Newton's method for finding the solution of the KKT conditions are implemented here.</p>
<p>The top of the function is as in most of these functions and just sets up all sorts of variables necessary for the actual assembly, including a whole bunch of extractors. The entire set up should look familiar, though somewhat lengthier, if you've previously looked at <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div></div><!-- fragment --><p>At this point, we apply the filter to the unfiltered density, and apply the adjoint (transpose) operation to the unfiltered density multiplier, both to the current best guess for the nonlinear solution. We use this later to tell us how far off our filtered density is from the filter applied to the unfiltered density. That is because while at the solution of the nonlinear problem, we have \(\rho=H\varrho\), but at intermediate iterations, we in general have \(\rho^k\neq H\varrho^k\) and the "residual" \(\rho^k-H\varrho^k\) will then appear as the right hand side of one of the Newton update equations that we compute below.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">  nonlinear_solution;</div><div class="line"></div><div class="line">filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                      SolutionBlocks::unfiltered_density),</div><div class="line">                    nonlinear_solution.block(</div><div class="line">                      SolutionBlocks::unfiltered_density));</div><div class="line">filter_matrix.Tvmult(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">  nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">  n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">  n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>ValueExtractors;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">    mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div></div><!-- fragment --><p>As part of the construction of our system matrix, we need to retrieve values from our current guess at the solution. The following lines of code retrieve the needed values.</p>
<div class="fragment"><div class="line">fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                              old_density_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_values);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_divs);</div><div class="line">fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">  nonlinear_solution, old_displacement_symmgrads);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">  nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">  .get_function_symmetric_gradients(</div><div class="line">    nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_values);</div><div class="line">fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_values);</div><div class="line">fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filtered_unfiltered_density_solution,</div><div class="line">  filtered_unfiltered_density_values);</div><div class="line">fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We need several more values corresponding to the test functions coming from the first derivatives taken from the Lagrangian, that is the \(d_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">      fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">      fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      displacement_multiplier_phi_i_symmgrad =</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">          i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                          q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">      fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                           q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">        i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div></div><!-- fragment --><p>Finally, we need values that come from the second round of derivatives taken from the Lagrangian, the \(c_{\bullet}\) functions. These are calculated here:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">  fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                   q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">  fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  displacement_multiplier_phi_j_symmgrad =</div><div class="line">    fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">      .symmetric_gradient(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">  fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">  fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">  fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">  fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">  fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">    j, q_point);</div></div><!-- fragment --><p>This is where the actual work starts. In the following, we will build all of the terms of the matrix &ndash; they are numerous and not entirely self-explanatory, also depending on the previous solutions and its derivatives (which we have already evaluated above and put into the variables called <code>old_*</code>). To understand what each of these terms corresponds to, you will want to look at the explicit form of these terms in the introduction above.</p>
<p>The right hand sides of the equations being driven to 0 give all the KKT conditions for finding a local minimum &ndash; the descriptions of what each individual equation are given with the computations of the right hand side.</p>
<div class="fragment"><div class="line">          <span class="comment">/* Equation 1 */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  (density_penalty_exponent - 1) *</div><div class="line">                  std::pow(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 2) *</div><div class="line">                  density_phi_i * density_phi_j *</div><div class="line">                  (old_displacement_multiplier_divs[q_point] *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_multiplier_phi_j_div *</div><div class="line">                     old_displacement_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_symmgrads[q_point] *</div><div class="line">                      displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">              + density_penalty_exponent *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                           density_penalty_exponent - 1) *</div><div class="line">                  density_phi_i *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     old_displacement_multiplier_divs[q_point] *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                      displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 2 */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (density_penalty_exponent *</div><div class="line">               <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent - 1) *</div><div class="line">               density_phi_j *</div><div class="line">               (old_displacement_multiplier_divs[q_point] *</div><div class="line">                  displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                2 * mu_values[q_point] *</div><div class="line">                  (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                   displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">             + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                        density_penalty_exponent) *</div><div class="line">                 (displacement_multiplier_phi_j_div *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                     displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">            );</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">           * calculated elsewhere. */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (-1 * unfiltered_density_phi_i *</div><div class="line">               lower_slack_multiplier_phi_j +</div><div class="line">             unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">          <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (</div><div class="line"></div><div class="line">              density_penalty_exponent *</div><div class="line">                <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent - 1) *</div><div class="line">                density_phi_j *</div><div class="line">                (old_displacement_divs[q_point] *</div><div class="line">                   displacement_multiplier_phi_i_div *</div><div class="line">                   lambda_values[q_point] +</div><div class="line">                 2 * mu_values[q_point] *</div><div class="line">                   (old_displacement_symmgrads[q_point] *</div><div class="line">                    displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">              + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                         density_penalty_exponent) *</div><div class="line">                  (displacement_phi_j_div *</div><div class="line">                     displacement_multiplier_phi_i_div *</div><div class="line">                     lambda_values[q_point] +</div><div class="line">                   2 * mu_values[q_point] *</div><div class="line">                     (displacement_phi_j_symmgrad *</div><div class="line">                      displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            lower_slack_multiplier_phi_i *</div><div class="line">            (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            upper_slack_multiplier_phi_i *</div><div class="line">            (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">           * is added later */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               unfiltered_density_multiplier_phi_i *</div><div class="line">                               (density_phi_j);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">             + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                 old_lower_slack_multiplier_values[q_point] /</div><div class="line">                 old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">          <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">            (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">             + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                 old_upper_slack_multiplier_values[q_point] /</div><div class="line">                 old_upper_slack_values[q_point]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have everything assembled, all we have to do is deal with the effect of (Dirichlet) boundary conditions and other constraints. We incorporate the former locally with just the contributions from the current cell, and then let the AffineConstraint class deal with the latter while copying contributions from the current cell into the global linear system:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                           local_dof_indices,</div><div class="line">                                           cell_matrix,</div><div class="line">                                           dummy_cell_rhs,</div><div class="line">                                           <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Having accumulated all of the terms that belong into the Newton matrix, we now also have to compute the terms for the right hand side (i.e., the negative residual). We already do this in another function, and so we call that here:</p>
<div class="fragment"><div class="line">system_rhs = calculate_test_rhs(nonlinear_solution);</div></div><!-- fragment --><p>Here we use the filter matrix we have already constructed. We only need to integrate this filter applied to test functions, which are piecewise constant, and so the integration becomes a simple multiplication by the measure of the cell. Iterating over the pre-made filter matrix allows us to use the information about which cells are in or out of the filter without repeatedly checking neighbor cells again.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">             filter_matrix.begin(i);</div><div class="line">           iter != filter_matrix.end(i);</div><div class="line">           ++iter)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                   SolutionBlocks::unfiltered_density)</div><div class="line">            .add(i, j, value);</div><div class="line">          system_matrix</div><div class="line">            .block(SolutionBlocks::unfiltered_density,</div><div class="line">                   SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">            .add(j, i, value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvingtheNewtonlinearsystem"></a> </p><h3>Solving the Newton linear system</h3>
<p>We will need to solve a linear system in each iteration. We use a direct solver, for now &ndash; this is clearly not an efficient choice for a matrix that has so many non-zeroes, and it will not scale to anything interesting. For "real" applications, we will need an iterative solver but the complexity of the system means that an iterative solver algorithm will take a good deal of work. Because this is not the focus of the current program, we simply stick with the direct solver we have here &ndash; the function follows the same structure as used in <a class="el" href="step_29.html">step-29</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">  linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> linear_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Detailsoftheoptimizationalgorithm"></a> </p><h3>Details of the optimization algorithm</h3>
<p>The next several functions deal with specific parts of the optimization algorithm, most notably with deciding whether the direction computed by solving the linearized (Newton) system is viable and, if so, how far we want to go in this direction.</p>
<p><a class="anchor" id="Computingsteplengths"></a> </p><h4>Computing step lengths</h4>
<p>We start with a function that does a binary search to figure out the maximum step that meets the dual feasibility &ndash; that is, how far can we go so that \(s&gt;0\) and \(z&gt;0\). The function returns a pair of values, one each for the \(s\) and \(z\) slack variables.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">        fraction_to_boundary = 1 - barrier_size;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">  <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">  <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">    {</div><div class="line">      step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">      step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">        (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">        (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">           .is_non_negative());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">           .is_non_negative()) &amp;&amp;</div><div class="line">        (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">           .is_non_negative());</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_s)</div><div class="line">        step_size_s_low = step_size_s;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (accept_z)</div><div class="line">        step_size_z_low = step_size_z;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size_z_high = step_size_z;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingresiduals"></a> </p><h4>Computing residuals</h4>
<p>The next function computes a right hand side vector linearized around a "test solution vector" that we can use to look at the magnitude of the KKT conditions. This is then used for testing the convergence before shrinking the barrier size, as well as in the calculation of the \(l_1\) merit.</p>
<p>The function is lengthy and complicated, but it is really just a copy of the right hand side part of what the <code>assemble_system()</code> function above did.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>We first create a zero vector with size and blocking of system_rhs</p>
<div class="fragment"><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">  test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">    test_solution;</div><div class="line">  filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density) = 0;</div><div class="line">  filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">    SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">  filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density),</div><div class="line">                      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                        SolutionBlocks::unfiltered_density));</div><div class="line">  filter_matrix.Tvmult(</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">    test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">    n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">      mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">      fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                    old_density_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_values);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_divs);</div><div class="line">      fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">        test_solution, old_displacement_symmgrads);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_displacement_multiplier_values);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">        test_solution, old_displacement_multiplier_divs);</div><div class="line">      fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">        .get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">      fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_values);</div><div class="line">      fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_lower_slack_multiplier_values);</div><div class="line">      fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_values);</div><div class="line">      fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_upper_slack_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">      fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filtered_unfiltered_density_solution,</div><div class="line">        filtered_unfiltered_density_values);</div><div class="line">      fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">        filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                displacement_multiplier_phi_i_symmgrad =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                    i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                    q_point);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                     q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                  i, q_point);</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">               * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">               * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">               * variables - the density, displacement, and</span></div><div class="line"><span class="comment">               * unfiltered density. */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (density_penalty_exponent *</div><div class="line">                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent - 1) *</div><div class="line">                   density_phi_i *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      old_displacement_divs[q_point] *</div><div class="line">                      lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_symmgrads[q_point] *</div><div class="line">                       old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                 density_phi_i *</div><div class="line">                   old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">               * below. */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                          density_penalty_exponent) *</div><div class="line">                 (old_displacement_multiplier_divs[q_point] *</div><div class="line">                    displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                  2 * mu_values[q_point] *</div><div class="line">                    (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                     displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 3 */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (unfiltered_density_phi_i *</div><div class="line">                   filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                     [q_point] +</div><div class="line">                 unfiltered_density_phi_i *</div><div class="line">                   old_upper_slack_multiplier_values[q_point] +</div><div class="line">                 -1 * unfiltered_density_phi_i *</div><div class="line">                   old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">              <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">               * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">               * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">               * a constraint. */</span></div><div class="line">              cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                       density_penalty_exponent) *</div><div class="line">                              (old_displacement_divs[q_point] *</div><div class="line">                                 displacement_multiplier_phi_i_div *</div><div class="line">                                 lambda_values[q_point] +</div><div class="line">                               2 * mu_values[q_point] *</div><div class="line">                                 (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                  old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">               * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">               * giving a minimum density of 0. */</span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (lower_slack_multiplier_phi_i *</div><div class="line">                              (old_unfiltered_density_values[q_point] -</div><div class="line">                               old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">               * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">               * density. */</span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (upper_slack_multiplier_phi_i *</div><div class="line">                              (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                               old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">               * density and the filter applied to the</span></div><div class="line"><span class="comment">               * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">               * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">               * applied correctly. */</span></div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                             (unfiltered_density_multiplier_phi_i *</div><div class="line">                              (old_density_values[q_point] -</div><div class="line">                               filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">               * requirement that s*z = \alpha for the barrier</span></div><div class="line"><span class="comment">               * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">               * from KKT conditions when \alpha goes to 0. */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (lower_slack_phi_i *</div><div class="line">                 (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">              <span class="comment">/* Equation 9 */</span></div><div class="line">              cell_rhs(i) +=</div><div class="line">                -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                (upper_slack_phi_i *</div><div class="line">                 (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                  barrier_size / old_upper_slack_values[q_point]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                   fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        -1 *</div><div class="line">                        (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                      i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (traction *</div><div class="line">                         fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                           i, face_q_point)) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               dummy_cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             test_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> test_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingthemeritfunction"></a> </p><h4>Computing the merit function</h4>
<p>The algorithm we use herein uses a "watchdog" strategy to determine where and how far to go from the current iterate. We base the watchdog strategy on an exact \(l_1\) merit function. This function calculates the exact \(l_1\) merit of a given, putative, next iterate.</p>
<p>The merit function consists of the sum of the objective function (which is simply an integral of external forces (on the boundary of the domain) times the displacement values of a test solution (typically, the current solution plus some multiple of the Newton update), and the \(l_1\) norms of the Lagrange multiplier components of residual vectors. The following code computes these parts in turn:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div></div><!-- fragment --><p>Start with computing the objective function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">              face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">              fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                     displacement_face_values);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                   face_q_point &lt; n_face_q_points;</div><div class="line">                   ++face_q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                  traction[1] = -1.;</div><div class="line"></div><div class="line">                  objective_function_merit +=</div><div class="line">                    (traction * displacement_face_values[face_q_point]) *</div><div class="line">                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">    objective_function_merit =</div><div class="line">      objective_function_merit -</div><div class="line">      barrier_size * cell-&gt;measure() *</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">          SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">  }</div></div><!-- fragment --><p>Then compute the residual and take the \(l_1\) norms of the components that correspond to Lagrange mulipliers. We add those to the objective function computed above, and return the sum at the bottom:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">    penalty_multiplier *</div><div class="line">    test_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">    objective_function_merit + elasticity_constraint_merit +</div><div class="line">    filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">  <span class="keywordflow">return</span> total_merit;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Findingasearchdirection"></a> </p><h4>Finding a search direction</h4>
<p>Next up is the function that actually computes a search direction starting at the current state (passed as the first argument) and returns the resulting vector. To this end, the function first calls the functions that assemble the linear system that corresponds to the Newton system, and that solve it.</p>
<p>This function also updates the penalty multiplier in the merit function, and then returns the largest scaled feasible step. It uses the <code>calculate_max_step_sizes()</code> function to find the largest feasible step that satisfies \(s&gt;0\) and \(z&gt;0\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">{</div><div class="line">  assemble_system();</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div></div><!-- fragment --><p>Next we are going to update penalty_multiplier. In essence, a larger penalty multiplier makes us consider the constraints more. Looking at the Hessian and gradient with respect to the step we want to take with our decision variables, and comparing that to the norm of our constraint error gives us a way to ensure that our merit function is "exact" - that is, it has a minimum in the same location that the objective function does. As our merit function is exact for any penalty multiplier over some minimum value, we only keep the computed value if it increases the penalty multiplier.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">  SolutionBlocks::density,</div><div class="line">  SolutionBlocks::displacement,</div><div class="line">  SolutionBlocks::unfiltered_density,</div><div class="line">  SolutionBlocks::density_upper_slack,</div><div class="line">  SolutionBlocks::density_lower_slack};</div><div class="line"><span class="keywordtype">double</span> hess_part = 0;</div><div class="line"><span class="keywordtype">double</span> grad_part = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">      {</div><div class="line">        Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">        system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">          .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">        hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">      }</div><div class="line">    grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                 step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">  SolutionBlocks::displacement_multiplier,</div><div class="line">  SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">  SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">  SolutionBlocks::density_upper_slack_multiplier};</div><div class="line"><span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">  constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line"><span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">  test_penalty_multiplier =</div><div class="line">    (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div></div><!-- fragment --><p>Based on all of this, we can now compute step sizes for the primal and dual (Lagrange multiplier) variables. Once we have these, we scale the components of the solution vector, and that is what this function returns.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">    calculate_max_step_size(nonlinear_solution, step);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">  step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingascaledstep"></a> </p><h4>Computing a scaled step</h4>
<p>The next function then implements a back-tracking algorithm for a line search. It keeps shrinking step size until it finds a step where the merit is decreased, and then returns the new location based on the current state vector, and the direction to go into, times the step length.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">    (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">     calculate_exact_merit(state)) /</div><div class="line">    1e-4;</div><div class="line">  <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">          calculate_exact_merit(state) +</div><div class="line">            step_size * descent_requirement * merit_derivative)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        step_size = step_size / 2;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Checkingforconvergence"></a> </p><h4>Checking for convergence</h4>
<p>The final auxiliary function in this block is the one that checks to see if the KKT conditions are sufficiently met so that the overall algorithm can lower the barrier size. It does so by computing the \(l_1\) norm of the residual, which is what <code>calculate_test_rhs()</code> computes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">            &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessingthesolution"></a> </p><h3>Postprocessing the solution</h3>
<p>The first of the postprocessing functions outputs information in a VTU file for visualization. It looks long, but it's really just the same as what was done in <a class="el" href="step_22.html">step-22</a>, for example, just with (a lot) more solution variables:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    }</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p>The second of these functions outputs the solution as an <code>.stl</code> file for 3d printing. <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files are made up of triangles and normal vectors, and we will use it to show all of those cells with a density value larger than zero by first extruding the mesh from a \(z\) value of zero to \(z=0.25\), and then generating two triangles for each face of the cells with a sufficiently large density value. The triangle nodes must go counter-clockwise when looking from the outside, and the normal vectors must be unit vectors pointing outwards, which requires a few checks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">{</div><div class="line">  static_assert(dim == 2,</div><div class="line">                <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">  std::ofstream stlfile;</div><div class="line">  stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">  <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">            SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">        {</div></div><!-- fragment --><p>We have now found a cell with a density value larger than zero. Let us start by writing out the bottom and top faces. Owing to the ordering issue mentioned above, we have to make sure that we understand whether a cell has a right- or left-handed coordinate system. We do this by interrogating the directions of the two edges starting at vertex 0 and whether they form a right-handed coordinate system.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                             cell-&gt;vertex(0),</div><div class="line">                                           cell-&gt;vertex(2) -</div><div class="line">                                             cell-&gt;vertex(0)};</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">  {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">   {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">  {</div><div class="line">    <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Write one side at z = height. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">  {</div><div class="line">    <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Write one side at z = height. */</span></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --><p>Next we need to deal with the four faces of the cell, extended into the \(z\) direction. However, we only need to write these faces if either the face is on the domain boundary, or if it is the interface between a cell with density greater than 0.5, and a cell with a density less than 0.5.</p>
<div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">               face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">               ++face_number)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                cell-&gt;face(face_number);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                  (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                   (nonlinear_solution.block(</div><div class="line">                      0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                    0.5)))</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                    (face-&gt;center() - cell-&gt;center());</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                  <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          0.000000e+00 +</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                          normal_vector[0] +</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                          normal_vector[1] -</div><div class="line">                        (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                          (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                          normal_vector[0] -</div><div class="line">                        (height - 0) *</div><div class="line">                          (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                      0)</div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                              &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                      stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">  stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctiondrivingtheoverallalgorithm"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function driving the overall algorithm</h3>
<p>This function finally provides the overall driver logic. It is, in the grand scheme of things, a rather complicated function primarily because the optimization algorithm is difficult: It isn't just about finding a Newton direction like in <a class="el" href="step_15.html">step-15</a> and then going a fixed distance in this direction any more, but instead about (i) determining what the optimal log-barrier penalty parameter should be in the current step, (ii) a complicated algorithm to determine how far we want to go, and other ingredients. Let us see how we can break this down into smaller chunks in the following documentation.</p>
<p>The function starts out simple enough with first setting up the mesh, the <a class="el" href="classDoFHandler.html">DoFHandler</a>, and then the various linear algebra objects necessary for the following:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    setup_boundary_values();</div><div class="line">    setup_block_system();</div><div class="line">    setup_filter_matrix();</div><div class="line">  }</div></div><!-- fragment --><p>We then set a number of parameters that affect the log-barrier and line search components of the optimization algorithm:</p>
<div class="fragment"><div class="line">barrier_size                  = 25;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div></div><!-- fragment --><p>Now start the principal iteration. The overall algorithm works by using an outer loop in which we loop until either (i) the log-barrier parameter has become small enough, or (ii) we have reached convergence. In any case, we terminate if end up with too large a number of iterations. This overall structure is encoded as a <code>do { ... } while (...)</code> loop where the convergence condition is at the bottom.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div></div><!-- fragment --><p>Within this outer loop, we have an inner loop in which we try to find an update direction using the watchdog algorithm described in the introduction.</p>
<p>The general idea of the watchdog algorithm itself is this: For a maximum of <code>max_uphill_steps</code> (i.e., a loop within the "inner loop" mentioned above) attempts, we use <code>find_max_step()</code> to compute a Newton update step, and add these up in the <code>nonlinear_solution</code> vector. In each of these attempts (starting from the place reached at the end of the previous attempt), we check whether we have reached a target value of the merit function described above. The target value is computed based on where this algorithm starts (the <code>nonlinear_solution</code> at the beginning of the watchdog loop, saves as <code>watchdog_state</code>) and the first proposed direction provided by <code>find_max_step()</code> in the first go-around of this loop (the <code>k==0</code> case).</p>
<div class="fragment"><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">              &lt;&lt; iteration_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">              &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">    <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">    <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">      {</div><div class="line">        ++iteration_number;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (k == 0)</div><div class="line">          {</div><div class="line">            first_step = update_step;</div><div class="line">            merit_derivative =</div><div class="line">              ((calculate_exact_merit(watchdog_state +</div><div class="line">                                      .0001 * first_step) -</div><div class="line">                calculate_exact_merit(watchdog_state)) /</div><div class="line">               .0001);</div><div class="line">            target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                           descent_requirement * merit_derivative;</div><div class="line">          }</div><div class="line"></div><div class="line">        nonlinear_solution += update_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">          calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                  &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                  &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">          {</div><div class="line">            watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>The next part of the algorithm then depends on whether the watchdog loop above succeeded. If it did, then we are satisfied and no further action is necessary: We just stay where we are. If, however, we took the maximal number of unsuccessful steps in the loop above, then we need to do something else, and this is what the following code block does.</p>
<p>Specifically, from the final (unsuccessful) state of the loop above, we seek one more update direction and take what is called a "stretch
   step". If that stretch state satisfies a condition involving the merit function, then we go there. On the other hand, if the stretch state is also unacceptable (as all of the watchdog steps above were), then we discard all of the watchdog steps taken above and start over again where we had started the watchdog iterations &ndash; that place was stored in the <code>watchdog_state</code> variable above. More specifically, the conditions below first test whether we take a step from <code>watchdog_state</code> in direction <code>first_step</code>, or whether we can do one more update from the stretch state to find a new place. It is possible that neither of these is actually better than the state we started from at the beginning of the watchdog algorithm, but even if that is so, that place clearly was a difficult place to be in, and getting away to start the next iteration from another place might be a useful strategy to eventually converge.</p>
<p>We keep repeating the watchdog steps above along with the logic below until this inner iteration is finally converged (or if we run up against the maximal number of iterations &ndash; where we count the number of linear solves as iterations and increment the counter every time we call <code>find_max_step()</code> since that is where the linear solve actually happens). In any case, at the end of each of these inner iterations we also output the solution in a form suitable for visualization.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    ++iteration_number;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">      compute_scaled_step(nonlinear_solution,</div><div class="line">                          update_step,</div><div class="line">                          descent_requirement);</div></div><!-- fragment --><p>If we did not get a successful watchdog step, we now need to decide between going back to where we started, or using the final state. We compare the merits of both of these locations, and then take a scaled step from whichever location is better. As the scaled step is guaranteed to lower the merit, we will end up keeping one of the two.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">             calculate_exact_merit(watchdog_state)) ||</div><div class="line">            (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            nonlinear_solution = stretch_state;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            std::cout</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                calculate_exact_merit(watchdog_state))</div><div class="line">              {</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(watchdog_state,</div><div class="line">                                      first_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                nonlinear_solution = stretch_state;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                  find_max_step();</div><div class="line">                nonlinear_solution =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      stretch_step,</div><div class="line">                                      descent_requirement);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    output_results(iteration_number);</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">       (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div></div><!-- fragment --><p>At the end of the outer loop, we have to update the barrier parameter, for which we use the following formula. The rest of the function is then simply about checking the outer loop convergence condition, and if we decide to terminate computations, about writing the final "design" as an STL file for use in 3d printing, and to output some timing information.</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The remainder of the code, the <code>main()</code> function, is as usual:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-79/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="TestProblem"></a></p><h3>Test Problem</h3>
<p>Messerschmitt-Bolkow-Blohm BeamMBB Beam</p>
<p>61 \(y\) DirichletNeumann</p>
<p>6331 \(x\)  <b>[Bendse2004]</b></p>
<div style="text-align:center;"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.mbbgeometry.png" alt="MBB"/>
</div>
 </div><p>MBB</p>
<div class="onecolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.filtereddensity.png" alt=""/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-79.unfiltereddensity.png" alt=""/>
</div>
 </div> </div><p> <b>[Bendse2004]</b>  " "</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h4>Possibilities for extensions</h4>
<p>75LOQO</p>
<p></p>
<p>SparseDirectUMFPACK</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Justin O&#39;Connor, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="signaling__nan_8h.html">deal.II/base/signaling_nan.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="packaged__operation_8h.html">deal.II/lac/packaged_operation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SAND</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionComponents</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density = 0;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement = 1;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density = 1 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier = 2 + dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier = 2 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack = 3 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 4 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack = 5 + 2 * dim;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 6 + 2 * dim;</div><div class="line">  } <span class="comment">// namespace SolutionComponents</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SolutionBlocks</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density                        = 0;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement                   = 1;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density             = 2;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displacement_multiplier        = 3;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unfiltered_density_multiplier  = 4;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack            = 5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_lower_slack_multiplier = 6;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack            = 7;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> density_upper_slack_multiplier = 8;</div><div class="line">  } <span class="comment">// namespace SolutionBlocks</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>BoundaryIds</div><div class="line">  {</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> down_force = 101;</div><div class="line">    constexpr <a class="code" href="classunsigned_01int.html">types::boundary_id</a> no_force   = 102;</div><div class="line">  } <span class="comment">// namespace BoundaryIds</span></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>ValueExtractors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      densities(SolutionComponents::density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="line">      displacements(SolutionComponents::displacement&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      unfiltered_densities(SolutionComponents::unfiltered_density&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement_multipliers(</div><div class="line">      SolutionComponents::displacement_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> unfiltered_density_multipliers(</div><div class="line">      SolutionComponents::unfiltered_density_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_lower_slacks(SolutionComponents::density_lower_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_lower_slack_multipliers(</div><div class="line">      SolutionComponents::density_lower_slack_multiplier&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="line">      density_upper_slacks(SolutionComponents::density_upper_slack&lt;dim&gt;);</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> density_upper_slack_multipliers(</div><div class="line">      SolutionComponents::density_upper_slack_multiplier&lt;dim&gt;);</div><div class="line">  } <span class="comment">// namespace ValueExtractors</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SANDTopOpt</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SANDTopOpt();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_block_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_filter_matrix();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solve();</div><div class="line"></div><div class="line">    std::pair&lt;double, double&gt;</div><div class="line">    calculate_max_step_size(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">    calculate_test_rhs(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> calculate_exact_merit(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> find_max_step();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> write_as_stl();</div><div class="line"></div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">    find_relevant_neighbors(</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      filter_sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; filter_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> nonlinear_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_ratio;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> density_penalty_exponent;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_r;</div><div class="line">    <span class="keywordtype">double</span>       penalty_multiplier;</div><div class="line">    <span class="keywordtype">double</span>       barrier_size;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::SANDTopOpt()</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         1,</div><div class="line">         (<a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1) ^ dim)),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(0),</div><div class="line">         5)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , density_ratio(.5)</div><div class="line">    , density_penalty_exponent(3)</div><div class="line">    , filter_r(.251)</div><div class="line">    , penalty_multiplier(1)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt; 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">SANDTopOpt&lt;dim&gt;::create_triangulation</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              {6, 1},</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0),</div><div class="line">                                              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(6, 1));</div><div class="line"></div><div class="line">    triangulation.refine_global(3);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 1) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0) - 3) &lt; .3))</div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::down_force);</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  face-&gt;set_boundary_id(BoundaryIds::no_force);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_boundary_values()</div><div class="line">  {</div><div class="line">    boundary_values.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> center = face-&gt;center();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1) - 0) &lt; 1e-12)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex_number : cell-&gt;vertex_indices())</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> vert = cell-&gt;vertex(vertex_number);</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 0) &lt; 1e-12 &amp;&amp;</div><div class="line">                            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 0);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> x_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 2);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[x_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[x_displacement_multiplier] = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line"></div><div class="line">                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(0) - 6) &lt; 1e-12 &amp;&amp;</div><div class="line">                                 <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(vert(1) - 0) &lt; 1e-12)</div><div class="line">                          {</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 1);</div><div class="line">                            <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> y_displacement_multiplier =</div><div class="line">                              cell-&gt;vertex_dof_index(vertex_number, 3);</div><div class="line"></div><div class="line">                            boundary_values[y_displacement]            = 0;</div><div class="line">                            boundary_values[y_displacement_multiplier] = 0;</div><div class="line">                          }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_block_system()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; block_component(9, 2);</div><div class="line">    block_component[0] = 0;</div><div class="line">    block_component[1] = 1;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_p = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a>                     n_u = dofs_per_block[1];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes = {</div><div class="line">      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(9, 9);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 9; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 9; ++j)</div><div class="line">        dsp.block(j, k).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(block_sizes[j], block_sizes[k]);</div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(2 * dim + 7, 2 * dim + 7);</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionComponents;</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement&lt;dim&gt; + i][density&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          coupling[density&lt;dim&gt;][displacement_multiplier&lt;dim&gt; + i] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          coupling[displacement_multiplier&lt;dim&gt; + i][density&lt;dim&gt;] =</div><div class="line">            <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      coupling[density&lt;dim&gt;][unfiltered_density_multiplier&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[unfiltered_density_multiplier&lt;dim&gt;][density&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for displacement */</span></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k)</div><div class="line">            {</div><div class="line">              coupling[displacement&lt;dim&gt; + i]</div><div class="line">                      [displacement_multiplier&lt;dim&gt; + k] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">              coupling[displacement_multiplier&lt;dim&gt; + k]</div><div class="line">                      [displacement&lt;dim&gt; + i] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="comment">/* Coupling for slack variables */</span></div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack&lt;dim&gt;][density_upper_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack&lt;dim&gt;][density_lower_slack&lt;dim&gt;] =</div><div class="line">        <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_lower_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_upper_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      coupling[density_upper_slack_multiplier&lt;dim&gt;]</div><div class="line">              [density_lower_slack_multiplier&lt;dim&gt;] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> density_mask =</div><div class="line">      fe.<a class="code" href="classComponentMask.html#a9fd6407bb6b49fc218e0f8b61c2b4231">component_mask</a>(ValueExtractors::densities&lt;dim&gt;);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> density_dofs =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof_handler, density_mask);</div><div class="line"></div><div class="line">    <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> last_density_dof =</div><div class="line">      density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1);</div><div class="line">    constraints.clear();</div><div class="line">    constraints.add_line(last_density_dof);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; density_dofs.<a class="code" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a>() - 1; ++i)</div><div class="line">      constraints.add_entry(last_density_dof,</div><div class="line">                            density_dofs.<a class="code" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a>(i),</div><div class="line">                            -1);</div><div class="line">    constraints.set_inhomogeneity(last_density_dof, 0);</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, coupling, dsp, constraints);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density,</div><div class="line">                         SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">                dsp</div><div class="line">                  .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                         SolutionBlocks::unfiltered_density)</div><div class="line">                  .<a class="code" href="classDynamicSparsityPattern.html#ae8b1dc183fb130d188ee13a5c8ba9324">add</a>(i, check_cell-&gt;active_cell_index());</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    std::ofstream out(<span class="stringliteral">&quot;sparsity.plt&quot;</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a2c70aa32631904ba92abf0562a00cc58">print_gnuplot</a>(out);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    nonlinear_solution.reinit(block_sizes);</div><div class="line">    system_rhs.reinit(block_sizes);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>SolutionBlocks;</div><div class="line">      nonlinear_solution.block(density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density).add(density_ratio);</div><div class="line">      nonlinear_solution.block(unfiltered_density_multiplier)</div><div class="line">        .add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack).add(density_ratio);</div><div class="line">      nonlinear_solution.block(density_lower_slack_multiplier).add(50);</div><div class="line">      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);</div><div class="line">      nonlinear_solution.block(density_upper_slack_multiplier).add(50);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::setup_filter_matrix()</div><div class="line">  {</div><div class="line"></div><div class="line">    filter_sparsity_pattern.copy_from(</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(SolutionBlocks::unfiltered_density,</div><div class="line">                             SolutionBlocks::unfiltered_density_multiplier));</div><div class="line">    filter_matrix.reinit(filter_sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell : find_relevant_neighbors(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">              cell-&gt;center().distance(check_cell-&gt;center());</div><div class="line">            <span class="keywordflow">if</span> (distance &lt; filter_r)</div><div class="line">              {</div><div class="line">                filter_matrix.add(i,</div><div class="line">                                  check_cell-&gt;active_cell_index(),</div><div class="line">                                  filter_r - distance);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; filter_matrix.m(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> denominator = 0;</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          denominator = denominator + iter-&gt;value();</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter = filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             iter++)</div><div class="line">          iter-&gt;value() = iter-&gt;value() / denominator;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt;</div><div class="line">  SANDTopOpt&lt;dim&gt;::find_relevant_neighbors(</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::set&lt;unsigned int&gt;                               neighbor_ids;</div><div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::cell_iterator&gt; cells_to_check;</div><div class="line"></div><div class="line">    neighbor_ids.insert(cell-&gt;active_cell_index());</div><div class="line">    cells_to_check.insert(cell);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> new_neighbors_found;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        new_neighbors_found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;check_cell :</div><div class="line">             std::vector&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>&gt;(</div><div class="line">               cells_to_check.begin(), cells_to_check.end()))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : check_cell-&gt;face_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!(check_cell-&gt;face(n)-&gt;at_boundary()))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor = check_cell-&gt;neighbor(n);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> distance =</div><div class="line">                      cell-&gt;center().distance(neighbor-&gt;center());</div><div class="line">                    <span class="keywordflow">if</span> ((distance &lt; filter_r) &amp;&amp;</div><div class="line">                        !(neighbor_ids.count(neighbor-&gt;active_cell_index())))</div><div class="line">                      {</div><div class="line">                        cells_to_check.insert(neighbor);</div><div class="line">                        neighbor_ids.insert(neighbor-&gt;active_cell_index());</div><div class="line">                        new_neighbors_found = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (new_neighbors_found);</div><div class="line">    <span class="keywordflow">return</span> cells_to_check;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>        fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     dummy_cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                    lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                    mu_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution =</div><div class="line">      nonlinear_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      nonlinear_solution;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        nonlinear_solution.block(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(nonlinear_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          nonlinear_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          nonlinear_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            nonlinear_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          nonlinear_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_j_symmgrad =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].symmetric_gradient(j,</div><div class="line">                                                                       q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_j_div =</div><div class="line">                      fe_values[displacements&lt;dim&gt;].divergence(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                      displacement_multiplier_phi_j_symmgrad =</div><div class="line">                        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">                          .symmetric_gradient(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_j_div =</div><div class="line">                      fe_values[displacement_multipliers&lt;dim&gt;].divergence(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_j =</div><div class="line">                      fe_values[densities&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_j =</div><div class="line">                      fe_values[unfiltered_densities&lt;dim&gt;].value(j, q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_j =</div><div class="line">                      fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_j =</div><div class="line">                      fe_values[density_lower_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_j =</div><div class="line">                      fe_values[density_upper_slacks&lt;dim&gt;].value(j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_j =</div><div class="line">                      fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                        j, q_point);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 1 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        -density_phi_i * unfiltered_density_multiplier_phi_j</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            (density_penalty_exponent - 1) *</div><div class="line">                            std::pow(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 2) *</div><div class="line">                            density_phi_i * density_phi_j *</div><div class="line">                            (old_displacement_multiplier_divs[q_point] *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                old_displacement_multiplier_symmgrads[q_point]))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_multiplier_phi_j_div *</div><div class="line">                               old_displacement_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_symmgrads[q_point] *</div><div class="line">                                displacement_multiplier_phi_j_symmgrad))</div><div class="line"></div><div class="line">                        + density_penalty_exponent *</div><div class="line">                            <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                     density_penalty_exponent - 1) *</div><div class="line">                            density_phi_i *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               old_displacement_multiplier_divs[q_point] *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                                displacement_phi_j_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 2 */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (density_penalty_exponent *</div><div class="line">                         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent - 1) *</div><div class="line">                         density_phi_j *</div><div class="line">                         (old_displacement_multiplier_divs[q_point] *</div><div class="line">                            displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                          2 * mu_values[q_point] *</div><div class="line">                            (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                             displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                       + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                  density_penalty_exponent) *</div><div class="line">                           (displacement_multiplier_phi_j_div *</div><div class="line">                              displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                            2 * mu_values[q_point] *</div><div class="line">                              (displacement_multiplier_phi_j_symmgrad *</div><div class="line">                               displacement_phi_i_symmgrad))</div><div class="line"></div><div class="line">                      );</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 3, which has to do with the filter and which is</span></div><div class="line"><span class="comment">                     * calculated elsewhere. */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (-1 * unfiltered_density_phi_i *</div><div class="line">                         lower_slack_multiplier_phi_j +</div><div class="line">                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 4: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (</div><div class="line"></div><div class="line">                        density_penalty_exponent *</div><div class="line">                          <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent - 1) *</div><div class="line">                          density_phi_j *</div><div class="line">                          (old_displacement_divs[q_point] *</div><div class="line">                             displacement_multiplier_phi_i_div *</div><div class="line">                             lambda_values[q_point] +</div><div class="line">                           2 * mu_values[q_point] *</div><div class="line">                             (old_displacement_symmgrads[q_point] *</div><div class="line">                              displacement_multiplier_phi_i_symmgrad))</div><div class="line"></div><div class="line">                        + <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                   density_penalty_exponent) *</div><div class="line">                            (displacement_phi_j_div *</div><div class="line">                               displacement_multiplier_phi_i_div *</div><div class="line">                               lambda_values[q_point] +</div><div class="line">                             2 * mu_values[q_point] *</div><div class="line">                               (displacement_phi_j_symmgrad *</div><div class="line">                                displacement_multiplier_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 5: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      lower_slack_multiplier_phi_i *</div><div class="line">                      (unfiltered_density_phi_j - lower_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 6: Primal feasibility */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      upper_slack_multiplier_phi_i *</div><div class="line">                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 7: Primal feasibility - the part with the filter</span></div><div class="line"><span class="comment">                     * is added later */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                                         unfiltered_density_multiplier_phi_i *</div><div class="line">                                         (density_phi_j);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 8: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (lower_slack_phi_i * lower_slack_multiplier_phi_j</div><div class="line"></div><div class="line">                       + lower_slack_phi_i * lower_slack_phi_j *</div><div class="line">                           old_lower_slack_multiplier_values[q_point] /</div><div class="line">                           old_lower_slack_values[q_point]);</div><div class="line"></div><div class="line">                    <span class="comment">/* Equation 9: Complementary slackness */</span></div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                      (upper_slack_phi_i * upper_slack_multiplier_phi_j</div><div class="line"></div><div class="line"></div><div class="line">                       + upper_slack_phi_i * upper_slack_phi_j *</div><div class="line">                           old_upper_slack_multiplier_values[q_point] /</div><div class="line">                           old_upper_slack_values[q_point]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 cell_matrix,</div><div class="line">                                                 dummy_cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    system_rhs = calculate_test_rhs(nonlinear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = cell-&gt;active_cell_index();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrix&lt;double&gt;::iterator</a> iter =</div><div class="line">               filter_matrix.begin(i);</div><div class="line">             iter != filter_matrix.end(i);</div><div class="line">             ++iter)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j     = iter-&gt;column();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>       value = iter-&gt;value() * cell-&gt;measure();</div><div class="line"></div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">                     SolutionBlocks::unfiltered_density)</div><div class="line">              .add(i, j, value);</div><div class="line">            system_matrix</div><div class="line">              .block(SolutionBlocks::unfiltered_density,</div><div class="line">                     SolutionBlocks::unfiltered_density_multiplier)</div><div class="line">              .add(j, i, value);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;solver&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> linear_solution;</div><div class="line">    linear_solution.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(nonlinear_solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(linear_solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(linear_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> linear_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt; SANDTopOpt&lt;dim&gt;::calculate_max_step_size(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;step)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span>       fraction_to_boundary;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_fraction_to_boundary = .8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_fraction_to_boundary = 1. - 1e-5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (min_fraction_to_boundary &lt; 1 - barrier_size)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (1 - barrier_size &lt; max_fraction_to_boundary)</div><div class="line">          fraction_to_boundary = 1 - barrier_size;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          fraction_to_boundary = max_fraction_to_boundary;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      fraction_to_boundary = min_fraction_to_boundary;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> step_size_s_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_low  = 0;</div><div class="line">    <span class="keywordtype">double</span> step_size_s_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_z_high = 1;</div><div class="line">    <span class="keywordtype">double</span> step_size_s, step_size_z;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> max_bisection_method_steps = 50;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_bisection_method_steps; ++k)</div><div class="line">      {</div><div class="line">        step_size_s = (step_size_s_low + step_size_s_high) / 2;</div><div class="line">        step_size_z = (step_size_z_low + step_size_z_high) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_s =</div><div class="line">          (fraction_to_boundary * state) + (step_size_s * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> state_test_z =</div><div class="line">          (fraction_to_boundary * state) + (step_size_z * step);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_s =</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_s.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack)</div><div class="line">             .is_non_negative());</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> accept_z =</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier)</div><div class="line">             .is_non_negative()) &amp;&amp;</div><div class="line">          (state_test_z.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier)</div><div class="line">             .is_non_negative());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_s)</div><div class="line">          step_size_s_low = step_size_s;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_s_high = step_size_s;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (accept_z)</div><div class="line">          step_size_z_low = step_size_z;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size_z_high = step_size_z;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {step_size_s_low, step_size_z_low};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::calculate_test_rhs(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs;</div><div class="line">    test_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(system_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                     fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; lambda_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; mu_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;            rhs_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filtered_unfiltered_density_solution = test_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> filter_adjoint_unfiltered_density_multiplier_solution =</div><div class="line">      test_solution;</div><div class="line">    filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density) = 0;</div><div class="line">    filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier) = 0;</div><div class="line"></div><div class="line">    filter_matrix.vmult(filtered_unfiltered_density_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density),</div><div class="line">                        test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">                          SolutionBlocks::unfiltered_density));</div><div class="line">    filter_matrix.Tvmult(</div><div class="line">      filter_adjoint_unfiltered_density_multiplier_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">        SolutionBlocks::unfiltered_density_multiplier),</div><div class="line">      test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier));</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_density_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          old_displacement_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;                  old_displacement_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_symmgrads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_displacement_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_displacement_multiplier_divs(n_q_points);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_displacement_multiplier_symmgrads(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_lower_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_upper_slack_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_unfiltered_density_multiplier_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filtered_unfiltered_density_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; filter_adjoint_unfiltered_density_multiplier_values(</div><div class="line">      n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>ValueExtractors;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        lambda.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), lambda_values);</div><div class="line">        mu.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), mu_values);</div><div class="line"></div><div class="line">        fe_values[densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                                      old_density_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_values);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_divs);</div><div class="line">        fe_values[displacements&lt;dim&gt;].get_function_symmetric_gradients(</div><div class="line">          test_solution, old_displacement_symmgrads);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_displacement_multiplier_values);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;].get_function_divergences(</div><div class="line">          test_solution, old_displacement_multiplier_divs);</div><div class="line">        fe_values[displacement_multipliers&lt;dim&gt;]</div><div class="line">          .get_function_symmetric_gradients(</div><div class="line">            test_solution, old_displacement_multiplier_symmgrads);</div><div class="line">        fe_values[density_lower_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_values);</div><div class="line">        fe_values[density_lower_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_lower_slack_multiplier_values);</div><div class="line">        fe_values[density_upper_slacks&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_values);</div><div class="line">        fe_values[density_upper_slack_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_upper_slack_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          test_solution, old_unfiltered_density_multiplier_values);</div><div class="line">        fe_values[unfiltered_densities&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filtered_unfiltered_density_solution,</div><div class="line">          filtered_unfiltered_density_values);</div><div class="line">        fe_values[unfiltered_density_multipliers&lt;dim&gt;].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_solution,</div><div class="line">          filter_adjoint_unfiltered_density_multiplier_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> displacement_phi_i_symmgrad =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].symmetric_gradient(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_phi_i_div =</div><div class="line">                  fe_values[displacements&lt;dim&gt;].divergence(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  displacement_multiplier_phi_i_symmgrad =</div><div class="line">                    fe_values[displacement_multipliers&lt;dim&gt;].symmetric_gradient(</div><div class="line">                      i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> displacement_multiplier_phi_i_div =</div><div class="line">                  fe_values[displacement_multipliers&lt;dim&gt;].divergence(i,</div><div class="line">                                                                      q_point);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> density_phi_i =</div><div class="line">                  fe_values[densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_phi_i =</div><div class="line">                  fe_values[unfiltered_densities&lt;dim&gt;].value(i, q_point);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> unfiltered_density_multiplier_phi_i =</div><div class="line">                  fe_values[unfiltered_density_multipliers&lt;dim&gt;].value(i,</div><div class="line">                                                                       q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_lower_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_phi_i =</div><div class="line">                  fe_values[density_lower_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_phi_i =</div><div class="line">                  fe_values[density_upper_slacks&lt;dim&gt;].value(i, q_point);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_multiplier_phi_i =</div><div class="line">                  fe_values[density_upper_slack_multipliers&lt;dim&gt;].value(</div><div class="line">                    i, q_point);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 1: This equation, along with equations</span></div><div class="line"><span class="comment">                 * 2 and 3, are the variational derivatives of the</span></div><div class="line"><span class="comment">                 * Lagrangian with respect to the decision</span></div><div class="line"><span class="comment">                 * variables - the density, displacement, and</span></div><div class="line"><span class="comment">                 * unfiltered density. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (density_penalty_exponent *</div><div class="line">                     <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                              density_penalty_exponent - 1) *</div><div class="line">                     density_phi_i *</div><div class="line">                     (old_displacement_multiplier_divs[q_point] *</div><div class="line">                        old_displacement_divs[q_point] *</div><div class="line">                        lambda_values[q_point] +</div><div class="line">                      2 * mu_values[q_point] *</div><div class="line">                        (old_displacement_symmgrads[q_point] *</div><div class="line">                         old_displacement_multiplier_symmgrads[q_point])) -</div><div class="line">                   density_phi_i *</div><div class="line">                     old_unfiltered_density_multiplier_values[q_point]);</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 2; the boundary terms will be added further down</span></div><div class="line"><span class="comment">                 * below. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                            density_penalty_exponent) *</div><div class="line">                   (old_displacement_multiplier_divs[q_point] *</div><div class="line">                      displacement_phi_i_div * lambda_values[q_point] +</div><div class="line">                    2 * mu_values[q_point] *</div><div class="line">                      (old_displacement_multiplier_symmgrads[q_point] *</div><div class="line">                       displacement_phi_i_symmgrad)));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 3 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (unfiltered_density_phi_i *</div><div class="line">                     filter_adjoint_unfiltered_density_multiplier_values</div><div class="line">                       [q_point] +</div><div class="line">                   unfiltered_density_phi_i *</div><div class="line">                     old_upper_slack_multiplier_values[q_point] +</div><div class="line">                   -1 * unfiltered_density_phi_i *</div><div class="line">                     old_lower_slack_multiplier_values[q_point]);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">/* Equation 4; boundary term will again be dealt</span></div><div class="line"><span class="comment">                 * with below. This equation being driven to 0</span></div><div class="line"><span class="comment">                 * ensures that the elasticity equation is met as</span></div><div class="line"><span class="comment">                 * a constraint. */</span></div><div class="line">                cell_rhs(i) += -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(old_density_values[q_point],</div><div class="line">                                         density_penalty_exponent) *</div><div class="line">                                (old_displacement_divs[q_point] *</div><div class="line">                                   displacement_multiplier_phi_i_div *</div><div class="line">                                   lambda_values[q_point] +</div><div class="line">                                 2 * mu_values[q_point] *</div><div class="line">                                   (displacement_multiplier_phi_i_symmgrad *</div><div class="line">                                    old_displacement_symmgrads[q_point])));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 5: This equation sets the lower slack</span></div><div class="line"><span class="comment">                 * variable equal to the unfiltered density,</span></div><div class="line"><span class="comment">                 * giving a minimum density of 0. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (lower_slack_multiplier_phi_i *</div><div class="line">                                (old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 6: This equation sets the upper slack</span></div><div class="line"><span class="comment">                 * variable equal to one minus the unfiltered</span></div><div class="line"><span class="comment">                 * density. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (upper_slack_multiplier_phi_i *</div><div class="line">                                (1 - old_unfiltered_density_values[q_point] -</div><div class="line">                                 old_upper_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 7: This is the difference between the</span></div><div class="line"><span class="comment">                 * density and the filter applied to the</span></div><div class="line"><span class="comment">                 * unfiltered density. This being driven to 0 by</span></div><div class="line"><span class="comment">                 * the Newton steps ensures that the filter is</span></div><div class="line"><span class="comment">                 * applied correctly. */</span></div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                               (unfiltered_density_multiplier_phi_i *</div><div class="line">                                (old_density_values[q_point] -</div><div class="line">                                 filtered_unfiltered_density_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 8: This along with equation 9 give the</span></div><div class="line"><span class="comment">                 * requirement that @f$s*z = \alpha@f$ for the barrier</span></div><div class="line"><span class="comment">                 * size alpha, and gives complementary slackness</span></div><div class="line"><span class="comment">                 * from KKT conditions when @f$\alpha@f$ goes to 0. */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (lower_slack_phi_i *</div><div class="line">                   (old_lower_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_lower_slack_values[q_point]));</div><div class="line"></div><div class="line">                <span class="comment">/* Equation 9 */</span></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  -1 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point) *</div><div class="line">                  (upper_slack_phi_i *</div><div class="line">                   (old_upper_slack_multiplier_values[q_point] -</div><div class="line">                    barrier_size / old_upper_slack_values[q_point]));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">              {</div><div class="line">                fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_q_point :</div><div class="line">                     fe_face_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_face_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                      {</div><div class="line">                        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                        traction[1] = -1.;</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          -1 *</div><div class="line">                          (traction * fe_face_values[displacements&lt;dim&gt;].value(</div><div class="line">                                        i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line"></div><div class="line">                        cell_rhs(i) +=</div><div class="line">                          (traction *</div><div class="line">                           fe_face_values[displacement_multipliers&lt;dim&gt;].value(</div><div class="line">                             i, face_q_point)) *</div><div class="line">                          fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <a class="code" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">MatrixTools::local_apply_boundary_values</a>(boundary_values,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 dummy_cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               test_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> test_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SANDTopOpt&lt;dim&gt;::calculate_exact_merit(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;test_solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;merit function&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> objective_function_merit = 0;</div><div class="line">    {</div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>  mapping(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>         fe_values(mapping,</div><div class="line">                              fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_face_values(mapping,</div><div class="line">                                       fe,</div><div class="line">                                       face_quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; displacement_face_values(n_face_q_points);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">                  face-&gt;boundary_id() == BoundaryIds::down_force)</div><div class="line">                {</div><div class="line">                  fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">                  fe_face_values[ValueExtractors::displacements&lt;dim&gt;]</div><div class="line">                    .<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(test_solution,</div><div class="line">                                         displacement_face_values);</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_q_point = 0;</div><div class="line">                       face_q_point &lt; n_face_q_points;</div><div class="line">                       ++face_q_point)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction;</div><div class="line">                      traction[1] = -1.;</div><div class="line"></div><div class="line">                      objective_function_merit +=</div><div class="line">                        (traction * displacement_face_values[face_q_point]) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(face_q_point);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_lower_slack)[cell-&gt;active_cell_index()]);</div><div class="line">        objective_function_merit =</div><div class="line">          objective_function_merit -</div><div class="line">          barrier_size * cell-&gt;measure() *</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(test_solution.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(</div><div class="line">              SolutionBlocks::density_upper_slack)[cell-&gt;active_cell_index()]);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs = calculate_test_rhs(test_solution);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> elasticity_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> filter_constraint_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lower_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> upper_slack_merit =</div><div class="line">      penalty_multiplier *</div><div class="line">      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> total_merit =</div><div class="line">      objective_function_merit + elasticity_constraint_merit +</div><div class="line">      filter_constraint_merit + lower_slack_merit + upper_slack_merit;</div><div class="line">    <span class="keywordflow">return</span> total_merit;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> SANDTopOpt&lt;dim&gt;::find_max_step()</div><div class="line">  {</div><div class="line">    assemble_system();</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> step = solve();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; decision_variables = {</div><div class="line">      SolutionBlocks::density,</div><div class="line">      SolutionBlocks::displacement,</div><div class="line">      SolutionBlocks::unfiltered_density,</div><div class="line">      SolutionBlocks::density_upper_slack,</div><div class="line">      SolutionBlocks::density_lower_slack};</div><div class="line">    <span class="keywordtype">double</span> hess_part = 0;</div><div class="line">    <span class="keywordtype">double</span> grad_part = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_i : decision_variables)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decision_variable_j : decision_variables)</div><div class="line">          {</div><div class="line">            Vector&lt;double&gt; temp_vector(step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i).size());</div><div class="line">            system_matrix.block(decision_variable_i, decision_variable_j)</div><div class="line">              .vmult(temp_vector, step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_j));</div><div class="line">            hess_part += step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i) * temp_vector;</div><div class="line">          }</div><div class="line">        grad_part -= system_rhs.block(decision_variable_i) *</div><div class="line">                     step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(decision_variable_i);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; equality_constraint_multipliers = {</div><div class="line">      SolutionBlocks::displacement_multiplier,</div><div class="line">      SolutionBlocks::unfiltered_density_multiplier,</div><div class="line">      SolutionBlocks::density_lower_slack_multiplier,</div><div class="line">      SolutionBlocks::density_upper_slack_multiplier};</div><div class="line">    <span class="keywordtype">double</span> constraint_norm = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multiplier_i : equality_constraint_multipliers)</div><div class="line">      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> test_penalty_multiplier;</div><div class="line">    <span class="keywordflow">if</span> (hess_part &gt; 0)</div><div class="line">      test_penalty_multiplier =</div><div class="line">        (grad_part + .5 * hess_part) / (.05 * constraint_norm);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);</div><div class="line"></div><div class="line">    penalty_multiplier = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(penalty_multiplier, test_penalty_multiplier);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; max_step_sizes =</div><div class="line">      calculate_max_step_size(nonlinear_solution, step);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_s = max_step_sizes.first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size_z = max_step_sizes.second;</div><div class="line"></div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::displacement_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack) *= step_size_s;</div><div class="line">    step.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> step;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  SANDTopOpt&lt;dim&gt;::compute_scaled_step(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;max_step,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> descent_requirement)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> merit_derivative =</div><div class="line">      (calculate_exact_merit(state + 1e-4 * max_step) -</div><div class="line">       calculate_exact_merit(state)) /</div><div class="line">      1e-4;</div><div class="line">    <span class="keywordtype">double</span>       step_size                 = 1;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_linesearch_iterations = 10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_linesearch_iterations; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (calculate_exact_merit(state + step_size * max_step) &lt;</div><div class="line">            calculate_exact_merit(state) +</div><div class="line">              step_size * descent_requirement * merit_derivative)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          step_size = step_size / 2;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> state + (step_size * max_step);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> SANDTopOpt&lt;dim&gt;::check_convergence(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;state)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> test_rhs      = calculate_test_rhs(state);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>              test_rhs_norm = test_rhs.<a class="code" href="classBlockVectorBase.html#a5253082a5591dc0d13fef1d65a3dbfae">l1_norm</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> convergence_condition = 1e-2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> target_norm           = convergence_condition * barrier_size;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    Checking convergence. Current rhs norm is &quot;</span></div><div class="line">              &lt;&lt; test_rhs_norm &lt;&lt; <span class="stringliteral">&quot;, target is &quot;</span> &lt;&lt; target_norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (test_rhs_norm &lt; target_norm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(1, <span class="stringliteral">&quot;density&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        solution_names.emplace_back(<span class="stringliteral">&quot;displacement_multiplier&quot;</span>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">          <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      }</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;unfiltered_density_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;low_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;high_slack_multiplier&quot;</span>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(nonlinear_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(iteration) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SANDTopOpt&lt;dim&gt;::write_as_stl()</div><div class="line">  {</div><div class="line">    static_assert(dim == 2,</div><div class="line">                  <span class="stringliteral">&quot;This function is not implemented for anything &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;other than the 2d case.&quot;</span>);</div><div class="line"></div><div class="line">    std::ofstream stlfile;</div><div class="line">    stlfile.open(<span class="stringliteral">&quot;bridge.stl&quot;</span>);</div><div class="line"></div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;solid bridge\n&quot;</span> &lt;&lt; std::scientific;</div><div class="line">    <span class="keywordtype">double</span> height = .25;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (nonlinear_solution.block(</div><div class="line">              SolutionBlocks::density)[cell-&gt;active_cell_index()] &gt; 0.5)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> edge_directions[2] = {cell-&gt;vertex(1) -</div><div class="line">                                                         cell-&gt;vertex(0),</div><div class="line">                                                       cell-&gt;vertex(2) -</div><div class="line">                                                         cell-&gt;vertex(0)};</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> edge_tensor(</div><div class="line">              {{edge_directions[0][0], edge_directions[0][1]},</div><div class="line">               {edge_directions[1][0], edge_directions[1][1]}});</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_right_handed_cell = (<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(edge_tensor) &gt; 0);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (is_right_handed_cell)</div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">/* The cell has a left-handed set up */</span></div><div class="line">              {</div><div class="line">                <span class="comment">/* Write one side at z = 0. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; -1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Write one side at z = height. */</span></div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(0)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span> &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; 1.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(1)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(2)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(2)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; cell-&gt;vertex(3)[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; cell-&gt;vertex(3)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number = 0;</div><div class="line">                 face_number &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                 ++face_number)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face =</div><div class="line">                  cell-&gt;face(face_number);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((face-&gt;at_boundary()) ||</div><div class="line">                    (!face-&gt;at_boundary() &amp;&amp;</div><div class="line">                     (nonlinear_solution.block(</div><div class="line">                        0)[cell-&gt;neighbor(face_number)-&gt;active_cell_index()] &lt;</div><div class="line">                      0.5)))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">                      (face-&gt;center() - cell-&gt;center());</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> normal_norm = normal_vector.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">                    <span class="keywordflow">if</span> ((face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            0.000000e+00 +</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) * (0 - 0) *</div><div class="line">                            normal_vector[0] +</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[0] - face-&gt;vertex(0)[0]) * (0 - 0) *</div><div class="line">                            normal_vector[1] -</div><div class="line">                          (face-&gt;vertex(0)[1] - face-&gt;vertex(0)[1]) *</div><div class="line">                            (face-&gt;vertex(1)[0] - face-&gt;vertex(0)[0]) *</div><div class="line">                            normal_vector[0] -</div><div class="line">                          (height - 0) *</div><div class="line">                            (face-&gt;vertex(1)[1] - face-&gt;vertex(0)[1]) * 0 &gt;</div><div class="line">                        0)</div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   facet normal &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[0] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; normal_vector[1] / normal_norm &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      outer loop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(0)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(0)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                &lt;&lt; 0.000000e+00 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;         vertex &quot;</span> &lt;&lt; face-&gt;vertex(1)[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; face-&gt;vertex(1)[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; height</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;      endloop\n&quot;</span>;</div><div class="line">                        stlfile &lt;&lt; <span class="stringliteral">&quot;   endfacet\n&quot;</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">    stlfile &lt;&lt; <span class="stringliteral">&quot;endsolid bridge&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SANDTopOpt&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;filter r is: &quot;</span> &lt;&lt; filter_r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;setup&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator_1_1Airfoil.html#aba2454eb933cce1ab7d0d68b4f6041ff">create_triangulation</a>();</div><div class="line"></div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">      setup_boundary_values();</div><div class="line">      setup_block_system();</div><div class="line">      setup_filter_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">    barrier_size                  = 25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_barrier_size = .0005;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_uphill_steps    = 8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       descent_requirement = .0001;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       iteration_number = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations   = 10000;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting outer step in iteration &quot;</span> &lt;&lt; iteration_number</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; with barrier parameter &quot;</span> &lt;&lt; barrier_size &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Starting inner step in iteration &quot;</span></div><div class="line">                      &lt;&lt; iteration_number</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; with merit function penalty multiplier &quot;</span></div><div class="line">                      &lt;&lt; penalty_multiplier &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> watchdog_step_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> watchdog_state = nonlinear_solution;</div><div class="line">            <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       first_step;</div><div class="line">            <span class="keywordtype">double</span> target_merit     = numbers::signaling_nan&lt;double&gt;();</div><div class="line">            <span class="keywordtype">double</span> merit_derivative = numbers::signaling_nan&lt;double&gt;();</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; max_uphill_steps; ++k)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (k == 0)</div><div class="line">                  {</div><div class="line">                    first_step = update_step;</div><div class="line">                    merit_derivative =</div><div class="line">                      ((calculate_exact_merit(watchdog_state +</div><div class="line">                                              .0001 * first_step) -</div><div class="line">                        calculate_exact_merit(watchdog_state)) /</div><div class="line">                       .0001);</div><div class="line">                    target_merit = calculate_exact_merit(watchdog_state) +</div><div class="line">                                   descent_requirement * merit_derivative;</div><div class="line">                  }</div><div class="line"></div><div class="line">                nonlinear_solution += update_step;</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> current_merit =</div><div class="line">                  calculate_exact_merit(nonlinear_solution);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;    current watchdog state merit is: &quot;</span></div><div class="line">                          &lt;&lt; current_merit &lt;&lt; <span class="stringliteral">&quot;; target merit is &quot;</span></div><div class="line">                          &lt;&lt; target_merit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (current_merit &lt; target_merit)</div><div class="line">                  {</div><div class="line">                    watchdog_step_found = <span class="keyword">true</span>;</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    found workable step after &quot;</span> &lt;&lt; k + 1</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (watchdog_step_found == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                ++iteration_number;</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> update_step = find_max_step();</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_state =</div><div class="line">                  compute_scaled_step(nonlinear_solution,</div><div class="line">                                      update_step,</div><div class="line">                                      descent_requirement);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((calculate_exact_merit(nonlinear_solution) &lt;</div><div class="line">                     calculate_exact_merit(watchdog_state)) ||</div><div class="line">                    (calculate_exact_merit(stretch_state) &lt; target_merit))</div><div class="line">                  {</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from end of watchdog&quot;</span></div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                    nonlinear_solution = stretch_state;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    std::cout</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;    Taking scaled step from beginning of watchdog&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">if</span> (calculate_exact_merit(stretch_state) &gt;</div><div class="line">                        calculate_exact_merit(watchdog_state))</div><div class="line">                      {</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(watchdog_state,</div><div class="line">                                              first_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        ++iteration_number;</div><div class="line">                        nonlinear_solution = stretch_state;</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> stretch_step =</div><div class="line">                          find_max_step();</div><div class="line">                        nonlinear_solution =</div><div class="line">                          compute_scaled_step(nonlinear_solution,</div><div class="line">                                              stretch_step,</div><div class="line">                                              descent_requirement);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            output_results(iteration_number);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((iteration_number &lt; max_iterations) &amp;&amp;</div><div class="line">               (check_convergence(nonlinear_solution) == <span class="keyword">false</span>));</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_multiplier = .8;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> barrier_size_exponent   = 1.2;</div><div class="line"></div><div class="line">        barrier_size =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(barrier_size * barrier_size_multiplier,</div><div class="line">                            std::pow(barrier_size, barrier_size_exponent)),</div><div class="line">                   min_barrier_size);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (((barrier_size &gt; min_barrier_size) ||</div><div class="line">            (check_convergence(nonlinear_solution) == <span class="keyword">false</span>)) &amp;&amp;</div><div class="line">           (iteration_number &lt; max_iterations));</div><div class="line"></div><div class="line">    write_as_stl();</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SAND</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SAND::SANDTopOpt&lt;2&gt; elastic_problem_2d;</div><div class="line">      elastic_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
