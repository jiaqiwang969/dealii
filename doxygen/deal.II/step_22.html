<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_22.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-22 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-22 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>, <a class="el" href="step_21.html">step-21</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Weakform">Weak form</a>
        <li><a href="#Boundaryconditions">Boundary conditions</a>
        <li><a href="#Discretization">Discretization</a>
        <li><a href="#Linearsolverandpreconditioningissues">Linear solver and preconditioning issues</a>
      <ul>
        <li><a href="#IsthishowoneshouldsolvetheStokesequations"> Is this how one should solve the Stokes equations? </a>
        <li><a href="#Anoteonthestructureofthelinearsystem"> A note on the structure of the linear system </a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#Implementation">Implementation</a>
      <ul>
        <li><a href="#UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions">Using imhomogeneous constraints for implementing Dirichlet boundary conditions</a>
        <li><a href="#UsingAffineConstraintsforincreasingperformance">Using AffineConstraints for increasing performance</a>
        <li><a href="#Performanceoptimizations">Performance optimizations</a>
    </ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Definingtheinnerpreconditionertype">Defining the inner preconditioner type</a>
        <li><a href="#ThecodeStokesProblemcodeclasstemplate">The <code>StokesProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#ThecodeSchurComplementcodeclasstemplate">The <code>SchurComplement</code> class template</a>
      </ul>
        <li><a href="#StokesProblemclassimplementation">StokesProblem class implementation</a>
      <ul>
        <li><a href="#StokesProblemStokesProblem">StokesProblem::StokesProblem</a>
        <li><a href="#StokesProblemsetup_dofs">StokesProblem::setup_dofs</a>
        <li><a href="#StokesProblemassemble_system">StokesProblem::assemble_system</a>
        <li><a href="#StokesProblemsolve">StokesProblem::solve</a>
        <li><a href="#StokesProblemoutput_results">StokesProblem::output_results</a>
        <li><a href="#StokesProblemrefine_mesh">StokesProblem::refine_mesh</a>
        <li><a href="#StokesProblemrun">StokesProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Outputoftheprogramandgraphicalvisualization">Output of the program and graphical visualization</a>
      <ul>
        <li><a href="#2Dcalculations">2D calculations</a>
        <li><a href="#3Dcalculations">3D calculations</a>
      </ul>
        <li><a href="#Sparsitypattern">Sparsity pattern</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Improvedlinearsolverin3D">Improved linear solver in 3D</a>
      <ul>
        <li><a href="#BetterILUdecompositionbysmartreordering">Better ILU decomposition by smart reordering</a>
        <li><a href="#BetterpreconditionerfortheinnerCGsolver">Better preconditioner for the inner CG solver</a>
        <li><a href="#BlockSchurcomplementpreconditioner">Block Schur complement preconditioner</a>
        <li><a href="#Combiningtheblockpreconditionerandmultigrid">Combining the block preconditioner and multigrid</a>
        <li><a href="#Noblockmatricesandvectors">No block matrices and vectors</a>
      </ul>
        <li><a href="#Moreinterestingtestcases">More interesting testcases</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Martin Kronbichler and Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The California Institute of Technology. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program deals with the Stokes system of equations which reads as follows in non-dimensionalized form: </p><p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; \textbf{f}, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> where \(\textbf u\) denotes the velocity of a fluid, \(p\) is its pressure, \(\textbf f\) are external forces, and \(\varepsilon(\textbf{u})= \nabla^s{\textbf{u}}= \frac 12 \left[ (\nabla \textbf{u}) + (\nabla \textbf{u})^T\right]\) is the rank-2 tensor of symmetrized gradients; a component-wise definition of it is \(\varepsilon(\textbf{u})_{ij}=\frac 12\left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}\right)\).</p>
<p>The Stokes equations describe the steady-state motion of a slow-moving, viscous fluid such as honey, rocks in the earth mantle, or other cases where inertia does not play a significant role. If a fluid is moving fast enough that inertia forces are significant compared to viscous friction, the Stokes equations are no longer valid; taking into account inertia effects then leads to the nonlinear Navier-Stokes equations. However, in this tutorial program, we will focus on the simpler Stokes system.</p>
<p>Note that when deriving the more general compressible Navier-Stokes equations, the diffusion is modeled as the divergence of the stress tensor </p><p class="formulaDsp">
\begin{eqnarray*} \tau = - \mu (2\varepsilon(\textbf{u}) - \frac{2}{3}\nabla \cdot \textbf{u} I), \end{eqnarray*}
</p>
<p> where \(\mu\) is the viscosity of the fluid. With the assumption of \(\mu=1\) (assume constant viscosity and non-dimensionalize the equation by dividing out \(\mu\)) and assuming incompressibility ( \(\textrm{div}\; \textbf{u}=0\)), we arrive at the formulation from above: </p><p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}). \end{eqnarray*}
</p>
<p> A different formulation uses the Laplace operator ( \(-\triangle \textbf{u}\)) instead of the symmetrized gradient. A big difference here is that the different components of the velocity do not couple. If you assume additional regularity of the solution \(\textbf{u}\) (second partial derivatives exist and are continuous), the formulations are equivalent: </p><p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}) = -\triangle \textbf{u} + \nabla \cdot (\nabla\textbf{u})^T = -\triangle \textbf{u}. \end{eqnarray*}
</p>
<p> This is because the \(i\)th entry of \(\nabla \cdot (\nabla\textbf{u})^T\) is given by: </p><p class="formulaDsp">
\begin{eqnarray*} [\nabla \cdot (\nabla\textbf{u})^T]_i = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})^T]_{i,j} = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})]_{j,i} = \sum_j \frac{\partial}{\partial x_j} \frac{\partial}{\partial x_i} \textbf{u}_j = \sum_j \frac{\partial}{\partial x_i} \frac{\partial}{\partial x_j} \textbf{u}_j = \frac{\partial}{\partial x_i} \textrm{div}\; \textbf{u} = 0. \end{eqnarray*}
</p>
<p> If you can not assume the above mentioned regularity, or if your viscosity is not a constant, the equivalence no longer holds. Therefore, we decided to stick with the more physically accurate symmetric tensor formulation in this tutorial.</p>
<p>To be well-posed, we will have to add boundary conditions to the equations. What boundary conditions are readily possible here will become clear once we discuss the weak form of the equations.</p>
<p>The equations covered here fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Weakform"></a></p><h3>Weak form</h3>
<p>The weak form of the equations is obtained by writing it in vector form as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p} \\ {-\textrm{div}\; \textbf{u}} \end{pmatrix} = \begin{pmatrix} {\textbf{f}} \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued test function \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) and integrating over the domain \(\Omega\), yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\).</p>
<p>A generally good rule of thumb is that if one <em>can</em> reduce how many derivatives are taken on any variable in the formulation, then one <em>should</em> in fact do that using integration by parts. (This is motivated by the theory of <a href="https://en.wikipedia.org/wiki/Partial_differential_equation">partial differential equations</a>, and in particular the difference between strong and <a href="https://en.wikipedia.org/wiki/Weak_solution">weak solutions</a>.) We have already done that for the Laplace equation, where we have integrated the second derivative by parts to obtain the weak formulation that has only one derivative on both test and trial function.</p>
<p>In the current context, we integrate by parts the second term: </p><p class="formulaDsp">
\begin{eqnarray*} (\textbf{v}, -2\; \textrm{div}\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega. \end{eqnarray*}
</p>
<p> Likewise, we integrate by parts the first term to obtain </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> where the scalar product between two tensor-valued quantities is here defined as </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} = 2 \int_\Omega \sum_{i,j=1}^d \frac{\partial v_j}{\partial x_i} \varepsilon(\textbf{u})_{ij} \ dx. \end{eqnarray*}
</p>
<p> Using this, we have now reduced the requirements on our variables to first derivatives for \(\mathbf u,\mathbf v\) and no derivatives at all for \(p,q\).</p>
<p>Because the scalar product between a general tensor like \(\nabla\textbf{v}\) and a symmetric tensor like \(\varepsilon(\textbf{u})\) equals the scalar product between the symmetrized forms of the two, we can also write the bilinear form above as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> We will deal with the boundary terms in the next section, but it is already clear from the domain terms </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} \end{eqnarray*}
</p>
<p> of the bilinear form that the Stokes equations yield a symmetric bilinear form, and consequently a symmetric (if indefinite) system matrix.</p>
<p><a class="anchor" id="Boundaryconditions"></a></p><h3>Boundary conditions</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.5.html">video lecture 21.5</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.55.html">video lecture 21.55</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html">video lecture 21.6</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html">video lecture 21.65</a>.)</dd></dl>
<p>The weak form just derived immediately presents us with different possibilities for imposing boundary conditions: </p><ol>
<li>
<p class="startli">Dirichlet velocity boundary conditions: On a part \(\Gamma_D\subset\partial\Omega\) we may impose Dirichlet conditions on the velocity \(\textbf u\):</p>
<p class="formulaDsp">
\begin{eqnarray*} \textbf u = \textbf g_D \qquad\qquad \textrm{on}\ \Gamma_D. \end{eqnarray*}
</p>
<p> Because test functions \(\textbf{v}\) come from the tangent space of the solution variable, we have that \(\textbf{v}=0\) on \(\Gamma_D\) and consequently that </p><p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_D} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_D} = 0. \end{eqnarray*}
</p>
<p> In other words, as usual, strongly imposed boundary values do not appear in the weak form.</p>
<p>It is noteworthy that if we impose Dirichlet boundary values on the entire boundary, then the pressure is only determined up to a constant. An algorithmic realization of that would use similar tools as have been seen in <a class="el" href="step_11.html">step-11</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Neumann-type or natural boundary conditions: On the rest of the boundary \(\Gamma_N=\partial\Omega\backslash\Gamma_D\), let us re-write the boundary terms as follows: </p><p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_N} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_N} &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i=1}^d (n_i v_i, p)_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i,j=1}^d (n_i v_j, p \delta_{ij})_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d (n_i v_j,p \delta_{ij} - 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} \\ &amp;=&amp; (\textbf{n} \otimes \textbf{v}, p \textbf{I} - 2\; \varepsilon(\textbf{u}))_{\Gamma_N}. \\ &amp;=&amp; (\textbf{v}, \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})])_{\Gamma_N}. \end{eqnarray*}
</p>
<p> In other words, on the Neumann part of the boundary we can prescribe values for the total stress: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] = \textbf g_N \qquad\qquad \textrm{on}\ \Gamma_N. \end{eqnarray*}
</p>
<p> If the boundary is subdivided into Dirichlet and Neumann parts \(\Gamma_D,\Gamma_N\), this then leads to the following weak form: </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N}. \end{eqnarray*}
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Robin-type boundary conditions: Robin boundary conditions are a mixture of Dirichlet and Neumann boundary conditions. They would read </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] = \textbf S \textbf u \qquad\qquad \textrm{on}\ \Gamma_R, \end{eqnarray*}
</p>
<p> with a rank-2 tensor (matrix) \(\textbf S\). The associated weak form is </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} + (\textbf S \textbf u, \textbf{v})_{\Gamma_R} = (\textbf{v}, \textbf{f})_\Omega. \end{eqnarray*}
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Partial boundary conditions: It is possible to combine Dirichlet and Neumann boundary conditions by only enforcing each of them for certain components of the velocity. For example, one way to impose artificial boundary conditions is to require that the flow is perpendicular to the boundary, i.e. the tangential component \(\textbf u_{\textbf t}=(\textbf 1-\textbf n\otimes\textbf n)\textbf u\) be zero, thereby constraining <code>dim</code>-1 components of the velocity. The remaining component can be constrained by requiring that the normal component of the normal stress be zero, yielding the following set of boundary conditions: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf u_{\textbf t} &amp;=&amp; 0, \\ \textbf n \cdot \left(\textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] \right) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p class="endli">An alternative to this is when one wants the flow to be <em>parallel</em> rather than perpendicular to the boundary (in deal.II, the <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a> function can do this for you). This is frequently the case for problems with a free boundary (e.g. at the surface of a river or lake if vertical forces of the flow are not large enough to actually deform the surface), or if no significant friction is exerted by the boundary on the fluid (e.g. at the interface between earth mantle and earth core where two fluids meet that are stratified by different densities but that both have small enough viscosities to not introduce much tangential stress on each other). In formulas, this means that </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot\textbf u &amp;=&amp; 0, \\ (\textbf 1-\textbf n\otimes\textbf n) \left(\textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] \right) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> the first condition (which needs to be imposed strongly) fixing a single component of the velocity, with the second (which would be enforced in the weak form) fixing the remaining two components. </p>
</li>
</ol>
<p>Despite this wealth of possibilities, we will only use Dirichlet and (homogeneous) Neumann boundary conditions in this tutorial program.</p>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p>As developed above, the weak form of the equations with Dirichlet and Neumann boundary conditions on \(\Gamma_D\) and \(\Gamma_N\) reads like this: find \(\textbf u\in \textbf V_g = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=\textbf g_D\}, p\in Q=L^2(\Omega)\) so that </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p> for all test functions \(\textbf{v}\in \textbf V_0 = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=0\},q\in Q\).</p>
<p>These equations represent a symmetric <a href="https://en.wikipedia.org/wiki/Ladyzhenskaya%E2%80%93Babu%C5%A1ka%E2%80%93Brezzi_condition">saddle point problem</a>. It is well known that then a solution only exists if the function spaces in which we search for a solution have to satisfy certain conditions, typically referred to as the Babuska-Brezzi or Ladyzhenskaya-Babuska-Brezzi (LBB) conditions. The continuous function spaces above satisfy these. However, when we discretize the equations by replacing the continuous variables and test functions by finite element functions in finite dimensional spaces \(\textbf V_{g,h}\subset \textbf V_g, Q_h\subset Q\), we have to make sure that \(\textbf V_h,Q_h\) also satisfy the LBB conditions. This is similar to what we had to do in <a class="el" href="step_20.html">step-20</a>.</p>
<p>For the Stokes equations, there are a number of possible choices to ensure that the finite element spaces are compatible with the LBB condition. A simple and accurate choice that we will use here is \(\textbf u_h\in Q_{p+1}^d, p_h\in Q_p\), i.e. use elements one order higher for the velocities than for the pressures.</p>
<p>This then leads to the following discrete problem: find \(\textbf u_h,p_h\) so that </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}_h), 2\; \varepsilon(\textbf u_h))_{\Omega} - (\textrm{div}\; \textbf{v}_h, p_h)_{\Omega} - (q_h,\textrm{div}\; \textbf{u}_h)_{\Omega} = (\textbf{v}_h, \textbf{f})_\Omega - (\textbf{v}_h, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p> for all test functions \(\textbf{v}_h, q_h\). Assembling the linear system associated with this problem follows the same lines used in <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_21.html">step-21</a>, and explained in detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Linearsolverandpreconditioningissues"></a></p><h3>Linear solver and preconditioning issues</h3>
<p>The weak form of the discrete equations naturally leads to the following linear system for the nodal values of the velocity and pressure fields: </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> Like in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>, we will solve this system of equations by forming the Schur complement, i.e. we will first find the solution \(P\) of </p><p class="formulaDsp">
\begin{eqnarray*} BA^{-1}B^T P &amp;=&amp; BA^{-1} F - G, \\ \end{eqnarray*}
</p>
<p> and then </p><p class="formulaDsp">
\begin{eqnarray*} AU &amp;=&amp; F - B^TP. \end{eqnarray*}
</p>
<p> The way we do this is pretty much exactly like we did in these previous tutorial programs, i.e. we use the same classes <code>SchurComplement</code> and <code>InverseMatrix</code> again. There are two significant differences, however:</p>
<ol>
<li>
<p class="startli">First, in the mixed Laplace equation we had to deal with the question of how to precondition the Schur complement \(B^TM^{-1}B\), which was spectrally equivalent to the Laplace operator on the pressure space (because \(B\) represents the gradient operator, \(B^T\) its adjoint \(-\textrm{div}\), and \(M\) the identity (up to the material parameter \(K^{-1}\)), so \(B^TM^{-1}B\) is something like \(-\textrm{div} \mathbf 1 \nabla = -\Delta\)). Consequently, the matrix is badly conditioned for small mesh sizes and we had to come up with an elaborate preconditioning scheme for the Schur complement.</p>
<p class="endli"></p>
</li>
<li>
Second, every time we multiplied with \(B^TM^{-1}B\) we had to solve with the mass matrix \(M\). This wasn't particularly difficult, however, since the mass matrix is always well conditioned and so simple to invert using CG and a little bit of preconditioning. </li>
</ol>
<p>In other words, preconditioning the inner solver for \(M\) was simple whereas preconditioning the outer solver for \(B^TM^{-1}B\) was complicated.</p>
<p>Here, the situation is pretty much exactly the opposite. The difference stems from the fact that the matrix at the heart of the Schur complement does not stem from the identity operator but from a variant of the Laplace operator, \(-\textrm{div} \nabla^s\) (where \(\nabla^s\) is the symmetric gradient) acting on a vector field. In the investigation of this issue we largely follow the paper D. Silvester and A. Wathen: "Fast iterative solution of stabilised Stokes systems part II. Using
general block preconditioners." (SIAM J. Numer. Anal., 31 (1994), pp. 1352-1367), which is available online <a href="http://siamdl.aip.org/getabs/servlet/GetabsServlet?prog=normal&amp;id=SJNAAM000031000005001352000001&amp;idtype=cvips&amp;gifs=Yes" target="_top">here</a>. Principally, the difference in the matrix at the heart of the Schur complement has two consequences:</p>
<ol>
<li>
<p class="startli">First, it makes the outer preconditioner simple: the Schur complement corresponds to the operator \(-\textrm{div} (-\textrm{div} \nabla^s)^{-1} \nabla\) on the pressure space; forgetting about the fact that we deal with symmetric gradients instead of the regular one, the Schur complement is something like \(-\textrm{div} (-\textrm{div} \nabla)^{-1} \nabla = -\textrm{div} (-\Delta)^{-1} \nabla\), which, even if not mathematically entirely concise, is spectrally equivalent to the identity operator (a heuristic argument would be to commute the operators into \(-\textrm{div}(-\Delta)^{-1} \nabla = -\textrm{div}\nabla(-\Delta)^{-1} = -\Delta(-\Delta)^{-1} = \mathbf 1\)). It turns out that it isn't easy to solve this Schur complement in a straightforward way with the CG method: using no preconditioner, the condition number of the Schur complement matrix depends on the size ratios of the largest to the smallest cells, and one still needs on the order of 50-100 CG iterations. However, there is a simple cure: precondition with the mass matrix on the pressure space and we get down to a number between 5-15 CG iterations, pretty much independently of the structure of the mesh (take a look at the <a href="#Results">results section</a> of this program to see that indeed the number of CG iterations does not change as we refine the mesh).</p>
<p>So all we need in addition to what we already have is the mass matrix on the pressure variables and we will store it in a separate object.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">While the outer preconditioner has become simpler compared to the mixed Laplace case discussed in <a class="el" href="step_20.html">step-20</a>, the issue of the inner solver has become more complicated. In the mixed Laplace discretization, the Schur complement has the form \(B^TM^{-1}B\). Thus, every time we multiplied with the Schur complement, we had to solve a linear system \(M_uz=y\); this isn't too complicated there, however, since the mass matrix \(M_u\) on the pressure space is well-conditioned.</p>
<p>On the other hand, for the Stokes equation we consider here, the Schur complement is \(BA^{-1}B^T\) where the matrix \(A\) is related to the Laplace operator (it is, in fact, the matrix corresponding to the bilinear form \((\nabla^s \varphi_i, \nabla^s\varphi_j)\)). Thus, solving with \(A\) is a lot more complicated: the matrix is badly conditioned and we know that we need many iterations unless we have a very good preconditioner. What is worse, we have to solve with \(A\) every time we multiply with the Schur complement, which is 5-15 times using the preconditioner described above.</p>
<p>Because we have to solve with \(A\) several times, it pays off to spend a bit more time once to create a good preconditioner for this matrix. So here's what we're going to do: if in 2d, we use the ultimate preconditioner, namely a direct sparse LU decomposition of the matrix. This is implemented using the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class that uses the UMFPACK direct solver to compute the decomposition. To use it, you will have to build deal.II with UMFPACK support (which is the default); see the <a href="../../readme.html#optional-software">ReadMe file</a> for instructions. With this, the inner solver converges in one iteration.</p>
<p>In 2d, we can do this sort of thing because even reasonably large problems rarely have more than a few 100,000 unknowns with relatively few nonzero entries per row. Furthermore, the bandwidth of matrices in 2d is \({\cal O}(\sqrt{N})\) and therefore moderate. For such matrices, sparse factors can be computed in a matter of a few seconds. (As a point of reference, computing the sparse factors of a matrix of size \(N\) and bandwidth \(B\) takes \({\cal O}(NB^2)\) operations. In 2d, this is \({\cal O}(N^2)\); though this is a higher complexity than, for example, assembling the linear system which takes \({\cal O}(N)\), the constant for computing the decomposition is so small that it doesn't become the dominating factor in the entire program until we get to very large numbers of unknowns in the high 100,000s or more.)</p>
<p>The situation changes in 3d, because there we quickly have many more unknowns and the bandwidth of matrices (which determines the number of nonzero entries in sparse LU factors) is \({\cal O}(N^{2/3})\), and there are many more entries per row as well. This makes using a sparse direct solver such as UMFPACK inefficient: only for problem sizes of a few 10,000 to maybe 100,000 unknowns can a sparse decomposition be computed using reasonable time and memory resources.</p>
<p class="endli">What we do in that case is to use an incomplete LU decomposition (ILU) as a preconditioner, rather than actually computing complete LU factors. As it so happens, deal.II has a class that does this: <a class="el" href="classSparseILU.html">SparseILU</a>. Computing the ILU takes a time that only depends on the number of nonzero entries in the sparse matrix (or that we are willing to fill in the LU factors, if these should be more than the ones in the matrix), but is independent of the bandwidth of the matrix. It is therefore an operation that can efficiently also be computed in 3d. On the other hand, an incomplete LU decomposition, by definition, does not represent an exact inverse of the matrix \(A\). Consequently, preconditioning with the ILU will still require more than one iteration, unlike preconditioning with the sparse direct solver. The inner solver will therefore take more time when multiplying with the Schur complement: an unavoidable trade-off. </p>
</li>
</ol>
<p>In the program below, we will make use of the fact that the <a class="el" href="classSparseILU.html">SparseILU</a> and <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> classes have a very similar interface and can be used interchangeably. All that we need is a switch class that, depending on the dimension, provides a type that is either of the two classes mentioned above. This is how we do that: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">};</div></div><!-- fragment --><p>From here on, we can refer to the type <code>typename InnerPreconditioner&lt;dim&gt;::type</code> and automatically get the correct preconditioner class. Because of the similarity of the interfaces of the two classes, we will be able to use them interchangeably using the same syntax in all places.</p>
<p><a class="anchor" id="IsthishowoneshouldsolvetheStokesequations"></a></p><h4>Is this how one should solve the Stokes equations? </h4>
<p>The discussions above showed <em>one</em> way in which the linear system that results from the Stokes equations can be solved, and because the tutorial programs are teaching tools that makes sense. But is this the way this system of equations <em>should</em> be solved?</p>
<p>The answer to this is no. The primary bottleneck with the approach, already identified above, is that we have to repeatedly solve linear systems with \(A\) inside the Schur complement, and because we don't have a good preconditioner for the Schur complement, these solves just have to happen too often. A better approach is to use a block decomposition, which is based on an observation of Silvester and Wathen <b>[SW94]</b> and explained in much greater detail in <b>[elman2005]</b> . An implementation of this alternative approach is discussed below, in the section on a <a href="#block-schur">block Schur complementation preconditioner</a> in the results section of this program.</p>
<p><a class="anchor" id="Anoteonthestructureofthelinearsystem"></a></p><h4>A note on the structure of the linear system </h4>
<p>Above, we have claimed that the linear system has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> i.e., in particular that there is a zero block at the bottom right of the matrix. This then allowed us to write the Schur complement as \(S=B A^{-1} B^T\). But this is not quite correct.</p>
<p>Think of what would happen if there are constraints on some pressure variables (see the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> documentation module), for example because we use adaptively refined meshes and continuous pressure finite elements so that there are hanging nodes. Another cause for such constraints are Dirichlet boundary conditions on the pressure. Then the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class, upon copying the local contributions to the matrix into the global linear system will zero out rows and columns corresponding to constrained degrees of freedom and put a positive entry on the diagonal. (You can think of this entry as being one for simplicity, though in reality it is a value of the same order of magnitude as the other matrix entries.) In other words, the bottom right block is really not empty at all: It has a few entries on the diagonal, one for each constrained pressure degree of freedom, and a correct description of the linear system we have to solve is that it has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; D_c \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> where \(D_c\) is the zero matrix with the exception of the positive diagonal entries for the constrained degrees of freedom. The correct Schur complement would then in fact be the matrix \(S = B A^{-1} B^T - D_c \) instead of the one stated above.</p>
<p>Thinking about this makes us, first, realize that the resulting Schur complement is now indefinite because \(B A^{-1} B^T\) is symmetric and positive definite whereas \(D_c\) is a positive semidefinite, and subtracting the latter from the former may no longer be positive definite. This is annoying because we could no longer employ the Conjugate Gradient method on this true Schur complement. That said, we could fix the issue in <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> by simply putting <em>negative</em> values onto the diagonal for the constrained pressure variables &ndash; because we really only put something nonzero to ensure that the resulting matrix is not singular; we really didn't care whether that entry is positive or negative. So if the entries on the diagonal of \(D_c\) were negative, then \(S\) would again be a symmetric and positive definite matrix.</p>
<p>But, secondly, the code below doesn't actually do any of that: It happily solves the linear system with the wrong Schur complement \(S = B A^{-1} B^T\) that just ignores the issue altogether. Why does this even work? To understand why this is so, recall that when writing local contributions into the global matrix, <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> zeros out the rows and columns that correspond to constrained degrees of freedom. This means that \(B\) has some zero rows, and \(B^T\) zero columns. As a consequence, if one were to multiply out what the entries of \(S\) are, one would realize that it has zero rows and columns for all constrained pressure degrees of freedom, including a zero on the diagonal. The nonzero entries of \(D_c\) would fit into exactly those zero diagonal locations, and ensure that \(S\) is invertible. Not doing so, strictly speaking, means that \(S\) remains singular: It is symmetric and positive definite on the subset of non-constrained pressure degrees of freedom, and simply the zero matrix on the constrained pressures. Why does the Conjugate Gradient method work for this matrix? Because <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> also makes sure that the right hand side entries that correspond to these zero rows of the matrix are <em>also</em> zero, i.e., the right hand side is compatible.</p>
<p>What this means is that whatever the values of the solution vector for these constrained pressure degrees of freedom, these rows will always have a zero residual and, if one were to consider what the CG algorithm does internally, just never produce any updates to the solution vector. In other words, the CG algorithm just <em>ignores</em> these rows, despite the fact that the matrix is singular. This only works because these degrees of freedom are entirely decoupled from the rest of the linear system (because the entire row and corresponding column are zero). At the end of the solution process, the constrained pressure values in the solution vector therefore remain exactly as they were when we started the call to the solver; they are finally overwritten with their correct values when we call <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> after the CG solver is done.</p>
<p>The upshot of this discussion is that the assumption that the bottom right block of the big matrix is zero is a bit simplified, but that just going with it does not actually lead to any practical problems worth addressing.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The domain, right hand side and boundary conditions we implement below relate to a problem in geophysics: there, one wants to compute the flow field of magma in the earth's interior under a mid-ocean rift. Rifts are places where two continental plates are very slowly drifting apart (a few centimeters per year at most), leaving a crack in the earth crust that is filled with magma from below. Without trying to be entirely realistic, we model this situation by solving the following set of equations and boundary conditions on the domain \(\Omega=[-2,2]\times[0,1]\times[-1,0]\): </p><p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; 0, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} -1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&lt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} +1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&gt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} 0 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x=0, \end{eqnarray*}
</p>
<p> and using natural boundary conditions \(\textbf{n}\cdot [p \textbf{I} - 2 \varepsilon(\textbf{u})] = 0\) everywhere else. In other words, at the left part of the top surface we prescribe that the fluid moves with the continental plate to the left at speed \(-1\), that it moves to the right on the right part of the top surface, and impose natural flow conditions everywhere else. If we are in 2d, the description is essentially the same, with the exception that we omit the second component of all vectors stated above.</p>
<p>As will become apparent in the <a href="#Results">results section</a>, the flow field will pull material from below and move it to the left and right ends of the domain, as expected. The discontinuity of velocity boundary conditions will produce a singularity in the pressure at the center of the top surface that sucks material all the way to the top surface to fill the gap left by the outward motion of material at this location.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p><a class="anchor" id="UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions"></a></p><h4>Using imhomogeneous constraints for implementing Dirichlet boundary conditions</h4>
<p>In all the previous tutorial programs, we used the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object merely for handling hanging node constraints (with exception of <a class="el" href="step_11.html">step-11</a>). However, the class can also be used to implement Dirichlet boundary conditions, as we will show in this program, by fixing some node values \(x_i = b_i\). Note that these are inhomogeneous constraints, and we have to pay some special attention to that. The way we are going to implement this is to first read in the boundary values into the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object by using the call</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          1,</div><div class="line">                                          BoundaryValues&lt;dim&gt;(),</div><div class="line">                                          constraints);</div></div><!-- fragment --><p>very similar to how we were making the list of boundary nodes before (note that we set Dirichlet conditions only on boundaries with boundary flag 1). The actual application of the boundary values is then handled by the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object directly, without any additional interference.</p>
<p>We could then proceed as before, namely by filling the matrix, and then calling a condense function on the constraints object of the form </p><div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (system_matrix, system_rhs);</div></div><!-- fragment --><p>Note that we call this on the system matrix and system right hand side simultaneously, since resolving inhomogeneous constraints requires knowledge about both the matrix entries and the right hand side. For efficiency reasons, though, we choose another strategy: all the constraints collected in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object can be resolved on the fly while writing local data into the global matrix, by using the call </p><div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a> (local_matrix, local_rhs,</div><div class="line">                                        local_dof_indices,</div><div class="line">                                        system_matrix, system_rhs);</div></div><!-- fragment --><p>This technique is further discussed in the <a class="el" href="step_27.html">step-27</a> tutorial program. All we need to know here is that this functions does three things at once: it writes the local data into the global matrix and right hand side, it distributes the hanging node constraints and additionally implements (inhomogeneous) Dirichlet boundary conditions. That's nice, isn't it?</p>
<p>We can conclude that the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class provides an alternative to using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> for implementing Dirichlet boundary conditions.</p>
<p><a class="anchor" id="constraint-matrix"></a> <a class="anchor" id="UsingAffineConstraintsforincreasingperformance"></a></p><h4>Using <a class="el" href="classAffineConstraints.html">AffineConstraints</a> for increasing performance</h4>
<p>Frequently, a sparse matrix contains a substantial amount of elements that actually are zero when we are about to start a linear solve. Such elements are introduced when we eliminate constraints or implement Dirichlet conditions, where we usually delete all entries in constrained rows and columns, i.e., we set them to zero. The fraction of elements that are present in the sparsity pattern, but do not really contain any information, can be up to one fourth of the total number of elements in the matrix for the 3D application considered in this tutorial program. Remember that matrix-vector products or preconditioners operate on all the elements of a sparse matrix (even those that are zero), which is an inefficiency we will avoid here.</p>
<p>An advantage of directly resolving constrained degrees of freedom is that we can avoid having most of the entries that are going to be zero in our sparse matrix &mdash; we do not need constrained entries during matrix construction (as opposed to the traditional algorithms, which first fill the matrix, and only resolve constraints afterwards). This will save both memory and time when forming matrix-vector products. The way we are going to do that is to pass the information about constraints to the function that generates the sparsity pattern, and then set a <code>false</code> argument specifying that we do not intend to use constrained entries: </p><div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern,</div><div class="line">                                 constraints, <span class="keyword">false</span>);</div></div><!-- fragment --><p> This functions obviates, by the way, also the call to the <code>condense()</code> function on the sparsity pattern.</p>
<p><a class="anchor" id="Performanceoptimizations"></a></p><h4>Performance optimizations</h4>
<p>The program developed below has seen a lot of TLC. We have run it over and over under profiling tools (mainly <a href="http://www.valgrind.org/">valgrind</a>'s cachegrind and callgrind tools, as well as the KDE <a href="http://kcachegrind.sourceforge.net/">KCachegrind</a> program for visualization) to see where the bottlenecks are. This has paid off: through this effort, the program has become about four times as fast when considering the runtime of the refinement cycles zero through three, reducing the overall number of CPU instructions executed from 869,574,060,348 to 199,853,005,625. For higher refinement levels, the gain is probably even larger since some algorithms that are not \({\cal O}(N)\) have been eliminated.</p>
<p>Essentially, there are currently two algorithms in the program that do not scale linearly with the number of degrees of freedom: renumbering of degrees of freedom (which is \({\cal O}(N \log N)\), and the linear solver (which is \({\cal O}(N^{4/3})\)). As for the first, while reordering degrees of freedom may not scale linearly, it is an indispensable part of the overall algorithm as it greatly improves the quality of the sparse ILU, easily making up for the time spent on computing the renumbering; graphs and timings to demonstrate this are shown in the documentation of the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace, also underlining the choice of the Cuthill-McKee reordering algorithm chosen below.</p>
<p>As for the linear solver: as mentioned above, our implementation here uses a Schur complement formulation. This is not necessarily the very best choice but demonstrates various important techniques available in deal.II. The question of which solver is best is again discussed in the <a href="#improved-solver">section on improved solvers in the results part</a> of this program, along with code showing alternative solvers and a comparison of their results.</p>
<p>Apart from this, many other algorithms have been tested and improved during the creation of this program. For example, in building the sparsity pattern, we originally used a (now no longer existing) BlockCompressedSparsityPattern object that added one element at a time; however, its data structures were poorly adapted for the large numbers of nonzero entries per row created by our discretization in 3d, leading to a quadratic behavior. Replacing the internal algorithms in deal.II to set many elements at a time, and using a BlockCompressedSimpleSparsityPattern (which has, as of early 2015, been in turn replaced by <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>) as a better adapted data structure, removed this bottleneck at the price of a slightly higher memory consumption. Likewise, the implementation of the decomposition step in the <a class="el" href="classSparseILU.html">SparseILU</a> class was very inefficient and has been replaced by one that is about 10 times faster. Even the vmult function of the <a class="el" href="classSparseILU.html">SparseILU</a> has been improved to save about twenty percent of time. Small improvements were applied here and there. Moreover, the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object has been used to eliminate a lot of entries in the sparse matrix that are eventually going to be zero, see <a href="#constraint-matrix">the section on using advanced features of the AffineConstraints class</a>.</p>
<p>A profile of how many CPU instructions are spent at the various different places in the program during refinement cycles zero through three in 3d is shown here:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.png"/>
</div>
<p>As can be seen, at this refinement level approximately three quarters of the instruction count is spent on the actual solver (the <a class="el" href="classSparseILU.html#aa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> calls on the left, the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult</a> call in the middle for the Schur complement solve, and another box representing the multiplications with <a class="el" href="classSparseILU.html">SparseILU</a> and <a class="el" href="classSparseMatrix.html">SparseMatrix</a> in the solve for <em>U</em>). About one fifth of the instruction count is spent on matrix assembly and sparse ILU computation (box in the lower right corner) and the rest on other things. Since floating point operations such as in the <a class="el" href="classSparseILU.html#aa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> calls typically take much longer than many of the logical operations and table lookups in matrix assembly, the fraction of the run time taken up by matrix assembly is actually significantly less than the fraction of instructions, as will become apparent in the comparison we make in the results section.</p>
<p>For higher refinement levels, the boxes representing the solver as well as the blue box at the top right stemming from reordering algorithm are going to grow at the expense of the other parts of the program, since they don't scale linearly. The fact that at this moderate refinement level (3168 cells and 93176 degrees of freedom) the linear solver already makes up about three quarters of the instructions is a good sign that most of the algorithms used in this program are well-tuned and that major improvements in speeding up the program are most likely not to come from hand-optimizing individual aspects but by changing solver algorithms. We will address this point in the discussion of results below as well.</p>
<p>As a final point, and as a point of reference, the following picture also shows how the profile looked at an early stage of optimizing this program:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.original.png"/>
</div>
<p>As mentioned above, the runtime of this version was about four times as long as for the first profile, with the <a class="el" href="classSparseILU.html">SparseILU</a> decomposition taking up about 30% of the instruction count, and operations an early, inefficient version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> about 10%. Both these bottlenecks have since been completely removed.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As usual, we start by including some well-known files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>Then we need to include the header file for the sparse direct solver UMFPACK:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div></div><!-- fragment --><p>This includes the library for the incomplete LU factorization that will be used as a preconditioner in 3D:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>As in all programs, the namespace dealii is included:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step22</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Definingtheinnerpreconditionertype"></a> </p><h3>Defining the inner preconditioner type</h3>
<p>As explained in the introduction, we are going to use different preconditioners for two and three space dimensions, respectively. We distinguish between them by the use of the spatial dimension as a template parameter. See <a class="el" href="step_4.html">step-4</a> for details on templates. We are not going to create any preconditioner object here, all we do is to create class that holds a local alias determining the preconditioner class so we can write our program in a dimension-independent way.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div></div><!-- fragment --><p>In 2D, we are going to use a sparse direct solver as preconditioner:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">};</div></div><!-- fragment --><p>And the ILU preconditioning in 3D, called by <a class="el" href="classSparseILU.html">SparseILU</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStokesProblemcodeclasstemplate"></a> </p><h3>The <code>StokesProblem</code> class template</h3>
<p>This is an adaptation of <a class="el" href="step_20.html">step-20</a>, so the main class and the data types are nearly the same as used there. The only difference is that we have an additional member <code>preconditioner_matrix</code>, that is used for preconditioning the Schur complement, and a corresponding sparsity pattern <code>preconditioner_sparsity_pattern</code>. In addition, instead of relying on <a class="el" href="classLinearOperator.html">LinearOperator</a>, we implement our own InverseMatrix class.</p>
<p>In this example we also use adaptive grid refinement, which is handled in analogy to <a class="el" href="step_6.html">step-6</a>. According to the discussion in the introduction, we are also going to use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object for implementing Dirichlet boundary conditions. Hence, we change the name <code>hanging_node_constraints</code> into <code>constraints</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div></div><!-- fragment --><p>This one is new: We shall use a so-called shared pointer structure to access the preconditioner. Shared pointers are essentially just a convenient form of pointers. Several shared pointers can point to the same object (just like regular pointers), but when the last shared pointer object to point to a preconditioner object is deleted (for example if a shared pointer object goes out of scope, if the class of which it is a member is destroyed, or if the pointer is assigned a different preconditioner object) then the preconditioner object pointed to is also destroyed. This ensures that we don't have to manually track in how many places a preconditioner object is still referenced, it can never create a memory leak, and can never produce a dangling pointer to an already destroyed object:</p>
<div class="fragment"><div class="line">  std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3>Boundary values and right hand side</h3>
<p>As in <a class="el" href="step_20.html">step-20</a> and most other example programs, the next task is to define the data for the PDE: For the Stokes problem, we are going to use natural boundary values on parts of the boundary (i.e. homogeneous Neumann-type) for which we won't have to do anything special (the homogeneity implies that the corresponding terms in the weak form are simply zero), and boundary conditions on the velocity (Dirichlet-type) on the rest of the boundary, as described in the introduction.</p>
<p>In order to enforce the Dirichlet boundary values on the velocity, we will use the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> function as usual which requires us to write a function object with as many components as the finite element has. In other words, we have to define the function on the \((u,p)\)-space, but we are going to filter out the pressure component when interpolating the boundary values.</p>
<p>The following function object is a representation of the boundary values described in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> (p[0] &lt; 0 ? -1 : (p[0] &gt; 0 ? 1 : 0));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p>We implement similar functions for the right hand side which for the current example is simply zero:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>The linear solvers and preconditioners are discussed extensively in the introduction. Here, we create the respective objects that will be used.</p>
<p><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> </p><h4>The <code>InverseMatrix</code> class template</h4>
<p>The <code>InverseMatrix</code> class represents the data structure for an inverse matrix. Unlike <a class="el" href="step_20.html">step-20</a>, we implement this with a class instead of the helper function inverse_linear_operator() we will apply this class to different kinds of matrices that will require different preconditioners (in <a class="el" href="step_20.html">step-20</a> we only used a non-identity preconditioner for the mass matrix). The types of matrix and preconditioner are passed to this class via template parameters, and matrix and preconditioner objects of these types will then be passed to the constructor when an <code>InverseMatrix</code> object is created. The member function <code>vmult</code> is obtained by solving a linear system:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  , preconditioner(&amp;preconditioner)</div><div class="line">{}</div></div><!-- fragment --><p>This is the implementation of the <code>vmult</code> function.</p>
<p>In this class we use a rather large tolerance for the solver control. The reason for this is that the function is used very frequently, and hence, any additional effort to make the residual in the CG solve smaller makes the solution more expensive. Note that we do not only use this class as a preconditioner for the Schur complement, but also when forming the inverse of the Laplace matrix &ndash; which is hence directly responsible for the accuracy of the solution itself, so we can't choose a too large tolerance, either.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, *preconditioner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeSchurComplementcodeclasstemplate"></a> </p><h4>The <code>SchurComplement</code> class template</h4>
<p>This class implements the Schur complement discussed in the introduction. It is in analogy to <a class="el" href="step_20.html">step-20</a>. Though, we now call it with a template parameter <code>PreconditionerType</code> in order to access that when specifying the respective type of the inverse matrix class. As a consequence of the definition above, the declaration <code>InverseMatrix</code> now contains the second template parameter for a preconditioner class as above, which affects the <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> object <code>m_inverse</code> as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div><div class="line">    A_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div><div class="line">  : system_matrix(&amp;system_matrix)</div><div class="line">  , A_inverse(&amp;A_inverse)</div><div class="line">  , tmp1(system_matrix.block(0, 0).m())</div><div class="line">  , tmp2(system_matrix.block(0, 0).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">SchurComplement&lt;PreconditionerType&gt;::vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">                                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).vmult(tmp1, src);</div><div class="line">  A_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">  system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemclassimplementation"></a> </p><h3>StokesProblem class implementation</h3>
<p><a class="anchor" id="StokesProblemStokesProblem"></a> </p><h4>StokesProblem::StokesProblem</h4>
<p>The constructor of this class looks very similar to the one of <a class="el" href="step_20.html">step-20</a>. The constructor initializes the variables for the polynomial degree, triangulation, finite element system and the dof handler. The underlying polynomial functions are of order <code>degree+1</code> for the vector-valued velocity components and of order <code>degree</code> for the pressure. This gives the LBB-stable element pair \(Q_{degree+1}^d\times Q_{degree}\), often referred to as the Taylor-Hood element.</p>
<p>Note that we initialize the triangulation with a MeshSmoothing argument, which ensures that the refinement of cells is done in a way that the approximation of the PDE solution remains well-behaved (problems arise if grids are too unstructured), see the documentation of <code><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></code> for details.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : degree(degree)</div><div class="line">  , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemsetup_dofs"></a> </p><h4>StokesProblem::setup_dofs</h4>
<p>Given a mesh, this function associates the degrees of freedom with it and creates the corresponding matrices and vectors. At the beginning it also releases the pointer to the preconditioner object (if the shared pointer pointed at anything at all at this point) since it will definitely not be needed any more after this point and will have to be re-computed after assembling the matrix, and unties the sparse matrices from their sparsity pattern objects.</p>
<p>We then proceed with distributing degrees of freedom and renumbering them: In order to make the ILU preconditioner (in 3D) work efficiently, it is important to enumerate the degrees of freedom in such a way that it reduces the bandwidth of the matrix, or maybe more importantly: in such a way that the ILU is as close as possible to a real LU decomposition. On the other hand, we need to preserve the block structure of velocity and pressure already seen in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>. This is done in two steps: First, all dofs are renumbered to improve the ILU and then we renumber once again by components. Since <code><a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></code> does not touch the renumbering within the individual blocks, the basic renumbering from the first step remains. As for how the renumber degrees of freedom to improve the ILU: deal.II has a number of algorithms that attempt to find orderings to improve ILUs, or reduce the bandwidth of matrices, or optimize some other aspect. The <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace shows a comparison of the results we obtain with several of these algorithms based on the testcase discussed here in this tutorial program. Here, we will use the traditional Cuthill-McKee algorithm already used in some of the previous tutorial programs. In the <a href="#improved-ilu">section on improved ILU</a> we're going to discuss this issue in more detail.</p>
<p>There is one more change compared to previous tutorial programs: There is no reason in sorting the <code>dim</code> velocity components individually. In fact, rather than first enumerating all \(x\)-velocities, then all \(y\)-velocities, etc, we would like to keep all velocities at the same location together and only separate between velocities (all components) and pressures. By default, this is not what the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function does: it treats each vector component separately; what we have to do is group several components into "blocks" and pass this block structure to that function. Consequently, we allocate a vector <code>block_component</code> with as many elements as there are components and describe all velocity components to correspond to block 0, while the pressure component will form block 1:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  A_preconditioner.reset();</div><div class="line">  system_matrix.clear();</div><div class="line">  preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div><div class="line">  block_component[dim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div></div><!-- fragment --><p>Now comes the implementation of Dirichlet boundary conditions, which should be evident after the discussion in the introduction. All that changed is that the function already appears in the setup functions, whereas we were used to see it in some assembly routine. Further down below where we set up the mesh, we will associate the top boundary where we impose Dirichlet boundary conditions with boundary indicator</p><ol type="1">
<li>We will have to pass this boundary indicator as second argument to the function below interpolating boundary values. There is one more thing, though. The function describing the Dirichlet conditions was defined for all components, both velocity and pressure. However, the Dirichlet conditions are to be set for the velocity only. To this end, we use a <a class="el" href="classComponentMask.html">ComponentMask</a> that only selects the velocity components. The component mask is obtained from the finite element by specifying the particular components we want. Since we use adaptively refined grids, the affine constraints object needs to be first filled with hanging node constraints generated from the DoF handler. Note the order of the two functions &mdash; we first compute the hanging node constraints, and then insert the boundary values into the constraints object. This makes sure that we respect H<sup>1</sup> conformity on boundaries with hanging nodes (in three space dimensions), where the hanging node needs to dominate the Dirichlet boundary values.</li>
</ol>
<div class="fragment"><div class="line">{</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints,</div><div class="line">                                           fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">}</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div></div><!-- fragment --><p>In analogy to <a class="el" href="step_20.html">step-20</a>, we count the dofs in the individual components. We could do this in the same way as there, but we want to operate on the block structure we used already for the renumbering: The function <code><a class="el" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></code> does the same as <code><a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a></code>, but now grouped as velocity and pressure block via <code>block_component</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next task is to allocate a sparsity pattern for the system matrix we will create and one for the preconditioner matrix. We could do this in the same way as in <a class="el" href="step_20.html">step-20</a>, i.e. directly build an object of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a> through <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>. However, there is a major reason not to do so: In 3D, the function DoFTools::max_couplings_between_dofs yields a conservative but rather large number for the coupling between the individual dofs, so that the memory initially provided for the creation of the sparsity pattern of the matrix is far too much &ndash; so much actually that the initial sparsity pattern won't even fit into the physical memory of most systems already for moderately-sized 3D problems, see also the discussion in <a class="el" href="step_18.html">step-18</a>. Instead, we first build temporary objects that use a different data structure that doesn't require allocating more memory than necessary but isn't suitable for use as a basis of <a class="el" href="classSparseMatrix.html">SparseMatrix</a> or <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> objects; in a second step we then copy these objects into objects of type <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>. This is entirely analogous to what we already did in <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_18.html">step-18</a>. In particular, we make use of the fact that we will never write into the \((1,1)\) block of the system matrix and that this is the only block to be filled for the preconditioner matrix.</p>
<p>All this is done inside new scopes, which means that the memory of <code>dsp</code> will be released once the information has been copied to <code>sparsity_pattern</code>.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div><div class="line"></div><div class="line">  preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  preconditioner_dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                  preconditioner_coupling,</div><div class="line">                                  preconditioner_dsp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div><div class="line">}</div></div><!-- fragment --><p>Finally, the system matrix, the preconsitioner matrix, the solution and the right hand side vector are created from the block structure similar to the approach in <a class="el" href="step_20.html">step-20</a>:</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(2);</div><div class="line">  solution.block(0).reinit(n_u);</div><div class="line">  solution.block(1).reinit(n_p);</div><div class="line">  solution.collect_sizes();</div><div class="line"></div><div class="line">  system_rhs.reinit(2);</div><div class="line">  system_rhs.block(0).reinit(n_u);</div><div class="line">  system_rhs.block(1).reinit(n_p);</div><div class="line">  system_rhs.collect_sizes();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemassemble_system"></a> </p><h4>StokesProblem::assemble_system</h4>
<p>The assembly process follows the discussion in <a class="el" href="step_20.html">step-20</a> and in the introduction. We use the well-known abbreviations for the data structures that hold the local matrices, right hand side, and global numbering of the degrees of freedom for the present cell.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix         = 0;</div><div class="line">  system_rhs            = 0;</div><div class="line">  preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div><div class="line">                                                 dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div></div><!-- fragment --><p>Next, we need two objects that work as extractors for the <a class="el" href="classFEValues.html">FEValues</a> object. Their use is explained in detail in the report on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>As an extension over <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>, we include a few optimizations that make assembly much faster for this particular problem. The improvements are based on the observation that we do a few calculations too many times when we do as in <a class="el" href="step_20.html">step-20</a>: The symmetric gradient actually has <code>dofs_per_cell</code> different values per quadrature point, but we extract it <code>dofs_per_cell*dofs_per_cell</code> times from the <a class="el" href="classFEValues.html">FEValues</a> object - for both the loop over <code>i</code> and the inner loop over <code>j</code>. In 3d, that means evaluating it \(89^2=7921\) instead of \(89\) times, a not insignificant difference.</p>
<p>So what we're going to do here is to avoid such repeated calculations by getting a vector of rank-2 tensors (and similarly for the divergence and the basis function value on pressure) at the quadrature point prior to starting the loop over the dofs on the cell. First, we create the respective objects that will hold these values. Then, we start the loop over all cells and the loop over the quadrature points, where we first extract these values. There is one more optimization we implement here: the local matrix (as well as the global one) is going to be symmetric, since all the operations involved are symmetric with respect to \(i\) and \(j\). This is implemented by simply running the inner loop not to <code>dofs_per_cell</code>, but only up to <code>i</code>, the index of the outer loop.</p>
<div class="fragment"><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    local_matrix                = 0;</div><div class="line">    local_preconditioner_matrix = 0;</div><div class="line">    local_rhs                   = 0;</div><div class="line"></div><div class="line">    right_hand_side.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                      rhs_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            symgrad_phi_u[k] =</div><div class="line">              fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">            div_phi_u[k] = fe_values[velocities].divergence(k, q);</div><div class="line">            phi_p[k]     = fe_values[pressure].value(k, q);</div><div class="line">          }</div></div><!-- fragment --><p>Now finally for the bilinear forms of both the system matrix and the matrix we use for the preconditioner. Recall that the formulas for these two are </p><p class="formulaDsp">
\begin{align*} A_{ij} &amp;= a(\varphi_i,\varphi_j) \\ &amp;= \underbrace{2(\varepsilon(\varphi_{i,\textbf{u}}), \varepsilon(\varphi_{j,\textbf{u}}))_{\Omega}} _{(1)} \; \underbrace{- (\textrm{div}\; \varphi_{i,\textbf{u}}, \varphi_{j,p})_{\Omega}} _{(2)} \; \underbrace{- (\varphi_{i,p}, \textrm{div}\; \varphi_{j,\textbf{u}})_{\Omega}} _{(3)} \end{align*}
</p>
<p> and </p><p class="formulaDsp">
\begin{align*} M_{ij} &amp;= \underbrace{(\varphi_{i,p}, \varphi_{j,p})_{\Omega}} _{(4)}, \end{align*}
</p>
<p> respectively, where \(\varphi_{i,\textbf{u}}\) and \(\varphi_{i,p}\) are the velocity and pressure components of the \(i\)th shape function. The various terms above are then easily recognized in the following implementation:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">      {</div><div class="line">        local_matrix(i, j) +=</div><div class="line">          (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) <span class="comment">// (1)</span></div><div class="line">           - div_phi_u[i] * phi_p[j]                 <span class="comment">// (2)</span></div><div class="line">           - phi_p[i] * div_phi_u[j])                <span class="comment">// (3)</span></div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);                        <span class="comment">// * dx</span></div><div class="line"></div><div class="line">        local_preconditioner_matrix(i, j) +=</div><div class="line">          (phi_p[i] * phi_p[j]) <span class="comment">// (4)</span></div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);   <span class="comment">// * dx</span></div><div class="line">      }</div></div><!-- fragment --><p>Note that in the implementation of (1) above, <code>operator*</code> is overloaded for symmetric tensors, yielding the scalar product between the two tensors.</p>
<p>For the right-hand side we use the fact that the shape functions are only non-zero in one component (because our elements are primitive). Instead of multiplying the tensor representing the dim+1 values of shape function i with the whole right-hand side vector, we only look at the only non-zero component. The function <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index</a> will return which component this shape function lives in (0=x velocity, 1=y velocity, 2=pressure in 2d), which we use to pick out the correct component of the right-hand side vector to multiply with.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">      local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div><div class="line">                         rhs_values[q](component_i)) <span class="comment">// * f(x_q))</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);            <span class="comment">// * dx</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Before we can write the local data into the global matrix (and simultaneously use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object to apply Dirichlet boundary conditions and eliminate hanging node constraints, as we discussed in the introduction), we have to be careful about one thing, though. We have only built half of the local matrices because of symmetry, but we're going to save the full matrices in order to use the standard functions for solving. This is done by flipping the indices in case we are pointing into the empty part of the local matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        local_matrix(i, j) = local_matrix(j, i);</div><div class="line">        local_preconditioner_matrix(i, j) =</div><div class="line">          local_preconditioner_matrix(j, i);</div><div class="line">      }</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                         local_rhs,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix,</div><div class="line">                                         system_rhs);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_preconditioner_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         preconditioner_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Before we're going to solve this linear system, we generate a preconditioner for the velocity-velocity matrix, i.e., <code>block(0,0)</code> in the system matrix. As mentioned above, this depends on the spatial dimension. Since the two classes described by the <code>InnerPreconditioner::type</code> alias have the same interface, we do not have to do anything different whether we want to use a sparse direct solver or an ILU:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  A_preconditioner =</div><div class="line">    std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div><div class="line">  A_preconditioner-&gt;initialize(</div><div class="line">    system_matrix.block(0, 0),</div><div class="line">    <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemsolve"></a> </p><h4>StokesProblem::solve</h4>
<p>After the discussion in the introduction and the definition of the respective classes above, the implementation of the <code>solve</code> function is rather straight-forward and done in a similar way as in <a class="el" href="step_20.html">step-20</a>. To start with, we need an object of the <code>InverseMatrix</code> class that represents the inverse of the matrix A. As described in the introduction, the inverse is generated with the help of an inner preconditioner of type <code>InnerPreconditioner::type</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div><div class="line">                 A_inverse(system_matrix.block(0, 0), *A_preconditioner);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div></div><!-- fragment --><p>This is as in <a class="el" href="step_20.html">step-20</a>. We generate the right hand side \(B A^{-1} F - G\) for the Schur complement and an object that represents the respective linear operation \(B A^{-1} B^T\), now with a template parameter indicating the preconditioner - in accordance with the definition of the class.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div><div class="line">  A_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">  system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">  schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line">  SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div><div class="line">    system_matrix, A_inverse);</div></div><!-- fragment --><p>The usual control structures for the solver call are created...</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                             1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * schur_rhs.l2_norm());</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div></div><!-- fragment --><p>Now to the preconditioner to the Schur complement. As explained in the introduction, the preconditioning is done by a mass matrix in the pressure variable.</p>
<p>Actually, the solver needs to have the preconditioner in the form \(P^{-1}\), so we need to create an inverse operation. Once again, we use an object of the class <code>InverseMatrix</code>, which implements the <code>vmult</code> operation that is needed by the solver. In this case, we have to invert the pressure mass matrix. As it already turned out in earlier tutorial programs, the inversion of a mass matrix is a rather cheap and straight-forward operation (compared to, e.g., a Laplace matrix). The CG method with ILU preconditioning converges in 5-10 steps, independently on the mesh size. This is precisely what we do here: We choose another ILU preconditioner and take it along to the InverseMatrix object via the corresponding template parameter. A CG solver is then called within the vmult operation of the inverse matrix.</p>
<p>An alternative that is cheaper to build, but needs more iterations afterwards, would be to choose a SSOR preconditioner with factor 1.2. It needs about twice the number of iterations, but the costs for its generation are almost negligible.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div><div class="line">preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div><div class="line">                          <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div><div class="line">  preconditioner_matrix.block(1, 1), preconditioner);</div></div><!-- fragment --><p>With the Schur complement and an efficient preconditioner at hand, we can solve the respective equation for the pressure (i.e. block 0 in the solution vector) in the usual way:</p>
<div class="fragment"><div class="line">cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div></div><!-- fragment --><p>After this first solution step, the hanging node constraints have to be distributed to the solution in order to achieve a consistent pressure field.</p>
<div class="fragment"><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>As in <a class="el" href="step_20.html">step-20</a>, we finally need to solve for the velocity equation where we plug in the solution to the pressure equation. This involves only objects we already know - so we simply multiply \(p\) by \(B^T\), subtract the right hand side and multiply by the inverse of \(A\). At the end, we need to distribute the constraints from hanging nodes in order to obtain a consistent flow field:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">    tmp *= -1;</div><div class="line">    tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">    A_inverse.vmult(solution.block(0), tmp);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemoutput_results"></a> </p><h4>StokesProblem::output_results</h4>
<p>The next function generates graphical output. In this example, we are going to use the VTK file format. We attach names to the individual variables in the problem: <code>velocity</code> to the <code>dim</code> components of velocity and <code>pressure</code> to the pressure.</p>
<p>Not all visualization programs have the ability to group individual vector components into a vector to provide vector plots; in particular, this holds for some VTK-based visualization programs. In this case, the logical grouping of components into vectors should already be described in the file containing the data. In other words, what we need to do is provide our output writers with a way to know which of the components of the finite element logically form a vector (with \(d\) components in \(d\) space dimensions) rather than letting them assume that we simply have a bunch of scalar fields. This is achieved using the members of the <code><a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a></code> namespace: as with the filename, we create a vector in which the first <code>dim</code> components refer to the velocities and are given the tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>; we finally push one tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a> to describe the grouping of the pressure variable.</p>
<p>The rest of the function is then the same as in <a class="el" href="step_20.html">step-20</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemrefine_mesh"></a> </p><h4>StokesProblem::refine_mesh</h4>
<p>This is the last interesting function of the <code>StokesProblem</code> class. As indicated by its name, it takes the solution to the problem and refines the mesh where this is needed. The procedure is the same as in the respective step in <a class="el" href="step_6.html">step-6</a>, with the exception that we base the refinement only on the change in pressure, i.e., we call the Kelly error estimator with a mask object of type <a class="el" href="classComponentMask.html">ComponentMask</a> that selects the single scalar component for the pressure that we are interested in (we get such a mask from the finite element class by specifying the component we want). Additionally, we do not coarsen the grid again:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell,</div><div class="line">    fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(pressure));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.0);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemrun"></a> </p><h4>StokesProblem::run</h4>
<p>The last step in the Stokes class is, as usual, the function that generates the initial grid and calls the other functions in the respective order.</p>
<p>We start off with a rectangle of size \(4 \times 1\) (in 2d) or \(4 \times 1 \times 1\) (in 3d), placed in \(R^2/R^3\) as \((-2,2)\times(-1,0)\) or \((-2,2)\times(0,1)\times(-1,0)\), respectively. It is natural to start with equal mesh size in each direction, so we subdivide the initial rectangle four times in the first coordinate direction. To limit the scope of the variables involved in the creation of the mesh to the range where we actually need them, we put the entire block between a pair of braces:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div><div class="line">    subdivisions[0] = 4;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, -1) :    <span class="comment">// 2d case</span></div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, 0, -1)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 1, 0)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              subdivisions,</div><div class="line">                                              bottom_left,</div><div class="line">                                              top_right);</div><div class="line">  }</div></div><!-- fragment --><p>A boundary indicator of 1 is set to all boundaries that are subject to Dirichlet boundary conditions, i.e. to faces that are located at 0 in the last coordinate direction. See the example description above for details.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;center()[dim - 1] == 0)</div><div class="line">      face-&gt;set_all_boundary_ids(1);</div></div><!-- fragment --><p>We then apply an initial refinement before solving for the first time. In 3D, there are going to be more degrees of freedom, so we refine less there:</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4 - dim);</div></div><!-- fragment --><p>As first seen in <a class="el" href="step_6.html">step-6</a>, we cycle over the different refinement levels and refine (except for the first cycle), setup the degrees of freedom and matrices, assemble, solve and create output:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step22</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function is the same as in <a class="el" href="step_20.html">step-20</a>. We pass the element degree as a parameter and choose the space dimension at the well-known template slot.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step22;</div><div class="line"></div><div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Outputoftheprogramandgraphicalvisualization"></a></p><h3>Output of the program and graphical visualization</h3>
<p><a class="anchor" id="2Dcalculations"></a></p><h4>2D calculations</h4>
<p>Running the program with the space dimension set to 2 in the <code>main</code> function yields the following output (in "release mode", See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.18.html">video lecture 18</a>.): </p><div class="fragment"><div class="line">examples/step-22&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 679 (594+85)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 160</div><div class="line">   Number of degrees of freedom: 1683 (1482+201)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 376</div><div class="line">   Number of degrees of freedom: 3813 (3370+443)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 880</div><div class="line">   Number of degrees of freedom: 8723 (7722+1001)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2008</div><div class="line">   Number of degrees of freedom: 19383 (17186+2197)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 4288</div><div class="line">   Number of degrees of freedom: 40855 (36250+4605)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div></div><!-- fragment --><p>The entire computation above takes about 2 seconds on a reasonably quick (for 2015 standards) machine.</p>
<p>What we see immediately from this is that the number of (outer) iterations does not increase as we refine the mesh. This confirms the statement in the introduction that preconditioning the Schur complement with the mass matrix indeed yields a matrix spectrally equivalent to the identity matrix (i.e. with eigenvalues bounded above and below independently of the mesh size or the relative sizes of cells). In other words, the mass matrix and the Schur complement are spectrally equivalent.</p>
<p>In the images below, we show the grids for the first six refinement steps in the program. Observe how the grid is refined in regions where the solution rapidly changes: On the upper boundary, we have Dirichlet boundary conditions that are -1 in the left half of the line and 1 in the right one, so there is an abrupt change at \(x=0\). Likewise, there are changes from Dirichlet to Neumann data in the two upper corners, so there is need for refinement there as well:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-0.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-1.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-3.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-4.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-5.png"/>
</div>
   </td></tr>
</table>
<p>Finally, following is a plot of the flow field. It shows fluid transported along with the moving upper boundary and being replaced by material coming from below:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.solution.png"/>
</div>
<p>This plot uses the capability of VTK-based visualization programs (in this case of VisIt) to show vector data; this is the result of us declaring the velocity components of the finite element in use to be a set of vector components, rather than independent scalar components in the <code>StokesProblem&lt;dim&gt;::output_results</code> function of this tutorial program.</p>
<p><a class="anchor" id="3Dcalculations"></a></p><h4>3D calculations</h4>
<p>In 3d, the screen output of the program looks like this:</p>
<div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 32</div><div class="line">   Number of degrees of freedom: 1356 (1275+81)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  13 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 144</div><div class="line">   Number of degrees of freedom: 5088 (4827+261)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 704</div><div class="line">   Number of degrees of freedom: 22406 (21351+1055)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 3168</div><div class="line">   Number of degrees of freedom: 93176 (89043+4133)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 11456</div><div class="line">   Number of degrees of freedom: 327808 (313659+14149)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 45056</div><div class="line">   Number of degrees of freedom: 1254464 (1201371+53093)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div></div><!-- fragment --><p>Again, we see that the number of outer iterations does not increase as we refine the mesh. Nevertheless, the compute time increases significantly: for each of the iterations above separately, it takes about 0.14 seconds, 0.63 seconds, 4.8 seconds, 35 seconds, 2 minutes and 33 seconds, and 13 minutes and 12 seconds. This overall superlinear (in the number of unknowns) increase in runtime is due to the fact that our inner solver is not \({\cal O}(N)\): a simple experiment shows that as we keep refining the mesh, the average number of ILU-preconditioned CG iterations to invert the velocity-velocity block \(A\) increases.</p>
<p>We will address the question of how possibly to improve our solver <a href="#improved-solver">below</a>.</p>
<p>As for the graphical output, the grids generated during the solution look as follow:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-0.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-1.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-3.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-4.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-5.png"/>
</div>
   </td></tr>
</table>
<p>Again, they show essentially the location of singularities introduced by boundary conditions. The vector field computed makes for an interesting graph:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.solution.png"/>
</div>
<p>The isocontours shown here as well are those of the pressure variable, showing the singularity at the point of discontinuous velocity boundary conditions.</p>
<p><a class="anchor" id="Sparsitypattern"></a></p><h3>Sparsity pattern</h3>
<p>As explained during the generation of the sparsity pattern, it is important to have the numbering of degrees of freedom in mind when using preconditioners like incomplete LU decompositions. This is most conveniently visualized using the distribution of nonzero elements in the stiffness matrix.</p>
<p>If we don't do anything special to renumber degrees of freedom (i.e., without using <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>, but with using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> to ensure that degrees of freedom are appropriately sorted into their corresponding blocks of the matrix and vector), then we get the following image after the first adaptive refinement in two dimensions:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-nor.png"/>
</div>
<p>In order to generate such a graph, you have to insert a piece of code like the following to the end of the setup step. </p><div class="fragment"><div class="line">{</div><div class="line">  std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern.gpl&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a7f59a68863a1e770ba275894a7170e70">print_gnuplot</a>(out);</div><div class="line">}</div></div><!-- fragment --><p>It is clearly visible that the nonzero entries are spread over almost the whole matrix. This makes preconditioning by ILU inefficient: ILU generates a Gaussian elimination (LU decomposition) without fill-in elements, which means that more tentative fill-ins left out will result in a worse approximation of the complete decomposition.</p>
<p>In this program, we have thus chosen a more advanced renumbering of components. The renumbering with <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a> and grouping the components into velocity and pressure yields the following output:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-ren.png"/>
</div>
<p>It is apparent that the situation has improved a lot. Most of the elements are now concentrated around the diagonal in the (0,0) block in the matrix. Similar effects are also visible for the other blocks. In this case, the ILU decomposition will be much closer to the full LU decomposition, which improves the quality of the preconditioner. (It may be interesting to note that the sparse direct solver UMFPACK does some internal renumbering of the equations before actually generating a sparse LU decomposition; that procedure leads to a very similar pattern to the one we got from the Cuthill-McKee algorithm.)</p>
<p>Finally, we want to have a closer look at a sparsity pattern in 3D. We show only the (0,0) block of the matrix, again after one adaptive refinement. Apart from the fact that the matrix size has increased, it is also visible that there are many more entries in the matrix. Moreover, even for the optimized renumbering, there will be a considerable amount of tentative fill-in elements. This illustrates why UMFPACK is not a good choice in 3D - a full decomposition needs many new entries that eventually won't fit into the physical memory (RAM):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.sparsity_uu-ren.png"/>
</div>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="improved-solver"></a> <a class="anchor" id="Improvedlinearsolverin3D"></a></p><h4>Improved linear solver in 3D</h4>
<p>We have seen in the section of computational results that the number of outer iterations does not depend on the mesh size, which is optimal in a sense of scalability. This does, however, not apply to the solver as a whole, as mentioned above: We did not look at the number of inner iterations when generating the inverse of the matrix \(A\) and the mass matrix \(M_p\). Of course, this is unproblematic in the 2D case where we precondition \(A\) with a direct solver and the <code>vmult</code> operation of the inverse matrix structure will converge in one single CG step, but this changes in 3D where we only use an ILU preconditioner. There, the number of required preconditioned CG steps to invert \(A\) increases as the mesh is refined, and each <code>vmult</code> operation involves on average approximately 14, 23, 36, 59, 75 and 101 inner CG iterations in the refinement steps shown above. (On the other hand, the number of iterations for applying the inverse pressure mass matrix is always around five, both in two and three dimensions.) To summarize, most work is spent on solving linear systems with the same matrix \(A\) over and over again. What makes this look even worse is the fact that we actually invert a matrix that is about 95 percent the size of the total system matrix and stands for 85 percent of the non-zero entries in the sparsity pattern. Hence, the natural question is whether it is reasonable to solve a linear system with matrix \(A\) for about 15 times when calculating the solution to the block system.</p>
<p>The answer is, of course, that we can do that in a few other (most of the time better) ways. Nevertheless, it has to be remarked that an indefinite system as the one at hand puts indeed much higher demands on the linear algebra than standard elliptic problems as we have seen in the early tutorial programs. The improvements are still rather unsatisfactory, if one compares with an elliptic problem of similar size. Either way, we will introduce below a number of improvements to the linear solver, a discussion that we will re-consider again with additional options in the <a class="el" href="step_31.html">step-31</a> program.</p>
<p><a class="anchor" id="improved-ilu"></a> <a class="anchor" id="BetterILUdecompositionbysmartreordering"></a></p><h5>Better ILU decomposition by smart reordering</h5>
<p>A first attempt to improve the speed of the linear solution process is to choose a dof reordering that makes the ILU being closer to a full LU decomposition, as already mentioned in the in-code comments. The <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace compares several choices for the renumbering of dofs for the Stokes equations. The best result regarding the computing time was found for the King ordering, which is accessed through the call <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a76fd1dc3212aeeca4294c358248e46d5">DoFRenumbering::boost::king_ordering</a>. With that program, the inner solver needs considerably less operations, e.g. about 62 inner CG iterations for the inversion of \(A\) at cycle 4 compared to about 75 iterations with the standard Cuthill-McKee-algorithm. Also, the computing time at cycle 4 decreased from about 17 to 11 minutes for the <code>solve()</code> call. However, the King ordering (and the orderings provided by the <a class="el" href="namespaceDoFRenumbering_1_1boost.html">DoFRenumbering::boost</a> namespace in general) has a serious drawback - it uses much more memory than the in-build deal versions, since it acts on abstract graphs rather than the geometry provided by the triangulation. In the present case, the renumbering takes about 5 times as much memory, which yields an infeasible algorithm for the last cycle in 3D with 1.2 million unknowns.</p>
<p><a class="anchor" id="BetterpreconditionerfortheinnerCGsolver"></a></p><h5>Better preconditioner for the inner CG solver</h5>
<p>Another idea to improve the situation even more would be to choose a preconditioner that makes CG for the (0,0) matrix \(A\) converge in a mesh-independent number of iterations, say 10 to 30. We have seen such a candidate in <a class="el" href="step_16.html">step-16</a>: multigrid.</p>
<p><a class="anchor" id="BlockSchurcomplementpreconditioner"></a></p><h5>Block Schur complement preconditioner</h5>
<p><a class="anchor" id="block-schur"></a> Even with a good preconditioner for \(A\), we still need to solve of the same linear system repeatedly (with different right hand sides, though) in order to make the Schur complement solve converge. The approach we are going to discuss here is how inner iteration and outer iteration can be combined. If we persist in calculating the Schur complement, there is no other possibility.</p>
<p>The alternative is to attack the block system at once and use an approximate Schur complement as efficient preconditioner. The idea is as follows: If we find a block preconditioner \(P\) such that the matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p> is simple, then an iterative solver with that preconditioner will converge in a few iterations. Using the Schur complement \(S = B A^{-1} B^T\), one finds that </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p> would appear to be a good choice since </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right)\cdot \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right). \end{eqnarray*}
</p>
<p> This is the approach taken by the paper by Silvester and Wathen referenced to in the introduction (with the exception that Silvester and Wathen use right preconditioning). In this case, a Krylov-based iterative method would converge in one step only if exact inverses of \(A\) and \(S\) were applied, since all the eigenvalues are one (and the number of iterations in such a method is bounded by the number of distinct eigenvalues). Below, we will discuss the choice of an adequate solver for this problem. First, we are going to have a closer look at the implementation of the preconditioner.</p>
<p>Since \(P\) is aimed to be a preconditioner only, we shall use approximations to the inverse of the Schur complement \(S\) and the matrix \(A\). Hence, the Schur complement will be approximated by the pressure mass matrix \(M_p\), and we use a preconditioner to \(A\) (without an InverseMatrix class around it) for approximating \(A^{-1}\).</p>
<p>Here comes the class that implements the block Schur complement preconditioner. The <code>vmult</code> operation for block vectors according to the derivation above can be specified by three successive operations: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>         &amp;S,</div><div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt;  &amp;Mpinv,</div><div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>,</div><div class="line">                       PreconditionerMp &gt; &gt; m_inverse;</div><div class="line">    <span class="keyword">const</span> PreconditionerA &amp;a_preconditioner;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp;</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line">BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::BlockSchurPreconditioner(</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>                            &amp;S,</div><div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt; &amp;Mpinv,</div><div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner</div><div class="line">          )</div><div class="line">                :</div><div class="line">                system_matrix           (&amp;S),</div><div class="line">                m_inverse               (&amp;Mpinv),</div><div class="line">                a_preconditioner        (Apreconditioner),</div><div class="line">                tmp                     (S.block(1,1).m())</div><div class="line">{}</div><div class="line"></div><div class="line">        <span class="comment">// Now the interesting function, the multiplication of</span></div><div class="line">        <span class="comment">// the preconditioner with a BlockVector.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keywordtype">void</span> BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::vmult (</div><div class="line">                                     <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">        <span class="comment">// Form u_new = A^{-1} u</span></div><div class="line">  a_preconditioner.vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">        <span class="comment">// Form tmp = - B u_new + p</span></div><div class="line">        <span class="comment">// (&lt;code&gt;SparseMatrix::residual&lt;/code&gt;</span></div><div class="line">        <span class="comment">// does precisely this)</span></div><div class="line">  system_matrix-&gt;block(1,0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">        <span class="comment">// Change sign in tmp</span></div><div class="line">  tmp *= -1;</div><div class="line">        <span class="comment">// Multiply by approximate Schur complement</span></div><div class="line">        <span class="comment">// (i.e. a pressure mass matrix)</span></div><div class="line">  m_inverse-&gt;vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">}</div></div><!-- fragment --><p>Since we act on the whole block system now, we have to live with one disadvantage: we need to perform the solver iterations on the full block system instead of the smaller pressure space.</p>
<p>Now we turn to the question which solver we should use for the block system. The first observation is that the resulting preconditioned matrix cannot be solved with CG since it is neither positive definite nor symmetric.</p>
<p>The deal.II libraries implement several solvers that are appropriate for the problem at hand. One choice is the solver <a class="el" href="classSolverBicgstab.html">BiCGStab</a>, which was used for the solution of the unsymmetric advection problem in <a class="el" href="step_9.html">step-9</a>. The second option, the one we are going to choose, is <a class="el" href="classSolverGMRES.html">GMRES</a> (generalized minimum residual). Both methods have their pros and cons - there are problems where one of the two candidates clearly outperforms the other, and vice versa. <a href="http://en.wikipedia.org/wiki/GMRES#Comparison_with_other_solvers">Wikipedia</a>'s article on the GMRES method gives a comparative presentation. A more comprehensive and well-founded comparison can be read e.g. in the book by J.W. Demmel (Applied Numerical Linear Algebra, SIAM, 1997, section 6.6.6).</p>
<p>For our specific problem with the ILU preconditioner for \(A\), we certainly need to perform hundreds of iterations on the block system for large problem sizes (we won't beat CG!). Actually, this disfavors GMRES: During the GMRES iterations, a basis of Krylov vectors is successively built up and some operations are performed on these vectors. The more vectors are in this basis, the more operations and memory will be needed. The number of operations scales as \({\cal O}(n + k^2)\) and memory as \({\cal O}(kn)\), where \(k\) is the number of vectors in the Krylov basis and \(n\) the size of the (block) matrix. To not let these demands grow excessively, deal.II limits the size \(k\) of the basis to 30 vectors by default. Then, the basis is rebuilt. This implementation of the GMRES method is called GMRES(k), with default \(k=30\). What we have gained by this restriction, namely a bound on operations and memory requirements, will be compensated by the fact that we use an incomplete basis - this will increase the number of required iterations.</p>
<p>BiCGStab, on the other hand, won't get slower when many iterations are needed (one iteration uses only results from one preceding step and not all the steps as GMRES). Besides the fact the BiCGStab is more expensive per step since two matrix-vector products are needed (compared to one for CG or GMRES), there is one main reason which makes BiCGStab not appropriate for this problem: The preconditioner applies the inverse of the pressure mass matrix by using the InverseMatrix class. Since the application of the inverse matrix to a vector is done only in approximative way (an exact inverse is too expensive), this will also affect the solver. In the case of BiCGStab, the Krylov vectors will not be orthogonal due to that perturbation. While this is uncritical for a small number of steps (up to about 50), it ruins the performance of the solver when these perturbations have grown to a significant magnitude in the coarse of iterations.</p>
<p>We did some experiments with BiCGStab and found it to be faster than GMRES up to refinement cycle 3 (in 3D), but it became very slow for cycles 4 and 5 (even slower than the original Schur complement), so the solver is useless in this situation. Choosing a sharper tolerance for the inverse matrix class (<code>1e-10*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code> instead of <code>1e-6*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code>) made BiCGStab perform well also for cycle 4, but did not change the failure on the very large problems.</p>
<p>GMRES is of course also effected by the approximate inverses, but it is not as sensitive to orthogonality and retains a relatively good performance also for large sizes, see the results below.</p>
<p>With this said, we turn to the realization of the solver call with GMRES with \(k=100\) temporary vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &amp;pressure_mass_matrix</div><div class="line">  = preconditioner_matrix.block(1,1);</div><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> pmass_preconditioner;</div><div class="line">pmass_preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a> (pressure_mass_matrix,</div><div class="line">  <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;,<a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div><div class="line">  m_inverse (pressure_mass_matrix, pmass_preconditioner);</div><div class="line"></div><div class="line">BlockSchurPreconditioner&lt;typename InnerPreconditioner&lt;dim&gt;::type,</div><div class="line">                         <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div><div class="line">  preconditioner (system_matrix, m_inverse, *A_preconditioner);</div><div class="line"></div><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m(),</div><div class="line">                              1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6*system_rhs.l2_norm());</div><div class="line"><a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;BlockVector&lt;double&gt;</a> &gt; vector_memory;</div><div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt;::AdditionalData gmres_data;</div><div class="line">gmres_data.max_n_tmp_vectors = 100;</div><div class="line"></div><div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt; gmres(solver_control, vector_memory,</div><div class="line">                                        gmres_data);</div><div class="line"></div><div class="line">gmres.solve(system_matrix, solution, system_rhs,</div><div class="line">            preconditioner);</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a> (solution);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_step()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; block GMRES iterations&quot;</span>;</div></div><!-- fragment --><p>Obviously, one needs to add the include file <a class="el" href="classSolverGMRES.html">&lt;lac/solver_gmres.h&gt;</a> in order to make this run. We call the solver with a <a class="el" href="classBlockVector.html">BlockVector</a> template in order to enable GMRES to operate on block vectors and matrices. Note also that we need to set the (1,1) block in the system matrix to zero (we saved the pressure mass matrix there which is not part of the problem) after we copied the information to another matrix.</p>
<p>Using the <a class="el" href="classTimer.html">Timer</a> class, we collect some statistics that compare the runtime of the block solver with the one from the problem implementation above. Besides the solution with the two options we also check if the solutions of the two variants are close to each other (i.e. this solver gives indeed the same solution as we had before) and calculate the infinity norm of the vector difference.</p>
<p>Let's first see the results in 2D: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 679 (594+85) [0.00162792 s]</div><div class="line">   Assembling...  [0.00108981 s]</div><div class="line">   Computing preconditioner... [0.0025959 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.00479603s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.00441718 s]</div><div class="line">   l_infinity difference between solution vectors: 5.38258e-07</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 160</div><div class="line">   Number of degrees of freedom: 1683 (1482+201) [0.00345707 s]</div><div class="line">   Assembling...  [0.00237417 s]</div><div class="line">   Computing preconditioner... [0.00605702 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0123992s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.011909 s]</div><div class="line">   l_infinity difference between solution vectors: 1.74658e-05</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 376</div><div class="line">   Number of degrees of freedom: 3813 (3370+443) [0.00729299 s]</div><div class="line">   Assembling...  [0.00529909 s]</div><div class="line">   Computing preconditioner... [0.0167508 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.031672s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.029232 s]</div><div class="line">   l_infinity difference between solution vectors: 7.81569e-06</div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 880</div><div class="line">   Number of degrees of freedom: 8723 (7722+1001) [0.017709 s]</div><div class="line">   Assembling...  [0.0126002 s]</div><div class="line">   Computing preconditioner... [0.0435679 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0971651s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.0992041 s]</div><div class="line">   l_infinity difference between solution vectors: 1.87249e-05</div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2008</div><div class="line">   Number of degrees of freedom: 19383 (17186+2197) [0.039988 s]</div><div class="line">   Assembling...  [0.028281 s]</div><div class="line">   Computing preconditioner... [0.118314 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.252133s ]</div><div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.269125 s]</div><div class="line">   l_infinity difference between solution vectors: 6.38657e-05</div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 4288</div><div class="line">   Number of degrees of freedom: 40855 (36250+4605) [0.0880702 s]</div><div class="line">   Assembling...  [0.0603511 s]</div><div class="line">   Computing preconditioner... [0.278339 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.53846s ]</div><div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.578667 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000173363</div></div><!-- fragment --><p>We see that there is no huge difference in the solution time between the block Schur complement preconditioner solver and the Schur complement itself. The reason is simple: we used a direct solve as preconditioner for \(A\) - so we cannot expect any gain by avoiding the inner iterations. We see that the number of iterations has slightly increased for GMRES, but all in all the two choices are fairly similar.</p>
<p>The picture of course changes in 3D:</p>
<div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 32</div><div class="line">   Number of degrees of freedom: 1356 (1275+81) [0.00845218 s]</div><div class="line">   Assembling...  [0.019372 s]</div><div class="line">   Computing preconditioner... [0.00712395 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 13 outer CG iterations <span class="keywordflow">for</span> p  [0.0320101s ]</div><div class="line">      Block Schur preconditioner: 22 GMRES iterations [0.0048759 s]</div><div class="line">   l_infinity difference between solution vectors: 2.15942e-05</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 144</div><div class="line">   Number of degrees of freedom: 5088 (4827+261) [0.0346942 s]</div><div class="line">   Assembling...  [0.0857739 s]</div><div class="line">   Computing preconditioner... [0.0465031 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [0.349258s ]</div><div class="line">      Block Schur preconditioner: 35 GMRES iterations [0.048759 s]</div><div class="line">   l_infinity difference between solution vectors: 1.77657e-05</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 704</div><div class="line">   Number of degrees of freedom: 22406 (21351+1055) [0.175669 s]</div><div class="line">   Assembling...  [0.437447 s]</div><div class="line">   Computing preconditioner... [0.286435 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [3.65519s ]</div><div class="line">      Block Schur preconditioner: 63 GMRES iterations [0.497787 s]</div><div class="line">   l_infinity difference between solution vectors: 5.08078e-05</div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 3168</div><div class="line">   Number of degrees of freedom: 93176 (89043+4133) [0.790985 s]</div><div class="line">   Assembling...  [1.97598 s]</div><div class="line">   Computing preconditioner... [1.4325 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [29.9666s ]</div><div class="line">      Block Schur preconditioner: 128 GMRES iterations [5.02645 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000119671</div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 11456</div><div class="line">   Number of degrees of freedom: 327808 (313659+14149) [3.44995 s]</div><div class="line">   Assembling...  [7.54772 s]</div><div class="line">   Computing preconditioner... [5.46306 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [139.987s ]</div><div class="line">      Block Schur preconditioner: 255 GMRES iterations [38.0946 s]</div><div class="line">   l_infinity difference between solution vectors: 0.00020793</div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 45056</div><div class="line">   Number of degrees of freedom: 1254464 (1201371+53093) [19.6795 s]</div><div class="line">   Assembling...  [28.6586 s]</div><div class="line">   Computing preconditioner... [22.401 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [796.767s ]</div><div class="line">      Block Schur preconditioner: 524 GMRES iterations [355.597 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000501219</div></div><!-- fragment --><p>Here, the block preconditioned solver is clearly superior to the Schur complement, but the advantage gets less for more mesh points. This is because GMRES(k) scales worse with the problem size than CG, as we discussed above. Nonetheless, the improvement by a factor of 3-6 for moderate problem sizes is quite impressive.</p>
<p><a class="anchor" id="Combiningtheblockpreconditionerandmultigrid"></a></p><h5>Combining the block preconditioner and multigrid</h5>
<p>An ultimate linear solver for this problem could be imagined as a combination of an optimal preconditioner for \(A\) (e.g. multigrid) and the block preconditioner described above, which is the approach taken in the <a class="el" href="step_31.html">step-31</a> and <a class="el" href="step_32.html">step-32</a> tutorial programs (where we use an algebraic multigrid method) and <a class="el" href="step_56.html">step-56</a> (where we use a geometric multigrid method).</p>
<p><a class="anchor" id="Noblockmatricesandvectors"></a></p><h5>No block matrices and vectors</h5>
<p>Another possibility that can be taken into account is to not set up a block system, but rather solve the system of velocity and pressure all at once. The options are direct solve with UMFPACK (2D) or GMRES with ILU preconditioning (3D). It should be straightforward to try that.</p>
<p><a class="anchor" id="Moreinterestingtestcases"></a></p><h4>More interesting testcases</h4>
<p>The program can of course also serve as a basis to compute the flow in more interesting cases. The original motivation to write this program was for it to be a starting point for some geophysical flow problems, such as the movement of magma under places where continental plates drift apart (for example mid-ocean ridges). Of course, in such places, the geometry is more complicated than the examples shown above, but it is not hard to accommodate for that.</p>
<p>For example, by using the following modification of the boundary values function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">BoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x_offset = <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(p[1]*4)/3;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> (p[0] &lt; x_offset ? -1 : (p[0] &gt; x_offset ? 1 : 0));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> and the following way to generate the mesh as the domain \([-2,2]\times[-2,2]\times[-1,0]\) </p><div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; subdivisions (dim, 1);</div><div class="line">subdivisions[0] = 4;</div><div class="line"><span class="keywordflow">if</span> (dim&gt;2)</div><div class="line">  subdivisions[1] = 4;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,-1) :</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,-2,-1));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right   = (dim == 2 ?</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2,0) :</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2,2,0));</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                           subdivisions,</div><div class="line">                                           bottom_left,</div><div class="line">                                           top_right);</div></div><!-- fragment --><p> then we get images where the fault line is curved: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d-extension.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d-grid-extension.png"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2008 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2008</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step22</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (component == 0)</div><div class="line">      <span class="keywordflow">return</span> (p[0] &lt; 0 ? -1 : (p[0] &gt; 0 ? 1 : 0));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                         Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                  <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">    <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">    <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    , preconditioner(&amp;preconditioner)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">    Vector&lt;double&gt; &amp;      dst,</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.size(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * src.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, *preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div><div class="line">      A_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div><div class="line">    : system_matrix(&amp;system_matrix)</div><div class="line">    , A_inverse(&amp;A_inverse)</div><div class="line">    , tmp1(system_matrix.block(0, 0).m())</div><div class="line">    , tmp2(system_matrix.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  SchurComplement&lt;PreconditionerType&gt;::vmult(Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).vmult(tmp1, src);</div><div class="line">    A_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : degree(degree)</div><div class="line">    , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    A_preconditioner.reset();</div><div class="line">    system_matrix.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div><div class="line">    block_component[dim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               1,</div><div class="line">                                               BoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">    }</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div><div class="line"></div><div class="line">      preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      preconditioner_dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                      preconditioner_coupling,</div><div class="line">                                      preconditioner_dsp,</div><div class="line">                                      constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(2);</div><div class="line">    solution.block(0).reinit(n_u);</div><div class="line">    solution.block(1).reinit(n_p);</div><div class="line">    solution.collect_sizes();</div><div class="line"></div><div class="line">    system_rhs.reinit(2);</div><div class="line">    system_rhs.block(0).reinit(n_u);</div><div class="line">    system_rhs.block(1).reinit(n_p);</div><div class="line">    system_rhs.collect_sizes();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix         = 0;</div><div class="line">    system_rhs            = 0;</div><div class="line">    preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix                = 0;</div><div class="line">        local_preconditioner_matrix = 0;</div><div class="line">        local_rhs                   = 0;</div><div class="line"></div><div class="line">        right_hand_side.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                          rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                symgrad_phi_u[k] =</div><div class="line">                  fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                div_phi_u[k] = fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]     = fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) <span class="comment">// (1)</span></div><div class="line">                       - div_phi_u[i] * phi_p[j]                 <span class="comment">// (2)</span></div><div class="line">                       - phi_p[i] * div_phi_u[j])                <span class="comment">// (3)</span></div><div class="line">                      * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);                        <span class="comment">// * dx</span></div><div class="line"></div><div class="line">                    local_preconditioner_matrix(i, j) +=</div><div class="line">                      (phi_p[i] * phi_p[j]) <span class="comment">// (4)</span></div><div class="line">                      * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);   <span class="comment">// * dx</span></div><div class="line">                  }</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                  fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div><div class="line">                                 * rhs_values[q](component_i)) <span class="comment">// * f(x_q))</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);            <span class="comment">// * dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              local_matrix(i, j) = local_matrix(j, i);</div><div class="line">              local_preconditioner_matrix(i, j) =</div><div class="line">                local_preconditioner_matrix(j, i);</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_preconditioner_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               preconditioner_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    A_preconditioner =</div><div class="line">      std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div><div class="line">    A_preconditioner-&gt;initialize(</div><div class="line">      system_matrix.block(0, 0),</div><div class="line">      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                        <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div><div class="line">                   A_inverse(system_matrix.block(0, 0), *A_preconditioner);</div><div class="line">    Vector&lt;double&gt; tmp(solution.block(0).size());</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;double&gt; schur_rhs(solution.block(1).size());</div><div class="line">      A_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line">      SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div><div class="line">        system_matrix, A_inverse);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div><div class="line">                                <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">      InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div><div class="line">        preconditioner_matrix.block(1, 1), preconditioner);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      A_inverse.vmult(solution.block(0), tmp);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell,</div><div class="line">      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(pressure));</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.0);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div><div class="line">      subdivisions[0] = 4;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, -1) :    <span class="comment">// 2d case</span></div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, 0, -1)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 1, 0)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                                subdivisions,</div><div class="line">                                                bottom_left,</div><div class="line">                                                top_right);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;center()[dim - 1] == 0)</div><div class="line">          face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4 - dim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step22</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step22;</div><div class="line"></div><div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a> , <a class="el" href="step_21.html">step-21</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Weakform">Weak form</a><a href="#Weakform">Weak form</a>
        <li><a href="#Boundaryconditions">Boundary conditions</a><a href="#Boundaryconditions">Boundary conditions</a>
        <li><a href="#Discretization">Discretization</a><a href="#Discretization">Discretization</a>
        <li><a href="#Linearsolverandpreconditioningissues">Linear solver and preconditioning issues</a><a href="#Linearsolverandpreconditioningissues">Linear solver and preconditioning issues</a>
      <ul>
        <li><a href="#IsthishowoneshouldsolvetheStokesequations"> Is this how one should solve the Stokes equations? </a><a href="#IsthishowoneshouldsolvetheStokesequations"> Is this how one should solve the Stokes equations? </a>
        <li><a href="#Anoteonthestructureofthelinearsystem"> A note on the structure of the linear system </a><a href="#Anoteonthestructureofthelinearsystem"> A note on the structure of the linear system </a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The testcase</a>
        <li><a href="#Implementation">Implementation</a><a href="#Implementation">Implementation</a>
      <ul>
        <li><a href="#UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions">Using imhomogeneous constraints for implementing Dirichlet boundary conditions</a><a href="#UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions">Using imhomogeneous constraints for implementing Dirichlet boundary conditions</a>
        <li><a href="#UsingAffineConstraintsforincreasingperformance">Using AffineConstraints for increasing performance</a><a href="#UsingAffineConstraintsforincreasingperformance">Using AffineConstraints for increasing performance</a>
        <li><a href="#Performanceoptimizations">Performance optimizations</a><a href="#Performanceoptimizations">Performance optimizations</a>
    </ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Definingtheinnerpreconditionertype">Defining the inner preconditioner type</a><a href="#Definingtheinnerpreconditionertype">Defining the inner preconditioner type</a>
        <li><a href="#ThecodeStokesProblemcodeclasstemplate">The <code>StokesProblem</code> class template</a><a href="#ThecodeStokesProblemcodeclasstemplate">The <code>StokesProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#ThecodeSchurComplementcodeclasstemplate">The <code>SchurComplement</code> class template</a><a href="#ThecodeSchurComplementcodeclasstemplate">The <code>SchurComplement</code> class template</a>
      </ul>
        <li><a href="#StokesProblemclassimplementation">StokesProblem class implementation</a><a href="#StokesProblemclassimplementation">StokesProblem class implementation</a>
      <ul>
        <li><a href="#StokesProblemStokesProblem">StokesProblem::StokesProblem</a><a href="#StokesProblemStokesProblem">StokesProblem::StokesProblem</a>
        <li><a href="#StokesProblemsetup_dofs">StokesProblem::setup_dofs</a><a href="#StokesProblemsetup_dofs">StokesProblem::setup_dofs</a>
        <li><a href="#StokesProblemassemble_system">StokesProblem::assemble_system</a><a href="#StokesProblemassemble_system">StokesProblem::assemble_system</a>
        <li><a href="#StokesProblemsolve">StokesProblem::solve</a><a href="#StokesProblemsolve">StokesProblem::solve</a>
        <li><a href="#StokesProblemoutput_results">StokesProblem::output_results</a><a href="#StokesProblemoutput_results">StokesProblem::output_results</a>
        <li><a href="#StokesProblemrefine_mesh">StokesProblem::refine_mesh</a><a href="#StokesProblemrefine_mesh">StokesProblem::refine_mesh</a>
        <li><a href="#StokesProblemrun">StokesProblem::run</a><a href="#StokesProblemrun">StokesProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Outputoftheprogramandgraphicalvisualization">Output of the program and graphical visualization</a><a href="#Outputoftheprogramandgraphicalvisualization">Output of the program and graphical visualization</a>
      <ul>
        <li><a href="#2Dcalculations">2D calculations</a><a href="#2Dcalculations">2D calculations</a>
        <li><a href="#3Dcalculations">3D calculations</a><a href="#3Dcalculations">3D calculations</a>
      </ul>
        <li><a href="#Sparsitypattern">Sparsity pattern</a><a href="#Sparsitypattern">Sparsity pattern</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Improvedlinearsolverin3D">Improved linear solver in 3D</a><a href="#Improvedlinearsolverin3D">Improved linear solver in 3D</a>
      <ul>
        <li><a href="#BetterILUdecompositionbysmartreordering">Better ILU decomposition by smart reordering</a><a href="#BetterILUdecompositionbysmartreordering">Better ILU decomposition by smart reordering</a>
        <li><a href="#BetterpreconditionerfortheinnerCGsolver">Better preconditioner for the inner CG solver</a><a href="#BetterpreconditionerfortheinnerCGsolver">Better preconditioner for the inner CG solver</a>
        <li><a href="#BlockSchurcomplementpreconditioner">Block Schur complement preconditioner</a><a href="#BlockSchurcomplementpreconditioner">Block Schur complement preconditioner</a>
        <li><a href="#Combiningtheblockpreconditionerandmultigrid">Combining the block preconditioner and multigrid</a><a href="#Combiningtheblockpreconditionerandmultigrid">Combining the block preconditioner and multigrid</a>
        <li><a href="#Noblockmatricesandvectors">No block matrices and vectors</a><a href="#Noblockmatricesandvectors">No block matrices and vectors</a>
      </ul>
        <li><a href="#Moreinterestingtestcases">More interesting testcases</a><a href="#Moreinterestingtestcases">More interesting testcases</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em>This program was contributed by Martin Kronbichler and Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The California Institute of Technology. </em></p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program deals with the Stokes system of equations which reads asfollows in non-dimensionalized form: </p><p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; \textbf{f}, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> where \(\textbf u\) denotes the velocity of a fluid, \(p\) is itspressure, \(\textbf f\) are external forces, and \(\varepsilon(\textbf{u})= \nabla^s{\textbf{u}}= \frac 12 \left[ (\nabla \textbf{u}) + (\nabla \textbf{u})^T\right]\) is therank-2 tensor of symmetrized gradients; a component-wise definitionof it is \(\varepsilon(\textbf{u})_{ij}=\frac 12\left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}\right)\) . The Stokes equations describe the steady-state motion of aslow-moving, viscous fluid such as honey, rocks in the earth mantle,or other cases where inertia does not play a significant role. If afluid is moving fast enough that inertia forces are significantcompared to viscous friction, the Stokes equations are no longervalid; taking into account inertia effects then leads to thenonlinear Navier-Stokes equations. However, in this tutorial program,we will focus on the simpler Stokes system. Note that when deriving the more general compressible Navier-Stokes equations,the diffusion is modeled as the divergence of the stress tensor </p><p class="formulaDsp">
\begin{eqnarray*} \tau = - \mu (2\varepsilon(\textbf{u}) - \frac{2}{3}\nabla \cdot \textbf{u} I), \end{eqnarray*}
</p>
<p> where \(\mu\) is the viscosity of the fluid. With the assumption of \(\mu=1\) (assume constant viscosity and non-dimensionalize the equation by dividing out \(\mu\) ) and assuming incompressibility ( \(\textrm{div}\; \textbf{u}=0\) ), wearrive at the formulation from above: </p><p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}). \end{eqnarray*}
</p>
<p> A different formulation uses the Laplace operator ( \(-\triangle \textbf{u}\) )instead of the symmetrized gradient. A big difference here is that thedifferent components of the velocity do not couple. If you assume additionalregularity of the solution \(\textbf{u}\) (second partial derivatives exist andare continuous), the formulations are equivalent: </p><p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}) = -\triangle \textbf{u} + \nabla \cdot (\nabla\textbf{u})^T = -\triangle \textbf{u}. \end{eqnarray*}
</p>
<p> This is because the \(i\) th entry of \(\nabla \cdot (\nabla\textbf{u})^T\) is given by: </p><p class="formulaDsp">
\begin{eqnarray*} [\nabla \cdot (\nabla\textbf{u})^T]_i = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})^T]_{i,j} = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})]_{j,i} = \sum_j \frac{\partial}{\partial x_j} \frac{\partial}{\partial x_i} \textbf{u}_j = \sum_j \frac{\partial}{\partial x_i} \frac{\partial}{\partial x_j} \textbf{u}_j = \frac{\partial}{\partial x_i} \textrm{div}\; \textbf{u} = 0. \end{eqnarray*}
</p>
<p> If you can not assume the above mentioned regularity, or if your viscosity isnot a constant, the equivalence no longer holds. Therefore, we decided tostick with the more physically accurate symmetric tensor formulation in thistutorial.</p>
<p>To be well-posed, we will have to add boundary conditions to theequations. What boundary conditions are readily possible here willbecome clear once we discuss the weak form of the equations. The equations covered here fall into the class of vector-valued problems. Atoplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Weakform"></a></p><h3>Weak form</h3>
<p>The weak form of the equations is obtained by writing it in vectorform as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p} \\ {-\textrm{div}\; \textbf{u}} \end{pmatrix} = \begin{pmatrix} {\textbf{f}} \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued testfunction \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) and integratingover the domain \(\Omega\) , yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) . A generally good rule of thumb is that if one <em>can</em> reduce howmany derivatives are taken on any variable in the formulation, thenone <em>should</em> in fact do that using integration by parts. (This ismotivated by the theory of <a href="https://en.wikipedia.org/wiki/Partial_differential_equation">partial differential equations</a>, and in particular the difference betweenstrong and <a href="https://en.wikipedia.org/wiki/Weak_solution">weak solutions</a>.) We have already done that for the Laplace equation,where we have integrated the second derivative by parts to obtain theweak formulation that has only one derivative on both test and trialfunction. In the current context, we integrate by parts the second term: </p><p class="formulaDsp">
\begin{eqnarray*} (\textbf{v}, -2\; \textrm{div}\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega. \end{eqnarray*}
</p>
<p> Likewise, we integrate by parts the first term to obtain </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> where the scalar product between two tensor-valued quantities is heredefined as </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} = 2 \int_\Omega \sum_{i,j=1}^d \frac{\partial v_j}{\partial x_i} \varepsilon(\textbf{u})_{ij} \ dx. \end{eqnarray*}
</p>
<p> Using this, we have now reduced the requirements on our variables tofirst derivatives for \(\mathbf u,\mathbf v\) and no derivatives at allfor \(p,q\) . Because the scalar product between a general tensor like \(\nabla\textbf{v}\) and a symmetric tensor like \(\varepsilon(\textbf{u})\) equals the scalar product between thesymmetrized forms of the two, we can also write the bilinear formabove as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> We will deal with the boundary terms in the next section, but it is alreadyclear from the domain terms </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} \end{eqnarray*}
</p>
<p> of the bilinear form that the Stokes equations yield a symmetric bilinearform, and consequently a symmetric (if indefinite) system matrix.</p>
<p><a class="anchor" id="Boundaryconditions"></a></p><h3>Boundary conditions</h3>
<pre class="fragment">@note The material presented here is also discussed in &lt;a href="http://www.math.colostate.edu/~bangerth/videos.676.21.5.html"&gt;video lecture 21.5&lt;/a&gt;. (All video lectures are also available &lt;a href="http://www.math.colostate.edu/~bangerth/videos.html"&gt;here&lt;/a&gt;.)  (  See also &lt;a href="http://www.math.colostate.edu/~bangerth/videos.676.21.55.html"&gt;video lecture 21.55&lt;/a&gt;, &lt;a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html"&gt;video lecture 21.6&lt;/a&gt;, &lt;a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html"&gt;video lecture 21.65&lt;/a&gt;.)  
</pre><p> The weak form just derived immediately presents us with differentpossibilities for imposing boundary conditions: </p><ol>
<li>
Dirichlet velocity boundary conditions: On a part \(\Gamma_D\subset\partial\Omega\) we may impose Dirichlet conditions on the velocity \(\textbf u\) : <p class="formulaDsp">
\begin{eqnarray*} \textbf u = \textbf g_D \qquad\qquad \textrm{on}\ \Gamma_D. \end{eqnarray*}
</p>
 Because test functions \(\textbf{v}\) come from the tangent space of the solution variable, we have that \(\textbf{v}=0\) on \(\Gamma_D\) and consequently that <p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_D} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_D} = 0. \end{eqnarray*}
</p>
 In other words, as usual, strongly imposed boundary values do not appear in the weak form. It is noteworthy that if we impose Dirichlet boundary values on the entire boundary, then the pressure is only determined up to a constant. An algorithmic realization of that would use similar tools as have been seen in <a class="el" href="step_11.html">step-11</a> . </li>
<li>
<p class="startli">Neumann-type or natural boundary conditions: On the rest of the boundary \(\Gamma_N=\partial\Omega\backslash\Gamma_D\) , let us re-write the boundary terms as follows: </p><p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_N} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_N} &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i=1}^d (n_i v_i, p)_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i,j=1}^d (n_i v_j, p \delta_{ij})_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d (n_i v_j,p \delta_{ij} - 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} \\ &amp;=&amp; (\textbf{n} \otimes \textbf{v}, p \textbf{I} - 2\; \varepsilon(\textbf{u}))_{\Gamma_N}. \\ &amp;=&amp; (\textbf{v}, \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})])_{\Gamma_N}. \end{eqnarray*}
</p>
<p> In other words, on the Neumann part of the boundary we can prescribe values for the total stress: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] = \textbf g_N \qquad\qquad \textrm{on}\ \Gamma_N. \end{eqnarray*}
</p>
<p> If the boundary is subdivided into Dirichlet and Neumann parts \(\Gamma_D,\Gamma_N\) , this then leads to the following weak form: </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N}. \end{eqnarray*}
</p>
<pre class="fragment">&lt;li&gt;  Robin-type boundary conditions: Robin boundary conditions are a mixture of    Dirichlet and Neumann boundary conditions. They would read \form#2962@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl
  with a rank-2 tensor (matrix) \form#2963  . The associated weak form is \form#2964@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl

&lt;li&gt;  Partial boundary conditions: It is possible to combine Dirichlet and    Neumann boundary conditions by only enforcing each of them for certain    components of the velocity. For example, one way to impose artificial    boundary conditions is to require that the flow is perpendicular to the    boundary, i.e. the tangential component \form#2965@_fakenl   be zero, thereby constraining      &lt;code&gt;dim&lt;/code&gt;  -1 components of the velocity. The remaining component can    be constrained by requiring that the normal component of the normal    stress be zero, yielding the following set of boundary conditions: \form#2966@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl

  An alternative to this is when one wants the flow to be &lt;i&gt;parallel&lt;/i&gt;    rather than perpendicular to the boundary (in deal.II, the      VectorTools::compute_no_normal_flux_constraints   function can do this for    you). This is frequently the case for problems with a free boundary    (e.g. at the surface of a river or lake if vertical forces of the flow are    not large enough to actually deform the surface), or if no significant    friction is exerted by the boundary on the fluid (e.g. at the interface    between earth mantle and earth core where two fluids meet that are    stratified by different densities but that both have small enough    viscosities to not introduce much tangential stress on each other).    In formulas, this means that \form#2967@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl
  the first condition (which needs to be imposed strongly) fixing a single    component of the velocity, with the second (which would be enforced in the    weak form) fixing the remaining two components.  &lt;/ol&gt;  
</pre><p> Despite this wealth of possibilities, we will only use Dirichlet and(homogeneous) Neumann boundary conditions in this tutorial program.</p>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p></p>
<p>As developed above, the weak form of the equations with Dirichlet and Neumannboundary conditions on \(\Gamma_D\) and \(\Gamma_N\) reads like this: find \(\textbf u\in \textbf V_g = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=\textbf g_D\}, p\in Q=L^2(\Omega)\) so that </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p> for all test functions \(\textbf{v}\in \textbf V_0 = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=0\},q\in Q\) . These equations represent a symmetric <a href="https://en.wikipedia.org/wiki/Ladyzhenskaya%E2%80%93Babu%C5%A1ka%E2%80%93Brezzi_condition">saddle point problem</a>. It is well knownthat then a solution only exists if the function spaces in which we search fora solution have to satisfy certain conditions, typically referred to as theBabuska-Brezzi or Ladyzhenskaya-Babuska-Brezzi (LBB) conditions. The continuousfunction spaces above satisfy these. However, when we discretize the equations byreplacing the continuous variables and test functions by finite elementfunctions in finite dimensional spaces \(\textbf V_{g,h}\subset \textbf V_g, Q_h\subset Q\) , we have to make sure that \(\textbf V_h,Q_h\) also satisfy the LBBconditions. This is similar to what we had to do in <a class="el" href="step_20.html">step-20</a> . For the Stokes equations, there are a number of possible choices to ensurethat the finite element spaces are compatible with the LBB condition. A simpleand accurate choice that we will use here is \(\textbf u_h\in Q_{p+1}^d, p_h\in Q_p\) , i.e. use elements one order higher for the velocities than for thepressures. This then leads to the following discrete problem: find \(\textbf u_h,p_h\) sothat </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}_h), 2\; \varepsilon(\textbf u_h))_{\Omega} - (\textrm{div}\; \textbf{v}_h, p_h)_{\Omega} - (q_h,\textrm{div}\; \textbf{u}_h)_{\Omega} = (\textbf{v}_h, \textbf{f})_\Omega - (\textbf{v}_h, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p> for all test functions \(\textbf{v}_h, q_h\) . Assembling the linear systemassociated with this problem follows the same lines used in <a class="el" href="step_20.html">step_20 </a>step-20"  ", <a class="el" href="step_21.html">step-21</a> , and explained in detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Linearsolverandpreconditioningissues"></a></p><h3>Linear solver and preconditioning issues</h3>
<p></p>
<p>The weak form of the discrete equations naturally leads to the followinglinear system for the nodal values of the velocity and pressure fields: </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> Like in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a> , we will solve thissystem of equations by forming the Schur complement, i.e. we will first findthe solution \(P\) of </p><p class="formulaDsp">
\begin{eqnarray*} BA^{-1}B^T P &amp;=&amp; BA^{-1} F - G, \\ \end{eqnarray*}
</p>
<p> and then </p><p class="formulaDsp">
\begin{eqnarray*} AU &amp;=&amp; F - B^TP. \end{eqnarray*}
</p>
<p> The way we do this is pretty much exactly like we did in these previoustutorial programs, i.e. we use the same classes <code>SchurComplement</code> and <code>InverseMatrix</code> again. There are two significant differences,however: </p><ol>
<li>
First, in the mixed Laplace equation we had to deal with the question of howto precondition the Schur complement \(B^TM^{-1}B\) , which was spectrallyequivalent to the Laplace operator on the pressure space (because \(B\) represents the gradient operator, \(B^T\) its adjoint \(-\textrm{div}\) , and \(M\) the identity (up to the material parameter \(K^{-1}\) ), so \(B^TM^{-1}B\) issomething like \(-\textrm{div} \mathbf 1 \nabla = -\Delta\) ). Consequently, thematrix is badly conditioned for small mesh sizes and we had to come up with anelaborate preconditioning scheme for the Schur complement. </li>
<li>
Second, every time we multiplied with \(B^TM^{-1}B\) we had to solve with themass matrix \(M\) . This wasn't particularly difficult, however, since the massmatrix is always well conditioned and so simple to invert using CG and alittle bit of preconditioning. </li>
</ol>
<p>In other words, preconditioning the inner solver for \(M\) was simple whereaspreconditioning the outer solver for \(B^TM^{-1}B\) was complicated. Here, the situation is pretty much exactly the opposite. The difference stemsfrom the fact that the matrix at the heart of the Schur complement does notstem from the identity operator but from a variant of the Laplace operator, \(-\textrm{div} \nabla^s\) (where \(\nabla^s\) is the symmetric gradient)acting on a vector field. In the investigation of this issuewe largely follow the paper D. Silvester and A. Wathen:"Fast iterative solution of stabilised Stokes systems part II. Usinggeneral block preconditioners." (SIAM J. Numer. Anal., 31 (1994),pp. 1352-1367), which is available online <a href="http://siamdl.aip.org/getabs/servlet/GetabsServlet?prog=normal&amp;id=SJNAAM000031000005001352000001&amp;idtype=cvips&amp;gifs=Yes" target="_top">here</a>.Principally, the difference in the matrix at the heart of the Schurcomplement has two consequences: </p><ol>
<li>
<p class="startli">First, it makes the outer preconditioner simple: the Schur complementcorresponds to the operator \(-\textrm{div} (-\textrm{div} \nabla^s)^{-1} \nabla\) on the pressure space; forgetting about the fact that we deal withsymmetric gradients instead of the regular one, the Schur complement issomething like \(-\textrm{div} (-\textrm{div} \nabla)^{-1} \nabla = -\textrm{div} (-\Delta)^{-1} \nabla\) , which, even if not mathematicallyentirely concise, is spectrally equivalent to the identity operator (aheuristic argument would be to commute the operators into \(-\textrm{div}(-\Delta)^{-1} \nabla = -\textrm{div}\nabla(-\Delta)^{-1} = -\Delta(-\Delta)^{-1} = \mathbf 1\) ). It turns out that it isn't easy to solvethis Schur complement in a straightforward way with the CG method:using no preconditioner, the condition number of the Schur complement matrixdepends on the size ratios of the largest to the smallest cells, and one stillneeds on the order of 50-100 CG iterations. However, there is a simple cure:precondition with the mass matrix on the pressure space and we get down to anumber between 5-15 CG iterations, pretty much independently of the structureof the mesh (take a look at the <a href="#Results">results section</a> of thisprogram to see that indeed the number of CG iterations does not change as werefine the mesh). So all we need in addition to what we already have is the mass matrix on thepressure variables and we will store it in a separate object.</p>
<pre class="fragment">&lt;li&gt;  While the outer preconditioner has become simpler compared to themixed Laplace case discussed in   @ref step_20 "step-20"  , the issue ofthe inner solver has become more complicated. In the mixed Laplacediscretization, the Schur complement has the form \form#292  . Thus,every time we multiplied with the Schur complement, we had to solve alinear system \form#2988  ; this isn't too complicated there, however,since the mass matrix \form#2989   on the pressure space is well-conditioned.
</pre><p class="endli">On the other hand, for the Stokes equation we consider here, the Schurcomplement is \(BA^{-1}B^T\) where the matrix \(A\) is related to theLaplace operator (it is, in fact, the matrix corresponding to thebilinear form \((\nabla^s \varphi_i, \nabla^s\varphi_j)\) ). Thus,solving with \(A\) is a lot more complicated: the matrix is badlyconditioned and we know that we need many iterations unless we have avery good preconditioner. What is worse, we have to solve with \(A\) every time we multiply with the Schur complement, which is 5-15 timesusing the preconditioner described above. Because we have to solve with \(A\) several times, it pays off to spenda bit more time once to create a good preconditioner for thismatrix. So here's what we're going to do: if in 2d, we use theultimate preconditioner, namely a direct sparse LU decomposition ofthe matrix. This is implemented using the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> classthat uses the UMFPACK direct solver to compute the decomposition. Touse it, you will have to build deal.II with UMFPACK support (which is thedefault); see the <a href="../../readme.html#optional-software">ReadMe file</a>for instructions. With this, the inner solver converges in one iteration. In 2d, we can do this sort of thing because even reasonably large problemsrarely have more than a few 100,000 unknowns with relatively few nonzeroentries per row. Furthermore, the bandwidth of matrices in 2d is \({\cal O}(\sqrt{N})\) and therefore moderate. For such matrices, sparse factors can becomputed in a matter of a few seconds. (As a point of reference, computing thesparse factors of a matrix of size \(N\) and bandwidth \(B\) takes \({\cal O}(NB^2)\) operations. In 2d, this is \({\cal O}(N^2)\) ; though this is a highercomplexity than, for example, assembling the linear system which takes \({\cal O}(N)\) , the constant for computing the decomposition is so small that itdoesn't become the dominating factor in the entire program until we get tovery large numbers of unknowns in the high 100,000s or more.) The situation changes in 3d, because there we quickly have many moreunknowns and the bandwidth of matrices (which determines the number ofnonzero entries in sparse LU factors) is \({\cal O}(N^{2/3})\) , and thereare many more entries per row as well. This makes using a sparsedirect solver such as UMFPACK inefficient: only for problem sizes of afew 10,000 to maybe 100,000 unknowns can a sparse decomposition becomputed using reasonable time and memory resources. What we do in that case is to use an incomplete LU decomposition (ILU) as apreconditioner, rather than actually computing complete LU factors. As it sohappens, deal.II has a class that does this: <a class="el" href="classSparseILU.html">SparseILU</a>. Computing the ILUtakes a time that only depends on the number of nonzero entries in the sparsematrix (or that we are willing to fill in the LU factors, if these should bemore than the ones in the matrix), but is independent of the bandwidth of thematrix. It is therefore an operation that can efficiently also be computed in3d. On the other hand, an incomplete LU decomposition, by definition, does notrepresent an exact inverse of the matrix \(A\) . Consequently, preconditioningwith the ILU will still require more than one iteration, unlikepreconditioning with the sparse direct solver. The inner solver will thereforetake more time when multiplying with the Schur complement: an unavoidabletrade-off. </p>
</li>
</ol>
<p>In the program below, we will make use of the fact that the <a class="el" href="classSparseILU.html">SparseILU</a> andSparseDirectUMFPACK classes have a very similar interface and can be usedinterchangeably. All that we need is a switch class that, depending on thedimension, provides a type that is either of the two classes mentionedabove. This is how we do that: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">};</div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">};</div></div><!-- fragment --><p>From here on, we can refer to the type <code>typename InnerPreconditioner&lt;dim&gt;::type</code> and automatically get the correctpreconditioner class. Because of the similarity of the interfaces of the twoclasses, we will be able to use them interchangeably using the same syntax inall places.</p>
<p><a class="anchor" id="IsthishowoneshouldsolvetheStokesequations"></a></p><h4>Is this how one should solve the Stokes equations? </h4>
<p></p>
<p>The discussions above showedone* way in which the linear system thatresults from the Stokes equations can be solved, and because thetutorial programs are teaching tools that makes sense. But is this theway this system of equationsshould* be solved? The answer to this is no. The primary bottleneck with the approach,already identified above, is that we have to repeatedly solve linearsystems with \(A\) inside the Schur complement, and because we don'thave a good preconditioner for the Schur complement, these solves justhave to happen too often. A better approach is to use a blockdecomposition, which is based on an observation of Silvester andWathen <b>[SW94]</b> and explained in much greater detail in <b>[elman2005]</b> . An implementation of this alternative approach isdiscussed below, in the section on a <a href="#block-schur">block Schur complementation preconditioner</a> in the results section of this program.</p>
<p><a class="anchor" id="Anoteonthestructureofthelinearsystem"></a></p><h4>A note on the structure of the linear system </h4>
<p></p>
<p>Above, we have claimed that the linear system has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> i.e., in particular that there is a zero block at the bottom right of thematrix. This then allowed us to write the Schur complement as \(S=B A^{-1} B^T\) . But this is not quite correct. Think of what would happen if there are constraints on somepressure variables (see the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> documentationmodule), for example because we use adaptivelyrefined meshes and continuous pressure finite elements so that thereare hanging nodes. Another cause for such constraints are Dirichletboundary conditions on the pressure. Then the AffineConstraintsclass, upon copying the local contributions to the matrix into theglobal linear system will zero out rows and columns correspondingto constrained degrees of freedom and put a positive entry onthe diagonal. (You can think of this entry as being one forsimplicity, though in reality it is a value of the same orderof magnitude as the other matrix entries.) In other words,the bottom right block is really not empty at all: It hasa few entries on the diagonal, one for each constrainedpressure degree of freedom, and a correct descriptionof the linear system we have to solve is that it has theform </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; D_c \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> where \(D_c\) is the zero matrix with the exception of thepositive diagonal entries for the constrained degrees offreedom. The correct Schur complement would then in factbe the matrix \(S = B A^{-1} B^T - D_c \) instead of the onestated above. Thinking about this makes us, first, realize that theresulting Schur complement is now indefinite because \(B A^{-1} B^T\) is symmetric and positive definite whereas \(D_c\) is a positive semidefinite, and subtracting the latterfrom the former may no longer be positive definite. Thisis annoying because we could no longer employ the ConjugateGradient method on this true Schur complement. That said, we couldfix the issue in <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> bysimply puttingnegative* values onto the diagonal for the constrainedpressure variables</p>
<ul>
<li>because we really only put something nonzeroto ensure that the resulting matrix is not singular; we really didn'tcare whether that entry is positive or negative. So if the entrieson the diagonal of \(D_c\) were negative, then \(S\) would again be asymmetric and positive definite matrix. But, secondly, the code below doesn't actually do any of that: Ithappily solves the linear system with the wrong Schur complement \(S = B A^{-1} B^T\) that just ignores the issue altogether. Whydoes this even work? To understand why this is so, recall thatwhen writing local contributions into the global matrix, <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> zeros out therows and columns that correspond to constrained degrees of freedom.This means that \(B\) has some zero rows, and \(B^T\) zero columns.As a consequence, if one were to multiply out what the entriesof \(S\) are, one would realize that it has zero rows and columnsfor all constrained pressure degrees of freedom, including azero on the diagonal. The nonzero entries of \(D_c\) would fitinto exactly those zero diagonal locations, and ensure that \(S\) is invertible. Not doing so, strictly speaking, means that \(S\) remains singular: It is symmetric and positive definite on thesubset of non-constrained pressure degrees of freedom, andsimply the zero matrix on the constrained pressures. Whydoes the Conjugate Gradient method work for this matrix?Because <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> also makes sure that the right hand side entries thatcorrespond to these zero rows of the matrix arealso* zero, i.e., the right hand side is compatible. What this means is that whatever the values of the solutionvector for these constrained pressure degrees of freedom,these rows will always have a zero residual and, if onewere to consider what the CG algorithm does internally, justnever produce any updates to the solution vector. In otherwords, the CG algorithm justignores* these rows, despite thefact that the matrix is singular. This only works because thesedegrees of freedom are entirely decoupled from the rest of thelinear system (because the entire row and corresponding columnare zero). At the end of the solution process, the constrainedpressure values in the solution vector therefore remain exactlyas they were when we started the call to the solver; they arefinally overwritten with their correct values when we call <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> after the CG solver is done. The upshot of this discussion is that the assumption that thebottom right block of the big matrix is zero is a bitsimplified, but that just going with it does not actually leadto any practical problems worth addressing.</li>
</ul>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p></p>
<p>The domain, right hand side and boundary conditions we implement below relateto a problem in geophysics: there, one wants to compute the flow field ofmagma in the earth's interior under a mid-ocean rift. Rifts are places wheretwo continental plates are very slowly drifting apart (a few centimeters peryear at most), leaving a crack in the earth crust that is filled with magmafrom below. Without trying to be entirely realistic, we model this situationby solving the following set of equations and boundary conditions on thedomain \(\Omega=[-2,2]\times[0,1]\times[-1,0]\) : </p><p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; 0, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} -1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&lt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} +1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&gt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} 0 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x=0, \end{eqnarray*}
</p>
<p> and using natural boundary conditions \(\textbf{n}\cdot [p \textbf{I} - 2 \varepsilon(\textbf{u})] = 0\) everywhere else. In other words, at theleft part of the top surface we prescribe that the fluid moves with thecontinental plate to the left at speed \(-1\) , that it moves to the right on theright part of the top surface, and impose natural flow conditions everywhereelse. If we are in 2d, the description is essentially the same, with theexception that we omit the second component of all vectors stated above. As will become apparent in the <a href="#Results">results section</a>, theflow field will pull material from below and move it to the left and rightends of the domain, as expected. The discontinuity of velocity boundaryconditions will produce a singularity in the pressure at the center of the topsurface that sucks material all the way to the top surface to fill the gapleft by the outward motion of material at this location.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p></p>
<p><a class="anchor" id="UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions"></a></p><h4>Using imhomogeneous constraints for implementing Dirichlet boundary conditions</h4>
<p></p>
<p>In all the previous tutorial programs, we used the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object merelyfor handling hanging node constraints (with exception of <a class="el" href="step_11.html">step-11</a> ). However,the class can also be used to implement Dirichlet boundary conditions, as wewill show in this program, by fixing some node values \(x_i = b_i\) . Note thatthese are inhomogeneous constraints, and we have to pay some specialattention to that. The way we are going to implement this is to first readin the boundary values into the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object by using the call </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          1,</div><div class="line">                                          BoundaryValues&lt;dim&gt;(),</div><div class="line">                                          constraints);</div></div><!-- fragment --><p>very similar to how we were making the list of boundary nodesbefore (note that we set Dirichlet conditions only on boundaries withboundary flag 1). The actual application of the boundary values is thenhandled by the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object directly, without any additionalinterference. We could then proceed as before, namely by filling the matrix, and thencalling a condense function on the constraints object of the form </p><div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (system_matrix, system_rhs);</div></div><!-- fragment --><p>Note that we call this on the system matrix and system right hand sidesimultaneously, since resolving inhomogeneous constraints requires knowledgeabout both the matrix entries and the right hand side. For efficiencyreasons, though, we choose another strategy: all the constraints collectedin the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object can be resolved on the fly while writing local datainto the global matrix, by using the call </p><div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a> (local_matrix, local_rhs,</div><div class="line">                                        local_dof_indices,</div><div class="line">                                        system_matrix, system_rhs);</div></div><!-- fragment --><p>This technique is further discussed in the <a class="el" href="step_27.html">step-27</a> tutorialprogram. All we need to know here is that this functions does three thingsat once: it writes the local data into the global matrix and right handside, it distributes the hanging node constraints and additionallyimplements (inhomogeneous) Dirichlet boundary conditions. That's nice, isn'tit? We can conclude that the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class provides an alternative to using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> for implementing Dirichlet boundaryconditions.</p>
<p><a class="anchor" id="constraint-matrix"></a> <a class="anchor" id="UsingAffineConstraintsforincreasingperformance"></a><a class="anchor" id="UsingAffineConstraintsforincreasingperformance"></a></p><h4>Using <a class="el" href="classAffineConstraints.html">AffineConstraints</a> for increasing performance</h4>
<h4>Using <a class="el" href="classAffineConstraints.html">AffineConstraints</a> for increasing performance</h4>
<p></p>
<p>Frequently, a sparse matrix contains a substantial amount of elements thatactually are zero when we are about to start a linear solve. Such elements areintroduced when we eliminate constraints or implement Dirichlet conditions,where we usually delete all entries in constrained rows and columns, i.e., weset them to zero. The fraction of elements that are present in the sparsitypattern, but do not really contain any information, can be up to one fourthof the total number of elements in the matrix for the 3D applicationconsidered in this tutorial program. Remember that matrix-vector products orpreconditioners operate on all the elements of a sparse matrix (even thosethat are zero), which is an inefficiency we will avoid here. An advantage of directly resolving constrained degrees of freedom is that wecan avoid having most of the entries that are going to be zero in our sparsematrix &mdash; we do not need constrained entries during matrix construction(as opposed to the traditional algorithms, which first fill the matrix, andonly resolve constraints afterwards). This will save both memory and timewhen forming matrix-vector products. The way we are going to do that is topass the information about constraints to the function that generates thesparsity pattern, and then set a <code>false</code> argument specifying that wedo not intend to use constrained entries: </p><div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern,</div><div class="line">                                 constraints, <span class="keyword">false</span>);</div></div><!-- fragment --><p> This functions obviates, by the way, also the call to the<code>condense()</code> function on the sparsity pattern.</p>
<p><a class="anchor" id="Performanceoptimizations"></a></p><h4>Performance optimizations</h4>
<p></p>
<p>The program developed below has seen a lot of TLC. We have run it over andover under profiling tools (mainly <a href="http://www.valgrind.org/">valgrind</a>'s cachegrind and callgrindtools, as well as the KDE <a href="http://kcachegrind.sourceforge.net/">KCachegrind</a> program forvisualization) to see where the bottlenecks are. This has paid off: throughthis effort, the program has become about four times as fast whenconsidering the runtime of the refinement cycles zero through three,reducing the overall number of CPU instructions executed from869,574,060,348 to 199,853,005,625. For higher refinement levels, the gainis probably even larger since some algorithms that are not \({\cal O}(N)\) have been eliminated. Essentially, there are currently two algorithms in the program that do notscale linearly with the number of degrees of freedom: renumbering of degreesof freedom (which is \({\cal O}(N \log N)\) , and the linear solver (which is \({\cal O}(N^{4/3})\) ). As for the first, while reordering degrees of freedommay not scale linearly, it is an indispensable part of the overall algorithmas it greatly improves the quality of the sparse ILU, easily making up forthe time spent on computing the renumbering; graphs and timings todemonstrate this are shown in the documentation of the DoFRenumberingnamespace, also underlining the choice of the Cuthill-McKee reorderingalgorithm chosen below. As for the linear solver: as mentioned above, our implementation here uses aSchur complement formulation. This is not necessarily the very best choicebut demonstrates various important techniques available in deal.II. Thequestion of which solver is best is again discussed in the <a href="#improved-solver">section on improved solvers in the results part</a>of this program, along with code showing alternative solvers and acomparison of their results. Apart from this, many other algorithms have been tested and improved duringthe creation of this program. For example, in building the sparsity pattern,we originally used a (now no longer existing) BlockCompressedSparsityPatternobject that added one element at a time; however, its data structures were poorlyadapted for the large numbers of nonzero entries per row created by ourdiscretization in 3d, leading to a quadratic behavior. Replacing the internalalgorithms in deal.II to set many elements at a time, and using aBlockCompressedSimpleSparsityPattern (which has, as of early 2015, been in turnreplaced by <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>) as a better adapted data structure,removed this bottleneck at the price of a slightly higher memoryconsumption. Likewise, the implementation of the decomposition step in theSparseILU class was very inefficient and has been replaced by one that isabout 10 times faster. Even the vmult function of the <a class="el" href="classSparseILU.html">SparseILU</a> has beenimproved to save about twenty percent of time. Small improvements wereapplied here and there. Moreover, the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object has been usedto eliminate a lot of entries in the sparse matrix that are eventually goingto be zero, see <a href="#constraint-matrix">the section on using advanced features of the AffineConstraints class</a>. A profile of how many CPU instructions are spent at the variousdifferent places in the program during refinement cycleszero through three in 3d is shown here: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.png"/>
</div>
<p> As can be seen, at this refinement level approximately three quarters of theinstruction count is spent on the actual solver (the <a class="el" href="classSparseILU.html#aa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> callson the left, the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult</a> call in the middle for the Schurcomplement solve, and another box representing the multiplications withSparseILU and <a class="el" href="classSparseMatrix.html">SparseMatrix</a> in the solve for <em>U</em>). About one fifth ofthe instruction count is spent on matrix assembly and sparse ILU computation(box in the lower right corner) and the rest on other things. Since floatingpoint operations such as in the <a class="el" href="classSparseILU.html#aa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> calls typically take muchlonger than many of the logical operations and table lookups in matrixassembly, the fraction of the run time taken up by matrix assembly isactually significantly less than the fraction of instructions, as willbecome apparent in the comparison we make in the results section. For higher refinement levels, the boxes representing the solver as well asthe blue box at the top right stemming from reordering algorithm are goingto grow at the expense of the other parts of the program, since they don'tscale linearly. The fact that at this moderate refinement level (3168 cellsand 93176 degrees of freedom) the linear solver already makes up about threequarters of the instructions is a good sign that most of the algorithms usedin this program are well-tuned and that major improvements in speeding upthe program are most likely not to come from hand-optimizing individualaspects but by changing solver algorithms. We will address this point in thediscussion of results below as well. As a final point, and as a point of reference, the following picture alsoshows how the profile looked at an early stage of optimizing this program: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.original.png"/>
</div>
<p> As mentioned above, the runtime of this version was about four times as long asfor the first profile, with the <a class="el" href="classSparseILU.html">SparseILU</a> decomposition taking up about 30% ofthe instruction count, and operations an early, inefficient version ofDynamicSparsityPattern about 10%. Both these bottlenecks have since beencompletely removed.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p></p>
<p>As usual, we start by including some well-known files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>Then we need to include the header file for the sparse direct solver UMFPACK:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div></div><!-- fragment --><p>This includes the library for the incomplete LU factorization that will be used as a preconditioner in 3D:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>As in all programs, the namespace dealii is included:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step22</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Definingtheinnerpreconditionertype"></a> </p><h3>Defining the inner preconditioner type</h3>
<p></p>
<p>As explained in the introduction, we are going to use different preconditioners for two and three space dimensions, respectively. We distinguish between them by the use of the spatial dimension as a template parameter. See <a class="el" href="step_4.html">step-4</a> for details on templates. We are not going to create any preconditioner object here, all we do is to create class that holds a local alias determining the preconditioner class so we can write our program in a dimension-independent way.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div></div><!-- fragment --><p>In 2D, we are going to use a sparse direct solver as preconditioner:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">};</div></div><!-- fragment --><p>And the ILU preconditioning in 3D, called by <a class="el" href="classSparseILU.html">SparseILU</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStokesProblemcodeclasstemplate"></a> </p><h3>The <code>StokesProblem</code> class template</h3>
<p></p>
<p>This is an adaptation of <a class="el" href="step_20.html">step-20</a> , so the main class and the data types are nearly the same as used there. The only difference is that we have an additional member <code>preconditioner_matrix</code> , that is used for preconditioning the Schur complement, and a corresponding sparsity pattern <code>preconditioner_sparsity_pattern</code> . In addition, instead of relying on <a class="el" href="classLinearOperator.html">LinearOperator</a>, we implement our own InverseMatrix class. In this example we also use adaptive grid refinement, which is handled in analogy to <a class="el" href="step_6.html">step-6</a> . According to the discussion in the introduction, we are also going to use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object for implementing Dirichlet boundary conditions. Hence, we change the name <code>hanging_node_constraints</code> into <code>constraints</code> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div></div><!-- fragment --><p>This one is new: We shall use a so-called shared pointer structure to access the preconditioner. Shared pointers are essentially just a convenient form of pointers. Several shared pointers can point to the same object (just like regular pointers), but when the last shared pointer object to point to a preconditioner object is deleted (for example if a shared pointer object goes out of scope, if the class of which it is a member is destroyed, or if the pointer is assigned a different preconditioner object) then the preconditioner object pointed to is also destroyed. This ensures that we don't have to manually track in how many places a preconditioner object is still referenced, it can never create a memory leak, and can never produce a dangling pointer to an already destroyed object:</p>
<div class="fragment"><div class="line">  std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3>Boundary values and right hand side</h3>
<p></p>
<p>As in <a class="el" href="step_20.html">step-20</a> and most other example programs, the next task is to define the data for the PDE: For the Stokes problem, we are going to use natural boundary values on parts of the boundary (i.e. homogeneous Neumann-type) for which we won't have to do anything special (the homogeneity implies that the corresponding terms in the weak form are simply zero), and boundary conditions on the velocity (Dirichlet-type) on the rest of the boundary, as described in the introduction. In order to enforce the Dirichlet boundary values on the velocity, we will use the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> function as usual which requires us to write a function object with as many components as the finite element has. In other words, we have to define the function on the \((u,p)\) -space, but we are going to filter out the pressure component when interpolating the boundary values.</p>
<p>The following function object is a representation of the boundary values described in the introduction:</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     BoundaryValues()</div><div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line">  </div><div class="line">     <span class="keywordflow">if</span> (component == 0)</div><div class="line">       <span class="keywordflow">return</span> (p[0] &lt; 0 ?</div><div class="line">  </div><div class="line">-1 : (p[0] &gt; 0 ? 1 : 0));</div><div class="line">     <span class="keywordflow">return</span> 0;</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                          <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">       <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">   }</div></div><!-- fragment --><p>We implement similar functions for the right hand side which for the current example is simply zero:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p></p>
<p>The linear solvers and preconditioners are discussed extensively in the introduction. Here, we create the respective objects that will be used.</p>
<pre class="fragment">&lt;a name="ThecodeInverseMatrixcodeclasstemplate"&gt;&lt;/a&gt;  &lt;h4&gt;The &lt;code&gt;InverseMatrix&lt;/code&gt; class template&lt;/h4&gt; The   &lt;code&gt;InverseMatrix&lt;/code&gt;   class represents the data structure for an inverse matrix. Unlike   step-20  , we implement this with a class instead of the helper function inverse_linear_operator() we will apply this class to different kinds of matrices that will require different preconditioners (in   step-20   we only used a non-identity preconditioner for the mass matrix). The types of matrix and preconditioner are passed to this class via template parameters, and matrix and preconditioner objects of these types will then be passed to the constructor when an   &lt;code&gt;InverseMatrix&lt;/code&gt;   object is created. The member function   &lt;code&gt;vmult&lt;/code&gt;   is obtained by solving a linear system:
</pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  , preconditioner(&amp;preconditioner)</div><div class="line">{}</div></div><!-- fragment --><p>This is the implementation of the <code>vmult</code> function.</p>
<p>In this class we use a rather large tolerance for the solver control. The reason for this is that the function is used very frequently, and hence, any additional effort to make the residual in the CG solve smaller makes the solution more expensive. Note that we do not only use this class as a preconditioner for the Schur complement, but also when forming the inverse of the Laplace matrix &ndash; which is hence directly responsible for the accuracy of the solution itself, so we can't choose a too large tolerance, either.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src,preconditioner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeSchurComplementcodeclasstemplate"></a> </p><h4>The <code>SchurComplement</code> class template</h4>
<p></p>
<p>This class implements the Schur complement discussed in the introduction. It is in analogy to <a class="el" href="step_20.html">step-20</a> . Though, we now call it with a template parameter <code>PreconditionerType</code> in order to access that when specifying the respective type of the inverse matrix class. As a consequence of the definition above, the declaration <code>InverseMatrix</code> now contains the second template parameter for a preconditioner class as above, which affects the <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> object <code>m_inverse</code> as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div><div class="line">    A_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div><div class="line">  : system_matrix(&amp;system_matrix)</div><div class="line">  , A_inverse(&amp;A_inverse)</div><div class="line">  , tmp1(system_matrix.block(0, 0).m())</div><div class="line">  , tmp2(system_matrix.block(0, 0).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">SchurComplement&lt;PreconditionerType&gt;::vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">                                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).vmult(tmp1, src);</div><div class="line">  A_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">  system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemclassimplementation"></a> </p><h3>StokesProblem class implementation</h3>
<p></p>
<pre class="fragment">&lt;a name="StokesProblemStokesProblem"&gt;&lt;/a&gt;  &lt;h4&gt;StokesProblem::StokesProblem&lt;/h4&gt;
</pre><p>The constructor of this class looks very similar to the one of <a class="el" href="step_20.html">step-20</a> . The constructor initializes the variables for the polynomial degree, triangulation, finite element system and the dof handler. The underlying polynomial functions are of order <code>degree+1</code> for the vector-valued velocity components and of order <code>degree</code> for the pressure. This gives the LBB-stable element pair \(Q_{degree+1}^d\times Q_{degree}\) , often referred to as the Taylor-Hood element. Note that we initialize the triangulation with a MeshSmoothing argument, which ensures that the refinement of cells is done in a way that the approximation of the PDE solution remains well-behaved (problems arise if grids are too unstructured), see the documentation of <code><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></code> for details.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : degree(degree)</div><div class="line">  , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemsetup_dofs"></a> </p><h4>StokesProblem::setup_dofs</h4>
<p></p>
<p>Given a mesh, this function associates the degrees of freedom with it and creates the corresponding matrices and vectors. At the beginning it also releases the pointer to the preconditioner object (if the shared pointer pointed at anything at all at this point) since it will definitely not be needed any more after this point and will have to be re-computed after assembling the matrix, and unties the sparse matrices from their sparsity pattern objects. We then proceed with distributing degrees of freedom and renumbering them: In order to make the ILU preconditioner (in 3D) work efficiently, it is important to enumerate the degrees of freedom in such a way that it reduces the bandwidth of the matrix, or maybe more importantly: in such a way that the ILU is as close as possible to a real LU decomposition. On the other hand, we need to preserve the block structure of velocity and pressure already seen in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a> . This is done in two steps: First, all dofs are renumbered to improve the ILU and then we renumber once again by components. Since <code><a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></code> does not touch the renumbering within the individual blocks, the basic renumbering from the first step remains. As for how the renumber degrees of freedom to improve the ILU: deal.II has a number of algorithms that attempt to find orderings to improve ILUs, or reduce the bandwidth of matrices, or optimize some other aspect. The <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace shows a comparison of the results we obtain with several of these algorithms based on the testcase discussed here in this tutorial program. Here, we will use the traditional Cuthill-McKee algorithm already used in some of the previous tutorial programs. In the <a href="#improved-ilu">section on improved ILU</a> we're going to discuss this issue in more detail.</p>
<p>There is one more change compared to previous tutorial programs: There is no reason in sorting the <code>dim</code> velocity components individually. In fact, rather than first enumerating all \(x\) -velocities, then all \(y\) -velocities, etc, we would like to keep all velocities at the same location together and only separate between velocities (all components) and pressures. By default, this is not what the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function does: it treats each vector component separately; what we have to do is group several components into "blocks" and pass this block structure to that function. Consequently, we allocate a vector <code>block_component</code> with as many elements as there are components and describe all velocity components to correspond to block 0, while the pressure component will form block 1:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  A_preconditioner.reset();</div><div class="line">  system_matrix.clear();</div><div class="line">  preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div><div class="line">  block_component[dim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div></div><!-- fragment --><p>Now comes the implementation of Dirichlet boundary conditions, which should be evident after the discussion in the introduction. All that changed is that the function already appears in the setup functions, whereas we were used to see it in some assembly routine. Further down below where we set up the mesh, we will associate the top boundary where we impose Dirichlet boundary conditions with boundary indicator 1. We will have to pass this boundary indicator as second argument to the function below interpolating boundary values. There is one more thing, though. The function describing the Dirichlet conditions was defined for all components, both velocity and pressure. However, the Dirichlet conditions are to be set for the velocity only. To this end, we use a <a class="el" href="classComponentMask.html">ComponentMask</a> that only selects the velocity components. The component mask is obtained from the finite element by specifying the particular components we want. Since we use adaptively refined grids, the affine constraints object needs to be first filled with hanging node constraints generated from the DoF handler. Note the order of the two functions &mdash; we first compute the hanging node constraints, and then insert the boundary values into the constraints object. This makes sure that we respect H<sup>1</sup> conformity on boundaries with hanging nodes (in three space dimensions), where the hanging node needs to dominate the Dirichlet boundary values.</p>
<div class="fragment"><div class="line">{</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints,</div><div class="line">                                           fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">}</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div></div><!-- fragment --><p>In analogy to <a class="el" href="step_20.html">step-20</a> , we count the dofs in the individual components. We could do this in the same way as there, but we want to operate on the block structure we used already for the renumbering: The function <code><a class="el" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></code> does the same as <code><a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a></code> , but now grouped as velocity and pressure block via <code>block_component</code> .</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next task is to allocate a sparsity pattern for the system matrix we will create and one for the preconditioner matrix. We could do this in the same way as in <a class="el" href="step_20.html">step-20</a> , i.e. directly build an object of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a> through <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>. However, there is a major reason not to do so: In 3D, the function DoFTools::max_couplings_between_dofs yields a conservative but rather large number for the coupling between the individual dofs, so that the memory initially provided for the creation of the sparsity pattern of the matrix is far too much</p>
<ul>
<li>so much actually that the initial sparsity pattern won't even fit into the physical memory of most systems already for moderately-sized 3D problems, see also the discussion in <a class="el" href="step_18.html">step-18</a> . Instead, we first build temporary objects that use a different data structure that doesn't require allocating more memory than necessary but isn't suitable for use as a basis of <a class="el" href="classSparseMatrix.html">SparseMatrix</a> or <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> objects; in a second step we then copy these objects into objects of type <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>. This is entirely analogous to what we already did in <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_18.html">step-18</a> . In particular, we make use of the fact that we will never write into the \((1,1)\) block of the system matrix and that this is the only block to be filled for the preconditioner matrix. All this is done inside new scopes, which means that the memory of <code>dsp</code> will be released once the information has been copied to <code>sparsity_pattern</code> .</li>
</ul>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div><div class="line"></div><div class="line">  preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  preconditioner_dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                  preconditioner_coupling,</div><div class="line">                                  preconditioner_dsp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div><div class="line">}</div></div><!-- fragment --><p>Finally, the system matrix, the preconsitioner matrix, the solution and the right hand side vector are created from the block structure similar to the approach in <a class="el" href="step_20.html">step-20</a> :</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(2);</div><div class="line">  solution.block(0).reinit(n_u);</div><div class="line">  solution.block(1).reinit(n_p);</div><div class="line">  solution.collect_sizes();</div><div class="line"></div><div class="line">  system_rhs.reinit(2);</div><div class="line">  system_rhs.block(0).reinit(n_u);</div><div class="line">  system_rhs.block(1).reinit(n_p);</div><div class="line">  system_rhs.collect_sizes();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemassemble_system"></a> </p><h4>StokesProblem::assemble_system</h4>
<p></p>
<p>The assembly process follows the discussion in <a class="el" href="step_20.html">step-20</a> and in the introduction. We use the well-known abbreviations for the data structures that hold the local matrices, right hand side, and global numbering of the degrees of freedom for the present cell.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix         = 0;</div><div class="line">  system_rhs            = 0;</div><div class="line">  preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div><div class="line">                                                 dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div></div><!-- fragment --><p>Next, we need two objects that work as extractors for the <a class="el" href="classFEValues.html">FEValues</a> object. Their use is explained in detail in the report on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>As an extension over <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a> , we include a few optimizations that make assembly much faster for this particular problem. The improvements are based on the observation that we do a few calculations too many times when we do as in <a class="el" href="step_20.html">step-20</a> : The symmetric gradient actually has <code>dofs_per_cell</code> different values per quadrature point, but we extract it <code>dofs_per_cell*dofs_per_cell</code> times from the <a class="el" href="classFEValues.html">FEValues</a> object</p>
<ul>
<li>for both the loop over <code>i</code> and the inner loop over <code>j</code> . In 3d, that means evaluating it \(89^2=7921\) instead of \(89\) times, a not insignificant difference. So what we're going to do here is to avoid such repeated calculations by getting a vector of rank-2 tensors (and similarly for the divergence and the basis function value on pressure) at the quadrature point prior to starting the loop over the dofs on the cell. First, we create the respective objects that will hold these values. Then, we start the loop over all cells and the loop over the quadrature points, where we first extract these values. There is one more optimization we implement here: the local matrix (as well as the global one) is going to be symmetric, since all the operations involved are symmetric with respect to \(i\) and \(j\) . This is implemented by simply running the inner loop not to <code>dofs_per_cell</code>, but only up to <code>i</code> , the index of the outer loop.</li>
</ul>
<div class="fragment"><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    local_matrix                = 0;</div><div class="line">    local_preconditioner_matrix = 0;</div><div class="line">    local_rhs                   = 0;</div><div class="line"></div><div class="line">    right_hand_side.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                      rhs_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            symgrad_phi_u[k] =</div><div class="line">              fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">            div_phi_u[k] = fe_values[velocities].divergence(k, q);</div><div class="line">            phi_p[k]     = fe_values[pressure].value(k, q);</div><div class="line">          }</div></div><!-- fragment --><p>Now finally for the bilinear forms of both the system matrix and the matrix we use for the preconditioner. Recall that the formulas for these two are</p>
<p class="formulaDsp">
\begin{align*} A_{ij} &amp;= a(\varphi_i,\varphi_j) \\ &amp;= \underbrace{2(\varepsilon(\varphi_{i,\textbf{u}}), \varepsilon(\varphi_{j,\textbf{u}}))_{\Omega}} _{(1)} \; \underbrace{- (\textrm{div}\; \varphi_{i,\textbf{u}}, \varphi_{j,p})_{\Omega}} _{(2)} \; \underbrace{- (\varphi_{i,p}, \textrm{div}\; \varphi_{j,\textbf{u}})_{\Omega}} _{(3)} \end{align*}
</p>
<p> and</p>
<p class="formulaDsp">
\begin{align*} M_{ij} &amp;= \underbrace{(\varphi_{i,p}, \varphi_{j,p})_{\Omega}} _{(4)}, \end{align*}
</p>
<p> respectively, where \(\varphi_{i,\textbf{u}}\) and \(\varphi_{i,p}\) are the velocity and pressure components of the \(i\) th shape function. The various terms above are then easily recognized in the following implementation:</p>
<div class="fragment"><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">               {</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                   {</div><div class="line">                     local_matrix(i, j) +=</div><div class="line">                       (2 (symgrad_phi_u[i] symgrad_phi_u[j]) <span class="comment">// (1)</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- div_phi_u[i] phi_p[j]                 <span class="comment">// (2)</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- phi_p[i] div_phi_u[j])                <span class="comment">// (3)</span></div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);                        <span class="comment">// dx</span></div><div class="line">  </div><div class="line">                     local_preconditioner_matrix(i, j) +=</div><div class="line">                       (phi_p[i] phi_p[j]) <span class="comment">// (4)</span></div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);   <span class="comment">// dx</span></div><div class="line">                   }</div></div><!-- fragment --><p>Note that in the implementation of (1) above, <code>operator*</code> is overloaded for symmetric tensors, yielding the scalar product between the two tensors. For the right-hand side we use the fact that the shape functions are only non-zero in one component (because our elements are primitive). Instead of multiplying the tensor representing the dim+1 values of shape function i with the whole right-hand side vector, we only look at the only non-zero component. The function <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index</a> will return which component this shape function lives in (0=x velocity, 1=y velocity, 2=pressure in 2d), which we use to pick out the correct component of the right-hand side vector to multiply with.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">      local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div><div class="line">                       rhs_values[q](component_i)) <span class="comment">// f(x_q))</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);            <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Before we can write the local data into the global matrix (and simultaneously use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object to apply Dirichlet boundary conditions and eliminate hanging node constraints, as we discussed in the introduction), we have to be careful about one thing, though. We have only built half of the local matrices because of symmetry, but we're going to save the full matrices in order to use the standard functions for solving. This is done by flipping the indices in case we are pointing into the empty part of the local matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        local_matrix(i, j) = local_matrix(j, i);</div><div class="line">        local_preconditioner_matrix(i, j) =</div><div class="line">          local_preconditioner_matrix(j, i);</div><div class="line">      }</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                         local_rhs,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix,</div><div class="line">                                         system_rhs);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_preconditioner_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         preconditioner_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Before we're going to solve this linear system, we generate a preconditioner for the velocity-velocity matrix, i.e., <code>block(0,0)</code> in the system matrix. As mentioned above, this depends on the spatial dimension. Since the two classes described by the <code>InnerPreconditioner::type</code> alias have the same interface, we do not have to do anything different whether we want to use a sparse direct solver or an ILU:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  A_preconditioner =</div><div class="line">    std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div><div class="line">  A_preconditioner-&gt;initialize(</div><div class="line">    system_matrix.block(0, 0),</div><div class="line">    <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemsolve"></a> </p><h4>StokesProblem::solve</h4>
<p></p>
<p>After the discussion in the introduction and the definition of the respective classes above, the implementation of the <code>solve</code> function is rather straight-forward and done in a similar way as in <a class="el" href="step_20.html">step-20</a> . To start with, we need an object of the <code>InverseMatrix</code> class that represents the inverse of the matrix A. As described in the introduction, the inverse is generated with the help of an inner preconditioner of type <code>InnerPreconditioner::type</code> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div><div class="line">                 A_inverse(system_matrix.block(0, 0),A_preconditioner);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div></div><!-- fragment --><p>This is as in <a class="el" href="step_20.html">step-20</a> . We generate the right hand side \(B A^{-1} F - G\) for the Schur complement and an object that represents the respective linear operation \(B A^{-1} B^T\) , now with a template parameter indicating the preconditioner</p>
<ul>
<li>in accordance with the definition of the class.</li>
</ul>
<div class="fragment"><div class="line">     {</div><div class="line">       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div><div class="line">       A_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">       system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">       schur_rhs</div><div class="line">  </div><div class="line">-= system_rhs.block(1);</div><div class="line">  </div><div class="line">       SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div><div class="line">         system_matrix, A_inverse);</div></div><!-- fragment --><p>The usual control structures for the solver call are created...</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                             1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 schur_rhs.l2_norm());</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div></div><!-- fragment --><p>Now to the preconditioner to the Schur complement. As explained in the introduction, the preconditioning is done by a mass matrix in the pressure variable. Actually, the solver needs to have the preconditioner in the form \(P^{-1}\) , so we need to create an inverse operation. Once again, we use an object of the class <code>InverseMatrix</code> , which implements the <code>vmult</code> operation that is needed by the solver. In this case, we have to invert the pressure mass matrix. As it already turned out in earlier tutorial programs, the inversion of a mass matrix is a rather cheap and straight-forward operation (compared to, e.g., a Laplace matrix). The CG method with ILU preconditioning converges in 5-10 steps, independently on the mesh size. This is precisely what we do here: We choose another ILU preconditioner and take it along to the InverseMatrix object via the corresponding template parameter. A CG solver is then called within the vmult operation of the inverse matrix. An alternative that is cheaper to build, but needs more iterations afterwards, would be to choose a SSOR preconditioner with factor 1.2. It needs about twice the number of iterations, but the costs for its generation are almost negligible.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div><div class="line">preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div><div class="line">                          <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div><div class="line">  preconditioner_matrix.block(1, 1), preconditioner);</div></div><!-- fragment --><p>With the Schur complement and an efficient preconditioner at hand, we can solve the respective equation for the pressure (i.e. block 0 in the solution vector) in the usual way:</p>
<div class="fragment"><div class="line">cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div></div><!-- fragment --><p>After this first solution step, the hanging node constraints have to be distributed to the solution in order to achieve a consistent pressure field.</p>
<div class="fragment"><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>As in <a class="el" href="step_20.html">step-20</a> , we finally need to solve for the velocity equation where we plug in the solution to the pressure equation. This involves only objects we already know</p>
<ul>
<li>so we simply multiply \(p\) by \(B^T\) , subtract the right hand side and multiply by the inverse of \(A\) . At the end, we need to distribute the constraints from hanging nodes in order to obtain a consistent flow field:</li>
</ul>
<div class="fragment"><div class="line">     {</div><div class="line">       system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">       tmp=</div><div class="line">  </div><div class="line">-1;</div><div class="line">       tmp += system_rhs.block(0);</div><div class="line">  </div><div class="line">       A_inverse.vmult(solution.block(0), tmp);</div><div class="line">  </div><div class="line">       constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">     }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemoutput_results"></a> </p><h4>StokesProblem::output_results</h4>
<p></p>
<p>The next function generates graphical output. In this example, we are going to use the VTK file format. We attach names to the individual variables in the problem: <code>velocity</code> to the <code>dim</code> components of velocity and <code>pressure</code> to the pressure. Not all visualization programs have the ability to group individual vector components into a vector to provide vector plots; in particular, this holds for some VTK-based visualization programs. In this case, the logical grouping of components into vectors should already be described in the file containing the data. In other words, what we need to do is provide our output writers with a way to know which of the components of the finite element logically form a vector (with \(d\) components in \(d\) space dimensions) rather than letting them assume that we simply have a bunch of scalar fields. This is achieved using the members of the <code><a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a></code> namespace: as with the filename, we create a vector in which the first <code>dim</code> components refer to the velocities and are given the tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>; we finally push one tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a> to describe the grouping of the pressure variable.</p>
<p>The rest of the function is then the same as in <a class="el" href="step_20.html">step-20</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemrefine_mesh"></a> </p><h4>StokesProblem::refine_mesh</h4>
<p></p>
<p>This is the last interesting function of the <code>StokesProblem</code> class. As indicated by its name, it takes the solution to the problem and refines the mesh where this is needed. The procedure is the same as in the respective step in <a class="el" href="step_6.html">step-6</a> , with the exception that we base the refinement only on the change in pressure, i.e., we call the Kelly error estimator with a mask object of type <a class="el" href="classComponentMask.html">ComponentMask</a> that selects the single scalar component for the pressure that we are interested in (we get such a mask from the finite element class by specifying the component we want). Additionally, we do not coarsen the grid again:</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div><div class="line">   {</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  </div><div class="line">     <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">     <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">       dof_handler,</div><div class="line">       <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(degree + 1),</div><div class="line">       std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">       solution,</div><div class="line">       estimated_error_per_cell,</div><div class="line">       fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(pressure));</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                     estimated_error_per_cell,</div><div class="line">                                                     0.3,</div><div class="line">                                                     0.0);</div><div class="line">     triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemrun"></a> </p><h4>StokesProblem::run</h4>
<p></p>
<p>The last step in the Stokes class is, as usual, the function that generates the initial grid and calls the other functions in the respective order. We start off with a rectangle of size \(4 \times 1\) (in 2d) or \(4 \times 1 \times 1\) (in 3d), placed in \(R^2/R^3\) as \((-2,2)\times(-1,0)\) or \((-2,2)\times(0,1)\times(-1,0)\) , respectively. It is natural to start with equal mesh size in each direction, so we subdivide the initial rectangle four times in the first coordinate direction. To limit the scope of the variables involved in the creation of the mesh to the range where we actually need them, we put the entire block between a pair of braces:</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div><div class="line">   {</div><div class="line">     {</div><div class="line">       std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div><div class="line">       subdivisions[0] = 4;</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div><div class="line">                                         <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,</div><div class="line">  </div><div class="line">-1) :    <span class="comment">// 2d case</span></div><div class="line">                                         <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, 0,</div><div class="line">  </div><div class="line">-1)); <span class="comment">// 3d case</span></div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div><div class="line">                                       <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div><div class="line">                                       <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 1, 0)); <span class="comment">// 3d case</span></div><div class="line">  </div><div class="line">       <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                                 subdivisions,</div><div class="line">                                                 bottom_left,</div><div class="line">                                                 top_right);</div><div class="line">     }</div></div><!-- fragment --><p>A boundary indicator of 1 is set to all boundaries that are subject to Dirichlet boundary conditions, i.e. to faces that are located at 0 in the last coordinate direction. See the example description above for details.</p>
<div class="fragment"><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">         <span class="keywordflow">if</span> (face-&gt;center()[dim</div><div class="line">  </div><div class="line">- 1] == 0)</div><div class="line">           face-&gt;set_all_boundary_ids(1);</div></div><!-- fragment --><p>We then apply an initial refinement before solving for the first time. In 3D, there are going to be more degrees of freedom, so we refine less there:</p>
<div class="fragment"><div class="line">     triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4</div><div class="line">  </div><div class="line">- dim);</div></div><!-- fragment --><p>As first seen in <a class="el" href="step_6.html">step-6</a> , we cycle over the different refinement levels and refine (except for the first cycle), setup the degrees of freedom and matrices, assemble, solve and create output:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"> </div><div class="line">        setup_dofs();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">        assemble_system();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">        solve();</div><div class="line"> </div><div class="line">        output_results(refinement_cycle);</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step22</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p></p>
<p>The main function is the same as in <a class="el" href="step_20.html">step-20</a> . We pass the element degree as a parameter and choose the space dimension at the well-known template slot.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step22;</div><div class="line"> </div><div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></p>
<p><a class="anchor" id="Outputoftheprogramandgraphicalvisualization"></a></p><h3>Output of the program and graphical visualization</h3>
<p></p>
<p><a class="anchor" id="2Dcalculations"></a></p><h4>2D calculations</h4>
<p></p>
<p>Running the program with the space dimension set to 2 in the <code>main</code> function yields the following output (in "release mode", See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.18.html">video lecture 18</a>.): </p><div class="fragment"><div class="line">examples/step-22&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 679 (594+85)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line">  </div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 160</div><div class="line">   Number of degrees of freedom: 1683 (1482+201)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line">  </div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 376</div><div class="line">   Number of degrees of freedom: 3813 (3370+443)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line">  </div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 880</div><div class="line">   Number of degrees of freedom: 8723 (7722+1001)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line">  </div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2008</div><div class="line">   Number of degrees of freedom: 19383 (17186+2197)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line">  </div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 4288</div><div class="line">   Number of degrees of freedom: 40855 (36250+4605)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div></div><!-- fragment --><p>The entire computation above takes about 2 seconds on a reasonablyquick (for 2015 standards) machine. What we see immediately from this is that the number of (outer)iterations does not increase as we refine the mesh. This confirms thestatement in the introduction that preconditioning the Schurcomplement with the mass matrix indeed yields a matrix spectrallyequivalent to the identity matrix (i.e. with eigenvalues bounded aboveand below independently of the mesh size or the relative sizes ofcells). In other words, the mass matrix and the Schur complement arespectrally equivalent. In the images below, we show the grids for the first six refinementsteps in the program. Observe how the grid is refined in regionswhere the solution rapidly changes: On the upper boundary, we haveDirichlet boundary conditions that are</p>
<ul>
<li>in the left half of the lineand 1 in the right one, so there is an abrupt change at \(x=0\) . Likewise,there are changes from Dirichlet to Neumann data in the two uppercorners, so there is need for refinement there as well: <table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-0.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-1.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-3.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-4.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-5.png"/>
</div>
   </td></tr>
</table>
Finally, following is a plot of the flow field. It shows fluidtransported along with the moving upper boundary and being replaced bymaterial coming from below: <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.solution.png"/>
</div>
 This plot uses the capability of VTK-based visualization programs (inthis case of VisIt) to show vector data; this is the result of usdeclaring the velocity components of the finite element in use to be aset of vector components, rather than independent scalar components inthe <code>StokesProblem&lt;dim&gt;::output_results</code> function of thistutorial program.</li>
</ul>
<p><a class="anchor" id="3Dcalculations"></a></p><h4>3D calculations</h4>
<p></p>
<p>In 3d, the screen output of the program looks like this: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 32</div><div class="line">   Number of degrees of freedom: 1356 (1275+81)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  13 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">  </div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 144</div><div class="line">   Number of degrees of freedom: 5088 (4827+261)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">  </div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 704</div><div class="line">   Number of degrees of freedom: 22406 (21351+1055)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">  </div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 3168</div><div class="line">   Number of degrees of freedom: 93176 (89043+4133)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">  </div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 11456</div><div class="line">   Number of degrees of freedom: 327808 (313659+14149)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">  </div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 45056</div><div class="line">   Number of degrees of freedom: 1254464 (1201371+53093)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div></div><!-- fragment --><p>Again, we see that the number of outer iterations does not increase aswe refine the mesh. Nevertheless, the compute time increasessignificantly: for each of the iterations above separately, it takes about0.14 seconds, 0.63 seconds, 4.8 seconds, 35 seconds, 2 minutes and 33 seconds,and 13 minutes and 12 seconds. This overall superlinear (in the number ofunknowns) increase in runtime is due to the fact that our inner solver is not \({\cal O}(N)\) : a simple experiment shows that as we keep refining the mesh, theaverage number of ILU-preconditioned CG iterations to invert thevelocity-velocity block \(A\) increases. We will address the question of how possibly to improve our solver <a href="#improved-solver">below</a>. As for the graphical output, the grids generated during the solutionlook as follow: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-0.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-1.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-3.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-4.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-5.png"/>
</div>
   </td></tr>
</table>
<p>Again, they show essentially the location of singularities introducedby boundary conditions. The vector field computed makes for aninteresting graph: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.solution.png"/>
</div>
<p> The isocontours shown here as well are those of the pressurevariable, showing the singularity at the point of discontinuousvelocity boundary conditions.</p>
<p><a class="anchor" id="Sparsitypattern"></a></p><h3>Sparsity pattern</h3>
<p></p>
<p>As explained during the generation of the sparsity pattern, it isimportant to have the numbering of degrees of freedom in mind whenusing preconditioners like incomplete LU decompositions. This is mostconveniently visualized using the distribution of nonzero elements inthe stiffness matrix. If we don't do anything special to renumber degrees of freedom (i.e.,without using <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>, but with using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> to ensure that degrees of freedom areappropriately sorted into their corresponding blocks of the matrix andvector), then we get the following image after the first adaptiverefinement in two dimensions: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-nor.png"/>
</div>
<p> In order to generate such a graph, you have to insert a piece ofcode like the following to the end of the setup step. </p><div class="fragment"><div class="line">{</div><div class="line">  std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern.gpl&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a7f59a68863a1e770ba275894a7170e70">print_gnuplot</a>(out);</div><div class="line">}</div></div><!-- fragment --><p>It is clearly visible that the nonzero entries are spread over almost thewhole matrix. This makes preconditioning by ILU inefficient: ILU generates aGaussian elimination (LU decomposition) without fill-in elements, which meansthat more tentative fill-ins left out will result in a worse approximation ofthe complete decomposition. In this program, we have thus chosen a more advanced renumbering ofcomponents. The renumbering with <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a> and groupingthe components into velocity and pressure yields the following output: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-ren.png"/>
</div>
<p> It is apparent that the situation has improved a lot. Most of the elements arenow concentrated around the diagonal in the (0,0) block in the matrix. Similareffects are also visible for the other blocks. In this case, the ILUdecomposition will be much closer to the full LU decomposition, which improvesthe quality of the preconditioner. (It may be interesting to note that thesparse direct solver UMFPACK does some internal renumbering of the equationsbefore actually generating a sparse LU decomposition; that procedure leads toa very similar pattern to the one we got from the Cuthill-McKee algorithm.) Finally, we want to have a closerlook at a sparsity pattern in 3D. We show only the (0,0) block of thematrix, again after one adaptive refinement. Apart from the fact that the matrixsize has increased, it is also visible that there are many more entriesin the matrix. Moreover, even for the optimized renumbering, there will be aconsiderable amount of tentative fill-in elements. This illustrates why UMFPACKis not a good choice in 3D</p>
<ul>
<li>a full decomposition needs many new entries that eventually won't fit into the physical memory (RAM): <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.sparsity_uu-ren.png"/>
</div>
</li>
</ul>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p></p>
<p><a class="anchor" id="improved-solver"></a> <a class="anchor" id="Improvedlinearsolverin3D"></a><a class="anchor" id="Improvedlinearsolverin3D"></a></p><h4>Improved linear solver in 3D</h4>
<h4>Improved linear solver in 3D</h4>
<p></p>
<p>We have seen in the section of computational results that the number of outeriterations does not depend on the mesh size, which is optimal in a sense ofscalability. This does, however, not apply to the solver as a whole, asmentioned above:We did not look at the number of inner iterations when generating the inverse ofthe matrix \(A\) and the mass matrix \(M_p\) . Of course, this is unproblematic inthe 2D case where we precondition \(A\) with a direct solver and the <code>vmult</code> operation of the inverse matrix structure will converge inone single CG step, but this changes in 3D where we only use an ILUpreconditioner. There, the number of required preconditioned CG steps toinvert \(A\) increases as the mesh is refined, and each <code>vmult</code> operation involves on average approximately 14, 23, 36, 59, 75 and 101 innerCG iterations in the refinement steps shown above. (On the other hand,the number of iterations for applying the inverse pressure mass matrix isalways around five, both in two and three dimensions.) To summarize, most workis spent on solving linear systems with the same matrix \(A\) over and over again.What makes this look even worse is the fact that weactually invert a matrix that is about 95 percent the size of the total systemmatrix and stands for 85 percent of the non-zero entries in the sparsitypattern. Hence, the natural question is whether it is reasonable to solve alinear system with matrix \(A\) for about 15 times when calculating the solutionto the block system. The answer is, of course, that we can do that in a few other (most of the timebetter) ways.Nevertheless, it has to be remarked that an indefinite system as the oneat hand puts indeed much higherdemands on the linear algebra than standard elliptic problems as we have seenin the early tutorial programs. The improvements are still ratherunsatisfactory, if one compares with an elliptic problem of similarsize. Either way, we will introduce below a number of improvements to thelinear solver, a discussion that we will re-consider again with additionaloptions in the <a class="el" href="step_31.html">step-31</a> program. <a class="anchor" id="improved-ilu"></a> <a class="anchor" id="BetterILUdecompositionbysmartreordering"></a><a class="anchor" id="BetterILUdecompositionbysmartreordering"></a></p><h5>Better ILU decomposition by smart reordering</h5>
<h5>Better ILU decomposition by smart reordering</h5>
<p></p>
<p>A first attempt to improve the speed of the linear solution process is to choosea dof reordering that makes the ILU being closer to a full LU decomposition, asalready mentioned in the in-code comments. The <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace comparesseveral choices for the renumbering of dofs for the Stokes equations. The bestresult regarding the computing time was found for the King ordering, which isaccessed through the call <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a76fd1dc3212aeeca4294c358248e46d5">DoFRenumbering::boost::king_ordering</a>. With thatprogram, the inner solver needs considerably less operations, e.g. about 62inner CG iterations for the inversion of \(A\) at cycle 4 compared to about 75iterations with the standard Cuthill-McKee-algorithm. Also, the computing timeat cycle 4 decreased from about 17 to 11 minutes for the <code>solve()</code> call. However, the King ordering (and the orderings provided by the <a class="el" href="namespaceDoFRenumbering_1_1boost.html">DoFRenumbering::boost</a> namespace in general) has a serious drawback</p>
<ul>
<li>it usesmuch more memory than the in-build deal versions, since it acts on abstractgraphs rather than the geometry provided by the triangulation. In the presentcase, the renumbering takes about 5 times as much memory, which yields aninfeasible algorithm for the last cycle in 3D with 1.2 millionunknowns. <a class="anchor" id="BetterpreconditionerfortheinnerCGsolver"></a><h5>Better preconditioner for the inner CG solver</h5>
</li>
</ul>
<p>Another idea to improve the situation even more would be to choose apreconditioner that makes CG for the (0,0) matrix \(A\) converge in amesh-independent number of iterations, say 10 to 30. We have seen such acandidate in <a class="el" href="step_16.html">step-16</a> : multigrid. <a class="anchor" id="BlockSchurcomplementpreconditioner"></a></p><h5>Block Schur complement preconditioner</h5>
<p><a class="anchor" id="block-schur"></a>Even with a good preconditioner for \(A\) , we stillneed to solve of the same linear system repeatedly (with differentright hand sides, though) in order to make the Schur complement solveconverge. The approach we are going to discuss here is how inner iterationand outer iteration can be combined. If we persist in calculating the Schurcomplement, there is no other possibility. The alternative is to attack the block system at once and use an approximateSchur complement as efficient preconditioner. The idea is asfollows: If we find a block preconditioner \(P\) such that the matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p> is simple, then an iterative solver with that preconditioner will converge in afew iterations. Using the Schur complement \(S = B A^{-1} B^T\) , one finds that </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p> would appear to be a good choice since </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right)\cdot \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right). \end{eqnarray*}
</p>
<p> This is the approach taken by the paper by Silvester and Wathen referencedto in the introduction (with the exception that Silvester and Wathen useright preconditioning). In this case, a Krylov-based iterative method wouldconverge in one step only if exact inverses of \(A\) and \(S\) were applied,since all the eigenvalues are one (and the number of iterations in such amethod is bounded by the number of distinct eigenvalues). Below, we willdiscuss the choice of an adequate solver for this problem. First, we aregoing to have a closer look at the implementation of the preconditioner. Since \(P\) is aimed to be a preconditioner only, we shall use approximations tothe inverse of the Schur complement \(S\) and the matrix \(A\) . Hence, the Schurcomplement will be approximated by the pressure mass matrix \(M_p\) , and we usea preconditioner to \(A\) (without an InverseMatrix class around it) forapproximating \(A^{-1}\) . Here comes the class that implements the block Schurcomplement preconditioner. The <code>vmult</code> operation for block vectorsaccording to the derivation above can be specified by three successiveoperations: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>         &amp;S,</div><div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt;  &amp;Mpinv,</div><div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner);</div><div class="line">  </div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>,</div><div class="line">                       PreconditionerMp &gt; &gt; m_inverse;</div><div class="line">    <span class="keyword">const</span> PreconditionerA &amp;a_preconditioner;</div><div class="line">  </div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp;</div><div class="line">  </div><div class="line">};</div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line">BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::BlockSchurPreconditioner(</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>                            &amp;S,</div><div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt; &amp;Mpinv,</div><div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner</div><div class="line">          )</div><div class="line">                :</div><div class="line">                system_matrix           (&amp;S),</div><div class="line">                m_inverse               (&amp;Mpinv),</div><div class="line">                a_preconditioner        (Apreconditioner),</div><div class="line">                tmp                     (S.block(1,1).m())</div><div class="line">{}</div><div class="line">  </div><div class="line">        <span class="comment">// Now the interesting function, the multiplication of</span></div><div class="line">        <span class="comment">// the preconditioner with a BlockVector.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keywordtype">void</span> BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::vmult (</div><div class="line">                                     <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">        <span class="comment">// Form u_new = A^{-1} u</span></div><div class="line">  a_preconditioner.vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">        <span class="comment">// Form tmp =</span></div><div class="line">  </div><div class="line">- B u_new + p</div><div class="line">        <span class="comment">// (&lt;code&gt;SparseMatrix::residual&lt;/code&gt;</span></div><div class="line">        <span class="comment">// does precisely this)</span></div><div class="line">  system_matrix-&gt;block(1,0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">        <span class="comment">// Change sign in tmp</span></div><div class="line">  tmp=</div><div class="line">  </div><div class="line">-1;</div><div class="line">        <span class="comment">// Multiply by approximate Schur complement</span></div><div class="line">        <span class="comment">// (i.e. a pressure mass matrix)</span></div><div class="line">  m_inverse-&gt;vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">}</div></div><!-- fragment --><p>Since we act on the whole block system now, we have to live with onedisadvantage: we need to perform the solver iterations onthe full block system instead of the smaller pressure space. Now we turn to the question which solver we should use for the blocksystem. The first observation is that the resulting preconditioned matrix cannotbe solved with CG since it is neither positive definite nor symmetric. The deal.II libraries implement several solvers that are appropriate for theproblem at hand. One choice is the solver <a class="el" href="classSolverBicgstab.html">BiCGStab</a>, whichwas used for the solution of the unsymmetric advection problem in <a class="el" href="step_9.html">step-9</a> . Thesecond option, the one we are going to choose, is <a class="el" href="classSolverGMRES.html">GMRES</a>(generalized minimum residual). Both methods have their pros and cons</p>
<ul>
<li>thereare problems where one of the two candidates clearly outperforms the other, andvice versa.<a href="http://en.wikipedia.org/wiki/GMRES#Comparison_with_other_solvers">Wikipedia</a>'sarticle on the GMRES method gives a comparative presentation.A more comprehensive and well-founded comparison can be read e.g. in the book byJ.W. Demmel (Applied Numerical Linear Algebra, SIAM, 1997, section 6.6.6). For our specific problem with the ILU preconditioner for \(A\) , we certainly needto perform hundreds of iterations on the block system for large problem sizes(we won't beat CG!). Actually, this disfavors GMRES: During the GMRESiterations, a basis of Krylov vectors is successively built up and someoperations are performed on these vectors. The more vectors are in this basis,the more operations and memory will be needed. The number of operations scalesas \({\cal O}(n + k^2)\) and memory as \({\cal O}(kn)\) , where \(k\) is the number ofvectors in the Krylov basis and \(n\) the size of the (block) matrix.To not let these demands grow excessively, deal.II limits the size \(k\) of thebasis to 30 vectors by default.Then, the basis is rebuilt. This implementation of the GMRES method is calledGMRES(k), with default \(k=30\) . What we have gained by this restriction,namely a bound on operations and memory requirements, will be compensated bythe fact that we use an incomplete basis</li>
<li>this will increase the number ofrequired iterations. BiCGStab, on the other hand, won't get slower when many iterations are needed(one iteration uses only results from one preceding step andnot all the steps as GMRES). Besides the fact the BiCGStab is more expensive perstep since two matrix-vector products are needed (compared to one forCG or GMRES), there is one main reason which makes BiCGStab not appropriate forthis problem: The preconditioner applies the inverse of the pressuremass matrix by using the InverseMatrix class. Since the application of theinverse matrix to a vector is done only in approximative way (an exact inverseis too expensive), this will also affect the solver. In the case of BiCGStab,the Krylov vectors will not be orthogonal due to that perturbation. Whilethis is uncritical for a small number of steps (up to about 50), it ruins theperformance of the solver when these perturbations have grown to a significantmagnitude in the coarse of iterations. We did some experiments with BiCGStab and found it tobe faster than GMRES up to refinement cycle 3 (in 3D), but it became very slowfor cycles 4 and 5 (even slower than the original Schur complement), so thesolver is useless in this situation. Choosing a sharper tolerance for theinverse matrix class ( <code>1e-10*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code> instead of <code>1e-6*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code> ) made BiCGStab perform well also for cycle 4,but did not change the failure on the very large problems. GMRES is of course also effected by the approximate inverses, but it is not assensitive to orthogonality and retains a relatively good performance also forlarge sizes, see the results below. With this said, we turn to the realization of the solver call with GMRES with \(k=100\) temporary vectors: <div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &amp;pressure_mass_matrix</div><div class="line">  = preconditioner_matrix.block(1,1);</div><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> pmass_preconditioner;</div><div class="line">pmass_preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a> (pressure_mass_matrix,</div><div class="line">  <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;,<a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div><div class="line">  m_inverse (pressure_mass_matrix, pmass_preconditioner);</div><div class="line"></div><div class="line">BlockSchurPreconditioner&lt;typename InnerPreconditioner&lt;dim&gt;::type,</div><div class="line">                         <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div><div class="line">  preconditioner (system_matrix, m_inverse,A_preconditioner);</div><div class="line"></div><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m(),</div><div class="line">                              1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6*system_rhs.l2_norm());</div><div class="line"><a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;BlockVector&lt;double&gt;</a> &gt; vector_memory;</div><div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt;::AdditionalData gmres_data;</div><div class="line">gmres_data.max_n_tmp_vectors = 100;</div><div class="line"></div><div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt; gmres(solver_control, vector_memory,</div><div class="line">                                        gmres_data);</div><div class="line"></div><div class="line">gmres.solve(system_matrix, solution, system_rhs,</div><div class="line">            preconditioner);</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a> (solution);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_step()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; block GMRES iterations&quot;</span>;</div></div><!-- fragment --></li>
</ul>
<p>Obviously, one needs to add the include file <a class="el" href="classSolverGMRES.html">&lt;lac/solver_gmres.h&gt;</a> in order to make this run.We call the solver with a <a class="el" href="classBlockVector.html">BlockVector</a> template in order to enableGMRES to operate on block vectors and matrices.Note also that we need to set the (1,1) block in the systemmatrix to zero (we saved the pressure mass matrix there which is not part of theproblem) after we copied the information to another matrix. Using the <a class="el" href="classTimer.html">Timer</a> class, we collect some statistics that compare the runtimeof the block solver with the one from the problem implementation above.Besides the solution with the two options we also check if the solutionsof the two variants are close to each other (i.e. this solver gives indeed thesame solution as we had before) and calculate the infinitynorm of the vector difference. Let's first see the results in 2D: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 679 (594+85) [0.00162792 s]</div><div class="line">   Assembling...  [0.00108981 s]</div><div class="line">   Computing preconditioner... [0.0025959 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.00479603s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.00441718 s]</div><div class="line">   l_infinity difference between solution vectors: 5.38258e-07</div><div class="line">  </div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 160</div><div class="line">   Number of degrees of freedom: 1683 (1482+201) [0.00345707 s]</div><div class="line">   Assembling...  [0.00237417 s]</div><div class="line">   Computing preconditioner... [0.00605702 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0123992s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.011909 s]</div><div class="line">   l_infinity difference between solution vectors: 1.74658e-05</div><div class="line">  </div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 376</div><div class="line">   Number of degrees of freedom: 3813 (3370+443) [0.00729299 s]</div><div class="line">   Assembling...  [0.00529909 s]</div><div class="line">   Computing preconditioner... [0.0167508 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.031672s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.029232 s]</div><div class="line">   l_infinity difference between solution vectors: 7.81569e-06</div><div class="line">  </div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 880</div><div class="line">   Number of degrees of freedom: 8723 (7722+1001) [0.017709 s]</div><div class="line">   Assembling...  [0.0126002 s]</div><div class="line">   Computing preconditioner... [0.0435679 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0971651s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.0992041 s]</div><div class="line">   l_infinity difference between solution vectors: 1.87249e-05</div><div class="line">  </div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2008</div><div class="line">   Number of degrees of freedom: 19383 (17186+2197) [0.039988 s]</div><div class="line">   Assembling...  [0.028281 s]</div><div class="line">   Computing preconditioner... [0.118314 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.252133s ]</div><div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.269125 s]</div><div class="line">   l_infinity difference between solution vectors: 6.38657e-05</div><div class="line">  </div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 4288</div><div class="line">   Number of degrees of freedom: 40855 (36250+4605) [0.0880702 s]</div><div class="line">   Assembling...  [0.0603511 s]</div><div class="line">   Computing preconditioner... [0.278339 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.53846s ]</div><div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.578667 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000173363</div></div><!-- fragment --><p>We see that there is no huge difference in the solution time between theblock Schur complement preconditioner solver and the Schur complementitself. The reason is simple: we used a direct solve as preconditioner for \(A\)</p>
<ul>
<li>so we cannot expect any gain by avoiding the inner iterations. We seethat the number of iterations has slightly increased for GMRES, but all inall the two choices are fairly similar. The picture of course changes in 3D: <div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 32</div><div class="line">   Number of degrees of freedom: 1356 (1275+81) [0.00845218 s]</div><div class="line">   Assembling...  [0.019372 s]</div><div class="line">   Computing preconditioner... [0.00712395 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 13 outer CG iterations <span class="keywordflow">for</span> p  [0.0320101s ]</div><div class="line">      Block Schur preconditioner: 22 GMRES iterations [0.0048759 s]</div><div class="line">   l_infinity difference between solution vectors: 2.15942e-05</div><div class="line">  </div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 144</div><div class="line">   Number of degrees of freedom: 5088 (4827+261) [0.0346942 s]</div><div class="line">   Assembling...  [0.0857739 s]</div><div class="line">   Computing preconditioner... [0.0465031 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [0.349258s ]</div><div class="line">      Block Schur preconditioner: 35 GMRES iterations [0.048759 s]</div><div class="line">   l_infinity difference between solution vectors: 1.77657e-05</div><div class="line">  </div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 704</div><div class="line">   Number of degrees of freedom: 22406 (21351+1055) [0.175669 s]</div><div class="line">   Assembling...  [0.437447 s]</div><div class="line">   Computing preconditioner... [0.286435 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [3.65519s ]</div><div class="line">      Block Schur preconditioner: 63 GMRES iterations [0.497787 s]</div><div class="line">   l_infinity difference between solution vectors: 5.08078e-05</div><div class="line">  </div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 3168</div><div class="line">   Number of degrees of freedom: 93176 (89043+4133) [0.790985 s]</div><div class="line">   Assembling...  [1.97598 s]</div><div class="line">   Computing preconditioner... [1.4325 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [29.9666s ]</div><div class="line">      Block Schur preconditioner: 128 GMRES iterations [5.02645 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000119671</div><div class="line">  </div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 11456</div><div class="line">   Number of degrees of freedom: 327808 (313659+14149) [3.44995 s]</div><div class="line">   Assembling...  [7.54772 s]</div><div class="line">   Computing preconditioner... [5.46306 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [139.987s ]</div><div class="line">      Block Schur preconditioner: 255 GMRES iterations [38.0946 s]</div><div class="line">   l_infinity difference between solution vectors: 0.00020793</div><div class="line">  </div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 45056</div><div class="line">   Number of degrees of freedom: 1254464 (1201371+53093) [19.6795 s]</div><div class="line">   Assembling...  [28.6586 s]</div><div class="line">   Computing preconditioner... [22.401 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [796.767s ]</div><div class="line">      Block Schur preconditioner: 524 GMRES iterations [355.597 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000501219</div></div><!-- fragment --></li>
</ul>
<p>Here, the block preconditioned solver is clearly superior to the Schurcomplement, but the advantage gets less for more mesh points. This isbecause GMRES(k) scales worse with the problem size than CG, as we discussedabove. Nonetheless, the improvement by a factor of 3-6 for moderate problemsizes is quite impressive.</p>
<p><a class="anchor" id="Combiningtheblockpreconditionerandmultigrid"></a></p><h5>Combining the block preconditioner and multigrid</h5>
<p>An ultimate linear solver for this problem could be imagined as acombination of an optimalpreconditioner for \(A\) (e.g. multigrid) and the block preconditionerdescribed above, which is the approach taken in the <a class="el" href="step_31.html">step-31</a> and <a class="el" href="step_32.html">step-32</a> tutorial programs (where we use an algebraic multigridmethod) and <a class="el" href="step_56.html">step-56</a> (where we use a geometric multigrid method).</p>
<p><a class="anchor" id="Noblockmatricesandvectors"></a></p><h5>No block matrices and vectors</h5>
<p>Another possibility that can be taken into account is to not set up a blocksystem, but rather solve the system of velocity and pressure all at once. Theoptions are direct solve with UMFPACK (2D) or GMRES with ILUpreconditioning (3D). It should be straightforward to try that.</p>
<p><a class="anchor" id="Moreinterestingtestcases"></a></p><h4>More interesting testcases</h4>
<p></p>
<p>The program can of course also serve as a basis to compute the flow in moreinteresting cases. The original motivation to write this program was for it tobe a starting point for some geophysical flow problems, such as themovement of magma under places where continental plates drift apart (forexample mid-ocean ridges). Of course, in such places, the geometry is morecomplicated than the examples shown above, but it is not hard to accommodatefor that. For example, by using the following modification of the boundary valuesfunction </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">BoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x_offset = <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(p[1]*4)/3;</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> (p[0] &lt; x_offset ?</div><div class="line">  </div><div class="line">-1 : (p[0] &gt; x_offset ? 1 : 0));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> and the following way to generate the mesh as the domain \([-2,2]\times[-2,2]\times[-1,0]\) </p><div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; subdivisions (dim, 1);</div><div class="line">subdivisions[0] = 4;</div><div class="line"><span class="keywordflow">if</span> (dim&gt;2)</div><div class="line">  subdivisions[1] = 4;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,-1) :</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,-2,-1));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right   = (dim == 2 ?</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2,0) :</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2,2,0));</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                           subdivisions,</div><div class="line">                                           bottom_left,</div><div class="line">                                           top_right);</div></div><!-- fragment --><p> then we get images where the fault line is curved: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d-extension.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d-grid-extension.png"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2008 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2008</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step22</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (component == 0)</div><div class="line">      <span class="keywordflow">return</span> (p[0] &lt; 0 ? -1 : (p[0] &gt; 0 ? 1 : 0));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                         Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                  <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">    <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">    <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    , preconditioner(&amp;preconditioner)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">    Vector&lt;double&gt; &amp;      dst,</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.size(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * src.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, *preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div><div class="line">      A_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div><div class="line">    : system_matrix(&amp;system_matrix)</div><div class="line">    , A_inverse(&amp;A_inverse)</div><div class="line">    , tmp1(system_matrix.block(0, 0).m())</div><div class="line">    , tmp2(system_matrix.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  SchurComplement&lt;PreconditionerType&gt;::vmult(Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).vmult(tmp1, src);</div><div class="line">    A_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : degree(degree)</div><div class="line">    , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    A_preconditioner.reset();</div><div class="line">    system_matrix.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div><div class="line">    block_component[dim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               1,</div><div class="line">                                               BoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">    }</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div><div class="line"></div><div class="line">      preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      preconditioner_dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                      preconditioner_coupling,</div><div class="line">                                      preconditioner_dsp,</div><div class="line">                                      constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(2);</div><div class="line">    solution.block(0).reinit(n_u);</div><div class="line">    solution.block(1).reinit(n_p);</div><div class="line">    solution.collect_sizes();</div><div class="line"></div><div class="line">    system_rhs.reinit(2);</div><div class="line">    system_rhs.block(0).reinit(n_u);</div><div class="line">    system_rhs.block(1).reinit(n_p);</div><div class="line">    system_rhs.collect_sizes();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix         = 0;</div><div class="line">    system_rhs            = 0;</div><div class="line">    preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix                = 0;</div><div class="line">        local_preconditioner_matrix = 0;</div><div class="line">        local_rhs                   = 0;</div><div class="line"></div><div class="line">        right_hand_side.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                          rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                symgrad_phi_u[k] =</div><div class="line">                  fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                div_phi_u[k] = fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]     = fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) <span class="comment">// (1)</span></div><div class="line">                       - div_phi_u[i] * phi_p[j]                 <span class="comment">// (2)</span></div><div class="line">                       - phi_p[i] * div_phi_u[j])                <span class="comment">// (3)</span></div><div class="line">                      * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);                        <span class="comment">// * dx</span></div><div class="line"></div><div class="line">                    local_preconditioner_matrix(i, j) +=</div><div class="line">                      (phi_p[i] * phi_p[j]) <span class="comment">// (4)</span></div><div class="line">                      * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);   <span class="comment">// * dx</span></div><div class="line">                  }</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                  fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div><div class="line">                                 * rhs_values[q](component_i)) <span class="comment">// * f(x_q))</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);            <span class="comment">// * dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              local_matrix(i, j) = local_matrix(j, i);</div><div class="line">              local_preconditioner_matrix(i, j) =</div><div class="line">                local_preconditioner_matrix(j, i);</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_preconditioner_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               preconditioner_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    A_preconditioner =</div><div class="line">      std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div><div class="line">    A_preconditioner-&gt;initialize(</div><div class="line">      system_matrix.block(0, 0),</div><div class="line">      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                        <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div><div class="line">                   A_inverse(system_matrix.block(0, 0), *A_preconditioner);</div><div class="line">    Vector&lt;double&gt; tmp(solution.block(0).size());</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;double&gt; schur_rhs(solution.block(1).size());</div><div class="line">      A_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line">      SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div><div class="line">        system_matrix, A_inverse);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div><div class="line">                                <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">      InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div><div class="line">        preconditioner_matrix.block(1, 1), preconditioner);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      A_inverse.vmult(solution.block(0), tmp);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell,</div><div class="line">      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(pressure));</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.0);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div><div class="line">      subdivisions[0] = 4;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, -1) :    <span class="comment">// 2d case</span></div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, 0, -1)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 1, 0)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                                subdivisions,</div><div class="line">                                                bottom_left,</div><div class="line">                                                top_right);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;center()[dim - 1] == 0)</div><div class="line">          face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4 - dim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step22</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step22;</div><div class="line"></div><div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>, <a class="el" href="step_21.html">step-21</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Weakform">Weak form</a>
        <li><a href="#Boundaryconditions">Boundary conditions</a>
        <li><a href="#Discretization">Discretization</a>
        <li><a href="#Linearsolverandpreconditioningissues">Linear solver and preconditioning issues</a>
      <ul>
        <li><a href="#IsthishowoneshouldsolvetheStokesequations"> Is this how one should solve the Stokes equations? </a>
        <li><a href="#Anoteonthestructureofthelinearsystem"> A note on the structure of the linear system </a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#Implementation">Implementation</a>
      <ul>
        <li><a href="#UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions">Using imhomogeneous constraints for implementing Dirichlet boundary conditions</a>
        <li><a href="#UsingAffineConstraintsforincreasingperformanceh4h4UsingAffineConstraintsforincreasingperformance">Using AffineConstraints for increasing performance</h4><h4>Using AffineConstraints for increasing performance</a>
        <li><a href="#Performanceoptimizations">Performance optimizations</a>
    </ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Definingtheinnerpreconditionertype">Defining the inner preconditioner type</a>
        <li><a href="#ThecodeStokesProblemcodeclasstemplate">The <code>StokesProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#ThecodeSchurComplementcodeclasstemplate">The <code>SchurComplement</code> class template</a>
      </ul>
        <li><a href="#StokesProblemclassimplementation">StokesProblem class implementation</a>
      <ul>
        <li><a href="#StokesProblemStokesProblem">StokesProblem::StokesProblem</a>
        <li><a href="#StokesProblemsetup_dofs">StokesProblem::setup_dofs</a>
        <li><a href="#StokesProblemassemble_system">StokesProblem::assemble_system</a>
        <li><a href="#StokesProblemsolve">StokesProblem::solve</a>
        <li><a href="#StokesProblemoutput_results">StokesProblem::output_results</a>
        <li><a href="#StokesProblemrefine_mesh">StokesProblem::refine_mesh</a>
        <li><a href="#StokesProblemrun">StokesProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Outputoftheprogramandgraphicalvisualization">Output of the program and graphical visualization</a>
      <ul>
        <li><a href="#2Dcalculations">2D calculations</a>
        <li><a href="#3Dcalculations">3D calculations</a>
      </ul>
        <li><a href="#Sparsitypattern">Sparsity pattern</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Improvedlinearsolverin3Dh4h4Improvedlinearsolverin3D">Improved linear solver in 3D</h4><h4>Improved linear solver in 3D</a>
      <ul>
        <li><a href="#BetterILUdecompositionbysmartreorderingh5h5BetterILUdecompositionbysmartreordering">Better ILU decomposition by smart reordering</h5><h5>Better ILU decomposition by smart reordering</a>
        <li><a href="#BetterpreconditionerfortheinnerCGsolver">Better preconditioner for the inner CG solver</a>
        <li><a href="#BlockSchurcomplementpreconditioner">Block Schur complement preconditioner</a>
        <li><a href="#Combiningtheblockpreconditionerandmultigrid">Combining the block preconditioner and multigrid</a>
        <li><a href="#Noblockmatricesandvectors">No block matrices and vectors</a>
      </ul>
        <li><a href="#Moreinterestingtestcases">More interesting testcases</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-22/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Martin Kronbichler and Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The California Institute of Technology. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p></p>
<p>这个程序处理斯托克斯方程组，其非维度形式如下。</p>
<p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; \textbf{f}, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \end{eqnarray*}
</p>
<p>其中 \(\textbf u\) 表示流体的速度， \(p\) 是其压力， \(\textbf f\) 是外力， \(\varepsilon(\textbf{u})= \nabla^s{\textbf{u}}= \frac 12 \left[ (\nabla \textbf{u}) + (\nabla \textbf{u})^T\right]\) 是对称梯度的第2级张量；它的分量定义是 \(\varepsilon(\textbf{u})_{ij}=\frac 12\left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}\right)\) 。</p>
<p>斯托克斯方程描述了缓慢移动的粘性流体的稳态运动，如蜂蜜、地幔中的岩石，或其他惯性不起作用的情况。如果流体的运动速度足够快，与粘性摩擦力相比，惯性力很重要，那么斯托克斯方程就不再有效；考虑到惯性效应，就会产生非线性纳维-斯托克斯方程。然而，在这个教程程序中，我们将重点关注更简单的斯托克斯系统。</p>
<p>请注意，在推导更一般的可压缩纳维-斯托克斯方程时，扩散被建模为应力张量的发散。</p>
<p class="formulaDsp">
\begin{eqnarray*} \tau = - \mu (2\varepsilon(\textbf{u}) - \frac{2}{3}\nabla \cdot \textbf{u} I), \end{eqnarray*}
</p>
<p>其中 \(\mu\) 是流体的粘度。有了 \(\mu=1\) 的假设（假设粘度恒定，通过除以 \(\mu\) 使方程非立体化），并假设不可压缩性（ \(\textrm{div}\; \textbf{u}=0\) ），我们就可以得出上面的公式。</p>
<p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}). \end{eqnarray*}
</p>
<p>一个不同的公式使用拉普拉斯算子（ \(-\triangle \textbf{u}\) ）而不是对称梯度。这里一个很大的区别是，速度的不同分量并不耦合。如果你假定解的额外规律性 \(\textbf{u}\) （第二部分导数存在并且是连续的），这些公式是等同的。</p>
<p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}) = -\triangle \textbf{u} + \nabla \cdot (\nabla\textbf{u})^T = -\triangle \textbf{u}. \end{eqnarray*}
</p>
<p>这是因为 \(i\) 中的第1个条目 \(\nabla \cdot (\nabla\textbf{u})^T\) 是由以下内容给出的。</p>
<p class="formulaDsp">
\begin{eqnarray*} [\nabla \cdot (\nabla\textbf{u})^T]_i = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})^T]_{i,j} = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})]_{j,i} = \sum_j \frac{\partial}{\partial x_j} \frac{\partial}{\partial x_i} \textbf{u}_j = \sum_j \frac{\partial}{\partial x_i} \frac{\partial}{\partial x_j} \textbf{u}_j = \frac{\partial}{\partial x_i} \textrm{div}\; \textbf{u} = 0. \end{eqnarray*}
</p>
<p>如果你不能假设上述的规律性，或者你的粘度不是一个常数，那么这个等价关系就不再成立。因此，我们决定在本教程中坚持使用物理上更准确的对称张量公式。</p>
<p>为了得到良好的解决，我们将不得不在方程中加入边界条件。一旦我们讨论方程的微弱形式，哪些边界条件在这里是容易做到的就会变得清晰。</p>
<p>这里所涉及的方程属于矢量值问题的范畴。这个主题的顶层概述可以在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中找到。</p>
<p><a class="anchor" id="Weakform"></a></p><h3>Weak form</h3>
<p></p>
<p>通过将其写成矢量形式，可以得到方程的弱形式为</p>
<p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p} \\ {-\textrm{div}\; \textbf{u}} \end{pmatrix} = \begin{pmatrix} {\textbf{f}} \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p>从左边开始与一个矢量值测试函数 \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) 形成点积，并在域 \(\Omega\) 上进行积分，得到以下一组方程。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p>这对所有的测试函数都必须成立 \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) 。</p>
<p>一般来说，一个好的经验法则是，如果一个人<em>can</em>减少公式中任何变量的导数，那么他<em>should</em>实际上是用部分积分来做。这是由<a href="https://en.wikipedia.org/wiki/Partial_differential_equation">partial differential equations</a>的理论引起的，特别是强和<a href="https://en.wikipedia.org/wiki/Weak_solution">weak solutions</a>之间的区别）。我们已经为拉普拉斯方程做了这个工作，在那里我们对第二导数进行了分项积分，以获得在测试和试验函数上都只有一个导数的弱表述。</p>
<p>在当前情况下，我们对第二项进行分项积分。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\textbf{v}, -2\; \textrm{div}\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega. \end{eqnarray*}
</p>
<p>同样地，我们对第一项进行分项积分，得到</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p>其中，两个张量值的量之间的标量乘积在此定义为</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} = 2 \int_\Omega \sum_{i,j=1}^d \frac{\partial v_j}{\partial x_i} \varepsilon(\textbf{u})_{ij} \ dx. \end{eqnarray*}
</p>
<p>利用这一点，我们现在已经将对我们的变量的要求降低到 \(\mathbf u,\mathbf v\) 的一阶导数，而对 \(p,q\) 完全没有导数。</p>
<p>因为像 \(\nabla\textbf{v}\) 这样的一般张量和 \(\varepsilon(\textbf{u})\) 这样的对称张量之间的标量积等于两者的对称形式之间的标量积，我们也可以把上面的双线性形式写成如下。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p>我们将在下一节处理边界条款，但从域条款中已经可以看出</p>
<p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} \end{eqnarray*}
</p>
<p>的双线性形式，斯托克斯方程产生一个对称的双线性形式，并因此产生一个对称的（如果是不确定的）系统矩阵。</p>
<p><a class="anchor" id="Boundaryconditions"></a></p><h3>Boundary conditions</h3>
<p></p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.5.html">video lecture 21.5</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) （ See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.55.html">video lecture 21.55</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html">video lecture 21.6</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html">video lecture 21.65</a>.) 。</dd></dl>
<p>刚刚导出的弱形式立即为我们提供了施加边界条件的不同可能性。</p><ol>
<li>
<p class="startli">迪里希特速度边界条件。在一个部分 \(\Gamma_D\subset\partial\Omega\) ，我们可以对速度 \(\textbf u\) 施加迪里希特条件。</p>
<p class="formulaDsp">
\begin{eqnarray*} \textbf u = \textbf g_D \qquad\qquad \textrm{on}\ \Gamma_D. \end{eqnarray*}
</p>
<p>因为测试函数 \(\textbf{v}\) 来自解变量的切线空间，我们有 \(\textbf{v}=0\) 对 \(\Gamma_D\) ，因此有 </p><p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_D} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_D} = 0. \end{eqnarray*}
</p>
<p>。</p>
<p>换句话说，像往常一样，强加的边界值并没有出现在弱形式中。</p>
<p>值得注意的是，如果我们在整个边界上施加迪里希特边界值，那么压力就只能确定到一个常数。这方面的算法实现将使用类似于步骤11中的工具。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">诺伊曼型或自然边界条件。在边界的其余部分 \(\Gamma_N=\partial\Omega\backslash\Gamma_D\) ，让我们把边界条款重新写成如下。 </p><p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_N} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_N} &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i=1}^d (n_i v_i, p)_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i,j=1}^d (n_i v_j, p \delta_{ij})_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d (n_i v_j,p \delta_{ij} - 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} \\ &amp;=&amp; (\textbf{n} \otimes \textbf{v}, p \textbf{I} - 2\; \varepsilon(\textbf{u}))_{\Gamma_N}. \\ &amp;=&amp; (\textbf{v}, \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})])_{\Gamma_N}. \end{eqnarray*}
</p>
<p>换句话说，在边界的诺伊曼部分，我们可以规定总应力的数值。 </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] = \textbf g_N \qquad\qquad \textrm{on}\ \Gamma_N. \end{eqnarray*}
</p>
<p>如果边界被细分为Dirichlet和Neumann部分 \(\Gamma_D,\Gamma_N\) ，这就导致了以下弱形式。 </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N}. \end{eqnarray*}
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">罗宾式边界条件。罗宾式边界条件是迪里切特和诺伊曼边界条件的混合物。它们将读作 </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] = \textbf S \textbf u \qquad\qquad \textrm{on}\ \Gamma_R, \end{eqnarray*}
</p>
<p>。</p>
<p>有一个等级2的张量（矩阵） \(\textbf S\) 。相关的弱形式是 </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} + (\textbf S \textbf u, \textbf{v})_{\Gamma_R} = (\textbf{v}, \textbf{f})_\Omega. \end{eqnarray*}
</p>
<p> 。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">部分边界条件。可以通过只对速度的某些分量强制执行Dirichlet和Neumann边界条件来结合它们。例如，施加人工边界条件的一种方法是要求流动垂直于边界，即切向分量 \(\textbf u_{\textbf t}=(\textbf 1-\textbf n\otimes\textbf n)\textbf u\) 为零，从而约束速度的 <code>dim</code> -1分量。剩下的分量可以通过要求法向应力的法向分量为零来约束，产生以下一组边界条件。 </p><p class="formulaDsp">
\begin{eqnarray*} \textbf u_{\textbf t} &amp;=&amp; 0, \\ \textbf n \cdot \left(\textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] \right) &amp;=&amp; 0. \end{eqnarray*}
</p>
<pre class="fragment">另一种情况是当人们希望流动是&lt;i&gt;parallel&lt;/i&gt;而不是垂直于边界时（在deal.II中， VectorTools::compute_no_normal_flux_constraints 函数可以为你这样做）。这种情况经常发生在自由边界的问题上（例如，在河流或湖泊的表面，如果流动的垂直力不足以使表面实际变形），或者如果边界对流体没有施加明显的摩擦力（例如，在地幔和地核的界面上，两种流体因密度不同而相遇，但它们的粘度都很小，不会对彼此产生很大的切向应力）。     在公式中，这意味着 \form#2967@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl@_fakenl

第一个条件（需要强加）固定了速度的一个分量，第二个条件（将在弱形式下强制执行）固定了其余的两个分量。   &lt;/ol&gt; 
</pre><p>尽管有这么多的可能性，我们在这个教程程序中只使用迪里希特和（同质）诺伊曼边界条件。</p>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p></p>
<p>如上所述，在 \(\Gamma_D\) 和 \(\Gamma_N\) 上有迪里希特和诺伊曼边界条件的方程的弱形式是这样的：找到 \(\textbf u\in \textbf V_g = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=\textbf g_D\}, p\in Q=L^2(\Omega)\) ，以便</p>
<p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p>为所有测试函数 \(\textbf{v}\in \textbf V_0 = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=0\},q\in Q\) 。</p>
<p>这些方程代表一个对称的<a href="https://en.wikipedia.org/wiki/Ladyzhenskaya%E2%80%93Babu%C5%A1ka%E2%80%93Brezzi_condition">saddle point problem</a>。众所周知，那么只有当我们寻找解决方案的函数空间必须满足某些条件时，解决方案才会存在，这些条件通常被称为Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件。上面的连续函数空间满足这些条件。然而，当我们将方程离散化，用有限维空间中的有限元函数取代连续变量和检验函数 \(\textbf V_{g,h}\subset \textbf V_g, Q_h\subset Q\) 时，我们必须确保 \(\textbf V_h,Q_h\) 也满足LBB条件。这与我们在第20步中要做的事情类似。</p>
<p>对于斯托克斯方程，有许多可能的选择来确保有限元空间与LBB条件兼容。一个简单而准确的选择是 \(\textbf u_h\in Q_{p+1}^d, p_h\in Q_p\) ，即对速度使用比压力高一阶的元素。</p>
<p>这就导致了以下的离散问题：找到 \(\textbf u_h,p_h\) ，以便于</p>
<p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}_h), 2\; \varepsilon(\textbf u_h))_{\Omega} - (\textrm{div}\; \textbf{v}_h, p_h)_{\Omega} - (q_h,\textrm{div}\; \textbf{u}_h)_{\Omega} = (\textbf{v}_h, \textbf{f})_\Omega - (\textbf{v}_h, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p>为所有测试函数 \(\textbf{v}_h, q_h\) 。组装与此问题相关的线性系统遵循 <a class="el" href="step_20.html">步骤-20</a>、步骤-21中使用的相同路线，并在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中详细解释。</p>
<p><a class="anchor" id="Linearsolverandpreconditioningissues"></a></p><h3>Linear solver and preconditioning issues</h3>
<p></p>
<p>离散方程的微弱形式自然导致了以下速度场和压力场的节点值的线性系统。</p>
<p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p>与第20步和第21步一样，我们将通过形成舒尔补数来解决这个方程组，也就是说，我们将首先找到 \(P\) 的解。</p>
<p class="formulaDsp">
\begin{eqnarray*} BA^{-1}B^T P &amp;=&amp; BA^{-1} F - G, \\ \end{eqnarray*}
</p>
<p>然后</p>
<p class="formulaDsp">
\begin{eqnarray*} AU &amp;=&amp; F - B^TP. \end{eqnarray*}
</p>
<p>我们这样做的方式与我们在以前的这些教程程序中做的差不多，也就是说，我们再次使用相同的类 <code>SchurComplement</code> 和 <code>InverseMatrix</code> 。然而，有两个显著的区别。</p>
<ol>
<li>
<p class="startli">首先，在混合拉普拉斯方程中，我们必须处理如何对舒尔补数 \(B^TM^{-1}B\) 进行预处理的问题，它在谱上等同于压力空间上的拉普拉斯算子（因为 \(B\) 代表梯度算子， \(B^T\) 代表其邻接算子 \(-\textrm{div}\) ，而 \(M\) 代表身份（直到材料参数 \(K^{-1}\) 为止），因此 \(B^TM^{-1}B\) 类似于 \(-\textrm{div} \mathbf 1 \nabla = -\Delta\) ）。因此，对于小的网格尺寸来说，矩阵的条件很差，我们不得不为Schur补数提出一个精心设计的预处理方案。</p>
<p class="endli"></p>
</li>
<li>
其次，每次我们与 \(B^TM^{-1}B\) 相乘时，我们必须用质量矩阵 \(M\) 来解决。然而，这并不特别困难，因为质量矩阵总是有很好的条件的，所以使用CG和一点点预处理就能简单地反转。 换句话说， </li>
</ol>
<p>的内部求解器的预处理很简单，而 \(B^TM^{-1}B\) 的外部求解器的预处理很复杂。</p>
<p>在这里，情况几乎完全相反。差异源于这样一个事实，即舒尔补码的核心矩阵不是来自身份算子，而是来自拉普拉斯算子的一个变体， \(-\textrm{div} \nabla^s\) （其中 \(\nabla^s\) 是对称梯度），作用于一个矢量场。在对这个问题的研究中，我们主要遵循D. Silvester和A. Wathen的论文。"稳定的斯托克斯系统的快速迭代解第二部分。使用一般块状先决条件"。(SIAM J. Numer.Anal., 31 (1994), pp. 1352-1367)，可在线查阅<a href="http://siamdl.aip.org/getabs/servlet/GetabsServlet?prog=normal&amp;id=SJNAAM000031000005001352000001&amp;idtype=cvips&amp;gifs=Yes" target="_top">here</a>。主要来说，舒尔补码的核心矩阵的差异有两个后果。</p>
<ol>
<li>
<p class="startli">首先，它使外部预处理变得简单：Schur补数对应于压力空间上的算子 \(-\textrm{div} (-\textrm{div} \nabla^s)^{-1} \nabla\) ；忘记我们处理的是对称梯度而不是常规梯度的事实，Schur补数类似于 \(-\textrm{div} (-\textrm{div} \nabla)^{-1} \nabla = -\textrm{div} (-\Delta)^{-1} \nabla\) ，即使在数学上不完全简明，在光谱上也等同于身份算子（一个启发式的论证是将算子换算成 \(-\textrm{div}(-\Delta)^{-1} \nabla = -\textrm{div}\nabla(-\Delta)^{-1} = -\Delta(-\Delta)^{-1} = \mathbf 1\) ）。事实证明，用CG方法直接解决这个Schur补数并不容易：在没有预处理的情况下，Schur补数矩阵的条件数取决于最大和最小单元的大小比，而且仍然需要50-100次CG迭代。然而，有一个简单的解决办法：用压力空间上的质量矩阵进行预处理，我们就可以减少到5-15次CG迭代，几乎不受网格结构的影响（看看这个程序的<a href="#Results">results section</a>，可以看到CG迭代的数量确实不会随着我们细化网格而改变）。</p>
<p>因此，除了我们已经有的东西之外，我们需要的是压力变量上的质量矩阵，我们将把它存储在一个单独的对象中。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">虽然与第20步讨论的混合拉普拉斯情况相比，外部预调节器变得简单了，但内部求解器的问题却变得更加复杂。在混合拉普拉斯离散化中，舒尔补数的形式为 \(B^TM^{-1}B\) 。因此，每当我们与舒尔补码相乘时，我们必须解决一个线性系统 \(M_uz=y\) ；然而，这并不太复杂，因为压力空间上的质量矩阵 \(M_u\) 是有条件的。</p>
<p>另一方面，对于我们这里考虑的斯托克斯方程，舒尔补码是 \(BA^{-1}B^T\) ，其中矩阵 \(A\) 与拉普拉斯算子有关（事实上，它是对应于双线性形式 \((\nabla^s \varphi_i, \nabla^s\varphi_j)\) 的矩阵）。因此，用 \(A\) 求解要复杂得多：矩阵的条件很差，我们知道我们需要很多迭代，除非我们有一个非常好的预处理程序。更糟糕的是，我们每次与舒尔补码相乘时都要用 \(A\) 求解，使用上述的预处理程序需要5-15次。</p>
<p>因为我们必须多次用 \(A\) 求解，所以多花一次时间为这个矩阵创建一个好的预处理程序是值得的。所以我们要做的是：如果在2d中，我们使用终极预处理程序，即矩阵的直接稀疏LU分解。这是用SparseDirectUMFPACK类实现的，它使用UMFPACK直接求解器来计算分解。要使用它，你必须建立支持UMFPACK的deal.II（这是默认的）；参见<a href="../../readme.html#optional-software">ReadMe file</a>中的说明。有了它，内解器在一次迭代中就能收敛。</p>
<p>在2D中，我们可以做这种事情，因为即使是合理的大问题，也很少有超过100,000个未知数的，每行的非零项相对较少。此外，2D中矩阵的带宽是 \({\cal O}(\sqrt{N})\) ，因此是中等的。对于这样的矩阵，稀疏因子可以在几秒钟内计算出来。作为参考，计算一个大小为 \(N\) 、带宽为 \(B\) 的矩阵的稀疏因子需要 \({\cal O}(NB^2)\) 次操作。在2d中，这是 \({\cal O}(N^2)\) ；尽管这比例如组装线性系统的复杂度要高，后者需要 \({\cal O}(N)\) ，但计算分解的常数非常小，直到我们达到非常大的未知数，甚至更多，它才成为整个程序中的主导因素）。)</p>
<p>情况在3D中发生了变化，因为在那里我们很快就会有更多的未知数，而且矩阵的带宽（决定了稀疏LU因子中非零项的数量）是 \({\cal O}(N^{2/3})\) ，而且每行也有很多条目。这使得像UMFPACK这样的稀疏直接求解器的效率很低：只有在问题规模为10,000到100,000个未知数时，才能用合理的时间和内存资源计算稀疏分解。</p>
<p class="endli">在这种情况下，我们要做的是使用一个不完整的LU分解（ILU）作为预处理，而不是实际计算完整的LU因子。恰好，deal.II有一个类可以做到这一点。SparseILU。计算ILU所需要的时间只取决于稀疏矩阵中的非零项的数量（或者说我们愿意填入LU因子，如果这些非零项应该多于矩阵中的非零项），但与矩阵的带宽无关。因此，这也是一个可以有效地在三维中计算的操作。另一方面，根据定义，一个不完整的LU分解并不代表矩阵的精确逆 \(A\) 。因此，与稀疏直接求解器的预处理不同，用ILU进行预处理仍然需要一次以上的迭代。因此，当与舒尔补码相乘时，内解器将花费更多时间：这是一个不可避免的权衡。 </p>
</li>
</ol>
<p>在下面的程序中，我们将利用SparseILU和SparseDirectUMFPACK类具有非常相似的接口，可以互换使用的事实。我们所需要的是一个开关类，根据维度的不同，提供一个类型，即上述两个类中的任何一个。我们就是这样做的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">};</div></div><!-- fragment --><p>从这里开始，我们可以引用<code>typename InnerPreconditioner&lt;dim&gt;::type</code> 这个类型，并自动得到正确的预处理程序类。由于这两个类的接口相似，我们将能够在所有地方使用相同的语法来互换使用它们。</p>
<p><a class="anchor" id="IsthishowoneshouldsolvetheStokesequations"></a></p><h4>Is this how one should solve the Stokes equations? </h4>
<p></p>
<p>上面的讨论显示了解决由斯托克斯方程产生的线性系统的*种方式，由于辅导程序是教学工具，这是有意义的。但这是解决这个方程组的**方式吗？</p>
<p>这个问题的答案是否定的。上面已经指出了这个方法的主要瓶颈，就是我们必须反复求解Schur补数内的 \(A\) 线性系统，由于我们没有一个好的Schur补数的预处理程序，这些求解就不得不经常发生。一个更好的方法是使用块分解，这是基于Silvester和Wathen <b>[SW94]</b> 的观察，在 <b>[elman2005]</b> 中有更详细的解释。下面在本程序的结果部分的a <a href="#block-schur">block Schur complementation preconditioner</a>一节中讨论了这种替代方法的实现。</p>
<p><a class="anchor" id="Anoteonthestructureofthelinearsystem"></a></p><h4>A note on the structure of the linear system </h4>
<p></p>
<p>以上，我们已经声称线性系统的形式是</p>
<p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p>即，特别是在矩阵的右下方有一个零块。这样，我们就可以把舒尔补码写成 \(S=B A^{-1} B^T\) 。但这并不完全正确。</p>
<p>想一想，如果对某些压力变量有约束会怎样（见 <a class="el" href="group__constraints.html">自由度的约束 </a>文件模块），例如因为我们使用自适应细化网格和连续压力有限元，所以会有悬挂节点。造成这种约束的另一个原因是压力的迪里希特边界条件。然后，AffineConstraints类，在将矩阵的局部贡献复制到全局线性系统时，会将对应于受限自由度的行和列清零，并在对角线上放一个正条目。为了简单起见，你可以认为这个条目是1，尽管实际上它是一个与其他矩阵条目相同数量级的值）。换句话说，右下角区块其实根本不是空的：它在对角线上有几个条目，每个受限的压力自由度都有一个，对我们要解决的线性系统的正确描述是，它的形式如下</p>
<p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; D_c \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p>其中 \(D_c\) 是零矩阵，除了受限自由度的正对角线项。那么正确的舒尔补码实际上是矩阵 \(S = B A^{-1} B^T - D_c \) ，而不是上面说的那个。</p>
<p>思考这个问题使我们，首先，意识到所得到的舒尔补数现在是不确定的，因为 \(B A^{-1} B^T\) 是对称的和正定的，而 \(D_c\) 是正半定的，从前者减去后者可能不再是正定的。这很烦人，因为我们不能再对这个真正的舒尔补数采用共轭梯度法。也就是说，我们可以在 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 中通过简单地将*负*值放在受限压力变量的对角线上来解决这个问题&ndash;因为我们实际上只是放了一些非零的东西来确保结果矩阵不是奇异的；我们真的不关心那个条目是正还是负。因此，如果 \(D_c\) 的对角线上的条目是负的，那么 \(S\) 将再次成为一个对称的正定矩阵。</p>
<p>但是，其次，下面的代码实际上并没有做这些事。它很高兴地用错误的Schur补码 \(S = B A^{-1} B^T\) 来解决线性系统，完全忽略了这个问题。为什么会这样呢？为了理解为什么会这样，回顾一下，当把局部贡献写入全局矩阵时， <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 把对应于受限自由度的行和列置零。这意味着 \(B\) 有一些零行， \(B^T\) 零列。因此，如果要乘出 \(S\) 的条目是什么，就会发现它的所有受限压力自由度的行和列都是零，包括对角线上的一个零。 \(D_c\) 的非零条目将正好适合于这些零对角线位置，并确保 \(S\) 是可逆的。不这样做，严格来说，意味着 \(S\) 仍然是单数。它在非约束压力自由度子集上是对称和正定的，而在约束压力上只是一个零矩阵。为什么共轭梯度法对这个矩阵有效？因为 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 也确保了对应于矩阵这些零行的右手边条目*也是零，也就是说，右手边是兼容的。</p>
<p>这意味着无论这些受限压力自由度的解向量的值是多少，这些行的残差总是为零，如果考虑到CG算法的内部操作，就永远不会对解向量产生任何更新。换句话说，CG算法只是*忽略*这些行，尽管矩阵是单数。这只是因为这些自由度与线性系统的其他部分完全解耦（因为整个行和相应的列都是零）。在求解过程结束时，求解向量中的受限压力值仍然和我们开始调用求解器时一模一样；当我们在CG求解器完成后调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 时，它们最终被正确的值所覆盖。</p>
<p>这个讨论的结果是，大矩阵的右下角块为零的假设有点简化，但仅仅按照这个假设，实际上并没有导致任何值得解决的实际问题。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p></p>
<p>我们下面实现的域、右手边和边界条件与地球物理学中的一个问题有关：在那里，人们想计算大洋中裂缝下地球内部岩浆的流动场。裂缝是两个大陆板块非常缓慢地漂移开来的地方（每年最多几厘米），在地壳上留下一个裂缝，被下面的岩浆填充。在不试图完全现实的情况下，我们通过求解域 \(\Omega=[-2,2]\times[0,1]\times[-1,0]\) 上的以下一组方程和边界条件来模拟这种情况。</p>
<p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; 0, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} -1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&lt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} +1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&gt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} 0 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x=0, \end{eqnarray*}
</p>
<p>并在其他地方使用自然边界条件 \(\textbf{n}\cdot [p \textbf{I} - 2 \varepsilon(\textbf{u})] = 0\) 。换句话说，在顶面的左边部分，我们规定流体以速度 \(-1\) 随大陆板向左移动，在顶面的右边部分向右移动，并在其他地方施加自然流动条件。如果我们在2d中，描述基本上是相同的，只是我们省略了上述所有矢量的第二部分。</p>
<p>正如在<a href="#Results">results section</a>中会变得很明显的那样，流场将从下面拉动材料，并将其移动到域的左右两端，这是预期的。速度边界条件的不连续性将在顶面中心产生一个压力奇点，将材料一直吸到顶面，以填补材料在此位置向外运动所留下的缺口。</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p></p>
<p><a class="anchor" id="UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions"></a></p><h4>Using imhomogeneous constraints for implementing Dirichlet boundary conditions</h4>
<p></p>
<p>在之前的所有教程程序中，我们仅仅使用AffineConstraints对象来处理悬挂节点约束（步骤11除外）。然而，这个类也可以用来实现Dirichlet边界条件，正如我们将在这个程序中展示的，通过固定一些节点值 \(x_i = b_i\) 。注意，这些是不均匀约束，我们要特别注意一些。我们要实现的方法是，首先通过调用AffineConstraints对象读入边界值</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          1,</div><div class="line">                                          BoundaryValues&lt;dim&gt;(),</div><div class="line">                                          constraints);</div></div><!-- fragment --><p>非常类似于我们之前制作边界节点列表的方式（注意，我们只在边界标志为1的边界上设置Dirichlet条件）。然后边界值的实际应用由AffineConstraints对象直接处理，没有任何额外的干扰。</p>
<p>然后我们可以像以前一样进行，即通过填充矩阵，然后在约束对象上调用一个浓缩函数，其形式为</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (system_matrix, system_rhs);</div></div><!-- fragment --><p>请注意，我们在系统矩阵和系统右侧同时调用，因为解决不均匀约束需要对矩阵条目和右侧的知识。但出于效率的考虑，我们选择了另一种策略：所有收集在AffineConstraints对象中的约束都可以在将本地数据写入全局矩阵的同时得到解决，方法是使用调用</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a> (local_matrix, local_rhs,</div><div class="line">                                        local_dof_indices,</div><div class="line">                                        system_matrix, system_rhs);</div></div><!-- fragment --><p>这个技术在<a class="el" href="step_27.html">step-27</a>教程程序中进一步讨论。我们在这里需要知道的是，这个函数同时做了三件事：它把局部数据写入全局矩阵和右手边，它分布了悬挂的节点约束，另外还实现了（不均匀的）迪里切特边界条件。这很好，不是吗？</p>
<p>我们可以得出结论，AffineConstraints类提供了一个替代使用 <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> 来实现Dirichlet边界条件的方法。</p>
<p><a class="anchor" id="constraint-matrix"></a></p>
<p><a class="anchor" id="UsingAffineConstraintsforincreasingperformanceh4h4UsingAffineConstraintsforincreasingperformance"></a></p><h4>Using <a class="el" href="classAffineConstraints.html">AffineConstraints</a> for increasing performance</h4>
<h4>Using <a class="el" href="classAffineConstraints.html">AffineConstraints</a> for increasing performance</h4>
<p></p>
<p>。</p>
<p>通常，稀疏矩阵包含大量的元素，当我们要开始线性求解时，这些元素实际上是零。这样的元素是在我们消除约束条件或实现Dirichlet条件时引入的，我们通常会删除受约束行和列中的所有条目，即把它们设置为零。对于本教程程序中所考虑的三维应用，存在于稀疏模式中但并不真正包含任何信息的那部分元素，可以达到矩阵中元素总数的四分之一。请记住，矩阵-向量乘积或预处理程序对稀疏矩阵的所有元素（甚至那些为零的元素）进行操作，这是我们在这里要避免的低效率。</p>
<p>直接解决约束自由度的一个好处是，我们可以避免在我们的稀疏矩阵中出现大部分要为零的条目&amp;mdash；在矩阵构建过程中，我们不需要约束的条目（与传统算法相反，传统算法是先填充矩阵，之后才解决约束）。这将在形成矩阵-向量乘积时节省内存和时间。我们要做的是将约束信息传递给生成稀疏模式的函数，然后设置一个<code>false</code>参数，指定我们不打算使用约束条目。</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern,</div><div class="line">                                 constraints, <span class="keyword">false</span>);</div></div><!-- fragment --><p>顺便说一下，这个函数也避免了对稀疏模式的<code>condense()</code>函数的调用。</p>
<p><a class="anchor" id="Performanceoptimizations"></a></p><h4>Performance optimizations</h4>
<p></p>
<p>下面开发的程序已经看到了很多的TLC。我们在分析工具（主要是<a href="http://www.valgrind.org/">valgrind</a>的cachegrind和callgrind工具，以及用于可视化的KDE<a href="http://kcachegrind.sourceforge.net/">KCachegrind</a>程序）下一遍又一遍地运行它，看看瓶颈在哪里。这已经得到了回报：通过这种努力，当考虑到细化周期0到3的运行时间时，程序的速度已经提高了大约4倍，将CPU指令的总体执行数量从869,574,060,348减少到199,853,005,625。对于更高的细化水平，收益可能更大，因为一些不是 \({\cal O}(N)\) 的算法被取消了。</p>
<p>基本上，目前程序中有两种算法不随自由度数量的增加而线性扩展：自由度的重新编号（即 \({\cal O}(N \log N)\) ，以及线性求解器（即 \({\cal O}(N^{4/3})\) ）。至于第一个，虽然自由度的重新排序可能不是线性扩展，但它是整个算法中不可缺少的部分，因为它极大地提高了稀疏ILU的质量，很容易弥补计算重新编号的时间；证明这一点的图表和时间显示在DoFRenumbering命名空间的文档中，也强调了下面选择的Cuthill-McKee重新排序算法。</p>
<p>至于线性求解器：如上所述，我们在这里的实现使用了Schur补码公式。这不一定是非常好的选择，但展示了deal.II中的各种重要技术。关于哪种求解器最好的问题，在本程序的<a href="#improved-solver">section on improved solvers in the results part</a>中再次进行了讨论，同时还有显示备选求解器的代码和对其结果的比较。</p>
<p>除此以外，在这个程序的创建过程中，许多其他的算法也被测试和改进。例如，在建立稀疏性模式时，我们最初使用了一个（现在已经不存在了）BlockCompressedSparsityPattern对象，每次增加一个元素；然而，它的数据结构对于我们在3d中离散化所产生的每行大量的非零条目来说适应性很差，导致了一个二次方的行为。替换deal.II中的内部算法，一次设置许多元素，并使用BlockCompressedSimpleSparsityPattern（截至2015年初，它又被BlockDynamicSparsityPattern取代）作为一个更好的适应性数据结构，消除了这个瓶颈，代价是内存消耗略高。同样，SparseILU类中的分解步骤的实现也非常低效，已经被一个快10倍的步骤所取代。甚至SparseILU的vmult函数也得到了改进，节省了大约20的时间。小的改进在这里和那里被应用。此外，AffineConstraints对象被用来消除稀疏矩阵中很多最终将为零的条目，见<a href="#constraint-matrix">the section on using advanced features of the AffineConstraints class</a>。</p>
<p>这里显示了在3D的细化周期0到3中，CPU指令在程序中各个不同的地方花费了多少的概况。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.png"/>
</div>
<p>可以看出，在这个细化级别，大约四分之三的指令数花在实际求解上（左边的 <a class="el" href="classSparseILU.html#aa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> 调用，中间的 <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult</a> 调用用于舒尔补码求解，另一个方框代表在求解<em>U</em>时与稀疏ILU和稀疏矩阵的乘法）。大约五分之一的指令数用于矩阵装配和稀疏ILU计算（右下角的方框），其余的用于其他方面。由于 <a class="el" href="classSparseILU.html#aa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> 调用中的浮点运算通常比矩阵装配中的许多逻辑运算和查表要长得多，矩阵装配所占用的运行时间的比例实际上大大低于指令的比例，这在我们在结果部分的比较中会变得很明显。</p>
<p>对于更高的细化水平，代表求解器的方框以及右上角源自重排算法的蓝色方框将以牺牲程序的其他部分为代价而增长，因为它们不是线性扩展。在这个中等细化水平（3168个单元和93176个自由度），线性求解器已经占了大约四分之三的指令，这是一个很好的迹象，说明这个程序中使用的大多数算法都是经过良好调整的，加快程序速度的主要改进很可能不是来自手工优化的个别方面，而是通过改变求解器的算法。我们将在下面的结果讨论中也讨论这一点。</p>
<p>最后一点，作为参考，下图也显示了在优化这个程序的早期阶段，配置文件的样子。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.original.png"/>
</div>
<p>如上所述，这个版本的运行时间大约是第一个配置文件的四倍，其中SparseILU分解占用了大约30的指令数，而操作早期低效版本的DynamicSparsityPattern大约占10。这两个瓶颈后来都被完全消除了。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p></p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p></p>
<p>As usual, we start by including some well-known files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>Then we need to include the header file for the sparse direct solver UMFPACK:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div></div><!-- fragment --><p>This includes the library for the incomplete LU factorization that will be used as a preconditioner in 3D:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>As in all programs, the namespace dealii is included:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step22</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Definingtheinnerpreconditionertype"></a> </p><h3>Defining the inner preconditioner type</h3>
<p></p>
<p>As explained in the introduction, we are going to use different preconditioners for two and three space dimensions, respectively. We distinguish between them by the use of the spatial dimension as a template parameter. See <a class="el" href="step_4.html">step-4</a> for details on templates. We are not going to create any preconditioner object here, all we do is to create class that holds a local alias determining the preconditioner class so we can write our program in a dimension-independent way.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div></div><!-- fragment --><p>In 2D, we are going to use a sparse direct solver as preconditioner:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">};</div></div><!-- fragment --><p>And the ILU preconditioning in 3D, called by <a class="el" href="classSparseILU.html">SparseILU</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStokesProblemcodeclasstemplate"></a> </p><h3>The <code>StokesProblem</code> class template</h3>
<p></p>
<p>This is an adaptation of <a class="el" href="step_20.html">step-20</a>, so the main class and the data types are nearly the same as used there. The only difference is that we have an additional member <code>preconditioner_matrix</code>, that is used for preconditioning the Schur complement, and a corresponding sparsity pattern <code>preconditioner_sparsity_pattern</code>. In addition, instead of relying on <a class="el" href="classLinearOperator.html">LinearOperator</a>, we implement our own InverseMatrix class.</p>
<p>In this example we also use adaptive grid refinement, which is handled in analogy to <a class="el" href="step_6.html">step-6</a>. According to the discussion in the introduction, we are also going to use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object for implementing Dirichlet boundary conditions. Hence, we change the name <code>hanging_node_constraints</code> into <code>constraints</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div></div><!-- fragment --><p>This one is new: We shall use a so-called shared pointer structure to access the preconditioner. Shared pointers are essentially just a convenient form of pointers. Several shared pointers can point to the same object (just like regular pointers), but when the last shared pointer object to point to a preconditioner object is deleted (for example if a shared pointer object goes out of scope, if the class of which it is a member is destroyed, or if the pointer is assigned a different preconditioner object) then the preconditioner object pointed to is also destroyed. This ensures that we don't have to manually track in how many places a preconditioner object is still referenced, it can never create a memory leak, and can never produce a dangling pointer to an already destroyed object:</p>
<div class="fragment"><div class="line">  std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3>Boundary values and right hand side</h3>
<p></p>
<p>As in <a class="el" href="step_20.html">step-20</a> and most other example programs, the next task is to define the data for the PDE: For the Stokes problem, we are going to use natural boundary values on parts of the boundary (i.e. homogeneous Neumann-type) for which we won't have to do anything special (the homogeneity implies that the corresponding terms in the weak form are simply zero), and boundary conditions on the velocity (Dirichlet-type) on the rest of the boundary, as described in the introduction.</p>
<p>In order to enforce the Dirichlet boundary values on the velocity, we will use the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> function as usual which requires us to write a function object with as many components as the finite element has. In other words, we have to define the function on the \((u,p)\)-space, but we are going to filter out the pressure component when interpolating the boundary values.</p>
<p>The following function object is a representation of the boundary values described in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> (p[0] &lt; 0 ? -1 : (p[0] &gt; 0 ? 1 : 0));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p>We implement similar functions for the right hand side which for the current example is simply zero:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p></p>
<p>The linear solvers and preconditioners are discussed extensively in the introduction. Here, we create the respective objects that will be used.</p>
<p><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> </p><h4>The <code>InverseMatrix</code> class template</h4>
<p>The <code>InverseMatrix</code> class represents the data structure for an inverse matrix. Unlike <a class="el" href="step_20.html">step-20</a>, we implement this with a class instead of the helper function inverse_linear_operator() we will apply this class to different kinds of matrices that will require different preconditioners (in <a class="el" href="step_20.html">step-20</a> we only used a non-identity preconditioner for the mass matrix). The types of matrix and preconditioner are passed to this class via template parameters, and matrix and preconditioner objects of these types will then be passed to the constructor when an <code>InverseMatrix</code> object is created. The member function <code>vmult</code> is obtained by solving a linear system:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  , preconditioner(&amp;preconditioner)</div><div class="line">{}</div></div><!-- fragment --><p>This is the implementation of the <code>vmult</code> function.</p>
<p>In this class we use a rather large tolerance for the solver control. The reason for this is that the function is used very frequently, and hence, any additional effort to make the residual in the CG solve smaller makes the solution more expensive. Note that we do not only use this class as a preconditioner for the Schur complement, but also when forming the inverse of the Laplace matrix &ndash; which is hence directly responsible for the accuracy of the solution itself, so we can't choose a too large tolerance, either.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, *preconditioner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeSchurComplementcodeclasstemplate"></a> </p><h4>The <code>SchurComplement</code> class template</h4>
<p></p>
<p>This class implements the Schur complement discussed in the introduction. It is in analogy to <a class="el" href="step_20.html">step-20</a>. Though, we now call it with a template parameter <code>PreconditionerType</code> in order to access that when specifying the respective type of the inverse matrix class. As a consequence of the definition above, the declaration <code>InverseMatrix</code> now contains the second template parameter for a preconditioner class as above, which affects the <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> object <code>m_inverse</code> as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div><div class="line">    A_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div><div class="line">  : system_matrix(&amp;system_matrix)</div><div class="line">  , A_inverse(&amp;A_inverse)</div><div class="line">  , tmp1(system_matrix.block(0, 0).m())</div><div class="line">  , tmp2(system_matrix.block(0, 0).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">SchurComplement&lt;PreconditionerType&gt;::vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">                                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).vmult(tmp1, src);</div><div class="line">  A_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">  system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemclassimplementation"></a> </p><h3>StokesProblem class implementation</h3>
<p></p>
<p><a class="anchor" id="StokesProblemStokesProblem"></a> </p><h4>StokesProblem::StokesProblem</h4>
<p></p>
<p>The constructor of this class looks very similar to the one of <a class="el" href="step_20.html">step-20</a>. The constructor initializes the variables for the polynomial degree, triangulation, finite element system and the dof handler. The underlying polynomial functions are of order <code>degree+1</code> for the vector-valued velocity components and of order <code>degree</code> for the pressure. This gives the LBB-stable element pair \(Q_{degree+1}^d\times Q_{degree}\), often referred to as the Taylor-Hood element.</p>
<p>Note that we initialize the triangulation with a MeshSmoothing argument, which ensures that the refinement of cells is done in a way that the approximation of the PDE solution remains well-behaved (problems arise if grids are too unstructured), see the documentation of <code><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></code> for details.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : degree(degree)</div><div class="line">  , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemsetup_dofs"></a> </p><h4>StokesProblem::setup_dofs</h4>
<p></p>
<p>Given a mesh, this function associates the degrees of freedom with it and creates the corresponding matrices and vectors. At the beginning it also releases the pointer to the preconditioner object (if the shared pointer pointed at anything at all at this point) since it will definitely not be needed any more after this point and will have to be re-computed after assembling the matrix, and unties the sparse matrices from their sparsity pattern objects.</p>
<p>We then proceed with distributing degrees of freedom and renumbering them: In order to make the ILU preconditioner (in 3D) work efficiently, it is important to enumerate the degrees of freedom in such a way that it reduces the bandwidth of the matrix, or maybe more importantly: in such a way that the ILU is as close as possible to a real LU decomposition. On the other hand, we need to preserve the block structure of velocity and pressure already seen in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>. This is done in two steps: First, all dofs are renumbered to improve the ILU and then we renumber once again by components. Since <code><a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></code> does not touch the renumbering within the individual blocks, the basic renumbering from the first step remains. As for how the renumber degrees of freedom to improve the ILU: deal.II has a number of algorithms that attempt to find orderings to improve ILUs, or reduce the bandwidth of matrices, or optimize some other aspect. The <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace shows a comparison of the results we obtain with several of these algorithms based on the testcase discussed here in this tutorial program. Here, we will use the traditional Cuthill-McKee algorithm already used in some of the previous tutorial programs. In the <a href="#improved-ilu">section on improved ILU</a> we're going to discuss this issue in more detail.</p>
<p>There is one more change compared to previous tutorial programs: There is no reason in sorting the <code>dim</code> velocity components individually. In fact, rather than first enumerating all \(x\)-velocities, then all \(y\)-velocities, etc, we would like to keep all velocities at the same location together and only separate between velocities (all components) and pressures. By default, this is not what the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function does: it treats each vector component separately; what we have to do is group several components into "blocks" and pass this block structure to that function. Consequently, we allocate a vector <code>block_component</code> with as many elements as there are components and describe all velocity components to correspond to block 0, while the pressure component will form block 1:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  A_preconditioner.reset();</div><div class="line">  system_matrix.clear();</div><div class="line">  preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div><div class="line">  block_component[dim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div></div><!-- fragment --><p>Now comes the implementation of Dirichlet boundary conditions, which should be evident after the discussion in the introduction. All that changed is that the function already appears in the setup functions, whereas we were used to see it in some assembly routine. Further down below where we set up the mesh, we will associate the top boundary where we impose Dirichlet boundary conditions with boundary indicator</p><ol type="1">
<li>We will have to pass this boundary indicator as second argument to the function below interpolating boundary values. There is one more thing, though. The function describing the Dirichlet conditions was defined for all components, both velocity and pressure. However, the Dirichlet conditions are to be set for the velocity only. To this end, we use a <a class="el" href="classComponentMask.html">ComponentMask</a> that only selects the velocity components. The component mask is obtained from the finite element by specifying the particular components we want. Since we use adaptively refined grids, the affine constraints object needs to be first filled with hanging node constraints generated from the DoF handler. Note the order of the two functions &mdash; we first compute the hanging node constraints, and then insert the boundary values into the constraints object. This makes sure that we respect H<sup>1</sup> conformity on boundaries with hanging nodes (in three space dimensions), where the hanging node needs to dominate the Dirichlet boundary values.</li>
</ol>
<div class="fragment"><div class="line">{</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           constraints,</div><div class="line">                                           fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">}</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div></div><!-- fragment --><p>In analogy to <a class="el" href="step_20.html">step-20</a>, we count the dofs in the individual components. We could do this in the same way as there, but we want to operate on the block structure we used already for the renumbering: The function <code><a class="el" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></code> does the same as <code><a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a></code>, but now grouped as velocity and pressure block via <code>block_component</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next task is to allocate a sparsity pattern for the system matrix we will create and one for the preconditioner matrix. We could do this in the same way as in <a class="el" href="step_20.html">step-20</a>, i.e. directly build an object of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a> through <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>. However, there is a major reason not to do so: In 3D, the function DoFTools::max_couplings_between_dofs yields a conservative but rather large number for the coupling between the individual dofs, so that the memory initially provided for the creation of the sparsity pattern of the matrix is far too much &ndash; so much actually that the initial sparsity pattern won't even fit into the physical memory of most systems already for moderately-sized 3D problems, see also the discussion in <a class="el" href="step_18.html">step-18</a>. Instead, we first build temporary objects that use a different data structure that doesn't require allocating more memory than necessary but isn't suitable for use as a basis of <a class="el" href="classSparseMatrix.html">SparseMatrix</a> or <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> objects; in a second step we then copy these objects into objects of type <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>. This is entirely analogous to what we already did in <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_18.html">step-18</a>. In particular, we make use of the fact that we will never write into the \((1,1)\) block of the system matrix and that this is the only block to be filled for the preconditioner matrix.</p>
<p>All this is done inside new scopes, which means that the memory of <code>dsp</code> will be released once the information has been copied to <code>sparsity_pattern</code>.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div><div class="line"></div><div class="line">  preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  preconditioner_dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                  preconditioner_coupling,</div><div class="line">                                  preconditioner_dsp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div><div class="line">}</div></div><!-- fragment --><p>Finally, the system matrix, the preconsitioner matrix, the solution and the right hand side vector are created from the block structure similar to the approach in <a class="el" href="step_20.html">step-20</a>:</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(2);</div><div class="line">  solution.block(0).reinit(n_u);</div><div class="line">  solution.block(1).reinit(n_p);</div><div class="line">  solution.collect_sizes();</div><div class="line"></div><div class="line">  system_rhs.reinit(2);</div><div class="line">  system_rhs.block(0).reinit(n_u);</div><div class="line">  system_rhs.block(1).reinit(n_p);</div><div class="line">  system_rhs.collect_sizes();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemassemble_system"></a> </p><h4>StokesProblem::assemble_system</h4>
<p></p>
<p>The assembly process follows the discussion in <a class="el" href="step_20.html">step-20</a> and in the introduction. We use the well-known abbreviations for the data structures that hold the local matrices, right hand side, and global numbering of the degrees of freedom for the present cell.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix         = 0;</div><div class="line">  system_rhs            = 0;</div><div class="line">  preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div><div class="line">                                                 dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div></div><!-- fragment --><p>Next, we need two objects that work as extractors for the <a class="el" href="classFEValues.html">FEValues</a> object. Their use is explained in detail in the report on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>As an extension over <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>, we include a few optimizations that make assembly much faster for this particular problem. The improvements are based on the observation that we do a few calculations too many times when we do as in <a class="el" href="step_20.html">step-20</a>: The symmetric gradient actually has <code>dofs_per_cell</code> different values per quadrature point, but we extract it <code>dofs_per_cell*dofs_per_cell</code> times from the <a class="el" href="classFEValues.html">FEValues</a> object - for both the loop over <code>i</code> and the inner loop over <code>j</code>. In 3d, that means evaluating it \(89^2=7921\) instead of \(89\) times, a not insignificant difference.</p>
<p>So what we're going to do here is to avoid such repeated calculations by getting a vector of rank-2 tensors (and similarly for the divergence and the basis function value on pressure) at the quadrature point prior to starting the loop over the dofs on the cell. First, we create the respective objects that will hold these values. Then, we start the loop over all cells and the loop over the quadrature points, where we first extract these values. There is one more optimization we implement here: the local matrix (as well as the global one) is going to be symmetric, since all the operations involved are symmetric with respect to \(i\) and \(j\). This is implemented by simply running the inner loop not to <code>dofs_per_cell</code>, but only up to <code>i</code>, the index of the outer loop.</p>
<div class="fragment"><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    local_matrix                = 0;</div><div class="line">    local_preconditioner_matrix = 0;</div><div class="line">    local_rhs                   = 0;</div><div class="line"></div><div class="line">    right_hand_side.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                      rhs_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            symgrad_phi_u[k] =</div><div class="line">              fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">            div_phi_u[k] = fe_values[velocities].divergence(k, q);</div><div class="line">            phi_p[k]     = fe_values[pressure].value(k, q);</div><div class="line">          }</div></div><!-- fragment --><p>Now finally for the bilinear forms of both the system matrix and the matrix we use for the preconditioner. Recall that the formulas for these two are </p><p class="formulaDsp">
\begin{align*} A_{ij} &amp;= a(\varphi_i,\varphi_j) \\ &amp;= \underbrace{2(\varepsilon(\varphi_{i,\textbf{u}}), \varepsilon(\varphi_{j,\textbf{u}}))_{\Omega}} _{(1)} \; \underbrace{- (\textrm{div}\; \varphi_{i,\textbf{u}}, \varphi_{j,p})_{\Omega}} _{(2)} \; \underbrace{- (\varphi_{i,p}, \textrm{div}\; \varphi_{j,\textbf{u}})_{\Omega}} _{(3)} \end{align*}
</p>
<p> and </p><p class="formulaDsp">
\begin{align*} M_{ij} &amp;= \underbrace{(\varphi_{i,p}, \varphi_{j,p})_{\Omega}} _{(4)}, \end{align*}
</p>
<p> respectively, where \(\varphi_{i,\textbf{u}}\) and \(\varphi_{i,p}\) are the velocity and pressure components of the \(i\)th shape function. The various terms above are then easily recognized in the following implementation:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">      {</div><div class="line">        local_matrix(i, j) +=</div><div class="line">          (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) <span class="comment">// (1)</span></div><div class="line">           - div_phi_u[i] * phi_p[j]                 <span class="comment">// (2)</span></div><div class="line">           - phi_p[i] * div_phi_u[j])                <span class="comment">// (3)</span></div><div class="line">          * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);                        <span class="comment">// * dx</span></div><div class="line"></div><div class="line">        local_preconditioner_matrix(i, j) +=</div><div class="line">          (phi_p[i] * phi_p[j]) <span class="comment">// (4)</span></div><div class="line">          * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);   <span class="comment">// * dx</span></div><div class="line">      }</div></div><!-- fragment --><p>Note that in the implementation of (1) above, <code>operator*</code> is overloaded for symmetric tensors, yielding the scalar product between the two tensors.</p>
<p>For the right-hand side we use the fact that the shape functions are only non-zero in one component (because our elements are primitive). Instead of multiplying the tensor representing the dim+1 values of shape function i with the whole right-hand side vector, we only look at the only non-zero component. The function <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index</a> will return which component this shape function lives in (0=x velocity, 1=y velocity, 2=pressure in 2d), which we use to pick out the correct component of the right-hand side vector to multiply with.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">      local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div><div class="line">                       * rhs_values[q](component_i)) <span class="comment">// * f(x_q))</span></div><div class="line">                      * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);            <span class="comment">// * dx</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Before we can write the local data into the global matrix (and simultaneously use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object to apply Dirichlet boundary conditions and eliminate hanging node constraints, as we discussed in the introduction), we have to be careful about one thing, though. We have only built half of the local matrices because of symmetry, but we're going to save the full matrices in order to use the standard functions for solving. This is done by flipping the indices in case we are pointing into the empty part of the local matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        local_matrix(i, j) = local_matrix(j, i);</div><div class="line">        local_preconditioner_matrix(i, j) =</div><div class="line">          local_preconditioner_matrix(j, i);</div><div class="line">      }</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                         local_rhs,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix,</div><div class="line">                                         system_rhs);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_preconditioner_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         preconditioner_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Before we're going to solve this linear system, we generate a preconditioner for the velocity-velocity matrix, i.e., <code>block(0,0)</code> in the system matrix. As mentioned above, this depends on the spatial dimension. Since the two classes described by the <code>InnerPreconditioner::type</code> alias have the same interface, we do not have to do anything different whether we want to use a sparse direct solver or an ILU:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  A_preconditioner =</div><div class="line">    std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div><div class="line">  A_preconditioner-&gt;initialize(</div><div class="line">    system_matrix.block(0, 0),</div><div class="line">    <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemsolve"></a> </p><h4>StokesProblem::solve</h4>
<p></p>
<p>After the discussion in the introduction and the definition of the respective classes above, the implementation of the <code>solve</code> function is rather straight-forward and done in a similar way as in <a class="el" href="step_20.html">step-20</a>. To start with, we need an object of the <code>InverseMatrix</code> class that represents the inverse of the matrix A. As described in the introduction, the inverse is generated with the help of an inner preconditioner of type <code>InnerPreconditioner::type</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div><div class="line">                 A_inverse(system_matrix.block(0, 0), *A_preconditioner);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div></div><!-- fragment --><p>This is as in <a class="el" href="step_20.html">step-20</a>. We generate the right hand side \(B A^{-1} F - G\) for the Schur complement and an object that represents the respective linear operation \(B A^{-1} B^T\), now with a template parameter indicating the preconditioner - in accordance with the definition of the class.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div><div class="line">  A_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">  system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">  schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line">  SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div><div class="line">    system_matrix, A_inverse);</div></div><!-- fragment --><p>The usual control structures for the solver call are created...</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                             1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * schur_rhs.l2_norm());</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div></div><!-- fragment --><p>Now to the preconditioner to the Schur complement. As explained in the introduction, the preconditioning is done by a mass matrix in the pressure variable.</p>
<p>Actually, the solver needs to have the preconditioner in the form \(P^{-1}\), so we need to create an inverse operation. Once again, we use an object of the class <code>InverseMatrix</code>, which implements the <code>vmult</code> operation that is needed by the solver. In this case, we have to invert the pressure mass matrix. As it already turned out in earlier tutorial programs, the inversion of a mass matrix is a rather cheap and straight-forward operation (compared to, e.g., a Laplace matrix). The CG method with ILU preconditioning converges in 5-10 steps, independently on the mesh size. This is precisely what we do here: We choose another ILU preconditioner and take it along to the InverseMatrix object via the corresponding template parameter. A CG solver is then called within the vmult operation of the inverse matrix.</p>
<p>An alternative that is cheaper to build, but needs more iterations afterwards, would be to choose a SSOR preconditioner with factor 1.2. It needs about twice the number of iterations, but the costs for its generation are almost negligible.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div><div class="line">preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div><div class="line">                          <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div><div class="line">  preconditioner_matrix.block(1, 1), preconditioner);</div></div><!-- fragment --><p>With the Schur complement and an efficient preconditioner at hand, we can solve the respective equation for the pressure (i.e. block 0 in the solution vector) in the usual way:</p>
<div class="fragment"><div class="line">cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div></div><!-- fragment --><p>After this first solution step, the hanging node constraints have to be distributed to the solution in order to achieve a consistent pressure field.</p>
<div class="fragment"><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>As in <a class="el" href="step_20.html">step-20</a>, we finally need to solve for the velocity equation where we plug in the solution to the pressure equation. This involves only objects we already know - so we simply multiply \(p\) by \(B^T\), subtract the right hand side and multiply by the inverse of \(A\). At the end, we need to distribute the constraints from hanging nodes in order to obtain a consistent flow field:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">    tmp *= -1;</div><div class="line">    tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">    A_inverse.vmult(solution.block(0), tmp);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemoutput_results"></a> </p><h4>StokesProblem::output_results</h4>
<p></p>
<p>The next function generates graphical output. In this example, we are going to use the VTK file format. We attach names to the individual variables in the problem: <code>velocity</code> to the <code>dim</code> components of velocity and <code>pressure</code> to the pressure.</p>
<p>Not all visualization programs have the ability to group individual vector components into a vector to provide vector plots; in particular, this holds for some VTK-based visualization programs. In this case, the logical grouping of components into vectors should already be described in the file containing the data. In other words, what we need to do is provide our output writers with a way to know which of the components of the finite element logically form a vector (with \(d\) components in \(d\) space dimensions) rather than letting them assume that we simply have a bunch of scalar fields. This is achieved using the members of the <code><a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a></code> namespace: as with the filename, we create a vector in which the first <code>dim</code> components refer to the velocities and are given the tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>; we finally push one tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a> to describe the grouping of the pressure variable.</p>
<p>The rest of the function is then the same as in <a class="el" href="step_20.html">step-20</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemrefine_mesh"></a> </p><h4>StokesProblem::refine_mesh</h4>
<p></p>
<p>This is the last interesting function of the <code>StokesProblem</code> class. As indicated by its name, it takes the solution to the problem and refines the mesh where this is needed. The procedure is the same as in the respective step in <a class="el" href="step_6.html">step-6</a>, with the exception that we base the refinement only on the change in pressure, i.e., we call the Kelly error estimator with a mask object of type <a class="el" href="classComponentMask.html">ComponentMask</a> that selects the single scalar component for the pressure that we are interested in (we get such a mask from the finite element class by specifying the component we want). Additionally, we do not coarsen the grid again:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell,</div><div class="line">    fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(pressure));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.0);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StokesProblemrun"></a> </p><h4>StokesProblem::run</h4>
<p></p>
<p>The last step in the Stokes class is, as usual, the function that generates the initial grid and calls the other functions in the respective order.</p>
<p>We start off with a rectangle of size \(4 \times 1\) (in 2d) or \(4 \times 1 \times 1\) (in 3d), placed in \(R^2/R^3\) as \((-2,2)\times(-1,0)\) or \((-2,2)\times(0,1)\times(-1,0)\), respectively. It is natural to start with equal mesh size in each direction, so we subdivide the initial rectangle four times in the first coordinate direction. To limit the scope of the variables involved in the creation of the mesh to the range where we actually need them, we put the entire block between a pair of braces:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div><div class="line">    subdivisions[0] = 4;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, -1) :    <span class="comment">// 2d case</span></div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, 0, -1)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 1, 0)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                              subdivisions,</div><div class="line">                                              bottom_left,</div><div class="line">                                              top_right);</div><div class="line">  }</div></div><!-- fragment --><p>A boundary indicator of 1 is set to all boundaries that are subject to Dirichlet boundary conditions, i.e. to faces that are located at 0 in the last coordinate direction. See the example description above for details.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;center()[dim - 1] == 0)</div><div class="line">      face-&gt;set_all_boundary_ids(1);</div></div><!-- fragment --><p>We then apply an initial refinement before solving for the first time. In 3D, there are going to be more degrees of freedom, so we refine less there:</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4 - dim);</div></div><!-- fragment --><p>As first seen in <a class="el" href="step_6.html">step-6</a>, we cycle over the different refinement levels and refine (except for the first cycle), setup the degrees of freedom and matrices, assemble, solve and create output:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step22</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p></p>
<p>The main function is the same as in <a class="el" href="step_20.html">step-20</a>. We pass the element degree as a parameter and choose the space dimension at the well-known template slot.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step22;</div><div class="line"></div><div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-22/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></p>
<p><a class="anchor" id="Outputoftheprogramandgraphicalvisualization"></a></p><h3>Output of the program and graphical visualization</h3>
<p></p>
<p><a class="anchor" id="2Dcalculations"></a></p><h4>2D calculations</h4>
<p></p>
<p>在 <code>main</code> 函数中空间维度设置为2的情况下运行程序，会产生以下输出（在 "释放模式 "下， See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.18.html">video lecture 18</a>.): ）。</p>
<div class="fragment"><div class="line">examples/step-22&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 679 (594+85)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 160</div><div class="line">   Number of degrees of freedom: 1683 (1482+201)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 376</div><div class="line">   Number of degrees of freedom: 3813 (3370+443)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 880</div><div class="line">   Number of degrees of freedom: 8723 (7722+1001)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2008</div><div class="line">   Number of degrees of freedom: 19383 (17186+2197)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 4288</div><div class="line">   Number of degrees of freedom: 40855 (36250+4605)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div></div><!-- fragment --><p>上述整个计算在一台相当快的（以2015年的标准）机器上需要大约2秒。</p>
<p>我们立即看到的是，（外部）迭代的次数并没有随着我们细化网格而增加。这证实了介绍中的说法，即用质量矩阵对Schur补码进行预处理，确实可以得到一个与身份矩阵频谱等价的矩阵（即特征值上下受限，与网格大小或单元的相对大小无关）。换句话说，质量矩阵和Schur补码在光谱上是等价的。</p>
<p>在下面的图片中，我们展示了程序中前六个细化步骤的网格。 观察一下网格是如何在解迅速变化的区域被细化的。在上边界，我们的迪里希特边界条件在左半边是-1，右半边是1，所以在 \(x=0\) 有一个突然的变化。同样地，在两个上角也有从Dirichlet到Neumann数据的变化，所以那里也需要细化。</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-0.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-1.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-3.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-4.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-5.png"/>
</div>
   </td></tr>
</table>
<p>最后，下面是一个流场图。它显示了流体随着上层边界的移动而被来自下层的物质所取代。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.solution.png"/>
</div>
<p>该图使用了基于VTK的可视化程序的能力（在这种情况下是VisIt）来显示矢量数据；这是我们将使用中的有限元的速度分量声明为一组矢量分量，而不是本教程程序的 <code>StokesProblem&lt;dim&gt;::output_results</code> 函数中的独立标量分量的结果。</p>
<p><a class="anchor" id="3Dcalculations"></a></p><h4>3D calculations</h4>
<p></p>
<p>在3D中，程序的屏幕输出看起来像这样。</p>
<div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 32</div><div class="line">   Number of degrees of freedom: 1356 (1275+81)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  13 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 144</div><div class="line">   Number of degrees of freedom: 5088 (4827+261)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 704</div><div class="line">   Number of degrees of freedom: 22406 (21351+1055)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 3168</div><div class="line">   Number of degrees of freedom: 93176 (89043+4133)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 11456</div><div class="line">   Number of degrees of freedom: 327808 (313659+14149)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 45056</div><div class="line">   Number of degrees of freedom: 1254464 (1201371+53093)</div><div class="line">   Assembling...</div><div class="line">   Computing preconditioner...</div><div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div></div><!-- fragment --><p>我们再次看到，随着我们对网格的细化，外迭代的次数并没有增加。然而，计算时间明显增加：对于上述每个迭代分别需要约0.14秒、0.63秒、4.8秒、35秒、2分33秒和13分12秒。这种运行时间的整体超线性（未知数的数量）增加是由于我们的内部求解器不是 \({\cal O}(N)\) ：一个简单的实验表明，随着我们不断细化网格，反演速度-速度块 \(A\) 的ILU预处理的CG平均迭代次数会增加。</p>
<p>我们将解决如何可能改进我们的解算器<a href="#improved-solver">below</a>的问题。</p>
<p>至于图形输出，在解决过程中产生的网格看起来如下。</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-0.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-1.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-3.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-4.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-5.png"/>
</div>
   </td></tr>
</table>
<p>同样，它们基本上显示了由边界条件引入的奇异点的位置。计算出的矢量场构成了一个有趣的图形。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.solution.png"/>
</div>
<p>这里显示的等值线也是压力变量的等值线，显示了在不连续的速度边界条件下的奇异现象。</p>
<p><a class="anchor" id="Sparsitypattern"></a></p><h3>Sparsity pattern</h3>
<p></p>
<p>正如在生成稀疏模式时解释的那样，在使用不完全LU分解等预处理程序时，必须牢记自由度的编号。使用刚度矩阵中的非零元素的分布可以最方便地看到这一点。</p>
<p>如果我们不对自由度的重新编号做任何特殊处理（即不使用 <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>, ，而是使用 <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> 来确保自由度被适当地排序到矩阵和向量的相应块中），那么我们在二维的第一次自适应细化后得到以下图像。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-nor.png"/>
</div>
<p>为了生成这样的图表，你必须在设置步骤的末尾插入一段类似以下的代码。</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern.gpl&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a7f59a68863a1e770ba275894a7170e70">print_gnuplot</a>(out);</div><div class="line">}</div></div><!-- fragment --><p>可以清楚地看到，非零项几乎分布在整个矩阵中。 这使得用ILU进行预处理的效率很低。ILU生成的高斯消除（LU分解）没有填充元素，这意味着更多的暂定填充元素的遗漏将导致完整分解的近似度降低。</p>
<p>因此，在这个程序中，我们选择了一种更高级的元件重新编号的方法。 用 <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a> 进行重新编号，并将元件分组为速度和压力，得到以下输出。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-ren.png"/>
</div>
<p>很明显，情况有了很大的改善。现在大多数元素都集中在矩阵中（0,0）块的对角线周围。其他区块也可以看到类似的效果。在这种情况下，ILU分解将更接近于完全的LU分解，这就提高了预处理程序的质量。值得注意的是，稀疏直接求解器UMFPACK在实际生成稀疏LU分解之前会对方程进行一些内部重新编号；这个过程导致了与我们从Cuthill-McKee算法中得到的模式非常相似）。</p>
<p>最后，我们想仔细看看三维的稀疏模式。我们只显示了矩阵的(0,0)块，还是在一次自适应细化之后。除了矩阵大小增加的事实之外，还可以看到矩阵中多了很多条目。此外，即使是优化后的重新编号，也会有相当数量的暂定填充元素。这说明了为什么UMFPACK在三维中不是一个好的选择&ndash;完整的分解需要许多新的条目，最终无法放入物理内存（RAM）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d.sparsity_uu-ren.png"/>
</div>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p></p>
<p><a class="anchor" id="improved-solver"></a></p>
<p><a class="anchor" id="Improvedlinearsolverin3Dh4h4Improvedlinearsolverin3D"></a></p><h4>Improved linear solver in 3D</h4>
<h4>Improved linear solver in 3D</h4>
<p></p>
<p>。</p>
<p>我们在计算结果一节中看到，外迭代次数不取决于网格大小，从可扩展性的角度看，这是最佳的。然而，如上所述，这并不适用于整个求解器。在生成矩阵 \(A\) 和质量矩阵 \(M_p\) 的逆时，我们没有研究内部迭代的数量。当然，这在二维情况下是没有问题的，我们用直接求解器对 \(A\) 进行预处理，逆矩阵结构的 <code>vmult</code> 操作将在一个单一的CG步骤中收敛，但这在三维情况下发生变化，我们只使用ILU预处理器。 在那里，反演 \(A\) 所需的预处理CG步骤的数量随着网格的细化而增加，每个 <code>vmult</code> 操作平均涉及上述细化步骤中的大约14、23、36、59、75和101次内部CG迭代。(另一方面，应用反压力质量矩阵的迭代次数总是在5次左右，在二维和三维中都是如此)。 总而言之，大部分的工作都花在了用相同的矩阵 \(A\) 反复解决线性系统上。让这看起来更糟糕的是，我们实际上反转了一个矩阵，其大小约为整个系统矩阵的95，并代表了稀疏模式中85的非零条目。因此，自然的问题是，在计算块状系统的解时，用矩阵 \(A\) 解约15次的线性系统是否合理。</p>
<p>当然，答案是，我们可以用其他一些（大多数时候是更好的）方法来做。然而，必须指出的是，正如我们在早期教程中所看到的那样，眼前的这个不确定系统对线性代数的要求确实比标准椭圆问题高得多。如果与类似规模的椭圆问题相比，其改进仍然相当不令人满意。无论如何，我们将在下面介绍一些对线性求解器的改进，我们将在第31步程序中用额外的选项再次重新考虑这一讨论。</p>
<p><a class="anchor" id="improved-ilu"></a></p>
<p><a class="anchor" id="BetterILUdecompositionbysmartreorderingh5h5BetterILUdecompositionbysmartreordering"></a></p><h5>Better ILU decomposition by smart reordering</h5>
<h5>Better ILU decomposition by smart reordering</h5>
<p></p>
<p>提高线性求解过程速度的第一个尝试是选择一个道夫重排序，使ILU更接近于全LU分解，这在代码中的注释中已经提到。DoFRenumbering命名空间比较了几种对斯托克斯方程的道夫重新编号的选择。关于计算时间的最佳结果是通过调用 <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a76fd1dc3212aeeca4294c358248e46d5">DoFRenumbering::boost::king_ordering</a>. 找到的，通过该程序，内部求解器需要的操作大大减少，例如，在第4周期对 \(A\) 进行反演的内部CG迭代约62次，而标准Cuthill-McKee-算法的迭代约75次。另外，在第4周期，对于 <code>solve()</code> 的调用，计算时间从大约17分钟减少到11分钟。然而，King排序（以及一般由 <a class="el" href="namespaceDoFRenumbering_1_1boost.html">DoFRenumbering::boost</a> 命名空间提供的排序）有一个严重的缺点&ndash;它比构建中的交易版本使用更多的内存，因为它作用于抽象图而不是由三角化提供的几何图形。在目前的情况下，重新编号需要大约5倍的内存，这就产生了一个不可行的算法，在3D的最后一个周期有120万未知数。</p>
<p><a class="anchor" id="BetterpreconditionerfortheinnerCGsolver"></a></p><h5>Better preconditioner for the inner CG solver</h5>
<p>另一个改善情况的想法是选择一个预处理程序，使(0,0)矩阵 \(A\) 的CG在一个与网格无关的迭代次数中收敛，比如10到30次。我们在步骤16中已经看到了这样的候选方案：多网格。</p>
<p><a class="anchor" id="BlockSchurcomplementpreconditioner"></a></p><h5>Block Schur complement preconditioner</h5>
<p><a class="anchor" id="block-schur"></a> 即使对 \(A\) 有一个好的预处理程序，我们仍然需要反复求解同一个线性系统（虽然右手边不同），以使舒尔补码的求解趋于一致。我们这里要讨论的方法是如何将内部迭代和外部迭代结合起来。如果我们坚持计算舒尔补码，就没有其他的可能性了。</p>
<p>另一种方法是一次性攻击块状系统，并使用近似的Schur补码作为有效的预处理程序。其思路如下。如果我们找到一个块状预处理器 \(P\) ，使矩阵</p>
<p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p>是简单的，那么使用该预处理程序的迭代求解器将在几次迭代中收敛。使用舒尔补码 \(S = B A^{-1} B^T\) ，我们发现</p>
<p class="formulaDsp">
\begin{eqnarray*} P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p>似乎是个不错的选择，因为</p>
<p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right)\cdot \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right). \end{eqnarray*}
</p>
<p>这就是引言中提到的Silvester和Wathen的论文所采取的方法（不同的是Silvester和Wathen使用了右预处理）。在这种情况下，基于Krylov的迭代方法只有在应用 \(A\) 和 \(S\) 的精确求逆时才会一步收敛，因为所有的特征值都是1（而这种方法的迭代次数是由不同特征值的数量所决定的）。下面，我们将讨论如何为这个问题选择一个适当的求解器。首先，我们要仔细研究一下预处理程序的实现。</p>
<p>由于 \(P\) 的目的只是作为一个预处理程序，我们将使用舒尔补码 \(S\) 和矩阵 \(A\) 的近似反向。因此，舒尔补集将由压力质量矩阵 \(M_p\) 近似，我们使用 \(A\) 的预处理器（周围没有反矩阵类）来近似 \(A^{-1}\) 。</p>
<p>这里有一个实现块舒尔补码预处理的类。根据上面的推导，对块向量的 <code>vmult</code> 操作可以通过三个连续的操作来指定。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>         &amp;S,</div><div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt;  &amp;Mpinv,</div><div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>,</div><div class="line">                       PreconditionerMp &gt; &gt; m_inverse;</div><div class="line">    <span class="keyword">const</span> PreconditionerA &amp;a_preconditioner;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp;</div><div class="line"></div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line">BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::BlockSchurPreconditioner(</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>                            &amp;S,</div><div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt; &amp;Mpinv,</div><div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner</div><div class="line">          )</div><div class="line">                :</div><div class="line">                system_matrix           (&amp;S),</div><div class="line">                m_inverse               (&amp;Mpinv),</div><div class="line">                a_preconditioner        (Apreconditioner),</div><div class="line">                tmp                     (S.block(1,1).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// Now the interesting function, the multiplication of</span></div><div class="line">        <span class="comment">// the preconditioner with a BlockVector.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keywordtype">void</span> BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::vmult (</div><div class="line">                                     <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">        <span class="comment">// Form u_new = A^{-1} u</span></div><div class="line">  a_preconditioner.vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">        <span class="comment">// Form tmp = - B u_new + p</span></div><div class="line">        <span class="comment">// (&lt;code&gt;SparseMatrix::residual&lt;/code&gt;</span></div><div class="line">        <span class="comment">// does precisely this)</span></div><div class="line">  system_matrix-&gt;block(1,0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">        <span class="comment">// Change sign in tmp</span></div><div class="line">  tmp *= -1;</div><div class="line">        <span class="comment">// Multiply by approximate Schur complement</span></div><div class="line">        <span class="comment">// (i.e. a pressure mass matrix)</span></div><div class="line">  m_inverse-&gt;vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">}</div></div><!-- fragment --><p>由于我们现在对整个区块系统采取行动，我们必须忍受一个缺点：我们需要对整个区块系统而不是较小的压力空间进行求解器迭代。</p>
<p>现在我们转向我们应该对块系统使用哪种求解器的问题。第一个观察结果是，所产生的预处理矩阵不能用CG求解，因为它既不是正定也不是对称的。</p>
<p>deal.II库实现了几个适合手头问题的求解器。一种选择是求解器 <a class="el" href="classSolverBicgstab.html">BiCGStab</a>，它被用于解决步骤9中的非对称平流问题。第二个选择，也就是我们要选择的，是 <a class="el" href="classSolverGMRES.html">GMRES</a>（广义最小残差）。这两种方法都有其优点和缺点&ndash;在有些问题上，两种候选方法中的一种明显优于另一种，反之亦然。<a href="http://en.wikipedia.org/wiki/GMRES#Comparison_with_other_solvers">Wikipedia</a>关于GMRES方法的文章给出了一个比较的介绍。更全面和有根据的比较可以在J.W.Demmel的书中读到（Applied Numerical Linear Algebra, SIAM, 1997, section 6.6.6）。</p>
<p>对于我们用ILU预处理 \(A\) 的具体问题，对于大的问题规模，我们当然需要在块系统上进行数百次迭代（我们不会打败CG！）。实际上，这不利于GMRES。在GMRES迭代过程中，Krylov向量的基础被陆续建立起来，并对这些向量进行一些操作。这个基础上的向量越多，需要的操作和内存就越多。操作的数量以 \({\cal O}(n + k^2)\) 的形式扩展，内存以 \({\cal O}(kn)\) 的形式扩展，其中 \(k\) 是Krylov基础中的向量数量， \(n\) 是（块）矩阵的大小。为了不让这些需求过度增长，deal.II将基的大小 \(k\) 默认限制为30个向量。然后，重新建立基。这种GMRES方法的实现被称为GMRES(k)，默认为 \(k=30\) 。我们通过这一限制所获得的东西，即对操作和内存需求的约束，将被我们使用不完整的基础这一事实所补偿&ndash;这将增加所需的迭代次数。</p>
<p>另一方面，当需要多次迭代时，BiCGStab不会变慢（一次迭代只使用前面一个步骤的结果，而不是像GMRES那样使用所有的步骤）。除了BiCGStab由于需要两个矩阵-向量乘积（相比之下，CG或GMRES只需要一个），所以每一步的成本更高之外，还有一个主要原因使得BiCGStab不适合这个问题：预处理程序通过使用InverseMatrix类应用压力质量矩阵的逆。由于向量的逆矩阵应用只是以近似的方式进行（精确的逆太昂贵了），这也会影响求解器。在BiCGStab的情况下，由于这种扰动，Krylov向量将不会是正交的。虽然这对于少量的步骤（最多50步）来说是不关键的，但当这些扰动在迭代的粗放中增长到相当大的程度时，它就会破坏求解器的性能。</p>
<p>我们用BiCGStab做了一些实验，发现它在细化周期3之前比GMRES快（在3D中），但在周期4和5时变得非常慢（甚至比原来的Schur补码还慢），所以在这种情况下求解器是没有用的。为逆矩阵类选择一个更尖锐的容忍度（ <code>1e-10*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code> 而不是 <code>1e-6*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code> ）使BiCGStab在第4周期也表现良好，但没有改变在非常大的问题上的失败。</p>
<p>当然，GMRES也会受到近似求逆的影响，但它对正交性不那么敏感，而且对于大尺寸也能保持相对较好的性能，见下面的结果。</p>
<p>说到这里，我们转向用 \(k=100\) 临时向量的GMRES实现求解器调用。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &amp;pressure_mass_matrix</div><div class="line">  = preconditioner_matrix.block(1,1);</div><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> pmass_preconditioner;</div><div class="line">pmass_preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a> (pressure_mass_matrix,</div><div class="line">  <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line"></div><div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;,<a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div><div class="line">  m_inverse (pressure_mass_matrix, pmass_preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">BlockSchurPreconditioner&lt;typename InnerPreconditioner&lt;dim&gt;::type,</div><div class="line">                         <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div><div class="line">  preconditioner (system_matrix, m_inverse, *A_preconditioner);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m(),</div><div class="line">                              1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6*system_rhs.l2_norm());</div><div class="line"><a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;BlockVector&lt;double&gt;</a> &gt; vector_memory;</div><div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt;::AdditionalData gmres_data;</div><div class="line">gmres_data.max_n_tmp_vectors = 100;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt; gmres(solver_control, vector_memory,</div><div class="line">                                        gmres_data);</div><div class="line"></div><div class="line"></div><div class="line">gmres.solve(system_matrix, solution, system_rhs,</div><div class="line">            preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a> (solution);</div><div class="line"></div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_step()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; block GMRES iterations&quot;</span>;</div></div><!-- fragment --><p>显然，人们需要添加include文件 <a class="el" href="classSolverGMRES.html">&lt;lac/solver_gmres.h&gt;</a>以使其运行。我们用BlockVector模板来调用求解器，以便使GMRES能够对块状向量和矩阵进行操作。还要注意的是，在我们将信息复制到另一个矩阵之后，我们需要将系统矩阵中的（1,1）块设置为零（我们将压力质量矩阵保存在那里，这不是问题的一部分）。</p>
<p>使用定时器类，我们收集了一些统计数据，将块状求解器的运行时间与上述问题实现中的运行时间进行比较。除了两个选项的解决方案，我们还检查了两个变体的解决方案是否接近（即这个求解器给出的解决方案确实与我们之前的解决方案相同），并计算矢量差的无穷大准则。</p>
<p>让我们先看看二维的结果。</p>
<div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 679 (594+85) [0.00162792 s]</div><div class="line">   Assembling...  [0.00108981 s]</div><div class="line">   Computing preconditioner... [0.0025959 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.00479603s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.00441718 s]</div><div class="line">   l_infinity difference between solution vectors: 5.38258e-07</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 160</div><div class="line">   Number of degrees of freedom: 1683 (1482+201) [0.00345707 s]</div><div class="line">   Assembling...  [0.00237417 s]</div><div class="line">   Computing preconditioner... [0.00605702 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0123992s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.011909 s]</div><div class="line">   l_infinity difference between solution vectors: 1.74658e-05</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 376</div><div class="line">   Number of degrees of freedom: 3813 (3370+443) [0.00729299 s]</div><div class="line">   Assembling...  [0.00529909 s]</div><div class="line">   Computing preconditioner... [0.0167508 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.031672s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.029232 s]</div><div class="line">   l_infinity difference between solution vectors: 7.81569e-06</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 880</div><div class="line">   Number of degrees of freedom: 8723 (7722+1001) [0.017709 s]</div><div class="line">   Assembling...  [0.0126002 s]</div><div class="line">   Computing preconditioner... [0.0435679 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0971651s ]</div><div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.0992041 s]</div><div class="line">   l_infinity difference between solution vectors: 1.87249e-05</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2008</div><div class="line">   Number of degrees of freedom: 19383 (17186+2197) [0.039988 s]</div><div class="line">   Assembling...  [0.028281 s]</div><div class="line">   Computing preconditioner... [0.118314 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.252133s ]</div><div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.269125 s]</div><div class="line">   l_infinity difference between solution vectors: 6.38657e-05</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 4288</div><div class="line">   Number of degrees of freedom: 40855 (36250+4605) [0.0880702 s]</div><div class="line">   Assembling...  [0.0603511 s]</div><div class="line">   Computing preconditioner... [0.278339 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.53846s ]</div><div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.578667 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000173363</div></div><!-- fragment --><p>我们看到，块状舒尔补码预处理求解器和舒尔补码本身在求解时间上没有巨大差异。原因很简单：我们使用直接求解作为 \(A\) 的预处理程序&ndash;所以我们不能指望通过避免内部迭代获得任何收益。我们看到，GMRES的迭代次数略有增加，但总的来说，这两种选择是相当相似的。</p>
<p>画面当然会发生三维变化。</p>
<div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 32</div><div class="line">   Number of degrees of freedom: 1356 (1275+81) [0.00845218 s]</div><div class="line">   Assembling...  [0.019372 s]</div><div class="line">   Computing preconditioner... [0.00712395 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 13 outer CG iterations <span class="keywordflow">for</span> p  [0.0320101s ]</div><div class="line">      Block Schur preconditioner: 22 GMRES iterations [0.0048759 s]</div><div class="line">   l_infinity difference between solution vectors: 2.15942e-05</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 144</div><div class="line">   Number of degrees of freedom: 5088 (4827+261) [0.0346942 s]</div><div class="line">   Assembling...  [0.0857739 s]</div><div class="line">   Computing preconditioner... [0.0465031 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [0.349258s ]</div><div class="line">      Block Schur preconditioner: 35 GMRES iterations [0.048759 s]</div><div class="line">   l_infinity difference between solution vectors: 1.77657e-05</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 704</div><div class="line">   Number of degrees of freedom: 22406 (21351+1055) [0.175669 s]</div><div class="line">   Assembling...  [0.437447 s]</div><div class="line">   Computing preconditioner... [0.286435 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [3.65519s ]</div><div class="line">      Block Schur preconditioner: 63 GMRES iterations [0.497787 s]</div><div class="line">   l_infinity difference between solution vectors: 5.08078e-05</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 3168</div><div class="line">   Number of degrees of freedom: 93176 (89043+4133) [0.790985 s]</div><div class="line">   Assembling...  [1.97598 s]</div><div class="line">   Computing preconditioner... [1.4325 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [29.9666s ]</div><div class="line">      Block Schur preconditioner: 128 GMRES iterations [5.02645 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000119671</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 11456</div><div class="line">   Number of degrees of freedom: 327808 (313659+14149) [3.44995 s]</div><div class="line">   Assembling...  [7.54772 s]</div><div class="line">   Computing preconditioner... [5.46306 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [139.987s ]</div><div class="line">      Block Schur preconditioner: 255 GMRES iterations [38.0946 s]</div><div class="line">   l_infinity difference between solution vectors: 0.00020793</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 45056</div><div class="line">   Number of degrees of freedom: 1254464 (1201371+53093) [19.6795 s]</div><div class="line">   Assembling...  [28.6586 s]</div><div class="line">   Computing preconditioner... [22.401 s]</div><div class="line">   Solving...</div><div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [796.767s ]</div><div class="line">      Block Schur preconditioner: 524 GMRES iterations [355.597 s]</div><div class="line">   l_infinity difference between solution vectors: 0.000501219</div></div><!-- fragment --><p>在这里，块状预处理求解器明显优于Schur补数，但是网格点越多，优势就越小。这是因为GMRES(k)随着问题规模的扩大比CG更差，正如我们上面所讨论的。 尽管如此，对于中等规模的问题，3-6倍的改进是相当令人印象深刻的。</p>
<p><a class="anchor" id="Combiningtheblockpreconditionerandmultigrid"></a></p><h5>Combining the block preconditioner and multigrid</h5>
<p>这个问题的终极线性求解器可以想象为 \(A\) 的最佳预处理器（如多网格）和上述的块状预处理器的组合，这就是步骤31和步骤32教程程序（我们使用代数多网格方法）和步骤56（我们使用几何多网格方法）中所采取的方法。</p>
<p><a class="anchor" id="Noblockmatricesandvectors"></a></p><h5>No block matrices and vectors</h5>
<p>另一个可以考虑的可能性是不设置块状系统，而是一次性解决速度和压力系统。可以选择用UMFPACK直接求解（2D）或用ILU预处理的GMRES（3D）。这应该是很直接的尝试。</p>
<p><a class="anchor" id="Moreinterestingtestcases"></a></p><h4>More interesting testcases</h4>
<p></p>
<p>当然，这个程序也可以作为计算更有趣的情况下的流动的基础。编写这个程序的最初动机是希望它能成为一些地球物理流动问题的起点，例如大陆板块漂移分离的地方（例如洋中脊）下的岩浆运动。当然，在这种地方，几何形状比上面的例子更复杂，但要适应这种情况并不难。</p>
<p>例如，通过使用以下对边界值函数的修改</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">BoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x_offset = <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(p[1]*4)/3;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> (p[0] &lt; x_offset ? -1 : (p[0] &gt; x_offset ? 1 : 0));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>和以下方式生成网格作为域 \([-2,2]\times[-2,2]\times[-1,0]\) 。</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; subdivisions (dim, 1);</div><div class="line">subdivisions[0] = 4;</div><div class="line"><span class="keywordflow">if</span> (dim&gt;2)</div><div class="line">  subdivisions[1] = 4;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,-1) :</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,-2,-1));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right   = (dim == 2 ?</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2,0) :</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2,2,0));</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                           subdivisions,</div><div class="line">                                           bottom_left,</div><div class="line">                                           top_right);</div></div><!-- fragment --><p>那么我们就会得到断层线是弯曲的图像。 </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d-extension.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-22.3d-grid-extension.png"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2008 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2008</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step22</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (component == 0)</div><div class="line">      <span class="keywordflow">return</span> (p[0] &lt; 0 ? -1 : (p[0] &gt; 0 ? 1 : 0));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                         Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                  <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">    <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">    <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    , preconditioner(&amp;preconditioner)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">    Vector&lt;double&gt; &amp;      dst,</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.size(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * src.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, *preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div><div class="line">      A_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div><div class="line">    : system_matrix(&amp;system_matrix)</div><div class="line">    , A_inverse(&amp;A_inverse)</div><div class="line">    , tmp1(system_matrix.block(0, 0).m())</div><div class="line">    , tmp2(system_matrix.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  SchurComplement&lt;PreconditionerType&gt;::vmult(Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).vmult(tmp1, src);</div><div class="line">    A_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : degree(degree)</div><div class="line">    , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    A_preconditioner.reset();</div><div class="line">    system_matrix.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div><div class="line">    block_component[dim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               1,</div><div class="line">                                               BoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">    }</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div><div class="line"></div><div class="line">      preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      preconditioner_dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                      preconditioner_coupling,</div><div class="line">                                      preconditioner_dsp,</div><div class="line">                                      constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(2);</div><div class="line">    solution.block(0).reinit(n_u);</div><div class="line">    solution.block(1).reinit(n_p);</div><div class="line">    solution.collect_sizes();</div><div class="line"></div><div class="line">    system_rhs.reinit(2);</div><div class="line">    system_rhs.block(0).reinit(n_u);</div><div class="line">    system_rhs.block(1).reinit(n_p);</div><div class="line">    system_rhs.collect_sizes();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix         = 0;</div><div class="line">    system_rhs            = 0;</div><div class="line">    preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix                = 0;</div><div class="line">        local_preconditioner_matrix = 0;</div><div class="line">        local_rhs                   = 0;</div><div class="line"></div><div class="line">        right_hand_side.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                          rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                symgrad_phi_u[k] =</div><div class="line">                  fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                div_phi_u[k] = fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]     = fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) <span class="comment">// (1)</span></div><div class="line">                       - div_phi_u[i] * phi_p[j]                 <span class="comment">// (2)</span></div><div class="line">                       - phi_p[i] * div_phi_u[j])                <span class="comment">// (3)</span></div><div class="line">                      * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);                        <span class="comment">// * dx</span></div><div class="line"></div><div class="line">                    local_preconditioner_matrix(i, j) +=</div><div class="line">                      (phi_p[i] * phi_p[j]) <span class="comment">// (4)</span></div><div class="line">                      * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);   <span class="comment">// * dx</span></div><div class="line">                  }</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                  fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div><div class="line">                                 * rhs_values[q](component_i)) <span class="comment">// * f(x_q))</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);            <span class="comment">// * dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              local_matrix(i, j) = local_matrix(j, i);</div><div class="line">              local_preconditioner_matrix(i, j) =</div><div class="line">                local_preconditioner_matrix(j, i);</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_preconditioner_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               preconditioner_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    A_preconditioner =</div><div class="line">      std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div><div class="line">    A_preconditioner-&gt;initialize(</div><div class="line">      system_matrix.block(0, 0),</div><div class="line">      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                        <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div><div class="line">                   A_inverse(system_matrix.block(0, 0), *A_preconditioner);</div><div class="line">    Vector&lt;double&gt; tmp(solution.block(0).size());</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;double&gt; schur_rhs(solution.block(1).size());</div><div class="line">      A_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line">      SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div><div class="line">        system_matrix, A_inverse);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div><div class="line">                                <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">      InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div><div class="line">        preconditioner_matrix.block(1, 1), preconditioner);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      A_inverse.vmult(solution.block(0), tmp);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell,</div><div class="line">      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(pressure));</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.0);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div><div class="line">      subdivisions[0] = 4;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, -1) :    <span class="comment">// 2d case</span></div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, 0, -1)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 1, 0)); <span class="comment">// 3d case</span></div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                                subdivisions,</div><div class="line">                                                bottom_left,</div><div class="line">                                                top_right);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;center()[dim - 1] == 0)</div><div class="line">          face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4 - dim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step22</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step22;</div><div class="line"></div><div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </li>
</ol>
</li>
</ol>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
