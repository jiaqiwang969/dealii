<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_38.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-38 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-38 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_34.html">step-34</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Testcase">Testcase</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeLaplaceBeltramiProblemcodeclasstemplate">The <code>LaplaceBeltramiProblem</code> class template</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeLaplaceBeltramiProblemcodeclass">Implementation of the <code>LaplaceBeltramiProblem</code> class</a>
      <ul>
        <li><a href="#LaplaceBeltramiProblemmake_grid_and_dofs">LaplaceBeltramiProblem::make_grid_and_dofs</a>
        <li><a href="#LaplaceBeltramiProblemassemble_system">LaplaceBeltramiProblem::assemble_system</a>
        <li><a href="#LaplaceBeltramiProblemsolve">LaplaceBeltramiProblem::solve</a>
        <li><a href="#LaplaceBeltramiProblemoutput_result">LaplaceBeltramiProblem::output_result</a>
        <li><a href="#LaplaceBeltramiProblemcompute_error">LaplaceBeltramiProblem::compute_error</a>
        <li><a href="#LaplaceBeltramiProblemrun">LaplaceBeltramiProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Andrea Bonito and M. Sebastian Pauletti, with editing and writing by Wolfgang Bangerth. <br />
 This material is based upon work supported by the National Science Foundation under Grant No. DMS-0914977. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation (NSF). </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>In this example, we show how to solve a partial differential equation (PDE) on a codimension one surface \(\Gamma \subset \mathbb R^3\) made of quadrilaterals, i.e. on a surface in 3d or a line in 2d. We focus on the following elliptic second order PDE </p><p class="formulaDsp">
\begin{align*} -\Delta_\Gamma u &amp;= f \qquad \text{on } \qquad \Gamma,\\ u &amp;= g \qquad \text{on} \qquad \partial \Gamma, \end{align*}
</p>
<p> which generalized the Laplace equation we have previously solved in several of the early tutorial programs. Our implementation is based on <a class="el" href="step_4.html">step-4</a>. <a class="el" href="step_34.html">step-34</a> also solves problems on lower dimensional surfaces; however, there we only consider integral equations that do not involve derivatives on the solution variable, while here we actually have to investigate what it means to take derivatives of a function only defined on a (possibly curved) surface.</p>
<p>In order to define the above operator, we start by introducing some notations. Let \(\mathbf x_S:\hat S \rightarrow S\) be a parameterization of a surface \(S\) from a reference element \(\hat S \subset \mathbb R^2\), i.e. each point \(\hat{\mathbf x}\in\hat S\) induces a point \({\mathbf x}_S(\hat{\mathbf x}) \in S\). Then let </p><p class="formulaDsp">
\[ G_S\dealcoloneq (D \mathbf{x}_S)^T \ D \mathbf{x}_S \]
</p>
<p> denotes the corresponding first fundamental form, where \(D \mathbf{x}_S=\left(\frac{\partial x_{S,i}(\hat{\mathbf x})}{\partial \hat x_j}\right)_{ij}\) is the derivative (Jacobian) of the mapping. In the following, \(S\) will be either the entire surface \(\Gamma\) or, more convenient for the finite element method, any face \(S \in {\mathbb T}\), where \({\mathbb T}\) is a partition (triangulation) of \(\Gamma\) constituted of quadrilaterals. We are now in position to define the tangential gradient of a function \(v : S \rightarrow \mathbb R\) by </p><p class="formulaDsp">
\[ (\nabla_S v)\circ \mathbf x_S \dealcoloneq D \mathbf x_S \ G_S^{-1} \ \nabla (v \circ \mathbf x_S). \]
</p>
<p> The surface Laplacian (also called the Laplace-Beltrami operator) is then defined as \(\Delta_S \dealcoloneq \nabla_S \cdot \nabla_S\). Note that an alternate way to compute the surface gradient on smooth surfaces \(\Gamma\) is </p><p class="formulaDsp">
\[ \nabla_S v = \nabla \tilde v - \mathbf n (\mathbf n \cdot \nabla \tilde v), \]
</p>
<p> where \(\tilde v\) is a "smooth" extension of \(v\) in a tubular neighborhood of \(\Gamma\) and \(\mathbf n\) is the normal of \(\Gamma\). Since \(\Delta_S = \nabla_S \cdot \nabla_S\), we deduce </p><p class="formulaDsp">
\[ \Delta_S v = \Delta \tilde v - \mathbf n^T \ D^2 \tilde v \ \mathbf n - (\mathbf n \cdot \nabla \tilde v) (\nabla \cdot \mathbf n - \mathbf n^T \ D \mathbf n \ \mathbf n ). \]
</p>
<p> Worth mentioning, the term \(\nabla \cdot \mathbf n - \mathbf n \ D \mathbf n \ \mathbf n\) appearing in the above expression is the total curvature of the surface (sum of principal curvatures).</p>
<p>As usual, we are only interested in weak solutions for which we can use \(C^0\) finite elements (rather than requiring \(C^1\) continuity as for strong solutions). We therefore resort to the weak formulation </p><p class="formulaDsp">
\[ \int_\Gamma \nabla_\Gamma u \cdot \nabla_\Gamma v = \int_\Gamma f \ v \qquad \forall v \in H^1_0(\Gamma) \]
</p>
<p> and take advantage of the partition \({\mathbb T}\) to further write </p><p class="formulaDsp">
\[ \sum_{K\in {\mathbb T}}\int_K \nabla_{K} u \cdot \nabla_{K} v = \sum_{K\in {\mathbb T}} \int_K f \ v \qquad \forall v \in H^1_0(\Gamma). \]
</p>
<p> Moreover, each integral in the above expression is computed in the reference element \(\hat K \dealcoloneq [0,1]^2\) so that </p><p class="formulaDsp">
\begin{align*} \int_{K} \nabla_{K} u \cdot \nabla_{K} v &amp;= \int_{\hat K} \nabla (u \circ \mathbf x_K)^T G_K^{-1} (D \mathbf x_K)^T D \mathbf x_K G_K^{-1} \nabla (v \circ \mathbf x_K) \sqrt{\det (G_K)} \\ &amp;= \int_{\hat K} \nabla (u \circ \mathbf x_K)^T G_K^{-1} \nabla (v \circ \mathbf x_K) \sqrt{\det (G_K)} \end{align*}
</p>
<p> and </p><p class="formulaDsp">
\[ \int_{K} f \ v = \int_{\hat K} (f \circ \mathbf x_K) (v \circ \mathbf x_K) \sqrt{\det (G_K)}. \]
</p>
<p> Finally, we use a quadrature formula defined by points \(\{p_l\}_{l=1}^N\subset \hat K\) and weights \(\{w_l\}_{l=1}^N \subset \mathbb R^+_*\) to evaluate the above integrals and obtain </p><p class="formulaDsp">
\[\int_{K} \nabla_{K} u \cdot \nabla_{K} v \approx \sum_{l=1}^N (\nabla (u \circ \mathbf x_K)(p_l))^T G^{-1}(p_l) \nabla (v \circ \mathbf x_K) (p_l) \sqrt{\det (G(p_l))} \ w_l \]
</p>
<p> and </p><p class="formulaDsp">
\[ \int_{K} f \ v \approx \sum_{l=1}^N (f \circ \mathbf x_K)(p_l) \ (v \circ \mathbf x_K)(p_l) \sqrt{\det (G(p_l))} \ w_l. \]
</p>
<p>Fortunately, deal.II has already all the tools to compute the above expressions. In fact, they barely differ from the ways in which we solve the usual Laplacian, only requiring the surface coordinate mapping to be provided in the constructor of the <a class="el" href="classFEValues.html">FEValues</a> class. This surface description given, in the codimension one surface case, the two routines <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">FEValues::shape_grad</a> and <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW</a> return </p><p class="formulaDsp">
\begin{align*} \text{FEValues::shape\_grad}(i,l)&amp;=D \mathbf x_K(p_l) G^{-1}(p_l)D(\varphi_i \circ \mathbf x_K) (p_l) \\ \text{FEValues::JxW}(l) &amp;= \sqrt{\det (G(p_l))} \ w_l. \end{align*}
</p>
<p> This provides exactly the terms we need for our computations.</p>
<p>On a more general note, details for the finite element approximation on surfaces can be found for instance in [Dziuk, in Partial differential equations and calculus of variations 1357, Lecture Notes in Math., 1988], [Demlow, SIAM J. Numer. Anal. 47(2), 2009] and [Bonito, Nochetto, and Pauletti, SIAM J. Numer. Anal. 48(5), 2010].</p>
<p><a class="anchor" id="Testcase"></a></p><h3>Testcase</h3>
<p>In general when you want to test numerically the accuracy and/or order of convergence of an algorithm you need to provide an exact solution. The usual trick is to pick a function that we want to be the solution, then apply the differential operator to it that defines a forcing term for the right hand side. This is what we do in this example. In the current case, the form of the domain is obviously also essential.</p>
<p>We produce one test case for a 2d problem and another one for 3d:</p>
<ul>
<li>
<p class="startli">In 2d, let's choose as domain a half circle. On this domain, we choose the function \(u(\mathbf x)=-2x_1x_2\) as the solution. To compute the right hand side, we have to compute the surface Laplacian of the solution function. There are (at least) two ways to do that. The first one is to project away the normal derivative as described above using the natural extension of \(u(\mathbf x)\) (still denoted by \(u\)) over \(\mathbb R^d\), i.e. to compute </p><p class="formulaDsp">
\[ -\Delta_\Gamma u = \Delta u - \mathbf n^T \ D^2 u \ \mathbf n - (\mathbf n \cdot \nabla u)\ \kappa, \]
</p>
<p> where \(\kappa\) is the total curvature of \(\Gamma\). Since we are on the unit circle, \(\mathbf n=\mathbf x\) and \(\kappa = 1\) so that </p><p class="formulaDsp">
\[ -\Delta_\Gamma u = -8 x_1x_2. \]
</p>
<p class="endli">A somewhat simpler way, at least for the current case of a curve in two-dimensional space, is to note that we can map the interval \(t \in [0,\pi]\) onto the domain \(\Omega\) using the transformation \(\mathbf x(t)= \left(\begin{array}{c} \cos t \\ \sin t \end{array}\right)\). At position \(\mathbf x=\mathbf x(t)\), the value of the solution is then \(u(\mathbf x(t)) = -2\cos t \sin t\). Taking into account that the transformation is length preserving, i.e. a segment of length \(dt\) is mapped onto a piece of curve of exactly the same length, the tangential Laplacian then satisfies </p><p class="formulaDsp">
\begin{align*} \Delta_\Gamma u &amp;= \frac{d^2}{dt^2}(-2\cos t \sin t) = -2 \frac{d}{dt}(-\sin^2 t + \cos^2 t) = -2 (-2 \sin t \cos t - 2 \cos t \sin t) \\ &amp;= 8 \sin t \cos t \\ &amp;= 8 x_1x_2, \end{align*}
</p>
<p> which is of course the same result as we had above.  </p>
</li>
<li>
In 3d, the domain is again half of the surface of the unit ball, i.e. a half sphere or dome. We choose \(u(\mathbf x)=-2\sin(\pi x_1)\cos(\pi x_2)e^z\) as the solution. We can compute the right hand side of the equation, \(f=-\Delta_\Gamma u\), in the same way as the method above (with \(\kappa = 2\)), yielding an awkward and lengthy expression. You can find the full expression in the source code.  </li>
</ul>
<p>In the program, we will also compute the \(H^1\) seminorm error of the solution. Since the solution function and its numerical approximation are only defined on the manifold, the obvious definition of this error functional is \(| e |_{H^1(\Gamma)} = | \nabla_\Gamma e |_{L_2(\Gamma)} = \left( \int_\Gamma | \nabla_\Gamma (u-u_h) |^2 \right)^{1/2}\). This requires us to provide the <em>tangential</em> gradient \(\nabla_\Gamma u\) to the function <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a> (first introduced in <a class="el" href="step_7.html">step-7</a>), which we will do by implementing the function <code>Solution::gradient</code> in the program below.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>If you've read through <a class="el" href="step_4.html">step-4</a> and understand the discussion above of how solution and right hand side correspond to each other, you will be immediately familiar with this program as well. In fact, there are only two things that are of significance:</p>
<ul>
<li>The way we generate the mesh that triangulates the computational domain.</li>
<li>The way we use <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> objects to describe that the domain on which we solve the partial differential equation is not planar but in fact curved.</li>
</ul>
<p><a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> objects were already introduced in <a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a> and as explained there, there is usually not a whole lot you have to know about how they work as long as you have a working description of how the boundary looks. In essence, we will simply declare an appropriate object of type <a class="el" href="classMappingQ.html">MappingQ</a> that will automatically obtain the boundary description from the <a class="el" href="classTriangulation.html">Triangulation</a>. The mapping object will then be passed to the appropriate functions, and we will get a boundary description for half circles or half spheres that is predefined in the library.</p>
<p>The rest of the program follows closely <a class="el" href="step_4.html">step-4</a> and, as far as computing the error, <a class="el" href="step_7.html">step-7</a>. Some aspects of this program, in particular the use of two template arguments on the classes <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and similar, are already described in detail in <a class="el" href="step_34.html">step-34</a>; you may wish to read through this tutorial program as well.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>If you've read through <a class="el" href="step_4.html">step-4</a> and <a class="el" href="step_7.html">step-7</a>, you will recognize that we have used all of the following include files there already. Consequently, we will not explain their meaning here again.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__control_8h.html">deal.II/lac/solver_control.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step38</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceBeltramiProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceBeltramiProblem</code> class template</h3>
<p>This class is almost exactly similar to the <code>LaplaceProblem</code> class in <a class="el" href="step_4.html">step-4</a>.</p>
<p>The essential differences are these:</p>
<ul>
<li>The template parameter now denotes the dimensionality of the embedding space, which is no longer the same as the dimensionality of the domain and the triangulation on which we compute. We indicate this by calling the parameter <code>spacedim</code>, and introducing a constant <code>dim</code> equal to the dimensionality of the domain &ndash; here equal to <code>spacedim-1</code>.</li>
<li>All member variables that have geometric aspects now need to know about both their own dimensionality as well as that of the embedding space. Consequently, we need to specify both of their template parameters one for the dimension of the mesh <code>dim</code>, and the other for the dimension of the embedding space, <code>spacedim</code>. This is exactly what we did in <a class="el" href="step_34.html">step-34</a>, take a look there for a deeper explanation.</li>
<li>We need an object that describes which kind of mapping to use from the reference cell to the cells that the triangulation is composed of. The classes derived from the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> base class do exactly this. Throughout most of deal.II, if you don't do anything at all, the library assumes that you want an object of kind <a class="el" href="classMappingQ1.html">MappingQ1</a> that uses a (bi-, tri-)linear mapping. In many cases, this is quite sufficient, which is why the use of these objects is mostly optional: for example, if you have a polygonal two-dimensional domain in two-dimensional space, a bilinear mapping of the reference cell to the cells of the triangulation yields an exact representation of the domain. If you have a curved domain, one may want to use a higher order mapping for those cells that lie at the boundary of the domain &ndash; this is what we did in <a class="el" href="step_11.html">step-11</a>, for example. However, here we have a curved domain, not just a curved boundary, and while we can approximate it with bilinearly mapped cells, it is really only prudent to use a higher order mapping for all cells. Consequently, this class has a member variable of type <a class="el" href="classMappingQ.html">MappingQ</a>; we will choose the polynomial degree of the mapping equal to the polynomial degree of the finite element used in the computations to ensure optimal approximation, though this iso-parametricity is not required.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceBeltramiProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceBeltramiProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree = 2);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = spacedim - 1;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> compute_error() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a>    dof_handler;</div><div class="line">  <a class="code" href="classMappingQ.html">MappingQ&lt;dim, spacedim&gt;</a>      mapping;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Next, let us define the classes that describe the exact solution and the right hand sides of the problem. This is in analogy to <a class="el" href="step_4.html">step-4</a> and <a class="el" href="step_7.html">step-7</a> where we also defined such objects. Given the discussion in the introduction, the actual formulas should be self-explanatory. A point of interest may be how we define the value and gradient functions for the 2d and 3d cases separately, using explicit specializations of the general template. An alternative to doing it this way might have been to define the general template and have a <code>switch</code> statement (or a sequence of <code>if</code>s) for each possible value of the spatial dimension.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  <a class="code" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (-2. * p(0) * p(1));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> Solution&lt;2&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> return_value;</div><div class="line">  return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0));</div><div class="line">  return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(0)) * std::cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(1)) *</div><div class="line">          <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2)));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> Solution&lt;3&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> return_value;</div><div class="line"></div><div class="line">  return_value[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  return_value[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  return_value[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (-8. * p(0) * p(1));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa13fcf221bed4879f9b319347525f703b">hessian</a>;</div><div class="line"></div><div class="line">  hessian[0][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[1][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[2][2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  hessian[0][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[1][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  hessian[0][2] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[2][0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  hessian[1][2] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[2][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">gradient</a>;</div><div class="line">  gradient[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  gradient[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  gradient[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> normal = p;</div><div class="line">  normal /= p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (-<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(hessian) + 2 * (gradient * normal) +</div><div class="line">          (hessian * normal) * normal);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeLaplaceBeltramiProblemcodeclass"></a> </p><h3>Implementation of the <code>LaplaceBeltramiProblem</code> class</h3>
<p>The rest of the program is actually quite unspectacular if you know <a class="el" href="step_4.html">step-4</a>. Our first step is to define the constructor, setting the polynomial degree of the finite element and mapping, and associating the DoF handler to the triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">LaplaceBeltramiProblem&lt;spacedim&gt;::LaplaceBeltramiProblem(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree)</div><div class="line">  : fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , mapping(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemmake_grid_and_dofs"></a> </p><h4>LaplaceBeltramiProblem::make_grid_and_dofs</h4>
<p>The next step is to create the mesh, distribute degrees of freedom, and set up the various variables that describe the linear system. All of these steps are standard with the exception of how to create a mesh that describes a surface. We could generate a mesh for the domain we are interested in, generate a triangulation using a mesh generator, and read it in using the <a class="el" href="classGridIn.html">GridIn</a> class. Or, as we do here, we generate the mesh using the facilities in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace.</p>
<p>In particular, what we're going to do is this (enclosed between the set of braces below): we generate a <code>spacedim</code> dimensional mesh for the half disk (in 2d) or half ball (in 3d), using the <a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a> function. This function sets the boundary indicators of all faces on the outside of the boundary to zero for the ones located on the perimeter of the disk/ball, and one on the straight part that splits the full disk/ball into two halves. The next step is the main point: The <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a> function creates a mesh that consists of those cells that are the faces of the previous mesh, i.e. it describes the <em>surface</em> cells of the original (volume) mesh. However, we do not want all faces: only those on the perimeter of the disk or ball which carry boundary indicator zero; we can select these cells using a set of boundary indicators that we pass to <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>.</p>
<p>There is one point that needs to be mentioned. In order to refine a surface mesh appropriately if the manifold is curved (similarly to refining the faces of cells that are adjacent to a curved boundary), the triangulation has to have an object attached to it that describes where new vertices should be located. If you don't attach such a boundary object, they will be located halfway between existing vertices; this is appropriate if you have a domain with straight boundaries (e.g. a polygon) but not when, as here, the manifold has curvature. So for things to work properly, we need to attach a manifold object to our (surface) triangulation, in much the same way as we've already done in 1d for the boundary. We create such an object and attach it to the triangulation.</p>
<p>The final step in creating the mesh is to refine it a number of times. The rest of the function is the same as in previous tutorial programs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">    boundary_ids.insert(0);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh,</div><div class="line">                                         triangulation,</div><div class="line">                                         boundary_ids);</div><div class="line">  }</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim, spacedim&gt;</a>());</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; degrees of freedom.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemassemble_system"></a> </p><h4>LaplaceBeltramiProblem::assemble_system</h4>
<p>The following is the central function of this program, assembling the matrix that corresponds to the surface Laplacian (Laplace-Beltrami operator). Maybe surprisingly, it actually looks exactly the same as for the regular Laplace operator discussed in, for example, <a class="el" href="step_4.html">step-4</a>. The key is that the <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">FEValues::shape_grad()</a> function does the magic: It returns the surface gradient \(\nabla_K \phi_i(x_q)\) of the \(i\)th shape function at the \(q\)th quadrature point. The rest then does not need any changes either:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_values(mapping,</div><div class="line">                                    fe,</div><div class="line">                                    quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  RightHandSide&lt;spacedim&gt; rhs;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      rhs.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                         rhs_values[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, Solution&lt;spacedim&gt;(), boundary_values);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(</div><div class="line">    boundary_values, system_matrix, solution, system_rhs, <span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemsolve"></a> </p><h4>LaplaceBeltramiProblem::solve</h4>
<p>The next function is the one that solves the linear system. Here, too, no changes are necessary:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemoutput_result"></a> </p><h4>LaplaceBeltramiProblem::output_result</h4>
<p>This is the function that generates graphical output from the solution. Most of it is boilerplate code, but there are two points worth pointing out:</p>
<ul>
<li>The <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function can take two kinds of vectors: Either vectors that have one value per degree of freedom defined by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object previously attached via <a class="el" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut::attach_dof_handler()</a>; and vectors that have one value for each cell of the triangulation, for example to output estimated errors for each cell. Typically, the <a class="el" href="classDataOut.html">DataOut</a> class knows to tell these two kinds of vectors apart: there are almost always more degrees of freedom than cells, so we can differentiate by the two kinds looking at the length of a vector. We could do the same here, but only because we got lucky: we use a half sphere. If we had used the whole sphere as domain and \(Q_1\) elements, we would have the same number of cells as vertices and consequently the two kinds of vectors would have the same number of elements. To avoid the resulting confusion, we have to tell the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function which kind of vector we have: DoF data. This is what the third argument to the function does.</li>
<li>The <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> function can generate output that subdivides each cell so that visualization programs can resolve curved manifolds or higher polynomial degree shape functions better. We here subdivide each element in each coordinate direction as many times as the polynomial degree of the finite element in use.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;::type_dof_data</a>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, mapping.get_degree());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) + <span class="stringliteral">&quot;d.vtk&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemcompute_error"></a> </p><h4>LaplaceBeltramiProblem::compute_error</h4>
<p>This is the last piece of functionality: we want to compute the error in the numerical solution. It is a verbatim copy of the code previously shown and discussed in <a class="el" href="step_7.html">step-7</a>. As mentioned in the introduction, the <code>Solution</code> class provides the (tangential) gradient of the solution. To avoid evaluating the error only a superconvergence points, we choose a quadrature rule of sufficiently high order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::compute_error()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    Solution&lt;spacedim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> h1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                      difference_per_cell,</div><div class="line">                                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;H1 error = &quot;</span> &lt;&lt; h1_error &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemrun"></a> </p><h4>LaplaceBeltramiProblem::run</h4>
<p>The last function provides the top-level logic. Its contents are self-explanatory:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceBeltramiProblem&lt;spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">    compute_error();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step38</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The remainder of the program is taken up by the <code>main()</code> function. It follows exactly the general layout first introduced in <a class="el" href="step_6.html">step-6</a> and used in all following tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step38;</div><div class="line"></div><div class="line">      LaplaceBeltramiProblem&lt;3&gt; laplace_beltrami;</div><div class="line">      laplace_beltrami.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When you run the program, the following output should be printed on screen:</p>
<pre class="fragment">Surface mesh has 1280 cells.
Surface mesh has 5185 degrees of freedom.
H1 error = 0.0217136
</pre><p>By playing around with the number of global refinements in the <code>LaplaceBeltrami::make_grid_and_dofs</code> function you increase or decrease mesh refinement. For example, doing one more refinement and only running the 3d surface problem yields the following output:</p>
<pre class="fragment">Surface mesh has 5120 cells.
Surface mesh has 20609 degrees of freedom.
H1 error = 0.00543481
</pre><p>This is what we expect: make the mesh size smaller by a factor of two and the error goes down by a factor of four (remember that we use bi-quadratic elements). The full sequence of errors from one to five refinements looks like this, neatly following the theoretically predicted pattern: </p><pre class="fragment">0.339438
0.0864385
0.0217136
0.00543481
0.00135913
</pre><p>Finally, the program produces graphical output that we can visualize. Here is a plot of the results:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.solution-3d.png"/>
</div>
<p>The program also works for 1d curves in 2d, not just 2d surfaces in 3d. You can test this by changing the template argument in <code>main()</code> like so: </p><div class="fragment"><div class="line">LaplaceBeltramiProblem&lt;2&gt; laplace_beltrami;</div></div><!-- fragment --><p> The domain is a curve in 2d, and we can visualize the solution by using the third dimension (and color) to denote the value of the function \(u(x)\). This then looks like so (the white curve is the domain, the colored curve is the solution extruded into the third dimension, clearly showing the change in sign as the curve moves from one quadrant of the domain into the adjacent one):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.solution-2d.png"/>
</div>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Computing on surfaces only becomes interesting if the surface is more interesting than just a half sphere. To achieve this, deal.II can read meshes that describe surfaces through the usual <a class="el" href="classGridIn.html">GridIn</a> class. Or, in case you have an analytic description, a simple mesh can sometimes be stretched and bent into a shape we are interested in.</p>
<p>Let us consider a relatively simple example: we take the half sphere we used before, we stretch it by a factor of 10 in the z-direction, and then we jumble the x- and y-coordinates a bit. Let's show the computational domain and the solution first before we go into details of the implementation below:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.warp-1.png"/>
</div>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.warp-2.png"/>
</div>
<p>The way to produce such a mesh is by using the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function. It needs a way to transform each individual mesh point to a different position. Let us here use the following, rather simple function (remember: stretch in one direction, jumble in the other two):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> warp(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> q = p;</div><div class="line">  q[spacedim-1] *= 10;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (spacedim &gt;= 2)</div><div class="line">    q[0] += 2*<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(q[spacedim-1]);</div><div class="line">  <span class="keywordflow">if</span> (spacedim &gt;= 3)</div><div class="line">    q[1] += 2*<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(q[spacedim-1]);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> q;</div><div class="line">}</div></div><!-- fragment --><p>If we followed the <code>LaplaceBeltrami::make_grid_and_dofs</code> function, we would extract the half spherical surface mesh as before, warp it into the shape we want, and refine as often as necessary. This is not quite as simple as we'd like here, though: refining requires that we have an appropriate manifold object attached to the triangulation that describes where new vertices of the mesh should be located upon refinement. I'm sure it's possible to describe this manifold in a not-too-complicated way by simply undoing the transformation above (yielding the spherical surface again), finding the location of a new point on the sphere, and then re-warping the result. But I'm a lazy person, and since doing this is not really the point here, let's just make our lives a bit easier: we'll extract the half sphere, refine it as often as necessary, get rid of the object that describes the manifold since we now no longer need it, and then finally warp the mesh. With the function above, this would look as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltrami&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line">    volume_mesh.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">    boundary_ids.insert(0);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh, triangulation,</div><div class="line">                                         boundary_ids);</div><div class="line">    <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;warp&lt;spacedim&gt;, triangulation);       <span class="comment">/* ** */</span></div><div class="line">    std::ofstream x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(volume_mesh, x);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(triangulation, y);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>Note that the only essential addition is the line marked with asterisks. It is worth pointing out one other thing here, though: because we detach the manifold description from the surface mesh, whenever we use a mapping object in the rest of the program, it has no curves boundary description to go on any more. Rather, it will have to use the implicit, <a class="el" href="classFlatManifold.html">FlatManifold</a> class that is used on all parts of the domain not explicitly assigned a different manifold object. Consequently, whether we use <a class="el" href="classMappingQ.html">MappingQ(2)</a>, <a class="el" href="classMappingQ.html">MappingQ(15)</a> or <a class="el" href="classMappingQ1.html">MappingQ1</a>, each cell of our mesh will be mapped using a bilinear approximation.</p>
<p>All these drawbacks aside, the resulting pictures are still pretty. The only other differences to what's in <a class="el" href="step_38.html">step-38</a> is that we changed the right hand side to \(f(\mathbf x)=\sin x_3\) and the boundary values (through the <code>Solution</code> class) to \(u(\mathbf x)|_{\partial\Omega}=\cos x_3\). Of course, we now no longer know the exact solution, so the computation of the error at the end of <code>LaplaceBeltrami::run</code> will yield a meaningless number.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Andrea Bonito, Sebastian Pauletti.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__control_8h.html">deal.II/lac/solver_control.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step38</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceBeltramiProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceBeltramiProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree = 2);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = spacedim - 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> compute_error() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a>    dof_handler;</div><div class="line">    <a class="code" href="classMappingQ.html">MappingQ&lt;dim, spacedim&gt;</a>      mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (-2. * p(0) * p(1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> Solution&lt;2&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> return_value;</div><div class="line">    return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0));</div><div class="line">    return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(0)) * std::cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(1)) *</div><div class="line">            <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2)));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> Solution&lt;3&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> return_value;</div><div class="line"></div><div class="line">    return_value[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    return_value[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    return_value[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (-8. * p(0) * p(1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> hessian;</div><div class="line"></div><div class="line">    hessian[0][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[1][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[0][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[1][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[0][2] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[1][2] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> gradient;</div><div class="line">    gradient[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    gradient[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    gradient[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> normal = p;</div><div class="line">    normal /= p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (-<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(hessian) + 2 * (gradient * normal) +</div><div class="line">            (hessian * normal) * normal);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  LaplaceBeltramiProblem&lt;spacedim&gt;::LaplaceBeltramiProblem(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree)</div><div class="line">    : fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , mapping(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line">      std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">      boundary_ids.insert(0);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh,</div><div class="line">                                           triangulation,</div><div class="line">                                           boundary_ids);</div><div class="line">    }</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim, spacedim&gt;</a>());</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; degrees of freedom.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.n_dofs());</div><div class="line">    system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_values(mapping,</div><div class="line">                                      fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    RightHandSide&lt;spacedim&gt; rhs;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        rhs.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                           rhs_values[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              system_matrix.add(local_dof_indices[i],</div><div class="line">                                local_dof_indices[j],</div><div class="line">                                cell_matrix(i, j));</div><div class="line"></div><div class="line">            system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, Solution&lt;spacedim&gt;(), boundary_values);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(</div><div class="line">      boundary_values, system_matrix, solution, system_rhs, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;::type_dof_data</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, mapping.get_degree());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) + <span class="stringliteral">&quot;d.vtk&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::compute_error()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      Solution&lt;spacedim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> h1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                        difference_per_cell,</div><div class="line">                                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;H1 error = &quot;</span> &lt;&lt; h1_error &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceBeltramiProblem&lt;spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">    compute_error();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step38</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step38;</div><div class="line"></div><div class="line">      LaplaceBeltramiProblem&lt;3&gt; laplace_beltrami;</div><div class="line">      laplace_beltrami.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_34.html">step-34</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Testcase">Testcase</a><a href="#Testcase">Testcase</a>
        <li><a href="#Implementation">Implementation</a><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeLaplaceBeltramiProblemcodeclasstemplate">The <code>LaplaceBeltramiProblem</code> class template</a><a href="#ThecodeLaplaceBeltramiProblemcodeclasstemplate">The <code>LaplaceBeltramiProblem</code> class template</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeLaplaceBeltramiProblemcodeclass">Implementation of the <code>LaplaceBeltramiProblem</code> class</a><a href="#ImplementationofthecodeLaplaceBeltramiProblemcodeclass">Implementation of the <code>LaplaceBeltramiProblem</code> class</a>
      <ul>
        <li><a href="#LaplaceBeltramiProblemmake_grid_and_dofs">LaplaceBeltramiProblem::make_grid_and_dofs</a><a href="#LaplaceBeltramiProblemmake_grid_and_dofs">LaplaceBeltramiProblem::make_grid_and_dofs</a>
        <li><a href="#LaplaceBeltramiProblemassemble_system">LaplaceBeltramiProblem::assemble_system</a><a href="#LaplaceBeltramiProblemassemble_system">LaplaceBeltramiProblem::assemble_system</a>
        <li><a href="#LaplaceBeltramiProblemsolve">LaplaceBeltramiProblem::solve</a><a href="#LaplaceBeltramiProblemsolve">LaplaceBeltramiProblem::solve</a>
        <li><a href="#LaplaceBeltramiProblemoutput_result">LaplaceBeltramiProblem::output_result</a><a href="#LaplaceBeltramiProblemoutput_result">LaplaceBeltramiProblem::output_result</a>
        <li><a href="#LaplaceBeltramiProblemcompute_error">LaplaceBeltramiProblem::compute_error</a><a href="#LaplaceBeltramiProblemcompute_error">LaplaceBeltramiProblem::compute_error</a>
        <li><a href="#LaplaceBeltramiProblemrun">LaplaceBeltramiProblem::run</a><a href="#LaplaceBeltramiProblemrun">LaplaceBeltramiProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em>This program was contributed by Andrea Bonito and M. Sebastian Pauletti, with editing and writing by Wolfgang Bangerth. <br />
 This material is based upon work supported by the National Science Foundation under Grant No. DMS-0914977. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation (NSF). </em> <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>In this example, we show how to solve a partial differential equation (PDE)on a codimension one surface \(\Gamma \subset \mathbb R^3\) made of quadrilaterals, i.e. on a surface in 3d or a line in 2d.We focus on the following elliptic second order PDE </p><p class="formulaDsp">
\begin{align*} -\Delta_\Gamma u &amp;= f \qquad \text{on } \qquad \Gamma,\\ u &amp;= g \qquad \text{on} \qquad \partial \Gamma, \end{align*}
</p>
<p> which generalized the Laplace equation we have previously solved in several ofthe early tutorial programs. Our implementation is based on <a class="el" href="step_4.html">step-4</a> . <a class="el" href="step_34.html">step-34</a> also solves problems on lower dimensional surfaces; however, there we onlyconsider integral equations that do not involve derivatives on the solutionvariable, while here we actually have to investigate what it means to takederivatives of a function only defined on a (possibly curved) surface. In order to define the above operator, we start by introducing some notations.Let \(\mathbf x_S:\hat S \rightarrow S\) be a parameterization ofa surface \(S\) from a reference element \(\hat S \subset \mathbb R^2\) ,i.e. each point \(\hat{\mathbf x}\in\hat S\) induces a point \({\mathbf x}_S(\hat{\mathbf x}) \in S\) . Then let </p><p class="formulaDsp">
\[ G_S\dealcoloneq (D \mathbf{x}_S)^T \ D \mathbf{x}_S \]
</p>
<p> the corresponding first fundamental form, where \(D \mathbf{x}_S=\left(\frac{\partial x_{S,i}(\hat{\mathbf x})}{\partial \hat x_j}\right)_{ij}\) is thederivative (Jacobian) of the mapping.In the following, \(S\) will be either the entire surface \(\Gamma\) or,more convenient for the finite element method, any face \(S \in {\mathbb T}\) , where \({\mathbb T}\) is a partition (triangulation) of \(\Gamma\) constituted of quadrilaterals.We are now in position to define the tangential gradient of a function \(v : S \rightarrow \mathbb R\) by </p><p class="formulaDsp">
\[ (\nabla_S v)\circ \mathbf x_S \dealcoloneq D \mathbf x_S \ G_S^{-1} \ \nabla (v \circ \mathbf x_S). \]
</p>
<p> surface Laplacian (also called the Laplace-Beltrami operator) is thendefined as \(\Delta_S \dealcoloneq \nabla_S \cdot \nabla_S\) .Note that an alternate way to compute the surface gradient on smooth surfaces \(\Gamma\) is </p><p class="formulaDsp">
\[ \nabla_S v = \nabla \tilde v - \mathbf n (\mathbf n \cdot \nabla \tilde v), \]
</p>
<p> \(\tilde v\) is a "smooth" extension of \(v\) in a tubular neighborhood of \(\Gamma\) and \(\mathbf n\) is the normal of \(\Gamma\) .Since \(\Delta_S = \nabla_S \cdot \nabla_S\) , we deduce </p><p class="formulaDsp">
\[ \Delta_S v = \Delta \tilde v - \mathbf n^T \ D^2 \tilde v \ \mathbf n - (\mathbf n \cdot \nabla \tilde v) (\nabla \cdot \mathbf n - \mathbf n^T \ D \mathbf n \ \mathbf n ). \]
</p>
<p> mentioning, the term \(\nabla \cdot \mathbf n - \mathbf n \ D \mathbf n \ \mathbf n\) appearing in the above expression is the total curvature of the surface (sum of principal curvatures). As usual, we are only interested in weak solutions for which we can use \(C^0\) finite elements (rather than requiring \(C^1\) continuity as for strongsolutions). We therefore resort to the weak formulation </p><p class="formulaDsp">
\[ \int_\Gamma \nabla_\Gamma u \cdot \nabla_\Gamma v = \int_\Gamma f \ v \qquad \forall v \in H^1_0(\Gamma) \]
</p>
<p> take advantage of the partition \({\mathbb T}\) to further write </p><p class="formulaDsp">
\[ \sum_{K\in {\mathbb T}}\int_K \nabla_{K} u \cdot \nabla_{K} v = \sum_{K\in {\mathbb T}} \int_K f \ v \qquad \forall v \in H^1_0(\Gamma). \]
</p>
<p>, each integral in the above expression is computed in the referenceelement \(\hat K \dealcoloneq [0,1]^2\) so that </p><p class="formulaDsp">
\begin{align*} \int_{K} \nabla_{K} u \cdot \nabla_{K} v &amp;= \int_{\hat K} \nabla (u \circ \mathbf x_K)^T G_K^{-1} (D \mathbf x_K)^T D \mathbf x_K G_K^{-1} \nabla (v \circ \mathbf x_K) \sqrt{\det (G_K)} \\ &amp;= \int_{\hat K} \nabla (u \circ \mathbf x_K)^T G_K^{-1} \nabla (v \circ \mathbf x_K) \sqrt{\det (G_K)} \end{align*}
</p>
<p> and </p><p class="formulaDsp">
\[ \int_{K} f \ v = \int_{\hat K} (f \circ \mathbf x_K) (v \circ \mathbf x_K) \sqrt{\det (G_K)}. \]
</p>
<p>, we use a quadrature formula defined by points \(\{p_l\}_{l=1}^N\subset \hat K\) and weights \(\{w_l\}_{l=1}^N \subset \mathbb R^+_*\) toevaluate the above integrals andobtain </p><p class="formulaDsp">
\[\int_{K} \nabla_{K} u \cdot \nabla_{K} v \approx \sum_{l=1}^N (\nabla (u \circ \mathbf x_K)(p_l))^T G^{-1}(p_l) \nabla (v \circ \mathbf x_K) (p_l) \sqrt{\det (G(p_l))} \ w_l \]
</p>
 <p class="formulaDsp">
\[ \int_{K} f \ v \approx \sum_{l=1}^N (f \circ \mathbf x_K)(p_l) \ (v \circ \mathbf x_K)(p_l) \sqrt{\det (G(p_l))} \ w_l. \]
</p>
<p>Fortunately, deal.II has already all the tools to compute the aboveexpressions.In fact, they barely differ from the ways in which we solve the usualLaplacian, only requiring the surface coordinate mapping to be provided in theconstructor of the <a class="el" href="classFEValues.html">FEValues</a> class.This surface description given, in the codimension one surface case, the tworoutines <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">FEValues::shape_grad</a> and <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW</a> return </p><p class="formulaDsp">
\begin{align*} \text{FEValues::shape\_grad}(i,l)&amp;=D \mathbf x_K(p_l) G^{-1}(p_l)D(\varphi_i \circ \mathbf x_K) (p_l) \\ \text{FEValues::JxW}(l) &amp;= \sqrt{\det (G(p_l))} \ w_l. \end{align*}
</p>
<p> This provides exactly the terms we need for our computations. On a more general note, details for the finite element approximation onsurfaces can be found for instance in[Dziuk, in Partial differential equations and calculus ofvariations 1357, Lecture Notes in Math., 1988],[Demlow, SIAM J. Numer. Anal. 47(2), 2009]and[Bonito, Nochetto, and Pauletti, SIAM J. Numer. Anal. 48(5), 2010].</p>
<p><a class="anchor" id="Testcase"></a></p><h3>Testcase</h3>
<p>In general when you want to test numerically the accuracy and/or order ofconvergence of an algorithm you need to provide an exact solution. The usualtrick is to pick a function that we want to be the solution, then apply thedifferential operator to it that defines a forcing term for the right handside. This is what we do in this example. In the current case, the form of thedomain is obviously also essential. We produce one test case for a 2d problem and another one for 3d: </p><ul>
<li>
In 2d, let's choose as domain a half circle. On this domain, we choose the function \(u(\mathbf x)=-2x_1x_2\) as the solution. To compute the right hand side, we have to compute the surface Laplacian of the solution function. There are (at least) two ways to do that. The first one is to project away the normal derivative as described above using the natural extension of \(u(\mathbf x)\) (still denoted by \(u\) ) over \(\mathbb R^d\) , i.e. to compute <p class="formulaDsp">
\[ -\Delta_\Gamma u = \Delta u - \mathbf n^T \ D^2 u \ \mathbf n - (\mathbf n \cdot \nabla u)\ \kappa, \]
</p>
 where \(\kappa\) is the total curvature of \(\Gamma\) . Since we are on the unit circle, \(\mathbf n=\mathbf x\) and \(\kappa = 1\) so that <p class="formulaDsp">
\[ -\Delta_\Gamma u = -8 x_1x_2. \]
</p>
 A somewhat simpler way, at least for the current case of a curve in two-dimensional space, is to note that we can map the interval \(t \in [0,\pi]\) onto the domain \(\Omega\) using the transformation \(\mathbf x(t)= \left(\begin{array}{c} \cos t \\ \sin t \end{array}\right)\) . At position \(\mathbf x=\mathbf x(t)\) , the value of the solution is then \(u(\mathbf x(t)) = -2\cos t \sin t\) . Taking into account that the transformation is length preserving, i.e. a segment of length \(dt\) is mapped onto a piece of curve of exactly the same length, the tangential Laplacian then satisfies <p class="formulaDsp">
\begin{align*} \Delta_\Gamma u &amp;= \frac{d^2}{dt^2}(-2\cos t \sin t) = -2 \frac{d}{dt}(-\sin^2 t + \cos^2 t) = -2 (-2 \sin t \cos t - 2 \cos t \sin t) \\ &amp;= 8 \sin t \cos t \\ &amp;= 8 x_1x_2, \end{align*}
</p>
 which is of course the same result as we had above.  </li>
<li>
In 3d, the domain is again half of the surface of the unit ball, i.e. a half sphere or dome. We choose \(u(\mathbf x)=-2\sin(\pi x_1)\cos(\pi x_2)e^z\) as the solution. We can compute the right hand side of the equation, \(f=-\Delta_\Gamma u\) , in the same way as the method above (with \(\kappa = 2\) ), yielding an awkward and lengthy expression. You can find the full expression in the source code.  </li>
</ul>
<p>In the program, we will also compute the \(H^1\) seminorm error of thesolution. Since the solution function and its numerical approximation are onlydefined on the manifold, the obvious definition of this error functional is \(| e |_{H^1(\Gamma)} = | \nabla_\Gamma e |_{L_2(\Gamma)} = \left( \int_\Gamma | \nabla_\Gamma (u-u_h) |^2 \right)^{1/2}\) . This requires us to provide the<em>tangential</em> gradient \(\nabla_\Gamma u\) to the function <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a> (first introduced in <a class="el" href="step_7.html">step-7</a> ), which wewill do by implementing the function <code>Solution::gradient</code> in theprogram below.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>If you've read through <a class="el" href="step_4.html">step-4</a> and understand the discussion above of howsolution and right hand side correspond to each other, you will be immediatelyfamiliar with this program as well. In fact, there are only two things thatare of significance:</p>
<ul>
<li>The way we generate the mesh that triangulates the computational domain.</li>
<li>The way we use <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> objects to describe that the domain on which we solve the partial differential equation is not planar but in fact curved. <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> objects were already introduced in <a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a> and asexplained there, there is usually not a whole lot you have to know about howthey work as long as you have a working description of how the boundarylooks. In essence, we will simply declare an appropriate object of typeMappingQ that will automatically obtain the boundary description from theTriangulation. The mapping object will then be passed to the appropriatefunctions, and we will get a boundary description for half circles or halfspheres that is predefined in the library. The rest of the program follows closely <a class="el" href="step_4.html">step-4</a> and, as far as computing theerror, <a class="el" href="step_7.html">step-7</a> . Some aspects of this program, in particular the use of twotemplate arguments on the classes <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and similar, arealready described in detail in <a class="el" href="step_34.html">step-34</a> ; you may wish to read through thistutorial program as well.</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>If you've read through <a class="el" href="step_4.html">step-4</a> and <a class="el" href="step_7.html">step-7</a> , you will recognize that we have used all of the following include files there already. Consequently, we will not explain their meaning here again.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__control_8h.html">deal.II/lac/solver_control.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step38</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceBeltramiProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceBeltramiProblem</code> class template</h3>
<p>This class is almost exactly similar to the <code>LaplaceProblem</code> class in <a class="el" href="step_4.html">step-4</a> .</p>
<p>The essential differences are these:</p>
<ul>
<li>The template parameter now denotes the dimensionality of the embedding space, which is no longer the same as the dimensionality of the domain and the triangulation on which we compute. We indicate this by calling the parameter <code>spacedim</code>, and introducing a constant <code>dim</code> equal to the dimensionality of the domain</li>
<li>here equal to <code>spacedim-1</code> .</li>
<li>All member variables that have geometric aspects now need to know about both their own dimensionality as well as that of the embedding space. Consequently, we need to specify both of their template parameters one for the dimension of the mesh <code>dim</code>, and the other for the dimension of the embedding space, <code>spacedim</code>. This is exactly what we did in <a class="el" href="step_34.html">step-34</a> , take a look there for a deeper explanation.</li>
<li>We need an object that describes which kind of mapping to use from the reference cell to the cells that the triangulation is composed of. The classes derived from the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> base class do exactly this. Throughout most of deal.II, if you don't do anything at all, the library assumes that you want an object of kind <a class="el" href="classMappingQ1.html">MappingQ1</a> that uses a (bi-, tri-)linear mapping. In many cases, this is quite sufficient, which is why the use of these objects is mostly optional: for example, if you have a polygonal two-dimensional domain in two-dimensional space, a bilinear mapping of the reference cell to the cells of the triangulation yields an exact representation of the domain. If you have a curved domain, one may want to use a higher order mapping for those cells that lie at the boundary of the domain</li>
<li>this is what we did in <a class="el" href="step_11.html">step-11</a> , for example. However, here we have a curved domain, not just a curved boundary, and while we can approximate it with bilinearly mapped cells, it is really only prudent to use a higher order mapping for all cells. Consequently, this class has a member variable of type <a class="el" href="classMappingQ.html">MappingQ</a>; we will choose the polynomial degree of the mapping equal to the polynomial degree of the finite element used in the computations to ensure optimal approximation, though this iso-parametricity is not required.</li>
</ul>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">   <span class="keyword">class </span>LaplaceBeltramiProblem</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     LaplaceBeltramiProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree = 2);</div><div class="line">     <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line">  </div><div class="line">   <span class="keyword">private</span>:</div><div class="line">     <span class="keyword">static</span> constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = spacedim</div><div class="line">  </div><div class="line">- 1;</div><div class="line">  </div><div class="line">     <span class="keywordtype">void</span> make_grid_and_dofs();</div><div class="line">     <span class="keywordtype">void</span> assemble_system();</div><div class="line">     <span class="keywordtype">void</span> solve();</div><div class="line">     <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line">     <span class="keywordtype">void</span> compute_error() <span class="keyword">const</span>;</div><div class="line">  </div><div class="line"> </div><div class="line">     <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">     <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>          fe;</div><div class="line">     <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a>    dof_handler;</div><div class="line">     <a class="code" href="classMappingQ.html">MappingQ&lt;dim, spacedim&gt;</a>      mapping;</div><div class="line">  </div><div class="line">     <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">     <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  </div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">   };</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Next, let us define the classes that describe the exact solution and the right hand sides of the problem. This is in analogy to <a class="el" href="step_4.html">step-4</a> and <a class="el" href="step_7.html">step-7</a> where we also defined such objects. Given the discussion in the introduction, the actual formulas should be self-explanatory. A point of interest may be how we define the value and gradient functions for the 2d and 3d cases separately, using explicit specializations of the general template. An alternative to doing it this way might have been to define the general template and have a <code>switch</code> statement (or a sequence of <code>if</code> s) for each possible value of the spatial dimension.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">     <a class="code" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <span class="keywordtype">double</span> Solution&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">return</span> (-2. p(0) p(1));</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> Solution&lt;2&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> return_value;</div><div class="line">     return_value[0] =</div><div class="line">  </div><div class="line">-2. p(1) (1</div><div class="line">  </div><div class="line">- 2. p(0) p(0));</div><div class="line">     return_value[1] =</div><div class="line">  </div><div class="line">-2. p(0) (1</div><div class="line">  </div><div class="line">- 2. p(1) p(1));</div><div class="line">  </div><div class="line">     return return_value;</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   template &lt;&gt;</div><div class="line">   <span class="keywordtype">double</span> Solution&lt;3&gt;::value(const <a class="code" href="classPoint.html">Point</a>&lt;3&gt; &amp;p, const <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">return</span> (std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> p(0)) std::cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> p(1))</div><div class="line">             <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2)));</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> Solution&lt;3&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  </div><div class="line">     <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> return_value;</div><div class="line">  </div><div class="line">     return_value[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     return_value[1] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     return_value[2] = sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">  </div><div class="line">     return return_value;</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   template &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   class RightHandSide : public <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <span class="keywordtype">double</span> RightHandSide&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">return</span> (-8. p(0) p(1));</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <span class="keywordtype">double</span> RightHandSide&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  </div><div class="line">     <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">hessian</a>;</div><div class="line">  </div><div class="line">     hessian[0][0] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     hessian[1][1] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     hessian[2][2] = sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">  </div><div class="line">     hessian[0][1] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     hessian[1][0] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">  </div><div class="line">     hessian[0][2] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     hessian[2][0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">  </div><div class="line">     hessian[1][2] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     hessian[2][1] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">  </div><div class="line">     <a class="code" href="classTensor.html">Tensor</a>&lt;1, 3&gt; gradient;</div><div class="line">     gradient[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     gradient[1] =</div><div class="line">  </div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">     gradient[2] = sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(0)) cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> p(1)) exp(p(2));</div><div class="line">  </div><div class="line">     <a class="code" href="classPoint.html">Point</a>&lt;3&gt; normal = p;</div><div class="line">     normal /= p.norm();</div><div class="line">  </div><div class="line">     return (-<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(hessian) + 2 (gradient normal) +</div><div class="line">             (hessian normal) normal);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeLaplaceBeltramiProblemcodeclass"></a> </p><h3>Implementation of the <code>LaplaceBeltramiProblem</code> class</h3>
<p>The rest of the program is actually quite unspectacular if you know <a class="el" href="step_4.html">step-4</a> . Our first step is to define the constructor, setting the polynomial degree of the finite element and mapping, and associating the DoF handler to the triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">LaplaceBeltramiProblem&lt;spacedim&gt;::LaplaceBeltramiProblem(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree)</div><div class="line">  : fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , mapping(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemmake_grid_and_dofs"></a> </p><h4>LaplaceBeltramiProblem::make_grid_and_dofs</h4>
<p>The next step is to create the mesh, distribute degrees of freedom, and set up the various variables that describe the linear system. All of these steps are standard with the exception of how to create a mesh that describes a surface. We could generate a mesh for the domain we are interested in, generate a triangulation using a mesh generator, and read it in using the <a class="el" href="classGridIn.html">GridIn</a> class. Or, as we do here, we generate the mesh using the facilities in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. In particular, what we're going to do is this (enclosed between the set of braces below): we generate a <code>spacedim</code> dimensional mesh for the half disk (in 2d) or half ball (in 3d), using the <a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a> function. This function sets the boundary indicators of all faces on the outside of the boundary to zero for the ones located on the perimeter of the disk/ball, and one on the straight part that splits the full disk/ball into two halves. The next step is the main point: The <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a> function creates a mesh that consists of those cells that are the faces of the previous mesh, i.e. it describes the <em>surface</em> cells of the original (volume) mesh. However, we do not want all faces: only those on the perimeter of the disk or ball which carry boundary indicator zero; we can select these cells using a set of boundary indicators that we pass to <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>. There is one point that needs to be mentioned. In order to refine a surface mesh appropriately if the manifold is curved (similarly to refining the faces of cells that are adjacent to a curved boundary), the triangulation has to have an object attached to it that describes where new vertices should be located. If you don't attach such a boundary object, they will be located halfway between existing vertices; this is appropriate if you have a domain with straight boundaries (e.g. a polygon) but not when, as here, the manifold has curvature. So for things to work properly, we need to attach a manifold object to our (surface) triangulation, in much the same way as we've already done in 1d for the boundary. We create such an object and attach it to the triangulation. The final step in creating the mesh is to refine it a number of times. The rest of the function is the same as in previous tutorial programs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">    boundary_ids.insert(0);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh,</div><div class="line">                                         triangulation,</div><div class="line">                                         boundary_ids);</div><div class="line">  }</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim, spacedim&gt;</a>());</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; degrees of freedom.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemassemble_system"></a> </p><h4>LaplaceBeltramiProblem::assemble_system</h4>
<p>The following is the central function of this program, assembling the matrix that corresponds to the surface Laplacian (Laplace-Beltrami operator). Maybe surprisingly, it actually looks exactly the same as for the regular Laplace operator discussed in, for example, <a class="el" href="step_4.html">step-4</a> . The key is that the <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">FEValues::shape_grad()</a> function does the magic: It returns the surface gradient \(\nabla_K \phi_i(x_q)\) of the \(i\) th shape function at the \(q\) th quadrature point. The rest then does not need any changes either:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(2 fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_values(mapping,</div><div class="line">                                    fe,</div><div class="line">                                    quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  RightHandSide&lt;spacedim&gt; rhs;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      rhs.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point)</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">                         rhs_values[q_point] fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, Solution&lt;spacedim&gt;(), boundary_values);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(</div><div class="line">    boundary_values, system_matrix, solution, system_rhs, <span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemsolve"></a> </p><h4>LaplaceBeltramiProblem::solve</h4>
<p>The next function is the one that solves the linear system. Here, too, no changes are necessary:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solution.size(), 1e-7 system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemoutput_result"></a> </p><h4>LaplaceBeltramiProblem::output_result</h4>
<p>This is the function that generates graphical output from the solution. Most of it is boilerplate code, but there are two points worth pointing out:</p>
<ul>
<li>The <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function can take two kinds of vectors: Either vectors that have one value per degree of freedom defined by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object previously attached via <a class="el" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut::attach_dof_handler()</a>; and vectors that have one value for each cell of the triangulation, for example to output estimated errors for each cell. Typically, the <a class="el" href="classDataOut.html">DataOut</a> class knows to tell these two kinds of vectors apart: there are almost always more degrees of freedom than cells, so we can differentiate by the two kinds looking at the length of a vector. We could do the same here, but only because we got lucky: we use a half sphere. If we had used the whole sphere as domain and \(Q_1\) elements, we would have the same number of cells as vertices and consequently the two kinds of vectors would have the same number of elements. To avoid the resulting confusion, we have to tell the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function which kind of vector we have: DoF data. This is what the third argument to the function does.</li>
<li>The <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> function can generate output that subdivides each cell so that visualization programs can resolve curved manifolds or higher polynomial degree shape functions better. We here subdivide each element in each coordinate direction as many times as the polynomial degree of the finite element in use.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;::type_dof_data</a>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, mapping.get_degree());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) + <span class="stringliteral">&quot;d.vtk&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemcompute_error"></a> </p><h4>LaplaceBeltramiProblem::compute_error</h4>
<p>This is the last piece of functionality: we want to compute the error in the numerical solution. It is a verbatim copy of the code previously shown and discussed in <a class="el" href="step_7.html">step-7</a> . As mentioned in the introduction, the <code>Solution</code> class provides the (tangential) gradient of the solution. To avoid evaluating the error only a superconvergence points, we choose a quadrature rule of sufficiently high order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::compute_error()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    Solution&lt;spacedim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> h1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                      difference_per_cell,</div><div class="line">                                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;H1 error = &quot;</span> &lt;&lt; h1_error &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemrun"></a> </p><h4>LaplaceBeltramiProblem::run</h4>
<p>The last function provides the top-level logic. Its contents are self-explanatory:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceBeltramiProblem&lt;spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">    compute_error();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step38</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The remainder of the program is taken up by the <code>main()</code> function. It follows exactly the general layout first introduced in <a class="el" href="step_6.html">step-6</a> and used in all following tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step38;</div><div class="line"> </div><div class="line">      LaplaceBeltramiProblem&lt;3&gt; laplace_beltrami;</div><div class="line">      laplace_beltrami.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When you run the program, the following output should be printed on screen: </p><pre class="fragment">Surface mesh has 1280 cells.
Surface mesh has 5185 degrees of freedom.
H1 error = 0.0217136
</pre><p>By playing around with the number of global refinements in the <code>LaplaceBeltrami::make_grid_and_dofs</code> function you increase or decrease meshrefinement. For example, doing one more refinement and only running the 3d surfaceproblem yields the followingoutput: </p><pre class="fragment">Surface mesh has 5120 cells.
Surface mesh has 20609 degrees of freedom.
H1 error = 0.00543481
</pre><p>This is what we expect: make the mesh size smaller by a factor of two and theerror goes down by a factor of four (remember that we use bi-quadraticelements). The full sequence of errors from one to five refinements looks likethis, neatly following the theoretically predicted pattern: </p><pre class="fragment">0.339438
0.0864385
0.0217136
0.00543481
0.00135913
</pre><p>Finally, the program produces graphical output that we can visualize. Here isa plot of the results: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.solution-3d.png"/>
</div>
<p> The program also works for 1d curves in 2d, not just 2d surfaces in 3d. Youcan test this by changing the template argument in <code>main()</code> likeso: </p><div class="fragment"><div class="line">LaplaceBeltramiProblem&lt;2&gt; laplace_beltrami;</div></div><!-- fragment --><p> The domain is a curve in 2d, and we can visualize the solution by using thethird dimension (and color) to denote the value of the function \(u(x)\) . Thisthen looks like so (the white curve is the domain, the colored curve is thesolution extruded into the third dimension, clearly showing the change in signas the curve moves from one quadrant of the domain into the adjacent one): </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.solution-2d.png"/>
</div>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Computing on surfaces only becomes interesting if the surface is moreinteresting than just a half sphere. To achieve this, deal.II can readmeshes that describe surfaces through the usual <a class="el" href="classGridIn.html">GridIn</a> class. Or, in case youhave an analytic description, a simple mesh can sometimes be stretched andbent into a shape we are interested in. Let us consider a relatively simple example: we take the half sphere we usedbefore, we stretch it by a factor of 10 in the z-direction, and then we jumblethe x- and y-coordinates a bit. Let's show the computational domain and thesolution first before we go into details of the implementation below: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.warp-1.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.warp-2.png"/>
</div>
<p> The way to produce such a mesh is by using the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function. It needs a way to transform each individual mesh point to adifferent position. Let us here use the following, rather simple function(remember: stretch in one direction, jumble in the other two): </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> warp(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> q = p;</div><div class="line">  q[spacedim-1]= 10;</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span> (spacedim &gt;= 2)</div><div class="line">    q[0] += 2*<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(q[spacedim-1]);</div><div class="line">  <span class="keywordflow">if</span> (spacedim &gt;= 3)</div><div class="line">    q[1] += 2*<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(q[spacedim-1]);</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> q;</div><div class="line">}</div></div><!-- fragment --><p>If we followed the <code>LaplaceBeltrami::make_grid_and_dofs</code> function, we wouldextract the half spherical surface mesh as before, warp it into the shape wewant, and refine as often as necessary. This is not quite as simple as we'dlike here, though: refining requires that we have an appropriate manifoldobject attached to the triangulation that describes where new vertices of themesh should be located upon refinement. I'm sure it's possible to describethis manifold in a not-too-complicated way by simply undoing thetransformation above (yielding the spherical surface again), finding thelocation of a new point on the sphere, and then re-warping the result. But I'ma lazy person, and since doing this is not really the point here, let's justmake our lives a bit easier: we'll extract the half sphere, refine it asoften as necessary, get rid of the object that describes the manifold since wenow no longer need it, and then finally warp the mesh. With the functionabove, this would look as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltrami&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line">  </div><div class="line">    volume_mesh.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line">  </div><div class="line">    std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">    boundary_ids.insert(0);</div><div class="line">  </div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh, triangulation,</div><div class="line">                                         boundary_ids);</div><div class="line">    <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;warp&lt;spacedim&gt;, triangulation);        <span class="comment">/* ** */</span> </div><div class="line">    std::ofstream x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(volume_mesh, x);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(triangulation, y);</div><div class="line">  }</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>Note that the only essential addition is the line marked withasterisks. It is worth pointing out one other thing here, though: because wedetach the manifold description from the surface mesh, whenever we use amapping object in the rest of the program, it has no curves boundarydescription to go on any more. Rather, it will have to use the implicit,<a class="el" href="classFlatManifold.html">FlatManifold</a> class that is used on all parts of the domain notexplicitly assigned a different manifold object. Consequently, whether we useMappingQ(2), <a class="el" href="classMappingQ.html">MappingQ(15)</a> or <a class="el" href="classMappingQ1.html">MappingQ1</a>, each cell of our mesh will be mappedusing a bilinear approximation. All these drawbacks aside, the resulting pictures are still pretty. The onlyother differences to what's in <a class="el" href="step_38.html">step-38</a> is that we changed the right hand sideto \(f(\mathbf x)=\sin x_3\) and the boundary values (through the <code>Solution</code> class) to \(u(\mathbf x)|_{\partial\Omega}=\cos x_3\) . Ofcourse, we now no longer know the exact solution, so the computation of theerror at the end of <code>LaplaceBeltrami::run</code> will yield a meaninglessnumber.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Andrea Bonito, Sebastian Pauletti.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__control_8h.html">deal.II/lac/solver_control.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step38</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceBeltramiProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceBeltramiProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree = 2);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = spacedim - 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> compute_error() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a>    dof_handler;</div><div class="line">    <a class="code" href="classMappingQ.html">MappingQ&lt;dim, spacedim&gt;</a>      mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (-2. * p(0) * p(1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> Solution&lt;2&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> return_value;</div><div class="line">    return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0));</div><div class="line">    return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(0)) * std::cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(1)) *</div><div class="line">            <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2)));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> Solution&lt;3&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> return_value;</div><div class="line"></div><div class="line">    return_value[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    return_value[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    return_value[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (-8. * p(0) * p(1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> hessian;</div><div class="line"></div><div class="line">    hessian[0][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[1][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[0][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[1][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[0][2] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[1][2] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> gradient;</div><div class="line">    gradient[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    gradient[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    gradient[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> normal = p;</div><div class="line">    normal /= p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (-<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(hessian) + 2 * (gradient * normal) +</div><div class="line">            (hessian * normal) * normal);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  LaplaceBeltramiProblem&lt;spacedim&gt;::LaplaceBeltramiProblem(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree)</div><div class="line">    : fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , mapping(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line">      std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">      boundary_ids.insert(0);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh,</div><div class="line">                                           triangulation,</div><div class="line">                                           boundary_ids);</div><div class="line">    }</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim, spacedim&gt;</a>());</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; degrees of freedom.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.n_dofs());</div><div class="line">    system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_values(mapping,</div><div class="line">                                      fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    RightHandSide&lt;spacedim&gt; rhs;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        rhs.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                           rhs_values[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              system_matrix.add(local_dof_indices[i],</div><div class="line">                                local_dof_indices[j],</div><div class="line">                                cell_matrix(i, j));</div><div class="line"></div><div class="line">            system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, Solution&lt;spacedim&gt;(), boundary_values);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(</div><div class="line">      boundary_values, system_matrix, solution, system_rhs, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;::type_dof_data</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, mapping.get_degree());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) + <span class="stringliteral">&quot;d.vtk&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::compute_error()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      Solution&lt;spacedim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> h1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                        difference_per_cell,</div><div class="line">                                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;H1 error = &quot;</span> &lt;&lt; h1_error &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceBeltramiProblem&lt;spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">    compute_error();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step38</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step38;</div><div class="line"></div><div class="line">      LaplaceBeltramiProblem&lt;3&gt; laplace_beltrami;</div><div class="line">      laplace_beltrami.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_34.html">step-34</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Testcase">Testcase</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeLaplaceBeltramiProblemcodeclasstemplate">The <code>LaplaceBeltramiProblem</code> class template</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeLaplaceBeltramiProblemcodeclass">Implementation of the <code>LaplaceBeltramiProblem</code> class</a>
      <ul>
        <li><a href="#LaplaceBeltramiProblemmake_grid_and_dofs">LaplaceBeltramiProblem::make_grid_and_dofs</a>
        <li><a href="#LaplaceBeltramiProblemassemble_system">LaplaceBeltramiProblem::assemble_system</a>
        <li><a href="#LaplaceBeltramiProblemsolve">LaplaceBeltramiProblem::solve</a>
        <li><a href="#LaplaceBeltramiProblemoutput_result">LaplaceBeltramiProblem::output_result</a>
        <li><a href="#LaplaceBeltramiProblemcompute_error">LaplaceBeltramiProblem::compute_error</a>
        <li><a href="#LaplaceBeltramiProblemrun">LaplaceBeltramiProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-38/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Andrea Bonito and M. Sebastian Pauletti, with editing and writing by Wolfgang Bangerth. <br />
 This material is based upon work supported by the National Science Foundation under Grant No. DMS-0914977. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation (NSF). </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>在这个例子中，我们展示了如何解决由四边形组成的一维曲面 \(\Gamma \subset \mathbb R^3\) 上的偏微分方程（PDE），即在三维的曲面或二维的直线上。我们重点讨论以下的椭圆二阶PDE</p>
<p class="formulaDsp">
\begin{align*} -\Delta_\Gamma u &amp;= f \qquad \text{on } \qquad \Gamma,\\ u &amp;= g \qquad \text{on} \qquad \partial \Gamma, \end{align*}
</p>
<p>它概括了我们以前在几个早期教程程序中解决的拉普拉斯方程。我们的实现是基于<a class="el" href="step_4.html">step-4</a>的。<a class="el" href="step_34.html">step-34</a>也可以解决低维曲面上的问题；但是，在那里我们只考虑不涉及解变量导数的积分方程，而在这里我们实际上要研究只在一个（可能是弯曲的）曲面上定义的函数的导数是什么意思。</p>
<p>为了定义上述算子，我们首先要介绍一些符号。让 \(\mathbf x_S:\hat S \rightarrow S\) 是一个由参考元素 \(\hat S \subset \mathbb R^2\) 构成的曲面 \(S\) 的参数化，即每个点 \(\hat{\mathbf x}\in\hat S\) 诱导出一个点 \({\mathbf x}_S(\hat{\mathbf x}) \in S\) 。那么让</p>
<p class="formulaDsp">
\[ G_S\dealcoloneq (D \mathbf{x}_S)^T \ D \mathbf{x}_S \]
</p>
<p>表示相应的第一基本形式，其中 \(D \mathbf{x}_S=\left(\frac{\partial x_{S,i}(\hat{\mathbf x})}{\partial \hat x_j}\right)_{ij}\) 是映射的导数（雅各布）。在下文中， \(S\) 将是整个表面 \(\Gamma\) ，或者对有限元方法更方便的是任何面 \(S \in {\mathbb T}\) ，其中 \({\mathbb T}\) 是由四边形构成的 \(\Gamma\) 的分区（三角化）。我们现在可以定义一个函数 \(v : S \rightarrow \mathbb R\) 的切向梯度，即</p>
<p class="formulaDsp">
\[ (\nabla_S v)\circ \mathbf x_S \dealcoloneq D \mathbf x_S \ G_S^{-1} \ \nabla (v \circ \mathbf x_S). \]
</p>
<p>表面拉普拉斯(也叫拉普拉斯-贝特拉米算子)的定义是 \(\Delta_S \dealcoloneq \nabla_S \cdot \nabla_S\) 。请注意，在光滑表面上计算表面梯度的另一种方法 \(\Gamma\) 是</p>
<p class="formulaDsp">
\[ \nabla_S v = \nabla \tilde v - \mathbf n (\mathbf n \cdot \nabla \tilde v), \]
</p>
<p>其中 \(\tilde v\) 是 \(v\) 在 \(\Gamma\) 的管状邻域的 "平滑 "扩展， \(\mathbf n\) 是 \(\Gamma\) 的法线。由于 \(\Delta_S = \nabla_S \cdot \nabla_S\) ，我们推导出</p>
<p class="formulaDsp">
\[ \Delta_S v = \Delta \tilde v - \mathbf n^T \ D^2 \tilde v \ \mathbf n - (\mathbf n \cdot \nabla \tilde v) (\nabla \cdot \mathbf n - \mathbf n^T \ D \mathbf n \ \mathbf n ). \]
</p>
<p>值得一提的是，上述表达式中出现的术语 \(\nabla \cdot \mathbf n - \mathbf n \ D \mathbf n \ \mathbf n\) 是曲面的总曲率（主曲率之和）。</p>
<p>像往常一样，我们只对弱解感兴趣，为此我们可以使用 \(C^0\) 有限元（而不是像强解那样要求 \(C^1\) 的连续性）。因此，我们求助于弱的表述</p>
<p class="formulaDsp">
\[ \int_\Gamma \nabla_\Gamma u \cdot \nabla_\Gamma v = \int_\Gamma f \ v \qquad \forall v \in H^1_0(\Gamma) \]
</p>
<p>并利用分区 \({\mathbb T}\) 的优势，进一步编写</p>
<p class="formulaDsp">
\[ \sum_{K\in {\mathbb T}}\int_K \nabla_{K} u \cdot \nabla_{K} v = \sum_{K\in {\mathbb T}} \int_K f \ v \qquad \forall v \in H^1_0(\Gamma). \]
</p>
<p>此外，上述表达式中的每个积分都是在参考元素 \(\hat K \dealcoloneq [0,1]^2\) 中计算的，因此</p>
<p class="formulaDsp">
\begin{align*} \int_{K} \nabla_{K} u \cdot \nabla_{K} v &amp;= \int_{\hat K} \nabla (u \circ \mathbf x_K)^T G_K^{-1} (D \mathbf x_K)^T D \mathbf x_K G_K^{-1} \nabla (v \circ \mathbf x_K) \sqrt{\det (G_K)} \\ &amp;= \int_{\hat K} \nabla (u \circ \mathbf x_K)^T G_K^{-1} \nabla (v \circ \mathbf x_K) \sqrt{\det (G_K)} \end{align*}
</p>
<p>和</p>
<p class="formulaDsp">
\[ \int_{K} f \ v = \int_{\hat K} (f \circ \mathbf x_K) (v \circ \mathbf x_K) \sqrt{\det (G_K)}. \]
</p>
<p>最后，我们使用由点 \(\{p_l\}_{l=1}^N\subset \hat K\) 和权重 \(\{w_l\}_{l=1}^N \subset \mathbb R^+_*\) 定义的正交公式来评估上述积分，得到</p>
<p class="formulaDsp">
\[\int_{K} \nabla_{K} u \cdot \nabla_{K} v \approx \sum_{l=1}^N (\nabla (u \circ \mathbf x_K)(p_l))^T G^{-1}(p_l) \nabla (v \circ \mathbf x_K) (p_l) \sqrt{\det (G(p_l))} \ w_l \]
</p>
<p>和</p>
<p class="formulaDsp">
\[ \int_{K} f \ v \approx \sum_{l=1}^N (f \circ \mathbf x_K)(p_l) \ (v \circ \mathbf x_K)(p_l) \sqrt{\det (G(p_l))} \ w_l. \]
</p>
<p>幸运的是，deal.II已经有了所有的工具来计算上述表达式。事实上，它们与我们求解通常的拉普拉斯的方法几乎没有区别，只需要在FEValues类的构造函数中提供表面坐标映射。这个曲面描述给定，在二维曲面的情况下，两个例程 <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">FEValues::shape_grad</a> 和 <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW</a> 会返回</p>
<p class="formulaDsp">
\begin{align*} \text{FEValues::shape\_grad}(i,l)&amp;=D \mathbf x_K(p_l) G^{-1}(p_l)D(\varphi_i \circ \mathbf x_K) (p_l) \\ \text{FEValues::JxW}(l) &amp;= \sqrt{\det (G(p_l))} \ w_l. \end{align*}
</p>
<p>这正好提供了我们的计算所需的术语。</p>
<p>在更广泛的意义上，表面有限元逼近的细节可以在[Dziuk, in Partial differential equations and calculus of variations 1357, Lecture Notes in Math., 1988], [Demlow, SIAM J. Numer. Anal. 47(2), 2009] 和 [Bonito, Nochetto, and Pauletti, SIAM J. Numer. Anal. 48(5), 2010] 中找到。</p>
<p><a class="anchor" id="Testcase"></a></p><h3>Testcase</h3>
<p>一般来说，当你想在数值上测试一个算法的准确性和/或收敛性，你需要提供一个精确的解决方案。通常的技巧是选择一个我们希望成为解决方案的函数，然后对其应用微分算子，为右侧定义一个强制项。这就是我们在这个例子中所做的。在当前情况下，域的形式显然也是至关重要的。</p>
<p>我们为二维问题制作一个测试案例，为三维问题制作另一个测试案例。</p>
<ul>
<li>
<p class="startli">在2d中，让我们选择一个半圆作为域。在这个域上，我们选择函数 \(u(\mathbf x)=-2x_1x_2\) 作为解决方案。为了计算右手边，我们必须计算解函数的表面拉普拉斯。有（至少）两种方法可以做到这一点。第一种是使用 \(u(\mathbf x)\) 的自然延伸（仍然用 \(u\) 表示）在 \(\mathbb R^d\) 上投影掉上面描述的法向导数，即计算 </p><p class="formulaDsp">
\[ -\Delta_\Gamma u = \Delta u - \mathbf n^T \ D^2 u \ \mathbf n - (\mathbf n \cdot \nabla u)\ \kappa, \]
</p>
<p> 。</p>
<p>其中 \(\kappa\) 是 \(\Gamma\) 的总曲率。 由于我们在单位圆上， \(\mathbf n=\mathbf x\) 和 \(\kappa = 1\) 所以 </p><p class="formulaDsp">
\[ -\Delta_\Gamma u = -8 x_1x_2. \]
</p>
<p>一个更简单的方法，至少对于目前二维空间的曲线的情况，是注意到我们可以用变换 \(t \in [0,\pi]\) 将区间 \(\Omega\) 映射到域 \(\mathbf x(t)= \left(\begin{array}{c} \cos t \\ \sin t \end{array}\right)\) 。 在位置 \(\mathbf x=\mathbf x(t)\) 上，解的值是 \(u(\mathbf x(t)) = -2\cos t \sin t\) 。 考虑到转换是保长的，即长度为 \(dt\) 的线段被映射到完全相同长度的曲线上，那么切向拉普拉斯就满足 </p><p class="formulaDsp">
\begin{align*} \Delta_\Gamma u &amp;= \frac{d^2}{dt^2}(-2\cos t \sin t) = -2 \frac{d}{dt}(-\sin^2 t + \cos^2 t) = -2 (-2 \sin t \cos t - 2 \cos t \sin t) \\ &amp;= 8 \sin t \cos t \\ &amp;= 8 x_1x_2, \end{align*}
</p>
<p> 。</p>
<p class="endli">这当然和我们上面的结果是一样的。  </p>
</li>
<li>
在三维中，域又是单位球表面的一半，即半球或圆顶。我们选择 \(u(\mathbf x)=-2\sin(\pi x_1)\cos(\pi x_2)e^z\) 作为解决方案。我们可以用上面的方法计算方程的右边， \(f=-\Delta_\Gamma u\) ，（用 \(\kappa = 2\) ），得到一个笨拙而冗长的表达。你可以在源代码中找到完整的表达式。  </li>
</ul>
<p>。</p>
<p>在程序中，我们还将计算出解的 \(H^1\) 半规范误差。由于解函数及其数值近似只在流形上定义，这个误差函数的明显定义是 \(| e |_{H^1(\Gamma)} = | \nabla_\Gamma e |_{L_2(\Gamma)} = \left( \int_\Gamma | \nabla_\Gamma (u-u_h) |^2 \right)^{1/2}\) 。这就要求我们为函数 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a> （在步骤7中首次引入）提供<em>tangential</em>梯度 \(\nabla_\Gamma u\) ，我们将通过在下面的程序中实现函数 <code>Solution::gradient</code> 来实现。</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>如果你已经读完了第4步，并且理解了上面关于解和右边如何对应的讨论，你也会立即熟悉这个程序。事实上，只有两件事是有意义的。</p>
<ul>
<li>我们生成三角计算域的网格的方式。</li>
<li>我们使用映射对象的方式来描述，我们解决偏微分方程的领域不是平面的，实际上是弯曲的。</li>
</ul>
<p>在第10步和第11步中已经介绍了映射对象，正如那里所解释的，只要你对边界的样子有一个有效的描述，你通常不需要知道它们是如何工作的。从本质上讲，我们将简单地声明一个适当的MappingQ类型的对象，它将自动从三角图中获得边界描述。然后，该映射对象将被传递给适当的函数，我们将得到库中预定义的半圆或半球形的边界描述。</p>
<p>该程序的其余部分紧跟步骤4，至于计算误差，则是步骤7。这个程序的某些方面，特别是在Triangulation、DoFHandler和类似的类上使用两个模板参数，已经在步骤34中作了详细描述；你不妨也读一读这个教程程序。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>If you've read through <a class="el" href="step_4.html">step-4</a> and <a class="el" href="step_7.html">step-7</a>, you will recognize that we have used all of the following include files there already. Consequently, we will not explain their meaning here again.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__control_8h.html">deal.II/lac/solver_control.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step38</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceBeltramiProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceBeltramiProblem</code> class template</h3>
<p>This class is almost exactly similar to the <code>LaplaceProblem</code> class in <a class="el" href="step_4.html">step-4</a>.</p>
<p>The essential differences are these:</p>
<ul>
<li>The template parameter now denotes the dimensionality of the embedding space, which is no longer the same as the dimensionality of the domain and the triangulation on which we compute. We indicate this by calling the parameter <code>spacedim</code>, and introducing a constant <code>dim</code> equal to the dimensionality of the domain &ndash; here equal to <code>spacedim-1</code>.</li>
<li>All member variables that have geometric aspects now need to know about both their own dimensionality as well as that of the embedding space. Consequently, we need to specify both of their template parameters one for the dimension of the mesh <code>dim</code>, and the other for the dimension of the embedding space, <code>spacedim</code>. This is exactly what we did in <a class="el" href="step_34.html">step-34</a>, take a look there for a deeper explanation.</li>
<li>We need an object that describes which kind of mapping to use from the reference cell to the cells that the triangulation is composed of. The classes derived from the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> base class do exactly this. Throughout most of deal.II, if you don't do anything at all, the library assumes that you want an object of kind <a class="el" href="classMappingQ1.html">MappingQ1</a> that uses a (bi-, tri-)linear mapping. In many cases, this is quite sufficient, which is why the use of these objects is mostly optional: for example, if you have a polygonal two-dimensional domain in two-dimensional space, a bilinear mapping of the reference cell to the cells of the triangulation yields an exact representation of the domain. If you have a curved domain, one may want to use a higher order mapping for those cells that lie at the boundary of the domain &ndash; this is what we did in <a class="el" href="step_11.html">step-11</a>, for example. However, here we have a curved domain, not just a curved boundary, and while we can approximate it with bilinearly mapped cells, it is really only prudent to use a higher order mapping for all cells. Consequently, this class has a member variable of type <a class="el" href="classMappingQ.html">MappingQ</a>; we will choose the polynomial degree of the mapping equal to the polynomial degree of the finite element used in the computations to ensure optimal approximation, though this iso-parametricity is not required.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceBeltramiProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceBeltramiProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree = 2);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = spacedim - 1;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> compute_error() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a>    dof_handler;</div><div class="line">  <a class="code" href="classMappingQ.html">MappingQ&lt;dim, spacedim&gt;</a>      mapping;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Next, let us define the classes that describe the exact solution and the right hand sides of the problem. This is in analogy to <a class="el" href="step_4.html">step-4</a> and <a class="el" href="step_7.html">step-7</a> where we also defined such objects. Given the discussion in the introduction, the actual formulas should be self-explanatory. A point of interest may be how we define the value and gradient functions for the 2d and 3d cases separately, using explicit specializations of the general template. An alternative to doing it this way might have been to define the general template and have a <code>switch</code> statement (or a sequence of <code>if</code>s) for each possible value of the spatial dimension.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  <a class="code" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (-2. * p(0) * p(1));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> Solution&lt;2&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> return_value;</div><div class="line">  return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0));</div><div class="line">  return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(0)) * std::cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(1)) *</div><div class="line">          <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2)));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> Solution&lt;3&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> return_value;</div><div class="line"></div><div class="line">  return_value[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  return_value[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  return_value[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (-8. * p(0) * p(1));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> hessian;</div><div class="line"></div><div class="line">  hessian[0][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[1][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[2][2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  hessian[0][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[1][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  hessian[0][2] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[2][0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  hessian[1][2] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  hessian[2][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> gradient;</div><div class="line">  gradient[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  gradient[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">  gradient[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> normal = p;</div><div class="line">  normal /= p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (-<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(hessian) + 2 * (gradient * normal) +</div><div class="line">          (hessian * normal) * normal);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeLaplaceBeltramiProblemcodeclass"></a> </p><h3>Implementation of the <code>LaplaceBeltramiProblem</code> class</h3>
<p>The rest of the program is actually quite unspectacular if you know <a class="el" href="step_4.html">step-4</a>. Our first step is to define the constructor, setting the polynomial degree of the finite element and mapping, and associating the DoF handler to the triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">LaplaceBeltramiProblem&lt;spacedim&gt;::LaplaceBeltramiProblem(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree)</div><div class="line">  : fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , mapping(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemmake_grid_and_dofs"></a> </p><h4>LaplaceBeltramiProblem::make_grid_and_dofs</h4>
<p>The next step is to create the mesh, distribute degrees of freedom, and set up the various variables that describe the linear system. All of these steps are standard with the exception of how to create a mesh that describes a surface. We could generate a mesh for the domain we are interested in, generate a triangulation using a mesh generator, and read it in using the <a class="el" href="classGridIn.html">GridIn</a> class. Or, as we do here, we generate the mesh using the facilities in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace.</p>
<p>In particular, what we're going to do is this (enclosed between the set of braces below): we generate a <code>spacedim</code> dimensional mesh for the half disk (in 2d) or half ball (in 3d), using the <a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a> function. This function sets the boundary indicators of all faces on the outside of the boundary to zero for the ones located on the perimeter of the disk/ball, and one on the straight part that splits the full disk/ball into two halves. The next step is the main point: The <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a> function creates a mesh that consists of those cells that are the faces of the previous mesh, i.e. it describes the <em>surface</em> cells of the original (volume) mesh. However, we do not want all faces: only those on the perimeter of the disk or ball which carry boundary indicator zero; we can select these cells using a set of boundary indicators that we pass to <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>.</p>
<p>There is one point that needs to be mentioned. In order to refine a surface mesh appropriately if the manifold is curved (similarly to refining the faces of cells that are adjacent to a curved boundary), the triangulation has to have an object attached to it that describes where new vertices should be located. If you don't attach such a boundary object, they will be located halfway between existing vertices; this is appropriate if you have a domain with straight boundaries (e.g. a polygon) but not when, as here, the manifold has curvature. So for things to work properly, we need to attach a manifold object to our (surface) triangulation, in much the same way as we've already done in 1d for the boundary. We create such an object and attach it to the triangulation.</p>
<p>The final step in creating the mesh is to refine it a number of times. The rest of the function is the same as in previous tutorial programs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">    boundary_ids.insert(0);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh,</div><div class="line">                                         triangulation,</div><div class="line">                                         boundary_ids);</div><div class="line">  }</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim, spacedim&gt;</a>());</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; degrees of freedom.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemassemble_system"></a> </p><h4>LaplaceBeltramiProblem::assemble_system</h4>
<p>The following is the central function of this program, assembling the matrix that corresponds to the surface Laplacian (Laplace-Beltrami operator). Maybe surprisingly, it actually looks exactly the same as for the regular Laplace operator discussed in, for example, <a class="el" href="step_4.html">step-4</a>. The key is that the <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">FEValues::shape_grad()</a> function does the magic: It returns the surface gradient \(\nabla_K \phi_i(x_q)\) of the \(i\)th shape function at the \(q\)th quadrature point. The rest then does not need any changes either:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_values(mapping,</div><div class="line">                                    fe,</div><div class="line">                                    quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  RightHandSide&lt;spacedim&gt; rhs;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      rhs.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                         rhs_values[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, Solution&lt;spacedim&gt;(), boundary_values);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(</div><div class="line">    boundary_values, system_matrix, solution, system_rhs, <span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemsolve"></a> </p><h4>LaplaceBeltramiProblem::solve</h4>
<p>The next function is the one that solves the linear system. Here, too, no changes are necessary:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemoutput_result"></a> </p><h4>LaplaceBeltramiProblem::output_result</h4>
<p>This is the function that generates graphical output from the solution. Most of it is boilerplate code, but there are two points worth pointing out:</p>
<ul>
<li>The <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function can take two kinds of vectors: Either vectors that have one value per degree of freedom defined by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object previously attached via <a class="el" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut::attach_dof_handler()</a>; and vectors that have one value for each cell of the triangulation, for example to output estimated errors for each cell. Typically, the <a class="el" href="classDataOut.html">DataOut</a> class knows to tell these two kinds of vectors apart: there are almost always more degrees of freedom than cells, so we can differentiate by the two kinds looking at the length of a vector. We could do the same here, but only because we got lucky: we use a half sphere. If we had used the whole sphere as domain and \(Q_1\) elements, we would have the same number of cells as vertices and consequently the two kinds of vectors would have the same number of elements. To avoid the resulting confusion, we have to tell the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function which kind of vector we have: DoF data. This is what the third argument to the function does.</li>
<li>The <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> function can generate output that subdivides each cell so that visualization programs can resolve curved manifolds or higher polynomial degree shape functions better. We here subdivide each element in each coordinate direction as many times as the polynomial degree of the finite element in use.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;::type_dof_data</a>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, mapping.get_degree());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) + <span class="stringliteral">&quot;d.vtk&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemcompute_error"></a> </p><h4>LaplaceBeltramiProblem::compute_error</h4>
<p>This is the last piece of functionality: we want to compute the error in the numerical solution. It is a verbatim copy of the code previously shown and discussed in <a class="el" href="step_7.html">step-7</a>. As mentioned in the introduction, the <code>Solution</code> class provides the (tangential) gradient of the solution. To avoid evaluating the error only a superconvergence points, we choose a quadrature rule of sufficiently high order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::compute_error()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    Solution&lt;spacedim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> h1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                      difference_per_cell,</div><div class="line">                                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;H1 error = &quot;</span> &lt;&lt; h1_error &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceBeltramiProblemrun"></a> </p><h4>LaplaceBeltramiProblem::run</h4>
<p>The last function provides the top-level logic. Its contents are self-explanatory:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceBeltramiProblem&lt;spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">    compute_error();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step38</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The remainder of the program is taken up by the <code>main()</code> function. It follows exactly the general layout first introduced in <a class="el" href="step_6.html">step-6</a> and used in all following tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step38;</div><div class="line"></div><div class="line">      LaplaceBeltramiProblem&lt;3&gt; laplace_beltrami;</div><div class="line">      laplace_beltrami.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-38/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>当你运行该程序时，应在屏幕上打印出以下输出。</p>
<pre class="fragment">Surface mesh has 1280 cells.
Surface mesh has 5185 degrees of freedom.
H1 error = 0.0217136
</pre><p>通过在 <code>LaplaceBeltrami::make_grid_and_dofs</code> 函数中玩弄全局细化的数量，可以增加或减少网格细化。例如，多做一次细化，只运行三维曲面问题，得到的输出结果如下。</p>
<pre class="fragment">Surface mesh has 5120 cells.
Surface mesh has 20609 degrees of freedom.
H1 error = 0.00543481
</pre><p>这就是我们所期望的：将网格尺寸缩小2倍，误差下降4倍（记住我们使用的是双二次元）。从一到五次细化的全部误差序列看起来是这样的，整齐地遵循理论上预测的模式。</p>
<pre class="fragment">0.339438
0.0864385
0.0217136
0.00543481
0.00135913
</pre><p>最后，该程序产生图形输出，我们可以将其可视化。下面是一个结果图。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.solution-3d.png"/>
</div>
<p>该程序也适用于2D中的1D曲线，而不仅仅是3D中的2D曲面。你可以通过改变 <code>main()</code> 中的模板参数来测试这一点，像这样。</p>
<div class="fragment"><div class="line">LaplaceBeltramiProblem&lt;2&gt; laplace_beltrami;</div></div><!-- fragment --><p>域是一条2D的曲线，我们可以通过使用第三维（和颜色）来表示函数 \(u(x)\) 的值来可视化解决方案。这样看起来就像这样（白色的曲线是域，彩色的曲线是被挤压到第三维的解决方案，清楚地显示了当曲线从域的一个象限移动到相邻的象限时符号的变化）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.solution-2d.png"/>
</div>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>只有当表面比仅仅是一个半球体更有趣时，在表面上的计算才会变得有趣。为了达到这个目的，deal.II可以通过通常的GridIn类读取描述曲面的网格。或者，万一你有一个分析性的描述，一个简单的网格有时可以被拉伸和弯曲成我们感兴趣的形状。</p>
<p>让我们考虑一个相对简单的例子：我们把之前用过的半球体，在Z方向上拉伸10倍，然后把X和Y坐标拼一下。让我们先展示一下计算域和解决方案，然后再讨论下面的实现细节。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.warp-1.png"/>
</div>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-38.warp-2.png"/>
</div>
<p>产生这种网格的方法是使用 <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> 函数。它需要一个方法来转换每个单独的网格点到不同的位置。让我们在这里使用下面这个相当简单的函数（记住：在一个方向上拉伸，在另外两个方向上拼凑）。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> warp(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> q = p;</div><div class="line">  q[spacedim-1] *= 10;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (spacedim &gt;= 2)</div><div class="line">    q[0] += 2*<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(q[spacedim-1]);</div><div class="line">  <span class="keywordflow">if</span> (spacedim &gt;= 3)</div><div class="line">    q[1] += 2*<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(q[spacedim-1]);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> q;</div><div class="line">}</div></div><!-- fragment --><p>如果我们遵循 <code>LaplaceBeltrami::make_grid_and_dofs</code> 函数，我们会像以前一样提取半球形表面网格，将其扭曲成我们想要的形状，并根据需要经常进行细化。但这并不像我们所希望的那样简单：细化需要我们有一个适当的流形对象附加到三角形上，描述细化时网格的新顶点应该位于何处。我相信可以通过简单地撤销上面的变换（重新得到球面），找到球面上新的点的位置，然后重新扭曲结果，以一种不太复杂的方式描述这个流形。但我是个懒人，既然这样做并不是真正的重点，我们还是让我们的生活变得简单一点：我们将提取半球体，根据需要对其进行细化，摆脱描述流形的对象，因为我们现在不再需要它，然后最后对网格进行扭曲。使用上面的函数，这将看起来如下。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceBeltrami&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line"></div><div class="line">    volume_mesh.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">    boundary_ids.insert(0);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh, triangulation,</div><div class="line">                                         boundary_ids);</div><div class="line">    <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;warp&lt;spacedim&gt;, triangulation);       <span class="comment">/* ** */</span></div><div class="line">    std::ofstream x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(volume_mesh, x);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(triangulation, y);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>请注意，唯一必要的补充是标有星号的那一行。不过值得指出的是：由于我们将流形描述从表面网格中分离出来，所以当我们在程序的其余部分使用映射对象时，它不再有曲线边界描述可言。相反，它将不得不使用隐含的FlatManifold类，该类用于域的所有未明确指定不同流形对象的部分。因此，无论我们使用MappingQ(2)、MappingQ(15)还是MappingQ1，我们的网格的每个单元都将使用双线性近似进行映射。</p>
<p>撇开所有这些缺点不谈，得到的图片还是很好看的。与步骤38中的内容唯一不同的是，我们把右手边改为 \(f(\mathbf x)=\sin x_3\) ，把边界值（通过 <code>Solution</code> 类）改为 \(u(\mathbf x)|_{\partial\Omega}=\cos x_3\) 。当然，我们现在已经不知道确切的解决方案，所以在 <code>LaplaceBeltrami::run</code> 末尾的误差计算将得到一个毫无意义的数字。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Andrea Bonito, Sebastian Pauletti.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__control_8h.html">deal.II/lac/solver_control.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step38</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceBeltramiProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceBeltramiProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree = 2);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = spacedim - 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> compute_error() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a>    dof_handler;</div><div class="line">    <a class="code" href="classMappingQ.html">MappingQ&lt;dim, spacedim&gt;</a>      mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (-2. * p(0) * p(1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> Solution&lt;2&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> return_value;</div><div class="line">    return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0));</div><div class="line">    return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(0)) * std::cos(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p(1)) *</div><div class="line">            <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2)));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> Solution&lt;3&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> return_value;</div><div class="line"></div><div class="line">    return_value[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    return_value[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    return_value[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;2&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (-8. * p(0) * p(1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;3&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> hessian;</div><div class="line"></div><div class="line">    hessian[0][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[1][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[0][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[1][0] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[0][2] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    hessian[1][2] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    hessian[2][1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> gradient;</div><div class="line">    gradient[0] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    gradient[1] = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line">    gradient[2] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(0)) * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * p(1)) * <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(p(2));</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> normal = p;</div><div class="line">    normal /= p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (-<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(hessian) + 2 * (gradient * normal) +</div><div class="line">            (hessian * normal) * normal);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  LaplaceBeltramiProblem&lt;spacedim&gt;::LaplaceBeltramiProblem(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> degree)</div><div class="line">    : fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , mapping(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;spacedim&gt;</a> volume_mesh;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(volume_mesh);</div><div class="line"></div><div class="line">      std::set&lt;types::boundary_id&gt; boundary_ids;</div><div class="line">      boundary_ids.insert(0);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh</a>(volume_mesh,</div><div class="line">                                           triangulation,</div><div class="line">                                           boundary_ids);</div><div class="line">    }</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim, spacedim&gt;</a>());</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; cells.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Surface mesh has &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; degrees of freedom.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.n_dofs());</div><div class="line">    system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_values(mapping,</div><div class="line">                                      fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    RightHandSide&lt;spacedim&gt; rhs;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        rhs.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                           rhs_values[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              system_matrix.add(local_dof_indices[i],</div><div class="line">                                local_dof_indices[j],</div><div class="line">                                cell_matrix(i, j));</div><div class="line"></div><div class="line">            system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, Solution&lt;spacedim&gt;(), boundary_values);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(</div><div class="line">      boundary_values, system_matrix, solution, system_rhs, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;::type_dof_data</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, mapping.get_degree());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) + <span class="stringliteral">&quot;d.vtk&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceBeltramiProblem&lt;spacedim&gt;::compute_error()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      Solution&lt;spacedim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> h1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                        difference_per_cell,</div><div class="line">                                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;H1 error = &quot;</span> &lt;&lt; h1_error &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceBeltramiProblem&lt;spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">    compute_error();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step38</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step38;</div><div class="line"></div><div class="line">      LaplaceBeltramiProblem&lt;3&gt; laplace_beltrami;</div><div class="line">      laplace_beltrami.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
