<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_72.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-72 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-72 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_71.html">step-71</a>, <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Motivation">Motivation</a>
        <li><a href="#ComputingtheJacobianfromtheresidual"> Computing the Jacobian from the residual </a>
        <li><a href="#ComputingtheJacobianandtheresidualfromtheenergyfunctional"> Computing the Jacobian and the residual from the energy functional </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemParameterscodeclass">The <code>MinimalSurfaceProblemParameters</code> class</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#MinimalSurfaceProblemMinimalSurfaceProblem">MinimalSurfaceProblem::MinimalSurfaceProblem</a>
        <li><a href="#MinimalSurfaceProblemsetup_system">MinimalSurfaceProblem::setup_system</a>
        <li><a href="#Assemblingthelinearsystem">Assembling the linear system</a>
      <ul>
        <li><a href="#Manualassembly">Manual assembly</a>
        <li><a href="#Assemblyviadifferentiationoftheresidualvector">Assembly via differentiation of the residual vector</a>
        <li><a href="#Assemblyviadifferentiationoftheenergyfunctional">Assembly via differentiation of the energy functional</a>
      </ul>
        <li><a href="#MinimalSurfaceProblemsolve">MinimalSurfaceProblem::solve</a>
        <li><a href="#MinimalSurfaceProblemrefine_mesh">MinimalSurfaceProblem::refine_mesh</a>
        <li><a href="#MinimalSurfaceProblemset_boundary_values">MinimalSurfaceProblem::set_boundary_values</a>
        <li><a href="#MinimalSurfaceProblemcompute_residual">MinimalSurfaceProblem::compute_residual</a>
        <li><a href="#MinimalSurfaceProblemdetermine_step_length">MinimalSurfaceProblem::determine_step_length</a>
        <li><a href="#MinimalSurfaceProblemoutput_results">MinimalSurfaceProblem::output_results</a>
        <li><a href="#MinimalSurfaceProblemrun">MinimalSurfaceProblem::run</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Jean-Paul Pelteret and Wolfgang Bangerth.</em></p>
<p><em>Wolfgang Bangerth's work is partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Motivation"></a></p><h3>Motivation</h3>
<p>This program solves the same problem as <a class="el" href="step_15.html">step-15</a>, that is, it solves for the <a href="https://en.wikipedia.org/wiki/Minimal_surface">minimal surface equation</a> </p><p class="formulaDsp">
\begin{align*} F(u) \dealcoloneq -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p>Among the issues we had identified there (see the <a href="step_15#extensions">Possibilities for extensions</a> section) was that when wanting to use a Newton iteration, we needed to compute the derivative of the residual of the equation with regard to the solution \(u\) (here, because the right hand side is zero, the residual is simply the left hand side). For the equation we have here, this is cumbersome but not impossible &ndash; but one can easily imagine much more complicated equations where just implementing the residual itself correctly is a challenge, let alone doing so for the derivative necessary to compute the Jacobian matrix. We will address this issue in this program: Using the automatic differentiation techniques discussed in great detail in <a class="el" href="step_71.html">step-71</a>, we will come up with a way how we only have to implement the residual and get the Jacobian for free.</p>
<p>In fact, we can even go one step further. While in <a class="el" href="step_15.html">step-15</a> we have just taken the equation as a given, the minimal surface equation is actually the product of minimizing an energy. Specifically, the minimal surface equations are the Euler-Lagrange equations that correspond to minimizing the energy </p><p class="formulaDsp">
\[ E(u) = \int_\Omega \Psi \left( u \right) \]
</p>
<p> where the <em>energy density</em> is given by </p><p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}}. \]
</p>
<p> This is the same as saying that we seek to find the stationary point of the variation of the energy functional </p><p class="formulaDsp">
\[ \min\limits_{u} E \left( u \right) \quad \rightarrow \quad \delta E \left( u, \varphi \right) \dealcoloneq \left(\varphi, F(u)\right) = 0 \qquad \forall \varphi, \]
</p>
<p> as this is where the equilibrium solution to the boundary value problem lies.</p>
<p>The key point then is that, maybe, we don't even need to implement the residual, but that implementing the simpler energy density \(\Psi(u)\) might actually be enough.</p>
<p>Our goal then is this: When using a Newton iteration, we need to repeatedly solve the linear partial differential equation </p><p class="formulaDsp">
\begin{align*} F&#39;(u^{n},\delta u^{n}) &amp;=- F(u^{n}) \end{align*}
</p>
<p> so that we can compute the update </p><p class="formulaDsp">
\begin{align*} u^{n+1}&amp;=u^{n}+\alpha^n \delta u^{n} \end{align*}
</p>
<p> with the solution \(\delta u^{n}\) of the Newton step. As discussed in <a class="el" href="step_15.html">step-15</a>, we can compute the derivative \(F&#39;(u,\delta u)\) by hand and obtain </p><p class="formulaDsp">
\[ F&#39;(u,\delta u) = - \nabla \cdot \left( \frac{1}{\left(1+|\nabla u|^{2}\right)^{\frac{1}{2}}}\nabla \delta u \right) + \nabla \cdot \left( \frac{\nabla u \cdot \nabla \delta u}{\left(1+|\nabla u|^{2}\right)^{\frac{3}{2}}} \nabla u \right). \]
</p>
<p>So here then is what this program is about: It is about techniques that can help us with computing \(F&#39;(u,\delta u)\) without having to implement it explicitly, either by providing an implementation of \(F(u)\) or an implementation of \(E(u)\). More precisely, we will implement three different approaches and compare them in terms of run-time but also &ndash; maybe more importantly &ndash; how much human effort it takes to implement them:</p><ul>
<li>The method used in <a class="el" href="step_15.html">step-15</a> to form the Jacobian matrix.</li>
<li>Computing the Jacobian matrix from an implementation of the residual \(F(u)\), using automatic differentiation.</li>
<li>Computing both the residual and Jacobian matrix from an implementation of the energy functional \(E(u)\), also using automatic differentiation.</li>
</ul>
<p>For the first of these methods, there are no conceptual changes compared to <a class="el" href="step_15.html">step-15</a>.</p>
<p><a class="anchor" id="ComputingtheJacobianfromtheresidual"></a></p><h3>Computing the Jacobian from the residual </h3>
<p>For the second method, let us outline how we will approach the issue using automatic differentiation to compute the linearization of the residual vector. To this end, let us change notation for a moment and denote by \(F(U)\) not the residual of the differential equation, but in fact the <em>residual vector</em> &ndash; i.e., the <em>discrete residual</em>. We do so because that is what we actually* do when we discretize the problem on a given mesh: We solve the problem \(F(U)=0\) where \(U\) is the vector of unknowns.</p>
<p>More precisely, the \(i\)th component of the residual is given by </p><p class="formulaDsp">
\[ F(U)_i \dealcoloneq \int\limits_{\Omega}\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p> where \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\). Given this, the contribution for cell \(K\) is </p><p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p> Its first order Taylor expansion is given as </p><p class="formulaDsp">
\[ F(U + \delta U)_i^K \approx F(U)_i^K + \sum_{j}^{n_{\textrm{dofs}}} \left[ \frac{\partial F(U)_i^K}{\partial U_j} \delta U_j \right], \]
</p>
<p> and consequently we can compute the contribution of cell \(K\) to the Jacobian matrix \(J\) as \(J(U)_{ij}^K = \frac{\partial F(U)_i^K}{\partial U_j}\). The important point here is that on cell \(K\), we can express </p><p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+\left| \sum_{j&#39;}^{n_\textrm{dofs}} U_{j&#39;} \nabla \varphi_{j&#39;}\right|^{2}}} \left(\sum_{j&#39;&#39;}^{n_\textrm{dofs}} U_{j&#39;&#39;} \nabla \varphi_{j&#39;&#39;}\right)\right] \, dV. \]
</p>
<p> For clarity, we have used \(j&#39;\) and \(j&#39;&#39;\) as counting indices to make clear that they are distinct from each other and from \(j\) above. Because in this formula, \(F(U)\) only depends on the coefficients \(U_j\), we can compute the derivative \(J(U)_{ij}^K\) as a matrix via automatic differentiation of \(F(U)_i^K\). By the same argument as we always use, it is clear that \(F(U)^K\) does not actually depend on all* unknowns \(U_j\), but only on those unknowns for which \(j\) is a shape function that lives on cell \(K\), and so in practice, we restrict \(F(U)^K\) and \(J(U)^K\) to that part of the vector and matrix that corresponds to the <em>local</em> DoF indices, and then distribute from the local cell \(K\) to the global objects.</p>
<p>Using all of these realizations, the approach will then be to implement \(F(U)^K\) in the program and let the automatic differentiation machinery compute the derivatives \(J(U)^K\) from that.</p>
<p><a class="anchor" id="ComputingtheJacobianandtheresidualfromtheenergyfunctional"></a></p><h3>Computing the Jacobian and the residual from the energy functional </h3>
<p>For the final implementation of the assembly process, we will move a level higher than the residual: our entire linear system will be determined directly from the energy functional that governs the physics of this boundary value problem. We can take advantage of the fact that we can calculate the total energy in the domain directly from the local contributions, i.e., </p><p class="formulaDsp">
\[ E \left( U \right) \dealcoloneq \int\limits_{\Omega} \Psi \left( u \right) \, dV . \]
</p>
<p> In the discrete setting, this means that on each finite element we have </p><p class="formulaDsp">
\[ E \left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{x}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} . \]
</p>
<p> If we implement the cell energy, which depends on the field solution, we can compute its first (discrete) variation </p><p class="formulaDsp">
\[ F(U)^K_i = \frac{\partial E(U)^K}{\partial U_i} \]
</p>
<p> and, thereafter, its second (discrete) variation </p><p class="formulaDsp">
\[ J(U)^K_{ij} = \frac{\partial^{2} E(U)^K}{\partial U_i \partial U_j}. \]
</p>
<p> So, from the cell contribution to the total energy function, we may expect to have the approximate residual and tangent contributions generated for us as long as we can provide an implementation of the local energy \(E(U)^K\). Again, due to the design of the automatic differentiation variables used in this tutorial, in practice these approximations for the contributions to the residual vector and tangent matrix are actually accurate to machine precision.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The majority of this tutorial is an exact replica of <a class="el" href="step_15.html">step-15</a>. So, in the interest of brevity and maintaining a focus on the changes implemented here, we will only document what's new and simply indicate which sections of code are a repetition of what has come before.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>There are a few new header files that have been included in this tutorial. The first is the one that provides the declaration of the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>This is the second, which is an all-inclusive header that will allow us to incorporate the automatic differentiation (AD) functionality within this code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>And the next three provide some multi-threading capability using the generic <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> framework.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>We then open a namespace for this program and import everything from the dealii namespace into it, as in previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step72</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemParameterscodeclass"></a> </p><h3>The <code>MinimalSurfaceProblemParameters</code> class</h3>
<p>In this tutorial we will implement three different approaches for assembling the linear system. One mirrors the hand implementation originally provided in <a class="el" href="step_15.html">step-15</a>, while the other two use the Sacado automatic differentiation library that is provided as a part of the Trilinos framework.</p>
<p>To facilitate switching between the three implementations, we have this really basic parameters class that has only two options that are configurable.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblemParameters();</div></div><!-- fragment --><p>Selection for the formulation and corresponding AD framework to be used:</p><ul>
<li>formulation = 0 : Unassisted implementation (full hand linearization).</li>
<li>formulation = 1 : Automated linearization of the finite element residual.</li>
<li>formulation = 2 : Automated computation of finite element residual and linearization using a variational formulation.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0;</div></div><!-- fragment --><p>The maximum acceptable tolerance for the linear system residual. We will see that the assembly time becomes appreciable once we use the AD framework, so we have increased the tolerance selected in <a class="el" href="step_15.html">step-15</a> by one order of magnitude. This way, the computations do not take too long to complete.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> tolerance = 1e-2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2));</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>The class template is essentially the same as in <a class="el" href="step_15.html">step-15</a>. The only functional changes to the class are that:</p><ul>
<li>the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function now takes in two arguments: one to choose which assembly approach is to be adopted, and one for the tolerance for the permissible final residual is, and</li>
<li>there are now three different assembly functions that implement the three methods of assembling the linear system. We'll provide details on these later on.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_unassisted();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_with_residual_linearization();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_using_energy_functional();</div><div class="line">  <span class="keywordtype">void</span>   solve();</div><div class="line">  <span class="keywordtype">void</span>   refine_mesh();</div><div class="line">  <span class="keywordtype">void</span>   set_boundary_values();</div><div class="line">  <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line">  Vector&lt;double&gt; newton_update;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>There are no changes to the boundary conditions applied to the problem.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<p><a class="anchor" id="MinimalSurfaceProblemMinimalSurfaceProblem"></a> </p><h4>MinimalSurfaceProblem::MinimalSurfaceProblem</h4>
<p>There have been no changes made to the class constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(2)</div><div class="line">  , quadrature_formula(fe.degree + 1)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsetup_system"></a> </p><h4>MinimalSurfaceProblem::setup_system</h4>
<p>There have been no changes made to the function that sets up the class data structures, namely the <a class="el" href="classDoFHandler.html">DoFHandler</a>, the hanging node constraints applied to the problem, and the linear system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblingthelinearsystem"></a> </p><h4>Assembling the linear system</h4>
<p><a class="anchor" id="Manualassembly"></a> </p><h5>Manual assembly</h5>
<p>The assembly functions are the interesting contributions to this tutorial. The assemble_system_unassisted() method implements exactly the same assembly function as is detailed in <a class="el" href="step_15.html">step-15</a>, but in this instance we use the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function to multithread the assembly process. The reason for doing this is quite simple: When using automatic differentiation, we know that there is to be some additional computational overhead incurred. In order to mitigate this performance loss, we'd like to take advantage of as many (easily available) computational resources as possible. The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> concept makes this a relatively straightforward task. At the same time, for the purposes of fair comparison, we need to do the same to the implementation that uses no assistance when computing the residual or its linearization. (The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function is first discussed in <a class="el" href="step_12.html">step-12</a> and <a class="el" href="step_16.html">step-16</a>, if you'd like to read up on it.)</p>
<p>The steps required to implement the multithreading are the same between the three functions, so we'll use the assemble_system_unassisted() function as an opportunity to focus on the multithreading itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div></div><!-- fragment --><p>The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> expects that we provide two exemplar data structures. The first, <code>ScratchData</code>, is to store all large data that is to be reused between threads. The <code>CopyData</code> will hold the contributions to the linear system that come from each cell. These independent matrix-vector pairs must be accumulated into the global linear system sequentially. Since we don't need anything on top of what the <a class="el" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData</a> and <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> classes already provide, we use these exact class definitions for our problem. Note that we only require a single instance of a local matrix, local right-hand side vector, and cell degree of freedom index vector &ndash; the <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> therefore has <code>1</code> for all three of its template arguments.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line"><span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div></div><!-- fragment --><p>We also need to know what type of iterator we'll be working with during assembly. For simplicity, we just ask the compiler to work this out for us using the decltype() specifier, knowing that we'll be iterating over active cells owned by the <code>dof_handler</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div></div><!-- fragment --><p>Here we initialize the exemplar data structures. Since we know that we need to compute the shape function gradients, weighted Jacobian, and the position of the quadrate points in real space, we pass these flags into the class constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"><span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>Now we define a lambda function that will perform the assembly on a single cell. The three arguments are those that will be expected by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>, due to the arguments that we'll pass to that final call. We also capture the <code>this</code> pointer, which means that we'll have access to "this" (i.e., the current <code>MinimalSurfaceProblem&lt;dim&gt;</code>) class instance, and its private member data (since the lambda function is defined within a MinimalSurfaceProblem&lt;dim&gt; method).</p>
<p>At the top of the function, we initialize the data structures that are dependent on the cell for which the work is being performed. Observe that the reinitialization call actually returns an instance to an <a class="el" href="classFEValues.html">FEValues</a> object that is initialized and stored within (and, therefore, reused by) the <code>scratch_data</code> object.</p>
<p>Similarly, we get aliases to the local matrix, local RHS vector, and local cell DoF indices from the <code>copy_data</code> instance that <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> provides. We then initialize the cell DoF indices, knowing that the local matrix and vector are already correctly sized.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                ScratchData &amp;           scratch_data,</div><div class="line">                                CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>For Newton's method, we require the gradient of the solution at the point about which the problem is being linearized.</p>
<p>Once we have that, we can perform assembly for this cell in the usual way. One minor difference to <a class="el" href="step_15.html">step-15</a> is that we've used the (rather convenient) range-based loops to iterate over all quadrature points and degrees-of-freedom.</p>
<div class="fragment"><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients(</div><div class="line">    fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution,</div><div class="line">                                   old_solution_gradients);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">        1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                old_solution_gradients[q]);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">              (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                   coeff                         <span class="comment">//   * a_n</span></div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                -                                <span class="comment">//  -</span></div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                   coeff * coeff * coeff         <span class="comment">//   * a_n^3</span></div><div class="line">                   (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                      old_solution_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                   old_solution_gradients[q]))   <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// * dx</span></div><div class="line"></div><div class="line">          cell_rhs(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                            coeff                     <span class="comment">// * a_n</span></div><div class="line">                            old_solution_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The second lambda function that <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> requires is one that performs the task of accumulating the local contributions in the global linear system. That is precisely what this one does, and the details of the implementation have been seen before. The primary point to recognize is that the local contributions are stored in the <code>copy_data</code> instance that is passed into this function. This <code>copy_data</code> has been filled with data during <em>some</em> call to the <code>cell_worker</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        system_matrix.add(local_dof_indices[i],</div><div class="line">                          local_dof_indices[j],</div><div class="line">                          cell_matrix(i, j));</div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>We have all of the required functions definitions in place, so now we call the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to perform the actual assembly. We pass a flag as the last parameter which states that we only want to perform the assembly on the cells. Internally, <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> then distributes the available work to different threads, making efficient use of the multiple cores almost all of today's processors have to offer.</p>
<div class="fragment"><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                      cell_worker,</div><div class="line">                      copier,</div><div class="line">                      sample_scratch_data,</div><div class="line">                      sample_copy_data,</div><div class="line">                      <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --><p>And finally, as is done in <a class="el" href="step_15.html">step-15</a>, we remove hanging nodes from the system and apply zero boundary values to the linear system that defines the Newton updates \(\delta u^n\).</p>
<div class="fragment"><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheresidualvector"></a> </p><h5>Assembly via differentiation of the residual vector</h5>
<p>As outlined in the introduction, what we need to do for this second approach is implement the local contributions \(F(U)^K\) from cell \(K\) to the residual vector, and then let the AD machinery deal with how to compute the derivatives \(J(U)_{ij}^K=\frac{\partial F(U)^K_i}{\partial U_j}\) from it.</p>
<p>For the following, recall that </p><p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p> where \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\).</p>
<p>Let us see how this is implemented in practice:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>We'll define up front the AD data structures that we'll be using, utilizing the techniques shown in <a class="el" href="step_71.html">step-71</a>. In this case, we choose the helper class that will automatically compute the linearization of the finite element residual using Sacado forward automatic differentiation types. These number types can be used to compute first derivatives only. This is exactly what we want, because we know that we'll only be linearizing the residual, which means that we only need to compute first-order derivatives. The return values from the calculations are to be of type <code>double</code>.</p>
<p>We also need an extractor to retrieve some data related to the field solution to the problem.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,</div><div class="line">  <span class="keywordtype">double</span>&gt;;</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div></div><!-- fragment --><p>With this, let us define the lambda function that will be used to compute the cell contributions to the Jacobian matrix and the right hand side:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                       ScratchData &amp;           scratch_data,</div><div class="line">                                       CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>We'll now create and initialize an instance of the AD helper class. To do this, we need to specify how many independent variables and dependent variables there are. The independent variables will be the number of local degrees of freedom that our solution vector has, i.e., the number \(j\) in the per-element representation of the discretized solution vector \(u (\mathbf{x})|_K = \sum\limits_{j} U^K_i \varphi_j(\mathbf{x})\) that indicates how many solution coefficients are associated with each finite element. In deal.II, this equals <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">FiniteElement::dofs_per_cell</a>. The number of dependent variables will be the number of entries in the local residual vector that we will be forming. In this particular problem (like many others that employ the <a href="https://en.wikipedia.org/wiki/Galerkin_method">standard Galerkin method</a>) the number of local solution coefficients matches the number of local residual equations.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell;</div><div class="line">ADHelper ad_helper(n_independent_variables, n_dependent_variables);</div></div><!-- fragment --><p>Next we inform the helper of the values of the solution, i.e., the actual values for \(U_j\) about which we wish to linearize. As this is done on each element individually, we have to extract the solution coefficients from the global solution vector. In other words, we define all of those coefficients \(U_j\) where \(j\) is a local degree of freedom as the independent variables that enter the computation of the vector \(F(U)^{K}\) (the dependent function).</p>
<p>Then we get the complete set of degree of freedom values as represented by auto-differentiable numbers. The operations performed with these variables are tracked by the AD library from this point until the object goes out of scope. So it is <em>precisely these variables</em> with respect to which we will compute derivatives of the residual entries.</p>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">  ad_helper.get_sensitive_dof_values();</div></div><!-- fragment --><p>Then we do some problem specific tasks, the first being to compute all values, (spatial) gradients, and the like based on "sensitive" AD degree of freedom values. In this instance we are retrieving the solution gradients at each quadrature point. Observe that the solution gradients are now sensitive to the values of the degrees of freedom as they use the <code>ADNumberType</code> as the scalar type and the <code>dof_values_ad</code> vector provides the local DoF values.</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">  dof_values_ad, old_solution_gradients);</div></div><!-- fragment --><p>The next variable that we declare will store the cell residual vector contributions. This is rather self-explanatory, save for one <b>very important</b> detail: Note that each entry in the vector is hand-initialized with a value of zero. This is a <em>highly recommended</em> practice, as some AD libraries appear not to safely initialize the internal data structures of these number types. Not doing so could lead to some very hard to understand or detect bugs (appreciate that the author of this program mentions this out of, generally bad, experience). So out of an abundance of caution it's worthwhile zeroing the initial value explicitly. After that, apart from a sign change the residual assembly looks much the same as we saw for the cell RHS vector before: We loop over all quadrature points, ensure that the coefficient now encodes its dependence on the (sensitive) finite element DoF values by using the correct <code>ADNumberType</code>, and finally we assemble the components of the residual vector. For complete clarity, the finite element shape functions (and their gradients, etc.) as well as the "JxW" values remain scalar valued, but the <code>coeff</code> and the <code>old_solution_gradients</code> at each quadrature point are computed in terms of the independent variables.</p>
<div class="fragment"><div class="line">std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables,</div><div class="line">                                      ADNumberType(0.0));</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> ADNumberType coeff =</div><div class="line">      1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                              old_solution_gradients[q]);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div><div class="line">        residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i</span></div><div class="line">                             coeff                      <span class="comment">// * a_n</span></div><div class="line">                             old_solution_gradients[q]) <span class="comment">// * u_n</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx</span></div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Once we have the full cell residual vector computed, we can register it with the helper class.</p>
<p>Thereafter, we compute the residual values (basically, extracting the real values from what we already computed) and their Jacobian (the linearization of each residual component with respect to all cell DoFs) at the evaluation point. For the purposes of assembly into the global linear system, we have to respect the sign difference between the residual and the RHS contribution: For Newton's method, the right hand side vector needs to be equal to the <em>negative</em> residual vector.</p>
<div class="fragment"><div class="line">  ad_helper.register_residual_vector(residual_ad);</div><div class="line"></div><div class="line">  ad_helper.compute_residual(cell_rhs);</div><div class="line">  cell_rhs *= -1.0;</div><div class="line"></div><div class="line">  ad_helper.compute_linearization(cell_matrix);</div><div class="line">};</div></div><!-- fragment --><p>The remainder of the function equals what we had previously:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">      copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        sample_scratch_data,</div><div class="line">                        sample_copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheenergyfunctional"></a> </p><h5>Assembly via differentiation of the energy functional</h5>
<p>In this third approach, we compute residual and Jacobian as first and second derivatives of the local energy functional </p><p class="formulaDsp">
\[ E\left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{X}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} \]
</p>
<p> with the energy density given by </p><p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}} . \]
</p>
<p>Let us again see how this is done:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>In this implementation of the assembly process, we choose the helper class that will automatically compute both the residual and its linearization from the cell contribution to an energy functional using nested Sacado forward automatic differentiation types. The selected number types can be used to compute both first and second derivatives. We require this, as the residual defined as the sensitivity of the potential energy with respect to the DoF values (i.e. its gradient). We'll then need to linearize the residual, implying that second derivatives of the potential energy must be computed. You might want to compare this with the definition of <code>ADHelper</code> used int previous function, where we used <code><a class="el" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;<a class="el" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,double&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt;</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>,</div><div class="line">  <span class="keywordtype">double</span>&gt;;</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div></div><!-- fragment --><p>Let us then again define the lambda function that does the integration on a cell.</p>
<p>To initialize an instance of the helper class, we now only require that the number of independent variables (that is, the number of degrees of freedom associated with the element solution vector) are known up front. This is because the second-derivative matrix that results from an energy functional is necessarily square (and also, incidentally, symmetric).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                       ScratchData &amp;           scratch_data,</div><div class="line">                                       CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">  ADHelper           ad_helper(n_independent_variables);</div></div><!-- fragment --><p>Once more, we register all cell DoFs values with the helper, followed by extracting the "sensitive" variant of these values that are to be used in subsequent operations that must be differentiated &ndash; one of those being the calculation of the solution gradients.</p>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">  ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">  dof_values_ad, old_solution_gradients);</div></div><!-- fragment --><p>We next create a variable that stores the cell total energy. Once more we emphasize that we explicitly zero-initialize this value, thereby ensuring the integrity of the data for this starting value.</p>
<p>The aim for our approach is then to compute the cell total energy, which is the sum of the internal (due to right hand side functions, typically linear in \(U\)) and external energies. In this particular case, we have no external energies (e.g., from source terms or Neumann boundary conditions), so we'll focus on the internal energy part.</p>
<p>In fact, computing \(E(U)^K\) is almost trivial, requiring only the following lines:</p>
<div class="fragment"><div class="line">ADNumberType energy_ad = ADNumberType(0.0);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                               old_solution_gradients[q]);</div><div class="line"></div><div class="line">    energy_ad += psi * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">  }</div></div><!-- fragment --><p>After we've computed the total energy on this cell, we'll register it with the helper. Based on that, we may now compute the desired quantities, namely the residual values and their Jacobian at the evaluation point. As before, the Newton right hand side needs to be the negative of the residual:</p>
<div class="fragment"><div class="line">  ad_helper.register_energy_functional(energy_ad);</div><div class="line"></div><div class="line">  ad_helper.compute_residual(cell_rhs);</div><div class="line">  cell_rhs *= -1.0;</div><div class="line"></div><div class="line">  ad_helper.compute_linearization(cell_matrix);</div><div class="line">};</div></div><!-- fragment --><p>As in the previous two functions, the remainder of the function is as before:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">      copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        sample_scratch_data,</div><div class="line">                        sample_copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsolve"></a> </p><h4>MinimalSurfaceProblem::solve</h4>
<p>The solve function is the same as is used in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div><div class="line">                               system_rhs.l2_norm() * 1e-6);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(newton_update);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length();</div><div class="line">  current_solution.add(alpha, newton_update);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrefine_mesh"></a> </p><h4>MinimalSurfaceProblem::refine_mesh</h4>
<p>Nothing has changed since <a class="el" href="step_15.html">step-15</a> with respect to the mesh refinement procedure and transfer of the solution between adapted meshes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    current_solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line"></div><div class="line">  triangulation.prepare_coarsening_and_refinement();</div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_transfer.interpolate(current_solution, tmp);</div><div class="line">  current_solution = tmp;</div><div class="line"></div><div class="line">  hanging_node_constraints.clear();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                          hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close();</div><div class="line"></div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  setup_system(<span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemset_boundary_values"></a> </p><h4>MinimalSurfaceProblem::set_boundary_values</h4>
<p>The choice of boundary conditions remains identical to <a class="el" href="step_15.html">step-15</a>...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">{</div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">    current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemcompute_residual"></a> </p><h4>MinimalSurfaceProblem::compute_residual</h4>
<p>... as does the function used to compute the residual during the solution iteration procedure. One could replace this by differentiation of the energy functional if one really wanted, but for simplicity we here simply copy what we already had in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  evaluation_point = current_solution;</div><div class="line">  evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                   coeff                    <span class="comment">// * a_n</span></div><div class="line">                                   <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// * u_n</span></div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemdetermine_step_length"></a> </p><h4>MinimalSurfaceProblem::determine_step_length</h4>
<p>The choice of step length (or, under-relaxation factor) for the nonlinear iterations procedure remains fixed at the value chosen and discussed in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0.1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemoutput_results"></a> </p><h4>MinimalSurfaceProblem::output_results</h4>
<p>This last function to be called from <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> outputs the current solution (and the Newton update) in graphical form as a VTU file. It is entirely the same as what has been used in previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrun"></a> </p><h4>MinimalSurfaceProblem::run</h4>
<p>In the run function, most remains the same as was first implemented in <a class="el" href="step_15.html">step-15</a>. The only observable changes are that we can now choose (via the parameter file) what the final acceptable tolerance for the system residual is, and that we can choose which method of assembly we wish to utilize. To make the second choice clear, we output to the console some message which indicates the selection. Since we're interested in comparing the time taken to assemble for each of the three methods, we've also added a timer that keeps a track of how much time is spent during assembly. We also track the time taken to solve the linear system, so that we can contrast those numbers to the part of the code which would normally take the longest time to execute.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach ********&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = {</div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}};</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size());</div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*first time=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5;</div><div class="line">             ++inner_iteration)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (formulation == 0)</div><div class="line">                assemble_system_unassisted();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1)</div><div class="line">                assemble_system_with_residual_linearization();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2)</div><div class="line">                assemble_system_using_energy_functional();</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line"></div><div class="line">            last_residual_norm = system_rhs.l2_norm();</div><div class="line"></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">              solve();</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        ++refinement_cycle;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step72</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main function</h4>
<p>Finally the main function. This follows the scheme of most other main functions, with two obvious exceptions:</p><ul>
<li>We call <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> in order to set up (via a hidden default parameter) the number of threads using the execution of multithreaded tasks.</li>
<li>We also have a few lines dedicates to reading in or initializing the user-defined parameters that will be considered during the execution of the program.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step72;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d;</div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation,</div><div class="line">                                     parameters.tolerance);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Since there was no change to the physics of the problem that has first been analyzed in <a class="el" href="step_15.html">step-15</a>, there is nothing to report about that. The only outwardly noticeable difference between them is that, by default, this program will only run 9 mesh refinement steps (as opposed to <a class="el" href="step_15.html">step-15</a>, which executes 11 refinements). This will be observable in the simulation status that appears between the header text that prints which assembly method is being used, and the final timings. (All timings reported below were obtained in release mode.)</p>
<div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Initial residual: 1.53143</div><div class="line">  Residual: 1.08746</div><div class="line">  Residual: 0.966748</div><div class="line">  Residual: 0.859602</div><div class="line">  Residual: 0.766462</div><div class="line">  Residual: 0.685475</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Mesh refinement step 9</div><div class="line">  Initial residual: 0.00924594</div><div class="line">  Residual: 0.00831928</div><div class="line">  Residual: 0.0074859</div><div class="line">  Residual: 0.0067363</div><div class="line">  Residual: 0.00606197</div><div class="line">  Residual: 0.00545529</div></div><!-- fragment --><p>So what is interesting for us to compare is how long the assembly process takes for the three different implementations, and to put that into some greater context. Below is the output for the hand linearization (as computed on a circa 2012 four core, eight thread laptop &ndash; but we're only really interested in the relative time between the different implementations): </p><div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Unassisted implementation (full hand linearization).</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      35.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      1.56s |       4.5% |</div><div class="line">| Solve                           |        50 |      30.8s |        88% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> And for the implementation that linearizes the residual in an automated manner using the Sacado dynamic forward AD number type: </p><div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Automated linearization of the finite element residual.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      40.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |       8.8s |        22% |</div><div class="line">| Solve                           |        50 |      28.6s |        71% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> And, lastly, for the implementation that computes both the residual and its linearization directly from an energy functional (using nested Sacado dynamic forward AD numbers): </p><div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Automated computation of finite element residual and linearization <span class="keyword">using</span> a variational formulation.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      48.8s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      16.7s |        34% |</div><div class="line">| Solve                           |        50 |      29.3s |        60% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>It's evident that the more work that is passed off to the automatic differentiation framework to perform, the more time is spent during the assembly process. Accumulated over all refinement steps, using one level of automatic differentiation resulted in \(5.65 \times\) more computational time being spent in the assembly stage when compared to unassisted assembly, while assembling the discrete linear system took \(10.7 \times\) longer when deriving directly from the energy functional. Unsurprisingly, the overall time spent solving the linear system remained unchanged. This means that the proportion of time spent in the solve phase to the assembly phase shifted significantly as the number of times automated differentiation was performed at the finite element level. For many, this might mean that leveraging higher-order differentiation (at the finite element level) in production code leads to an unacceptable overhead, but it may still be useful during the prototyping phase. A good compromise between the two may, therefore, be the automated linearization of the finite element residual, which offers a lot of convenience at a measurable, but perhaps not unacceptable, cost. Alternatively, one could consider not re-building the Newton matrix in every step &ndash; a topic that is explored in substantial depth in <a class="el" href="step_77.html">step-77</a>.</p>
<p>Of course, in practice the actual overhead is very much dependent on the problem being evaluated (e.g., how many components there are in the solution, what the nature of the function being differentiated is, etc.). So the exact results presented here should be interpreted within the context of this scalar problem alone, and when it comes to other problems, some preliminary investigation by the user is certainly warranted.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>Like <a class="el" href="step_71.html">step-71</a>, there are a few items related to automatic differentiation that could be evaluated further:</p><ul>
<li>The use of other AD frameworks should be investigated, with the outlook that alternative implementations may provide performance benefits.</li>
<li>It is also worth evaluating AD number types other than those that have been hard-coded into this tutorial. With regard to twice differentiable types employed at the finite-element level, mixed differentiation modes ("RAD-FAD") should in principle be more computationally efficient than the single mode ("FAD-FAD") types employed here. The reason that the RAD-FAD type was not selected by default is that, at the time of writing, there remain some bugs in its implementation within the Sacado library that lead to memory leaks. This is documented in the <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module.</li>
<li>It might be the case that using reduced precision types (i.e., <code>float</code>) as the scalar types for the AD numbers could render a reduction in computational expense during assembly. Using <code>float</code> as the data type for the matrix and the residual is not unreasonable, given that the Newton update is only meant to get us closer to the solution, but not actually <em>to</em> the solution; as a consequence, it makes sense to consider using reduced-precision data types for computing these updates, and then accumulating these updates in a solution vector that uses the full <code>double</code> precision accuracy.</li>
<li>One further method of possibly reducing resources during assembly is to frame the AD implementations as a constitutive model. This would be similar to the approach adopted in <a class="el" href="step_71.html">step-71</a>, and pushes the starting point for the automatic differentiation one level higher up the chain of computations. This, in turn, means that less operations are tracked by the AD library, thereby reducing the cost of differentiating (even though one would perform the differentiation at each cell quadrature point).</li>
<li><a class="el" href="step_77.html">step-77</a> is yet another variation of <a class="el" href="step_15.html">step-15</a> that addresses a very different part of the problem: Line search and whether it is necessary to re-build the Newton matrix in every nonlinear iteration. Given that the results above show that using automatic differentiation comes at a cost, the techniques in <a class="el" href="step_77.html">step-77</a> have the potential to offset these costs to some degree. It would therefore be quite interesting to combine the current program with the techniques in <a class="el" href="step_77.html">step-77</a>. For production codes, this would certainly be the way to go.</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Jean-Paul Pelteret,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot;, authored by Sven Wetterauer, University of Heidelberg, 2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step72</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblemParameters();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> tolerance = 1e-2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2));</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_unassisted();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_with_residual_linearization();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_using_energy_functional();</div><div class="line">    <span class="keywordtype">void</span>   solve();</div><div class="line">    <span class="keywordtype">void</span>   refine_mesh();</div><div class="line">    <span class="keywordtype">void</span>   set_boundary_values();</div><div class="line">    <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line">    Vector&lt;double&gt; newton_update;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(2)</div><div class="line">    , quadrature_formula(fe.degree + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                    ScratchData &amp;           scratch_data,</div><div class="line">                                    CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution,</div><div class="line">                                       old_solution_gradients);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                    old_solution_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                     * coeff                         <span class="comment">//   * a_n</span></div><div class="line">                     * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                    -                                <span class="comment">//  -</span></div><div class="line">                    (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                     * coeff * coeff * coeff         <span class="comment">//   * a_n^3</span></div><div class="line">                     * (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                        * old_solution_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                     * old_solution_gradients[q]))   <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// * dx</span></div><div class="line"></div><div class="line">              cell_rhs(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                              * coeff                     <span class="comment">// * a_n</span></div><div class="line">                              * old_solution_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                              * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// * dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,</div><div class="line">      <span class="keywordtype">double</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                           ScratchData &amp;           scratch_data,</div><div class="line">                                           CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell;</div><div class="line">      ADHelper ad_helper(n_independent_variables, n_dependent_variables);</div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">        ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">        dof_values_ad, old_solution_gradients);</div><div class="line"></div><div class="line">      std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables,</div><div class="line">                                            ADNumberType(0.0));</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> ADNumberType coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                    old_solution_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i</span></div><div class="line">                                 * coeff                      <span class="comment">// * a_n</span></div><div class="line">                                 * old_solution_gradients[q]) <span class="comment">// * u_n</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      ad_helper.register_residual_vector(residual_ad);</div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs);</div><div class="line">      cell_rhs *= -1.0;</div><div class="line"></div><div class="line">      ad_helper.compute_linearization(cell_matrix);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt;</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>,</div><div class="line">      <span class="keywordtype">double</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                           ScratchData &amp;           scratch_data,</div><div class="line">                                           CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">      ADHelper           ad_helper(n_independent_variables);</div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">        ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">        dof_values_ad, old_solution_gradients);</div><div class="line"></div><div class="line">      ADNumberType energy_ad = ADNumberType(0.0);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                                     old_solution_gradients[q]);</div><div class="line"></div><div class="line">          energy_ad += psi * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      ad_helper.register_energy_functional(energy_ad);</div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs);</div><div class="line">      cell_rhs *= -1.0;</div><div class="line"></div><div class="line">      ad_helper.compute_linearization(cell_matrix);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div><div class="line">                                 system_rhs.l2_norm() * 1e-6);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(newton_update);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length();</div><div class="line">    current_solution.add(alpha, newton_update);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = tmp;</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    evaluation_point = current_solution;</div><div class="line">    evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                   * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                   * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// * u_n</span></div><div class="line">                                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach ********&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = {</div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}};</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size());</div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*first time=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5;</div><div class="line">             ++inner_iteration)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (formulation == 0)</div><div class="line">                assemble_system_unassisted();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1)</div><div class="line">                assemble_system_with_residual_linearization();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2)</div><div class="line">                assemble_system_using_energy_functional();</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line"></div><div class="line">            last_residual_norm = system_rhs.l2_norm();</div><div class="line"></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">              solve();</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        ++refinement_cycle;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step72</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step72;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d;</div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation,</div><div class="line">                                     parameters.tolerance);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_71.html">step-71</a> , <a class="el" href="step_15.html">step-15</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Motivation">Motivation</a><a href="#Motivation">Motivation</a>
        <li><a href="#ComputingtheJacobianfromtheresidual"> Computing the Jacobian from the residual </a><a href="#ComputingtheJacobianfromtheresidual"> Computing the Jacobian from the residual </a>
        <li><a href="#ComputingtheJacobianandtheresidualfromtheenergyfunctional"> Computing the Jacobian and the residual from the energy functional </a><a href="#ComputingtheJacobianandtheresidualfromtheenergyfunctional"> Computing the Jacobian and the residual from the energy functional </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemParameterscodeclass">The <code>MinimalSurfaceProblemParameters</code> class</a><a href="#ThecodeMinimalSurfaceProblemParameterscodeclass">The <code>MinimalSurfaceProblemParameters</code> class</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#MinimalSurfaceProblemMinimalSurfaceProblem">MinimalSurfaceProblem::MinimalSurfaceProblem</a><a href="#MinimalSurfaceProblemMinimalSurfaceProblem">MinimalSurfaceProblem::MinimalSurfaceProblem</a>
        <li><a href="#MinimalSurfaceProblemsetup_system">MinimalSurfaceProblem::setup_system</a><a href="#MinimalSurfaceProblemsetup_system">MinimalSurfaceProblem::setup_system</a>
        <li><a href="#Assemblingthelinearsystem">Assembling the linear system</a><a href="#Assemblingthelinearsystem">Assembling the linear system</a>
      <ul>
        <li><a href="#Manualassembly">Manual assembly</a><a href="#Manualassembly">Manual assembly</a>
        <li><a href="#Assemblyviadifferentiationoftheresidualvector">Assembly via differentiation of the residual vector</a><a href="#Assemblyviadifferentiationoftheresidualvector">Assembly via differentiation of the residual vector</a>
        <li><a href="#Assemblyviadifferentiationoftheenergyfunctional">Assembly via differentiation of the energy functional</a><a href="#Assemblyviadifferentiationoftheenergyfunctional">Assembly via differentiation of the energy functional</a>
      </ul>
        <li><a href="#MinimalSurfaceProblemsolve">MinimalSurfaceProblem::solve</a><a href="#MinimalSurfaceProblemsolve">MinimalSurfaceProblem::solve</a>
        <li><a href="#MinimalSurfaceProblemrefine_mesh">MinimalSurfaceProblem::refine_mesh</a><a href="#MinimalSurfaceProblemrefine_mesh">MinimalSurfaceProblem::refine_mesh</a>
        <li><a href="#MinimalSurfaceProblemset_boundary_values">MinimalSurfaceProblem::set_boundary_values</a><a href="#MinimalSurfaceProblemset_boundary_values">MinimalSurfaceProblem::set_boundary_values</a>
        <li><a href="#MinimalSurfaceProblemcompute_residual">MinimalSurfaceProblem::compute_residual</a><a href="#MinimalSurfaceProblemcompute_residual">MinimalSurfaceProblem::compute_residual</a>
        <li><a href="#MinimalSurfaceProblemdetermine_step_length">MinimalSurfaceProblem::determine_step_length</a><a href="#MinimalSurfaceProblemdetermine_step_length">MinimalSurfaceProblem::determine_step_length</a>
        <li><a href="#MinimalSurfaceProblemoutput_results">MinimalSurfaceProblem::output_results</a><a href="#MinimalSurfaceProblemoutput_results">MinimalSurfaceProblem::output_results</a>
        <li><a href="#MinimalSurfaceProblemrun">MinimalSurfaceProblem::run</a><a href="#MinimalSurfaceProblemrun">MinimalSurfaceProblem::run</a>
        <li><a href="#Themainfunction">The main function</a><a href="#Themainfunction">The main function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em>This program was contributed by Jean-Paul Pelteret and Wolfgang Bangerth.</em></p>
<p><em>Wolfgang Bangerth's work is partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Motivation"></a></p><h3>Motivation</h3>
<p>This program solves the same problem as <a class="el" href="step_15.html">step-15</a> , that is, it solvesfor the<a href="https://en.wikipedia.org/wiki/Minimal_surface">minimal surface equation</a> </p><p class="formulaDsp">
\begin{align*} F(u) \dealcoloneq -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p>Among the issues we had identified there (see the<a href="step_15#extensions">Possibilities for extensions</a> section)was that when wanting to usea Newton iteration, we needed to compute the derivative of theresidual of the equation with regard to the solution \(u\) (here,because the right hand side is zero, the residual is simply the lefthand side). For the equation we have here, this is cumbersome but notimpossible</p>
<ul>
<li>but one can easily imagine much more complicatedequations where just implementing the residual itself correctly is achallenge, let alone doing so for the derivative necessary to computethe Jacobian matrix. We will address this issue in this program: Usingthe automatic differentiation techniques discussed in great detail in <a class="el" href="step_71.html">step-71</a> , we will come up with a way how we only have to implement theresidual and get the Jacobian for free. In fact, we can even go one step further. While in <a class="el" href="step_15.html">step-15</a> we havejust taken the equation as a given, the minimal surface equation isactually the product of minimizing an energy. Specifically,the minimal surface equations are the Euler-Lagrange equations thatcorrespond to minimizing the energy <p class="formulaDsp">
\[ E(u) = \int_\Omega \Psi \left( u \right) \]
</p>
 theenergy density* is given by <p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}}. \]
</p>
 is the same as saying that we seek to find the stationary point ofthe variation of the energy functional <p class="formulaDsp">
\[ \min\limits_{u} E \left( u \right) \quad \rightarrow \quad \delta E \left( u, \varphi \right) \dealcoloneq \left(\varphi, F(u)\right) = 0 \qquad \forall \varphi, \]
</p>
 this is where the equilibrium solution to the boundary value problem lies. The key point then is that, maybe, we don't even need to implement theresidual, but that implementing the simpler energy density \(\Psi(u)\) might actually be enough. Our goal then is this: Whenusing a Newton iteration, we need to repeatedly solve thelinear partial differential equation <p class="formulaDsp">
\begin{align*} F&#39;(u^{n},\delta u^{n}) &amp;=- F(u^{n}) \end{align*}
</p>
 so that we can compute the update <p class="formulaDsp">
\begin{align*} u^{n+1}&amp;=u^{n}+\alpha^n \delta u^{n} \end{align*}
</p>
 with the solution \(\delta u^{n}\) of the Newton step. As discussed in <a class="el" href="step_15.html">step-15</a> ,we can compute the derivative \(F&#39;(u,\delta u)\) by hand andobtain <p class="formulaDsp">
\[ F&#39;(u,\delta u) = - \nabla \cdot \left( \frac{1}{\left(1+|\nabla u|^{2}\right)^{\frac{1}{2}}}\nabla \delta u \right) + \nabla \cdot \left( \frac{\nabla u \cdot \nabla \delta u}{\left(1+|\nabla u|^{2}\right)^{\frac{3}{2}}} \nabla u \right). \]
</p>
 So here then is what this program is about: It is about techniquesthat can help us with computing \(F&#39;(u,\delta u)\) without having toimplement it explicitly, either by providing an implementation of \(F(u)\) or an implementation of \(E(u)\) . More precisely, we willimplement three different approaches and compare them in terms ofrun-time but also</li>
<li>maybe more importantly</li>
<li>how much human effortit takes to implement them:</li>
<li>The method used in <a class="el" href="step_15.html">step-15</a> to form the Jacobian matrix.</li>
<li>Computing the Jacobian matrix from an implementation of the residual \(F(u)\) , using automatic differentiation.</li>
<li>Computing both the residual and Jacobian matrix from an implementation of the energy functional \(E(u)\) , also using automatic differentiation. For the first of these methods, there are no conceptual changescompared to <a class="el" href="step_15.html">step-15</a> .</li>
</ul>
<p><a class="anchor" id="ComputingtheJacobianfromtheresidual"></a></p><h3>Computing the Jacobian from the residual </h3>
<p>For the second method, let us outline how we will approach the issueusing automatic differentiationto compute the linearization of the residual vector. To this end, letus change notation for a moment and denote by \(F(U)\) not the residualof the differential equation, but in fact theresidual vector*</p>
<ul>
<li>i.e., thediscrete residual*. We do so because that is what we actually* do when we discretize the problem on a given mesh: We solvethe problem \(F(U)=0\) where \(U\) is the vector of unknowns. More precisely, the \(i\) th component of the residual is given by <p class="formulaDsp">
\[ F(U)_i \dealcoloneq \int\limits_{\Omega}\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
 \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) . Given this, thecontribution for cell \(K\) is <p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
 first order Taylor expansion is given as <p class="formulaDsp">
\[ F(U + \delta U)_i^K \approx F(U)_i^K + \sum_{j}^{n_{\textrm{dofs}}} \left[ \frac{\partial F(U)_i^K}{\partial U_j} \delta U_j \right], \]
</p>
 consequently we can compute the contribution of cell \(K\) to theJacobian matrix \(J\) as \(J(U)_{ij}^K = \frac{\partial F(U)_i^K}{\partial U_j}\) . Theimportant point here is that on cell \(K\) , we can express <p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+\left| \sum_{j&#39;}^{n_\textrm{dofs}} U_{j&#39;} \nabla \varphi_{j&#39;}\right|^{2}}} \left(\sum_{j&#39;&#39;}^{n_\textrm{dofs}} U_{j&#39;&#39;} \nabla \varphi_{j&#39;&#39;}\right)\right] \, dV. \]
</p>
 clarity, we have used \(j&#39;\) and \(j&#39;&#39;\) as counting indices to makeclear that they are distinct from each other and from \(j\) above.Because in this formula, \(F(U)\) only depends on the coefficients \(U_j\) , we can compute the derivative \(J(U)_{ij}^K\) as a matrix viaautomatic differentiation of \(F(U)_i^K\) . By the same argument as wealways use, it is clear that \(F(U)^K\) does not actually depend on all* unknowns \(U_j\) , but only on those unknowns for which \(j\) is ashape function that lives on cell \(K\) , and so in practice, we restrict \(F(U)^K\) and \(J(U)^K\) to that part of the vector and matrix thatcorresponds to thelocal* DoF indices, and then distribute from thelocal cell \(K\) to the global objects. Using all of these realizations, the approach will then be toimplement \(F(U)^K\) in the program and let the automatic differentiationmachinery compute the derivatives \(J(U)^K\) from that.</li>
</ul>
<p><a class="anchor" id="ComputingtheJacobianandtheresidualfromtheenergyfunctional"></a></p><h3>Computing the Jacobian and the residual from the energy functional </h3>
<p>For the final implementation of the assembly process, we will move a levelhigher than the residual: our entire linear system will be determineddirectly from the energy functional that governs the physics of thisboundary value problem. We can take advantage of the fact that we cancalculate the total energy in the domain directly from the localcontributions, i.e., </p><p class="formulaDsp">
\[ E \left( U \right) \dealcoloneq \int\limits_{\Omega} \Psi \left( u \right) \, dV . \]
</p>
<p> the discrete setting, this means that on each finite element we have </p><p class="formulaDsp">
\[ E \left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{x}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} . \]
</p>
<p> we implement the cell energy, which depends on the field solution,we can compute its first (discrete) variation </p><p class="formulaDsp">
\[ F(U)^K_i = \frac{\partial E(U)^K}{\partial U_i} \]
</p>
<p>, thereafter, its second (discrete) variation </p><p class="formulaDsp">
\[ J(U)^K_{ij} = \frac{\partial^{2} E(U)^K}{\partial U_i \partial U_j}. \]
</p>
<p>, from the cell contribution to the total energy function, we may expectto have the approximate residual and tangent contributions generatedfor us as long as we can provide an implementation of the local energy \(E(U)^K\) . Again, due to the design of theautomatic differentiation variables used in this tutorial, in practicethese approximations for the contributions to the residual vector andtangent matrix are actually accurate to machine precision.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The majority of this tutorial is an exact replica of <a class="el" href="step_15.html">step-15</a> . So, in the interest of brevity and maintaining a focus on the changes implemented here, we will only document what's new and simply indicate which sections of code are a repetition of what has come before.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>There are a few new header files that have been included in this tutorial. The first is the one that provides the declaration of the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>This is the second, which is an all-inclusive header that will allow us to incorporate the automatic differentiation (AD) functionality within this code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>And the next three provide some multi-threading capability using the generic <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> framework.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>We then open a namespace for this program and import everything from the dealii namespace into it, as in previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step72</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemParameterscodeclass"></a> </p><h3>The <code>MinimalSurfaceProblemParameters</code> class</h3>
<p>In this tutorial we will implement three different approaches for assembling the linear system. One mirrors the hand implementation originally provided in <a class="el" href="step_15.html">step-15</a> , while the other two use the Sacado automatic differentiation library that is provided as a part of the Trilinos framework. To facilitate switching between the three implementations, we have this really basic parameters class that has only two options that are configurable.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblemParameters();</div></div><!-- fragment --><p>Selection for the formulation and corresponding AD framework to be used:</p>
<ul>
<li>formulation = 0 : Unassisted implementation (full hand linearization).</li>
<li>formulation = 1 : Automated linearization of the finite element residual.</li>
<li>formulation = 2 : Automated computation of finite element residual and linearization using a variational formulation.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0;</div></div><!-- fragment --><p>The maximum acceptable tolerance for the linear system residual. We will see that the assembly time becomes appreciable once we use the AD framework, so we have increased the tolerance selected in <a class="el" href="step_15.html">step-15</a> by one order of magnitude. This way, the computations do not take too long to complete.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> tolerance = 1e-2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2));</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>The class template is essentially the same as in <a class="el" href="step_15.html">step-15</a> . The only functional changes to the class are that:</p>
<ul>
<li>the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function now takes in two arguments: one to choose which assembly approach is to be adopted, and one for the tolerance for the permissible final residual is, and</li>
<li>there are now three different assembly functions that implement the three methods of assembling the linear system. We'll provide details on these later on.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_unassisted();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_with_residual_linearization();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_using_energy_functional();</div><div class="line">  <span class="keywordtype">void</span>   solve();</div><div class="line">  <span class="keywordtype">void</span>   refine_mesh();</div><div class="line">  <span class="keywordtype">void</span>   set_boundary_values();</div><div class="line">  <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line">  Vector&lt;double&gt; newton_update;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>There are no changes to the boundary conditions applied to the problem.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 numbers::PI (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<pre class="fragment">&lt;a name="MinimalSurfaceProblemMinimalSurfaceProblem"&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::MinimalSurfaceProblem&lt;/h4&gt;
</pre><p>There have been no changes made to the class constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(2)</div><div class="line">  , quadrature_formula(fe.degree + 1)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsetup_system"></a> </p><h4>MinimalSurfaceProblem::setup_system</h4>
<p>There have been no changes made to the function that sets up the class data structures, namely the <a class="el" href="classDoFHandler.html">DoFHandler</a>, the hanging node constraints applied to the problem, and the linear system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblingthelinearsystem"></a> </p><h4>Assembling the linear system</h4>
<pre class="fragment">&lt;a name="Manualassembly"&gt;&lt;/a&gt;  &lt;h5&gt;Manual assembly&lt;/h5&gt;
</pre><p>The assembly functions are the interesting contributions to this tutorial. The assemble_system_unassisted() method implements exactly the same assembly function as is detailed in <a class="el" href="step_15.html">step-15</a> , but in this instance we use the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function to multithread the assembly process. The reason for doing this is quite simple: When using automatic differentiation, we know that there is to be some additional computational overhead incurred. In order to mitigate this performance loss, we'd like to take advantage of as many (easily available) computational resources as possible. The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> concept makes this a relatively straightforward task. At the same time, for the purposes of fair comparison, we need to do the same to the implementation that uses no assistance when computing the residual or its linearization. (The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function is first discussed in <a class="el" href="step_12.html">step-12</a> and <a class="el" href="step_16.html">step-16</a> , if you'd like to read up on it.) The steps required to implement the multithreading are the same between the three functions, so we'll use the assemble_system_unassisted() function as an opportunity to focus on the multithreading itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div></div><!-- fragment --><p>The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> expects that we provide two exemplar data structures. The first, <code>ScratchData</code>, is to store all large data that is to be reused between threads. The <code>CopyData</code> will hold the contributions to the linear system that come from each cell. These independent matrix-vector pairs must be accumulated into the global linear system sequentially. Since we don't need anything on top of what the <a class="el" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData</a> and <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> classes already provide, we use these exact class definitions for our problem. Note that we only require a single instance of a local matrix, local right-hand side vector, and cell degree of freedom index vector</p>
<ul>
<li>the <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> therefore has <code>1</code> for all three of its template arguments.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line"><span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div></div><!-- fragment --><p>We also need to know what type of iterator we'll be working with during assembly. For simplicity, we just ask the compiler to work this out for us using the decltype() specifier, knowing that we'll be iterating over active cells owned by the <code>dof_handler</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div></div><!-- fragment --><p>Here we initialize the exemplar data structures. Since we know that we need to compute the shape function gradients, weighted Jacobian, and the position of the quadrate points in real space, we pass these flags into the class constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"><span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>Now we define a lambda function that will perform the assembly on a single cell. The three arguments are those that will be expected by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>, due to the arguments that we'll pass to that final call. We also capture the <code>this</code> pointer, which means that we'll have access to "this" (i.e., the current <code>MinimalSurfaceProblem&lt;dim&gt;</code>) class instance, and its private member data (since the lambda function is defined within a MinimalSurfaceProblem&lt;dim&gt; method). At the top of the function, we initialize the data structures that are dependent on the cell for which the work is being performed. Observe that the reinitialization call actually returns an instance to an <a class="el" href="classFEValues.html">FEValues</a> object that is initialized and stored within (and, therefore, reused by) the <code>scratch_data</code> object. Similarly, we get aliases to the local matrix, local RHS vector, and local cell DoF indices from the <code>copy_data</code> instance that <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> provides. We then initialize the cell DoF indices, knowing that the local matrix and vector are already correctly sized.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                ScratchData &amp;           scratch_data,</div><div class="line">                                CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>For Newton's method, we require the gradient of the solution at the point about which the problem is being linearized. Once we have that, we can perform assembly for this cell in the usual way. One minor difference to <a class="el" href="step_15.html">step-15</a> is that we've used the (rather convenient) range-based loops to iterate over all quadrature points and degrees-of-freedom.</p>
<div class="fragment"><div class="line">       std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients(</div><div class="line">         fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution,</div><div class="line">                                        old_solution_gradients);</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">         {</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">             1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q]</div><div class="line">                                     old_solution_gradients[q]);</div><div class="line">  </div><div class="line">           <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">             {</div><div class="line">               <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                 <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                   (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                      coeff                         <span class="comment">//   a_n</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   \nabla \phi_j)</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-                                <span class="comment">//</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-</div><div class="line">                     (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                      coeff coeff coeff         <span class="comment">//   a_n^3</span></div><div class="line">                      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   (\nabla \phi_j</span></div><div class="line">                         old_solution_gradients[q]) <span class="comment">//      \nabla u_n)</span></div><div class="line">                      old_solution_gradients[q]))   <span class="comment">//   \nabla u_n)))</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// dx</span></div><div class="line">  </div><div class="line">               cell_rhs(i)</div><div class="line">  </div><div class="line">-= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                               coeff                     <span class="comment">// a_n</span></div><div class="line">                               old_solution_gradients[q] <span class="comment">// u_n</span></div><div class="line">                               fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// dx</span></div><div class="line">             }</div><div class="line">         }</div><div class="line">     };</div></div><!-- fragment --><p>The second lambda function that <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> requires is one that performs the task of accumulating the local contributions in the global linear system. That is precisely what this one does, and the details of the implementation have been seen before. The primary point to recognize is that the local contributions are stored in the <code>copy_data</code> instance that is passed into this function. This <code>copy_data</code> has been filled with data during <em>some</em> call to the <code>cell_worker</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        system_matrix.add(local_dof_indices[i],</div><div class="line">                          local_dof_indices[j],</div><div class="line">                          cell_matrix(i, j));</div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>We have all of the required functions definitions in place, so now we call the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to perform the actual assembly. We pass a flag as the last parameter which states that we only want to perform the assembly on the cells. Internally, <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> then distributes the available work to different threads, making efficient use of the multiple cores almost all of today's processors have to offer.</p>
<div class="fragment"><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                      cell_worker,</div><div class="line">                      copier,</div><div class="line">                      sample_scratch_data,</div><div class="line">                      sample_copy_data,</div><div class="line">                      <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --><p>And finally, as is done in <a class="el" href="step_15.html">step-15</a> , we remove hanging nodes from the system and apply zero boundary values to the linear system that defines the Newton updates \(\delta u^n\) .</p>
<div class="fragment"><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheresidualvector"></a> </p><h5>Assembly via differentiation of the residual vector</h5>
<p>As outlined in the introduction, what we need to do for this second approach is implement the local contributions \(F(U)^K\) from cell \(K\) to the residual vector, and then let the AD machinery deal with how to compute the derivatives \(J(U)_{ij}^K=\frac{\partial F(U)^K_i}{\partial U_j}\) from it. For the following, recall that </p><p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p> where \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) . Let us see how this is implemented in practice:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>We'll define up front the AD data structures that we'll be using, utilizing the techniques shown in <a class="el" href="step_71.html">step-71</a> . In this case, we choose the helper class that will automatically compute the linearization of the finite element residual using Sacado forward automatic differentiation types. These number types can be used to compute first derivatives only. This is exactly what we want, because we know that we'll only be linearizing the residual, which means that we only need to compute first-order derivatives. The return values from the calculations are to be of type <code>double</code>. We also need an extractor to retrieve some data related to the field solution to the problem.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,</div><div class="line">  <span class="keywordtype">double</span>&gt;;</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div></div><!-- fragment --><p>With this, let us define the lambda function that will be used to compute the cell contributions to the Jacobian matrix and the right hand side:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                       ScratchData &amp;           scratch_data,</div><div class="line">                                       CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>We'll now create and initialize an instance of the AD helper class. To do this, we need to specify how many independent variables and dependent variables there are. The independent variables will be the number of local degrees of freedom that our solution vector has, i.e., the number \(j\) in the per-element representation of the discretized solution vector \(u (\mathbf{x})|_K = \sum\limits_{j} U^K_i \varphi_j(\mathbf{x})\) that indicates how many solution coefficients are associated with each finite element. In deal.II, this equals <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">FiniteElement::dofs_per_cell</a>. The number of dependent variables will be the number of entries in the local residual vector that we will be forming. In this particular problem (like many others that employ the <a href="https://en.wikipedia.org/wiki/Galerkin_method">standard Galerkin method</a>) the number of local solution coefficients matches the number of local residual equations.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell;</div><div class="line">ADHelper ad_helper(n_independent_variables, n_dependent_variables);</div></div><!-- fragment --><p>Next we inform the helper of the values of the solution, i.e., the actual values for \(U_j\) about which we wish to linearize. As this is done on each element individually, we have to extract the solution coefficients from the global solution vector. In other words, we define all of those coefficients \(U_j\) where \(j\) is a local degree of freedom as the independent variables that enter the computation of the vector \(F(U)^{K}\) (the dependent function). Then we get the complete set of degree of freedom values as represented by auto-differentiable numbers. The operations performed with these variables are tracked by the AD library from this point until the object goes out of scope. So it is <em> precisely these variables </em> with respect to which we will compute derivatives of the residual entries.</p>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">  ad_helper.get_sensitive_dof_values();</div></div><!-- fragment --><p>Then we do some problem specific tasks, the first being to compute all values, (spatial) gradients, and the like based on "sensitive" AD degree of freedom values. In this instance we are retrieving the solution gradients at each quadrature point. Observe that the solution gradients are now sensitive to the values of the degrees of freedom as they use the <code>ADNumberType</code> as the scalar type and the <code>dof_values_ad</code> vector provides the local DoF values.</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">  dof_values_ad, old_solution_gradients);</div></div><!-- fragment --><p>The next variable that we declare will store the cell residual vector contributions. This is rather self-explanatory, save for one <b>very important</b> detail: Note that each entry in the vector is hand-initialized with a value of zero. This is a <em> highly recommended </em> practice, as some AD libraries appear not to safely initialize the internal data structures of these number types. Not doing so could lead to some very hard to understand or detect bugs (appreciate that the author of this program mentions this out of, generally bad, experience). So out of an abundance of caution it's worthwhile zeroing the initial value explicitly. After that, apart from a sign change the residual assembly looks much the same as we saw for the cell RHS vector before: We loop over all quadrature points, ensure that the coefficient now encodes its dependence on the (sensitive) finite element DoF values by using the correct <code>ADNumberType</code>, and finally we assemble the components of the residual vector. For complete clarity, the finite element shape functions (and their gradients, etc.) as well as the "JxW" values remain scalar valued, but the <code>coeff</code> and the <code>old_solution_gradients</code> at each quadrature point are computed in terms of the independent variables.</p>
<div class="fragment"><div class="line">std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables,</div><div class="line">                                      ADNumberType(0.0));</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> ADNumberType coeff =</div><div class="line">      1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q]</div><div class="line">                              old_solution_gradients[q]);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div><div class="line">        residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i</span></div><div class="line">                           coeff                      <span class="comment">// a_n</span></div><div class="line">                           old_solution_gradients[q]) <span class="comment">// u_n</span></div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// dx</span></div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Once we have the full cell residual vector computed, we can register it with the helper class. Thereafter, we compute the residual values (basically, extracting the real values from what we already computed) and their Jacobian (the linearization of each residual component with respect to all cell DoFs) at the evaluation point. For the purposes of assembly into the global linear system, we have to respect the sign difference between the residual and the RHS contribution: For Newton's method, the right hand side vector needs to be equal to thenegative* residual vector.</p>
<div class="fragment"><div class="line">       ad_helper.register_residual_vector(residual_ad);</div><div class="line">  </div><div class="line">       ad_helper.compute_residual(cell_rhs);</div><div class="line">       cell_rhs=</div><div class="line">  </div><div class="line">-1.0;</div><div class="line">  </div><div class="line">       ad_helper.compute_linearization(cell_matrix);</div><div class="line">     };</div></div><!-- fragment --><p>The remainder of the function equals what we had previously:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">      copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        sample_scratch_data,</div><div class="line">                        sample_copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheenergyfunctional"></a> </p><h5>Assembly via differentiation of the energy functional</h5>
<p>In this third approach, we compute residual and Jacobian as first and second derivatives of the local energy functional </p><p class="formulaDsp">
\[ E\left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{X}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} \]
</p>
<p> with the energy density given by </p><p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}} . \]
</p>
<p> Let us again see how this is done:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>In this implementation of the assembly process, we choose the helper class that will automatically compute both the residual and its linearization from the cell contribution to an energy functional using nested Sacado forward automatic differentiation types. The selected number types can be used to compute both first and second derivatives. We require this, as the residual defined as the sensitivity of the potential energy with respect to the DoF values (i.e. its gradient). We'll then need to linearize the residual, implying that second derivatives of the potential energy must be computed. You might want to compare this with the definition of <code>ADHelper</code> used int previous function, where we used <code><a class="el" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;<a class="el" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,double&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt;</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>,</div><div class="line">  <span class="keywordtype">double</span>&gt;;</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div></div><!-- fragment --><p>Let us then again define the lambda function that does the integration on a cell. To initialize an instance of the helper class, we now only require that the number of independent variables (that is, the number of degrees of freedom associated with the element solution vector) are known up front. This is because the second-derivative matrix that results from an energy functional is necessarily square (and also, incidentally, symmetric).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                       ScratchData &amp;           scratch_data,</div><div class="line">                                       CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">  ADHelper           ad_helper(n_independent_variables);</div></div><!-- fragment --><p>Once more, we register all cell DoFs values with the helper, followed by extracting the "sensitive" variant of these values that are to be used in subsequent operations that must be differentiated</p>
<ul>
<li>one of those being the calculation of the solution gradients.</li>
</ul>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">  ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">  dof_values_ad, old_solution_gradients);</div></div><!-- fragment --><p>We next create a variable that stores the cell total energy. Once more we emphasize that we explicitly zero-initialize this value, thereby ensuring the integrity of the data for this starting value. The aim for our approach is then to compute the cell total energy, which is the sum of the internal (due to right hand side functions, typically linear in \(U\) ) and external energies. In this particular case, we have no external energies (e.g., from source terms or Neumann boundary conditions), so we'll focus on the internal energy part. In fact, computing \(E(U)^K\) is almost trivial, requiring only the following lines:</p>
<div class="fragment"><div class="line">ADNumberType energy_ad = ADNumberType(0.0);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q]</div><div class="line">                                               old_solution_gradients[q]);</div><div class="line"></div><div class="line">    energy_ad += psi fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">  }</div></div><!-- fragment --><p>After we've computed the total energy on this cell, we'll register it with the helper. Based on that, we may now compute the desired quantities, namely the residual values and their Jacobian at the evaluation point. As before, the Newton right hand side needs to be the negative of the residual:</p>
<div class="fragment"><div class="line">       ad_helper.register_energy_functional(energy_ad);</div><div class="line">  </div><div class="line">       ad_helper.compute_residual(cell_rhs);</div><div class="line">       cell_rhs=</div><div class="line">  </div><div class="line">-1.0;</div><div class="line">  </div><div class="line">       ad_helper.compute_linearization(cell_matrix);</div><div class="line">     };</div></div><!-- fragment --><p>As in the previous two functions, the remainder of the function is as before:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">      copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        sample_scratch_data,</div><div class="line">                        sample_copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsolve"></a> </p><h4>MinimalSurfaceProblem::solve</h4>
<p>The solve function is the same as is used in <a class="el" href="step_15.html">step-15</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div><div class="line">                               system_rhs.l2_norm() 1e-6);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(newton_update);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length();</div><div class="line">  current_solution.add(alpha, newton_update);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrefine_mesh"></a> </p><h4>MinimalSurfaceProblem::refine_mesh</h4>
<p>Nothing has changed since <a class="el" href="step_15.html">step-15</a> with respect to the mesh refinement procedure and transfer of the solution between adapted meshes.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">   {</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line">  </div><div class="line">     <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">       dof_handler,</div><div class="line">       <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(fe.degree + 1),</div><div class="line">       std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">       current_solution,</div><div class="line">       estimated_error_per_cell);</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                     estimated_error_per_cell,</div><div class="line">                                                     0.3,</div><div class="line">                                                     0.03);</div><div class="line">  </div><div class="line">     triangulation.prepare_coarsening_and_refinement();</div><div class="line">     <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">     solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">     triangulation.execute_coarsening_and_refinement();</div><div class="line">  </div><div class="line">     dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  </div><div class="line">     Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     solution_transfer.interpolate(current_solution, tmp);</div><div class="line">     current_solution = tmp;</div><div class="line">  </div><div class="line">     hanging_node_constraints.clear();</div><div class="line">     <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                             hanging_node_constraints);</div><div class="line">     hanging_node_constraints.close();</div><div class="line">  </div><div class="line">     set_boundary_values();</div><div class="line">  </div><div class="line">     setup_system(<span class="keyword">false</span>);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemset_boundary_values"></a> </p><h4>MinimalSurfaceProblem::set_boundary_values</h4>
<p>The choice of boundary conditions remains identical to <a class="el" href="step_15.html">step-15</a> ...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">{</div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">    current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemcompute_residual"></a> </p><h4>MinimalSurfaceProblem::compute_residual</h4>
<p>... as does the function used to compute the residual during the solution iteration procedure. One could replace this by differentiation of the energy functional if one really wanted, but for simplicity we here simply copy what we already had in <a class="el" href="step_15.html">step-15</a> .</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  </div><div class="line">     Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     evaluation_point = current_solution;</div><div class="line">     evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                             quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">     Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points);</div><div class="line">  </div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">       {</div><div class="line">         <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">         fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  </div><div class="line">         fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>);</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           {</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">               1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">               <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i)</div><div class="line">  </div><div class="line">-= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                    coeff                    <span class="comment">// a_n</span></div><div class="line">                                    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// u_n</span></div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// dx</span></div><div class="line">           }</div><div class="line">  </div><div class="line">         cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">           residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">       }</div><div class="line">  </div><div class="line">     hanging_node_constraints.condense(residual);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">          <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">       residual(i) = 0;</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemdetermine_step_length"></a> </p><h4>MinimalSurfaceProblem::determine_step_length</h4>
<p>The choice of step length (or, under-relaxation factor) for the nonlinear iterations procedure remains fixed at the value chosen and discussed in <a class="el" href="step_15.html">step-15</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0.1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemoutput_results"></a> </p><h4>MinimalSurfaceProblem::output_results</h4>
<p>This last function to be called from <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> outputs the current solution (and the Newton update) in graphical form as a VTU file. It is entirely the same as what has been used in previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrun"></a> </p><h4>MinimalSurfaceProblem::run</h4>
<p>In the run function, most remains the same as was first implemented in <a class="el" href="step_15.html">step-15</a> . The only observable changes are that we can now choose (via the parameter file) what the final acceptable tolerance for the system residual is, and that we can choose which method of assembly we wish to utilize. To make the second choice clear, we output to the console some message which indicates the selection. Since we're interested in comparing the time taken to assemble for each of the three methods, we've also added a timer that keeps a track of how much time is spent during assembly. We also track the time taken to solve the linear system, so that we can contrast those numbers to the part of the code which would normally take the longest time to execute.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach*******&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = {</div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}};</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size());</div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"> </div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"> </div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"> </div><div class="line">    setup_system( <span class="comment">/*first time=*/</span> <span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"> </div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5;</div><div class="line">             ++inner_iteration)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line"> </div><div class="line">              <span class="keywordflow">if</span> (formulation == 0)</div><div class="line">                assemble_system_unassisted();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1)</div><div class="line">                assemble_system_with_residual_linearization();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2)</div><div class="line">                assemble_system_using_energy_functional();</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line"> </div><div class="line">            last_residual_norm = system_rhs.l2_norm();</div><div class="line"> </div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">              solve();</div><div class="line">            }</div><div class="line"> </div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line"> </div><div class="line">        output_results(refinement_cycle);</div><div class="line"> </div><div class="line">        ++refinement_cycle;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step72</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main function</h4>
<p>Finally the main function. This follows the scheme of most other main functions, with two obvious exceptions:</p>
<ul>
<li>We call <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> in order to set up (via a hidden default parameter) the number of threads using the execution of multithreaded tasks.</li>
<li>We also have a few lines dedicates to reading in or initializing the user-defined parameters that will be considered during the execution of the program.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step72;</div><div class="line"> </div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv);</div><div class="line"> </div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"> </div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"> </div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d;</div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation,</div><div class="line">                                     parameters.tolerance);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Since there was no change to the physics of the problem that has first been analyzedin <a class="el" href="step_15.html">step-15</a> , there is nothing to report about that. The only outwardly noticeabledifference between them is that, by default, this program will only run 9 meshrefinement steps (as opposed to <a class="el" href="step_15.html">step-15</a> , which executes 11 refinements).This will be observable in the simulation status that appears between theheader text that prints which assembly method is being used, and the finaltimings. (All timings reported below were obtained in release mode.) </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Initial residual: 1.53143</div><div class="line">  Residual: 1.08746</div><div class="line">  Residual: 0.966748</div><div class="line">  Residual: 0.859602</div><div class="line">  Residual: 0.766462</div><div class="line">  Residual: 0.685475</div><div class="line">  </div><div class="line">...</div><div class="line">  </div><div class="line">Mesh refinement step 9</div><div class="line">  Initial residual: 0.00924594</div><div class="line">  Residual: 0.00831928</div><div class="line">  Residual: 0.0074859</div><div class="line">  Residual: 0.0067363</div><div class="line">  Residual: 0.00606197</div><div class="line">  Residual: 0.00545529</div></div><!-- fragment --><p>So what is interesting for us to compare is how long the assembly process takesfor the three different implementations, and to put that into some greater context.Below is the output for the hand linearization (as computed on a circa 2012four core, eight thread laptop</p>
<ul>
<li>but we're only really interested in therelative time between the different implementations): <div class="fragment"><div class="line">         Assembly approach*******</div><div class="line">Unassisted implementation (full hand linearization).</div><div class="line">  </div><div class="line">...</div><div class="line">  </div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      35.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      1.56s |       4.5% |</div><div class="line">| Solve                           |        50 |      30.8s |        88% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --> And for the implementation that linearizes the residual in an automatedmanner using the Sacado dynamic forward AD number type: <div class="fragment"><div class="line">         Assembly approach*******</div><div class="line">Automated linearization of the finite element residual.</div><div class="line">  </div><div class="line">...</div><div class="line">  </div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      40.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |       8.8s |        22% |</div><div class="line">| Solve                           |        50 |      28.6s |        71% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --> And, lastly, for the implementation that computes both the residual andits linearization directly from an energy functional (using nested Sacadodynamic forward AD numbers): <div class="fragment"><div class="line">         Assembly approach*******</div><div class="line">Automated computation of finite element residual and linearization <span class="keyword">using</span> a variational formulation.</div><div class="line">  </div><div class="line">...</div><div class="line">  </div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      48.8s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      16.7s |        34% |</div><div class="line">| Solve                           |        50 |      29.3s |        60% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --></li>
</ul>
<p>It's evident that the more work that is passed off to the automatic differentiationframework to perform, the more time is spent during the assembly process. Accumulatedover all refinement steps, using one level of automatic differentiation resultedin \(5.65 \times\) more computational time being spent in the assembly stage whencompared to unassisted assembly, while assembling the discrete linear system took \(10.7 \times\) longer when deriving directly from the energy functional.Unsurprisingly, the overall time spent solving the linear system remained unchanged.This means that the proportion of time spent in the solve phase to the assembly phaseshifted significantly as the number of times automated differentiation was performedat the finite element level. For many, this might mean that leveraging higher-orderdifferentiation (at the finite element level) in production code leads to anunacceptable overhead, but it may still be useful during the prototyping phase.A good compromise between the two may, therefore, be the automated linearizationof the finite element residual, which offers a lot of convenience at a measurable,but perhaps not unacceptable, cost. Alternatively, one could considernot re-building the Newton matrix in every step</p>
<ul>
<li>a topic that isexplored in substantial depth in <a class="el" href="step_77.html">step-77</a> . Of course, in practice the actual overhead is very much dependent on the problem being evaluated(e.g., how many components there are in the solution, what the nature of the functionbeing differentiated is, etc.). So the exact results presented here should beinterpreted within the context of this scalar problem alone, and when it comes toother problems, some preliminary investigation by the user is certainly warranted.</li>
</ul>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>Like <a class="el" href="step_71.html">step-71</a> , there are a few items related to automatic differentiation that couldbe evaluated further:</p>
<ul>
<li>The use of other AD frameworks should be investigated, with the outlook that alternative implementations may provide performance benefits.</li>
<li>It is also worth evaluating AD number types other than those that have been hard-coded into this tutorial. With regard to twice differentiable types employed at the finite-element level, mixed differentiation modes ("RAD-FAD") should in principle be more computationally efficient than the single mode ("FAD-FAD") types employed here. The reason that the RAD-FAD type was not selected by default is that, at the time of writing, there remain some bugs in its implementation within the Sacado library that lead to memory leaks. This is documented in the <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module.</li>
<li>It might be the case that using reduced precision types (i.e., <code>float</code>) as the scalar types for the AD numbers could render a reduction in computational expense during assembly. Using <code>float</code> as the data type for the matrix and the residual is not unreasonable, given that the Newton update is only meant to get us closer to the solution, but not actuallyto* the solution; as a consequence, it makes sense to consider using reduced-precision data types for computing these updates, and then accumulating these updates in a solution vector that uses the full <code>double</code> precision accuracy.</li>
<li>One further method of possibly reducing resources during assembly is to frame the AD implementations as a constitutive model. This would be similar to the approach adopted in <a class="el" href="step_71.html">step-71</a> , and pushes the starting point for the automatic differentiation one level higher up the chain of computations. This, in turn, means that less operations are tracked by the AD library, thereby reducing the cost of differentiating (even though one would perform the differentiation at each cell quadrature point).</li>
<li><a class="el" href="step_77.html">step-77</a> is yet another variation of <a class="el" href="step_15.html">step-15</a> that addresses a very different part of the problem: Line search and whether it is necessary to re-build the Newton matrix in every nonlinear iteration. Given that the results above show that using automatic differentiation comes at a cost, the techniques in <a class="el" href="step_77.html">step-77</a> have the potential to offset these costs to some degree. It would therefore be quite interesting to combine the current program with the techniques in <a class="el" href="step_77.html">step-77</a> . For production codes, this would certainly be the way to go.</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Jean-Paul Pelteret,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot;, authored by Sven Wetterauer, University of Heidelberg, 2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step72</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblemParameters();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> tolerance = 1e-2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2));</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_unassisted();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_with_residual_linearization();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_using_energy_functional();</div><div class="line">    <span class="keywordtype">void</span>   solve();</div><div class="line">    <span class="keywordtype">void</span>   refine_mesh();</div><div class="line">    <span class="keywordtype">void</span>   set_boundary_values();</div><div class="line">    <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line">    Vector&lt;double&gt; newton_update;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(2)</div><div class="line">    , quadrature_formula(fe.degree + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                    ScratchData &amp;           scratch_data,</div><div class="line">                                    CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution,</div><div class="line">                                       old_solution_gradients);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                    old_solution_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                     * coeff                         <span class="comment">//   * a_n</span></div><div class="line">                     * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                    -                                <span class="comment">//  -</span></div><div class="line">                    (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                     * coeff * coeff * coeff         <span class="comment">//   * a_n^3</span></div><div class="line">                     * (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                        * old_solution_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                     * old_solution_gradients[q]))   <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// * dx</span></div><div class="line"></div><div class="line">              cell_rhs(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                              * coeff                     <span class="comment">// * a_n</span></div><div class="line">                              * old_solution_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                              * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// * dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,</div><div class="line">      <span class="keywordtype">double</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                           ScratchData &amp;           scratch_data,</div><div class="line">                                           CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell;</div><div class="line">      ADHelper ad_helper(n_independent_variables, n_dependent_variables);</div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">        ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">        dof_values_ad, old_solution_gradients);</div><div class="line"></div><div class="line">      std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables,</div><div class="line">                                            ADNumberType(0.0));</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> ADNumberType coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                    old_solution_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i</span></div><div class="line">                                 * coeff                      <span class="comment">// * a_n</span></div><div class="line">                                 * old_solution_gradients[q]) <span class="comment">// * u_n</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      ad_helper.register_residual_vector(residual_ad);</div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs);</div><div class="line">      cell_rhs *= -1.0;</div><div class="line"></div><div class="line">      ad_helper.compute_linearization(cell_matrix);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt;</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>,</div><div class="line">      <span class="keywordtype">double</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                           ScratchData &amp;           scratch_data,</div><div class="line">                                           CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">      ADHelper           ad_helper(n_independent_variables);</div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">        ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">        dof_values_ad, old_solution_gradients);</div><div class="line"></div><div class="line">      ADNumberType energy_ad = ADNumberType(0.0);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                                     old_solution_gradients[q]);</div><div class="line"></div><div class="line">          energy_ad += psi * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      ad_helper.register_energy_functional(energy_ad);</div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs);</div><div class="line">      cell_rhs *= -1.0;</div><div class="line"></div><div class="line">      ad_helper.compute_linearization(cell_matrix);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div><div class="line">                                 system_rhs.l2_norm() * 1e-6);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(newton_update);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length();</div><div class="line">    current_solution.add(alpha, newton_update);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = tmp;</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    evaluation_point = current_solution;</div><div class="line">    evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                   * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                   * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// * u_n</span></div><div class="line">                                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach ********&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = {</div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}};</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size());</div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*first time=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5;</div><div class="line">             ++inner_iteration)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (formulation == 0)</div><div class="line">                assemble_system_unassisted();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1)</div><div class="line">                assemble_system_with_residual_linearization();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2)</div><div class="line">                assemble_system_using_energy_functional();</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line"></div><div class="line">            last_residual_norm = system_rhs.l2_norm();</div><div class="line"></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">              solve();</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        ++refinement_cycle;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step72</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step72;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d;</div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation,</div><div class="line">                                     parameters.tolerance);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_71.html">step-71</a>, <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Motivation">Motivation</a>
        <li><a href="#ComputingtheJacobianfromtheresidual"> Computing the Jacobian from the residual </a>
        <li><a href="#ComputingtheJacobianandtheresidualfromtheenergyfunctional"> Computing the Jacobian and the residual from the energy functional </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemParameterscodeclass">The <code>MinimalSurfaceProblemParameters</code> class</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#MinimalSurfaceProblemMinimalSurfaceProblem">MinimalSurfaceProblem::MinimalSurfaceProblem</a>
        <li><a href="#MinimalSurfaceProblemsetup_system">MinimalSurfaceProblem::setup_system</a>
        <li><a href="#Assemblingthelinearsystem">Assembling the linear system</a>
      <ul>
        <li><a href="#Manualassembly">Manual assembly</a>
        <li><a href="#Assemblyviadifferentiationoftheresidualvector">Assembly via differentiation of the residual vector</a>
        <li><a href="#Assemblyviadifferentiationoftheenergyfunctional">Assembly via differentiation of the energy functional</a>
      </ul>
        <li><a href="#MinimalSurfaceProblemsolve">MinimalSurfaceProblem::solve</a>
        <li><a href="#MinimalSurfaceProblemrefine_mesh">MinimalSurfaceProblem::refine_mesh</a>
        <li><a href="#MinimalSurfaceProblemset_boundary_values">MinimalSurfaceProblem::set_boundary_values</a>
        <li><a href="#MinimalSurfaceProblemcompute_residual">MinimalSurfaceProblem::compute_residual</a>
        <li><a href="#MinimalSurfaceProblemdetermine_step_length">MinimalSurfaceProblem::determine_step_length</a>
        <li><a href="#MinimalSurfaceProblemoutput_results">MinimalSurfaceProblem::output_results</a>
        <li><a href="#MinimalSurfaceProblemrun">MinimalSurfaceProblem::run</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-72/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Jean-Paul Pelteret and Wolfgang Bangerth.</em></p>
<p><em>Wolfgang Bangerth's work is partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Motivation"></a></p><h3>Motivation</h3>
<p>这个程序解决的问题与步骤15相同，即求解<a href="https://en.wikipedia.org/wiki/Minimal_surface">最小表面方程</a> </p><p class="formulaDsp">
\begin{align*} F(u) \dealcoloneq -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p>我们在那里发现的问题（见<a href="step_15#extensions">Possibilities for extensions</a>部分）是，当想要使用牛顿迭代时，我们需要计算方程残差对解的导数 \(u\) （这里，因为右手边是零，残差只是左手边）。对于我们这里的方程来说，这很麻烦，但并非不可能 &ndash; 但我们很容易想象出更复杂的方程，仅仅正确实现残差本身就是一个挑战，更不用说为计算雅各布矩阵所需的导数而这样做。我们将在这个程序中解决这个问题。使用在步骤-71中详细讨论的自动微分技术，我们将想出一个办法，我们只需要实现残差，就可以免费得到雅各布矩阵。</p>
<p>事实上，我们甚至可以更进一步。虽然在第15步中，我们只是把方程作为一个给定值，但最小表面方程实际上是最小化一个能量的产物。具体来说，最小曲面方程是对应于最小化能量的欧拉-拉格朗日方程 </p><p class="formulaDsp">
\[ E(u) = \int_\Omega \Psi \left( u \right) \]
</p>
<p>其中*能量密度*由 </p><p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}}. \]
</p>
<p>给出。</p>
<p>这等于说，我们寻求找到能量函数变化的静止点 </p><p class="formulaDsp">
\[ \min\limits_{u} E \left( u \right) \quad \rightarrow \quad \delta E \left( u, \varphi \right) \dealcoloneq \left(\varphi, F(u)\right) = 0 \qquad \forall \varphi, \]
</p>
<p> 。</p>
<p>因为这是边界值问题的平衡解所在。</p>
<p>那么关键的一点是，也许，我们甚至不需要实现残差，但实现更简单的能量密度 \(\Psi(u)\) 可能实际上已经足够了。</p>
<p>那么我们的目标是这样的。当使用牛顿迭代时，我们需要反复解决线性偏微分方程 </p><p class="formulaDsp">
\begin{align*} F&#39;(u^{n},\delta u^{n}) &amp;=- F(u^{n}) \end{align*}
</p>
<p>。</p>
<p>这样我们就可以计算出更新 </p><p class="formulaDsp">
\begin{align*} u^{n+1}&amp;=u^{n}+\alpha^n \delta u^{n} \end{align*}
</p>
<p>。</p>
<p>与牛顿步骤的解 \(\delta u^{n}\) 。正如步骤15所讨论的，我们可以用手计算导数 \(F&#39;(u,\delta u)\) ，得到 </p><p class="formulaDsp">
\[ F&#39;(u,\delta u) = - \nabla \cdot \left( \frac{1}{\left(1+|\nabla u|^{2}\right)^{\frac{1}{2}}}\nabla \delta u \right) + \nabla \cdot \left( \frac{\nabla u \cdot \nabla \delta u}{\left(1+|\nabla u|^{2}\right)^{\frac{3}{2}}} \nabla u \right). \]
</p>
<p>。</p>
<p>那么，这里就是这个计划的内容。它是关于可以帮助我们计算 \(F&#39;(u,\delta u)\) 的技术，而不必明确地实现它，要么提供 \(F(u)\) 的实现，要么提供 \(E(u)\) 的实现。更确切地说，我们将实现三种不同的方法，并在运行时间方面进行比较，但同时&ndash;也许更重要的是&ndash;实现这些方法需要多少人力。</p>
<ul>
<li>第15步中使用的方法，形成雅各布矩阵。</li>
<li>从残差 \(F(u)\) 的实现中计算雅各布矩阵，使用自动微分法。</li>
<li>从能量函数 \(E(u)\) 的实现中计算残差和雅各布矩阵，也使用自动微分法。</li>
</ul>
<p>对于这些方法中的第一个，与步骤15相比，没有任何概念上的变化。</p>
<p><a class="anchor" id="ComputingtheJacobianfromtheresidual"></a></p><h3>Computing the Jacobian from the residual </h3>
<p>对于第二种方法，让我们概述一下我们将如何利用自动微分来计算残差向量的线性化。为此，让我们暂时改变一下符号，用 \(F(U)\) 表示的不是微分方程的残差，而实际上是*残差向量*，即*离散残差。我们这样做是因为当我们在给定的网格上对问题进行离散时，这就是我们*实际*做的事情。我们解决 \(F(U)=0\) 问题，其中 \(U\) 是未知数的矢量。</p>
<p>更准确地说，残差的 \(i\) th分量由以下公式给出</p>
<p class="formulaDsp">
\[ F(U)_i \dealcoloneq \int\limits_{\Omega}\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p>其中 \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) 。鉴于此，单元格 \(K\) 的贡献是</p>
<p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p>它的一阶泰勒展开为</p>
<p class="formulaDsp">
\[ F(U + \delta U)_i^K \approx F(U)_i^K + \sum_{j}^{n_{\textrm{dofs}}} \left[ \frac{\partial F(U)_i^K}{\partial U_j} \delta U_j \right], \]
</p>
<p>因此我们可以计算出 \(K\) 单元格对雅各布矩阵 \(J\) 的贡献为 \(J(U)_{ij}^K = \frac{\partial F(U)_i^K}{\partial U_j}\) 。这里重要的一点是，在单元格 \(K\) 上，我们可以表示为</p>
<p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+\left| \sum_{j&#39;}^{n_\textrm{dofs}} U_{j&#39;} \nabla \varphi_{j&#39;}\right|^{2}}} \left(\sum_{j&#39;&#39;}^{n_\textrm{dofs}} U_{j&#39;&#39;} \nabla \varphi_{j&#39;&#39;}\right)\right] \, dV. \]
</p>
<p>为了清楚起见，我们用 \(j&#39;\) 和 \(j&#39;&#39;\) 作为计数索引，以明确它们彼此之间以及与上述 \(j\) 的区别。因为在这个公式中， \(F(U)\) 只取决于系数 \(U_j\) ，我们可以通过自动微分 \(F(U)_i^K\) 来计算导数 \(J(U)_{ij}^K\) 作为一个矩阵。通过我们一直使用的相同论证，很明显 \(F(U)^K\) 实际上并不依赖于*所有*未知数 \(U_j\) ，而只是依赖于 \(j\) 是住在单元格 \(K\) 的形状函数的那些未知数。] ，因此在实践中，我们将 \(F(U)^K\) 和 \(J(U)^K\) 限制为矢量和矩阵中对应于*本地*DoF指数的部分，然后从本地单元 \(K\) 分布到全球对象。</p>
<p>使用所有这些实现，然后的方法将是在程序中实现 \(F(U)^K\) ，并让自动微分机械从中计算导数 \(J(U)^K\) 。</p>
<p><a class="anchor" id="ComputingtheJacobianandtheresidualfromtheenergyfunctional"></a></p><h3>Computing the Jacobian and the residual from the energy functional </h3>
<p>对于装配过程的最终实现，我们将比残差高一个层次：我们的整个线性系统将直接由支配这个边界值问题的物理学的能量函数决定。我们可以利用这样一个事实：我们可以直接从局部贡献中计算出域中的总能量，即。</p>
<p class="formulaDsp">
\[ E \left( U \right) \dealcoloneq \int\limits_{\Omega} \Psi \left( u \right) \, dV . \]
</p>
<p>在离散设置中，这意味着在每个有限元上我们有</p>
<p class="formulaDsp">
\[ E \left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{x}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} . \]
</p>
<p>如果我们实现细胞能量，它取决于场解，我们可以计算它的第一个（离散）变化</p>
<p class="formulaDsp">
\[ F(U)^K_i = \frac{\partial E(U)^K}{\partial U_i} \]
</p>
<p>此后，它的第二个（离散）变化</p>
<p class="formulaDsp">
\[ J(U)^K_{ij} = \frac{\partial^{2} E(U)^K}{\partial U_i \partial U_j}. \]
</p>
<p>因此，从单元格对总能量函数的贡献来看，只要我们能够提供局部能量的实现，我们就可以期望为我们生成近似的残差和正切贡献 \(E(U)^K\) 。同样，由于本教程中使用的自动微分变量的设计，在实践中，这些对残差向量和正切矩阵贡献的近似值实际上是精确到机器精度的。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The majority of this tutorial is an exact replica of <a class="el" href="step_15.html">step-15</a>. So, in the interest of brevity and maintaining a focus on the changes implemented here, we will only document what's new and simply indicate which sections of code are a repetition of what has come before.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>There are a few new header files that have been included in this tutorial. The first is the one that provides the declaration of the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>This is the second, which is an all-inclusive header that will allow us to incorporate the automatic differentiation (AD) functionality within this code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>And the next three provide some multi-threading capability using the generic <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> framework.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>We then open a namespace for this program and import everything from the dealii namespace into it, as in previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step72</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemParameterscodeclass"></a> </p><h3>The <code>MinimalSurfaceProblemParameters</code> class</h3>
<p>In this tutorial we will implement three different approaches for assembling the linear system. One mirrors the hand implementation originally provided in <a class="el" href="step_15.html">step-15</a>, while the other two use the Sacado automatic differentiation library that is provided as a part of the Trilinos framework.</p>
<p>To facilitate switching between the three implementations, we have this really basic parameters class that has only two options that are configurable.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblemParameters();</div></div><!-- fragment --><p>Selection for the formulation and corresponding AD framework to be used:</p><ul>
<li>formulation = 0 : Unassisted implementation (full hand linearization).</li>
<li>formulation = 1 : Automated linearization of the finite element residual.</li>
<li>formulation = 2 : Automated computation of finite element residual and linearization using a variational formulation.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0;</div></div><!-- fragment --><p>The maximum acceptable tolerance for the linear system residual. We will see that the assembly time becomes appreciable once we use the AD framework, so we have increased the tolerance selected in <a class="el" href="step_15.html">step-15</a> by one order of magnitude. This way, the computations do not take too long to complete.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> tolerance = 1e-2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2));</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>The class template is essentially the same as in <a class="el" href="step_15.html">step-15</a>. The only functional changes to the class are that:</p><ul>
<li>the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function now takes in two arguments: one to choose which assembly approach is to be adopted, and one for the tolerance for the permissible final residual is, and</li>
<li>there are now three different assembly functions that implement the three methods of assembling the linear system. We'll provide details on these later on.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_unassisted();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_with_residual_linearization();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system_using_energy_functional();</div><div class="line">  <span class="keywordtype">void</span>   solve();</div><div class="line">  <span class="keywordtype">void</span>   refine_mesh();</div><div class="line">  <span class="keywordtype">void</span>   set_boundary_values();</div><div class="line">  <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line">  Vector&lt;double&gt; newton_update;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>There are no changes to the boundary conditions applied to the problem.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<p><a class="anchor" id="MinimalSurfaceProblemMinimalSurfaceProblem"></a> </p><h4>MinimalSurfaceProblem::MinimalSurfaceProblem</h4>
<p>There have been no changes made to the class constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(2)</div><div class="line">  , quadrature_formula(fe.degree + 1)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsetup_system"></a> </p><h4>MinimalSurfaceProblem::setup_system</h4>
<p>There have been no changes made to the function that sets up the class data structures, namely the <a class="el" href="classDoFHandler.html">DoFHandler</a>, the hanging node constraints applied to the problem, and the linear system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblingthelinearsystem"></a> </p><h4>Assembling the linear system</h4>
<p><a class="anchor" id="Manualassembly"></a> </p><h5>Manual assembly</h5>
<p>The assembly functions are the interesting contributions to this tutorial. The assemble_system_unassisted() method implements exactly the same assembly function as is detailed in <a class="el" href="step_15.html">step-15</a>, but in this instance we use the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function to multithread the assembly process. The reason for doing this is quite simple: When using automatic differentiation, we know that there is to be some additional computational overhead incurred. In order to mitigate this performance loss, we'd like to take advantage of as many (easily available) computational resources as possible. The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> concept makes this a relatively straightforward task. At the same time, for the purposes of fair comparison, we need to do the same to the implementation that uses no assistance when computing the residual or its linearization. (The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function is first discussed in <a class="el" href="step_12.html">step-12</a> and <a class="el" href="step_16.html">step-16</a>, if you'd like to read up on it.)</p>
<p>The steps required to implement the multithreading are the same between the three functions, so we'll use the assemble_system_unassisted() function as an opportunity to focus on the multithreading itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div></div><!-- fragment --><p>The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> expects that we provide two exemplar data structures. The first, <code>ScratchData</code>, is to store all large data that is to be reused between threads. The <code>CopyData</code> will hold the contributions to the linear system that come from each cell. These independent matrix-vector pairs must be accumulated into the global linear system sequentially. Since we don't need anything on top of what the <a class="el" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData</a> and <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> classes already provide, we use these exact class definitions for our problem. Note that we only require a single instance of a local matrix, local right-hand side vector, and cell degree of freedom index vector &ndash; the <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> therefore has <code>1</code> for all three of its template arguments.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line"><span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div></div><!-- fragment --><p>We also need to know what type of iterator we'll be working with during assembly. For simplicity, we just ask the compiler to work this out for us using the decltype() specifier, knowing that we'll be iterating over active cells owned by the <code>dof_handler</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div></div><!-- fragment --><p>Here we initialize the exemplar data structures. Since we know that we need to compute the shape function gradients, weighted Jacobian, and the position of the quadrate points in real space, we pass these flags into the class constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"><span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>Now we define a lambda function that will perform the assembly on a single cell. The three arguments are those that will be expected by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>, due to the arguments that we'll pass to that final call. We also capture the <code>this</code> pointer, which means that we'll have access to "this" (i.e., the current <code>MinimalSurfaceProblem&lt;dim&gt;</code>) class instance, and its private member data (since the lambda function is defined within a MinimalSurfaceProblem&lt;dim&gt; method).</p>
<p>At the top of the function, we initialize the data structures that are dependent on the cell for which the work is being performed. Observe that the reinitialization call actually returns an instance to an <a class="el" href="classFEValues.html">FEValues</a> object that is initialized and stored within (and, therefore, reused by) the <code>scratch_data</code> object.</p>
<p>Similarly, we get aliases to the local matrix, local RHS vector, and local cell DoF indices from the <code>copy_data</code> instance that <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> provides. We then initialize the cell DoF indices, knowing that the local matrix and vector are already correctly sized.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                ScratchData &amp;           scratch_data,</div><div class="line">                                CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>For Newton's method, we require the gradient of the solution at the point about which the problem is being linearized.</p>
<p>Once we have that, we can perform assembly for this cell in the usual way. One minor difference to <a class="el" href="step_15.html">step-15</a> is that we've used the (rather convenient) range-based loops to iterate over all quadrature points and degrees-of-freedom.</p>
<div class="fragment"><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients(</div><div class="line">    fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution,</div><div class="line">                                   old_solution_gradients);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">        1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                old_solution_gradients[q]);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">              (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                 * coeff                         <span class="comment">//   * a_n</span></div><div class="line">                 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                -                                <span class="comment">//  -</span></div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                 * coeff * coeff * coeff         <span class="comment">//   * a_n^3</span></div><div class="line">                 * (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                    * old_solution_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                 * old_solution_gradients[q]))   <span class="comment">//   * \nabla u_n)))</span></div><div class="line">               * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// * dx</span></div><div class="line"></div><div class="line">          cell_rhs(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                          * coeff                     <span class="comment">// * a_n</span></div><div class="line">                          * old_solution_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                          * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The second lambda function that <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> requires is one that performs the task of accumulating the local contributions in the global linear system. That is precisely what this one does, and the details of the implementation have been seen before. The primary point to recognize is that the local contributions are stored in the <code>copy_data</code> instance that is passed into this function. This <code>copy_data</code> has been filled with data during <em>some</em> call to the <code>cell_worker</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        system_matrix.add(local_dof_indices[i],</div><div class="line">                          local_dof_indices[j],</div><div class="line">                          cell_matrix(i, j));</div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>We have all of the required functions definitions in place, so now we call the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to perform the actual assembly. We pass a flag as the last parameter which states that we only want to perform the assembly on the cells. Internally, <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> then distributes the available work to different threads, making efficient use of the multiple cores almost all of today's processors have to offer.</p>
<div class="fragment"><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                      cell_worker,</div><div class="line">                      copier,</div><div class="line">                      sample_scratch_data,</div><div class="line">                      sample_copy_data,</div><div class="line">                      <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --><p>And finally, as is done in <a class="el" href="step_15.html">step-15</a>, we remove hanging nodes from the system and apply zero boundary values to the linear system that defines the Newton updates \(\delta u^n\).</p>
<div class="fragment"><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheresidualvector"></a> </p><h5>Assembly via differentiation of the residual vector</h5>
<p>As outlined in the introduction, what we need to do for this second approach is implement the local contributions \(F(U)^K\) from cell \(K\) to the residual vector, and then let the AD machinery deal with how to compute the derivatives \(J(U)_{ij}^K=\frac{\partial F(U)^K_i}{\partial U_j}\) from it.</p>
<p>For the following, recall that </p><p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p> where \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\).</p>
<p>Let us see how this is implemented in practice:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>We'll define up front the AD data structures that we'll be using, utilizing the techniques shown in <a class="el" href="step_71.html">step-71</a>. In this case, we choose the helper class that will automatically compute the linearization of the finite element residual using Sacado forward automatic differentiation types. These number types can be used to compute first derivatives only. This is exactly what we want, because we know that we'll only be linearizing the residual, which means that we only need to compute first-order derivatives. The return values from the calculations are to be of type <code>double</code>.</p>
<p>We also need an extractor to retrieve some data related to the field solution to the problem.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,</div><div class="line">  <span class="keywordtype">double</span>&gt;;</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div></div><!-- fragment --><p>With this, let us define the lambda function that will be used to compute the cell contributions to the Jacobian matrix and the right hand side:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                       ScratchData &amp;           scratch_data,</div><div class="line">                                       CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>We'll now create and initialize an instance of the AD helper class. To do this, we need to specify how many independent variables and dependent variables there are. The independent variables will be the number of local degrees of freedom that our solution vector has, i.e., the number \(j\) in the per-element representation of the discretized solution vector \(u (\mathbf{x})|_K = \sum\limits_{j} U^K_i \varphi_j(\mathbf{x})\) that indicates how many solution coefficients are associated with each finite element. In deal.II, this equals <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">FiniteElement::dofs_per_cell</a>. The number of dependent variables will be the number of entries in the local residual vector that we will be forming. In this particular problem (like many others that employ the <a href="https://en.wikipedia.org/wiki/Galerkin_method">standard Galerkin method</a>) the number of local solution coefficients matches the number of local residual equations.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell;</div><div class="line">ADHelper ad_helper(n_independent_variables, n_dependent_variables);</div></div><!-- fragment --><p>Next we inform the helper of the values of the solution, i.e., the actual values for \(U_j\) about which we wish to linearize. As this is done on each element individually, we have to extract the solution coefficients from the global solution vector. In other words, we define all of those coefficients \(U_j\) where \(j\) is a local degree of freedom as the independent variables that enter the computation of the vector \(F(U)^{K}\) (the dependent function).</p>
<p>Then we get the complete set of degree of freedom values as represented by auto-differentiable numbers. The operations performed with these variables are tracked by the AD library from this point until the object goes out of scope. So it is <em>precisely these variables</em> with respect to which we will compute derivatives of the residual entries.</p>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">  ad_helper.get_sensitive_dof_values();</div></div><!-- fragment --><p>Then we do some problem specific tasks, the first being to compute all values, (spatial) gradients, and the like based on "sensitive" AD degree of freedom values. In this instance we are retrieving the solution gradients at each quadrature point. Observe that the solution gradients are now sensitive to the values of the degrees of freedom as they use the <code>ADNumberType</code> as the scalar type and the <code>dof_values_ad</code> vector provides the local DoF values.</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">  dof_values_ad, old_solution_gradients);</div></div><!-- fragment --><p>The next variable that we declare will store the cell residual vector contributions. This is rather self-explanatory, save for one <b>very important</b> detail: Note that each entry in the vector is hand-initialized with a value of zero. This is a <em>highly recommended</em> practice, as some AD libraries appear not to safely initialize the internal data structures of these number types. Not doing so could lead to some very hard to understand or detect bugs (appreciate that the author of this program mentions this out of, generally bad, experience). So out of an abundance of caution it's worthwhile zeroing the initial value explicitly. After that, apart from a sign change the residual assembly looks much the same as we saw for the cell RHS vector before: We loop over all quadrature points, ensure that the coefficient now encodes its dependence on the (sensitive) finite element DoF values by using the correct <code>ADNumberType</code>, and finally we assemble the components of the residual vector. For complete clarity, the finite element shape functions (and their gradients, etc.) as well as the "JxW" values remain scalar valued, but the <code>coeff</code> and the <code>old_solution_gradients</code> at each quadrature point are computed in terms of the independent variables.</p>
<div class="fragment"><div class="line">std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables,</div><div class="line">                                      ADNumberType(0.0));</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> ADNumberType coeff =</div><div class="line">      1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                              old_solution_gradients[q]);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">      {</div><div class="line">        residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i</span></div><div class="line">                           * coeff                      <span class="comment">// * a_n</span></div><div class="line">                           * old_solution_gradients[q]) <span class="comment">// * u_n</span></div><div class="line">                          * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx</span></div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Once we have the full cell residual vector computed, we can register it with the helper class.</p>
<p>Thereafter, we compute the residual values (basically, extracting the real values from what we already computed) and their Jacobian (the linearization of each residual component with respect to all cell DoFs) at the evaluation point. For the purposes of assembly into the global linear system, we have to respect the sign difference between the residual and the RHS contribution: For Newton's method, the right hand side vector needs to be equal to the <em>negative</em> residual vector.</p>
<div class="fragment"><div class="line">  ad_helper.register_residual_vector(residual_ad);</div><div class="line"></div><div class="line">  ad_helper.compute_residual(cell_rhs);</div><div class="line">  cell_rhs *= -1.0;</div><div class="line"></div><div class="line">  ad_helper.compute_linearization(cell_matrix);</div><div class="line">};</div></div><!-- fragment --><p>The remainder of the function equals what we had previously:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">      copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        sample_scratch_data,</div><div class="line">                        sample_copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheenergyfunctional"></a> </p><h5>Assembly via differentiation of the energy functional</h5>
<p>In this third approach, we compute residual and Jacobian as first and second derivatives of the local energy functional </p><p class="formulaDsp">
\[ E\left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{X}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} \]
</p>
<p> with the energy density given by </p><p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}} . \]
</p>
<p>Let us again see how this is done:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div></div><!-- fragment --><p>In this implementation of the assembly process, we choose the helper class that will automatically compute both the residual and its linearization from the cell contribution to an energy functional using nested Sacado forward automatic differentiation types. The selected number types can be used to compute both first and second derivatives. We require this, as the residual defined as the sensitivity of the potential energy with respect to the DoF values (i.e. its gradient). We'll then need to linearize the residual, implying that second derivatives of the potential energy must be computed. You might want to compare this with the definition of <code>ADHelper</code> used int previous function, where we used <code><a class="el" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;<a class="el" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,double&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt;</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>,</div><div class="line">  <span class="keywordtype">double</span>&gt;;</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div></div><!-- fragment --><p>Let us then again define the lambda function that does the integration on a cell.</p>
<p>To initialize an instance of the helper class, we now only require that the number of independent variables (that is, the number of degrees of freedom associated with the element solution vector) are known up front. This is because the second-derivative matrix that results from an energy functional is necessarily square (and also, incidentally, symmetric).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                       ScratchData &amp;           scratch_data,</div><div class="line">                                       CopyData &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">    copy_data.local_dof_indices[0];</div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">  ADHelper           ad_helper(n_independent_variables);</div></div><!-- fragment --><p>Once more, we register all cell DoFs values with the helper, followed by extracting the "sensitive" variant of these values that are to be used in subsequent operations that must be differentiated &ndash; one of those being the calculation of the solution gradients.</p>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">  ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">  dof_values_ad, old_solution_gradients);</div></div><!-- fragment --><p>We next create a variable that stores the cell total energy. Once more we emphasize that we explicitly zero-initialize this value, thereby ensuring the integrity of the data for this starting value.</p>
<p>The aim for our approach is then to compute the cell total energy, which is the sum of the internal (due to right hand side functions, typically linear in \(U\)) and external energies. In this particular case, we have no external energies (e.g., from source terms or Neumann boundary conditions), so we'll focus on the internal energy part.</p>
<p>In fact, computing \(E(U)^K\) is almost trivial, requiring only the following lines:</p>
<div class="fragment"><div class="line">ADNumberType energy_ad = ADNumberType(0.0);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                               old_solution_gradients[q]);</div><div class="line"></div><div class="line">    energy_ad += psi * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">  }</div></div><!-- fragment --><p>After we've computed the total energy on this cell, we'll register it with the helper. Based on that, we may now compute the desired quantities, namely the residual values and their Jacobian at the evaluation point. As before, the Newton right hand side needs to be the negative of the residual:</p>
<div class="fragment"><div class="line">  ad_helper.register_energy_functional(energy_ad);</div><div class="line"></div><div class="line">  ad_helper.compute_residual(cell_rhs);</div><div class="line">  cell_rhs *= -1.0;</div><div class="line"></div><div class="line">  ad_helper.compute_linearization(cell_matrix);</div><div class="line">};</div></div><!-- fragment --><p>As in the previous two functions, the remainder of the function is as before:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">      copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        sample_scratch_data,</div><div class="line">                        sample_copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix);</div><div class="line">  hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     newton_update,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsolve"></a> </p><h4>MinimalSurfaceProblem::solve</h4>
<p>The solve function is the same as is used in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div><div class="line">                               system_rhs.l2_norm() * 1e-6);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(newton_update);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length();</div><div class="line">  current_solution.add(alpha, newton_update);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrefine_mesh"></a> </p><h4>MinimalSurfaceProblem::refine_mesh</h4>
<p>Nothing has changed since <a class="el" href="step_15.html">step-15</a> with respect to the mesh refinement procedure and transfer of the solution between adapted meshes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    current_solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line"></div><div class="line">  triangulation.prepare_coarsening_and_refinement();</div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_transfer.interpolate(current_solution, tmp);</div><div class="line">  current_solution = tmp;</div><div class="line"></div><div class="line">  hanging_node_constraints.clear();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                          hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close();</div><div class="line"></div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  setup_system(<span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemset_boundary_values"></a> </p><h4>MinimalSurfaceProblem::set_boundary_values</h4>
<p>The choice of boundary conditions remains identical to <a class="el" href="step_15.html">step-15</a>...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">{</div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">    current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemcompute_residual"></a> </p><h4>MinimalSurfaceProblem::compute_residual</h4>
<p>... as does the function used to compute the residual during the solution iteration procedure. One could replace this by differentiation of the energy functional if one really wanted, but for simplicity we here simply copy what we already had in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  evaluation_point = current_solution;</div><div class="line">  evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                 * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                 * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// * u_n</span></div><div class="line">                                 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemdetermine_step_length"></a> </p><h4>MinimalSurfaceProblem::determine_step_length</h4>
<p>The choice of step length (or, under-relaxation factor) for the nonlinear iterations procedure remains fixed at the value chosen and discussed in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0.1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemoutput_results"></a> </p><h4>MinimalSurfaceProblem::output_results</h4>
<p>This last function to be called from <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> outputs the current solution (and the Newton update) in graphical form as a VTU file. It is entirely the same as what has been used in previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrun"></a> </p><h4>MinimalSurfaceProblem::run</h4>
<p>In the run function, most remains the same as was first implemented in <a class="el" href="step_15.html">step-15</a>. The only observable changes are that we can now choose (via the parameter file) what the final acceptable tolerance for the system residual is, and that we can choose which method of assembly we wish to utilize. To make the second choice clear, we output to the console some message which indicates the selection. Since we're interested in comparing the time taken to assemble for each of the three methods, we've also added a timer that keeps a track of how much time is spent during assembly. We also track the time taken to solve the linear system, so that we can contrast those numbers to the part of the code which would normally take the longest time to execute.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach ********&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = {</div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}};</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size());</div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*first time=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5;</div><div class="line">             ++inner_iteration)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (formulation == 0)</div><div class="line">                assemble_system_unassisted();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1)</div><div class="line">                assemble_system_with_residual_linearization();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2)</div><div class="line">                assemble_system_using_energy_functional();</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line"></div><div class="line">            last_residual_norm = system_rhs.l2_norm();</div><div class="line"></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">              solve();</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        ++refinement_cycle;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step72</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main function</h4>
<p>Finally the main function. This follows the scheme of most other main functions, with two obvious exceptions:</p><ul>
<li>We call <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> in order to set up (via a hidden default parameter) the number of threads using the execution of multithreaded tasks.</li>
<li>We also have a few lines dedicates to reading in or initializing the user-defined parameters that will be considered during the execution of the program.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step72;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d;</div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation,</div><div class="line">                                     parameters.tolerance);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-72/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>由于在步骤15中首先分析的问题的物理学没有变化，所以没有什么可报告的。它们之间唯一外显的区别是，在默认情况下，这个程序只运行9个网格细化步骤（相对于第15步，执行11个细化）。这可以从模拟状态中观察到，该状态出现在打印出正在使用的装配方法的标题文本和最终的时间。下面报告的所有时间都是在发布模式下获得的）。</p>
<div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Initial residual: 1.53143</div><div class="line">  Residual: 1.08746</div><div class="line">  Residual: 0.966748</div><div class="line">  Residual: 0.859602</div><div class="line">  Residual: 0.766462</div><div class="line">  Residual: 0.685475</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">Mesh refinement step 9</div><div class="line">  Initial residual: 0.00924594</div><div class="line">  Residual: 0.00831928</div><div class="line">  Residual: 0.0074859</div><div class="line">  Residual: 0.0067363</div><div class="line">  Residual: 0.00606197</div><div class="line">  Residual: 0.00545529</div></div><!-- fragment --><p>因此，我们感兴趣的是比较三种不同实现方式的装配过程需要多长时间，并把它放到更大的背景中。下面是手部线性化的输出结果（在2012年左右的四核八线程笔记本电脑上计算的结果&ndash;但我们真正感兴趣的只是不同实现方式之间的相对时间）。</p>
<div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Unassisted implementation (full hand linearization).</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      35.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      1.56s |       4.5% |</div><div class="line">| Solve                           |        50 |      30.8s |        88% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>而对于使用萨卡多动态正向AD数字类型，以自动方式将残差线性化的实施。</p>
<div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Automated linearization of the finite element residual.</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      40.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |       8.8s |        22% |</div><div class="line">| Solve                           |        50 |      28.6s |        71% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>最后，对于直接从能量函数（使用嵌套的Sacado动态前向AD数）计算残差和其线性化的实现。</p>
<div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Automated computation of finite element residual and linearization <span class="keyword">using</span> a variational formulation.</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      48.8s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      16.7s |        34% |</div><div class="line">| Solve                           |        50 |      29.3s |        60% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>很明显，交给自动分化框架执行的工作越多，在装配过程中花费的时间就越多。在所有细化步骤中累积起来，与无辅助装配相比，使用一级自动微分导致在装配阶段花费了 \(5.65 \times\) 的计算时间，而直接从能量函数推导时，装配离散线性系统花费了 \(10.7 \times\) 的时间。不足为奇的是，解决线性系统的总体时间保持不变。这意味着，随着在有限元水平上进行自动微分的次数的增加，花在求解阶段的时间与装配阶段的时间比例发生了明显的转变。对许多人来说，这可能意味着在生产代码中利用高阶微分（在有限元水平）会导致不可接受的开销，但在原型设计阶段，它可能仍然有用。因此，两者之间的一个很好的折衷办法是有限元残差的自动线性化，它以可衡量的、但也许不是不可接受的成本提供了很多便利。另外，我们可以考虑不在每一步中重新建立牛顿矩阵&ndash;这个主题在步骤77中有大量的深入探讨。</p>
<p>当然，在实践中，实际的开销在很大程度上取决于被评估的问题（例如，解决方案中有多少成分，被微分的函数的性质是什么，等等）。因此，这里提出的确切结果应该仅在这个标量问题的背景下进行解释，当涉及到其他问题时，用户肯定需要进行一些初步调查。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>与步骤-71一样，有几个与自动区分有关的项目可以进一步评估。</p>
<ul>
<li>应调查其他AD框架的使用情况，并展望其他实施方式可能提供性能优势。</li>
<li>除了本教程中硬编码的数字类型外，还值得对AD数字类型进行评估。关于在有限元水平上采用的两次微分类型，混合微分模式（"RAD-FAD"）原则上应该比这里采用的单一模式（"FAD-FAD"）类型的计算效率更高。RAD-FAD类型没有被默认选择的原因是，在撰写本文时，在Sacado库中，它的实现仍然存在一些错误，导致内存泄漏。 这在 <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> 模块中有所记载。</li>
<li>也许使用低精度类型（即 "浮动"）作为AD数字的标量类型可以减少装配时的计算费用。使用 "float "作为矩阵和残差的数据类型并不是不合理的，因为牛顿更新只是为了让我们更接近解决方案，而不是实际*到解决方案；因此，考虑使用降低精度的数据类型来计算这些更新，然后将这些更新累积到使用全 "双 "精度的解决方案向量中，是有意义的。</li>
<li>在装配过程中可能减少资源的另一个方法是将AD的实现作为一个构成模型。这类似于步骤71中采用的方法，并将自动微分的起点推到了计算链的上一级。这反过来意味着AD库跟踪的操作更少，从而降低了微分的成本（尽管我们会在每个单元的正交点进行微分）。</li>
<li>第77步是第15步的另一个变化，解决了问题的一个非常不同的部分：直线搜索以及是否有必要在每次非线性迭代中重新建立牛顿矩阵。鉴于上述结果表明，使用自动微分是有代价的，第77步的技术有可能在一定程度上抵消这些代价。因此，将目前的程序与第77步中的技术结合起来是相当有趣的。对于生产代码来说，这肯定是个好办法。</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Jean-Paul Pelteret,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot;, authored by Sven Wetterauer, University of Heidelberg, 2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step72</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblemParameters();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> tolerance = 1e-2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2));</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_unassisted();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_with_residual_linearization();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system_using_energy_functional();</div><div class="line">    <span class="keywordtype">void</span>   solve();</div><div class="line">    <span class="keywordtype">void</span>   refine_mesh();</div><div class="line">    <span class="keywordtype">void</span>   set_boundary_values();</div><div class="line">    <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line">    Vector&lt;double&gt; newton_update;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(2)</div><div class="line">    , quadrature_formula(fe.degree + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                    ScratchData &amp;           scratch_data,</div><div class="line">                                    CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution,</div><div class="line">                                       old_solution_gradients);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                    old_solution_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                     * coeff                         <span class="comment">//   * a_n</span></div><div class="line">                     * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                    -                                <span class="comment">//  -</span></div><div class="line">                    (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                     * coeff * coeff * coeff         <span class="comment">//   * a_n^3</span></div><div class="line">                     * (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                        * old_solution_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                     * old_solution_gradients[q]))   <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// * dx</span></div><div class="line"></div><div class="line">              cell_rhs(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                              * coeff                     <span class="comment">// * a_n</span></div><div class="line">                              * old_solution_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                              * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// * dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,</div><div class="line">      <span class="keywordtype">double</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                           ScratchData &amp;           scratch_data,</div><div class="line">                                           CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell;</div><div class="line">      ADHelper ad_helper(n_independent_variables, n_dependent_variables);</div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">        ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">        dof_values_ad, old_solution_gradients);</div><div class="line"></div><div class="line">      std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables,</div><div class="line">                                            ADNumberType(0.0));</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> ADNumberType coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                    old_solution_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            {</div><div class="line">              residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i</span></div><div class="line">                                 * coeff                      <span class="comment">// * a_n</span></div><div class="line">                                 * old_solution_gradients[q]) <span class="comment">// * u_n</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      ad_helper.register_residual_vector(residual_ad);</div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs);</div><div class="line">      cell_rhs *= -1.0;</div><div class="line"></div><div class="line">      ad_helper.compute_linearization(cell_matrix);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line">                                          quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt;</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>,</div><div class="line">      <span class="keywordtype">double</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">                                           ScratchData &amp;           scratch_data,</div><div class="line">                                           CopyData &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line">      ADHelper           ad_helper(n_independent_variables);</div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line">        ad_helper.get_sensitive_dof_values();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line">        dof_values_ad, old_solution_gradients);</div><div class="line"></div><div class="line">      ADNumberType energy_ad = ADNumberType(0.0);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] *</div><div class="line">                                                     old_solution_gradients[q]);</div><div class="line"></div><div class="line">          energy_ad += psi * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      ad_helper.register_energy_functional(energy_ad);</div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs);</div><div class="line">      cell_rhs *= -1.0;</div><div class="line"></div><div class="line">      ad_helper.compute_linearization(cell_matrix);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line">        copy_data.local_dof_indices[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          sample_scratch_data,</div><div class="line">                          sample_copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix);</div><div class="line">    hanging_node_constraints.condense(system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       newton_update,</div><div class="line">                                       system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div><div class="line">                                 system_rhs.l2_norm() * 1e-6);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(newton_update);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length();</div><div class="line">    current_solution.add(alpha, newton_update);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = tmp;</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    evaluation_point = current_solution;</div><div class="line">    evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                   * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                   * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// * u_n</span></div><div class="line">                                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach ********&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = {</div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>,</div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}};</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size());</div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*first time=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5;</div><div class="line">             ++inner_iteration)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (formulation == 0)</div><div class="line">                assemble_system_unassisted();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1)</div><div class="line">                assemble_system_with_residual_linearization();</div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2)</div><div class="line">                assemble_system_using_energy_functional();</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line"></div><div class="line">            last_residual_norm = system_rhs.l2_norm();</div><div class="line"></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">              solve();</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        ++refinement_cycle;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step72</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step72;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d;</div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation,</div><div class="line">                                     parameters.tolerance);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
