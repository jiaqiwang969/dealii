<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_51.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-51 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-51 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>, <a class="el" href="step_9.html">step-9</a>, <a class="el" href="step_61.html">step-61</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HybridizablediscontinuousGalerkinmethods"> Hybridizable discontinuous Galerkin methods </a>
      <ul>
        <li><a href="#Reducingthesizeofthelinearsystem"> Reducing the size of the linear system </a>
        <li><a href="#RelationwithStaticCondensation"> Relation with Static Condensation </a>
        <li><a href="#Solutionqualityandratesofconvergence"> Solution quality and rates of convergence</a>
        <li><a href="#Alternativeapproaches"> Alternative approaches </a>
      </ul>
        <li><a href="#HDGappliedtotheconvectiondiffusionproblem"> HDG applied to the convection-diffusion problem </a>
      <ul>
        <li><a href="#Postprocessingandsuperconvergence"> Post-processing and super-convergence </a>
      </ul>
        <li><a href="#Problemspecificdata"> Problem specific data </a>
        <li><a href="#Implementation"> Implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheHDGsolverclass">The HDG solver class</a>
        <li><a href="#TheHDGclassimplementation">The HDG class implementation</a>
      <ul>
        <li><a href="#Constructor">Constructor</a>
        <li><a href="#HDGsetup_system">HDG::setup_system</a>
        <li><a href="#HDGPerTaskData">HDG::PerTaskData</a>
        <li><a href="#HDGScratchData">HDG::ScratchData</a>
        <li><a href="#HDGPostProcessScratchData">HDG::PostProcessScratchData</a>
        <li><a href="#HDGassemble_system">HDG::assemble_system</a>
        <li><a href="#HDGassemble_system_one_cell">HDG::assemble_system_one_cell</a>
        <li><a href="#HDGcopy_local_to_global">HDG::copy_local_to_global</a>
        <li><a href="#HDGsolve">HDG::solve</a>
        <li><a href="#HDGpostprocess">HDG::postprocess</a>
        <li><a href="#HDGpostprocess_one_cell">HDG::postprocess_one_cell</a>
        <li><a href="#HDGoutput_results">HDG::output_results</a>
        <li><a href="#HDGrefine_grid">HDG::refine_grid</a>
        <li><a href="#HDGrun">HDG::run</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
      <ul>
        <li><a href="#Convergencetables">Convergence tables</a>
      </ul>
        <li><a href="#Comparisonwithcontinuousfiniteelements">Comparison with continuous finite elements</a>
      <ul>
        <li><a href="#Resultsfor2D">Results for 2D</a>
        <li><a href="#Resultsfor3D">Results for 3D</a>
      </ul>
        <li><a href="#Possibilitiesforimprovements">Possibilities for improvements</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Martin Kronbichler and Scott Miller. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program presents the implementation of a hybridizable discontinuous Galkerin method for the convection-diffusion equation.</p>
<p><a class="anchor" id="HybridizablediscontinuousGalerkinmethods"></a></p><h3>Hybridizable discontinuous Galerkin methods </h3>
<p>One common argument against the use of discontinuous Galerkin elements is the large number of globally coupled degrees of freedom that one must solve in an implicit system. This is because, unlike continuous finite elements, in typical discontinuous elements there is one degree of freedom at each vertex <em>for each of the adjacent elements</em>, rather than just one, and similarly for edges and faces. As an example of how fast the number of unknowns grows, consider the <a class="el" href="classFE__DGPMonomial.html">FE_DGPMonomial</a> basis: each scalar solution component is represented by polynomials of degree \(p\) with \((1/\text{dim}!) \prod_{i=1}^{\text{dim}}(p+i)\) degrees of freedom per element. Typically, all degrees of freedom in an element are coupled to all of the degrees of freedom in the adjacent elements. The resulting discrete equations yield very large linear systems very quickly, especially for systems of equations in 2 or 3 dimensions.</p>
<p><a class="anchor" id="Reducingthesizeofthelinearsystem"></a></p><h4>Reducing the size of the linear system </h4>
<p>To alleviate the computational cost of solving such large linear systems, the hybridizable discontinuous Galerkin (HDG) methodology was introduced by Cockburn and co-workers (see the references in the recent HDG overview article by Nguyen and Peraire <b>[Ngu2012]</b>).</p>
<p>The HDG method achieves this goal by formulating the mathematical problem using Dirichlet-to-Neumann mappings. The partial differential equations are first written as a first order system, and each field is then discretized via a DG method. At this point, the single-valued "trace" values on the skeleton of the mesh, i.e., element faces, are taken to be independent unknown quantities. This yields unknowns in the discrete formulation that fall into two categories:</p><ul>
<li>Face unknowns that only couple with the cell unknowns from both sides of the face;</li>
<li>Cell unknowns that only couple with the cell and face unknowns defined within the same cell. Crucially, no cell interior degree of freedom on one cell ever couples to any interior cell degree of freedom of a different cell.</li>
</ul>
<p>The Dirichlet-to-Neumann map concept then permits the following solution procedure: </p><ol>
<li>
Use local element interior data to enforce a Neumann condition on the skeleton of the triangulation. The global problem is then to solve for the trace values, which are the only globally coupled unknowns. </li>
<li>
Use the known skeleton values as Dirichlet data for solving local element-level solutions. This is known as the 'local solver', and is an <em>embarrassingly parallel</em> element-by-element solution process. </li>
</ol>
<p><a class="anchor" id="RelationwithStaticCondensation"></a></p><h4>Relation with Static Condensation </h4>
<p>The above procedure also has a linear algebra interpretation&mdash;referred to as <em>static condensation</em>&mdash;that was exploited to reduce the size of the global linear system by Guyan in the context of continuous Finite Elements <b>[G65]</b>, and by Fraeijs de Veubeke for mixed methods <b>[F65]</b>. In the latter case (mixed formulation), the system reduction was achieved through the use of discontinuous fluxes combined with the introduction of an additional auxiliary <em>hybrid</em> variable that approximates the trace of the unknown at the boundary of every element. This procedure became known as hybridization and&mdash;by analogy&mdash;is the reason why the local discontinuous Galerkin method introduced by Cockburn, Gopalakrishnan, and Lazarov in 2009 <b>[CGL2009]</b>, and subsequently developed by their collaborators, eventually came to be known as the <em>hybridizable discontinuous Galerkin</em> (HDG) method.</p>
<p>Let us write the complete linear system associated to the HDG problem as a block system with the discrete DG (cell interior) variables \(U\) as first block and the skeleton (face) variables \(\Lambda\) as the second block: </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} A &amp; B \\ C &amp; D \end{pmatrix} \begin{pmatrix} U \\ \Lambda \end{pmatrix} = \begin{pmatrix} F \\ G \end{pmatrix}. \end{eqnarray*}
</p>
<p> Our aim is now to eliminate the \(U\) block with a Schur complement approach similar to <a class="el" href="step_20.html">step-20</a>, which results in the following two steps: </p><p class="formulaDsp">
\begin{eqnarray*} (D - C A^{-1} B) \Lambda &amp;=&amp; G - C A^{-1} F, \\ A U &amp;=&amp; F - B \Lambda. \end{eqnarray*}
</p>
<p> The point is that the presence of \(A^{-1}\) is not a problem because \(A\) is a block diagonal matrix where each block corresponds to one cell and is therefore easy enough to invert. The coupling to other cells is introduced by the matrices \(B\) and \(C\) over the skeleton variable. The block-diagonality of \(A\) and the structure in \(B\) and \(C\) allow us to invert the matrix \(A\) element by element (the local solution of the Dirichlet problem) and subtract \(CA^{-1}B\) from \(D\). The steps in the Dirichlet-to-Neumann map concept hence correspond to </p><ol>
<li>
constructing the Schur complement matrix \(D-C A^{-1} B\) and right hand side \(G - C A^{-1} F\) <em>locally on each cell</em> and inserting the contribution into the global trace matrix in the usual way, </li>
<li>
solving the Schur complement system for \(\Lambda\), and </li>
<li>
solving for \(U\) using the second equation, given \(\Lambda\). </li>
</ol>
<p><a class="anchor" id="Solutionqualityandratesofconvergence"></a></p><h4>Solution quality and rates of convergence</h4>
<p>Another criticism of traditional DG methods is that the approximate fluxes converge suboptimally. The local HDG solutions can be shown to converge as \(\mathcal{O}(h^{p+1})\), i.e., at optimal order. Additionally, a super-convergence property can be used to post-process a new approximate solution that converges at the rate \(\mathcal{O}(h^{p+2})\).</p>
<p><a class="anchor" id="Alternativeapproaches"></a></p><h4>Alternative approaches </h4>
<p>The hybridizable discontinuous Galerkin method is only one way in which the problems of the discontinuous Galerkin method can be addressed. Another idea is what is called the "weak Galerkin" method. It is explored in <a class="el" href="step_61.html">step-61</a>.</p>
<p><a class="anchor" id="HDGappliedtotheconvectiondiffusionproblem"></a></p><h3>HDG applied to the convection-diffusion problem </h3>
<p>The HDG formulation used for this example is taken from <br />
 <b> N.C. Nguyen, J. Peraire, B. Cockburn: <em>An implicit high-order hybridizable discontinuous Galerkin method for linear convection–diffusion equations</em>, Journal of Computational <a class="el" href="namespacePhysics.html">Physics</a>, 2009, 228:9, 3232-3254. <a href="http://dx.doi.org/10.1016/j.jcp.2009.01.030">[DOI]</a> </b></p>
<p>We consider the convection-diffusion equation over the domain \(\Omega\) with Dirichlet boundary \(\partial \Omega_D\) and Neumann boundary \(\partial \Omega_N\): </p><p class="formulaDsp">
\begin{eqnarray*} \nabla \cdot (\mathbf{c} u) - \nabla \cdot (\kappa \nabla u) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{c} u - \kappa \nabla u)\cdot \mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}
</p>
<p>Introduce the auxiliary variable \(\mathbf{q}=-\kappa \nabla u\) and rewrite the above equation as the first order system: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{q} + \kappa \nabla u &amp;=&amp; 0, \quad \text{ in } \Omega, \\ \nabla \cdot (\mathbf{c} u + \mathbf{q}) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{q} + \mathbf{c}u)\cdot\mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}
</p>
<p>We multiply these equations by the weight functions \(\mathbf{v}, w\) and integrate by parts over every element \(K\) to obtain: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf{v}, \kappa^{-1} \mathbf{q})_K - (\nabla\cdot\mathbf{v}, u)_K + \left&lt;\mathbf{v}\cdot\mathbf{n}, {\hat{u}}\right&gt;_{\partial K} &amp;=&amp; 0, \\ - (\nabla w, \mathbf{c} u + \mathbf{q})_K + \left&lt;w, (\widehat{\mathbf{c} u}+{\hat{\mathbf{q}}})\cdot\mathbf{n}\right&gt;_{\partial K} &amp;=&amp; (w,f)_K. \end{eqnarray*}
</p>
<p>The terms decorated with a hat denote the numerical traces (also commonly referred to as numerical fluxes). They are approximations to the interior values on the boundary of the element. To ensure conservation, these terms must be single-valued on any given element edge \(\partial K\) even though, with discontinuous shape functions, there may of course be multiple values coming from the cells adjacent to an interface. We eliminate the numerical trace \(\hat{\mathbf{q}}\) by using traces of the form: </p><p class="formulaDsp">
\begin{eqnarray*} \widehat{\mathbf{c} u}+\hat{\mathbf{q}} = \mathbf{c}\hat{u} + \mathbf{q} + \tau(u - \hat{u})\mathbf{n} \quad \text{ on } \partial K. \end{eqnarray*}
</p>
<p>The variable \(\hat {u}\) is introduced as an additional independent variable and is the one for which we finally set up a globally coupled linear system. As mentioned above, it is defined on the element faces and discontinuous from one face to another wherever faces meet (at vertices in 2d, and at edges and vertices in 3d). Values for \(u\) and \(\mathbf{q}\) appearing in the numerical trace function are taken to be the cell's interior solution restricted to the boundary \(\partial K\).</p>
<p>The local stabilization parameter \(\tau\) has effects on stability and accuracy of HDG solutions; see the literature for a further discussion. A stabilization parameter of unity is reported to be the choice which gives best results. A stabilization parameter \(\tau\) that tends to infinity prohibits jumps in the solution over the element boundaries, making the HDG solution approach the approximation with continuous finite elements. In the program below, we choose the stabilization parameter as </p><p class="formulaDsp">
\begin{eqnarray*} \tau = \frac{\kappa}{\ell} + |\mathbf{c} \cdot \mathbf{n}| \end{eqnarray*}
</p>
<p> where we set the diffusion \(\kappa=1\) and the diffusion length scale to \(\ell = \frac{1}{5}\).</p>
<p>The trace/skeleton variables in HDG methods are single-valued on element faces. As such, they must strongly represent the Dirichlet data on \(\partial\Omega_D\). This means that </p><p class="formulaDsp">
\begin{equation*} \hat{u}|_{\partial \Omega_D} = g_D, \end{equation*}
</p>
<p> where the equal sign actually means an \(L_2\) projection of the boundary function \(g\) onto the space of the face variables (e.g. linear functions on the faces). This constraint is then applied to the skeleton variable \(\hat{u}\) using inhomogeneous constraints by the method <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>.</p>
<p>Summing the elemental contributions across all elements in the triangulation, enforcing the normal component of the numerical flux, and integrating by parts on the equation weighted by \(w\), we arrive at the final form of the problem: Find \((\mathbf{q}_h, u_h, \hat{u}_h) \in \mathcal{V}_h^p \times \mathcal{W}_h^p \times \mathcal{M}_h^p\) such that </p><p class="formulaDsp">
\begin{align*} (\mathbf{v}, \kappa^{-1} \mathbf{q}_h)_{\mathcal{T}} - ( \nabla\cdot\mathbf{v}, u_h)_{\mathcal{T}} + \left&lt;\mathbf{v}\cdot\mathbf{n}, \hat{u}_h\right&gt;_{\partial\mathcal{T}} &amp;= 0, \quad &amp;&amp;\forall \mathbf{v} \in \mathcal{V}_h^p, \\ - (\nabla w, \mathbf{c} u_h)_{\mathcal{T}} + (w, \nabla \cdot \mathbf{q}_h)_{\mathcal{T}} + (w, (\mathbf{c}\cdot\mathbf{n}) \hat{u}_h)_{\partial \mathcal{T}} + \left&lt;w, \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= (w, f)_{\mathcal{T}}, \quad &amp;&amp;\forall w \in \mathcal{W}_h^p, \\ \left&lt; \mu, \hat{u}_h\mathbf{c} \cdot \mathbf{n} + \mathbf{q}_h\cdot \mathbf{n} + \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= \left&lt;\mu, g_N\right&gt;_{\partial\Omega_N}, \quad &amp;&amp;\forall \mu \in \mathcal{M}_h^p. \end{align*}
</p>
<p>The unknowns \((\mathbf{q}_h, u_h)\) are referred to as local variables; they are represented as standard DG variables. The unknown \(\hat{u}_h\) is the skeleton variable which has support on the codimension-1 surfaces (faces) of the mesh.</p>
<p>We use the notation \((\cdot, \cdot)_{\mathcal{T}} = \sum_K (\cdot, \cdot)_K\) to denote the sum of integrals over all cells and \(\left&lt;\cdot, \cdot\right&gt;_{\partial \mathcal{T}} = \sum_K \left&lt;\cdot, \cdot\right&gt;_{\partial K}\) to denote integration over all faces of all cells, i.e., interior faces are visited twice, once from each side and with the corresponding normal vectors. When combining the contribution from both elements sharing a face, the above equation yields terms familiar from the DG method, with jumps of the solution over the cell boundaries.</p>
<p>In the equation above, the space \(\mathcal {W}_h^{p}\) for the scalar variable \(u_h\) is defined as the space of functions that are tensor product polynomials of degree \(p\) on each cell and discontinuous over the element boundaries \(\mathcal Q_{-p}\), i.e., the space described by <code>FE_DGQ&lt;dim&gt;(p)</code>. The space for the gradient or flux variable \(\mathbf{q}_i\) is a vector element space where each component is a locally polynomial and discontinuous \(\mathcal Q_{-p}\). In the code below, we collect these two local parts together in one <a class="el" href="classFESystem.html">FESystem</a> where the first <code>dim</code> components denote the gradient part and the last scalar component corresponds to the scalar variable. For the skeleton component \(\hat{u}_h\), we define a space that consists of discontinuous tensor product polynomials that live on the element faces, which in deal.II is implemented by the class <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>. This space is otherwise similar to <a class="el" href="classFE__DGQ.html">FE_DGQ</a>, i.e., the solution function is not continuous between two neighboring faces, see also the results section below for an illustration.</p>
<p>In the weak form given above, we can note the following coupling patterns: </p><ol>
<li>
The matrix \(A\) consists of local-local coupling terms. These arise when the local weighting functions \((\mathbf{v}, w)\) multiply the local solution terms \((\mathbf{q}_h, u_h)\). Because the elements are discontinuous, \(A\) is block diagonal. </li>
<li>
The matrix \(B\) represents the local-face coupling. These are the terms with weighting functions \((\mathbf{v}, w)\) multiplying the skeleton variable \(\hat{u}_h\). </li>
<li>
The matrix \(C\) represents the face-local coupling, which involves the weighting function \(\mu\) multiplying the local solutions \((\mathbf{q}_h, u_h)\). </li>
<li>
The matrix \(D\) is the face-face coupling; terms involve both \(\mu\) and \(\hat{u}_h\). </li>
</ol>
<p><a class="anchor" id="Postprocessingandsuperconvergence"></a></p><h4>Post-processing and super-convergence </h4>
<p>One special feature of the HDG methods is that they typically allow for constructing an enriched solution that gains accuracy. This post-processing takes the HDG solution in an element-by-element fashion and combines it such that one can get \(\mathcal O(h^{p+2})\) order of accuracy when using polynomials of degree \(p\). For this to happen, there are two necessary ingredients: </p><ol>
<li>
The computed solution gradient \(\mathbf{q}_h\) converges at optimal rate, i.e., \(\mathcal{O}(h^{p+1})\). </li>
<li>
The cell-wise average of the scalar part of the solution, \(\frac{(1,u_h)_K}{\text{vol}(K)}\), super-converges at rate \(\mathcal{O}(h^{p+2})\). </li>
</ol>
<p>We now introduce a new variable \(u_h^* \in \mathcal{V}_h^{p+1}\), which we find by minimizing the expression \(|\kappa \nabla u_h^* + \mathbf{q}_h|^2\) over the cell \(K\) under the constraint \(\left(1, u_h^*\right)_K = \left(1, u_h\right)_K\). The constraint is necessary because the minimization functional does not determine the constant part of \(u_h^*\). This translates to the following system of equations: </p><p class="formulaDsp">
\begin{eqnarray*} \left(1, u_h^*\right)_K &amp;=&amp; \left(1, u_h\right)_K\\ \left(\nabla w_h^*, \kappa \nabla u_h^*\right)_K &amp;=&amp; -\left(\nabla w_h^*, \mathbf{q}_h\right)_K \quad \text{for all } w_h^* \in \mathcal Q^{p+1}. \end{eqnarray*}
</p>
<p>Since we test by the whole set of basis functions in the space of tensor product polynomials of degree \(p+1\) in the second set of equations, this is an overdetermined system with one more equation than unknowns. We fix this in the code below by omitting one of these equations (since the rows in the Laplacian are linearly dependent when representing a constant function). As we will see below, this form of the post-processing gives the desired super-convergence result with rate \(\mathcal {O}(h^{p+2})\). It should be noted that there is some freedom in constructing \(u_h^*\) and this minimization approach to extract the information from the gradient is not the only one. In particular, the post-processed solution defined here does not satisfy the convection-diffusion equation in any sense. As an alternative, the paper by Nguyen, Peraire and Cockburn cited above suggests another somewhat more involved formula for convection-diffusion that can also post-process the flux variable into an \(H(\Omega,\mathrm{div})\)-conforming variant and better represents the local convection-diffusion operator when the diffusion is small. We leave the implementation of a more sophisticated post-processing as a possible extension to the interested reader.</p>
<p>Note that for vector-valued problems, the post-processing works similarly. One simply sets the constraint for the mean value of each vector component separately and uses the gradient as the main source of information.</p>
<p><a class="anchor" id="Problemspecificdata"></a></p><h3>Problem specific data </h3>
<p>For this tutorial program, we consider almost the same test case as in <a class="el" href="step_7.html">step-7</a>. The computational domain is \(\Omega \dealcoloneq [-1,1]^d\) and the exact solution corresponds to the one in <a class="el" href="step_7.html">step-7</a>, except for a scaling. We use the following source centers \(x_i\) for the exponentials </p><ul>
<li>
1D: \(\{x_i\}^1 = \{ -\frac{1}{3}, 0, \frac{1}{3} \}\), </li>
<li>
2D: \(\{\mathbf{x}_i\}^2 = \{ (-\frac{1}{2},\frac{1}{2}), (-\frac{1}{2},-\frac{1}{2}), (\frac{1}{2},-\frac{1}{2}) \}\), </li>
<li>
3D: \(\{\mathbf{x}_i\}^3 = \{ (-\frac{1}{2},\frac{1}{2}, \frac{1}{4}), (-\frac{3}{5},-\frac{1}{2}, -\frac{1}{8}), (\frac{1}{2},-\frac{1}{2}, \frac{1}{2}) \}\). </li>
</ul>
<p>With the exact solution given, we then choose the forcing on the right hand side and the Neumann boundary condition such that we obtain this solution (manufactured solution technique). In this example, we choose the diffusion equal to one and the convection as </p><p class="formulaDsp">
\[ \mathbf{c} = \begin{cases} 1, &amp; \textrm{dim}=1 \\ (y, -x), &amp; \textrm{dim}=2 \\ (y, -x, 1), &amp; \textrm{dim}=3 \end{cases} \]
</p>
<p> Note that the convection is divergence-free, \(\nabla \cdot c = 0\).</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation </h3>
<p>Besides implementing the above equations, the implementation below provides the following features: </p><ul>
<li>
<a class="el" href="namespaceWorkStream.html">WorkStream</a> to parallelize local solvers. Workstream has been presented in detail in <a class="el" href="step_9.html">step-9</a>. </li>
<li>
Reconstruct the local DG solution from the trace. </li>
<li>
Post-processing the solution for superconvergence. </li>
<li>
<a class="el" href="classDataOutFaces.html">DataOutFaces</a> for direct output of the global skeleton solution. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of the deal.II include files have already been covered in previous examples and are not commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2exceptions_8h.html">deal.II/base/exceptions.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div></div><!-- fragment --><p>However, we do have a few new includes for the example. The first one defines finite element spaces on the faces of the triangulation, which we refer to as the 'skeleton'. These finite elements do not have any support on the element interior, and they represent polynomials that have a single value on each codimension-1 surface, but admit discontinuities on codimension-2 surfaces.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div></div><!-- fragment --><p>The second new file we include defines a new type of sparse matrix. The regular <code><a class="el" href="classSparseMatrix.html">SparseMatrix</a></code> type stores indices to all non-zero entries. The <code><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a></code> takes advantage of the coupled nature of DG solutions. It stores an index to a matrix sub-block of a specified size. In the HDG context, this sub-block-size is actually the number of degrees of freedom per face defined by the skeleton solution field. This reduces the memory consumption of the matrix by up to one third and results in similar speedups when using the matrix in solvers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chunk__sparse__matrix_8h.html">deal.II/lac/chunk_sparse_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>The final new include for this example deals with data output. Since we have a finite element field defined on the skeleton of the mesh, we would like to visualize what that solution actually is. <a class="el" href="classDataOutFaces.html">DataOutFaces</a> does exactly this; the interface is the almost the same as the familiar <a class="el" href="classDataOut.html">DataOut</a>, but the output only has codimension-1 data for the simulation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>We start by putting all of our classes into their own namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>The structure of the analytic solution is the same as in <a class="el" href="step_7.html">step-7</a>. There are two exceptions. Firstly, we also create a solution for the 3d case, and secondly, we scale the solution so its norm is of order unity for all values of the solution width.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionBase</div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">  SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers] =</div><div class="line">    {<a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">  SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers] =</div><div class="line">    {<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers] = {</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6, -0.5, -0.125),</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5, -0.5, 0.5)};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1. / 5.;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">        sum +=</div><div class="line">          <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sum /</div><div class="line">           <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        sum +=</div><div class="line">          (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">           std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) *</div><div class="line">           x_minus_xi);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sum /</div><div class="line">           <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>This class implements a function where the scalar solution and its negative gradient are collected together. This function is used when computing the error of the HDG approximation and its implementation is to simply call value and gradient function of the Solution class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SolutionAndGradient()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  v)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), dim + 1);</div><div class="line">    Solution&lt;dim&gt;  solution;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad = solution.gradient(p);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      v[d] = -grad[d];</div><div class="line">    v[dim] = solution.value(p);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Next comes the implementation of the convection velocity. As described in the introduction, we choose a velocity field that is \((y, -x)\) in 2D and \((y, -x, 1)\) in 3D. This gives a divergence-free velocity field.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConvectionVelocity()</div><div class="line">    : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="classTensorFunction.html#a60e07c97b7b3b30c612644f9ca42d477">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 1:</div><div class="line">          convection[0] = 1;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          convection[0] = p[1];</div><div class="line">          convection[1] = -p[0];</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          convection[0] = p[1];</div><div class="line">          convection[1] = -p[0];</div><div class="line">          convection[2] = 1;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> convection;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>The last function we implement is the right hand side for the manufactured solution. It is very similar to <a class="el" href="step_7.html">step-7</a>, with the exception that we now have a convection term instead of the reaction term. Since the velocity field is incompressible, i.e., \(\nabla \cdot \mathbf{c} = 0\), the advection term simply reads \(\mathbf{c} \nabla u\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          convection = convection_velocity.value(p);</div><div class="line">    <span class="keywordtype">double</span>                  sum        = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        sum +=</div><div class="line">          ((2 * dim - 2 * convection * x_minus_xi -</div><div class="line">            4 * x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) /</div><div class="line">           (this-&gt;width * this-&gt;width) *</div><div class="line">           std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sum /</div><div class="line">           <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheHDGsolverclass"></a> </p><h3>The HDG solver class</h3>
<p>The HDG solution procedure follows closely that of <a class="el" href="step_7.html">step-7</a>. The major difference is the use of three different sets of <a class="el" href="classDoFHandler.html">DoFHandler</a> and FE objects, along with the <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> and the corresponding solutions vectors. We also use <a class="el" href="namespaceWorkStream.html">WorkStream</a> to enable a multithreaded local solution process which exploits the embarrassingly parallel nature of the local solver. For <a class="el" href="namespaceWorkStream.html">WorkStream</a>, we define the local operations on a cell and a copy function into the global matrix and vector. We do this both for the assembly (which is run twice, once when we generate the system matrix and once when we compute the element-interior solutions from the skeleton values) and for the postprocessing where we extract a solution that converges at higher order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>HDG</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> RefinementMode</div><div class="line">  {</div><div class="line">    global_refinement,</div><div class="line">    adaptive_refinement</div><div class="line">  };</div><div class="line"></div><div class="line">  HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> postprocess();</div><div class="line">  <span class="keywordtype">void</span> refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div></div><!-- fragment --><p>Data for the assembly and solution of the primal variables.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PerTaskData;</div><div class="line"><span class="keyword">struct </span>ScratchData;</div></div><!-- fragment --><p>Post-processing the solution to obtain \(u^*\) is an element-by-element procedure; as such, we do not need to assemble any global data and do not declare any 'task data' for <a class="el" href="namespaceWorkStream.html">WorkStream</a> to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PostProcessScratchData;</div></div><!-- fragment --><p>The following three functions are used by <a class="el" href="namespaceWorkStream.html">WorkStream</a> to do the actual work of the program.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_system_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  ScratchData &amp;                                         scratch,</div><div class="line">  PerTaskData &amp;                                         task_data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> postprocess_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  PostProcessScratchData &amp;                              scratch,</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        empty_data);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>The 'local' solutions are interior to each element. These represent the primal solution field \(u\) as well as the auxiliary field \(\mathbf{q}\).</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe_local;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_local;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution_local;</div></div><!-- fragment --><p>The new finite element type and corresponding <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> are used for the global skeleton solution that couples the element-level local solutions.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>   fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  system_rhs;</div></div><!-- fragment --><p>As stated in the introduction, HDG solutions can be post-processed to attain superconvergence rates of \(\mathcal{O}(h^{p+2})\). The post-processed solution is a discontinuous finite element solution representing the primal variable on the interior of each cell. We define a FE type of degree \(p+1\) to represent this post-processed solution, which we only use for output after constructing it.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>     fe_u_post;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_u_post;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution_u_post;</div></div><!-- fragment --><p>The degrees of freedom corresponding to the skeleton strongly enforce Dirichlet boundary conditions, just as in a continuous Galerkin finite element method. We can enforce the boundary conditions in an analogous manner via an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object. In addition, hanging nodes are handled in the same way as for continuous finite elements: For the face elements which only define degrees of freedom on the face, this process sets the solution on the refined side to coincide with the representation on the coarse side.</p>
<p>Note that for HDG, the elimination of hanging nodes is not the only possibility &mdash; in terms of the HDG theory, one could also use the unknowns from the refined side and express the local solution on the coarse side through the trace values on the refined side. However, such a setup is not as easily implemented in terms of deal.II loops and not further analyzed.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div></div><!-- fragment --><p>The usage of the <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> class is similar to the usual sparse matrices: You need a sparsity pattern of type <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> and the actual matrix object. When creating the sparsity pattern, we just have to additionally pass the size of local blocks.</p>
<div class="fragment"><div class="line"><a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>Same as <a class="el" href="step_7.html">step-7</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">  <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheHDGclassimplementation"></a> </p><h3>The HDG class implementation</h3>
<p><a class="anchor" id="Constructor"></a> </p><h4>Constructor</h4>
<p>The constructor is similar to those in other examples, with the exception of handling multiple <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> objects. Note that we create a system of finite elements for the local DG part, including the gradient/flux part and the scalar part.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">HDG&lt;dim&gt;::HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode)</div><div class="line">  : fe_local(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim, <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler_local(triangulation)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe_u_post(degree + 1)</div><div class="line">  , dof_handler_u_post(triangulation)</div><div class="line">  , refinement_mode(refinement_mode)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="HDGsetup_system"></a> </p><h4>HDG::setup_system</h4>
<p>The system for an HDG solution is setup in an analogous manner to most of the other tutorial programs. We are careful to distribute dofs with all of our <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The <code>solution</code> and <code>system_matrix</code> objects go with the global skeleton solution.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler_local.distribute_dofs(fe_local);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  solution_local.reinit(dof_handler_local.n_dofs());</div><div class="line">  solution_u_post.reinit(dof_handler_u_post.n_dofs());</div><div class="line"></div><div class="line">  constraints.clear();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt; boundary_functions;</div><div class="line">  Solution&lt;dim&gt;                                       solution_function;</div><div class="line">  boundary_functions[0] = &amp;solution_function;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>(dof_handler,</div><div class="line">                                       boundary_functions,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                       constraints);</div><div class="line">  constraints.close();</div></div><!-- fragment --><p>When creating the chunk sparsity pattern, we first create the usual dynamic sparsity pattern and then set the chunk size, which is equal to the number of dofs on a face, when copying this into the final sparsity pattern.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a>());</div><div class="line">  }</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGPerTaskData"></a> </p><h4>HDG::PerTaskData</h4>
<p>Next comes the definition of the local data structures for the parallel assembly. The first structure <code>PerTaskData</code> contains the local vector and matrix that are written into the global matrix, whereas the ScratchData contains all data that we need for the local assembly. There is one variable worth noting here, namely the boolean variable <code>trace_reconstruct</code>. As mentioned in the introduction, we solve the HDG system in two steps. First, we create a linear system for the skeleton system where we condense the local part into it via the Schur complement \(D-CA^{-1}B\). Then, we solve for the local part using the skeleton solution. For these two steps, we need the same matrices on the elements twice, which we want to compute by two assembly steps. Since most of the code is similar, we do this with the same function but only switch between the two based on a flag that we set when starting the assembly. Since we need to pass this information on to the local worker routines, we store it once in the task data.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_vector;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">  PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">    : cell_matrix(n_dofs, n_dofs)</div><div class="line">    , cell_vector(n_dofs)</div><div class="line">    , dof_indices(n_dofs)</div><div class="line">    , trace_reconstruct(trace_reconstruct)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGScratchData"></a> </p><h4>HDG::ScratchData</h4>
<p><code>ScratchData</code> contains persistent data for each thread within <a class="el" href="namespaceWorkStream.html">WorkStream</a>. The <a class="el" href="classFEValues.html">FEValues</a>, matrix, and vector objects should be familiar by now. There are two objects that need to be discussed: <code>std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_local_support_on_face</code> and <code>std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_support_on_face</code>. These are used to indicate whether or not the finite elements chosen have support (non-zero values) on a given face of the reference cell for the local part associated to <code>fe_local</code> and the skeleton part <code>fe</code>. We extract this information in the constructor and store it once for all cells that we work on. Had we not stored this information, we would be forced to assemble a large number of zero terms on each cell, which would significantly slow the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     l_rhs;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     tmp_rhs;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; q_phi;</div><div class="line">  std::vector&lt;double&gt;         q_phi_div;</div><div class="line">  std::vector&lt;double&gt;         u_phi;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_phi_grad;</div><div class="line">  std::vector&lt;double&gt;         tr_phi;</div><div class="line">  std::vector&lt;double&gt;         trace_values;</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_local_support_on_face;</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_support_on_face;</div><div class="line"></div><div class="line">  ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">  RightHandSide&lt;dim&gt;      right_hand_side;</div><div class="line">  <span class="keyword">const</span> Solution&lt;dim&gt;     exact_solution;</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp;   face_quadrature_formula,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_face_flags,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">    : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">    , fe_face_values_local(fe_local,</div><div class="line">                           face_quadrature_formula,</div><div class="line">                           local_face_flags)</div><div class="line">    , fe_face_values(fe, face_quadrature_formula, flags)</div><div class="line">    , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">    , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">    , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">    , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">    , l_rhs(fe_local.n_dofs_per_cell())</div><div class="line">    , tmp_rhs(fe_local.n_dofs_per_cell())</div><div class="line">    , q_phi(fe_local.n_dofs_per_cell())</div><div class="line">    , q_phi_div(fe_local.n_dofs_per_cell())</div><div class="line">    , u_phi(fe_local.n_dofs_per_cell())</div><div class="line">    , u_phi_grad(fe_local.n_dofs_per_cell())</div><div class="line">    , tr_phi(fe.n_dofs_per_cell())</div><div class="line">    , trace_values(face_quadrature_formula.size())</div><div class="line">    , fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">    , fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">    , exact_solution()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_local.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">            fe_local_support_on_face[face_no].push_back(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">            fe_support_on_face[face_no].push_back(i);</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">    : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                      sd.fe_values_local.get_quadrature(),</div><div class="line">                      sd.fe_values_local.get_update_flags())</div><div class="line">    , fe_face_values_local(sd.fe_face_values_local.get_fe(),</div><div class="line">                           sd.fe_face_values_local.get_quadrature(),</div><div class="line">                           sd.fe_face_values_local.get_update_flags())</div><div class="line">    , fe_face_values(sd.fe_face_values.get_fe(),</div><div class="line">                     sd.fe_face_values.get_quadrature(),</div><div class="line">                     sd.fe_face_values.get_update_flags())</div><div class="line">    , ll_matrix(sd.ll_matrix)</div><div class="line">    , lf_matrix(sd.lf_matrix)</div><div class="line">    , fl_matrix(sd.fl_matrix)</div><div class="line">    , tmp_matrix(sd.tmp_matrix)</div><div class="line">    , l_rhs(sd.l_rhs)</div><div class="line">    , tmp_rhs(sd.tmp_rhs)</div><div class="line">    , q_phi(sd.q_phi)</div><div class="line">    , q_phi_div(sd.q_phi_div)</div><div class="line">    , u_phi(sd.u_phi)</div><div class="line">    , u_phi_grad(sd.u_phi_grad)</div><div class="line">    , tr_phi(sd.tr_phi)</div><div class="line">    , trace_values(sd.trace_values)</div><div class="line">    , fe_local_support_on_face(sd.fe_local_support_on_face)</div><div class="line">    , fe_support_on_face(sd.fe_support_on_face)</div><div class="line">    , exact_solution()</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGPostProcessScratchData"></a> </p><h4>HDG::PostProcessScratchData</h4>
<p><code>PostProcessScratchData</code> contains the data used by <a class="el" href="namespaceWorkStream.html">WorkStream</a> when post-processing the local solution \(u^*\). It is similar, but much simpler, than <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         u_values;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_gradients;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_sol;</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">    : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">    , fe_values(fe, quadrature_formula, flags)</div><div class="line">    , u_values(quadrature_formula.size())</div><div class="line">    , u_gradients(quadrature_formula.size())</div><div class="line">    , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">    , cell_rhs(fe.n_dofs_per_cell())</div><div class="line">    , cell_sol(fe.n_dofs_per_cell())</div><div class="line">  {}</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">    : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                      sd.fe_values_local.get_quadrature(),</div><div class="line">                      sd.fe_values_local.get_update_flags())</div><div class="line">    , fe_values(sd.fe_values.get_fe(),</div><div class="line">                sd.fe_values.get_quadrature(),</div><div class="line">                sd.fe_values.get_update_flags())</div><div class="line">    , u_values(sd.u_values)</div><div class="line">    , u_gradients(sd.u_gradients)</div><div class="line">    , cell_matrix(sd.cell_matrix)</div><div class="line">    , cell_rhs(sd.cell_rhs)</div><div class="line">    , cell_sol(sd.cell_sol)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system"></a> </p><h4>HDG::assemble_system</h4>
<p>The <code>assemble_system</code> function is similar to the one on <a class="el" href="step_32.html">step-32</a>, where the quadrature formula and the update flags are set up, and then <code><a class="el" href="namespaceWorkStream.html">WorkStream</a></code> is used to do the work in a multi-threaded manner. The <code>trace_reconstruct</code> input parameter is used to decide whether we are solving for the global skeleton solution (false) or the local solution (true).</p>
<p>One thing worth noting for the multi-threaded execution of assembly is the fact that the local computations in <code>assemble_system_one_cell()</code> call into BLAS and LAPACK functions if those are available in deal.II. Thus, the underlying BLAS/LAPACK library must support calls from multiple threads at the same time. Most implementations do support this, but some libraries need to be built in a specific way to avoid problems. For example, OpenBLAS compiled without multithreading inside the BLAS/LAPACK calls needs to built with a flag called <code>USE_LOCKING</code> set to true.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  PerTaskData task_data(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(), trace_reconstruct);</div><div class="line">  ScratchData scratch(fe,</div><div class="line">                      fe_local,</div><div class="line">                      quadrature_formula,</div><div class="line">                      face_quadrature_formula,</div><div class="line">                      local_flags,</div><div class="line">                      local_face_flags,</div><div class="line">                      flags);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                  &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                  scratch,</div><div class="line">                  task_data);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system_one_cell"></a> </p><h4>HDG::assemble_system_one_cell</h4>
<p>The real work of the HDG program is done by <code>assemble_system_one_cell</code>. Assembling the local matrices \(A, B, C\) is done here, along with the local contributions of the global matrix \(D\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  ScratchData &amp;                                         scratch,</div><div class="line">  PerTaskData &amp;                                         task_data)</div><div class="line">{</div></div><!-- fragment --><p>Construct iterator for dof_handler_local for <a class="el" href="classFEValues.html">FEValues</a> reinit function.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                        cell-&gt;level(),</div><div class="line">                                                        cell-&gt;index(),</div><div class="line">                                                        &amp;dof_handler_local);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">  scratch.fe_values_local.get_quadrature().size();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">  scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell =</div><div class="line">  scratch.fe_values_local.get_fe().n_dofs_per_cell();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">scratch.ll_matrix = 0;</div><div class="line">scratch.l_rhs     = 0;</div><div class="line"><span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">  {</div><div class="line">    scratch.lf_matrix     = 0;</div><div class="line">    scratch.fl_matrix     = 0;</div><div class="line">    task_data.cell_matrix = 0;</div><div class="line">    task_data.cell_vector = 0;</div><div class="line">  }</div><div class="line">scratch.fe_values_local.reinit(loc_cell);</div></div><!-- fragment --><p>We first compute the cell-interior contribution to <code>ll_matrix</code> matrix (referred to as matrix \(A\) in the introduction) corresponding to local-local coupling, as well as the local right-hand-side vector. We store the values at each quadrature point for the basis functions, the right-hand-side value, and the convection velocity, in order to have quick access to these fields.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value = scratch.right_hand_side.value(</div><div class="line">      scratch.fe_values_local.quadrature_point(q));</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection = scratch.convection_velocity.value(</div><div class="line">      scratch.fe_values_local.quadrature_point(q));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; loc_dofs_per_cell; ++k)</div><div class="line">      {</div><div class="line">        scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);</div><div class="line">        scratch.q_phi_div[k] =</div><div class="line">          scratch.fe_values_local[fluxes].divergence(k, q);</div><div class="line">        scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);</div><div class="line">        scratch.u_phi_grad[k] =</div><div class="line">          scratch.fe_values_local[scalar].gradient(k, q);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; loc_dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; loc_dofs_per_cell; ++j)</div><div class="line">          scratch.ll_matrix(i, j) +=</div><div class="line">            (scratch.q_phi[i] * scratch.q_phi[j] -</div><div class="line">             scratch.q_phi_div[i] * scratch.u_phi[j] +</div><div class="line">             scratch.u_phi[i] * scratch.q_phi_div[j] -</div><div class="line">             (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]) *</div><div class="line">            JxW;</div><div class="line">        scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Face terms are assembled on all faces of all elements. This is in contrast to more traditional DG methods, where each face is only visited once in the assembly procedure.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">  {</div><div class="line">    scratch.fe_face_values_local.reinit(loc_cell, face_no);</div><div class="line">    scratch.fe_face_values.reinit(cell, face_no);</div></div><!-- fragment --><p>The already obtained \(\hat{u}\) values are needed when solving for the local variables.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">  scratch.fe_face_values.get_function_values(solution,</div><div class="line">                                             scratch.trace_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     JxW = scratch.fe_face_values.JxW(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">      scratch.fe_face_values.quadrature_point(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal =</div><div class="line">      scratch.fe_face_values.normal_vector(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection =</div><div class="line">      scratch.convection_velocity.value(quadrature_point);</div></div><!-- fragment --><p>Here we compute the stabilization parameter discussed in the introduction: since the diffusion is one and the diffusion length scale is set to 1/5, it simply results in a contribution of 5 for the diffusion part and the magnitude of convection through the element boundary in a centered scheme for the convection part.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. + <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(convection * normal));</div></div><!-- fragment --><p>We store the non-zero flux and scalar values, making use of the support_on_face information we created in <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">     k &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">     ++k)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk =</div><div class="line">      scratch.fe_local_support_on_face[face_no][k];</div><div class="line">    scratch.q_phi[k] =</div><div class="line">      scratch.fe_face_values_local[fluxes].value(kk, q);</div><div class="line">    scratch.u_phi[k] =</div><div class="line">      scratch.fe_face_values_local[scalar].value(kk, q);</div><div class="line">  }</div></div><!-- fragment --><p>When <code>trace_reconstruct=false</code>, we are preparing to assemble the system for the skeleton variable \(\hat{u}\). If this is the case, we must assemble all local matrices associated with the problem: local-local, local-face, face-local, and face-face. The face-face matrix is stored as <code>TaskData::cell_matrix</code>, so that it can be assembled into the global system by <code>copy_local_to_global</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">         k &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">         ++k)</div><div class="line">      scratch.tr_phi[k] = scratch.fe_face_values.shape_value(</div><div class="line">        scratch.fe_support_on_face[face_no][k], q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">         i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">         ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">           j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">           ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">            scratch.fe_local_support_on_face[face_no][i];</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">            scratch.fe_support_on_face[face_no][j];</div><div class="line">          scratch.lf_matrix(ii, jj) +=</div><div class="line">            ((scratch.q_phi[i] * normal +</div><div class="line">              (convection * normal - tau_stab) * scratch.u_phi[i]) *</div><div class="line">             scratch.tr_phi[j]) *</div><div class="line">            JxW;</div></div><!-- fragment --><p>Note the sign of the face_no-local matrix. We negate the sign during assembly here so that we can use the <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a> with addition when computing the Schur complement.</p>
<div class="fragment"><div class="line">        scratch.fl_matrix(jj, ii) -=</div><div class="line">          ((scratch.q_phi[i] * normal +</div><div class="line">            tau_stab * scratch.u_phi[i]) *</div><div class="line">           scratch.tr_phi[j]) *</div><div class="line">          JxW;</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">       i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">       ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">         j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">         ++j)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">          scratch.fe_support_on_face[face_no][i];</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">          scratch.fe_support_on_face[face_no][j];</div><div class="line">        task_data.cell_matrix(ii, jj) +=</div><div class="line">          ((convection * normal - tau_stab) * scratch.tr_phi[i] *</div><div class="line">           scratch.tr_phi[j]) *</div><div class="line">          JxW;</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">      (cell-&gt;face(face_no)-&gt;boundary_id() == 1))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">        -scratch.exact_solution.gradient(quadrature_point) *</div><div class="line">          normal +</div><div class="line">        convection * normal *</div><div class="line">          scratch.exact_solution.value(quadrature_point);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">           i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">           ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">            scratch.fe_support_on_face[face_no][i];</div><div class="line">          task_data.cell_vector(ii) +=</div><div class="line">            scratch.tr_phi[i] * neumann_value * JxW;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This last term adds the contribution of the term \(\left&lt;w,\tau u_h\right&gt;_{\partial \mathcal T}\) to the local matrix. As opposed to the face matrices above, we need it in both assembly stages.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">     i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">     ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">       j &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">       ++j)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">        scratch.fe_local_support_on_face[face_no][i];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">        scratch.fe_local_support_on_face[face_no][j];</div><div class="line">      scratch.ll_matrix(ii, jj) +=</div><div class="line">        tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;</div><div class="line">    }</div></div><!-- fragment --><p>When <code>trace_reconstruct=true</code>, we are solving for the local solutions on an element by element basis. The local right-hand-side is calculated by replacing the basis functions <code>tr_phi</code> in the <code>lf_matrix</code> computation by the computed values <code>trace_values</code>. Of course, the sign of the matrix is now minus since we have moved everything to the other side of the equation.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">             i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">             ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">              scratch.fe_local_support_on_face[face_no][i];</div><div class="line">            scratch.l_rhs(ii) -=</div><div class="line">              (scratch.q_phi[i] * normal +</div><div class="line">               scratch.u_phi[i] * (convection * normal - tau_stab)) *</div><div class="line">              scratch.trace_values[q] * JxW;</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Once assembly of all of the local contributions is complete, we must either: (1) assemble the global system, or (2) compute the local solution values and save them. In either case, the first step is to invert the local-local matrix.</p>
<div class="fragment"><div class="line">scratch.ll_matrix.gauss_jordan();</div></div><!-- fragment --><p>For (1), we compute the Schur complement and add it to the <code>cell_matrix</code>, matrix \(D\) in the introduction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">    scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">    scratch.tmp_matrix.mmult(task_data.cell_matrix,</div><div class="line">                             scratch.lf_matrix,</div><div class="line">                             <span class="keyword">true</span>);</div><div class="line">    cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">  }</div></div><!-- fragment --><p>For (2), we are simply solving (ll_matrix).(solution_local) = (l_rhs). Hence, we multiply <code>l_rhs</code> by our already inverted local-local matrix and store the result using the <code>set_dof_values</code> function.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">      loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGcopy_local_to_global"></a> </p><h4>HDG::copy_local_to_global</h4>
<p>If we are in the first step of the solution, i.e. <code>trace_reconstruct=false</code>, then we assemble the local matrices into the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">    constraints.distribute_local_to_global(data.cell_matrix,</div><div class="line">                                           data.cell_vector,</div><div class="line">                                           data.dof_indices,</div><div class="line">                                           system_matrix,</div><div class="line">                                           system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGsolve"></a> </p><h4>HDG::solve</h4>
<p>The skeleton solution is solved for by using a BiCGStab solver with identity preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                  solver_control(system_matrix.m() * 10,</div><div class="line">                               1e-11 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0, 0, 0, 1);</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div></div><!-- fragment --><p>Once we have solved for the skeleton solution, we can solve for the local solutions in an element-by-element fashion. We do this by re-using the same <code>assemble_system</code> function but switching <code>trace_reconstruct</code> to true.</p>
<div class="fragment"><div class="line">  assemble_system(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess"></a> </p><h4>HDG::postprocess</h4>
<p>The postprocess method serves two purposes. First, we want to construct a post-processed scalar variables in the element space of degree \(p+1\) that we hope will converge at order \(p+2\). This is again an element-by-element process and only involves the scalar solution as well as the gradient on the local cell. To do this, we introduce the already defined scratch data together with some update flags and run the work stream to do this in parallel.</p>
<p>Secondly, we want to compute discretization errors just as we did in <a class="el" href="step_7.html">step-7</a>. The overall procedure is similar with calls to <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>. The difference is in how we compute the errors for the scalar variable and the gradient variable. In <a class="el" href="step_7.html">step-7</a>, we did this by computing <code>L2_norm</code> or <code>H1_seminorm</code> contributions. Here, we have a <a class="el" href="classDoFHandler.html">DoFHandler</a> with these two contributions computed and sorted by their vector component, <code>[0, dim)</code> for the gradient and <code>dim</code> for the scalar. To compute their value, we hence use a <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> with either of them, together with the <code>SolutionAndGradient</code> class introduced above that contains the analytic parts of either of them. Eventually, we also compute the L2-error of the post-processed solution and add the results into the convergence table.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_u_post.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PostProcessScratchData scratch(</div><div class="line">      fe_u_post, fe_local, quadrature_formula, local_flags, flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">      dof_handler_u_post.begin_active(),</div><div class="line">      dof_handler_u_post.end(),</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">             PostProcessScratchData &amp;                              scratch,</div><div class="line">             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        data) {</div><div class="line">        this-&gt;postprocess_one_cell(cell, scratch, data);</div><div class="line">      },</div><div class="line">      std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">      scratch,</div><div class="line">      0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select(dim, dim + 1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                    solution_local,</div><div class="line">                                    SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;value_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select(</div><div class="line">    std::pair&lt;unsigned int, unsigned int&gt;(0, dim), dim + 1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                    solution_local,</div><div class="line">                                    SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;gradient_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_u_post,</div><div class="line">                                    solution_u_post,</div><div class="line">                                    Solution&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 3),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> post_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>, L2_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>, grad_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess_one_cell"></a> </p><h4>HDG::postprocess_one_cell</h4>
<p>This is the actual work done for the postprocessing. According to the discussion in the introduction, we need to set up a system that projects the gradient part of the DG solution onto the gradient of the post-processed variable. Moreover, we need to set the average of the new post-processed variable to equal the average of the scalar DG solution on the cell.</p>
<p>More technically speaking, the projection of the gradient is a system that would potentially fills our <code>dofs_per_cell</code> times <code>dofs_per_cell</code> matrix but is singular (the sum of all rows would be zero because the constant function has zero gradient). Therefore, we take one row away and use it for imposing the average of the scalar value. We pick the first row for the scalar part, even though we could pick any row for \(\mathcal Q_{-p}\) elements. However, had we used <a class="el" href="classFE__DGP.html">FE_DGP</a> elements instead, the first row would correspond to the constant part already and deleting e.g. the last row would give us a singular system. This way, our program can also be used for those elements.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  PostProcessScratchData &amp;                              scratch,</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                          cell-&gt;level(),</div><div class="line">                                                          cell-&gt;index(),</div><div class="line">                                                          &amp;dof_handler_local);</div><div class="line"></div><div class="line">  scratch.fe_values_local.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(loc_cell);</div><div class="line">  scratch.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line"></div><div class="line">  scratch.fe_values_local[scalar].get_function_values(solution_local,</div><div class="line">                                                      scratch.u_values);</div><div class="line">  scratch.fe_values_local[fluxes].get_function_values(solution_local,</div><div class="line">                                                      scratch.u_gradients);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> sum = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          sum = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            sum += (scratch.fe_values.shape_grad(i, q) *</div><div class="line">                    scratch.fe_values.shape_grad(j, q)) *</div><div class="line">                   scratch.fe_values.JxW(q);</div><div class="line">          scratch.cell_matrix(i, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) *</div><div class="line">               scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_rhs(i) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">    {</div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_matrix(0, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    }</div><div class="line">  {</div><div class="line">    sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      sum += scratch.u_values[q] * scratch.fe_values.JxW(q);</div><div class="line">    scratch.cell_rhs(0) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">  }</div></div><!-- fragment --><p>Having assembled all terms, we can again go on and solve the linear system. We invert the matrix and then multiply the inverse by the right hand side. An alternative (and more numerically stable) method would have been to only factorize the matrix and apply the factorization.</p>
<div class="fragment"><div class="line">  scratch.cell_matrix.gauss_jordan();</div><div class="line">  scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">  cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGoutput_results"></a> </p><h4>HDG::output_results</h4>
<p>We have 3 sets of results that we would like to output: the local solution, the post-processed local solution, and the skeleton solution. The former 2 both 'live' on element volumes, whereas the latter lives on codimension-1 surfaces of the triangulation. Our <code>output_results</code> function writes all local solutions to the same vtk file, even though they correspond to different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The graphical output for the skeleton variable is done through use of the <a class="el" href="classDataOutFaces.html">DataOutFaces</a> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  std::string filename;</div><div class="line">  <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  std::string face_out(filename);</div><div class="line">  face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">  filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">  filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">  filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div></div><!-- fragment --><p>We first define the names and types of the local solution, and add the data to <code>data_out</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; names(dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">names.emplace_back(<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  component_interpretation(</div><div class="line">    dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">component_interpretation[dim] =</div><div class="line">  <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_local,</div><div class="line">                         solution_local,</div><div class="line">                         names,</div><div class="line">                         component_interpretation);</div></div><!-- fragment --><p>The second data item we add is the post-processed solution. In this case, it is a single scalar variable belonging to a different <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; post_name(1, <span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_u_post,</div><div class="line">                         solution_u_post,</div><div class="line">                         post_name,</div><div class="line">                         post_comp_type);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">std::ofstream face_output(face_out);</div></div><!-- fragment --><p>The <code><a class="el" href="classDataOutFaces.html">DataOutFaces</a></code> class works analogously to the <code><a class="el" href="classDataOut.html">DataOut</a></code> class when we have a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> that defines the solution on the skeleton of the triangulation. We treat it as such here, and the code is similar to that above.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a>        data_out_face(<span class="keyword">false</span>);</div><div class="line">  std::vector&lt;std::string&gt; face_name(1, <span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  data_out_face.add_data_vector(dof_handler,</div><div class="line">                                solution,</div><div class="line">                                face_name,</div><div class="line">                                face_component_type);</div><div class="line"></div><div class="line">  data_out_face.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">  data_out_face.write_vtk(face_output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGrefine_grid"></a> </p><h4>HDG::refine_grid</h4>
<p>We implement two different refinement cases for HDG, just as in <code><a class="el" href="step_7.html">step-7</a></code>: adaptive_refinement and global_refinement. The global_refinement option recreates the entire triangulation every time. This is because we want to use a finer sequence of meshes than what we would get with one refinement step, namely 2, 3, 4, 6, 8, 12, 16, ... elements per direction.</p>
<p>The adaptive_refinement mode uses the <code><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a></code> to give a decent indication of the non-regular regions in the scalar local solutions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 2, -1, 1);</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> global_refinement:</div><div class="line">          {</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation,</div><div class="line">                                                 2 + (cycle % 2),</div><div class="line">                                                 -1,</div><div class="line">                                                 1);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim + cycle / 2);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">          {</div><div class="line">            <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">            <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">            std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">              neumann_boundary;</div><div class="line">            <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler_local,</div><div class="line">                                               <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                               neumann_boundary,</div><div class="line">                                               solution_local,</div><div class="line">                                               estimated_error_per_cell,</div><div class="line">                                               fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(</div><div class="line">                                                 scalar));</div><div class="line"></div><div class="line">            <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">              triangulation, estimated_error_per_cell, 0.3, 0.);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>Just as in <a class="el" href="step_7.html">step-7</a>, we set the boundary indicator of two of the faces to 1 where we want to specify Neumann boundary conditions instead of Dirichlet conditions. Since we re-create the triangulation every time for global refinement, the flags are set in every refinement step, not just at the beginning.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">        <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(0) - (-1)) &lt; 1e-12) ||</div><div class="line">            (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">          face-&gt;set_boundary_id(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGrun"></a> </p><h4>HDG::run</h4>
<p>The functionality here is basically the same as <code><a class="el" href="step_7.html">step-7</a></code>. We loop over 10 cycles, refining the grid on each one. At the end, convergence tables are created.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HDG&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 10; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      refine_grid(cycle);</div><div class="line">      setup_system();</div><div class="line">      assemble_system(<span class="keyword">false</span>);</div><div class="line">      solve();</div><div class="line">      postprocess();</div><div class="line">      output_results(cycle);</div><div class="line">    }</div></div><!-- fragment --><p>There is one minor change for the convergence table compared to <a class="el" href="step_7.html">step-7</a>: Since we did not refine our mesh by a factor two in each cycle (but rather used the sequence 2, 3, 4, 6, 8, 12, ...), we need to tell the convergence rate evaluation about this. We do this by setting the number of cells as a reference column and additionally specifying the dimension of the problem, which gives the necessary information for the relation between number of cells and mesh size.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div></div><!-- fragment --><p>Now for the three calls to the main class in complete analogy to <a class="el" href="step_7.html">step-7</a>.</p>
<div class="fragment"><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>We first have a look at the output generated by the program when run in 2D. In the four images below, we show the solution for polynomial degree \(p=1\) and cycles 2, 3, 4, and 8 of the program. In the plots, we overlay the data generated from the internal data (DG part) with the skeleton part ( \(\hat{u}\)) into the same plot. We had to generate two different data sets because cells and faces represent different geometric entities, the combination of which (in the same file) is not supported in the VTK output of deal.II.</p>
<p>The images show the distinctive features of HDG: The cell solution (colored surfaces) is discontinuous between the cells. The solution on the skeleton variable sits on the faces and ties together the local parts. The skeleton solution is not continuous on the vertices where the faces meet, even though its values are quite close along lines in the same coordinate direction. The skeleton solution can be interpreted as a rubber spring between the two sides that balances the jumps in the solution (or rather, the flux \(\kappa \nabla u + \mathbf{c} u\)). From the picture at the top left, it is clear that the bulk solution frequently over- and undershoots and that the skeleton variable in indeed a better approximation to the exact solution; this explains why we can get a better solution using a postprocessing step.</p>
<p>As the mesh is refined, the jumps between the cells get small (we represent a smooth solution), and the skeleton solution approaches the interior parts. For cycle 8, there is no visible difference in the two variables. We also see how boundary conditions are implemented weakly and that the interior variables do not exactly satisfy boundary conditions. On the lower and left boundaries, we set Neumann boundary conditions, whereas we set Dirichlet conditions on the right and top boundaries.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_8.png"/>
</div>
  </td></tr>
</table>
<p>Next, we have a look at the post-processed solution, again at cycles 2, 3, 4, and 8. This is a discontinuous solution that is locally described by second order polynomials. While the solution does not look very good on the mesh of cycle two, it looks much better for cycles three and four. As shown by the convergence table below, we find that is also converges more quickly to the analytical solution.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_8.png"/>
</div>
  </td></tr>
</table>
<p>Finally, we look at the solution for \(p=3\) at cycle 2. Despite the coarse mesh with only 64 cells, the post-processed solution is similar in quality to the linear solution (not post-processed) at cycle 8 with 4,096 cells. This clearly shows the superiority of high order methods for smooth solutions.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_q3_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_q3_2.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="Convergencetables"></a></p><h4>Convergence tables</h4>
<p>When the program is run, it also outputs information about the respective steps and convergence tables with errors in the various components in the end. In 2D, the convergence tables look the following:</p>
<div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells dofs   val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01 2.207e+01   1.798e+01</div><div class="line">   31   170 9.874e+00 1.322e+01   9.798e+00</div><div class="line">   61   314 7.452e-01 3.793e+00   4.891e-01</div><div class="line">  121   634 3.240e-01 1.511e+00   2.616e-01</div><div class="line">  238  1198 8.585e-02 8.212e-01   1.808e-02</div><div class="line">  454  2290 4.802e-02 5.178e-01   2.195e-02</div><div class="line">  898  4378 2.561e-02 2.947e-01   4.318e-03</div><div class="line"> 1720  7864 1.306e-02 1.664e-01   2.978e-03</div><div class="line"> 3271 14638 7.025e-03 9.815e-02   1.075e-03</div><div class="line"> 6217 27214 4.119e-03 6.407e-02   9.975e-04</div><div class="line"></div><div class="line">Q1 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01    - 2.207e+01    - 1.798e+01    -</div><div class="line">   36   168 6.125e+00 2.66 9.472e+00 2.09 6.084e+00 2.67</div><div class="line">   64   288 9.785e-01 6.38 4.260e+00 2.78 7.102e-01 7.47</div><div class="line">  144   624 2.730e-01 3.15 1.866e+00 2.04 6.115e-02 6.05</div><div class="line">  256  1088 1.493e-01 2.10 1.046e+00 2.01 2.880e-02 2.62</div><div class="line">  576  2400 6.965e-02 1.88 4.846e-01 1.90 9.204e-03 2.81</div><div class="line"> 1024  4224 4.018e-02 1.91 2.784e-01 1.93 4.027e-03 2.87</div><div class="line"> 2304  9408 1.831e-02 1.94 1.264e-01 1.95 1.236e-03 2.91</div><div class="line"> 4096 16640 1.043e-02 1.96 7.185e-02 1.96 5.306e-04 2.94</div><div class="line"> 9216 37248 4.690e-03 1.97 3.228e-02 1.97 1.599e-04 2.96</div><div class="line"></div><div class="line">Q3 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16   160 3.613e-01    - 1.891e+00    - 3.020e-01    -</div><div class="line">   36   336 6.411e-02 4.26 5.081e-01 3.24 3.238e-02 5.51</div><div class="line">   64   576 3.480e-02 2.12 2.533e-01 2.42 5.277e-03 6.31</div><div class="line">  144  1248 8.297e-03 3.54 5.924e-02 3.58 6.330e-04 5.23</div><div class="line">  256  2176 2.254e-03 4.53 1.636e-02 4.47 1.403e-04 5.24</div><div class="line">  576  4800 4.558e-04 3.94 3.277e-03 3.96 1.844e-05 5.01</div><div class="line"> 1024  8448 1.471e-04 3.93 1.052e-03 3.95 4.378e-06 5.00</div><div class="line"> 2304 18816 2.956e-05 3.96 2.104e-04 3.97 5.750e-07 5.01</div><div class="line"> 4096 33280 9.428e-06 3.97 6.697e-05 3.98 1.362e-07 5.01</div><div class="line"> 9216 74496 1.876e-06 3.98 1.330e-05 3.99 1.788e-08 5.01</div></div><!-- fragment --><p>One can see the error reduction upon grid refinement, and for the cases where global refinement was performed, also the convergence rates. The quadratic convergence rates of Q1 elements in the \(L_2\) norm for both the scalar variable and the gradient variable is apparent, as is the cubic rate for the postprocessed scalar variable in the \(L_2\) norm. Note this distinctive feature of an HDG solution. In typical continuous finite elements, the gradient of the solution of order \(p\) converges at rate \(p\) only, as opposed to \(p+1\) for the actual solution. Even though superconvergence results for finite elements are also available (e.g. superconvergent patch recovery first introduced by Zienkiewicz and Zhu), these are typically limited to structured meshes and other special cases. For Q3 HDG variables, the scalar variable and gradient converge at fourth order and the postprocessed scalar variable at fifth order.</p>
<p>The same convergence rates are observed in 3d. </p><div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells   dofs    val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00 1.941e+01   6.102e+00</div><div class="line">    29     500 3.309e+00 1.023e+01   2.145e+00</div><div class="line">   113    1792 2.204e+00 1.023e+01   1.912e+00</div><div class="line">   379    5732 6.085e-01 5.008e+00   2.233e-01</div><div class="line">  1317   19412 1.543e-01 1.464e+00   4.196e-02</div><div class="line">  4579   64768 5.058e-02 5.611e-01   9.521e-03</div><div class="line"> 14596  199552 2.129e-02 3.122e-01   4.569e-03</div><div class="line"> 46180  611400 1.033e-02 1.622e-01   1.684e-03</div><div class="line">144859 1864212 5.007e-03 8.371e-02   7.364e-04</div><div class="line">451060 5684508 2.518e-03 4.562e-02   3.070e-04</div><div class="line"></div><div class="line">Q1 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>          grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00    - 1.941e+01     - 6.102e+00    -</div><div class="line">    27     432 5.491e+00 0.64 2.184e+01 -0.29 4.448e+00 0.78</div><div class="line">    64     960 3.646e+00 1.42 1.299e+01  1.81 3.306e+00 1.03</div><div class="line">   216    3024 1.595e+00 2.04 8.550e+00  1.03 1.441e+00 2.05</div><div class="line">   512    6912 6.922e-01 2.90 5.306e+00  1.66 2.511e-01 6.07</div><div class="line">  1728   22464 2.915e-01 2.13 2.490e+00  1.87 8.588e-02 2.65</div><div class="line">  4096   52224 1.684e-01 1.91 1.453e+00  1.87 4.055e-02 2.61</div><div class="line"> 13824  172800 7.972e-02 1.84 6.861e-01  1.85 1.335e-02 2.74</div><div class="line"> 32768  405504 4.637e-02 1.88 3.984e-01  1.89 5.932e-03 2.82</div><div class="line">110592 1354752 2.133e-02 1.92 1.830e-01  1.92 1.851e-03 2.87</div><div class="line"></div><div class="line">Q3 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     576 5.670e+00    - 1.868e+01    - 5.462e+00    -</div><div class="line">    27    1728 1.048e+00 4.16 6.988e+00 2.42 8.011e-01 4.73</div><div class="line">    64    3840 2.831e-01 4.55 2.710e+00 3.29 1.363e-01 6.16</div><div class="line">   216   12096 7.883e-02 3.15 7.721e-01 3.10 2.158e-02 4.55</div><div class="line">   512   27648 3.642e-02 2.68 3.305e-01 2.95 5.231e-03 4.93</div><div class="line">  1728   89856 8.546e-03 3.58 7.581e-02 3.63 7.640e-04 4.74</div><div class="line">  4096  208896 2.598e-03 4.14 2.313e-02 4.13 1.783e-04 5.06</div><div class="line"> 13824  691200 5.314e-04 3.91 4.697e-03 3.93 2.355e-05 4.99</div><div class="line"> 32768 1622016 1.723e-04 3.91 1.517e-03 3.93 5.602e-06 4.99</div><div class="line">110592 5419008 3.482e-05 3.94 3.055e-04 3.95 7.374e-07 5.00</div></div><!-- fragment --><p><a class="anchor" id="Comparisonwithcontinuousfiniteelements"></a></p><h3>Comparison with continuous finite elements</h3>
<p><a class="anchor" id="Resultsfor2D"></a></p><h4>Results for 2D</h4>
<p>The convergence tables verify the expected convergence rates stated in the introduction. Now, we want to show a quick comparison of the computational efficiency of the HDG method compared to a usual finite element (continuous Galkerin) method on the problem of this tutorial. Of course, stability aspects of the HDG method compared to continuous finite elements for transport-dominated problems are also important in practice, which is an aspect not seen on a problem with smooth analytic solution. In the picture below, we compare the \(L_2\) error as a function of the number of degrees of freedom (left) and of the computing time spent in the linear solver (right) for two space dimensions of continuous finite elements (CG) and the hybridized discontinuous Galerkin method presented in this tutorial. As opposed to the tutorial where we only use unpreconditioned BiCGStab, the times shown in the figures below use the Trilinos algebraic multigrid preconditioner in <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. For the HDG part, a wrapper around <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> for the trace variable has been used in order to utilize the block structure in the matrix on the finest level.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_plain.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The results in the graphs show that the HDG method is slower than continuous finite elements at \(p=1\), about equally fast for cubic elements and faster for sixth order elements. However, we have seen above that the HDG method actually produces solutions which are more accurate than what is represented in the original variables. Therefore, in the next two plots below we instead display the error of the post-processed solution for HDG (denoted by \(p=1^*\) for example). We now see a clear advantage of HDG for the same amount of work for both \(p=3\) and \(p=6\), and about the same quality for \(p=1\).</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_post.png" width="400"/>
</div>
  </td></tr>
</table>
<p>Since the HDG method actually produces results converging as \(h^{p+2}\), we should compare it to a continuous Galerkin solution with the same asymptotic convergence behavior, i.e., <a class="el" href="classFE__Q.html">FE_Q</a> with degree \(p+1\). If we do this, we get the convergence curves below. We see that CG with second order polynomials is again clearly better than HDG with linears. However, the advantage of HDG for higher orders remains.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The results are in line with properties of DG methods in general: Best performance is typically not achieved for linear elements, but rather at somewhat higher order, usually around \(p=3\). This is because of a volume-to-surface effect for discontinuous solutions with too much of the solution living on the surfaces and hence duplicating work when the elements are linear. Put in other words, DG methods are often most efficient when used at relatively high order, despite their focus on a discontinuous (and hence, seemingly low accurate) representation of solutions.</p>
<p><a class="anchor" id="Resultsfor3D"></a></p><h4>Results for 3D</h4>
<p>We now show the same figures in 3D: The first row shows the number of degrees of freedom and computing time versus the \(L_2\) error in the scalar variable \(u\) for CG and HDG at order \(p\), the second row shows the post-processed HDG solution instead of the original one, and the third row compares the post-processed HDG solution with CG at order \(p+1\). In 3D, the volume-to-surface effect makes the cost of HDG somewhat higher and the CG solution is clearly better than HDG for linears by any metric. For cubics, HDG and CG are of similar quality, whereas HDG is again more efficient for sixth order polynomials. One can alternatively also use the combination of <a class="el" href="classFE__DGP.html">FE_DGP</a> and <a class="el" href="classFE__FaceP.html">FE_FaceP</a> instead of (<a class="el" href="classFE__DGQ.html">FE_DGQ</a>, <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>), which do not use tensor product polynomials of degree \(p\) but Legendre polynomials of <em>complete</em> degree \(p\). There are fewer degrees of freedom on the skeleton variable for <a class="el" href="classFE__FaceP.html">FE_FaceP</a> for a given mesh size, but the solution quality (error vs. number of DoFs) is very similar to the results for <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_plain.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_post.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>One final note on the efficiency comparison: We tried to use general-purpose sparse matrix structures and similar solvers (optimal AMG preconditioners for both without particular tuning of the AMG parameters on any of them) to give a fair picture of the cost versus accuracy of two methods, on a toy example. It should be noted however that geometric multigrid (GMG) for continuous finite elements is about a factor four to five faster for \(p=3\) and \(p=6\). As of 2019, optimal-complexity iterative solvers for HDG are still under development in the research community. Also, there are other implementation aspects for CG available such as fast matrix-free approaches as shown in <a class="el" href="step_37.html">step-37</a> that make higher order continuous elements more competitive. Again, it is not clear to the authors of the tutorial whether similar improvements could be made for HDG. We refer to <a href="https://dx.doi.org/10.1137/16M110455X">Kronbichler and Wall (2018)</a> for a recent efficiency evaluation.</p>
<p><a class="anchor" id="Possibilitiesforimprovements"></a></p><h3>Possibilities for improvements</h3>
<p>As already mentioned in the introduction, one possibility is to implement another post-processing technique as discussed in the literature.</p>
<p>A second item that is not done optimally relates to the performance of this program, which is of course an issue in practical applications (weighing in also the better solution quality of (H)DG methods for transport-dominated problems). Let us look at the computing time of the tutorial program and the share of the individual components:</p>
<table align="center" class="doxtable">
<tr>
<th>&#160; </th><th>&#160; </th><th>Setup </th><th>Assemble </th><th>Solve </th><th>Trace reconstruct </th><th>Post-processing </th><th>Output  </th></tr>
<tr>
<th>&#160; </th><th>Total time </th><th colspan="6">Relative share  </th></tr>
<tr>
<td align="left">2D, Q1, cycle 9, 37,248 dofs </td><td align="center">5.34s </td><td align="center">0.7% </td><td align="center">1.2% </td><td align="center">89.5% </td><td align="center">0.9% </td><td align="center">2.3% </td><td align="center">5.4%  </td></tr>
<tr>
<td align="left">2D, Q3, cycle 9, 74,496 dofs </td><td align="center">22.2s </td><td align="center">0.4% </td><td align="center">4.3% </td><td align="center">84.1% </td><td align="center">4.1% </td><td align="center">3.5% </td><td align="center">3.6%  </td></tr>
<tr>
<td align="left">3D, Q1, cycle 7, 172,800 dofs </td><td align="center">9.06s </td><td align="center">3.1% </td><td align="center">8.9% </td><td align="center">42.7% </td><td align="center">7.0% </td><td align="center">20.6% </td><td align="center">17.7%  </td></tr>
<tr>
<td align="left">3D, Q3, cycle 7, 691,200 dofs </td><td align="center">516s </td><td align="center">0.6% </td><td align="center">34.5% </td><td align="center">13.4% </td><td align="center">32.8% </td><td align="center">17.1% </td><td align="center">1.5%  </td></tr>
</table>
<p>As can be seen from the table, the solver and assembly calls dominate the runtime of the program. This also gives a clear indication of where improvements would make the most sense:</p>
<ol>
<li>
<p class="startli">Better linear solvers: We use a BiCGStab iterative solver without preconditioner, where the number of iteration increases with increasing problem size (the number of iterations for Q1 elements and global refinements starts at 35 for the small sizes but increase up to 701 for the largest size). To do better, one could for example use an algebraic multigrid preconditioner from Trilinos, or some more advanced variants as the one discussed in <a href="https://dx.doi.org/10.1137/16M110455X">Kronbichler and Wall (2018)</a>. For diffusion-dominated problems such as the problem at hand with finer meshes, such a solver can be designed that uses the matrix-vector products from the more efficient <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> on the finest level, as long as we are not working in parallel with MPI. For MPI-parallelized computations, a standard <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> can be used.</p>
<p class="endli"></p>
</li>
<li>
Speed up assembly by pre-assembling parts that do not change from one cell to another (those that do neither contain variable coefficients nor mapping-dependent terms). </li>
</ol>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2013 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Martin Kronbichler, Technische Universität München,</span></div><div class="line"><span class="comment"> *         Scott T. Miller, The Pennsylvania State University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2exceptions_8h.html">deal.II/base/exceptions.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chunk__sparse__matrix_8h.html">deal.II/lac/chunk_sparse_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionBase</div><div class="line">  {</div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">    SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers] =</div><div class="line">      {<a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)};</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">    SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers] =</div><div class="line">      {<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">    SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers] = {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6, -0.5, -0.125),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5, -0.5, 0.5)};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1. / 5.;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordtype">double</span> sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">          sum +=</div><div class="line">            <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">          sum +=</div><div class="line">            (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">             std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) *</div><div class="line">             x_minus_xi);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SolutionAndGradient()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  v)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.size(), dim + 1);</div><div class="line">      Solution&lt;dim&gt;  solution;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad = solution.gradient(p);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        v[d] = -grad[d];</div><div class="line">      v[dim] = solution.value(p);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ConvectionVelocity()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection;</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> 1:</div><div class="line">            convection[0] = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 2:</div><div class="line">            convection[0] = p[1];</div><div class="line">            convection[1] = -p[0];</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 3:</div><div class="line">            convection[0] = p[1];</div><div class="line">            convection[1] = -p[0];</div><div class="line">            convection[2] = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line">      <span class="keywordflow">return</span> convection;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          convection = convection_velocity.value(p);</div><div class="line">      <span class="keywordtype">double</span>                  sum        = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">          sum +=</div><div class="line">            ((2 * dim - 2 * convection * x_minus_xi -</div><div class="line">              4 * x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) /</div><div class="line">             (this-&gt;width * this-&gt;width) *</div><div class="line">             std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>HDG</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> RefinementMode</div><div class="line">    {</div><div class="line">      global_refinement,</div><div class="line">      adaptive_refinement</div><div class="line">    };</div><div class="line"></div><div class="line">    HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> postprocess();</div><div class="line">    <span class="keywordtype">void</span> refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData;</div><div class="line">    <span class="keyword">struct </span>ScratchData;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PostProcessScratchData;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system_one_cell(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      ScratchData &amp;                                         scratch,</div><div class="line">      PerTaskData &amp;                                         task_data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> postprocess_one_cell(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      PostProcessScratchData &amp;                              scratch,</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        empty_data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe_local;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_local;</div><div class="line">    Vector&lt;double&gt;  solution_local;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>   fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    Vector&lt;double&gt;  solution;</div><div class="line">    Vector&lt;double&gt;  system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>     fe_u_post;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_u_post;</div><div class="line">    Vector&lt;double&gt;  solution_u_post;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">    <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  HDG&lt;dim&gt;::HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode)</div><div class="line">    : fe_local(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim, <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler_local(triangulation)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe_u_post(degree + 1)</div><div class="line">    , dof_handler_u_post(triangulation)</div><div class="line">    , refinement_mode(refinement_mode)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler_local.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_local);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    solution_local.reinit(dof_handler_local.n_dofs());</div><div class="line">    solution_u_post.reinit(dof_handler_u_post.n_dofs());</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt; boundary_functions;</div><div class="line">    Solution&lt;dim&gt;                                       solution_function;</div><div class="line">    boundary_functions[0] = &amp;solution_function;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>(dof_handler,</div><div class="line">                                         boundary_functions,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a>());</div><div class="line">    }</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_vector;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">    PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">      : cell_matrix(n_dofs, n_dofs)</div><div class="line">      , cell_vector(n_dofs)</div><div class="line">      , dof_indices(n_dofs)</div><div class="line">      , trace_reconstruct(trace_reconstruct)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">    Vector&lt;double&gt;     l_rhs;</div><div class="line">    Vector&lt;double&gt;     tmp_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; q_phi;</div><div class="line">    std::vector&lt;double&gt;         q_phi_div;</div><div class="line">    std::vector&lt;double&gt;         u_phi;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_phi_grad;</div><div class="line">    std::vector&lt;double&gt;         tr_phi;</div><div class="line">    std::vector&lt;double&gt;         trace_values;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_local_support_on_face;</div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_support_on_face;</div><div class="line"></div><div class="line">    ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">    RightHandSide&lt;dim&gt;      right_hand_side;</div><div class="line">    <span class="keyword">const</span> Solution&lt;dim&gt;     exact_solution;</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp;   face_quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_face_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">      : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">      , fe_face_values_local(fe_local,</div><div class="line">                             face_quadrature_formula,</div><div class="line">                             local_face_flags)</div><div class="line">      , fe_face_values(fe, face_quadrature_formula, flags)</div><div class="line">      , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">      , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , l_rhs(fe_local.n_dofs_per_cell())</div><div class="line">      , tmp_rhs(fe_local.n_dofs_per_cell())</div><div class="line">      , q_phi(fe_local.n_dofs_per_cell())</div><div class="line">      , q_phi_div(fe_local.n_dofs_per_cell())</div><div class="line">      , u_phi(fe_local.n_dofs_per_cell())</div><div class="line">      , u_phi_grad(fe_local.n_dofs_per_cell())</div><div class="line">      , tr_phi(fe.n_dofs_per_cell())</div><div class="line">      , trace_values(face_quadrature_formula.size())</div><div class="line">      , fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">      , fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">      , exact_solution()</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_local.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">              fe_local_support_on_face[face_no].push_back(i);</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">              fe_support_on_face[face_no].push_back(i);</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">      : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                        sd.fe_values_local.get_quadrature(),</div><div class="line">                        sd.fe_values_local.get_update_flags())</div><div class="line">      , fe_face_values_local(sd.fe_face_values_local.get_fe(),</div><div class="line">                             sd.fe_face_values_local.get_quadrature(),</div><div class="line">                             sd.fe_face_values_local.get_update_flags())</div><div class="line">      , fe_face_values(sd.fe_face_values.get_fe(),</div><div class="line">                       sd.fe_face_values.get_quadrature(),</div><div class="line">                       sd.fe_face_values.get_update_flags())</div><div class="line">      , ll_matrix(sd.ll_matrix)</div><div class="line">      , lf_matrix(sd.lf_matrix)</div><div class="line">      , fl_matrix(sd.fl_matrix)</div><div class="line">      , tmp_matrix(sd.tmp_matrix)</div><div class="line">      , l_rhs(sd.l_rhs)</div><div class="line">      , tmp_rhs(sd.tmp_rhs)</div><div class="line">      , q_phi(sd.q_phi)</div><div class="line">      , q_phi_div(sd.q_phi_div)</div><div class="line">      , u_phi(sd.u_phi)</div><div class="line">      , u_phi_grad(sd.u_phi_grad)</div><div class="line">      , tr_phi(sd.tr_phi)</div><div class="line">      , trace_values(sd.trace_values)</div><div class="line">      , fe_local_support_on_face(sd.fe_local_support_on_face)</div><div class="line">      , fe_support_on_face(sd.fe_support_on_face)</div><div class="line">      , exact_solution()</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         u_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_gradients;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs;</div><div class="line">    Vector&lt;double&gt; cell_sol;</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">      : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">      , fe_values(fe, quadrature_formula, flags)</div><div class="line">      , u_values(quadrature_formula.size())</div><div class="line">      , u_gradients(quadrature_formula.size())</div><div class="line">      , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">      , cell_rhs(fe.n_dofs_per_cell())</div><div class="line">      , cell_sol(fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">      : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                        sd.fe_values_local.get_quadrature(),</div><div class="line">                        sd.fe_values_local.get_update_flags())</div><div class="line">      , fe_values(sd.fe_values.get_fe(),</div><div class="line">                  sd.fe_values.get_quadrature(),</div><div class="line">                  sd.fe_values.get_update_flags())</div><div class="line">      , u_values(sd.u_values)</div><div class="line">      , u_gradients(sd.u_gradients)</div><div class="line">      , cell_matrix(sd.cell_matrix)</div><div class="line">      , cell_rhs(sd.cell_rhs)</div><div class="line">      , cell_sol(sd.cell_sol)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PerTaskData task_data(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(), trace_reconstruct);</div><div class="line">    ScratchData scratch(fe,</div><div class="line">                        fe_local,</div><div class="line">                        quadrature_formula,</div><div class="line">                        face_quadrature_formula,</div><div class="line">                        local_flags,</div><div class="line">                        local_face_flags,</div><div class="line">                        flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    *<span class="keyword">this</span>,</div><div class="line">                    &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                    &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                    scratch,</div><div class="line">                    task_data);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system_one_cell(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    ScratchData &amp;                                         scratch,</div><div class="line">    PerTaskData &amp;                                         task_data)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                            cell-&gt;level(),</div><div class="line">                                                            cell-&gt;index(),</div><div class="line">                                                            &amp;dof_handler_local);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch.fe_values_local.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">      scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell =</div><div class="line">      scratch.fe_values_local.get_fe().n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">    scratch.ll_matrix = 0;</div><div class="line">    scratch.l_rhs     = 0;</div><div class="line">    <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">      {</div><div class="line">        scratch.lf_matrix     = 0;</div><div class="line">        scratch.fl_matrix     = 0;</div><div class="line">        task_data.cell_matrix = 0;</div><div class="line">        task_data.cell_vector = 0;</div><div class="line">      }</div><div class="line">    scratch.fe_values_local.reinit(loc_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value = scratch.right_hand_side.value(</div><div class="line">          scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection = scratch.convection_velocity.value(</div><div class="line">          scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; loc_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);</div><div class="line">            scratch.q_phi_div[k] =</div><div class="line">              scratch.fe_values_local[fluxes].divergence(k, q);</div><div class="line">            scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);</div><div class="line">            scratch.u_phi_grad[k] =</div><div class="line">              scratch.fe_values_local[scalar].gradient(k, q);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; loc_dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; loc_dofs_per_cell; ++j)</div><div class="line">              scratch.ll_matrix(i, j) +=</div><div class="line">                (scratch.q_phi[i] * scratch.q_phi[j] -</div><div class="line">                 scratch.q_phi_div[i] * scratch.u_phi[j] +</div><div class="line">                 scratch.u_phi[i] * scratch.q_phi_div[j] -</div><div class="line">                 (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]) *</div><div class="line">                JxW;</div><div class="line">            scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">      {</div><div class="line">        scratch.fe_face_values_local.reinit(loc_cell, face_no);</div><div class="line">        scratch.fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">          scratch.fe_face_values.get_function_values(solution,</div><div class="line">                                                     scratch.trace_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>     JxW = scratch.fe_face_values.JxW(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">              scratch.fe_face_values.quadrature_point(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal =</div><div class="line">              scratch.fe_face_values.normal_vector(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection =</div><div class="line">              scratch.convection_velocity.value(quadrature_point);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. + <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(convection * normal));</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">                 k &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                 ++k)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk =</div><div class="line">                  scratch.fe_local_support_on_face[face_no][k];</div><div class="line">                scratch.q_phi[k] =</div><div class="line">                  scratch.fe_face_values_local[fluxes].value(kk, q);</div><div class="line">                scratch.u_phi[k] =</div><div class="line">                  scratch.fe_face_values_local[scalar].value(kk, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">                     k &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                     ++k)</div><div class="line">                  scratch.tr_phi[k] = scratch.fe_face_values.shape_value(</div><div class="line">                    scratch.fe_support_on_face[face_no][k], q);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                     i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                       j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                        scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                        scratch.fe_support_on_face[face_no][j];</div><div class="line">                      scratch.lf_matrix(ii, jj) +=</div><div class="line">                        ((scratch.q_phi[i] * normal +</div><div class="line">                          (convection * normal - tau_stab) * scratch.u_phi[i]) *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line"></div><div class="line">                      scratch.fl_matrix(jj, ii) -=</div><div class="line">                        ((scratch.q_phi[i] * normal +</div><div class="line">                          tau_stab * scratch.u_phi[i]) *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                     i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                       j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                        scratch.fe_support_on_face[face_no][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                        scratch.fe_support_on_face[face_no][j];</div><div class="line">                      task_data.cell_matrix(ii, jj) +=</div><div class="line">                        ((convection * normal - tau_stab) * scratch.tr_phi[i] *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">                    (cell-&gt;face(face_no)-&gt;boundary_id() == 1))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">                      -scratch.exact_solution.gradient(quadrature_point) *</div><div class="line">                        normal +</div><div class="line">                      convection * normal *</div><div class="line">                        scratch.exact_solution.value(quadrature_point);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                         i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                         ++i)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                          scratch.fe_support_on_face[face_no][i];</div><div class="line">                        task_data.cell_vector(ii) +=</div><div class="line">                          scratch.tr_phi[i] * neumann_value * JxW;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                 i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                 ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                   j &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                   ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][j];</div><div class="line">                  scratch.ll_matrix(ii, jj) +=</div><div class="line">                    tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;</div><div class="line">                }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                   i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                   ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                  scratch.l_rhs(ii) -=</div><div class="line">                    (scratch.q_phi[i] * normal +</div><div class="line">                     scratch.u_phi[i] * (convection * normal - tau_stab)) *</div><div class="line">                    scratch.trace_values[q] * JxW;</div><div class="line">                }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    scratch.ll_matrix.gauss_jordan();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">        scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">        scratch.tmp_matrix.mmult(task_data.cell_matrix,</div><div class="line">                                 scratch.lf_matrix,</div><div class="line">                                 <span class="keyword">true</span>);</div><div class="line">        cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">        loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      constraints.distribute_local_to_global(data.cell_matrix,</div><div class="line">                                             data.cell_vector,</div><div class="line">                                             data.dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                  solver_control(system_matrix.m() * 10,</div><div class="line">                                 1e-11 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span></div><div class="line">              &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0, 0, 0, 1);</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    assemble_system(<span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_u_post.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      PostProcessScratchData scratch(</div><div class="line">        fe_u_post, fe_local, quadrature_formula, local_flags, flags);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">        dof_handler_u_post.begin_active(),</div><div class="line">        dof_handler_u_post.end(),</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">               PostProcessScratchData &amp;                              scratch,</div><div class="line">               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        data) {</div><div class="line">          this-&gt;postprocess_one_cell(cell, scratch, data);</div><div class="line">        },</div><div class="line">        std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">        scratch,</div><div class="line">        0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select(dim, dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                      solution_local,</div><div class="line">                                      SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;value_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select(</div><div class="line">      std::pair&lt;unsigned int, unsigned int&gt;(0, dim), dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                      solution_local,</div><div class="line">                                      SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;gradient_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_u_post,</div><div class="line">                                      solution_u_post,</div><div class="line">                                      Solution&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 3),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> post_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>, L2_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>, grad_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess_one_cell(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    PostProcessScratchData &amp;                              scratch,</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                            cell-&gt;level(),</div><div class="line">                                                            cell-&gt;index(),</div><div class="line">                                                            &amp;dof_handler_local);</div><div class="line"></div><div class="line">    scratch.fe_values_local.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(loc_cell);</div><div class="line">    scratch.fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line"></div><div class="line">    scratch.fe_values_local[scalar].get_function_values(solution_local,</div><div class="line">                                                        scratch.u_values);</div><div class="line">    scratch.fe_values_local[fluxes].get_function_values(solution_local,</div><div class="line">                                                        scratch.u_gradients);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            sum = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              sum += (scratch.fe_values.shape_grad(i, q) *</div><div class="line">                      scratch.fe_values.shape_grad(j, q)) *</div><div class="line">                     scratch.fe_values.JxW(q);</div><div class="line">            scratch.cell_matrix(i, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">          }</div><div class="line"></div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) *</div><div class="line">                 scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_rhs(i) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_matrix(0, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      }</div><div class="line">    {</div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        sum += scratch.u_values[q] * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_rhs(0) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    scratch.cell_matrix.gauss_jordan();</div><div class="line">    scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">    cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    std::string filename;</div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> global_refinement:</div><div class="line">          filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">          filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    std::string face_out(filename);</div><div class="line">    face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">    filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">    filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">    filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; names(dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">    names.emplace_back(<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      component_interpretation(</div><div class="line">        dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    component_interpretation[dim] =</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_local,</div><div class="line">                             solution_local,</div><div class="line">                             names,</div><div class="line">                             component_interpretation);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; post_name(1, <span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_u_post,</div><div class="line">                             solution_u_post,</div><div class="line">                             post_name,</div><div class="line">                             post_comp_type);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">    face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">    face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">    face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream face_output(face_out);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a>        data_out_face(<span class="keyword">false</span>);</div><div class="line">    std::vector&lt;std::string&gt; face_name(1, <span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    data_out_face.add_data_vector(dof_handler,</div><div class="line">                                  solution,</div><div class="line">                                  face_name,</div><div class="line">                                  face_component_type);</div><div class="line"></div><div class="line">    data_out_face.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out_face.write_vtk(face_output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 2, -1, 1);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> global_refinement:</div><div class="line">            {</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">              <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation,</div><div class="line">                                                   2 + (cycle % 2),</div><div class="line">                                                   -1,</div><div class="line">                                                   1);</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim + cycle / 2);</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">            {</div><div class="line">              Vector&lt;float&gt; estimated_error_per_cell(</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">              <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">              std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">                neumann_boundary;</div><div class="line">              <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler_local,</div><div class="line">                                                 <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                                 neumann_boundary,</div><div class="line">                                                 solution_local,</div><div class="line">                                                 estimated_error_per_cell,</div><div class="line">                                                 fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(</div><div class="line">                                                   scalar));</div><div class="line"></div><div class="line">              <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">                triangulation, estimated_error_per_cell, 0.3, 0.);</div><div class="line"></div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(0) - (-1)) &lt; 1e-12) ||</div><div class="line">              (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HDG&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 10; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        refine_grid(cycle);</div><div class="line">        setup_system();</div><div class="line">        assemble_system(<span class="keyword">false</span>);</div><div class="line">        solve();</div><div class="line">        postprocess();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a> , <a class="el" href="step_9.html">step-9</a> , <a class="el" href="step_61.html">step-61</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HybridizablediscontinuousGalerkinmethods"> Hybridizable discontinuous Galerkin methods </a><a href="#HybridizablediscontinuousGalerkinmethods"> Hybridizable discontinuous Galerkin methods </a>
      <ul>
        <li><a href="#Reducingthesizeofthelinearsystem"> Reducing the size of the linear system </a><a href="#Reducingthesizeofthelinearsystem"> Reducing the size of the linear system </a>
        <li><a href="#RelationwithStaticCondensation"> Relation with Static Condensation </a><a href="#RelationwithStaticCondensation"> Relation with Static Condensation </a>
        <li><a href="#Solutionqualityandratesofconvergence"> Solution quality and rates of convergence</a><a href="#Solutionqualityandratesofconvergence"> Solution quality and rates of convergence</a>
        <li><a href="#Alternativeapproaches"> Alternative approaches </a><a href="#Alternativeapproaches"> Alternative approaches </a>
      </ul>
        <li><a href="#HDGappliedtotheconvectiondiffusionproblem"> HDG applied to the convection-diffusion problem </a><a href="#HDGappliedtotheconvectiondiffusionproblem"> HDG applied to the convection-diffusion problem </a>
      <ul>
        <li><a href="#Postprocessingandsuperconvergence"> Post-processing and super-convergence </a><a href="#Postprocessingandsuperconvergence"> Post-processing and super-convergence </a>
      </ul>
        <li><a href="#Problemspecificdata"> Problem specific data </a><a href="#Problemspecificdata"> Problem specific data </a>
        <li><a href="#Implementation"> Implementation </a><a href="#Implementation"> Implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#TheHDGsolverclass">The HDG solver class</a><a href="#TheHDGsolverclass">The HDG solver class</a>
        <li><a href="#TheHDGclassimplementation">The HDG class implementation</a><a href="#TheHDGclassimplementation">The HDG class implementation</a>
      <ul>
        <li><a href="#Constructor">Constructor</a><a href="#Constructor">Constructor</a>
        <li><a href="#HDGsetup_system">HDG::setup_system</a><a href="#HDGsetup_system">HDG::setup_system</a>
        <li><a href="#HDGPerTaskData">HDG::PerTaskData</a><a href="#HDGPerTaskData">HDG::PerTaskData</a>
        <li><a href="#HDGScratchData">HDG::ScratchData</a><a href="#HDGScratchData">HDG::ScratchData</a>
        <li><a href="#HDGPostProcessScratchData">HDG::PostProcessScratchData</a><a href="#HDGPostProcessScratchData">HDG::PostProcessScratchData</a>
        <li><a href="#HDGassemble_system">HDG::assemble_system</a><a href="#HDGassemble_system">HDG::assemble_system</a>
        <li><a href="#HDGassemble_system_one_cell">HDG::assemble_system_one_cell</a><a href="#HDGassemble_system_one_cell">HDG::assemble_system_one_cell</a>
        <li><a href="#HDGcopy_local_to_global">HDG::copy_local_to_global</a><a href="#HDGcopy_local_to_global">HDG::copy_local_to_global</a>
        <li><a href="#HDGsolve">HDG::solve</a><a href="#HDGsolve">HDG::solve</a>
        <li><a href="#HDGpostprocess">HDG::postprocess</a><a href="#HDGpostprocess">HDG::postprocess</a>
        <li><a href="#HDGpostprocess_one_cell">HDG::postprocess_one_cell</a><a href="#HDGpostprocess_one_cell">HDG::postprocess_one_cell</a>
        <li><a href="#HDGoutput_results">HDG::output_results</a><a href="#HDGoutput_results">HDG::output_results</a>
        <li><a href="#HDGrefine_grid">HDG::refine_grid</a><a href="#HDGrefine_grid">HDG::refine_grid</a>
        <li><a href="#HDGrun">HDG::run</a><a href="#HDGrun">HDG::run</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a><a href="#Programoutput">Program output</a>
      <ul>
        <li><a href="#Convergencetables">Convergence tables</a><a href="#Convergencetables">Convergence tables</a>
      </ul>
        <li><a href="#Comparisonwithcontinuousfiniteelements">Comparison with continuous finite elements</a><a href="#Comparisonwithcontinuousfiniteelements">Comparison with continuous finite elements</a>
      <ul>
        <li><a href="#Resultsfor2D">Results for 2D</a><a href="#Resultsfor2D">Results for 2D</a>
        <li><a href="#Resultsfor3D">Results for 3D</a><a href="#Resultsfor3D">Results for 3D</a>
      </ul>
        <li><a href="#Possibilitiesforimprovements">Possibilities for improvements</a><a href="#Possibilitiesforimprovements">Possibilities for improvements</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em> This program was contributed by Martin Kronbichler and Scott Miller. </em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program presents the implementation of a hybridizablediscontinuous Galkerin method for the convection-diffusion equation. <a class="anchor" id="HybridizablediscontinuousGalerkinmethods"></a></p><h3>Hybridizable discontinuous Galerkin methods </h3>
<p>One common argument against the use of discontinuous Galerkin elementsis the large number of globally coupled degrees of freedom that onemust solve in an implicit system. This is because, unlike continuous finiteelements, in typical discontinuous elements there is one degree of freedom ateach vertex <em>for each of the adjacent elements</em>, rather than just one,and similarly for edges and faces. As an example of how fast the number ofunknowns grows, consider the <a class="el" href="classFE__DGPMonomial.html">FE_DGPMonomial</a> basis: eachscalar solution component is represented by polynomials of degree \(p\) with \((1/\text{dim}!) \prod_{i=1}^{\text{dim}}(p+i)\) degrees of freedom perelement. Typically, all degrees of freedom in an element are coupledto all of the degrees of freedom in the adjacent elements. The resultingdiscrete equations yield very large linear systems very quickly, especiallyfor systems of equations in 2 or 3 dimensions. <a class="anchor" id="Reducingthesizeofthelinearsystem"></a></p><h4>Reducing the size of the linear system </h4>
<p>To alleviate the computational cost of solving such large linear systems,the hybridizable discontinuous Galerkin (HDG) methodology was introducedby Cockburn and co-workers (see the references in the recent HDG overviewarticle by Nguyen and Peraire <b>[Ngu2012]</b> ). The HDG method achieves this goal by formulating the mathematical problem usingDirichlet-to-Neumann mappings. The partial differential equations are firstwritten as a first order system, and each field is then discretized via a DGmethod. At this point, the single-valued "trace" values on the skeleton of themesh, i.e., element faces, are taken to be independent unknown quantities.This yields unknowns in the discrete formulation that fall into two categories:</p>
<ul>
<li>Face unknowns that only couple with the cell unknowns from both sides of the face;</li>
<li>Cell unknowns that only couple with the cell and face unknowns defined within the same cell. Crucially, no cell interior degree of freedom on one cell ever couples to any interior cell degree of freedom of a different cell. The Dirichlet-to-Neumann map concept then permits the following solution procedure: <ol>
<li>
Use local element interior data to enforce a Neumann condition on theskeleton of the triangulation. The global problem is then to solve for thetrace values, which are the only globally coupled unknowns. </li>
<li>
Use the known skeleton values as Dirichlet data for solving localelement-level solutions. This is known as the 'local solver', and is an<em>embarrassingly parallel</em> element-by-element solution process. </li>
</ol>
<a class="anchor" id="RelationwithStaticCondensation"></a><h4>Relation with Static Condensation </h4>
</li>
</ul>
<p>The above procedure also has a linear algebra interpretation&mdash;referred toas <em>static condensation</em>&mdash;that was exploited to reduce the size of theglobal linear system by Guyan in the context of continuous Finite Elements <b>[G65]</b> , and by Fraeijs de Veubeke for mixed methods <b>[F65]</b> . In thelatter case (mixed formulation), the system reduction was achieved through theuse of discontinuous fluxes combined with the introduction of an additionalauxiliary <em>hybrid</em> variable that approximates the trace of the unknownat the boundary of every element. This procedure became known as hybridizationand&mdash;by analogy&mdash;is the reason why the local discontinuous Galerkin methodintroduced by Cockburn, Gopalakrishnan, and Lazarov in 2009 <b>[CGL2009]</b> , andsubsequently developed by their collaborators, eventually came to be known asthe <em>hybridizable discontinuous Galerkin</em> (HDG) method. Let us write the complete linear system associated to the HDG problem as ablock system with the discrete DG (cell interior) variables \(U\) as first blockand the skeleton (face) variables \(\Lambda\) as the second block: </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} A &amp; B \\ C &amp; D \end{pmatrix} \begin{pmatrix} U \\ \Lambda \end{pmatrix} = \begin{pmatrix} F \\ G \end{pmatrix}. \end{eqnarray*}
</p>
<p> Our aim is now to eliminate the \(U\) block with a Schur complementapproach similar to <a class="el" href="step_20.html">step-20</a> , which results in the following two steps: </p><p class="formulaDsp">
\begin{eqnarray*} (D - C A^{-1} B) \Lambda &amp;=&amp; G - C A^{-1} F, \\ A U &amp;=&amp; F - B \Lambda. \end{eqnarray*}
</p>
<p> The point is that the presence of \(A^{-1}\) is not a problem because \(A\) is ablock diagonal matrix where each block corresponds to one cell and istherefore easy enough to invert.The coupling to other cells is introduced by the matrices \(B\) and \(C\) over the skeleton variable. The block-diagonality of \(A\) and the structure in \(B\) and \(C\) allow us to invert thematrix \(A\) element by element (the local solution of the Dirichletproblem) and subtract \(CA^{-1}B\) from \(D\) . The steps in the Dirichlet-to-Neumannmap concept hence correspond to </p><ol>
<li>
constructing the Schur complement matrix \(D-C A^{-1} B\) and right hand side \(G - C A^{-1} F\) <em>locally on each cell</em> and inserting the contribution into the global trace matrix in the usual way, </li>
<li>
solving the Schur complement system for \(\Lambda\) , and </li>
<li>
solving for \(U\) using the second equation, given \(\Lambda\) . </li>
</ol>
<p><a class="anchor" id="Solutionqualityandratesofconvergence"></a></p><h4>Solution quality and rates of convergence</h4>
<p>Another criticism of traditional DG methods is that the approximate fluxesconverge suboptimally. The local HDG solutions can be shown to convergeas \(\mathcal{O}(h^{p+1})\) , i.e., at optimal order. Additionally, asuper-convergence property can be used to post-process a new approximatesolution that converges at the rate \(\mathcal{O}(h^{p+2})\) .</p>
<p><a class="anchor" id="Alternativeapproaches"></a></p><h4>Alternative approaches </h4>
<p>The hybridizable discontinuous Galerkin method is only one way inwhich the problems of the discontinuous Galerkin method can beaddressed. Another idea is what is called the "weak Galerkin"method. It is explored in <a class="el" href="step_61.html">step-61</a> .</p>
<p><a class="anchor" id="HDGappliedtotheconvectiondiffusionproblem"></a></p><h3>HDG applied to the convection-diffusion problem </h3>
<p>The HDG formulation used for this example is taken from <br />
 <b> N.C. Nguyen, J. Peraire, B. Cockburn: <em>An implicit high-order hybridizable discontinuous Galerkin method for linear convection–diffusion equations</em><em>An implicit high-order hybridizable discontinuous Galerkin method for linear convection–diffusion equations</em>, Journal of Computational <a class="el" href="namespacePhysics.html">Physics</a>, 2009, 228:9, 3232-3254. <a href="http://dx.doi.org/10.1016/j.jcp.2009.01.030">[DOI]</a><a href="http://dx.doi.org/10.1016/j.jcp.2009.01.030">[DOI]</a> </b> We consider the convection-diffusion equation over the domain \(\Omega\) with Dirichlet boundary \(\partial \Omega_D\) and Neumann boundary \(\partial \Omega_N\) : </p><p class="formulaDsp">
\begin{eqnarray*} \nabla \cdot (\mathbf{c} u) - \nabla \cdot (\kappa \nabla u) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{c} u - \kappa \nabla u)\cdot \mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}
</p>
<p>Introduce the auxiliary variable \(\mathbf{q}=-\kappa \nabla u\) and rewritethe above equation as the first order system: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{q} + \kappa \nabla u &amp;=&amp; 0, \quad \text{ in } \Omega, \\ \nabla \cdot (\mathbf{c} u + \mathbf{q}) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{q} + \mathbf{c}u)\cdot\mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}
</p>
<p>We multiply these equations by the weight functions \(\mathbf{v}, w\) and integrate by parts over every element \(K\) to obtain: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf{v}, \kappa^{-1} \mathbf{q})_K - (\nabla\cdot\mathbf{v}, u)_K + \left&lt;\mathbf{v}\cdot\mathbf{n}, {\hat{u}}\right&gt;_{\partial K} &amp;=&amp; 0, \\ - (\nabla w, \mathbf{c} u + \mathbf{q})_K + \left&lt;w, (\widehat{\mathbf{c} u}+{\hat{\mathbf{q}}})\cdot\mathbf{n}\right&gt;_{\partial K} &amp;=&amp; (w,f)_K. \end{eqnarray*}
</p>
<p>The terms decorated with a hat denote the numerical traces (also commonly referredto as numerical fluxes). They are approximationsto the interior values on the boundary of the element. To ensure conservation,these terms must be single-valued on any given element edge \(\partial K\) eventhough, with discontinuous shape functions, there may of course be multiplevalues coming from the cells adjacent to an interface.We eliminate the numerical trace \(\hat{\mathbf{q}}\) by using traces of the form: </p><p class="formulaDsp">
\begin{eqnarray*} \widehat{\mathbf{c} u}+\hat{\mathbf{q}} = \mathbf{c}\hat{u} + \mathbf{q} + \tau(u - \hat{u})\mathbf{n} \quad \text{ on } \partial K. \end{eqnarray*}
</p>
<p>The variable \(\hat {u}\) is introduced as an additional independent variableand is the one for which we finally set up a globally coupled linearsystem. As mentioned above, it is defined on the element faces anddiscontinuous from one face to another wherever faces meet (atvertices in 2d, and at edges and vertices in 3d).Values for \(u\) and \(\mathbf{q}\) appearing in the numerical trace functionare taken to be the cell's interior solution restrictedto the boundary \(\partial K\) . The local stabilization parameter \(\tau\) has effects on stability and accuracyof HDG solutions; see the literature for a further discussion. A stabilizationparameter of unity is reported to be the choice which gives best results. Astabilization parameter \(\tau\) that tends to infinity prohibits jumps in thesolution over the element boundaries, making the HDG solution approach theapproximation with continuous finite elements. In the program below, we choosethe stabilization parameter as </p><p class="formulaDsp">
\begin{eqnarray*} \tau = \frac{\kappa}{\ell} + |\mathbf{c} \cdot \mathbf{n}| \end{eqnarray*}
</p>
<p> where we set the diffusion \(\kappa=1\) and the diffusion length scale to \(\ell = \frac{1}{5}\) . The trace/skeleton variables in HDG methods are single-valued on elementfaces. As such, they must strongly represent the Dirichlet data on \(\partial\Omega_D\) . This means that </p><p class="formulaDsp">
\begin{equation*} \hat{u}|_{\partial \Omega_D} = g_D, \end{equation*}
</p>
<p> where the equal sign actually means an \(L_2\) projection of the boundaryfunction \(g\) onto the space of the face variables (e.g. linear functions onthe faces). This constraint is then applied to the skeleton variable \(\hat{u}\) using inhomogeneous constraints by the method <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>. Summing the elementalcontributions across all elements in the triangulation, enforcing the normalcomponent of the numerical flux, and integrating by partson the equation weighted by \(w\) , we arrive at the final form of the problem:Find \((\mathbf{q}_h, u_h, \hat{u}_h) \in \mathcal{V}_h^p \times \mathcal{W}_h^p \times \mathcal{M}_h^p\) such that </p><p class="formulaDsp">
\begin{align*} (\mathbf{v}, \kappa^{-1} \mathbf{q}_h)_{\mathcal{T}} - ( \nabla\cdot\mathbf{v}, u_h)_{\mathcal{T}} + \left&lt;\mathbf{v}\cdot\mathbf{n}, \hat{u}_h\right&gt;_{\partial\mathcal{T}} &amp;= 0, \quad &amp;&amp;\forall \mathbf{v} \in \mathcal{V}_h^p, \\ - (\nabla w, \mathbf{c} u_h)_{\mathcal{T}} + (w, \nabla \cdot \mathbf{q}_h)_{\mathcal{T}} + (w, (\mathbf{c}\cdot\mathbf{n}) \hat{u}_h)_{\partial \mathcal{T}} + \left&lt;w, \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= (w, f)_{\mathcal{T}}, \quad &amp;&amp;\forall w \in \mathcal{W}_h^p, \\ \left&lt; \mu, \hat{u}_h\mathbf{c} \cdot \mathbf{n} + \mathbf{q}_h\cdot \mathbf{n} + \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= \left&lt;\mu, g_N\right&gt;_{\partial\Omega_N}, \quad &amp;&amp;\forall \mu \in \mathcal{M}_h^p. \end{align*}
</p>
<p>The unknowns \((\mathbf{q}_h, u_h)\) are referred to as local variables; they arerepresented as standard DG variables. The unknown \(\hat{u}_h\) is the skeletonvariable which has support on the codimension-1 surfaces (faces) of the mesh. We use the notation \((\cdot, \cdot)_{\mathcal{T}} = \sum_K (\cdot, \cdot)_K\) to denote the sum of integrals over all cells and \(\left&lt;\cdot, \cdot\right&gt;_{\partial \mathcal{T}} = \sum_K \left&lt;\cdot, \cdot\right&gt;_{\partial K}\) to denote integration over all faces of all cells,i.e., interior faces are visited twice, once from each side and withthe corresponding normal vectors. When combining the contribution fromboth elements sharing a face, the above equation yields terms familiarfrom the DG method, with jumps of the solution over the cell boundaries. In the equation above, the space \(\mathcal {W}_h^{p}\) for the scalar variable \(u_h\) is defined as the space of functions that are tensorproduct polynomials of degree \(p\) on each cell and discontinuous over theelement boundaries \(\mathcal Q_{-p}\) , i.e., the space described by <code>FE_DGQ&lt;dim&gt;(p)</code> . The space for the gradient or flux variable \(\mathbf{q}_i\) is a vector element space where each component isa locally polynomial and discontinuous \(\mathcal Q_{-p}\) . In the code below,we collect these two local parts together in one <a class="el" href="classFESystem.html">FESystem</a> where the first <code>dim</code> components denote the gradient part and the last scalar componentcorresponds to the scalar variable. For the skeleton component \(\hat{u}_h\) , wedefine a space that consists of discontinuous tensor product polynomials thatlive on the element faces, which in deal.II is implemented by the classFE_FaceQ. This space is otherwise similar to <a class="el" href="classFE__DGQ.html">FE_DGQ</a>, i.e., the solutionfunction is not continuous between two neighboring faces, see also the resultssection below for an illustration. In the weak form given above, we can note the following coupling patterns: </p><ol>
<li>
The matrix \(A\) consists of local-local coupling terms. These arise when the local weighting functions \((\mathbf{v}, w)\) multiply the local solution terms \((\mathbf{q}_h, u_h)\) . Because the elements are discontinuous, \(A\) is block diagonal. </li>
<li>
The matrix \(B\) represents the local-face coupling. These are the terms with weighting functions \((\mathbf{v}, w)\) multiplying the skeleton variable \(\hat{u}_h\) . </li>
<li>
The matrix \(C\) represents the face-local coupling, which involves the weighting function \(\mu\) multiplying the local solutions \((\mathbf{q}_h, u_h)\) . </li>
<li>
The matrix \(D\) is the face-face coupling; terms involve both \(\mu\) and \(\hat{u}_h\) . </li>
</ol>
<p><a class="anchor" id="Postprocessingandsuperconvergence"></a></p><h4>Post-processing and super-convergence </h4>
<p>One special feature of the HDG methods is that they typically allow forconstructing an enriched solution that gains accuracy. This post-processingtakes the HDG solution in an element-by-element fashion and combines it suchthat one can get \(\mathcal O(h^{p+2})\) order of accuracy when usingpolynomials of degree \(p\) . For this to happen, there are two necessaryingredients: </p><ol>
<li>
The computed solution gradient \(\mathbf{q}_h\) converges at optimal rate, i.e., \(\mathcal{O}(h^{p+1})\) . </li>
<li>
The cell-wise average of the scalar part of the solution, \(\frac{(1,u_h)_K}{\text{vol}(K)}\) , super-converges at rate \(\mathcal{O}(h^{p+2})\) . </li>
</ol>
<p>We now introduce a new variable \(u_h^* \in \mathcal{V}_h^{p+1}\) , which we findby minimizing the expression \(|\kappa \nabla u_h^* + \mathbf{q}_h|^2\) over the cell \(K\) under the constraint \(\left(1, u_h^*\right)_K = \left(1, u_h\right)_K\) . The constraint is necessary because the minimizationfunctional does not determine the constant part of \(u_h^*\) . Thistranslates to the following system of equations: </p><p class="formulaDsp">
\begin{eqnarray*} \left(1, u_h^*\right)_K &amp;=&amp; \left(1, u_h\right)_K\\ \left(\nabla w_h^*, \kappa \nabla u_h^*\right)_K &amp;=&amp; -\left(\nabla w_h^*, \mathbf{q}_h\right)_K \quad \text{for all } w_h^* \in \mathcal Q^{p+1}. \end{eqnarray*}
</p>
<p>Since we test by the whole set of basis functions in the space of tensorproduct polynomials of degree \(p+1\) in the second set of equations, thisis an overdetermined system with one more equation than unknowns. We fix thisin the code below by omitting one of these equations (since the rows in theLaplacian are linearly dependent when representing a constant function). As wewill see below, this form of the post-processing gives the desiredsuper-convergence result with rate \(\mathcal {O}(h^{p+2})\) . It should benoted that there is some freedom in constructing \(u_h^*\) and this minimizationapproach to extract the information from the gradient is not the only one. Inparticular, the post-processed solution defined here does not satisfy theconvection-diffusion equation in any sense. As an alternative, the paper byNguyen, Peraire and Cockburn cited above suggests another somewhat moreinvolved formula for convection-diffusion that can also post-process the fluxvariable into an \(H(\Omega,\mathrm{div})\) -conforming variant and betterrepresents the local convection-diffusion operator when the diffusion issmall. We leave the implementation of a more sophisticated post-processing asa possible extension to the interested reader. Note that for vector-valued problems, the post-processing works similarly. Onesimply sets the constraint for the mean value of each vector componentseparately and uses the gradient as the main source of information. <a class="anchor" id="Problemspecificdata"></a></p><h3>Problem specific data </h3>
<p>For this tutorial program, we consider almost the same test case as in <a class="el" href="step_7.html">step-7</a> . The computational domain is \(\Omega \dealcoloneq [-1,1]^d\) and the exactsolution corresponds to the one in <a class="el" href="step_7.html">step-7</a> , except for a scaling. We use thefollowing source centers \(x_i\) for the exponentials </p><ul>
<li>
1D: \(\{x_i\}^1 = \{ -\frac{1}{3}, 0, \frac{1}{3} \}\) , </li>
<li>
2D: \(\{\mathbf{x}_i\}^2 = \{ (-\frac{1}{2},\frac{1}{2}), (-\frac{1}{2},-\frac{1}{2}), (\frac{1}{2},-\frac{1}{2}) \}\) , </li>
<li>
3D: \(\{\mathbf{x}_i\}^3 = \{ (-\frac{1}{2},\frac{1}{2}, \frac{1}{4}), (-\frac{3}{5},-\frac{1}{2}, -\frac{1}{8}), (\frac{1}{2},-\frac{1}{2}, \frac{1}{2}) \}\) . </li>
</ul>
<p>With the exact solution given, we then choose the forcing on the right handside and the Neumann boundary condition such that we obtain this solution(manufactured solution technique). In this example, we choose the diffusionequal to one and the convection as </p><p class="formulaDsp">
\[ \mathbf{c} = \begin{cases} 1, &amp; \textrm{dim}=1 \\ (y, -x), &amp; \textrm{dim}=2 \\ (y, -x, 1), &amp; \textrm{dim}=3 \end{cases} \]
</p>
<p> that the convection is divergence-free, \(\nabla \cdot c = 0\) . <a class="anchor" id="Implementation"></a></p><h3>Implementation </h3>
<p>Besides implementing the above equations, the implementation below providesthe following features: </p><ul>
<li>
<a class="el" href="namespaceWorkStream.html">WorkStream</a> to parallelize local solvers. Workstream has been presented in detail in <a class="el" href="step_9.html">step-9</a> . </li>
<li>
Reconstruct the local DG solution from the trace. </li>
<li>
Post-processing the solution for superconvergence. </li>
<li>
<a class="el" href="classDataOutFaces.html">DataOutFaces</a> for direct output of the global skeleton solution. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of the deal.II include files have already been covered in previous examples and are not commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2exceptions_8h.html">deal.II/base/exceptions.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div></div><!-- fragment --><p>However, we do have a few new includes for the example. The first one defines finite element spaces on the faces of the triangulation, which we refer to as the 'skeleton'. These finite elements do not have any support on the element interior, and they represent polynomials that have a single value on each codimension-1 surface, but admit discontinuities on codimension-2 surfaces.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div></div><!-- fragment --><p>The second new file we include defines a new type of sparse matrix. The regular <code><a class="el" href="classSparseMatrix.html">SparseMatrix</a></code> type stores indices to all non-zero entries. The <code><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a></code> takes advantage of the coupled nature of DG solutions. It stores an index to a matrix sub-block of a specified size. In the HDG context, this sub-block-size is actually the number of degrees of freedom per face defined by the skeleton solution field. This reduces the memory consumption of the matrix by up to one third and results in similar speedups when using the matrix in solvers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chunk__sparse__matrix_8h.html">deal.II/lac/chunk_sparse_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>The final new include for this example deals with data output. Since we have a finite element field defined on the skeleton of the mesh, we would like to visualize what that solution actually is. <a class="el" href="classDataOutFaces.html">DataOutFaces</a> does exactly this; the interface is the almost the same as the familiar <a class="el" href="classDataOut.html">DataOut</a>, but the output only has codimension-1 data for the simulation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>We start by putting all of our classes into their own namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>The structure of the analytic solution is the same as in <a class="el" href="step_7.html">step-7</a> . There are two exceptions. Firstly, we also create a solution for the 3d case, and secondly, we scale the solution so its norm is of order unity for all values of the solution width.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>SolutionBase</div><div class="line">   {</div><div class="line">   <span class="keyword">protected</span>:</div><div class="line">     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">     SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers] =</div><div class="line">       {<a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)};</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">     SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers] =</div><div class="line">       {<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5,</div><div class="line">  </div><div class="line">-0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5,</div><div class="line">  </div><div class="line">-0.5)};</div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;&gt;</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">     SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers] = {</div><div class="line">       <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">       <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6,</div><div class="line">  </div><div class="line">-0.5,</div><div class="line">  </div><div class="line">-0.125),</div><div class="line">       <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5,</div><div class="line">  </div><div class="line">-0.5, 0.5)};</div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1. / 5.;</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <span class="keywordtype">double</span> sum = 0;</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">         {</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p</div><div class="line">  </div><div class="line">- this-&gt;source_centers[i];</div><div class="line">           sum +=</div><div class="line">             <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width this-&gt;width));</div><div class="line">         }</div><div class="line">  </div><div class="line">       <span class="keywordflow">return</span> sum /</div><div class="line">              <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> this-&gt;width this-&gt;width, dim / 2.);</div><div class="line">     }</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">     gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">         {</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p</div><div class="line">  </div><div class="line">- this-&gt;source_centers[i];</div><div class="line">  </div><div class="line">           sum +=</div><div class="line">             (-2 / (this-&gt;width this-&gt;width)</div><div class="line">              std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width this-&gt;width))</div><div class="line">              x_minus_xi);</div><div class="line">         }</div><div class="line">  </div><div class="line">       <span class="keywordflow">return</span> sum /</div><div class="line">              <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> this-&gt;width this-&gt;width, dim / 2.);</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p>This class implements a function where the scalar solution and its negative gradient are collected together. This function is used when computing the error of the HDG approximation and its implementation is to simply call value and gradient function of the Solution class.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     SolutionAndGradient()</div><div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  v)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), dim + 1);</div><div class="line">       Solution&lt;dim&gt;  solution;</div><div class="line">       <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad = solution.gradient(p);</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">         v[d] =</div><div class="line">  </div><div class="line">-grad[d];</div><div class="line">       v[dim] = solution.value(p);</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p>Next comes the implementation of the convection velocity. As described in the introduction, we choose a velocity field that is \((y, -x)\) in 2D and \((y, -x, 1)\) in 3D. This gives a divergence-free velocity field.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     ConvectionVelocity()</div><div class="line">       : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="classTensorFunction.html#a60e07c97b7b3b30c612644f9ca42d477">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection;</div><div class="line">       <span class="keywordflow">switch</span> (dim)</div><div class="line">         {</div><div class="line">           <span class="keywordflow">case</span> 1:</div><div class="line">             convection[0] = 1;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">           <span class="keywordflow">case</span> 2:</div><div class="line">             convection[0] = p[1];</div><div class="line">             convection[1] =</div><div class="line">  </div><div class="line">-p[0];</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">           <span class="keywordflow">case</span> 3:</div><div class="line">             convection[0] = p[1];</div><div class="line">             convection[1] =</div><div class="line">  </div><div class="line">-p[0];</div><div class="line">             convection[2] = 1;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">           <span class="keywordflow">default</span>:</div><div class="line">             <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">         }</div><div class="line">       <span class="keywordflow">return</span> convection;</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p>The last function we implement is the right hand side for the manufactured solution. It is very similar to <a class="el" href="step_7.html">step-7</a> , with the exception that we now have a convection term instead of the reaction term. Since the velocity field is incompressible, i.e., \(\nabla \cdot \mathbf{c} = 0\) , the advection term simply reads \(\mathbf{c} \nabla u\) .</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">       <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          convection = convection_velocity.value(p);</div><div class="line">       <span class="keywordtype">double</span>                  sum        = 0;</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">         {</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p</div><div class="line">  </div><div class="line">- this-&gt;source_centers[i];</div><div class="line">  </div><div class="line">           sum +=</div><div class="line">             ((2 dim</div><div class="line">  </div><div class="line">- 2 convection x_minus_xi</div><div class="line">  </div><div class="line">-</div><div class="line">               4 x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width this-&gt;width)) /</div><div class="line">              (this-&gt;width this-&gt;width)</div><div class="line">              std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width this-&gt;width)));</div><div class="line">         }</div><div class="line">  </div><div class="line">       <span class="keywordflow">return</span> sum /</div><div class="line">              <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> this-&gt;width this-&gt;width, dim / 2.);</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p><a class="anchor" id="TheHDGsolverclass"></a> </p><h3>The HDG solver class</h3>
<p>The HDG solution procedure follows closely that of <a class="el" href="step_7.html">step-7</a> . The major difference is the use of three different sets of <a class="el" href="classDoFHandler.html">DoFHandler</a> and FE objects, along with the <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> and the corresponding solutions vectors. We also use <a class="el" href="namespaceWorkStream.html">WorkStream</a> to enable a multithreaded local solution process which exploits the embarrassingly parallel nature of the local solver. For <a class="el" href="namespaceWorkStream.html">WorkStream</a>, we define the local operations on a cell and a copy function into the global matrix and vector. We do this both for the assembly (which is run twice, once when we generate the system matrix and once when we compute the element-interior solutions from the skeleton values) and for the postprocessing where we extract a solution that converges at higher order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>HDG</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> RefinementMode</div><div class="line">  {</div><div class="line">    global_refinement,</div><div class="line">    adaptive_refinement</div><div class="line">  };</div><div class="line"></div><div class="line">  HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> postprocess();</div><div class="line">  <span class="keywordtype">void</span> refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div></div><!-- fragment --><p>Data for the assembly and solution of the primal variables.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PerTaskData;</div><div class="line"><span class="keyword">struct </span>ScratchData;</div></div><!-- fragment --><p>Post-processing the solution to obtain \(u^*\) is an element-by-element procedure; as such, we do not need to assemble any global data and do not declare any 'task data' for <a class="el" href="namespaceWorkStream.html">WorkStream</a> to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PostProcessScratchData;</div></div><!-- fragment --><p>The following three functions are used by <a class="el" href="namespaceWorkStream.html">WorkStream</a> to do the actual work of the program.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_system_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  ScratchData &amp;                                         scratch,</div><div class="line">  PerTaskData &amp;                                         task_data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> postprocess_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  PostProcessScratchData &amp;                              scratch,</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        empty_data);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>The 'local' solutions are interior to each element. These represent the primal solution field \(u\) as well as the auxiliary field \(\mathbf{q}\) .</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe_local;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_local;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution_local;</div></div><!-- fragment --><p>The new finite element type and corresponding <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> are used for the global skeleton solution that couples the element-level local solutions.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>   fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  system_rhs;</div></div><!-- fragment --><p>As stated in the introduction, HDG solutions can be post-processed to attain superconvergence rates of \(\mathcal{O}(h^{p+2})\) . The post-processed solution is a discontinuous finite element solution representing the primal variable on the interior of each cell. We define a FE type of degree \(p+1\) to represent this post-processed solution, which we only use for output after constructing it.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>     fe_u_post;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_u_post;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution_u_post;</div></div><!-- fragment --><p>The degrees of freedom corresponding to the skeleton strongly enforce Dirichlet boundary conditions, just as in a continuous Galerkin finite element method. We can enforce the boundary conditions in an analogous manner via an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object. In addition, hanging nodes are handled in the same way as for continuous finite elements: For the face elements which only define degrees of freedom on the face, this process sets the solution on the refined side to coincide with the representation on the coarse side. Note that for HDG, the elimination of hanging nodes is not the only possibility &mdash; in terms of the HDG theory, one could also use the unknowns from the refined side and express the local solution on the coarse side through the trace values on the refined side. However, such a setup is not as easily implemented in terms of deal.II loops and not further analyzed.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div></div><!-- fragment --><p>The usage of the <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> class is similar to the usual sparse matrices: You need a sparsity pattern of type <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> and the actual matrix object. When creating the sparsity pattern, we just have to additionally pass the size of local blocks.</p>
<div class="fragment"><div class="line"><a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>Same as <a class="el" href="step_7.html">step-7</a> :</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">  <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheHDGclassimplementation"></a> </p><h3>The HDG class implementation</h3>
<pre class="fragment">&lt;a name="Constructor"&gt;&lt;/a&gt;  &lt;h4&gt;Constructor&lt;/h4&gt; The constructor is similar to those in other examples, with the exception of handling multiple DoFHandler and FiniteElement objects. Note that we create a system of finite elements for the local DG part, including the gradient/flux part and the scalar part.
</pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">HDG&lt;dim&gt;::HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode)</div><div class="line">  : fe_local(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim, <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler_local(triangulation)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe_u_post(degree + 1)</div><div class="line">  , dof_handler_u_post(triangulation)</div><div class="line">  , refinement_mode(refinement_mode)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="HDGsetup_system"></a> </p><h4>HDG::setup_system</h4>
<p>The system for an HDG solution is setup in an analogous manner to most of the other tutorial programs. We are careful to distribute dofs with all of our <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The <code>solution</code> and <code>system_matrix</code> objects go with the global skeleton solution.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> HDG&lt;dim&gt;::setup_system()</div><div class="line">   {</div><div class="line">     dof_handler_local.distribute_dofs(fe_local);</div><div class="line">     dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">     dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line">  </div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">               &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">     solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  </div><div class="line">     solution_local.reinit(dof_handler_local.n_dofs());</div><div class="line">     solution_u_post.reinit(dof_handler_u_post.n_dofs());</div><div class="line">  </div><div class="line">     constraints.clear();</div><div class="line">     <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">     std::map&lt;types::boundary_id, const Function&lt;dim&gt;&gt; boundary_functions;</div><div class="line">     Solution&lt;dim&gt;                                       solution_function;</div><div class="line">     boundary_functions[0] = &amp;solution_function;</div><div class="line">     <a class="code" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>(dof_handler,</div><div class="line">                                          boundary_functions,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                          constraints);</div><div class="line">     constraints.close();</div></div><!-- fragment --><p>When creating the chunk sparsity pattern, we first create the usual dynamic sparsity pattern and then set the chunk size, which is equal to the number of dofs on a face, when copying this into the final sparsity pattern.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a>());</div><div class="line">  }</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGPerTaskData"></a> </p><h4>HDG::PerTaskData</h4>
<p>Next comes the definition of the local data structures for the parallel assembly. The first structure <code>PerTaskData</code> contains the local vector and matrix that are written into the global matrix, whereas the ScratchData contains all data that we need for the local assembly. There is one variable worth noting here, namely the boolean variable <code>trace_reconstruct</code>. As mentioned in the introduction, we solve the HDG system in two steps. First, we create a linear system for the skeleton system where we condense the local part into it via the Schur complement \(D-CA^{-1}B\) . Then, we solve for the local part using the skeleton solution. For these two steps, we need the same matrices on the elements twice, which we want to compute by two assembly steps. Since most of the code is similar, we do this with the same function but only switch between the two based on a flag that we set when starting the assembly. Since we need to pass this information on to the local worker routines, we store it once in the task data.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_vector;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">  PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">    : cell_matrix(n_dofs, n_dofs)</div><div class="line">    , cell_vector(n_dofs)</div><div class="line">    , dof_indices(n_dofs)</div><div class="line">    , trace_reconstruct(trace_reconstruct)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGScratchData"></a> </p><h4>HDG::ScratchData</h4>
<p><code>ScratchData</code> contains persistent data for each thread within <a class="el" href="namespaceWorkStream.html">WorkStream</a>. The <a class="el" href="classFEValues.html">FEValues</a>, matrix, and vector objects should be familiar by now. There are two objects that need to be discussed: <code>std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_local_support_on_face</code> and <code>std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_support_on_face</code>. These are used to indicate whether or not the finite elements chosen have support (non-zero values) on a given face of the reference cell for the local part associated to <code>fe_local</code> and the skeleton part <code>fe</code>. We extract this information in the constructor and store it once for all cells that we work on. Had we not stored this information, we would be forced to assemble a large number of zero terms on each cell, which would significantly slow the program.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">   {</div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line">  </div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     l_rhs;</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     tmp_rhs;</div><div class="line">  </div><div class="line">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; q_phi;</div><div class="line">     std::vector&lt;double&gt;         q_phi_div;</div><div class="line">     std::vector&lt;double&gt;         u_phi;</div><div class="line">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_phi_grad;</div><div class="line">     std::vector&lt;double&gt;         tr_phi;</div><div class="line">     std::vector&lt;double&gt;         trace_values;</div><div class="line">  </div><div class="line">     std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_local_support_on_face;</div><div class="line">     std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_support_on_face;</div><div class="line">  </div><div class="line">     ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">     RightHandSide&lt;dim&gt;      right_hand_side;</div><div class="line">     <span class="keyword">const</span> Solution&lt;dim&gt;     exact_solution;</div><div class="line">  </div><div class="line">     ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; &amp;   face_quadrature_formula,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_face_flags,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">       : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">       , fe_face_values_local(fe_local,</div><div class="line">                              face_quadrature_formula,</div><div class="line">                              local_face_flags)</div><div class="line">       , fe_face_values(fe, face_quadrature_formula, flags)</div><div class="line">       , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">       , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">       , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">       , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">       , l_rhs(fe_local.n_dofs_per_cell())</div><div class="line">       , tmp_rhs(fe_local.n_dofs_per_cell())</div><div class="line">       , q_phi(fe_local.n_dofs_per_cell())</div><div class="line">       , q_phi_div(fe_local.n_dofs_per_cell())</div><div class="line">       , u_phi(fe_local.n_dofs_per_cell())</div><div class="line">       , u_phi_grad(fe_local.n_dofs_per_cell())</div><div class="line">       , tr_phi(fe.n_dofs_per_cell())</div><div class="line">       , trace_values(face_quadrature_formula.size())</div><div class="line">       , fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">       , fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">       , exact_solution()</div><div class="line">     {</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_local.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">           {</div><div class="line">             <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">               fe_local_support_on_face[face_no].push_back(i);</div><div class="line">           }</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">           {</div><div class="line">             <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">               fe_support_on_face[face_no].push_back(i);</div><div class="line">           }</div><div class="line">     }</div><div class="line">  </div><div class="line">     ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">       : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                         sd.fe_values_local.get_quadrature(),</div><div class="line">                         sd.fe_values_local.get_update_flags())</div><div class="line">       , fe_face_values_local(sd.fe_face_values_local.get_fe(),</div><div class="line">                              sd.fe_face_values_local.get_quadrature(),</div><div class="line">                              sd.fe_face_values_local.get_update_flags())</div><div class="line">       , fe_face_values(sd.fe_face_values.get_fe(),</div><div class="line">                        sd.fe_face_values.get_quadrature(),</div><div class="line">                        sd.fe_face_values.get_update_flags())</div><div class="line">       , ll_matrix(sd.ll_matrix)</div><div class="line">       , lf_matrix(sd.lf_matrix)</div><div class="line">       , fl_matrix(sd.fl_matrix)</div><div class="line">       , tmp_matrix(sd.tmp_matrix)</div><div class="line">       , l_rhs(sd.l_rhs)</div><div class="line">       , tmp_rhs(sd.tmp_rhs)</div><div class="line">       , q_phi(sd.q_phi)</div><div class="line">       , q_phi_div(sd.q_phi_div)</div><div class="line">       , u_phi(sd.u_phi)</div><div class="line">       , u_phi_grad(sd.u_phi_grad)</div><div class="line">       , tr_phi(sd.tr_phi)</div><div class="line">       , trace_values(sd.trace_values)</div><div class="line">       , fe_local_support_on_face(sd.fe_local_support_on_face)</div><div class="line">       , fe_support_on_face(sd.fe_support_on_face)</div><div class="line">       , exact_solution()</div><div class="line">     {}</div><div class="line">   };</div></div><!-- fragment --><p><a class="anchor" id="HDGPostProcessScratchData"></a> </p><h4>HDG::PostProcessScratchData</h4>
<p><code>PostProcessScratchData</code> contains the data used by <a class="el" href="namespaceWorkStream.html">WorkStream</a> when post-processing the local solution \(u^*\) . It is similar, but much simpler, than <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         u_values;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_gradients;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_sol;</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">    : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">    , fe_values(fe, quadrature_formula, flags)</div><div class="line">    , u_values(quadrature_formula.size())</div><div class="line">    , u_gradients(quadrature_formula.size())</div><div class="line">    , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">    , cell_rhs(fe.n_dofs_per_cell())</div><div class="line">    , cell_sol(fe.n_dofs_per_cell())</div><div class="line">  {}</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">    : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                      sd.fe_values_local.get_quadrature(),</div><div class="line">                      sd.fe_values_local.get_update_flags())</div><div class="line">    , fe_values(sd.fe_values.get_fe(),</div><div class="line">                sd.fe_values.get_quadrature(),</div><div class="line">                sd.fe_values.get_update_flags())</div><div class="line">    , u_values(sd.u_values)</div><div class="line">    , u_gradients(sd.u_gradients)</div><div class="line">    , cell_matrix(sd.cell_matrix)</div><div class="line">    , cell_rhs(sd.cell_rhs)</div><div class="line">    , cell_sol(sd.cell_sol)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system"></a> </p><h4>HDG::assemble_system</h4>
<p>The <code>assemble_system</code> function is similar to the one on Step-32 , where the quadrature formula and the update flags are set up, and then <code><a class="el" href="namespaceWorkStream.html">WorkStream</a></code> is used to do the work in a multi-threaded manner. The <code>trace_reconstruct</code> input parameter is used to decide whether we are solving for the global skeleton solution (false) or the local solution (true). One thing worth noting for the multi-threaded execution of assembly is the fact that the local computations in <code>assemble_system_one_cell()</code> call into BLAS and LAPACK functions if those are available in deal.II. Thus, the underlying BLAS/LAPACK library must support calls from multiple threads at the same time. Most implementations do support this, but some libraries need to be built in a specific way to avoid problems. For example, OpenBLAS compiled without multithreading inside the BLAS/LAPACK calls needs to built with a flag called <code>USE_LOCKING</code> set to true.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     PerTaskData task_data(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(), trace_reconstruct);</div><div class="line">     ScratchData scratch(fe,</div><div class="line">                         fe_local,</div><div class="line">                         quadrature_formula,</div><div class="line">                         face_quadrature_formula,</div><div class="line">                         local_flags,</div><div class="line">                         local_face_flags,</div><div class="line">                         flags);</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                     dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                     &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                     &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                     scratch,</div><div class="line">                     task_data);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system_one_cell"></a> </p><h4>HDG::assemble_system_one_cell</h4>
<p>The real work of the HDG program is done by <code>assemble_system_one_cell</code>. Assembling the local matrices \(A, B, C\) is done here, along with the local contributions of the global matrix \(D\) .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  ScratchData &amp;                                         scratch,</div><div class="line">  PerTaskData &amp;                                         task_data)</div><div class="line">{</div></div><!-- fragment --><p>Construct iterator for dof_handler_local for <a class="el" href="classFEValues.html">FEValues</a> reinit function.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                        cell-&gt;level(),</div><div class="line">                                                        cell-&gt;index(),</div><div class="line">                                                        &amp;dof_handler_local);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">  scratch.fe_values_local.get_quadrature().size();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">  scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell =</div><div class="line">  scratch.fe_values_local.get_fe().n_dofs_per_cell();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">scratch.ll_matrix = 0;</div><div class="line">scratch.l_rhs     = 0;</div><div class="line"><span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">  {</div><div class="line">    scratch.lf_matrix     = 0;</div><div class="line">    scratch.fl_matrix     = 0;</div><div class="line">    task_data.cell_matrix = 0;</div><div class="line">    task_data.cell_vector = 0;</div><div class="line">  }</div><div class="line">scratch.fe_values_local.reinit(loc_cell);</div></div><!-- fragment --><p>We first compute the cell-interior contribution to <code>ll_matrix</code> matrix (referred to as matrix \(A\) in the introduction) corresponding to local-local coupling, as well as the local right-hand-side vector. We store the values at each quadrature point for the basis functions, the right-hand-side value, and the convection velocity, in order to have quick access to these fields.</p>
<div class="fragment"><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">       {</div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value = scratch.right_hand_side.value(</div><div class="line">           scratch.fe_values_local.quadrature_point(q));</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection = scratch.convection_velocity.value(</div><div class="line">           scratch.fe_values_local.quadrature_point(q));</div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; loc_dofs_per_cell; ++k)</div><div class="line">           {</div><div class="line">             scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);</div><div class="line">             scratch.q_phi_div[k] =</div><div class="line">               scratch.fe_values_local[fluxes].divergence(k, q);</div><div class="line">             scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);</div><div class="line">             scratch.u_phi_grad[k] =</div><div class="line">               scratch.fe_values_local[scalar].gradient(k, q);</div><div class="line">           }</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; loc_dofs_per_cell; ++i)</div><div class="line">           {</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; loc_dofs_per_cell; ++j)</div><div class="line">               scratch.ll_matrix(i, j) +=</div><div class="line">                 (scratch.q_phi[i] scratch.q_phi[j]</div><div class="line">  </div><div class="line">-</div><div class="line">                  scratch.q_phi_div[i] scratch.u_phi[j] +</div><div class="line">                  scratch.u_phi[i] scratch.q_phi_div[j]</div><div class="line">  </div><div class="line">-</div><div class="line">                  (scratch.u_phi_grad[i] convection) scratch.u_phi[j])</div><div class="line">                 JxW;</div><div class="line">             scratch.l_rhs(i) += scratch.u_phi[i] rhs_value JxW;</div><div class="line">           }</div><div class="line">       }</div></div><!-- fragment --><p>Face terms are assembled on all faces of all elements. This is in contrast to more traditional DG methods, where each face is only visited once in the assembly procedure.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">  {</div><div class="line">    scratch.fe_face_values_local.reinit(loc_cell, face_no);</div><div class="line">    scratch.fe_face_values.reinit(cell, face_no);</div></div><!-- fragment --><p>The already obtained \(\hat{u}\) values are needed when solving for the local variables.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">  scratch.fe_face_values.get_function_values(solution,</div><div class="line">                                             scratch.trace_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     JxW = scratch.fe_face_values.JxW(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">      scratch.fe_face_values.quadrature_point(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal =</div><div class="line">      scratch.fe_face_values.normal_vector(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection =</div><div class="line">      scratch.convection_velocity.value(quadrature_point);</div></div><!-- fragment --><p>Here we compute the stabilization parameter discussed in the introduction: since the diffusion is one and the diffusion length scale is set to 1/5, it simply results in a contribution of 5 for the diffusion part and the magnitude of convection through the element boundary in a centered scheme for the convection part.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. + <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(convection normal));</div></div><!-- fragment --><p>We store the non-zero flux and scalar values, making use of the support_on_face information we created in <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">     k &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">     ++k)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk =</div><div class="line">      scratch.fe_local_support_on_face[face_no][k];</div><div class="line">    scratch.q_phi[k] =</div><div class="line">      scratch.fe_face_values_local[fluxes].value(kk, q);</div><div class="line">    scratch.u_phi[k] =</div><div class="line">      scratch.fe_face_values_local[scalar].value(kk, q);</div><div class="line">  }</div></div><!-- fragment --><p>When <code>trace_reconstruct=false</code>, we are preparing to assemble the system for the skeleton variable \(\hat{u}\) . If this is the case, we must assemble all local matrices associated with the problem: local-local, local-face, face-local, and face-face. The face-face matrix is stored as <code>TaskData::cell_matrix</code>, so that it can be assembled into the global system by <code>copy_local_to_global</code>.</p>
<div class="fragment"><div class="line">             <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">               {</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">                      k &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                      ++k)</div><div class="line">                   scratch.tr_phi[k] = scratch.fe_face_values.shape_value(</div><div class="line">                     scratch.fe_support_on_face[face_no][k], q);</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                      i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                      ++i)</div><div class="line">                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                        j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                        ++j)</div><div class="line">                     {</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                         scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                         scratch.fe_support_on_face[face_no][j];</div><div class="line">                       scratch.lf_matrix(ii, jj) +=</div><div class="line">                         ((scratch.q_phi[i] normal +</div><div class="line">                           (convection normal</div><div class="line">  </div><div class="line">- tau_stab) scratch.u_phi[i])</div><div class="line">                          scratch.tr_phi[j])</div><div class="line">                         JxW;</div></div><!-- fragment --><p>Note the sign of the face_no-local matrix. We negate the sign during assembly here so that we can use the <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a> with addition when computing the Schur complement.</p>
<div class="fragment"><div class="line">                       scratch.fl_matrix(jj, ii)</div><div class="line">  </div><div class="line">-=</div><div class="line">                         ((scratch.q_phi[i] normal +</div><div class="line">                           tau_stab scratch.u_phi[i])</div><div class="line">                          scratch.tr_phi[j])</div><div class="line">                         JxW;</div><div class="line">                     }</div><div class="line">  </div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                      i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                      ++i)</div><div class="line">                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                        j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                        ++j)</div><div class="line">                     {</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                         scratch.fe_support_on_face[face_no][i];</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                         scratch.fe_support_on_face[face_no][j];</div><div class="line">                       task_data.cell_matrix(ii, jj) +=</div><div class="line">                         ((convection normal</div><div class="line">  </div><div class="line">- tau_stab) scratch.tr_phi[i]</div><div class="line">                          scratch.tr_phi[j])</div><div class="line">                         JxW;</div><div class="line">                     }</div><div class="line">  </div><div class="line">                 <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">                     (cell-&gt;face(face_no)-&gt;boundary_id() == 1))</div><div class="line">                   {</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-scratch.exact_solution.gradient(quadrature_point)</div><div class="line">                         normal +</div><div class="line">                       convection normal</div><div class="line">                         scratch.exact_solution.value(quadrature_point);</div><div class="line">                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                          i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                          ++i)</div><div class="line">                       {</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                           scratch.fe_support_on_face[face_no][i];</div><div class="line">                         task_data.cell_vector(ii) +=</div><div class="line">                           scratch.tr_phi[i] neumann_value JxW;</div><div class="line">                       }</div><div class="line">                   }</div><div class="line">               }</div></div><!-- fragment --><p>This last term adds the contribution of the term \(\left&lt;w,\tau u_h\right&gt;_{\partial \mathcal T}\) to the local matrix. As opposed to the face matrices above, we need it in both assembly stages.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">     i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">     ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">       j &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">       ++j)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">        scratch.fe_local_support_on_face[face_no][i];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">        scratch.fe_local_support_on_face[face_no][j];</div><div class="line">      scratch.ll_matrix(ii, jj) +=</div><div class="line">        tau_stab scratch.u_phi[i] scratch.u_phi[j] JxW;</div><div class="line">    }</div></div><!-- fragment --><p>When <code>trace_reconstruct=true</code>, we are solving for the local solutions on an element by element basis. The local right-hand-side is calculated by replacing the basis functions <code>tr_phi</code> in the <code>lf_matrix</code> computation by the computed values <code>trace_values</code>. Of course, the sign of the matrix is now minus since we have moved everything to the other side of the equation.</p>
<div class="fragment"><div class="line">             <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                    i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                    ++i)</div><div class="line">                 {</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                     scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                   scratch.l_rhs(ii)</div><div class="line">  </div><div class="line">-=</div><div class="line">                     (scratch.q_phi[i] normal +</div><div class="line">                      scratch.u_phi[i] (convection normal</div><div class="line">  </div><div class="line">- tau_stab))</div><div class="line">                     scratch.trace_values[q] JxW;</div><div class="line">                 }</div><div class="line">           }</div><div class="line">       }</div></div><!-- fragment --><p>Once assembly of all of the local contributions is complete, we must either: (1) assemble the global system, or (2) compute the local solution values and save them. In either case, the first step is to invert the local-local matrix.</p>
<div class="fragment"><div class="line">scratch.ll_matrix.gauss_jordan();</div></div><!-- fragment --><p>For (1), we compute the Schur complement and add it to the <code>cell_matrix</code>, matrix \(D\) in the introduction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">    scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">    scratch.tmp_matrix.mmult(task_data.cell_matrix,</div><div class="line">                             scratch.lf_matrix,</div><div class="line">                             <span class="keyword">true</span>);</div><div class="line">    cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">  }</div></div><!-- fragment --><p>For (2), we are simply solving (ll_matrix).(solution_local) = (l_rhs). Hence, we multiply <code>l_rhs</code> by our already inverted local-local matrix and store the result using the <code>set_dof_values</code> function.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">      loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGcopy_local_to_global"></a> </p><h4>HDG::copy_local_to_global</h4>
<p>If we are in the first step of the solution, i.e. <code>trace_reconstruct=false</code>, then we assemble the local matrices into the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">    constraints.distribute_local_to_global(data.cell_matrix,</div><div class="line">                                           data.cell_vector,</div><div class="line">                                           data.dof_indices,</div><div class="line">                                           system_matrix,</div><div class="line">                                           system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGsolve"></a> </p><h4>HDG::solve</h4>
<p>The skeleton solution is solved for by using a BiCGStab solver with identity preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                  solver_control(system_matrix.m() 10,</div><div class="line">                               1e-11 system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0, 0, 0, 1);</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div></div><!-- fragment --><p>Once we have solved for the skeleton solution, we can solve for the local solutions in an element-by-element fashion. We do this by re-using the same <code>assemble_system</code> function but switching <code>trace_reconstruct</code> to true.</p>
<div class="fragment"><div class="line">  assemble_system(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess"></a> </p><h4>HDG::postprocess</h4>
<p>The postprocess method serves two purposes. First, we want to construct a post-processed scalar variables in the element space of degree \(p+1\) that we hope will converge at order \(p+2\) . This is again an element-by-element process and only involves the scalar solution as well as the gradient on the local cell. To do this, we introduce the already defined scratch data together with some update flags and run the work stream to do this in parallel. Secondly, we want to compute discretization errors just as we did in <a class="el" href="step_7.html">step-7</a> . The overall procedure is similar with calls to <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>. The difference is in how we compute the errors for the scalar variable and the gradient variable. In <a class="el" href="step_7.html">step-7</a> , we did this by computing <code>L2_norm</code> or <code>H1_seminorm</code> contributions. Here, we have a <a class="el" href="classDoFHandler.html">DoFHandler</a> with these two contributions computed and sorted by their vector component, <code>[0, dim)</code> for the gradient and <code>dim</code> for the scalar. To compute their value, we hence use a <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> with either of them, together with the <code>SolutionAndGradient</code> class introduced above that contains the analytic parts of either of them. Eventually, we also compute the L2-error of the post-processed solution and add the results into the convergence table.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_u_post.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PostProcessScratchData scratch(</div><div class="line">      fe_u_post, fe_local, quadrature_formula, local_flags, flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">      dof_handler_u_post.begin_active(),</div><div class="line">      dof_handler_u_post.end(),</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">             PostProcessScratchData &amp;                              scratch,</div><div class="line">             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        data) {</div><div class="line">        this-&gt;postprocess_one_cell(cell, scratch, data);</div><div class="line">      },</div><div class="line">      std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">      scratch,</div><div class="line">      0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select(dim, dim + 1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                    solution_local,</div><div class="line">                                    SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;value_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select(</div><div class="line">    std::pair&lt;unsigned int, unsigned int&gt;(0, dim), dim + 1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                    solution_local,</div><div class="line">                                    SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;gradient_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_u_post,</div><div class="line">                                    solution_u_post,</div><div class="line">                                    Solution&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 3),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> post_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>, L2_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>, grad_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess_one_cell"></a> </p><h4>HDG::postprocess_one_cell</h4>
<p>This is the actual work done for the postprocessing. According to the discussion in the introduction, we need to set up a system that projects the gradient part of the DG solution onto the gradient of the post-processed variable. Moreover, we need to set the average of the new post-processed variable to equal the average of the scalar DG solution on the cell. More technically speaking, the projection of the gradient is a system that would potentially fills our <code>dofs_per_cell</code> times <code>dofs_per_cell</code> matrix but is singular (the sum of all rows would be zero because the constant function has zero gradient). Therefore, we take one row away and use it for imposing the average of the scalar value. We pick the first row for the scalar part, even though we could pick any row for \(\mathcal Q_{-p}\) elements. However, had we used <a class="el" href="classFE__DGP.html">FE_DGP</a> elements instead, the first row would correspond to the constant part already and deleting e.g. the last row would give us a singular system. This way, our program can also be used for those elements.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess_one_cell(</div><div class="line">     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">     PostProcessScratchData &amp;                              scratch,</div><div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">   {</div><div class="line">     <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                             cell-&gt;level(),</div><div class="line">                                                             cell-&gt;index(),</div><div class="line">                                                             &amp;dof_handler_local);</div><div class="line">  </div><div class="line">     scratch.fe_values_local.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(loc_cell);</div><div class="line">     scratch.fe_values.reinit(cell);</div><div class="line">  </div><div class="line">     <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">     <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line">  </div><div class="line">     scratch.fe_values_local[scalar].get_function_values(solution_local,</div><div class="line">                                                         scratch.u_values);</div><div class="line">     scratch.fe_values_local[fluxes].get_function_values(solution_local,</div><div class="line">                                                         scratch.u_gradients);</div><div class="line">  </div><div class="line">     <span class="keywordtype">double</span> sum = 0;</div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dofs_per_cell; ++i)</div><div class="line">       {</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">           {</div><div class="line">             sum = 0;</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">               sum += (scratch.fe_values.shape_grad(i, q)</div><div class="line">                       scratch.fe_values.shape_grad(j, q))</div><div class="line">                      scratch.fe_values.JxW(q);</div><div class="line">             scratch.cell_matrix(i, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">           }</div><div class="line">  </div><div class="line">         sum = 0;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           sum</div><div class="line">  </div><div class="line">-= (scratch.fe_values.shape_grad(i, q) scratch.u_gradients[q])</div><div class="line">                  scratch.fe_values.JxW(q);</div><div class="line">         scratch.cell_rhs(i) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">       }</div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">       {</div><div class="line">         sum = 0;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           sum += scratch.fe_values.shape_value(j, q) scratch.fe_values.JxW(q);</div><div class="line">         scratch.cell_matrix(0, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">       }</div><div class="line">     {</div><div class="line">       sum = 0;</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">         sum += scratch.u_values[q] scratch.fe_values.JxW(q);</div><div class="line">       scratch.cell_rhs(0) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">     }</div></div><!-- fragment --><p>Having assembled all terms, we can again go on and solve the linear system. We invert the matrix and then multiply the inverse by the right hand side. An alternative (and more numerically stable) method would have been to only factorize the matrix and apply the factorization.</p>
<div class="fragment"><div class="line">  scratch.cell_matrix.gauss_jordan();</div><div class="line">  scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">  cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGoutput_results"></a> </p><h4>HDG::output_results</h4>
<p>We have 3 sets of results that we would like to output: the local solution, the post-processed local solution, and the skeleton solution. The former 2 both 'live' on element volumes, whereas the latter lives on codimension-1 surfaces of the triangulation. Our <code>output_results</code> function writes all local solutions to the same vtk file, even though they correspond to different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The graphical output for the skeleton variable is done through use of the <a class="el" href="classDataOutFaces.html">DataOutFaces</a> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  std::string filename;</div><div class="line">  <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  std::string face_out(filename);</div><div class="line">  face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">  filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">  filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">  filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div></div><!-- fragment --><p>We first define the names and types of the local solution, and add the data to <code>data_out</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; names(dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">names.emplace_back(<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  component_interpretation(</div><div class="line">    dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">component_interpretation[dim] =</div><div class="line">  <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_local,</div><div class="line">                         solution_local,</div><div class="line">                         names,</div><div class="line">                         component_interpretation);</div></div><!-- fragment --><p>The second data item we add is the post-processed solution. In this case, it is a single scalar variable belonging to a different <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; post_name(1, <span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_u_post,</div><div class="line">                         solution_u_post,</div><div class="line">                         post_name,</div><div class="line">                         post_comp_type);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">std::ofstream face_output(face_out);</div></div><!-- fragment --><p>The <code><a class="el" href="classDataOutFaces.html">DataOutFaces</a></code> class works analogously to the <code><a class="el" href="classDataOut.html">DataOut</a></code> class when we have a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> that defines the solution on the skeleton of the triangulation. We treat it as such here, and the code is similar to that above.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a>        data_out_face(<span class="keyword">false</span>);</div><div class="line">  std::vector&lt;std::string&gt; face_name(1, <span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  data_out_face.add_data_vector(dof_handler,</div><div class="line">                                solution,</div><div class="line">                                face_name,</div><div class="line">                                face_component_type);</div><div class="line"></div><div class="line">  data_out_face.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">  data_out_face.write_vtk(face_output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGrefine_grid"></a> </p><h4>HDG::refine_grid</h4>
<p>We implement two different refinement cases for HDG, just as in <code><a class="el" href="step_7.html">step-7</a></code> : adaptive_refinement and global_refinement. The global_refinement option recreates the entire triangulation every time. This is because we want to use a finer sequence of meshes than what we would get with one refinement step, namely 2, 3, 4, 6, 8, 12, 16, ... elements per direction.</p>
<p>The adaptive_refinement mode uses the <code><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a></code> to give a decent indication of the non-regular regions in the scalar local solutions.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">   {</div><div class="line">     <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">       {</div><div class="line">         <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 2,</div><div class="line">  </div><div class="line">-1, 1);</div><div class="line">         triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3</div><div class="line">  </div><div class="line">- dim);</div><div class="line">       }</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">       <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">         {</div><div class="line">           <span class="keywordflow">case</span> global_refinement:</div><div class="line">             {</div><div class="line">               triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">               <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation,</div><div class="line">                                                    2 + (cycle % 2),</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-1,</div><div class="line">                                                    1);</div><div class="line">               triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3</div><div class="line">  </div><div class="line">- dim + cycle / 2);</div><div class="line">               <span class="keywordflow">break</span>;</div><div class="line">             }</div><div class="line">  </div><div class="line">           <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">             {</div><div class="line">               <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div><div class="line">                 triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  </div><div class="line">               <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">               std::map&lt;types::boundary_id, const Function&lt;dim&gt;&gt;</div><div class="line">                 neumann_boundary;</div><div class="line">               <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler_local,</div><div class="line">                                                  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                                  neumann_boundary,</div><div class="line">                                                  solution_local,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(</div><div class="line">                                                    scalar));</div><div class="line">  </div><div class="line">               <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">                 triangulation, estimated_error_per_cell, 0.3, 0.);</div><div class="line">  </div><div class="line">               triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  </div><div class="line">               <span class="keywordflow">break</span>;</div><div class="line">             }</div><div class="line">  </div><div class="line">           <span class="keywordflow">default</span>:</div><div class="line">             {</div><div class="line">               <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">             }</div><div class="line">         }</div></div><!-- fragment --><p>Just as in <a class="el" href="step_7.html">step-7</a> , we set the boundary indicator of two of the faces to 1 where we want to specify Neumann boundary conditions instead of Dirichlet conditions. Since we re-create the triangulation every time for global refinement, the flags are set in every refinement step, not just at the beginning.</p>
<div class="fragment"><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">         <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">           <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(0)</div><div class="line">  </div><div class="line">- (-1)) &lt; 1e-12) ||</div><div class="line">               (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1)</div><div class="line">  </div><div class="line">- (-1)) &lt; 1e-12))</div><div class="line">             face-&gt;set_boundary_id(1);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="HDGrun"></a> </p><h4>HDG::run</h4>
<p>The functionality here is basically the same as <code>Step-7</code> . We loop over 10 cycles, refining the grid on each one. At the end, convergence tables are created.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HDG&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 10; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      refine_grid(cycle);</div><div class="line">      setup_system();</div><div class="line">      assemble_system(<span class="keyword">false</span>);</div><div class="line">      solve();</div><div class="line">      postprocess();</div><div class="line">      output_results(cycle);</div><div class="line">    }</div></div><!-- fragment --><p>There is one minor change for the convergence table compared to <a class="el" href="step_7.html">step-7</a> : Since we did not refine our mesh by a factor two in each cycle (but rather used the sequence 2, 3, 4, 6, 8, 12, ...), we need to tell the convergence rate evaluation about this. We do this by setting the number of cells as a reference column and additionally specifying the dimension of the problem, which gives the necessary information for the relation between number of cells and mesh size.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"> </div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"> </div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div></div><!-- fragment --><p>Now for the three calls to the main class in complete analogy to <a class="el" href="step_7.html">step-7</a> .</p>
<div class="fragment"><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"> </div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"> </div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>We first have a look at the output generated by the program when run in 2D. Inthe four images below, we show the solution for polynomial degree \(p=1\) and cycles 2, 3, 4, and 8 of the program. In the plots, we overlay the datagenerated from the internal data (DG part) with the skeleton part ( \(\hat{u}\) )into the same plot. We had to generate two different data sets because cellsand faces represent different geometric entities, the combination of which (inthe same file) is not supported in the VTK output of deal.II. The images show the distinctive features of HDG: The cell solution (coloredsurfaces) is discontinuous between the cells. The solution on the skeletonvariable sits on the faces and ties together the local parts. The skeletonsolution is not continuous on the vertices where the faces meet, even thoughits values are quite close along lines in the same coordinate direction. Theskeleton solution can be interpreted as a rubber spring between the two sidesthat balances the jumps in the solution (or rather, the flux \(\kappa \nabla u + \mathbf{c} u\) ). From the picture at the top left, it is clear thatthe bulk solution frequently over- and undershoots and that theskeleton variable in indeed a better approximation to the exactsolution; this explains why we can get a better solution using apostprocessing step. As the mesh is refined, the jumps between the cells getsmall (we represent a smooth solution), and the skeleton solution approachesthe interior parts. For cycle 8, there is no visible difference in the twovariables. We also see how boundary conditions are implemented weakly and thatthe interior variables do not exactly satisfy boundary conditions. On thelower and left boundaries, we set Neumann boundary conditions, whereas we setDirichlet conditions on the right and top boundaries. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_8.png"/>
</div>
  </td></tr>
</table>
<p>Next, we have a look at the post-processed solution, again at cycles 2, 3, 4,and 8. This is a discontinuous solution that is locally described by secondorder polynomials. While the solution does not look very good on the mesh ofcycle two, it looks much better for cycles three and four. As shown by theconvergence table below, we find that is also converges more quickly to theanalytical solution. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_8.png"/>
</div>
  </td></tr>
</table>
<p>Finally, we look at the solution for \(p=3\) at cycle 2. Despite the coarsemesh with only 64 cells, the post-processed solution is similar in qualityto the linear solution (not post-processed) at cycle 8 with 4,096cells. This clearly shows the superiority of high order methods for smoothsolutions. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_q3_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_q3_2.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="Convergencetables"></a></p><h4>Convergence tables</h4>
<p>When the program is run, it also outputs information about the respectivesteps and convergence tables with errors in the various components in theend. In 2D, the convergence tables look the following: </p><div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells dofs   val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01 2.207e+01   1.798e+01</div><div class="line">   31   170 9.874e+00 1.322e+01   9.798e+00</div><div class="line">   61   314 7.452e-01 3.793e+00   4.891e-01</div><div class="line">  121   634 3.240e-01 1.511e+00   2.616e-01</div><div class="line">  238  1198 8.585e-02 8.212e-01   1.808e-02</div><div class="line">  454  2290 4.802e-02 5.178e-01   2.195e-02</div><div class="line">  898  4378 2.561e-02 2.947e-01   4.318e-03</div><div class="line"> 1720  7864 1.306e-02 1.664e-01   2.978e-03</div><div class="line"> 3271 14638 7.025e-03 9.815e-02   1.075e-03</div><div class="line"> 6217 27214 4.119e-03 6.407e-02   9.975e-04</div><div class="line">  </div><div class="line">Q1 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 2.207e+01</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 1.798e+01</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-</div><div class="line">   36   168 6.125e+00 2.66 9.472e+00 2.09 6.084e+00 2.67</div><div class="line">   64   288 9.785e-01 6.38 4.260e+00 2.78 7.102e-01 7.47</div><div class="line">  144   624 2.730e-01 3.15 1.866e+00 2.04 6.115e-02 6.05</div><div class="line">  256  1088 1.493e-01 2.10 1.046e+00 2.01 2.880e-02 2.62</div><div class="line">  576  2400 6.965e-02 1.88 4.846e-01 1.90 9.204e-03 2.81</div><div class="line"> 1024  4224 4.018e-02 1.91 2.784e-01 1.93 4.027e-03 2.87</div><div class="line"> 2304  9408 1.831e-02 1.94 1.264e-01 1.95 1.236e-03 2.91</div><div class="line"> 4096 16640 1.043e-02 1.96 7.185e-02 1.96 5.306e-04 2.94</div><div class="line"> 9216 37248 4.690e-03 1.97 3.228e-02 1.97 1.599e-04 2.96</div><div class="line">  </div><div class="line">Q3 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16   160 3.613e-01</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 1.891e+00</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 3.020e-01</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-</div><div class="line">   36   336 6.411e-02 4.26 5.081e-01 3.24 3.238e-02 5.51</div><div class="line">   64   576 3.480e-02 2.12 2.533e-01 2.42 5.277e-03 6.31</div><div class="line">  144  1248 8.297e-03 3.54 5.924e-02 3.58 6.330e-04 5.23</div><div class="line">  256  2176 2.254e-03 4.53 1.636e-02 4.47 1.403e-04 5.24</div><div class="line">  576  4800 4.558e-04 3.94 3.277e-03 3.96 1.844e-05 5.01</div><div class="line"> 1024  8448 1.471e-04 3.93 1.052e-03 3.95 4.378e-06 5.00</div><div class="line"> 2304 18816 2.956e-05 3.96 2.104e-04 3.97 5.750e-07 5.01</div><div class="line"> 4096 33280 9.428e-06 3.97 6.697e-05 3.98 1.362e-07 5.01</div><div class="line"> 9216 74496 1.876e-06 3.98 1.330e-05 3.99 1.788e-08 5.01</div></div><!-- fragment --><p>One can see the error reduction upon grid refinement, and for the cases whereglobal refinement was performed, also the convergence rates. The quadraticconvergence rates of Q1 elements in the \(L_2\) norm for both the scalarvariable and the gradient variable is apparent, as is the cubic rate for thepostprocessed scalar variable in the \(L_2\) norm. Note this distinctivefeature of an HDG solution. In typical continuous finite elements, thegradient of the solution of order \(p\) converges at rate \(p\) only, asopposed to \(p+1\) for the actual solution. Even though superconvergenceresults for finite elements are also available (e.g. superconvergent patchrecovery first introduced by Zienkiewicz and Zhu), these are typically limitedto structured meshes and other special cases. For Q3 HDG variables, the scalarvariable and gradient converge at fourth order and the postprocessed scalarvariable at fifth order. The same convergence rates are observed in 3d. </p><div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells   dofs    val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00 1.941e+01   6.102e+00</div><div class="line">    29     500 3.309e+00 1.023e+01   2.145e+00</div><div class="line">   113    1792 2.204e+00 1.023e+01   1.912e+00</div><div class="line">   379    5732 6.085e-01 5.008e+00   2.233e-01</div><div class="line">  1317   19412 1.543e-01 1.464e+00   4.196e-02</div><div class="line">  4579   64768 5.058e-02 5.611e-01   9.521e-03</div><div class="line"> 14596  199552 2.129e-02 3.122e-01   4.569e-03</div><div class="line"> 46180  611400 1.033e-02 1.622e-01   1.684e-03</div><div class="line">144859 1864212 5.007e-03 8.371e-02   7.364e-04</div><div class="line">451060 5684508 2.518e-03 4.562e-02   3.070e-04</div><div class="line">  </div><div class="line">Q1 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>          grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 1.941e+01</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 6.102e+00</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-</div><div class="line">    27     432 5.491e+00 0.64 2.184e+01</div><div class="line">  </div><div class="line">-0.29 4.448e+00 0.78</div><div class="line">    64     960 3.646e+00 1.42 1.299e+01  1.81 3.306e+00 1.03</div><div class="line">   216    3024 1.595e+00 2.04 8.550e+00  1.03 1.441e+00 2.05</div><div class="line">   512    6912 6.922e-01 2.90 5.306e+00  1.66 2.511e-01 6.07</div><div class="line">  1728   22464 2.915e-01 2.13 2.490e+00  1.87 8.588e-02 2.65</div><div class="line">  4096   52224 1.684e-01 1.91 1.453e+00  1.87 4.055e-02 2.61</div><div class="line"> 13824  172800 7.972e-02 1.84 6.861e-01  1.85 1.335e-02 2.74</div><div class="line"> 32768  405504 4.637e-02 1.88 3.984e-01  1.89 5.932e-03 2.82</div><div class="line">110592 1354752 2.133e-02 1.92 1.830e-01  1.92 1.851e-03 2.87</div><div class="line">  </div><div class="line">Q3 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     576 5.670e+00</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 1.868e+01</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- 5.462e+00</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-</div><div class="line">    27    1728 1.048e+00 4.16 6.988e+00 2.42 8.011e-01 4.73</div><div class="line">    64    3840 2.831e-01 4.55 2.710e+00 3.29 1.363e-01 6.16</div><div class="line">   216   12096 7.883e-02 3.15 7.721e-01 3.10 2.158e-02 4.55</div><div class="line">   512   27648 3.642e-02 2.68 3.305e-01 2.95 5.231e-03 4.93</div><div class="line">  1728   89856 8.546e-03 3.58 7.581e-02 3.63 7.640e-04 4.74</div><div class="line">  4096  208896 2.598e-03 4.14 2.313e-02 4.13 1.783e-04 5.06</div><div class="line"> 13824  691200 5.314e-04 3.91 4.697e-03 3.93 2.355e-05 4.99</div><div class="line"> 32768 1622016 1.723e-04 3.91 1.517e-03 3.93 5.602e-06 4.99</div><div class="line">110592 5419008 3.482e-05 3.94 3.055e-04 3.95 7.374e-07 5.00</div></div><!-- fragment --><p><a class="anchor" id="Comparisonwithcontinuousfiniteelements"></a></p><h3>Comparison with continuous finite elements</h3>
<p><a class="anchor" id="Resultsfor2D"></a></p><h4>Results for 2D</h4>
<p>The convergence tables verify the expected convergence rates stated in theintroduction. Now, we want to show a quick comparison of the computationalefficiency of the HDG method compared to a usual finite element (continuousGalkerin) method on the problem of this tutorial. Of course, stability aspectsof the HDG method compared to continuous finite elements fortransport-dominated problems are also important in practice, which is anaspect not seen on a problem with smooth analytic solution. In the picturebelow, we compare the \(L_2\) error as a function of the number of degrees offreedom (left) and of the computing time spent in the linear solver (right)for two space dimensions of continuous finite elements (CG) and the hybridizeddiscontinuous Galerkin method presented in this tutorial. As opposed to thetutorial where we only use unpreconditioned BiCGStab, the times shown in thefigures below use the Trilinos algebraic multigrid preconditioner in <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. For the HDG part, a wrapper aroundChunkSparseMatrix for the trace variable has been used in order to utilize theblock structure in the matrix on the finest level. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_plain.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The results in the graphs show that the HDG method is slower than continuousfinite elements at \(p=1\) , about equally fast for cubic elements andfaster for sixth order elements. However, we have seen above that the HDGmethod actually produces solutions which are more accurate than what isrepresented in the original variables. Therefore, in the next two plots belowwe instead display the error of the post-processed solution for HDG (denotedby \(p=1^*\) for example). We now see a clear advantage of HDG for the sameamount of work for both \(p=3\) and \(p=6\) , and about the same qualityfor \(p=1\) . </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_post.png" width="400"/>
</div>
  </td></tr>
</table>
<p>Since the HDG method actually produces results converging as \(h^{p+2}\) , we should compare it to a continuous Galerkinsolution with the same asymptotic convergence behavior, i.e., <a class="el" href="classFE__Q.html">FE_Q</a> with degree \(p+1\) . If we do this, we get the convergence curves below. We see thatCG with second order polynomials is again clearly better than HDG withlinears. However, the advantage of HDG for higher orders remains. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The results are in line with properties of DG methods in general: Bestperformance is typically not achieved for linear elements, but rather atsomewhat higher order, usually around \(p=3\) . This is because of avolume-to-surface effect for discontinuous solutions with too much of thesolution living on the surfaces and hence duplicating work when the elementsare linear. Put in other words, DG methods are often most efficient when usedat relatively high order, despite their focus on a discontinuous (and hence,seemingly low accurate) representation of solutions. <a class="anchor" id="Resultsfor3D"></a></p><h4>Results for 3D</h4>
<p>We now show the same figures in 3D: The first row shows the number of degreesof freedom and computing time versus the \(L_2\) error in the scalar variable \(u\) for CG and HDG at order \(p\) , the second row shows thepost-processed HDG solution instead of the original one, and the third rowcompares the post-processed HDG solution with CG at order \(p+1\) . In 3D,the volume-to-surface effect makes the cost of HDG somewhat higher and the CGsolution is clearly better than HDG for linears by any metric. For cubics, HDGand CG are of similar quality, whereas HDG is again more efficient for sixthorder polynomials. One can alternatively also use the combination of FE_DGPand <a class="el" href="classFE__FaceP.html">FE_FaceP</a> instead of (<a class="el" href="classFE__DGQ.html">FE_DGQ</a>, <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>), which do not use tensor productpolynomials of degree \(p\) but Legendre polynomials of <em>complete</em>degree \(p\) . There are fewer degrees of freedom on the skeleton variablefor <a class="el" href="classFE__FaceP.html">FE_FaceP</a> for a given mesh size, but the solution quality (error vs. numberof DoFs) is very similar to the results for <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_plain.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_post.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>One final note on the efficiency comparison: We tried to use general-purposesparse matrix structures and similar solvers (optimal AMG preconditioners forboth without particular tuning of the AMG parameters on any of them) to give afair picture of the cost versus accuracy of two methods, on a toy example. Itshould be noted however that geometric multigrid (GMG) for continuous finiteelements is about a factor four to five faster for \(p=3\) and \(p=6\) . As of2019, optimal-complexity iterative solvers for HDG are still under developmentin the research community. Also, there are other implementation aspects for CGavailable such as fast matrix-free approaches as shown in <a class="el" href="step_37.html">step-37</a> that makehigher order continuous elements more competitive. Again, it is not clear tothe authors of the tutorial whether similar improvements could be made forHDG. We refer to <a href="https://dx.doi.org/10.1137/16M110455X">Kronbichler and Wall (2018)</a> for a recent efficiency evaluation.</p>
<p><a class="anchor" id="Possibilitiesforimprovements"></a></p><h3>Possibilities for improvements</h3>
<p>As already mentioned in the introduction, one possibility is to implementanother post-processing technique as discussed in the literature. A second item that is not done optimally relates to the performance of thisprogram, which is of course an issue in practical applications (weighing inalso the better solution quality of (H)DG methods for transport-dominatedproblems). Let us look atthe computing time of the tutorial program and the share of the individualcomponents: </p><table align="center" class="doxtable">
<tr>
<th>&#160; </th><th>&#160; </th><th>Setup </th><th>Assemble </th><th>Solve </th><th>Trace reconstruct </th><th>Post-processing </th><th>Output  </th></tr>
<tr>
<th>&#160; </th><th>Total time </th><th colspan="6">Relative share  </th></tr>
<tr>
<td align="left">2D, Q1, cycle 9, 37,248 dofs </td><td align="center">5.34s </td><td align="center">0.7% </td><td align="center">1.2% </td><td align="center">89.5% </td><td align="center">0.9% </td><td align="center">2.3% </td><td align="center">5.4%  </td></tr>
<tr>
<td align="left">2D, Q3, cycle 9, 74,496 dofs </td><td align="center">22.2s </td><td align="center">0.4% </td><td align="center">4.3% </td><td align="center">84.1% </td><td align="center">4.1% </td><td align="center">3.5% </td><td align="center">3.6%  </td></tr>
<tr>
<td align="left">3D, Q1, cycle 7, 172,800 dofs </td><td align="center">9.06s </td><td align="center">3.1% </td><td align="center">8.9% </td><td align="center">42.7% </td><td align="center">7.0% </td><td align="center">20.6% </td><td align="center">17.7%  </td></tr>
<tr>
<td align="left">3D, Q3, cycle 7, 691,200 dofs </td><td align="center">516s </td><td align="center">0.6% </td><td align="center">34.5% </td><td align="center">13.4% </td><td align="center">32.8% </td><td align="center">17.1% </td><td align="center">1.5%  </td></tr>
</table>
<p>As can be seen from the table, the solver and assembly calls dominate theruntime of the program. This also gives a clear indication of whereimprovements would make the most sense: </p><ol>
<li>
Better linear solvers: We use a BiCGStab iterative solver without preconditioner, where the number of iteration increases with increasing problem size (the number of iterations for Q1 elements and global refinements starts at 35 for the small sizes but increase up to 701 for the largest size). To do better, one could for example use an algebraic multigrid preconditioner from Trilinos, or some more advanced variants as the one discussed in <a href="https://dx.doi.org/10.1137/16M110455X">Kronbichler and Wall (2018)</a>. For diffusion-dominated problems such as the problem at hand with finer meshes, such a solver can be designed that uses the matrix-vector products from the more efficient <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> on the finest level, as long as we are not working in parallel with MPI. For MPI-parallelized computations, a standard <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> can be used. </li>
<li>
Speed up assembly by pre-assembling parts that do not change from one cell to another (those that do neither contain variable coefficients nor mapping-dependent terms). </li>
</ol>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2013 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Martin Kronbichler, Technische Universität München,</span></div><div class="line"><span class="comment"> *         Scott T. Miller, The Pennsylvania State University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2exceptions_8h.html">deal.II/base/exceptions.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chunk__sparse__matrix_8h.html">deal.II/lac/chunk_sparse_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionBase</div><div class="line">  {</div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">    SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers] =</div><div class="line">      {<a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)};</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">    SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers] =</div><div class="line">      {<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">    SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers] = {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6, -0.5, -0.125),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5, -0.5, 0.5)};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1. / 5.;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordtype">double</span> sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">          sum +=</div><div class="line">            <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">          sum +=</div><div class="line">            (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">             std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) *</div><div class="line">             x_minus_xi);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SolutionAndGradient()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  v)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.size(), dim + 1);</div><div class="line">      Solution&lt;dim&gt;  solution;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad = solution.gradient(p);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        v[d] = -grad[d];</div><div class="line">      v[dim] = solution.value(p);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ConvectionVelocity()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection;</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> 1:</div><div class="line">            convection[0] = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 2:</div><div class="line">            convection[0] = p[1];</div><div class="line">            convection[1] = -p[0];</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 3:</div><div class="line">            convection[0] = p[1];</div><div class="line">            convection[1] = -p[0];</div><div class="line">            convection[2] = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line">      <span class="keywordflow">return</span> convection;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          convection = convection_velocity.value(p);</div><div class="line">      <span class="keywordtype">double</span>                  sum        = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">          sum +=</div><div class="line">            ((2 * dim - 2 * convection * x_minus_xi -</div><div class="line">              4 * x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) /</div><div class="line">             (this-&gt;width * this-&gt;width) *</div><div class="line">             std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>HDG</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> RefinementMode</div><div class="line">    {</div><div class="line">      global_refinement,</div><div class="line">      adaptive_refinement</div><div class="line">    };</div><div class="line"></div><div class="line">    HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> postprocess();</div><div class="line">    <span class="keywordtype">void</span> refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData;</div><div class="line">    <span class="keyword">struct </span>ScratchData;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PostProcessScratchData;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system_one_cell(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      ScratchData &amp;                                         scratch,</div><div class="line">      PerTaskData &amp;                                         task_data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> postprocess_one_cell(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      PostProcessScratchData &amp;                              scratch,</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        empty_data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe_local;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_local;</div><div class="line">    Vector&lt;double&gt;  solution_local;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>   fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    Vector&lt;double&gt;  solution;</div><div class="line">    Vector&lt;double&gt;  system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>     fe_u_post;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_u_post;</div><div class="line">    Vector&lt;double&gt;  solution_u_post;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">    <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  HDG&lt;dim&gt;::HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode)</div><div class="line">    : fe_local(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim, <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler_local(triangulation)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe_u_post(degree + 1)</div><div class="line">    , dof_handler_u_post(triangulation)</div><div class="line">    , refinement_mode(refinement_mode)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler_local.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_local);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    solution_local.reinit(dof_handler_local.n_dofs());</div><div class="line">    solution_u_post.reinit(dof_handler_u_post.n_dofs());</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt; boundary_functions;</div><div class="line">    Solution&lt;dim&gt;                                       solution_function;</div><div class="line">    boundary_functions[0] = &amp;solution_function;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>(dof_handler,</div><div class="line">                                         boundary_functions,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a>());</div><div class="line">    }</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_vector;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">    PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">      : cell_matrix(n_dofs, n_dofs)</div><div class="line">      , cell_vector(n_dofs)</div><div class="line">      , dof_indices(n_dofs)</div><div class="line">      , trace_reconstruct(trace_reconstruct)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">    Vector&lt;double&gt;     l_rhs;</div><div class="line">    Vector&lt;double&gt;     tmp_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; q_phi;</div><div class="line">    std::vector&lt;double&gt;         q_phi_div;</div><div class="line">    std::vector&lt;double&gt;         u_phi;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_phi_grad;</div><div class="line">    std::vector&lt;double&gt;         tr_phi;</div><div class="line">    std::vector&lt;double&gt;         trace_values;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_local_support_on_face;</div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_support_on_face;</div><div class="line"></div><div class="line">    ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">    RightHandSide&lt;dim&gt;      right_hand_side;</div><div class="line">    <span class="keyword">const</span> Solution&lt;dim&gt;     exact_solution;</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp;   face_quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_face_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">      : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">      , fe_face_values_local(fe_local,</div><div class="line">                             face_quadrature_formula,</div><div class="line">                             local_face_flags)</div><div class="line">      , fe_face_values(fe, face_quadrature_formula, flags)</div><div class="line">      , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">      , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , l_rhs(fe_local.n_dofs_per_cell())</div><div class="line">      , tmp_rhs(fe_local.n_dofs_per_cell())</div><div class="line">      , q_phi(fe_local.n_dofs_per_cell())</div><div class="line">      , q_phi_div(fe_local.n_dofs_per_cell())</div><div class="line">      , u_phi(fe_local.n_dofs_per_cell())</div><div class="line">      , u_phi_grad(fe_local.n_dofs_per_cell())</div><div class="line">      , tr_phi(fe.n_dofs_per_cell())</div><div class="line">      , trace_values(face_quadrature_formula.size())</div><div class="line">      , fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">      , fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">      , exact_solution()</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_local.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">              fe_local_support_on_face[face_no].push_back(i);</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">              fe_support_on_face[face_no].push_back(i);</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">      : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                        sd.fe_values_local.get_quadrature(),</div><div class="line">                        sd.fe_values_local.get_update_flags())</div><div class="line">      , fe_face_values_local(sd.fe_face_values_local.get_fe(),</div><div class="line">                             sd.fe_face_values_local.get_quadrature(),</div><div class="line">                             sd.fe_face_values_local.get_update_flags())</div><div class="line">      , fe_face_values(sd.fe_face_values.get_fe(),</div><div class="line">                       sd.fe_face_values.get_quadrature(),</div><div class="line">                       sd.fe_face_values.get_update_flags())</div><div class="line">      , ll_matrix(sd.ll_matrix)</div><div class="line">      , lf_matrix(sd.lf_matrix)</div><div class="line">      , fl_matrix(sd.fl_matrix)</div><div class="line">      , tmp_matrix(sd.tmp_matrix)</div><div class="line">      , l_rhs(sd.l_rhs)</div><div class="line">      , tmp_rhs(sd.tmp_rhs)</div><div class="line">      , q_phi(sd.q_phi)</div><div class="line">      , q_phi_div(sd.q_phi_div)</div><div class="line">      , u_phi(sd.u_phi)</div><div class="line">      , u_phi_grad(sd.u_phi_grad)</div><div class="line">      , tr_phi(sd.tr_phi)</div><div class="line">      , trace_values(sd.trace_values)</div><div class="line">      , fe_local_support_on_face(sd.fe_local_support_on_face)</div><div class="line">      , fe_support_on_face(sd.fe_support_on_face)</div><div class="line">      , exact_solution()</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         u_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_gradients;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs;</div><div class="line">    Vector&lt;double&gt; cell_sol;</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">      : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">      , fe_values(fe, quadrature_formula, flags)</div><div class="line">      , u_values(quadrature_formula.size())</div><div class="line">      , u_gradients(quadrature_formula.size())</div><div class="line">      , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">      , cell_rhs(fe.n_dofs_per_cell())</div><div class="line">      , cell_sol(fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">      : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                        sd.fe_values_local.get_quadrature(),</div><div class="line">                        sd.fe_values_local.get_update_flags())</div><div class="line">      , fe_values(sd.fe_values.get_fe(),</div><div class="line">                  sd.fe_values.get_quadrature(),</div><div class="line">                  sd.fe_values.get_update_flags())</div><div class="line">      , u_values(sd.u_values)</div><div class="line">      , u_gradients(sd.u_gradients)</div><div class="line">      , cell_matrix(sd.cell_matrix)</div><div class="line">      , cell_rhs(sd.cell_rhs)</div><div class="line">      , cell_sol(sd.cell_sol)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PerTaskData task_data(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(), trace_reconstruct);</div><div class="line">    ScratchData scratch(fe,</div><div class="line">                        fe_local,</div><div class="line">                        quadrature_formula,</div><div class="line">                        face_quadrature_formula,</div><div class="line">                        local_flags,</div><div class="line">                        local_face_flags,</div><div class="line">                        flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    *<span class="keyword">this</span>,</div><div class="line">                    &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                    &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                    scratch,</div><div class="line">                    task_data);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system_one_cell(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    ScratchData &amp;                                         scratch,</div><div class="line">    PerTaskData &amp;                                         task_data)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                            cell-&gt;level(),</div><div class="line">                                                            cell-&gt;index(),</div><div class="line">                                                            &amp;dof_handler_local);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch.fe_values_local.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">      scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell =</div><div class="line">      scratch.fe_values_local.get_fe().n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">    scratch.ll_matrix = 0;</div><div class="line">    scratch.l_rhs     = 0;</div><div class="line">    <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">      {</div><div class="line">        scratch.lf_matrix     = 0;</div><div class="line">        scratch.fl_matrix     = 0;</div><div class="line">        task_data.cell_matrix = 0;</div><div class="line">        task_data.cell_vector = 0;</div><div class="line">      }</div><div class="line">    scratch.fe_values_local.reinit(loc_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value = scratch.right_hand_side.value(</div><div class="line">          scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection = scratch.convection_velocity.value(</div><div class="line">          scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; loc_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);</div><div class="line">            scratch.q_phi_div[k] =</div><div class="line">              scratch.fe_values_local[fluxes].divergence(k, q);</div><div class="line">            scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);</div><div class="line">            scratch.u_phi_grad[k] =</div><div class="line">              scratch.fe_values_local[scalar].gradient(k, q);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; loc_dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; loc_dofs_per_cell; ++j)</div><div class="line">              scratch.ll_matrix(i, j) +=</div><div class="line">                (scratch.q_phi[i] * scratch.q_phi[j] -</div><div class="line">                 scratch.q_phi_div[i] * scratch.u_phi[j] +</div><div class="line">                 scratch.u_phi[i] * scratch.q_phi_div[j] -</div><div class="line">                 (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]) *</div><div class="line">                JxW;</div><div class="line">            scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">      {</div><div class="line">        scratch.fe_face_values_local.reinit(loc_cell, face_no);</div><div class="line">        scratch.fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">          scratch.fe_face_values.get_function_values(solution,</div><div class="line">                                                     scratch.trace_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>     JxW = scratch.fe_face_values.JxW(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">              scratch.fe_face_values.quadrature_point(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal =</div><div class="line">              scratch.fe_face_values.normal_vector(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection =</div><div class="line">              scratch.convection_velocity.value(quadrature_point);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. + <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(convection * normal));</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">                 k &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                 ++k)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk =</div><div class="line">                  scratch.fe_local_support_on_face[face_no][k];</div><div class="line">                scratch.q_phi[k] =</div><div class="line">                  scratch.fe_face_values_local[fluxes].value(kk, q);</div><div class="line">                scratch.u_phi[k] =</div><div class="line">                  scratch.fe_face_values_local[scalar].value(kk, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">                     k &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                     ++k)</div><div class="line">                  scratch.tr_phi[k] = scratch.fe_face_values.shape_value(</div><div class="line">                    scratch.fe_support_on_face[face_no][k], q);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                     i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                       j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                        scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                        scratch.fe_support_on_face[face_no][j];</div><div class="line">                      scratch.lf_matrix(ii, jj) +=</div><div class="line">                        ((scratch.q_phi[i] * normal +</div><div class="line">                          (convection * normal - tau_stab) * scratch.u_phi[i]) *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line"></div><div class="line">                      scratch.fl_matrix(jj, ii) -=</div><div class="line">                        ((scratch.q_phi[i] * normal +</div><div class="line">                          tau_stab * scratch.u_phi[i]) *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                     i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                       j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                        scratch.fe_support_on_face[face_no][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                        scratch.fe_support_on_face[face_no][j];</div><div class="line">                      task_data.cell_matrix(ii, jj) +=</div><div class="line">                        ((convection * normal - tau_stab) * scratch.tr_phi[i] *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">                    (cell-&gt;face(face_no)-&gt;boundary_id() == 1))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">                      -scratch.exact_solution.gradient(quadrature_point) *</div><div class="line">                        normal +</div><div class="line">                      convection * normal *</div><div class="line">                        scratch.exact_solution.value(quadrature_point);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                         i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                         ++i)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                          scratch.fe_support_on_face[face_no][i];</div><div class="line">                        task_data.cell_vector(ii) +=</div><div class="line">                          scratch.tr_phi[i] * neumann_value * JxW;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                 i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                 ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                   j &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                   ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][j];</div><div class="line">                  scratch.ll_matrix(ii, jj) +=</div><div class="line">                    tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;</div><div class="line">                }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                   i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                   ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                  scratch.l_rhs(ii) -=</div><div class="line">                    (scratch.q_phi[i] * normal +</div><div class="line">                     scratch.u_phi[i] * (convection * normal - tau_stab)) *</div><div class="line">                    scratch.trace_values[q] * JxW;</div><div class="line">                }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    scratch.ll_matrix.gauss_jordan();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">        scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">        scratch.tmp_matrix.mmult(task_data.cell_matrix,</div><div class="line">                                 scratch.lf_matrix,</div><div class="line">                                 <span class="keyword">true</span>);</div><div class="line">        cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">        loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      constraints.distribute_local_to_global(data.cell_matrix,</div><div class="line">                                             data.cell_vector,</div><div class="line">                                             data.dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                  solver_control(system_matrix.m() * 10,</div><div class="line">                                 1e-11 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span></div><div class="line">              &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0, 0, 0, 1);</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    assemble_system(<span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_u_post.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      PostProcessScratchData scratch(</div><div class="line">        fe_u_post, fe_local, quadrature_formula, local_flags, flags);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">        dof_handler_u_post.begin_active(),</div><div class="line">        dof_handler_u_post.end(),</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">               PostProcessScratchData &amp;                              scratch,</div><div class="line">               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        data) {</div><div class="line">          this-&gt;postprocess_one_cell(cell, scratch, data);</div><div class="line">        },</div><div class="line">        std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">        scratch,</div><div class="line">        0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select(dim, dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                      solution_local,</div><div class="line">                                      SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;value_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select(</div><div class="line">      std::pair&lt;unsigned int, unsigned int&gt;(0, dim), dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                      solution_local,</div><div class="line">                                      SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;gradient_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_u_post,</div><div class="line">                                      solution_u_post,</div><div class="line">                                      Solution&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 3),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> post_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>, L2_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>, grad_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess_one_cell(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    PostProcessScratchData &amp;                              scratch,</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                            cell-&gt;level(),</div><div class="line">                                                            cell-&gt;index(),</div><div class="line">                                                            &amp;dof_handler_local);</div><div class="line"></div><div class="line">    scratch.fe_values_local.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(loc_cell);</div><div class="line">    scratch.fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line"></div><div class="line">    scratch.fe_values_local[scalar].get_function_values(solution_local,</div><div class="line">                                                        scratch.u_values);</div><div class="line">    scratch.fe_values_local[fluxes].get_function_values(solution_local,</div><div class="line">                                                        scratch.u_gradients);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            sum = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              sum += (scratch.fe_values.shape_grad(i, q) *</div><div class="line">                      scratch.fe_values.shape_grad(j, q)) *</div><div class="line">                     scratch.fe_values.JxW(q);</div><div class="line">            scratch.cell_matrix(i, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">          }</div><div class="line"></div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) *</div><div class="line">                 scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_rhs(i) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_matrix(0, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      }</div><div class="line">    {</div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        sum += scratch.u_values[q] * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_rhs(0) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    scratch.cell_matrix.gauss_jordan();</div><div class="line">    scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">    cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    std::string filename;</div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> global_refinement:</div><div class="line">          filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">          filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    std::string face_out(filename);</div><div class="line">    face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">    filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">    filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">    filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; names(dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">    names.emplace_back(<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      component_interpretation(</div><div class="line">        dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    component_interpretation[dim] =</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_local,</div><div class="line">                             solution_local,</div><div class="line">                             names,</div><div class="line">                             component_interpretation);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; post_name(1, <span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_u_post,</div><div class="line">                             solution_u_post,</div><div class="line">                             post_name,</div><div class="line">                             post_comp_type);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">    face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">    face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">    face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream face_output(face_out);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a>        data_out_face(<span class="keyword">false</span>);</div><div class="line">    std::vector&lt;std::string&gt; face_name(1, <span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    data_out_face.add_data_vector(dof_handler,</div><div class="line">                                  solution,</div><div class="line">                                  face_name,</div><div class="line">                                  face_component_type);</div><div class="line"></div><div class="line">    data_out_face.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out_face.write_vtk(face_output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 2, -1, 1);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> global_refinement:</div><div class="line">            {</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">              <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation,</div><div class="line">                                                   2 + (cycle % 2),</div><div class="line">                                                   -1,</div><div class="line">                                                   1);</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim + cycle / 2);</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">            {</div><div class="line">              Vector&lt;float&gt; estimated_error_per_cell(</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">              <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">              std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">                neumann_boundary;</div><div class="line">              <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler_local,</div><div class="line">                                                 <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                                 neumann_boundary,</div><div class="line">                                                 solution_local,</div><div class="line">                                                 estimated_error_per_cell,</div><div class="line">                                                 fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(</div><div class="line">                                                   scalar));</div><div class="line"></div><div class="line">              <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">                triangulation, estimated_error_per_cell, 0.3, 0.);</div><div class="line"></div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(0) - (-1)) &lt; 1e-12) ||</div><div class="line">              (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HDG&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 10; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        refine_grid(cycle);</div><div class="line">        setup_system();</div><div class="line">        assemble_system(<span class="keyword">false</span>);</div><div class="line">        solve();</div><div class="line">        postprocess();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>, <a class="el" href="step_9.html">step-9</a>, <a class="el" href="step_61.html">step-61</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HybridizablediscontinuousGalerkinmethods"> Hybridizable discontinuous Galerkin methods </a>
      <ul>
        <li><a href="#Reducingthesizeofthelinearsystem"> Reducing the size of the linear system </a>
        <li><a href="#RelationwithStaticCondensation"> Relation with Static Condensation </a>
        <li><a href="#Solutionqualityandratesofconvergence"> Solution quality and rates of convergence</a>
        <li><a href="#Alternativeapproaches"> Alternative approaches </a>
      </ul>
        <li><a href="#HDGappliedtotheconvectiondiffusionproblem"> HDG applied to the convection-diffusion problem </a>
      <ul>
        <li><a href="#Postprocessingandsuperconvergence"> Post-processing and super-convergence </a>
      </ul>
        <li><a href="#Problemspecificdata"> Problem specific data </a>
        <li><a href="#Implementation"> Implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheHDGsolverclass">The HDG solver class</a>
        <li><a href="#TheHDGclassimplementation">The HDG class implementation</a>
      <ul>
        <li><a href="#Constructor">Constructor</a>
        <li><a href="#HDGsetup_system">HDG::setup_system</a>
        <li><a href="#HDGPerTaskData">HDG::PerTaskData</a>
        <li><a href="#HDGScratchData">HDG::ScratchData</a>
        <li><a href="#HDGPostProcessScratchData">HDG::PostProcessScratchData</a>
        <li><a href="#HDGassemble_system">HDG::assemble_system</a>
        <li><a href="#HDGassemble_system_one_cell">HDG::assemble_system_one_cell</a>
        <li><a href="#HDGcopy_local_to_global">HDG::copy_local_to_global</a>
        <li><a href="#HDGsolve">HDG::solve</a>
        <li><a href="#HDGpostprocess">HDG::postprocess</a>
        <li><a href="#HDGpostprocess_one_cell">HDG::postprocess_one_cell</a>
        <li><a href="#HDGoutput_results">HDG::output_results</a>
        <li><a href="#HDGrefine_grid">HDG::refine_grid</a>
        <li><a href="#HDGrun">HDG::run</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
      <ul>
        <li><a href="#Convergencetables">Convergence tables</a>
      </ul>
        <li><a href="#Comparisonwithcontinuousfiniteelements">Comparison with continuous finite elements</a>
      <ul>
        <li><a href="#Resultsfor2D">Results for 2D</a>
        <li><a href="#Resultsfor3D">Results for 3D</a>
      </ul>
        <li><a href="#Possibilitiesforimprovements">Possibilities for improvements</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-51/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Martin Kronbichler and Scott Miller. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>本教程程序介绍了对流-扩散方程的可混合的不连续Galkerin方法的实现。</p>
<p><a class="anchor" id="HybridizablediscontinuousGalerkinmethods"></a></p><h3>Hybridizable discontinuous Galerkin methods </h3>
<p>反对使用非连续Galerkin元素的一个常见论点是，在隐式系统中必须解决大量的全局耦合自由度。 这是因为，与连续有限元不同，在典型的非连续元中，每个顶点有一个自由度<em>for each of the adjacent elements</em>，而不是只有一个，对边和面也是如此。 作为未知数增长速度的例子，请考虑FE_DGPMonomial基础：每个标量解分量都由度数为 \(p\) 的多项式表示，每个元素有 \((1/\text{dim}!) \prod_{i=1}^{\text{dim}}(p+i)\) 个自由度。通常，一个元素的所有自由度都与相邻元素的所有自由度相耦合。 由此产生的离散方程会很快产生非常大的线性系统，特别是对于2或3维的方程系统。</p>
<p><a class="anchor" id="Reducingthesizeofthelinearsystem"></a></p><h4>Reducing the size of the linear system </h4>
<p>为了减轻解决这种大型线性系统的计算成本，Cockburn和同事们引入了可混合的非连续Galerkin（HDG）方法（见Nguyen和Peraire最近发表的HDG概述文章中的参考资料 <b>[Ngu2012]</b> ）。</p>
<p>HDG方法通过使用Dirichlet-to-Neumann映射对数学问题进行表述来实现这一目标。 偏微分方程首先被写成一阶系统，然后每个场通过DG方法进行离散。 在这一点上，网格骨架上的单值 "跟踪 "值，即元素面，被视为独立的未知量。这就产生了离散公式中的未知数，这些未知数分为两类。</p>
<ul>
<li>面的未知数，只与面的两边的单元格未知数耦合。</li>
<li>单元未知数只与同一单元内定义的单元和面未知数相耦合。最重要的是，一个单元格的内部自由度不会与另一个单元格的任何内部自由度相耦合。</li>
</ul>
<p>然后，Dirichlet-to-Neumann地图的概念允许以下解决程序。</p><ol>
<li>
使用局部元素内部数据来强制执行三角形骨架上的Neumann条件。 然后，全局问题是求解轨迹值，这是唯一全局耦合的未知数。 </li>
<li>
使用已知的骨架值作为Dirichlet数据来求解局部元素级的解决方案。 这被称为 "局部求解器"，是一个<em>embarrassingly parallel</em>逐个元素的求解过程。 </li>
</ol>
<p><a class="anchor" id="RelationwithStaticCondensation"></a></p><h4>Relation with Static Condensation </h4>
<p>上述程序也有线性代数的解释&ndash;被称为<em>static condensation</em>&ndash;被Guyan在连续有限元的背景下 <b>[G65]</b> ，以及被Fraeijs de Veubeke用于混合方法 <b>[F65]</b> ，用来减少全局线性系统的大小。在后一种情况下（混合公式），系统的减少是通过使用不连续的通量，结合引入一个额外的辅助变量<em>hybrid</em>来实现的，该变量在每个元素的边界上近似于未知数的轨迹。这个过程被称为混合化，并且通过类比，这也是为什么Cockburn、Gopalakrishnan和Lazarov在2009年引入的局部非连续Galerkin方法 <b>[CGL2009]</b> ，以及随后由他们的合作者开发，最终被称为<em>hybridizable discontinuous Galerkin</em>（HDG）方法的原因。</p>
<p>让我们把与HDG问题相关的完整线性系统写成一个块状系统，离散DG（单元内部）变量 \(U\) 为第一块，骨架（面）变量 \(\Lambda\) 为第二块。</p>
<p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} A &amp; B \\ C &amp; D \end{pmatrix} \begin{pmatrix} U \\ \Lambda \end{pmatrix} = \begin{pmatrix} F \\ G \end{pmatrix}. \end{eqnarray*}
</p>
<p>我们现在的目的是用类似于步骤20的舒尔补码方法来消除 \(U\) 块，这导致了以下两个步骤。</p>
<p class="formulaDsp">
\begin{eqnarray*} (D - C A^{-1} B) \Lambda &amp;=&amp; G - C A^{-1} F, \\ A U &amp;=&amp; F - B \Lambda. \end{eqnarray*}
</p>
<p>关键是 \(A^{-1}\) 的存在不是问题，因为 \(A\) 是一个块对角线矩阵，每个块对应一个单元，因此足够容易反转。与其他单元的耦合是由骨架变量上的矩阵 \(B\) 和 \(C\) 引入的。 \(A\) 的块对角性以及 \(B\) 和 \(C\) 的结构使我们能够逐元反转矩阵 \(A\) （迪里希特问题的局部解），并从 \(D\) 中减去 \(CA^{-1}B\) 。因此，迪里切特到诺曼映射概念的步骤对应于</p><ol>
<li>
构建舒尔补码矩阵 \(D-C A^{-1} B\) 和右手边 \(G - C A^{-1} F\) <em>locally on each cell</em>并以通常的方式将贡献插入全局跟踪矩阵， </li>
<li>
求解舒尔互补系统 \(\Lambda\) ， </li>
<li>
使用第二个方程求解 \(U\) ，给出 \(\Lambda\) 。 </li>
</ol>
<p><a class="anchor" id="Solutionqualityandratesofconvergence"></a></p><h4>Solution quality and rates of convergence</h4>
<p>对传统DG方法的另一个批评是，近似通量的收敛是次优的。 局部HDG解可以被证明是收敛的 \(\mathcal{O}(h^{p+1})\) ，即以最优顺序收敛。 此外，还可以利用超级收敛特性对新的近似解进行后处理，使其以 \(\mathcal{O}(h^{p+2})\) 的速率收敛。</p>
<p><a class="anchor" id="Alternativeapproaches"></a></p><h4>Alternative approaches </h4>
<p>可混合的非连续Galerkin方法只是解决非连续Galerkin方法的问题的一种方法。另一个想法是所谓的 "弱Galerkin "方法。它在步骤61中进行了探讨。</p>
<p><a class="anchor" id="HDGappliedtotheconvectiondiffusionproblem"></a></p><h3>HDG applied to the convection-diffusion problem </h3>
<p>本例中使用的HDG公式取自 <br />
 <b> N.C. Nguyen, J. Peraire, B. Cockburn: <em>An implicit high-order hybridizable discontinuous Galerkin method for linear convection–diffusion equations</em><em>An implicit high-order hybridizable discontinuous Galerkin method for linear convection–diffusion equations</em>, Journal of Computational <a class="el" href="namespacePhysics.html">Physics</a>, 2009, 228:9, 3232-3254. <a href="http://dx.doi.org/10.1016/j.jcp.2009.01.030">[DOI]</a><a href="http://dx.doi.org/10.1016/j.jcp.2009.01.030">[DOI]</a> </b>。</p>
<p>我们考虑域 \(\Omega\) 上的对流-扩散方程，该方程具有迪里切特边界 \(\partial \Omega_D\) 和诺伊曼边界 \(\partial \Omega_N\) 。</p>
<p class="formulaDsp">
\begin{eqnarray*} \nabla \cdot (\mathbf{c} u) - \nabla \cdot (\kappa \nabla u) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{c} u - \kappa \nabla u)\cdot \mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}
</p>
<p>引入辅助变量 \(\mathbf{q}=-\kappa \nabla u\) ，将上述方程改写为一阶系统。</p>
<p class="formulaDsp">
\begin{eqnarray*} \mathbf{q} + \kappa \nabla u &amp;=&amp; 0, \quad \text{ in } \Omega, \\ \nabla \cdot (\mathbf{c} u + \mathbf{q}) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{q} + \mathbf{c}u)\cdot\mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}
</p>
<p>我们将这些方程乘以权重函数 \(\mathbf{v}, w\) ，并对每个元素 \(K\) 进行分项积分，得到。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\mathbf{v}, \kappa^{-1} \mathbf{q})_K - (\nabla\cdot\mathbf{v}, u)_K + \left&lt;\mathbf{v}\cdot\mathbf{n}, {\hat{u}}\right&gt;_{\partial K} &amp;=&amp; 0, \\ - (\nabla w, \mathbf{c} u + \mathbf{q})_K + \left&lt;w, (\widehat{\mathbf{c} u}+{\hat{\mathbf{q}}})\cdot\mathbf{n}\right&gt;_{\partial K} &amp;=&amp; (w,f)_K. \end{eqnarray*}
</p>
<p>带帽子的术语表示数值轨迹（通常也被称为数值通量）。 它们是对元素边界上的内部值的近似。 为了确保守恒，这些项在任何给定的元素边上都必须是单值的 \(\partial K\) ，尽管对于不连续的形状函数，当然可能有多个值来自界面附近的单元。我们通过使用以下形式的跟踪来消除数字跟踪 \(\hat{\mathbf{q}}\) 。</p>
<p class="formulaDsp">
\begin{eqnarray*} \widehat{\mathbf{c} u}+\hat{\mathbf{q}} = \mathbf{c}\hat{u} + \mathbf{q} + \tau(u - \hat{u})\mathbf{n} \quad \text{ on } \partial K. \end{eqnarray*}
</p>
<p>变量 \(\hat {u}\) 作为一个额外的自变量被引入，是我们最终建立一个全局耦合线性系统的变量。如上所述，它被定义在元素面上，并且在面与面的交汇处（2D中的顶点，3D中的边缘和顶点）不连续。数值跟踪函数中出现的 \(u\) 和 \(\mathbf{q}\) 的值被认为是限制在边界 \(\partial K\) 的单元内部解。</p>
<p>局部稳定参数 \(\tau\) 对HDG解决方案的稳定性和准确性有影响；进一步的讨论见文献。据报道，稳定参数为1是给出最佳结果的选择。趋向于无穷大的稳定参数 \(\tau\) 禁止解在元素边界上的跳跃，使HDG解接近连续有限元素的近似值。在下面的程序中，我们选择稳定参数为</p>
<p class="formulaDsp">
\begin{eqnarray*} \tau = \frac{\kappa}{\ell} + |\mathbf{c} \cdot \mathbf{n}| \end{eqnarray*}
</p>
<p>其中我们设定扩散 \(\kappa=1\) 和扩散长度尺度为 \(\ell = \frac{1}{5}\) 。</p>
<p>HDG方法中的轨迹/骨架变量在元素面上是单值的。 因此，它们必须强烈地代表 \(\partial\Omega_D\) 上的迪里希特数据。 这意味着</p>
<p class="formulaDsp">
\begin{equation*} \hat{u}|_{\partial \Omega_D} = g_D, \end{equation*}
</p>
<p>其中等号实际上是指边界函数 \(L_2\) 对脸部变量空间的 \(g\) 投射（例如脸部的线性函数）。然后，这个约束被应用于骨架变量 \(\hat{u}\) ，使用非均质约束的方法 <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>. 。</p>
<p>将三角结构中所有元素的贡献相加，强制执行数值通量的法线分量，并对由 \(w\) 加权的方程进行分项积分，我们得出问题的最终形式：找到 \((\mathbf{q}_h, u_h, \hat{u}_h) \in \mathcal{V}_h^p \times \mathcal{W}_h^p \times \mathcal{M}_h^p\) ，以便</p>
<p class="formulaDsp">
\begin{align*} (\mathbf{v}, \kappa^{-1} \mathbf{q}_h)_{\mathcal{T}} - ( \nabla\cdot\mathbf{v}, u_h)_{\mathcal{T}} + \left&lt;\mathbf{v}\cdot\mathbf{n}, \hat{u}_h\right&gt;_{\partial\mathcal{T}} &amp;= 0, \quad &amp;&amp;\forall \mathbf{v} \in \mathcal{V}_h^p, \\ - (\nabla w, \mathbf{c} u_h)_{\mathcal{T}} + (w, \nabla \cdot \mathbf{q}_h)_{\mathcal{T}} + (w, (\mathbf{c}\cdot\mathbf{n}) \hat{u}_h)_{\partial \mathcal{T}} + \left&lt;w, \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= (w, f)_{\mathcal{T}}, \quad &amp;&amp;\forall w \in \mathcal{W}_h^p, \\ \left&lt; \mu, \hat{u}_h\mathbf{c} \cdot \mathbf{n} + \mathbf{q}_h\cdot \mathbf{n} + \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= \left&lt;\mu, g_N\right&gt;_{\partial\Omega_N}, \quad &amp;&amp;\forall \mu \in \mathcal{M}_h^p. \end{align*}
</p>
<p>未知数 \((\mathbf{q}_h, u_h)\) 被称为局部变量；它们被表示为标准的DG变量。 未知数 \(\hat{u}_h\) 是骨架变量，在网格的一维表面（面）上有支持。</p>
<p>我们用符号 \((\cdot, \cdot)_{\mathcal{T}} = \sum_K (\cdot, \cdot)_K\) 表示所有单元的积分之和， \(\left&lt;\cdot, \cdot\right&gt;_{\partial \mathcal{T}} = \sum_K \left&lt;\cdot, \cdot\right&gt;_{\partial K}\) 表示所有单元的所有面的积分，也就是说，内部面被访问两次，一次来自每侧，并有相应的法向量。当结合共享一个面的两个元素的贡献时，上述方程产生了DG方法中熟悉的条款，解在单元格边界上有跳跃性。</p>
<p>在上述方程中，标量变量 \(\mathcal {W}_h^{p}\) 的空间 \(u_h\) 被定义为在每个单元上为张量积多项式 \(p\) 且在元素边界上不连续的函数空间 \(\mathcal Q_{-p}\) ，即由 <code>FE_DGQ&lt;dim&gt;(p)</code> 描述的空间。梯度或通量变量的空间 \(\mathbf{q}_i\) 是一个矢量元素空间，其中每个分量是局部多项式且不连续 \(\mathcal Q_{-p}\) 。在下面的代码中，我们将这两个局部部分收集在一个FESystem中，其中第一个 <code>dim组件表示梯度部分，最后一个标量组件对应标量变量。对于骨架部分</code> \(\hat{u}_h\) ，我们定义了一个由住在元素面上的不连续张量乘积多项式组成的空间，在deal.II中由FE_FaceQ类实现。这个空间在其他方面与FE_DGQ相似，即解函数在两个相邻的面之间不连续，也可参见下面的结果部分进行说明。</p>
<p>在上面给出的弱形式中，我们可以注意到以下的耦合模式。</p><ol>
<li>
矩阵 \(A\) 由局部-局部耦合项组成。 当局部加权函数 \((\mathbf{v}, w)\) 与局部求解项 \((\mathbf{q}_h, u_h)\) 相乘时就会产生这些耦合项。因为这些元素是不连续的， \(A\) 是块对角线。 </li>
<li>
矩阵 \(B\) 代表局部面的耦合。 这些是具有加权函数 \((\mathbf{v}, w)\) 的条款，乘以骨架变量 \(\hat{u}_h\) 。 </li>
<li>
矩阵 \(C\) 代表面-本地耦合，它涉及加权函数 \(\mu\) 乘以本地解 \((\mathbf{q}_h, u_h)\) 。 </li>
<li>
矩阵 \(D\) 是面-面耦合；条款涉及 \(\mu\) 和 \(\hat{u}_h\) 。 </li>
</ol>
<p><a class="anchor" id="Postprocessingandsuperconvergence"></a></p><h4>Post-processing and super-convergence </h4>
<p>HDG方法的一个特点是，它们通常允许构建一个丰富的解决方案，以提高精度。这种后处理方法以逐个元素的方式获取HDG解决方案，并将其结合起来，从而在使用度数为 \(p\) 的多项式时可以获得 \(\mathcal O(h^{p+2})\) 的精度。要做到这一点，有两个必要的成分。</p><ol>
<li>
计算的解梯度 \(\mathbf{q}_h\) 以最佳速度收敛，即 \(\mathcal{O}(h^{p+1})\) 。 </li>
<li>
解的标量部分的单元平均数， \(\frac{(1,u_h)_K}{\text{vol}(K)}\) ，以 \(\mathcal{O}(h^{p+2})\) 的速度超级收敛。 </li>
</ol>
<p>我们现在引入一个新的变量 \(u_h^* \in \mathcal{V}_h^{p+1}\) ，我们通过在约束条件 \(\left(1, u_h^*\right)_K = \left(1, u_h\right)_K\) 下对单元格 \(K\) 的表达式进行最小化来找到它。这个约束是必要的，因为最小化函数并不能确定 \(u_h^*\) 的常数部分。这就转化为以下方程组。</p>
<p class="formulaDsp">
\begin{eqnarray*} \left(1, u_h^*\right)_K &amp;=&amp; \left(1, u_h\right)_K\\ \left(\nabla w_h^*, \kappa \nabla u_h^*\right)_K &amp;=&amp; -\left(\nabla w_h^*, \mathbf{q}_h\right)_K \quad \text{for all } w_h^* \in \mathcal Q^{p+1}. \end{eqnarray*}
</p>
<p>由于我们在第二组方程中用度数为 \(p+1\) 的张量积多项式空间中的整组基函数进行测试，这是一个过度确定的系统，方程比未知数多一个。我们在下面的代码中通过省略其中一个方程来解决这个问题（因为拉普拉斯的行在代表一个常数函数时是线性依赖的）。正如我们将在下面看到的，这种形式的后处理给出了所需的超级收敛结果，速率为 \(\mathcal {O}(h^{p+2})\) 。 应该指出的是，在构建 \(u_h^*\) 时有一定的自由度，这种从梯度中提取信息的最小化方法不是唯一的方法。特别是，这里定义的后处理方案在任何意义上都不满足对流-扩散方程。作为替代方案，上面引用的Nguyen、Peraire和Cockburn的论文提出了另一个有点复杂的对流-扩散公式，该公式也可以将通量变量后处理为 \(H(\Omega,\mathrm{div})\) -符合的变体，并且在扩散较小时更好地表示局部对流-扩散算子。我们把更复杂的后处理的实现作为一个可能的扩展留给感兴趣的读者。</p>
<p>请注意，对于矢量值的问题，后处理的工作原理是类似的。我们只需为每个向量分量的平均值分别设置约束，并将梯度作为主要信息来源。</p>
<p><a class="anchor" id="Problemspecificdata"></a></p><h3>Problem specific data </h3>
<p>在这个教程程序中，我们考虑的测试案例与步骤7中的几乎相同。计算域是 \(\Omega \dealcoloneq [-1,1]^d\) ，精确的解决方案与步骤7中的解决方案相对应，除了一个缩放比例。我们使用以下源中心 \(x_i\) 作为指数 </p><ul>
<li>
1D： \(\{x_i\}^1 = \{ -\frac{1}{3}, 0, \frac{1}{3} \}\) , </li>
<li>
2D： \(\{\mathbf{x}_i\}^2 = \{ (-\frac{1}{2},\frac{1}{2}), (-\frac{1}{2},-\frac{1}{2}), (\frac{1}{2},-\frac{1}{2}) \}\) , </li>
<li>
3D： \(\{\mathbf{x}_i\}^3 = \{ (-\frac{1}{2},\frac{1}{2}, \frac{1}{4}), (-\frac{3}{5},-\frac{1}{2}, -\frac{1}{8}), (\frac{1}{2},-\frac{1}{2}, \frac{1}{2}) \}\) 。 </li>
</ul>
<p>有了精确的解决方案，我们就可以选择右手边的强制力和诺伊曼边界条件，从而得到这个解决方案（制造的解决方案技术）。在这个例子中，我们选择扩散等于1，对流为</p>
<p class="formulaDsp">
\[ \mathbf{c} = \begin{cases} 1, &amp; \textrm{dim}=1 \\ (y, -x), &amp; \textrm{dim}=2 \\ (y, -x, 1), &amp; \textrm{dim}=3 \end{cases} \]
</p>
<p> 注意，对流是无发散的， \(\nabla \cdot c = 0\) 。</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation </h3>
<p>除了实现上述方程，下面的实现还提供了以下功能。 </p><ul>
<li>
WorkStream来并行化本地求解器。在步骤9中已经详细介绍了Workstream。 </li>
<li>
从跟踪中重构本地DG解。 </li>
<li>
对解进行后处理以实现超融合。 </li>
<li>
用于直接输出全局骨架解的DataOutFaces。 </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of the deal.II include files have already been covered in previous examples and are not commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2exceptions_8h.html">deal.II/base/exceptions.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div></div><!-- fragment --><p>However, we do have a few new includes for the example. The first one defines finite element spaces on the faces of the triangulation, which we refer to as the 'skeleton'. These finite elements do not have any support on the element interior, and they represent polynomials that have a single value on each codimension-1 surface, but admit discontinuities on codimension-2 surfaces.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div></div><!-- fragment --><p>The second new file we include defines a new type of sparse matrix. The regular <code><a class="el" href="classSparseMatrix.html">SparseMatrix</a></code> type stores indices to all non-zero entries. The <code><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a></code> takes advantage of the coupled nature of DG solutions. It stores an index to a matrix sub-block of a specified size. In the HDG context, this sub-block-size is actually the number of degrees of freedom per face defined by the skeleton solution field. This reduces the memory consumption of the matrix by up to one third and results in similar speedups when using the matrix in solvers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chunk__sparse__matrix_8h.html">deal.II/lac/chunk_sparse_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>The final new include for this example deals with data output. Since we have a finite element field defined on the skeleton of the mesh, we would like to visualize what that solution actually is. <a class="el" href="classDataOutFaces.html">DataOutFaces</a> does exactly this; the interface is the almost the same as the familiar <a class="el" href="classDataOut.html">DataOut</a>, but the output only has codimension-1 data for the simulation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>We start by putting all of our classes into their own namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>The structure of the analytic solution is the same as in <a class="el" href="step_7.html">step-7</a>. There are two exceptions. Firstly, we also create a solution for the 3d case, and secondly, we scale the solution so its norm is of order unity for all values of the solution width.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionBase</div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">  SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers] =</div><div class="line">    {<a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">  SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers] =</div><div class="line">    {<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers] = {</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6, -0.5, -0.125),</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5, -0.5, 0.5)};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1. / 5.;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">        sum +=</div><div class="line">          <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sum /</div><div class="line">           <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        sum +=</div><div class="line">          (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">           std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) *</div><div class="line">           x_minus_xi);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sum /</div><div class="line">           <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>This class implements a function where the scalar solution and its negative gradient are collected together. This function is used when computing the error of the HDG approximation and its implementation is to simply call value and gradient function of the Solution class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SolutionAndGradient()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  v)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), dim + 1);</div><div class="line">    Solution&lt;dim&gt;  solution;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad = solution.gradient(p);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      v[d] = -grad[d];</div><div class="line">    v[dim] = solution.value(p);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Next comes the implementation of the convection velocity. As described in the introduction, we choose a velocity field that is \((y, -x)\) in 2D and \((y, -x, 1)\) in 3D. This gives a divergence-free velocity field.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConvectionVelocity()</div><div class="line">    : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="classTensorFunction.html#a60e07c97b7b3b30c612644f9ca42d477">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 1:</div><div class="line">          convection[0] = 1;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          convection[0] = p[1];</div><div class="line">          convection[1] = -p[0];</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          convection[0] = p[1];</div><div class="line">          convection[1] = -p[0];</div><div class="line">          convection[2] = 1;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> convection;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>The last function we implement is the right hand side for the manufactured solution. It is very similar to <a class="el" href="step_7.html">step-7</a>, with the exception that we now have a convection term instead of the reaction term. Since the velocity field is incompressible, i.e., \(\nabla \cdot \mathbf{c} = 0\), the advection term simply reads \(\mathbf{c} \nabla u\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          convection = convection_velocity.value(p);</div><div class="line">    <span class="keywordtype">double</span>                  sum        = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        sum +=</div><div class="line">          ((2 * dim - 2 * convection * x_minus_xi -</div><div class="line">            4 * x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) /</div><div class="line">           (this-&gt;width * this-&gt;width) *</div><div class="line">           std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sum /</div><div class="line">           <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheHDGsolverclass"></a> </p><h3>The HDG solver class</h3>
<p>The HDG solution procedure follows closely that of <a class="el" href="step_7.html">step-7</a>. The major difference is the use of three different sets of <a class="el" href="classDoFHandler.html">DoFHandler</a> and FE objects, along with the <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> and the corresponding solutions vectors. We also use <a class="el" href="namespaceWorkStream.html">WorkStream</a> to enable a multithreaded local solution process which exploits the embarrassingly parallel nature of the local solver. For <a class="el" href="namespaceWorkStream.html">WorkStream</a>, we define the local operations on a cell and a copy function into the global matrix and vector. We do this both for the assembly (which is run twice, once when we generate the system matrix and once when we compute the element-interior solutions from the skeleton values) and for the postprocessing where we extract a solution that converges at higher order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>HDG</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> RefinementMode</div><div class="line">  {</div><div class="line">    global_refinement,</div><div class="line">    adaptive_refinement</div><div class="line">  };</div><div class="line"></div><div class="line">  HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> postprocess();</div><div class="line">  <span class="keywordtype">void</span> refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div></div><!-- fragment --><p>Data for the assembly and solution of the primal variables.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PerTaskData;</div><div class="line"><span class="keyword">struct </span>ScratchData;</div></div><!-- fragment --><p>Post-processing the solution to obtain \(u^*\) is an element-by-element procedure; as such, we do not need to assemble any global data and do not declare any 'task data' for <a class="el" href="namespaceWorkStream.html">WorkStream</a> to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PostProcessScratchData;</div></div><!-- fragment --><p>The following three functions are used by <a class="el" href="namespaceWorkStream.html">WorkStream</a> to do the actual work of the program.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_system_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  ScratchData &amp;                                         scratch,</div><div class="line">  PerTaskData &amp;                                         task_data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> postprocess_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  PostProcessScratchData &amp;                              scratch,</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        empty_data);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>The 'local' solutions are interior to each element. These represent the primal solution field \(u\) as well as the auxiliary field \(\mathbf{q}\).</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe_local;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_local;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution_local;</div></div><!-- fragment --><p>The new finite element type and corresponding <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> are used for the global skeleton solution that couples the element-level local solutions.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>   fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  system_rhs;</div></div><!-- fragment --><p>As stated in the introduction, HDG solutions can be post-processed to attain superconvergence rates of \(\mathcal{O}(h^{p+2})\). The post-processed solution is a discontinuous finite element solution representing the primal variable on the interior of each cell. We define a FE type of degree \(p+1\) to represent this post-processed solution, which we only use for output after constructing it.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>     fe_u_post;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_u_post;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  solution_u_post;</div></div><!-- fragment --><p>The degrees of freedom corresponding to the skeleton strongly enforce Dirichlet boundary conditions, just as in a continuous Galerkin finite element method. We can enforce the boundary conditions in an analogous manner via an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object. In addition, hanging nodes are handled in the same way as for continuous finite elements: For the face elements which only define degrees of freedom on the face, this process sets the solution on the refined side to coincide with the representation on the coarse side.</p>
<p>Note that for HDG, the elimination of hanging nodes is not the only possibility &mdash; in terms of the HDG theory, one could also use the unknowns from the refined side and express the local solution on the coarse side through the trace values on the refined side. However, such a setup is not as easily implemented in terms of deal.II loops and not further analyzed.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div></div><!-- fragment --><p>The usage of the <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> class is similar to the usual sparse matrices: You need a sparsity pattern of type <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> and the actual matrix object. When creating the sparsity pattern, we just have to additionally pass the size of local blocks.</p>
<div class="fragment"><div class="line"><a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>Same as <a class="el" href="step_7.html">step-7</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">  <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheHDGclassimplementation"></a> </p><h3>The HDG class implementation</h3>
<p><a class="anchor" id="Constructor"></a> </p><h4>Constructor</h4>
<p>The constructor is similar to those in other examples, with the exception of handling multiple <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> objects. Note that we create a system of finite elements for the local DG part, including the gradient/flux part and the scalar part.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">HDG&lt;dim&gt;::HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode)</div><div class="line">  : fe_local(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim, <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler_local(triangulation)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe_u_post(degree + 1)</div><div class="line">  , dof_handler_u_post(triangulation)</div><div class="line">  , refinement_mode(refinement_mode)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="HDGsetup_system"></a> </p><h4>HDG::setup_system</h4>
<p>The system for an HDG solution is setup in an analogous manner to most of the other tutorial programs. We are careful to distribute dofs with all of our <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The <code>solution</code> and <code>system_matrix</code> objects go with the global skeleton solution.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler_local.distribute_dofs(fe_local);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  solution_local.reinit(dof_handler_local.n_dofs());</div><div class="line">  solution_u_post.reinit(dof_handler_u_post.n_dofs());</div><div class="line"></div><div class="line">  constraints.clear();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt; boundary_functions;</div><div class="line">  Solution&lt;dim&gt;                                       solution_function;</div><div class="line">  boundary_functions[0] = &amp;solution_function;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>(dof_handler,</div><div class="line">                                       boundary_functions,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                       constraints);</div><div class="line">  constraints.close();</div></div><!-- fragment --><p>When creating the chunk sparsity pattern, we first create the usual dynamic sparsity pattern and then set the chunk size, which is equal to the number of dofs on a face, when copying this into the final sparsity pattern.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a>());</div><div class="line">  }</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGPerTaskData"></a> </p><h4>HDG::PerTaskData</h4>
<p>Next comes the definition of the local data structures for the parallel assembly. The first structure <code>PerTaskData</code> contains the local vector and matrix that are written into the global matrix, whereas the ScratchData contains all data that we need for the local assembly. There is one variable worth noting here, namely the boolean variable <code>trace_reconstruct</code>. As mentioned in the introduction, we solve the HDG system in two steps. First, we create a linear system for the skeleton system where we condense the local part into it via the Schur complement \(D-CA^{-1}B\). Then, we solve for the local part using the skeleton solution. For these two steps, we need the same matrices on the elements twice, which we want to compute by two assembly steps. Since most of the code is similar, we do this with the same function but only switch between the two based on a flag that we set when starting the assembly. Since we need to pass this information on to the local worker routines, we store it once in the task data.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_vector;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">  PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">    : cell_matrix(n_dofs, n_dofs)</div><div class="line">    , cell_vector(n_dofs)</div><div class="line">    , dof_indices(n_dofs)</div><div class="line">    , trace_reconstruct(trace_reconstruct)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGScratchData"></a> </p><h4>HDG::ScratchData</h4>
<p><code>ScratchData</code> contains persistent data for each thread within <a class="el" href="namespaceWorkStream.html">WorkStream</a>. The <a class="el" href="classFEValues.html">FEValues</a>, matrix, and vector objects should be familiar by now. There are two objects that need to be discussed: <code>std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_local_support_on_face</code> and <code>std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_support_on_face</code>. These are used to indicate whether or not the finite elements chosen have support (non-zero values) on a given face of the reference cell for the local part associated to <code>fe_local</code> and the skeleton part <code>fe</code>. We extract this information in the constructor and store it once for all cells that we work on. Had we not stored this information, we would be forced to assemble a large number of zero terms on each cell, which would significantly slow the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     l_rhs;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     tmp_rhs;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; q_phi;</div><div class="line">  std::vector&lt;double&gt;         q_phi_div;</div><div class="line">  std::vector&lt;double&gt;         u_phi;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_phi_grad;</div><div class="line">  std::vector&lt;double&gt;         tr_phi;</div><div class="line">  std::vector&lt;double&gt;         trace_values;</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_local_support_on_face;</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_support_on_face;</div><div class="line"></div><div class="line">  ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">  RightHandSide&lt;dim&gt;      right_hand_side;</div><div class="line">  <span class="keyword">const</span> Solution&lt;dim&gt;     exact_solution;</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp;   face_quadrature_formula,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_face_flags,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">    : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">    , fe_face_values_local(fe_local,</div><div class="line">                           face_quadrature_formula,</div><div class="line">                           local_face_flags)</div><div class="line">    , fe_face_values(fe, face_quadrature_formula, flags)</div><div class="line">    , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">    , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">    , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">    , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">    , l_rhs(fe_local.n_dofs_per_cell())</div><div class="line">    , tmp_rhs(fe_local.n_dofs_per_cell())</div><div class="line">    , q_phi(fe_local.n_dofs_per_cell())</div><div class="line">    , q_phi_div(fe_local.n_dofs_per_cell())</div><div class="line">    , u_phi(fe_local.n_dofs_per_cell())</div><div class="line">    , u_phi_grad(fe_local.n_dofs_per_cell())</div><div class="line">    , tr_phi(fe.n_dofs_per_cell())</div><div class="line">    , trace_values(face_quadrature_formula.size())</div><div class="line">    , fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">    , fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">    , exact_solution()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_local.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">            fe_local_support_on_face[face_no].push_back(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">            fe_support_on_face[face_no].push_back(i);</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">    : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                      sd.fe_values_local.get_quadrature(),</div><div class="line">                      sd.fe_values_local.get_update_flags())</div><div class="line">    , fe_face_values_local(sd.fe_face_values_local.get_fe(),</div><div class="line">                           sd.fe_face_values_local.get_quadrature(),</div><div class="line">                           sd.fe_face_values_local.get_update_flags())</div><div class="line">    , fe_face_values(sd.fe_face_values.get_fe(),</div><div class="line">                     sd.fe_face_values.get_quadrature(),</div><div class="line">                     sd.fe_face_values.get_update_flags())</div><div class="line">    , ll_matrix(sd.ll_matrix)</div><div class="line">    , lf_matrix(sd.lf_matrix)</div><div class="line">    , fl_matrix(sd.fl_matrix)</div><div class="line">    , tmp_matrix(sd.tmp_matrix)</div><div class="line">    , l_rhs(sd.l_rhs)</div><div class="line">    , tmp_rhs(sd.tmp_rhs)</div><div class="line">    , q_phi(sd.q_phi)</div><div class="line">    , q_phi_div(sd.q_phi_div)</div><div class="line">    , u_phi(sd.u_phi)</div><div class="line">    , u_phi_grad(sd.u_phi_grad)</div><div class="line">    , tr_phi(sd.tr_phi)</div><div class="line">    , trace_values(sd.trace_values)</div><div class="line">    , fe_local_support_on_face(sd.fe_local_support_on_face)</div><div class="line">    , fe_support_on_face(sd.fe_support_on_face)</div><div class="line">    , exact_solution()</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGPostProcessScratchData"></a> </p><h4>HDG::PostProcessScratchData</h4>
<p><code>PostProcessScratchData</code> contains the data used by <a class="el" href="namespaceWorkStream.html">WorkStream</a> when post-processing the local solution \(u^*\). It is similar, but much simpler, than <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         u_values;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_gradients;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_sol;</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">    : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">    , fe_values(fe, quadrature_formula, flags)</div><div class="line">    , u_values(quadrature_formula.size())</div><div class="line">    , u_gradients(quadrature_formula.size())</div><div class="line">    , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">    , cell_rhs(fe.n_dofs_per_cell())</div><div class="line">    , cell_sol(fe.n_dofs_per_cell())</div><div class="line">  {}</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">    : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                      sd.fe_values_local.get_quadrature(),</div><div class="line">                      sd.fe_values_local.get_update_flags())</div><div class="line">    , fe_values(sd.fe_values.get_fe(),</div><div class="line">                sd.fe_values.get_quadrature(),</div><div class="line">                sd.fe_values.get_update_flags())</div><div class="line">    , u_values(sd.u_values)</div><div class="line">    , u_gradients(sd.u_gradients)</div><div class="line">    , cell_matrix(sd.cell_matrix)</div><div class="line">    , cell_rhs(sd.cell_rhs)</div><div class="line">    , cell_sol(sd.cell_sol)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system"></a> </p><h4>HDG::assemble_system</h4>
<p>The <code>assemble_system</code> function is similar to the one on <a class="el" href="step_32.html">step-32</a>, where the quadrature formula and the update flags are set up, and then <code><a class="el" href="namespaceWorkStream.html">WorkStream</a></code> is used to do the work in a multi-threaded manner. The <code>trace_reconstruct</code> input parameter is used to decide whether we are solving for the global skeleton solution (false) or the local solution (true).</p>
<p>One thing worth noting for the multi-threaded execution of assembly is the fact that the local computations in <code>assemble_system_one_cell()</code> call into BLAS and LAPACK functions if those are available in deal.II. Thus, the underlying BLAS/LAPACK library must support calls from multiple threads at the same time. Most implementations do support this, but some libraries need to be built in a specific way to avoid problems. For example, OpenBLAS compiled without multithreading inside the BLAS/LAPACK calls needs to built with a flag called <code>USE_LOCKING</code> set to true.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  PerTaskData task_data(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(), trace_reconstruct);</div><div class="line">  ScratchData scratch(fe,</div><div class="line">                      fe_local,</div><div class="line">                      quadrature_formula,</div><div class="line">                      face_quadrature_formula,</div><div class="line">                      local_flags,</div><div class="line">                      local_face_flags,</div><div class="line">                      flags);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                  &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                  scratch,</div><div class="line">                  task_data);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system_one_cell"></a> </p><h4>HDG::assemble_system_one_cell</h4>
<p>The real work of the HDG program is done by <code>assemble_system_one_cell</code>. Assembling the local matrices \(A, B, C\) is done here, along with the local contributions of the global matrix \(D\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  ScratchData &amp;                                         scratch,</div><div class="line">  PerTaskData &amp;                                         task_data)</div><div class="line">{</div></div><!-- fragment --><p>Construct iterator for dof_handler_local for <a class="el" href="classFEValues.html">FEValues</a> reinit function.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                        cell-&gt;level(),</div><div class="line">                                                        cell-&gt;index(),</div><div class="line">                                                        &amp;dof_handler_local);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">  scratch.fe_values_local.get_quadrature().size();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">  scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell =</div><div class="line">  scratch.fe_values_local.get_fe().n_dofs_per_cell();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">scratch.ll_matrix = 0;</div><div class="line">scratch.l_rhs     = 0;</div><div class="line"><span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">  {</div><div class="line">    scratch.lf_matrix     = 0;</div><div class="line">    scratch.fl_matrix     = 0;</div><div class="line">    task_data.cell_matrix = 0;</div><div class="line">    task_data.cell_vector = 0;</div><div class="line">  }</div><div class="line">scratch.fe_values_local.reinit(loc_cell);</div></div><!-- fragment --><p>We first compute the cell-interior contribution to <code>ll_matrix</code> matrix (referred to as matrix \(A\) in the introduction) corresponding to local-local coupling, as well as the local right-hand-side vector. We store the values at each quadrature point for the basis functions, the right-hand-side value, and the convection velocity, in order to have quick access to these fields.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value = scratch.right_hand_side.value(</div><div class="line">      scratch.fe_values_local.quadrature_point(q));</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection = scratch.convection_velocity.value(</div><div class="line">      scratch.fe_values_local.quadrature_point(q));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; loc_dofs_per_cell; ++k)</div><div class="line">      {</div><div class="line">        scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);</div><div class="line">        scratch.q_phi_div[k] =</div><div class="line">          scratch.fe_values_local[fluxes].divergence(k, q);</div><div class="line">        scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);</div><div class="line">        scratch.u_phi_grad[k] =</div><div class="line">          scratch.fe_values_local[scalar].gradient(k, q);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; loc_dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; loc_dofs_per_cell; ++j)</div><div class="line">          scratch.ll_matrix(i, j) +=</div><div class="line">            (scratch.q_phi[i] * scratch.q_phi[j] -</div><div class="line">             scratch.q_phi_div[i] * scratch.u_phi[j] +</div><div class="line">             scratch.u_phi[i] * scratch.q_phi_div[j] -</div><div class="line">             (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]) *</div><div class="line">            JxW;</div><div class="line">        scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Face terms are assembled on all faces of all elements. This is in contrast to more traditional DG methods, where each face is only visited once in the assembly procedure.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">  {</div><div class="line">    scratch.fe_face_values_local.reinit(loc_cell, face_no);</div><div class="line">    scratch.fe_face_values.reinit(cell, face_no);</div></div><!-- fragment --><p>The already obtained \(\hat{u}\) values are needed when solving for the local variables.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">  scratch.fe_face_values.get_function_values(solution,</div><div class="line">                                             scratch.trace_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     JxW = scratch.fe_face_values.JxW(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">      scratch.fe_face_values.quadrature_point(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal =</div><div class="line">      scratch.fe_face_values.normal_vector(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection =</div><div class="line">      scratch.convection_velocity.value(quadrature_point);</div></div><!-- fragment --><p>Here we compute the stabilization parameter discussed in the introduction: since the diffusion is one and the diffusion length scale is set to 1/5, it simply results in a contribution of 5 for the diffusion part and the magnitude of convection through the element boundary in a centered scheme for the convection part.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. + <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(convection * normal));</div></div><!-- fragment --><p>We store the non-zero flux and scalar values, making use of the support_on_face information we created in <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">     k &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">     ++k)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk =</div><div class="line">      scratch.fe_local_support_on_face[face_no][k];</div><div class="line">    scratch.q_phi[k] =</div><div class="line">      scratch.fe_face_values_local[fluxes].value(kk, q);</div><div class="line">    scratch.u_phi[k] =</div><div class="line">      scratch.fe_face_values_local[scalar].value(kk, q);</div><div class="line">  }</div></div><!-- fragment --><p>When <code>trace_reconstruct=false</code>, we are preparing to assemble the system for the skeleton variable \(\hat{u}\). If this is the case, we must assemble all local matrices associated with the problem: local-local, local-face, face-local, and face-face. The face-face matrix is stored as <code>TaskData::cell_matrix</code>, so that it can be assembled into the global system by <code>copy_local_to_global</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">         k &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">         ++k)</div><div class="line">      scratch.tr_phi[k] = scratch.fe_face_values.shape_value(</div><div class="line">        scratch.fe_support_on_face[face_no][k], q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">         i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">         ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">           j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">           ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">            scratch.fe_local_support_on_face[face_no][i];</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">            scratch.fe_support_on_face[face_no][j];</div><div class="line">          scratch.lf_matrix(ii, jj) +=</div><div class="line">            ((scratch.q_phi[i] * normal +</div><div class="line">              (convection * normal - tau_stab) * scratch.u_phi[i]) *</div><div class="line">             scratch.tr_phi[j]) *</div><div class="line">            JxW;</div></div><!-- fragment --><p>Note the sign of the face_no-local matrix. We negate the sign during assembly here so that we can use the <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a> with addition when computing the Schur complement.</p>
<div class="fragment"><div class="line">        scratch.fl_matrix(jj, ii) -=</div><div class="line">          ((scratch.q_phi[i] * normal +</div><div class="line">            tau_stab * scratch.u_phi[i]) *</div><div class="line">           scratch.tr_phi[j]) *</div><div class="line">          JxW;</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">       i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">       ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">         j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">         ++j)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">          scratch.fe_support_on_face[face_no][i];</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">          scratch.fe_support_on_face[face_no][j];</div><div class="line">        task_data.cell_matrix(ii, jj) +=</div><div class="line">          ((convection * normal - tau_stab) * scratch.tr_phi[i] *</div><div class="line">           scratch.tr_phi[j]) *</div><div class="line">          JxW;</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">      (cell-&gt;face(face_no)-&gt;boundary_id() == 1))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">        -scratch.exact_solution.gradient(quadrature_point) *</div><div class="line">          normal +</div><div class="line">        convection * normal *</div><div class="line">          scratch.exact_solution.value(quadrature_point);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">           i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">           ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">            scratch.fe_support_on_face[face_no][i];</div><div class="line">          task_data.cell_vector(ii) +=</div><div class="line">            scratch.tr_phi[i] * neumann_value * JxW;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This last term adds the contribution of the term \(\left&lt;w,\tau u_h\right&gt;_{\partial \mathcal T}\) to the local matrix. As opposed to the face matrices above, we need it in both assembly stages.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">     i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">     ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">       j &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">       ++j)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">        scratch.fe_local_support_on_face[face_no][i];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">        scratch.fe_local_support_on_face[face_no][j];</div><div class="line">      scratch.ll_matrix(ii, jj) +=</div><div class="line">        tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;</div><div class="line">    }</div></div><!-- fragment --><p>When <code>trace_reconstruct=true</code>, we are solving for the local solutions on an element by element basis. The local right-hand-side is calculated by replacing the basis functions <code>tr_phi</code> in the <code>lf_matrix</code> computation by the computed values <code>trace_values</code>. Of course, the sign of the matrix is now minus since we have moved everything to the other side of the equation.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">             i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">             ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">              scratch.fe_local_support_on_face[face_no][i];</div><div class="line">            scratch.l_rhs(ii) -=</div><div class="line">              (scratch.q_phi[i] * normal +</div><div class="line">               scratch.u_phi[i] * (convection * normal - tau_stab)) *</div><div class="line">              scratch.trace_values[q] * JxW;</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Once assembly of all of the local contributions is complete, we must either: (1) assemble the global system, or (2) compute the local solution values and save them. In either case, the first step is to invert the local-local matrix.</p>
<div class="fragment"><div class="line">scratch.ll_matrix.gauss_jordan();</div></div><!-- fragment --><p>For (1), we compute the Schur complement and add it to the <code>cell_matrix</code>, matrix \(D\) in the introduction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">    scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">    scratch.tmp_matrix.mmult(task_data.cell_matrix,</div><div class="line">                             scratch.lf_matrix,</div><div class="line">                             <span class="keyword">true</span>);</div><div class="line">    cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">  }</div></div><!-- fragment --><p>For (2), we are simply solving (ll_matrix).(solution_local) = (l_rhs). Hence, we multiply <code>l_rhs</code> by our already inverted local-local matrix and store the result using the <code>set_dof_values</code> function.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">      loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGcopy_local_to_global"></a> </p><h4>HDG::copy_local_to_global</h4>
<p>If we are in the first step of the solution, i.e. <code>trace_reconstruct=false</code>, then we assemble the local matrices into the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">    constraints.distribute_local_to_global(data.cell_matrix,</div><div class="line">                                           data.cell_vector,</div><div class="line">                                           data.dof_indices,</div><div class="line">                                           system_matrix,</div><div class="line">                                           system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGsolve"></a> </p><h4>HDG::solve</h4>
<p>The skeleton solution is solved for by using a BiCGStab solver with identity preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                  solver_control(system_matrix.m() * 10,</div><div class="line">                               1e-11 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0, 0, 0, 1);</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div></div><!-- fragment --><p>Once we have solved for the skeleton solution, we can solve for the local solutions in an element-by-element fashion. We do this by re-using the same <code>assemble_system</code> function but switching <code>trace_reconstruct</code> to true.</p>
<div class="fragment"><div class="line">  assemble_system(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess"></a> </p><h4>HDG::postprocess</h4>
<p>The postprocess method serves two purposes. First, we want to construct a post-processed scalar variables in the element space of degree \(p+1\) that we hope will converge at order \(p+2\). This is again an element-by-element process and only involves the scalar solution as well as the gradient on the local cell. To do this, we introduce the already defined scratch data together with some update flags and run the work stream to do this in parallel.</p>
<p>Secondly, we want to compute discretization errors just as we did in <a class="el" href="step_7.html">step-7</a>. The overall procedure is similar with calls to <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>. The difference is in how we compute the errors for the scalar variable and the gradient variable. In <a class="el" href="step_7.html">step-7</a>, we did this by computing <code>L2_norm</code> or <code>H1_seminorm</code> contributions. Here, we have a <a class="el" href="classDoFHandler.html">DoFHandler</a> with these two contributions computed and sorted by their vector component, <code>[0, dim)</code> for the gradient and <code>dim</code> for the scalar. To compute their value, we hence use a <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> with either of them, together with the <code>SolutionAndGradient</code> class introduced above that contains the analytic parts of either of them. Eventually, we also compute the L2-error of the post-processed solution and add the results into the convergence table.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_u_post.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PostProcessScratchData scratch(</div><div class="line">      fe_u_post, fe_local, quadrature_formula, local_flags, flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">      dof_handler_u_post.begin_active(),</div><div class="line">      dof_handler_u_post.end(),</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">             PostProcessScratchData &amp;                              scratch,</div><div class="line">             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        data) {</div><div class="line">        this-&gt;postprocess_one_cell(cell, scratch, data);</div><div class="line">      },</div><div class="line">      std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">      scratch,</div><div class="line">      0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select(dim, dim + 1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                    solution_local,</div><div class="line">                                    SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;value_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select(</div><div class="line">    std::pair&lt;unsigned int, unsigned int&gt;(0, dim), dim + 1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                    solution_local,</div><div class="line">                                    SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;gradient_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_u_post,</div><div class="line">                                    solution_u_post,</div><div class="line">                                    Solution&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 3),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> post_error =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>, L2_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>, grad_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess_one_cell"></a> </p><h4>HDG::postprocess_one_cell</h4>
<p>This is the actual work done for the postprocessing. According to the discussion in the introduction, we need to set up a system that projects the gradient part of the DG solution onto the gradient of the post-processed variable. Moreover, we need to set the average of the new post-processed variable to equal the average of the scalar DG solution on the cell.</p>
<p>More technically speaking, the projection of the gradient is a system that would potentially fills our <code>dofs_per_cell</code> times <code>dofs_per_cell</code> matrix but is singular (the sum of all rows would be zero because the constant function has zero gradient). Therefore, we take one row away and use it for imposing the average of the scalar value. We pick the first row for the scalar part, even though we could pick any row for \(\mathcal Q_{-p}\) elements. However, had we used <a class="el" href="classFE__DGP.html">FE_DGP</a> elements instead, the first row would correspond to the constant part already and deleting e.g. the last row would give us a singular system. This way, our program can also be used for those elements.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess_one_cell(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  PostProcessScratchData &amp;                              scratch,</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                          cell-&gt;level(),</div><div class="line">                                                          cell-&gt;index(),</div><div class="line">                                                          &amp;dof_handler_local);</div><div class="line"></div><div class="line">  scratch.fe_values_local.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(loc_cell);</div><div class="line">  scratch.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line"></div><div class="line">  scratch.fe_values_local[scalar].get_function_values(solution_local,</div><div class="line">                                                      scratch.u_values);</div><div class="line">  scratch.fe_values_local[fluxes].get_function_values(solution_local,</div><div class="line">                                                      scratch.u_gradients);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> sum = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          sum = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            sum += (scratch.fe_values.shape_grad(i, q) *</div><div class="line">                    scratch.fe_values.shape_grad(j, q)) *</div><div class="line">                   scratch.fe_values.JxW(q);</div><div class="line">          scratch.cell_matrix(i, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) *</div><div class="line">               scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_rhs(i) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">    {</div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_matrix(0, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    }</div><div class="line">  {</div><div class="line">    sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      sum += scratch.u_values[q] * scratch.fe_values.JxW(q);</div><div class="line">    scratch.cell_rhs(0) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">  }</div></div><!-- fragment --><p>Having assembled all terms, we can again go on and solve the linear system. We invert the matrix and then multiply the inverse by the right hand side. An alternative (and more numerically stable) method would have been to only factorize the matrix and apply the factorization.</p>
<div class="fragment"><div class="line">  scratch.cell_matrix.gauss_jordan();</div><div class="line">  scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">  cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGoutput_results"></a> </p><h4>HDG::output_results</h4>
<p>We have 3 sets of results that we would like to output: the local solution, the post-processed local solution, and the skeleton solution. The former 2 both 'live' on element volumes, whereas the latter lives on codimension-1 surfaces of the triangulation. Our <code>output_results</code> function writes all local solutions to the same vtk file, even though they correspond to different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The graphical output for the skeleton variable is done through use of the <a class="el" href="classDataOutFaces.html">DataOutFaces</a> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  std::string filename;</div><div class="line">  <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  std::string face_out(filename);</div><div class="line">  face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">  filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">  filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">  filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div></div><!-- fragment --><p>We first define the names and types of the local solution, and add the data to <code>data_out</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; names(dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">names.emplace_back(<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  component_interpretation(</div><div class="line">    dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">component_interpretation[dim] =</div><div class="line">  <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_local,</div><div class="line">                         solution_local,</div><div class="line">                         names,</div><div class="line">                         component_interpretation);</div></div><!-- fragment --><p>The second data item we add is the post-processed solution. In this case, it is a single scalar variable belonging to a different <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; post_name(1, <span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_u_post,</div><div class="line">                         solution_u_post,</div><div class="line">                         post_name,</div><div class="line">                         post_comp_type);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">std::ofstream face_output(face_out);</div></div><!-- fragment --><p>The <code><a class="el" href="classDataOutFaces.html">DataOutFaces</a></code> class works analogously to the <code><a class="el" href="classDataOut.html">DataOut</a></code> class when we have a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> that defines the solution on the skeleton of the triangulation. We treat it as such here, and the code is similar to that above.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a>        data_out_face(<span class="keyword">false</span>);</div><div class="line">  std::vector&lt;std::string&gt; face_name(1, <span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  data_out_face.add_data_vector(dof_handler,</div><div class="line">                                solution,</div><div class="line">                                face_name,</div><div class="line">                                face_component_type);</div><div class="line"></div><div class="line">  data_out_face.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">  data_out_face.write_vtk(face_output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGrefine_grid"></a> </p><h4>HDG::refine_grid</h4>
<p>We implement two different refinement cases for HDG, just as in <code><a class="el" href="step_7.html">step-7</a></code>: adaptive_refinement and global_refinement. The global_refinement option recreates the entire triangulation every time. This is because we want to use a finer sequence of meshes than what we would get with one refinement step, namely 2, 3, 4, 6, 8, 12, 16, ... elements per direction.</p>
<p>The adaptive_refinement mode uses the <code><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a></code> to give a decent indication of the non-regular regions in the scalar local solutions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 2, -1, 1);</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> global_refinement:</div><div class="line">          {</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation,</div><div class="line">                                                 2 + (cycle % 2),</div><div class="line">                                                 -1,</div><div class="line">                                                 1);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim + cycle / 2);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">          {</div><div class="line">            <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">            <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">            std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">              neumann_boundary;</div><div class="line">            <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler_local,</div><div class="line">                                               <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                               neumann_boundary,</div><div class="line">                                               solution_local,</div><div class="line">                                               estimated_error_per_cell,</div><div class="line">                                               fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(</div><div class="line">                                                 scalar));</div><div class="line"></div><div class="line">            <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">              triangulation, estimated_error_per_cell, 0.3, 0.);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>Just as in <a class="el" href="step_7.html">step-7</a>, we set the boundary indicator of two of the faces to 1 where we want to specify Neumann boundary conditions instead of Dirichlet conditions. Since we re-create the triangulation every time for global refinement, the flags are set in every refinement step, not just at the beginning.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">        <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(0) - (-1)) &lt; 1e-12) ||</div><div class="line">            (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">          face-&gt;set_boundary_id(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGrun"></a> </p><h4>HDG::run</h4>
<p>The functionality here is basically the same as <code><a class="el" href="step_7.html">step-7</a></code>. We loop over 10 cycles, refining the grid on each one. At the end, convergence tables are created.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HDG&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 10; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      refine_grid(cycle);</div><div class="line">      setup_system();</div><div class="line">      assemble_system(<span class="keyword">false</span>);</div><div class="line">      solve();</div><div class="line">      postprocess();</div><div class="line">      output_results(cycle);</div><div class="line">    }</div></div><!-- fragment --><p>There is one minor change for the convergence table compared to <a class="el" href="step_7.html">step-7</a>: Since we did not refine our mesh by a factor two in each cycle (but rather used the sequence 2, 3, 4, 6, 8, 12, ...), we need to tell the convergence rate evaluation about this. We do this by setting the number of cells as a reference column and additionally specifying the dimension of the problem, which gives the necessary information for the relation between number of cells and mesh size.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div></div><!-- fragment --><p>Now for the three calls to the main class in complete analogy to <a class="el" href="step_7.html">step-7</a>.</p>
<div class="fragment"><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-51/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>我们首先看一下程序在二维运行时产生的输出。在下面的四张图片中，我们展示了多项式度数 \(p=1\) 和程序的周期2、3、4和8的解决方案。在图中，我们将从内部数据（DG部分）产生的数据与骨架部分（ \(\hat{u}\) ）叠加到同一图中。我们不得不生成两个不同的数据集，因为单元格和面孔代表不同的几何实体，它们的组合（在同一个文件中）在VTK输出的deal.II中不被支持。</p>
<p>这些图像显示了HDG的明显特征：细胞的解决方案（彩色的表面）在细胞之间是不连续的。骨架变量上的解位于面的位置，并将局部部分联系起来。骨架解决方案在面与面之间的顶点上是不连续的，尽管它的值沿着同一坐标方向的线相当接近。骨架解可以被解释为两边之间的橡胶弹簧，它可以平衡解的跳跃（或者说，通量 \(\kappa \nabla u + \mathbf{c} u\) ）。从左上角的图片可以看出，大体解经常出现过冲和欠冲，而骨架变量确实是对精确解更好的近似；这解释了为什么我们可以通过后处理步骤得到更好的解。</p>
<p>随着网格的细化，单元之间的跳跃变得很小（我们代表一个平滑的解决方案），骨架解决方案接近内部部分。对于第8周期，两个变量没有明显的区别。我们还看到边界条件是如何弱化实施的，内部变量并不完全满足边界条件。在下部和左侧边界，我们设置了诺伊曼边界条件，而在右侧和顶部边界，我们设置了迪里希特条件。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_8.png"/>
</div>
  </td></tr>
</table>
<p>接下来，我们看一下后处理的解决方案，还是在周期2、3、4和8。这是一个不连续的解决方案，局部由二阶多项式描述。虽然在第二周期的网格上，解决方案看起来不是很好，但在第三和第四周期，它看起来好得多。正如下面的收敛表所示，我们发现它也更快地收敛到了分析解。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_8.png"/>
</div>
  </td></tr>
</table>
<p>最后，我们看一下 \(p=3\) 在第二周期的解。尽管网格较粗，只有64个单元，但经过后处理的解在质量上与第8周期4,096个单元的线性解（未经过后处理）相似。这清楚地表明了高阶方法对于平滑解的优越性。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_q3_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_q3_2.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="Convergencetables"></a></p><h4>Convergence tables</h4>
<p>当程序运行时，它还会输出各自的步骤和收敛表的信息，并在最后输出各部分的误差。在2D中，收敛表看起来如下。</p>
<div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells dofs   val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01 2.207e+01   1.798e+01</div><div class="line">   31   170 9.874e+00 1.322e+01   9.798e+00</div><div class="line">   61   314 7.452e-01 3.793e+00   4.891e-01</div><div class="line">  121   634 3.240e-01 1.511e+00   2.616e-01</div><div class="line">  238  1198 8.585e-02 8.212e-01   1.808e-02</div><div class="line">  454  2290 4.802e-02 5.178e-01   2.195e-02</div><div class="line">  898  4378 2.561e-02 2.947e-01   4.318e-03</div><div class="line"> 1720  7864 1.306e-02 1.664e-01   2.978e-03</div><div class="line"> 3271 14638 7.025e-03 9.815e-02   1.075e-03</div><div class="line"> 6217 27214 4.119e-03 6.407e-02   9.975e-04</div><div class="line"></div><div class="line"></div><div class="line">Q1 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01    - 2.207e+01    - 1.798e+01    -</div><div class="line">   36   168 6.125e+00 2.66 9.472e+00 2.09 6.084e+00 2.67</div><div class="line">   64   288 9.785e-01 6.38 4.260e+00 2.78 7.102e-01 7.47</div><div class="line">  144   624 2.730e-01 3.15 1.866e+00 2.04 6.115e-02 6.05</div><div class="line">  256  1088 1.493e-01 2.10 1.046e+00 2.01 2.880e-02 2.62</div><div class="line">  576  2400 6.965e-02 1.88 4.846e-01 1.90 9.204e-03 2.81</div><div class="line"> 1024  4224 4.018e-02 1.91 2.784e-01 1.93 4.027e-03 2.87</div><div class="line"> 2304  9408 1.831e-02 1.94 1.264e-01 1.95 1.236e-03 2.91</div><div class="line"> 4096 16640 1.043e-02 1.96 7.185e-02 1.96 5.306e-04 2.94</div><div class="line"> 9216 37248 4.690e-03 1.97 3.228e-02 1.97 1.599e-04 2.96</div><div class="line"></div><div class="line"></div><div class="line">Q3 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16   160 3.613e-01    - 1.891e+00    - 3.020e-01    -</div><div class="line">   36   336 6.411e-02 4.26 5.081e-01 3.24 3.238e-02 5.51</div><div class="line">   64   576 3.480e-02 2.12 2.533e-01 2.42 5.277e-03 6.31</div><div class="line">  144  1248 8.297e-03 3.54 5.924e-02 3.58 6.330e-04 5.23</div><div class="line">  256  2176 2.254e-03 4.53 1.636e-02 4.47 1.403e-04 5.24</div><div class="line">  576  4800 4.558e-04 3.94 3.277e-03 3.96 1.844e-05 5.01</div><div class="line"> 1024  8448 1.471e-04 3.93 1.052e-03 3.95 4.378e-06 5.00</div><div class="line"> 2304 18816 2.956e-05 3.96 2.104e-04 3.97 5.750e-07 5.01</div><div class="line"> 4096 33280 9.428e-06 3.97 6.697e-05 3.98 1.362e-07 5.01</div><div class="line"> 9216 74496 1.876e-06 3.98 1.330e-05 3.99 1.788e-08 5.01</div></div><!-- fragment --><p>我们可以看到网格细化后的误差减少，对于进行全局细化的情况，也可以看到收敛率。在 \(L_2\) 准则下，标量变量和梯度变量的Q1元素的二次收敛率很明显，在 \(L_2\) 准则下，后处理的标量变量的三次收敛率也是如此。注意HDG解决方案的这一明显特征。在典型的连续有限元中，阶 \(p\) 的解的梯度收敛率只有 \(p\) ，与实际解的 \(p+1\) 相反。即使有限元的超收敛结果也是可用的（例如Zienkiewicz和Zhu首次提出的超收敛补丁恢复），但这些通常只限于结构化网格和其他特殊情况。对于Q3 HDG变量，标量变量和梯度在四阶收敛，后处理的标量变量在五阶收敛。</p>
<p>在3D中观察到相同的收敛率。</p>
<div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells   dofs    val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00 1.941e+01   6.102e+00</div><div class="line">    29     500 3.309e+00 1.023e+01   2.145e+00</div><div class="line">   113    1792 2.204e+00 1.023e+01   1.912e+00</div><div class="line">   379    5732 6.085e-01 5.008e+00   2.233e-01</div><div class="line">  1317   19412 1.543e-01 1.464e+00   4.196e-02</div><div class="line">  4579   64768 5.058e-02 5.611e-01   9.521e-03</div><div class="line"> 14596  199552 2.129e-02 3.122e-01   4.569e-03</div><div class="line"> 46180  611400 1.033e-02 1.622e-01   1.684e-03</div><div class="line">144859 1864212 5.007e-03 8.371e-02   7.364e-04</div><div class="line">451060 5684508 2.518e-03 4.562e-02   3.070e-04</div><div class="line"></div><div class="line"></div><div class="line">Q1 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>          grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00    - 1.941e+01     - 6.102e+00    -</div><div class="line">    27     432 5.491e+00 0.64 2.184e+01 -0.29 4.448e+00 0.78</div><div class="line">    64     960 3.646e+00 1.42 1.299e+01  1.81 3.306e+00 1.03</div><div class="line">   216    3024 1.595e+00 2.04 8.550e+00  1.03 1.441e+00 2.05</div><div class="line">   512    6912 6.922e-01 2.90 5.306e+00  1.66 2.511e-01 6.07</div><div class="line">  1728   22464 2.915e-01 2.13 2.490e+00  1.87 8.588e-02 2.65</div><div class="line">  4096   52224 1.684e-01 1.91 1.453e+00  1.87 4.055e-02 2.61</div><div class="line"> 13824  172800 7.972e-02 1.84 6.861e-01  1.85 1.335e-02 2.74</div><div class="line"> 32768  405504 4.637e-02 1.88 3.984e-01  1.89 5.932e-03 2.82</div><div class="line">110592 1354752 2.133e-02 1.92 1.830e-01  1.92 1.851e-03 2.87</div><div class="line"></div><div class="line"></div><div class="line">Q3 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     576 5.670e+00    - 1.868e+01    - 5.462e+00    -</div><div class="line">    27    1728 1.048e+00 4.16 6.988e+00 2.42 8.011e-01 4.73</div><div class="line">    64    3840 2.831e-01 4.55 2.710e+00 3.29 1.363e-01 6.16</div><div class="line">   216   12096 7.883e-02 3.15 7.721e-01 3.10 2.158e-02 4.55</div><div class="line">   512   27648 3.642e-02 2.68 3.305e-01 2.95 5.231e-03 4.93</div><div class="line">  1728   89856 8.546e-03 3.58 7.581e-02 3.63 7.640e-04 4.74</div><div class="line">  4096  208896 2.598e-03 4.14 2.313e-02 4.13 1.783e-04 5.06</div><div class="line"> 13824  691200 5.314e-04 3.91 4.697e-03 3.93 2.355e-05 4.99</div><div class="line"> 32768 1622016 1.723e-04 3.91 1.517e-03 3.93 5.602e-06 4.99</div><div class="line">110592 5419008 3.482e-05 3.94 3.055e-04 3.95 7.374e-07 5.00</div></div><!-- fragment --><p><a class="anchor" id="Comparisonwithcontinuousfiniteelements"></a></p><h3>Comparison with continuous finite elements</h3>
<p><a class="anchor" id="Resultsfor2D"></a></p><h4>Results for 2D</h4>
<p>收敛表验证了介绍中所述的预期收敛率。现在，我们想在本教程的问题上展示一下HDG方法与普通有限元（连续Galkerin）方法相比的计算效率的快速比较。当然，与连续有限元相比，HDG方法对于传输为主的问题的稳定性方面在实践中也很重要，这是在平滑分析解的问题上看不到的方面。在下面的图片中，我们比较了 \(L_2\) 误差作为自由度数的函数（左）和线性求解器中花费的计算时间（右），连续有限元（CG）和本教程中介绍的混合非连续Galerkin方法的两个空间维度。相对于教程中我们只使用无条件的BiCGStab，下面的数字中显示的时间使用了 <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. 中的Trilinos代数多网格预处理器 对于HDG部分，为了利用最细级别的矩阵中的块结构，我们使用了ChunkSparseMatrix周围的跟踪变量的包装器。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_plain.png" width="400"/>
</div>
  </td></tr>
</table>
<p>图中的结果显示，HDG方法在 \(p=1\) 时比连续有限元慢，对立方体元素的速度差不多，对六阶元素的速度更快。然而，我们在上面已经看到，HDG方法实际上产生的解比原始变量所表示的更准确。因此，在下面两幅图中，我们转而显示HDG的后处理解的误差（例如用 \(p=1^*\) 表示）。现在我们看到，对于 \(p=3\) 和 \(p=6\) ，在相同的工作量下，HDG有明显的优势，而对于 \(p=1\) ，质量也差不多。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_post.png" width="400"/>
</div>
  </td></tr>
</table>
<p>由于HDG方法实际产生的结果收敛为 \(h^{p+2}\) ，我们应该将其与具有相同渐进收敛行为的连续Galerkin解决方案进行比较，即程度为 \(p+1\) 的FE_Q。如果我们这样做，我们会得到下面的收敛曲线。我们看到，用二阶多项式的CG又明显优于用线型的HDG。然而，HDG对高阶的优势依然存在。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>这些结果与一般的DG方法的特性是一致的。最佳性能通常不是在线性元素上实现的，而是在更高的阶数上，通常在 \(p=3\) 左右。这是因为不连续解的体积-表面效应，有太多的解存在于表面，因此当元素为线性时，会出现重复工作。换句话说，尽管DG方法专注于不连续（因此看起来精度不高）的解的表示，但在相对高的阶数上使用时往往是最有效的。</p>
<p><a class="anchor" id="Resultsfor3D"></a></p><h4>Results for 3D</h4>
<p>我们现在展示了同样的三维数字：第一行显示了自由度数和计算时间与标量变量 \(L_2\) 中的 \(u\) 误差的关系，在 \(p\) 阶的CG和HDG，第二行显示了后处理的HDG方案，而不是原始方案，第三行比较了后处理的HDG方案与阶 \(p+1\) 的CG。在三维中，体积-表面效应使得HDG的成本更高，对于线型来说，CG的解决方案显然比HDG更好。对于立方体，HDG和CG的质量相似，而HDG对于六阶多项式又更有效率。我们也可以使用FE_DGP和FE_FaceP的组合来代替（FE_DGQ, FE_FaceQ），它们不使用 \(p\) 度的张量积多项式，而是<em>complete</em>度的Legendre多项式。在给定的网格尺寸下，FE_FaceP的骨架变量的自由度较少，但求解质量（误差与自由度数量的关系）与FE_FaceQ的结果非常相似。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_plain.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_post.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>关于效率比较的最后一点说明。我们试图使用通用的稀疏矩阵结构和类似的求解器（两者的最佳AMG预处理器，没有对任何一个AMG参数进行特别的调整），在一个玩具的例子上，对两种方法的成本与精度进行公平的描述。然而，应该注意的是，连续有限元的几何多网格（GMG）对于 \(p=3\) 和 \(p=6\) 来说，大约快了四到五个系数。截至2019年，HDG的最优复杂度迭代求解器仍在研究界开发中。另外，还有其他方面的CG的实现，如步骤37所示的快速无矩阵方法，使高阶连续元素更具竞争力。同样，本教程的作者也不清楚是否可以对HDG做出类似的改进。我们参考<a href="https://dx.doi.org/10.1137/16M110455X">Kronbichler and Wall (2018)</a>，了解最近的效率评估。</p>
<p><a class="anchor" id="Possibilitiesforimprovements"></a></p><h3>Possibilities for improvements</h3>
<p>正如在介绍中已经提到的，一种可能性是实施文献中讨论的另一种后处理技术。</p>
<p>第二项没有做得很好的是与这个程序的性能有关，这当然是实际应用中的一个问题（也要权衡(H)DG方法对传输为主的问题有更好的解决质量）。让我们来看看这个教程程序的计算时间和各个部分的份额。</p>
<table align="center" class="doxtable">
<tr>
<th>&#160; </th><th>&#160; </th><th>Setup </th><th>Assemble </th><th>Solve </th><th>Trace reconstruct </th><th>Post-processing </th><th>Output  </th></tr>
<tr>
<th>&#160; </th><th>Total time </th><th colspan="6">Relative share  </th></tr>
<tr>
<td align="left">2D, Q1, cycle 9, 37,248 dofs </td><td align="center">5.34s </td><td align="center">0.7% </td><td align="center">1.2% </td><td align="center">89.5% </td><td align="center">0.9% </td><td align="center">2.3% </td><td align="center">5.4%  </td></tr>
<tr>
<td align="left">2D, Q3, cycle 9, 74,496 dofs </td><td align="center">22.2s </td><td align="center">0.4% </td><td align="center">4.3% </td><td align="center">84.1% </td><td align="center">4.1% </td><td align="center">3.5% </td><td align="center">3.6%  </td></tr>
<tr>
<td align="left">3D, Q1, cycle 7, 172,800 dofs </td><td align="center">9.06s </td><td align="center">3.1% </td><td align="center">8.9% </td><td align="center">42.7% </td><td align="center">7.0% </td><td align="center">20.6% </td><td align="center">17.7%  </td></tr>
<tr>
<td align="left">3D, Q3, cycle 7, 691,200 dofs </td><td align="center">516s </td><td align="center">0.6% </td><td align="center">34.5% </td><td align="center">13.4% </td><td align="center">32.8% </td><td align="center">17.1% </td><td align="center">1.5%  </td></tr>
</table>
<p>从表中可以看出，解算器和汇编调用在程序的运行时间中占主导地位。这也清楚地表明，在哪些方面的改进是最有意义的。</p>
<ol>
<li>
<p class="startli">更好的线性求解器。我们使用的是BiCGStab迭代求解器，没有预处理程序，迭代次数随着问题大小的增加而增加（Q1元素和全局细化的迭代次数在小尺寸时从35次开始，但在最大尺寸时增加到701次）。为了做得更好，例如可以使用Trilinos的代数多网格预处理程序，或者像<a href="https://dx.doi.org/10.1137/16M110455X">Kronbichler and Wall (2018)</a>中讨论的一些更高级的变体。对于以扩散为主的问题，比如目前的问题，只要我们不与MPI并行工作，就可以设计这样一个求解器，在最细的层次上使用更高效的ChunkSparseMatrix的矩阵-向量积。对于MPI并行化的计算，可以使用一个标准 <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> 。</p>
<p class="endli"></p>
</li>
<li>
通过预先组装那些不从一个单元改变到另一个单元的部件（那些既不包含可变系数也不包含依赖映射的项）来加快组装速度。 </li>
</ol>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2013 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Martin Kronbichler, Technische Universität München,</span></div><div class="line"><span class="comment"> *         Scott T. Miller, The Pennsylvania State University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2exceptions_8h.html">deal.II/base/exceptions.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chunk__sparse__matrix_8h.html">deal.II/lac/chunk_sparse_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionBase</div><div class="line">  {</div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">    SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers] =</div><div class="line">      {<a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0), <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)};</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">    SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers] =</div><div class="line">      {<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">    SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers] = {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6, -0.5, -0.125),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5, -0.5, 0.5)};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1. / 5.;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordtype">double</span> sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">          sum +=</div><div class="line">            <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">          sum +=</div><div class="line">            (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">             std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) *</div><div class="line">             x_minus_xi);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SolutionAndGradient()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  v)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.size(), dim + 1);</div><div class="line">      Solution&lt;dim&gt;  solution;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad = solution.gradient(p);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        v[d] = -grad[d];</div><div class="line">      v[dim] = solution.value(p);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ConvectionVelocity()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection;</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> 1:</div><div class="line">            convection[0] = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 2:</div><div class="line">            convection[0] = p[1];</div><div class="line">            convection[1] = -p[0];</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 3:</div><div class="line">            convection[0] = p[1];</div><div class="line">            convection[1] = -p[0];</div><div class="line">            convection[2] = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line">      <span class="keywordflow">return</span> convection;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;, <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          convection = convection_velocity.value(p);</div><div class="line">      <span class="keywordtype">double</span>                  sum        = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; this-&gt;n_source_centers; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">          sum +=</div><div class="line">            ((2 * dim - 2 * convection * x_minus_xi -</div><div class="line">              4 * x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)) /</div><div class="line">             (this-&gt;width * this-&gt;width) *</div><div class="line">             std::exp(-x_minus_xi.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() / (this-&gt;width * this-&gt;width)));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> sum /</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * this-&gt;width * this-&gt;width, dim / 2.);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>HDG</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> RefinementMode</div><div class="line">    {</div><div class="line">      global_refinement,</div><div class="line">      adaptive_refinement</div><div class="line">    };</div><div class="line"></div><div class="line">    HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> postprocess();</div><div class="line">    <span class="keywordtype">void</span> refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData;</div><div class="line">    <span class="keyword">struct </span>ScratchData;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PostProcessScratchData;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system_one_cell(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      ScratchData &amp;                                         scratch,</div><div class="line">      PerTaskData &amp;                                         task_data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> postprocess_one_cell(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      PostProcessScratchData &amp;                              scratch,</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        empty_data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe_local;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_local;</div><div class="line">    Vector&lt;double&gt;  solution_local;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>   fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    Vector&lt;double&gt;  solution;</div><div class="line">    Vector&lt;double&gt;  system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>     fe_u_post;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_u_post;</div><div class="line">    Vector&lt;double&gt;  solution_u_post;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">    <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  HDG&lt;dim&gt;::HDG(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree, <span class="keyword">const</span> RefinementMode refinement_mode)</div><div class="line">    : fe_local(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim, <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler_local(triangulation)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe_u_post(degree + 1)</div><div class="line">    , dof_handler_u_post(triangulation)</div><div class="line">    , refinement_mode(refinement_mode)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler_local.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_local);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    solution_local.reinit(dof_handler_local.n_dofs());</div><div class="line">    solution_u_post.reinit(dof_handler_u_post.n_dofs());</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt; boundary_functions;</div><div class="line">    Solution&lt;dim&gt;                                       solution_function;</div><div class="line">    boundary_functions[0] = &amp;solution_function;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values</a>(dof_handler,</div><div class="line">                                         boundary_functions,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a>());</div><div class="line">    }</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_vector;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">    PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">      : cell_matrix(n_dofs, n_dofs)</div><div class="line">      , cell_vector(n_dofs)</div><div class="line">      , dof_indices(n_dofs)</div><div class="line">      , trace_reconstruct(trace_reconstruct)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">    Vector&lt;double&gt;     l_rhs;</div><div class="line">    Vector&lt;double&gt;     tmp_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; q_phi;</div><div class="line">    std::vector&lt;double&gt;         q_phi_div;</div><div class="line">    std::vector&lt;double&gt;         u_phi;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_phi_grad;</div><div class="line">    std::vector&lt;double&gt;         tr_phi;</div><div class="line">    std::vector&lt;double&gt;         trace_values;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_local_support_on_face;</div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; fe_support_on_face;</div><div class="line"></div><div class="line">    ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">    RightHandSide&lt;dim&gt;      right_hand_side;</div><div class="line">    <span class="keyword">const</span> Solution&lt;dim&gt;     exact_solution;</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp;   face_quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_face_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">      : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">      , fe_face_values_local(fe_local,</div><div class="line">                             face_quadrature_formula,</div><div class="line">                             local_face_flags)</div><div class="line">      , fe_face_values(fe, face_quadrature_formula, flags)</div><div class="line">      , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">      , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())</div><div class="line">      , l_rhs(fe_local.n_dofs_per_cell())</div><div class="line">      , tmp_rhs(fe_local.n_dofs_per_cell())</div><div class="line">      , q_phi(fe_local.n_dofs_per_cell())</div><div class="line">      , q_phi_div(fe_local.n_dofs_per_cell())</div><div class="line">      , u_phi(fe_local.n_dofs_per_cell())</div><div class="line">      , u_phi_grad(fe_local.n_dofs_per_cell())</div><div class="line">      , tr_phi(fe.n_dofs_per_cell())</div><div class="line">      , trace_values(face_quadrature_formula.size())</div><div class="line">      , fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">      , fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">      , exact_solution()</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_local.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">              fe_local_support_on_face[face_no].push_back(i);</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no))</div><div class="line">              fe_support_on_face[face_no].push_back(i);</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">      : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                        sd.fe_values_local.get_quadrature(),</div><div class="line">                        sd.fe_values_local.get_update_flags())</div><div class="line">      , fe_face_values_local(sd.fe_face_values_local.get_fe(),</div><div class="line">                             sd.fe_face_values_local.get_quadrature(),</div><div class="line">                             sd.fe_face_values_local.get_update_flags())</div><div class="line">      , fe_face_values(sd.fe_face_values.get_fe(),</div><div class="line">                       sd.fe_face_values.get_quadrature(),</div><div class="line">                       sd.fe_face_values.get_update_flags())</div><div class="line">      , ll_matrix(sd.ll_matrix)</div><div class="line">      , lf_matrix(sd.lf_matrix)</div><div class="line">      , fl_matrix(sd.fl_matrix)</div><div class="line">      , tmp_matrix(sd.tmp_matrix)</div><div class="line">      , l_rhs(sd.l_rhs)</div><div class="line">      , tmp_rhs(sd.tmp_rhs)</div><div class="line">      , q_phi(sd.q_phi)</div><div class="line">      , q_phi_div(sd.q_phi_div)</div><div class="line">      , u_phi(sd.u_phi)</div><div class="line">      , u_phi_grad(sd.u_phi_grad)</div><div class="line">      , tr_phi(sd.tr_phi)</div><div class="line">      , trace_values(sd.trace_values)</div><div class="line">      , fe_local_support_on_face(sd.fe_local_support_on_face)</div><div class="line">      , fe_support_on_face(sd.fe_support_on_face)</div><div class="line">      , exact_solution()</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         u_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; u_gradients;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs;</div><div class="line">    Vector&lt;double&gt; cell_sol;</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;       quadrature_formula,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         local_flags,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         flags)</div><div class="line">      : fe_values_local(fe_local, quadrature_formula, local_flags)</div><div class="line">      , fe_values(fe, quadrature_formula, flags)</div><div class="line">      , u_values(quadrature_formula.size())</div><div class="line">      , u_gradients(quadrature_formula.size())</div><div class="line">      , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())</div><div class="line">      , cell_rhs(fe.n_dofs_per_cell())</div><div class="line">      , cell_sol(fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">      : fe_values_local(sd.fe_values_local.get_fe(),</div><div class="line">                        sd.fe_values_local.get_quadrature(),</div><div class="line">                        sd.fe_values_local.get_update_flags())</div><div class="line">      , fe_values(sd.fe_values.get_fe(),</div><div class="line">                  sd.fe_values.get_quadrature(),</div><div class="line">                  sd.fe_values.get_update_flags())</div><div class="line">      , u_values(sd.u_values)</div><div class="line">      , u_gradients(sd.u_gradients)</div><div class="line">      , cell_matrix(sd.cell_matrix)</div><div class="line">      , cell_rhs(sd.cell_rhs)</div><div class="line">      , cell_sol(sd.cell_sol)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PerTaskData task_data(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(), trace_reconstruct);</div><div class="line">    ScratchData scratch(fe,</div><div class="line">                        fe_local,</div><div class="line">                        quadrature_formula,</div><div class="line">                        face_quadrature_formula,</div><div class="line">                        local_flags,</div><div class="line">                        local_face_flags,</div><div class="line">                        flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    *<span class="keyword">this</span>,</div><div class="line">                    &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                    &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                    scratch,</div><div class="line">                    task_data);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::assemble_system_one_cell(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    ScratchData &amp;                                         scratch,</div><div class="line">    PerTaskData &amp;                                         task_data)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                            cell-&gt;level(),</div><div class="line">                                                            cell-&gt;index(),</div><div class="line">                                                            &amp;dof_handler_local);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch.fe_values_local.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">      scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell =</div><div class="line">      scratch.fe_values_local.get_fe().n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">    scratch.ll_matrix = 0;</div><div class="line">    scratch.l_rhs     = 0;</div><div class="line">    <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">      {</div><div class="line">        scratch.lf_matrix     = 0;</div><div class="line">        scratch.fl_matrix     = 0;</div><div class="line">        task_data.cell_matrix = 0;</div><div class="line">        task_data.cell_vector = 0;</div><div class="line">      }</div><div class="line">    scratch.fe_values_local.reinit(loc_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value = scratch.right_hand_side.value(</div><div class="line">          scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection = scratch.convection_velocity.value(</div><div class="line">          scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; loc_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);</div><div class="line">            scratch.q_phi_div[k] =</div><div class="line">              scratch.fe_values_local[fluxes].divergence(k, q);</div><div class="line">            scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);</div><div class="line">            scratch.u_phi_grad[k] =</div><div class="line">              scratch.fe_values_local[scalar].gradient(k, q);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; loc_dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; loc_dofs_per_cell; ++j)</div><div class="line">              scratch.ll_matrix(i, j) +=</div><div class="line">                (scratch.q_phi[i] * scratch.q_phi[j] -</div><div class="line">                 scratch.q_phi_div[i] * scratch.u_phi[j] +</div><div class="line">                 scratch.u_phi[i] * scratch.q_phi_div[j] -</div><div class="line">                 (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]) *</div><div class="line">                JxW;</div><div class="line">            scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">      {</div><div class="line">        scratch.fe_face_values_local.reinit(loc_cell, face_no);</div><div class="line">        scratch.fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">          scratch.fe_face_values.get_function_values(solution,</div><div class="line">                                                     scratch.trace_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>     JxW = scratch.fe_face_values.JxW(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">              scratch.fe_face_values.quadrature_point(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal =</div><div class="line">              scratch.fe_face_values.normal_vector(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> convection =</div><div class="line">              scratch.convection_velocity.value(quadrature_point);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. + <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(convection * normal));</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">                 k &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                 ++k)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk =</div><div class="line">                  scratch.fe_local_support_on_face[face_no][k];</div><div class="line">                scratch.q_phi[k] =</div><div class="line">                  scratch.fe_face_values_local[fluxes].value(kk, q);</div><div class="line">                scratch.u_phi[k] =</div><div class="line">                  scratch.fe_face_values_local[scalar].value(kk, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line">                     k &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                     ++k)</div><div class="line">                  scratch.tr_phi[k] = scratch.fe_face_values.shape_value(</div><div class="line">                    scratch.fe_support_on_face[face_no][k], q);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                     i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                       j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                        scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                        scratch.fe_support_on_face[face_no][j];</div><div class="line">                      scratch.lf_matrix(ii, jj) +=</div><div class="line">                        ((scratch.q_phi[i] * normal +</div><div class="line">                          (convection * normal - tau_stab) * scratch.u_phi[i]) *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line"></div><div class="line">                      scratch.fl_matrix(jj, ii) -=</div><div class="line">                        ((scratch.q_phi[i] * normal +</div><div class="line">                          tau_stab * scratch.u_phi[i]) *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                     i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                       j &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                        scratch.fe_support_on_face[face_no][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                        scratch.fe_support_on_face[face_no][j];</div><div class="line">                      task_data.cell_matrix(ii, jj) +=</div><div class="line">                        ((convection * normal - tau_stab) * scratch.tr_phi[i] *</div><div class="line">                         scratch.tr_phi[j]) *</div><div class="line">                        JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">                    (cell-&gt;face(face_no)-&gt;boundary_id() == 1))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">                      -scratch.exact_solution.gradient(quadrature_point) *</div><div class="line">                        normal +</div><div class="line">                      convection * normal *</div><div class="line">                        scratch.exact_solution.value(quadrature_point);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                         i &lt; scratch.fe_support_on_face[face_no].size();</div><div class="line">                         ++i)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                          scratch.fe_support_on_face[face_no][i];</div><div class="line">                        task_data.cell_vector(ii) +=</div><div class="line">                          scratch.tr_phi[i] * neumann_value * JxW;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                 i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                 ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">                   j &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                   ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][j];</div><div class="line">                  scratch.ll_matrix(ii, jj) +=</div><div class="line">                    tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;</div><div class="line">                }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div><div class="line">                   i &lt; scratch.fe_local_support_on_face[face_no].size();</div><div class="line">                   ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii =</div><div class="line">                    scratch.fe_local_support_on_face[face_no][i];</div><div class="line">                  scratch.l_rhs(ii) -=</div><div class="line">                    (scratch.q_phi[i] * normal +</div><div class="line">                     scratch.u_phi[i] * (convection * normal - tau_stab)) *</div><div class="line">                    scratch.trace_values[q] * JxW;</div><div class="line">                }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    scratch.ll_matrix.gauss_jordan();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">        scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">        scratch.tmp_matrix.mmult(task_data.cell_matrix,</div><div class="line">                                 scratch.lf_matrix,</div><div class="line">                                 <span class="keyword">true</span>);</div><div class="line">        cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">        loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      constraints.distribute_local_to_global(data.cell_matrix,</div><div class="line">                                             data.cell_vector,</div><div class="line">                                             data.dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                  solver_control(system_matrix.m() * 10,</div><div class="line">                                 1e-11 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span></div><div class="line">              &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0, 0, 0, 1);</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    assemble_system(<span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_u_post.degree + 1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      PostProcessScratchData scratch(</div><div class="line">        fe_u_post, fe_local, quadrature_formula, local_flags, flags);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">        dof_handler_u_post.begin_active(),</div><div class="line">        dof_handler_u_post.end(),</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">               PostProcessScratchData &amp;                              scratch,</div><div class="line">               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                                        data) {</div><div class="line">          this-&gt;postprocess_one_cell(cell, scratch, data);</div><div class="line">        },</div><div class="line">        std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">        scratch,</div><div class="line">        0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select(dim, dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                      solution_local,</div><div class="line">                                      SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;value_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select(</div><div class="line">      std::pair&lt;unsigned int, unsigned int&gt;(0, dim), dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_local,</div><div class="line">                                      solution_local,</div><div class="line">                                      SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;gradient_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler_u_post,</div><div class="line">                                      solution_u_post,</div><div class="line">                                      Solution&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 3),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> post_error =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>, L2_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>, grad_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::postprocess_one_cell(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    PostProcessScratchData &amp;                              scratch,</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> loc_cell(&amp;triangulation,</div><div class="line">                                                            cell-&gt;level(),</div><div class="line">                                                            cell-&gt;index(),</div><div class="line">                                                            &amp;dof_handler_local);</div><div class="line"></div><div class="line">    scratch.fe_values_local.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(loc_cell);</div><div class="line">    scratch.fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line"></div><div class="line">    scratch.fe_values_local[scalar].get_function_values(solution_local,</div><div class="line">                                                        scratch.u_values);</div><div class="line">    scratch.fe_values_local[fluxes].get_function_values(solution_local,</div><div class="line">                                                        scratch.u_gradients);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            sum = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              sum += (scratch.fe_values.shape_grad(i, q) *</div><div class="line">                      scratch.fe_values.shape_grad(j, q)) *</div><div class="line">                     scratch.fe_values.JxW(q);</div><div class="line">            scratch.cell_matrix(i, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">          }</div><div class="line"></div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) *</div><div class="line">                 scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_rhs(i) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_matrix(0, j) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">      }</div><div class="line">    {</div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        sum += scratch.u_values[q] * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_rhs(0) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    scratch.cell_matrix.gauss_jordan();</div><div class="line">    scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">    cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    std::string filename;</div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> global_refinement:</div><div class="line">          filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">          filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    std::string face_out(filename);</div><div class="line">    face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">    filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">    filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">    filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; names(dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">    names.emplace_back(<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      component_interpretation(</div><div class="line">        dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    component_interpretation[dim] =</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_local,</div><div class="line">                             solution_local,</div><div class="line">                             names,</div><div class="line">                             component_interpretation);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; post_name(1, <span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_u_post,</div><div class="line">                             solution_u_post,</div><div class="line">                             post_name,</div><div class="line">                             post_comp_type);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">    face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, 1);</div><div class="line">    face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2);</div><div class="line">    face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream face_output(face_out);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a>        data_out_face(<span class="keyword">false</span>);</div><div class="line">    std::vector&lt;std::string&gt; face_name(1, <span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    data_out_face.add_data_vector(dof_handler,</div><div class="line">                                  solution,</div><div class="line">                                  face_name,</div><div class="line">                                  face_component_type);</div><div class="line"></div><div class="line">    data_out_face.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out_face.write_vtk(face_output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 2, -1, 1);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> global_refinement:</div><div class="line">            {</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">              <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation,</div><div class="line">                                                   2 + (cycle % 2),</div><div class="line">                                                   -1,</div><div class="line">                                                   1);</div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim + cycle / 2);</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">            {</div><div class="line">              Vector&lt;float&gt; estimated_error_per_cell(</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">              <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">              std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">                neumann_boundary;</div><div class="line">              <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler_local,</div><div class="line">                                                 <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                                 neumann_boundary,</div><div class="line">                                                 solution_local,</div><div class="line">                                                 estimated_error_per_cell,</div><div class="line">                                                 fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(</div><div class="line">                                                   scalar));</div><div class="line"></div><div class="line">              <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">                triangulation, estimated_error_per_cell, 0.3, 0.);</div><div class="line"></div><div class="line">              triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          <span class="keywordflow">if</span> ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(0) - (-1)) &lt; 1e-12) ||</div><div class="line">              (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HDG&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 10; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        refine_grid(cycle);</div><div class="line">        setup_system();</div><div class="line">        assemble_system(<span class="keyword">false</span>);</div><div class="line">        solve();</div><div class="line">        postprocess();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem(3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
