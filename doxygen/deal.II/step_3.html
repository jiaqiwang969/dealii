<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_3.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-3 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-3 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_2.html">step-2</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thebasicsetupoffiniteelementmethods">The basic set up of finite element methods</a>
        <li><a href="#Shouldwemultiplybyatestfunctionfromtheleftorfromtheright"> Should we multiply by a test function from the left or from the right? </a>
        <li><a href="#Computingthematrixandrighthandsidevector"> Computing the matrix and right hand side vector </a>
        <li><a href="#Abouttheimplementation">About the implementation</a>
        <li><a href="#Anoteontypes"> A note on types </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Manynewincludefiles">Many new include files</a>
        <li><a href="#ThecodeStep3codeclass">The <code>Step3</code> class</a>
      <ul>
        <li><a href="#Step3Step3">Step3::Step3</a>
        <li><a href="#Step3make_grid">Step3::make_grid</a>
        <li><a href="#Step3setup_system">Step3::setup_system</a>
        <li><a href="#Step3assemble_system">Step3::assemble_system</a>
        <li><a href="#Step3solve">Step3::solve</a>
        <li><a href="#Step3output_results">Step3::output_results</a>
        <li><a href="#Step3run">Step3::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
        <li><a href="#UsingHDF5tooutputthesolutionandadditionaldata">Using HDF5 to output the solution and additional data</a>
      <ul>
        <li><a href="#Changingtheoutputtoh5"> Changing the output to .h5</a>
        <li><a href="#Addingthepointvalueandthemeanseeextensionaboveintotheh5file"> Adding the point value and the mean (see extension above) into the .h5 file</a>
      </ul>
        <li><a href="#UsingRandggplot2togenerateplots"> Using R and ggplot2 to generate plots</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.10.html">video lecture 10</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p><a class="anchor" id="Thebasicsetupoffiniteelementmethods"></a></p><h3>The basic set up of finite element methods</h3>
<p>This is the first example where we actually use finite elements to compute something. We will solve a simple version of Poisson's equation with zero boundary values, but a nonzero right hand side: </p><p class="formulaDsp">
\begin{align*} -\Delta u &amp;= f \qquad\qquad &amp; \text{in}\ \Omega, \\ u &amp;= 0 \qquad\qquad &amp; \text{on}\ \partial\Omega. \end{align*}
</p>
<p> We will solve this equation on the square, \(\Omega=[-1,1]^2\), for which you've already learned how to generate a mesh in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a>. In this program, we will also only consider the particular case \(f(\mathbf x)=1\) and come back to how to implement the more general case in the next tutorial program, <a class="el" href="step_4.html">step-4</a>.</p>
<p>If you've learned about the basics of the finite element method, you will remember the steps we need to take to approximate the solution \(u\) by a finite dimensional approximation. Specifically, we first need to derive the weak form of the equation above, which we obtain by multiplying the equation by a test function \(\varphi\) <em>from the left</em> (we will come back to the reason for multiplying from the left and not from the right below) and integrating over the domain \(\Omega\): </p><p class="formulaDsp">
\begin{align*} -\int_\Omega \varphi \Delta u = \int_\Omega \varphi f. \end{align*}
</p>
<p> This can be integrated by parts: </p><p class="formulaDsp">
\begin{align*} \int_\Omega \nabla\varphi \cdot \nabla u - \int_{\partial\Omega} \varphi \mathbf{n}\cdot \nabla u = \int_\Omega \varphi f. \end{align*}
</p>
<p> The test function \(\varphi\) has to satisfy the same kind of boundary conditions (in mathematical terms: it needs to come from the tangent space of the set in which we seek the solution), so on the boundary \(\varphi=0\) and consequently the weak form we are looking for reads </p><p class="formulaDsp">
\begin{align*} (\nabla\varphi, \nabla u) = (\varphi, f), \end{align*}
</p>
<p> where we have used the common notation \((a,b)=\int_\Omega a\; b\). The problem then asks for a function \(u\) for which this statement is true for all test functions \(\varphi\) from the appropriate space (which here is the space \(H^1\)).</p>
<p>Of course we can't find such a function on a computer in the general case, and instead we seek an approximation \(u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\), where the \(U_j\) are unknown expansion coefficients we need to determine (the "degrees of freedom" of this problem), and \(\varphi_i(\mathbf x)\) are the finite element shape functions we will use. To define these shape functions, we need the following:</p>
<ul>
<li>A mesh on which to define shape functions. You have already seen how to generate and manipulate the objects that describe meshes in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a>.</li>
<li>A finite element that describes the shape functions we want to use on the reference cell (which in deal.II is always the unit interval \([0,1]\), the unit square \([0,1]^2\) or the unit cube \([0,1]^3\), depending on which space dimension you work in). In <a class="el" href="step_2.html">step-2</a>, we had already used an object of type FE_Q&lt;2&gt;, which denotes the usual Lagrange elements that define shape functions by interpolation on support points. The simplest one is FE_Q&lt;2&gt;(1), which uses polynomial degree 1. In 2d, these are often referred to as <em>bilinear</em>, since they are linear in each of the two coordinates of the reference cell. (In 1d, they would be <em>linear</em> and in 3d <em>tri-linear</em>; however, in the deal.II documentation, we will frequently not make this distinction and simply always call these functions "linear".)</li>
<li>A <a class="el" href="classDoFHandler.html">DoFHandler</a> object that enumerates all the degrees of freedom on the mesh, taking the reference cell description the finite element object provides as the basis. You've also already seen how to do this in <a class="el" href="step_2.html">step-2</a>.</li>
<li>A mapping that tells how the shape functions on the real cell are obtained from the shape functions defined by the finite element class on the reference cell. By default, unless you explicitly say otherwise, deal.II will use a (bi-, tri-)linear mapping for this, so in most cases you don't have to worry about this step.</li>
</ul>
<p>Through these steps, we now have a set of functions \(\varphi_i\), and we can define the weak form of the discrete problem: Find a function \(u_h\), i.e., find the expansion coefficients \(U_j\) mentioned above, so that </p><p class="formulaDsp">
\begin{align*} (\nabla\varphi_i, \nabla u_h) = (\varphi_i, f), \qquad\qquad i=0\ldots N-1. \end{align*}
</p>
<p> Note that we here follow the convention that everything is counted starting at zero, as common in C and C++. This equation can be rewritten as a linear system if you insert the representation \(u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) and then observe that </p><p class="formulaDsp">
\begin{align*} (\nabla\varphi_i, \nabla u_h) &amp;= \left(\nabla\varphi_i, \nabla \Bigl[\sum_j U_j \varphi_j\Bigr]\right) \\ &amp;= \sum_j \left(\nabla\varphi_i, \nabla \left[U_j \varphi_j\right]\right) \\ &amp;= \sum_j \left(\nabla\varphi_i, \nabla \varphi_j \right) U_j. \end{align*}
</p>
<p> With this, the problem reads: Find a vector \(U\) so that </p><p class="formulaDsp">
\begin{align*} A U = F, \end{align*}
</p>
<p> where the matrix \(A\) and the right hand side \(F\) are defined as </p><p class="formulaDsp">
\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j), \\ F_i &amp;= (\varphi_i, f). \end{align*}
</p>
<p><a class="anchor" id="Shouldwemultiplybyatestfunctionfromtheleftorfromtheright"></a></p><h3>Should we multiply by a test function from the left or from the right? </h3>
<p>Before we move on with describing how these quantities can be computed, note that if we had multiplied the original equation from the <em>right</em> by a test function rather than from the left, then we would have obtained a linear system of the form </p><p class="formulaDsp">
\begin{align*} U^T A = F^T \end{align*}
</p>
<p> with a row vector \(F^T\). By transposing this system, this is of course equivalent to solving </p><p class="formulaDsp">
\begin{align*} A^T U = F \end{align*}
</p>
<p> which here is the same as above since \(A=A^T\). But in general is not, and in order to avoid any sort of confusion, experience has shown that simply getting into the habit of multiplying the equation from the left rather than from the right (as is often done in the mathematical literature) avoids a common class of errors as the matrix is automatically correct and does not need to be transposed when comparing theory and implementation. See <a class="el" href="step_9.html">step-9</a> for the first example in this tutorial where we have a non-symmetric bilinear form for which it makes a difference whether we multiply from the right or from the left.</p>
<p><a class="anchor" id="Computingthematrixandrighthandsidevector"></a></p><h3>Computing the matrix and right hand side vector </h3>
<p>Now we know what we need (namely: objects that hold the matrix and vectors, as well as ways to compute \(A_{ij},F_i\)), and we can look at what it takes to make that happen:</p>
<ul>
<li>The object for \(A\) is of type <a class="el" href="classSparseMatrix.html">SparseMatrix</a> while those for \(U\) and \(F\) are of type <a class="el" href="classVector.html">Vector</a>. We will see in the program below what classes are used to solve linear systems.</li>
<li>We need a way to form the integrals. In the finite element method, this is most commonly done using quadrature, i.e. the integrals are replaced by a weighted sum over a set of points on each cell. That is, we first split the integral over \(\Omega\) into integrals over all cells, <p class="formulaDsp">
\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j) = \sum_{K \in {\mathbb T}} \int_K \nabla\varphi_i \cdot \nabla \varphi_j, \\ F_i &amp;= (\varphi_i, f) = \sum_{K \in {\mathbb T}} \int_K \varphi_i f, \end{align*}
</p>
 and then approximate each cell's contribution by quadrature: <p class="formulaDsp">
\begin{align*} A^K_{ij} &amp;= \int_K \nabla\varphi_i \cdot \nabla \varphi_j \approx \sum_q \nabla\varphi_i(\mathbf x^K_q) \cdot \nabla \varphi_j(\mathbf x^K_q) w_q^K, \\ F^K_i &amp;= \int_K \varphi_i f \approx \sum_q \varphi_i(\mathbf x^K_q) f(\mathbf x^K_q) w^K_q, \end{align*}
</p>
 where \(\mathbf x^K_q\) is the \(q\)th quadrature point on cell \(K\), and \(w^K_q\) the \(q\)th quadrature weight. There are different parts to what is needed in doing this, and we will discuss them in turn next.</li>
<li>First, we need a way to describe the location \(\mathbf x_q^K\) of quadrature points and their weights \(w^K_q\). They are usually mapped from the reference cell in the same way as shape functions, i.e., implicitly using the <a class="el" href="classMappingQ1.html">MappingQ1</a> class or, if you explicitly say so, through one of the other classes derived from <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>. The locations and weights on the reference cell are described by objects derived from the <a class="el" href="classQuadrature.html">Quadrature</a> base class. Typically, one chooses a quadrature formula (i.e. a set of points and weights) so that the quadrature exactly equals the integral in the matrix; this can be achieved because all factors in the integral are polynomial, and is done by Gaussian quadrature formulas, implemented in the <a class="el" href="classQGauss.html">QGauss</a> class.</li>
<li>We then need something that can help us evaluate \(\varphi_i(\mathbf x^K_q)\) on cell \(K\). This is what the <a class="el" href="classFEValues.html">FEValues</a> class does: it takes a finite element objects to describe \(\varphi\) on the reference cell, a quadrature object to describe the quadrature points and weights, and a mapping object (or implicitly takes the <a class="el" href="classMappingQ1.html">MappingQ1</a> class) and provides values and derivatives of the shape functions on the real cell \(K\) as well as all sorts of other information needed for integration, at the quadrature points located on \(K\).</li>
</ul>
<p><a class="el" href="classFEValues.html">FEValues</a> really is the central class in the assembly process. One way you can view it is as follows: The <a class="el" href="classFiniteElement.html">FiniteElement</a> and derived classes describe shape <em>functions</em>, i.e., infinite dimensional objects: functions have values at every point. We need this for theoretical reasons because we want to perform our analysis with integrals over functions. However, for a computer, this is a very difficult concept, since they can in general only deal with a finite amount of information, and so we replace integrals by sums over quadrature points that we obtain by mapping (the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> object) using points defined on a reference cell (the <a class="el" href="classQuadrature.html">Quadrature</a> object) onto points on the real cell. In essence, we reduce the problem to one where we only need a finite amount of information, namely shape function values and derivatives, quadrature weights, normal vectors, etc, exclusively at a finite set of points. The <a class="el" href="classFEValues.html">FEValues</a> class is the one that brings the three components together and provides this finite set of information on a particular cell \(K\). You will see it in action when we assemble the linear system below.</p>
<p>It is noteworthy that all of this could also be achieved if you simply created these three objects yourself in an application program, and juggled the information yourself. However, this would neither be simpler (the <a class="el" href="classFEValues.html">FEValues</a> class provides exactly the kind of information you actually need) nor faster: the <a class="el" href="classFEValues.html">FEValues</a> class is highly optimized to only compute on each cell the particular information you need; if anything can be re-used from the previous cell, then it will do so, and there is a lot of code in that class to make sure things are cached wherever this is advantageous.</p>
<p>The final piece of this introduction is to mention that after a linear system is obtained, it is solved using an iterative solver and then postprocessed: we create an output file using the <a class="el" href="classDataOut.html">DataOut</a> class that can then be visualized using one of the common visualization programs.</p>
<dl class="section note"><dt>Note</dt><dd>The preceding overview of all the important steps of any finite element implementation has its counterpart in deal.II: The library can naturally be grouped into a number of "modules" that cover the basic concepts just outlined. You can access these modules through the tab at the top of this page. An overview of the most fundamental groups of concepts is also available on the <a href="index.html">front page of the deal.II manual</a>.</dd></dl>
<p><a class="anchor" id="Abouttheimplementation"></a></p><h3>About the implementation</h3>
<p>Although this is the simplest possible equation you can solve using the finite element method, this program shows the basic structure of most finite element programs and also serves as the template that almost all of the following programs will essentially follow. Specifically, the main class of this program looks like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Step3 ();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid ();</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>     <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>              fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>        dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>This follows the object oriented programming mantra of <a href="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)">data encapsulation</a>, i.e. we do our best to hide almost all internal details of this class in private members that are not accessible to the outside.</p>
<p>Let's start with the member variables: These follow the building blocks we have outlined above in the bullet points, namely we need a <a class="el" href="classTriangulation.html">Triangulation</a> and a <a class="el" href="classDoFHandler.html">DoFHandler</a> object, and a finite element object that describes the kinds of shape functions we want to use. The second group of objects relate to the linear algebra: the system matrix and right hand side as well as the solution vector, and an object that describes the sparsity pattern of the matrix. This is all this class needs (and the essentials that any solver for a stationary PDE requires) and that needs to survive throughout the entire program. In contrast to this, the <a class="el" href="classFEValues.html">FEValues</a> object we need for assembly is only required throughout assembly, and so we create it as a local object in the function that does that and destroy it again at its end.</p>
<p>Secondly, let's look at the member functions. These, as well, already form the common structure that almost all following tutorial programs will use: </p><ul>
<li>
<code>make_grid()</code>: This is what one could call a <em>preprocessing function</em>. As its name suggests, it sets up the object that stores the triangulation. In later examples, it could also deal with boundary conditions, geometries, etc. </li>
<li>
<code>setup_system()</code>: This then is the function in which all the other data structures are set up that are needed to solve the problem. In particular, it will initialize the <a class="el" href="classDoFHandler.html">DoFHandler</a> object and correctly size the various objects that have to do with the linear algebra. This function is often separated from the preprocessing function above because, in a time dependent program, it may be called at least every few time steps whenever the mesh is adaptively refined (something we will see how to do in <a class="el" href="step_6.html">step-6</a>). On the other hand, setting up the mesh itself in the preprocessing function above is done only once at the beginning of the program and is, therefore, separated into its own function. </li>
<li>
<code>assemble_system()</code>: This, then is where the contents of the matrix and right hand side are computed, as discussed at length in the introduction above. Since doing something with this linear system is conceptually very different from computing its entries, we separate it from the following function. </li>
<li>
<code>solve()</code>: This then is the function in which we compute the solution \(U\) of the linear system \(AU=F\). In the current program, this is a simple task since the matrix is so simple, but it will become a significant part of a program's size whenever the problem is not so trivial any more (see, for example, <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_22.html">step-22</a>, or <a class="el" href="step_31.html">step-31</a> once you've learned a bit more about the library). </li>
<li>
<code>output_results()</code>: Finally, when you have computed a solution, you probably want to do something with it. For example, you may want to output it in a format that can be visualized, or you may want to compute quantities you are interested in: say, heat fluxes in a heat exchanger, air friction coefficients of a wing, maximum bridge loads, or simply the value of the numerical solution at a point. This function is therefore the place for postprocessing your solution. </li>
</ul>
<p>All of this is held together by the single public function (other than the constructor), namely the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function. It is the one that is called from the place where an object of this type is created, and it is the one that calls all the other functions in their proper order. Encapsulating this operation into the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function, rather than calling all the other functions from <code>main()</code> makes sure that you can change how the separation of concerns within this class is implemented. For example, if one of the functions becomes too big, you can split it up into two, and the only places you have to be concerned about changing as a consequence are within this very same class, and not anywhere else.</p>
<p>As mentioned above, you will see this general structure &mdash; sometimes with variants in spelling of the functions' names, but in essentially this order of separation of functionality &mdash; again in many of the following tutorial programs.</p>
<p><a class="anchor" id="Anoteontypes"></a></p><h3>A note on types </h3>
<p>deal.II defines a number of integral types via alias in namespace <a class="el" href="namespacetypes.html">types</a>. (In the previous sentence, the word "integral" is used as the <em>adjective</em> that corresponds to the noun "integer". It shouldn't be confused with the <em>noun</em> "integral" that represents the area or volume under a curve or surface. The adjective "integral" is widely used in the C++ world in contexts such as "integral type", "integral constant", etc.) In particular, in this program you will see <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> in a couple of places: an integer type that is used to denote the <em>global</em> index of a degree of freedom, i.e., the index of a particular degree of freedom within the <a class="el" href="classDoFHandler.html">DoFHandler</a> object that is defined on top of a triangulation (as opposed to the index of a particular degree of freedom within a particular cell). For the current program (as well as almost all of the tutorial programs), you will have a few thousand to maybe a few million unknowns globally (and, for \(Q_1\) elements, you will have 4 <em>locally on each cell</em> in 2d and 8 in 3d). Consequently, a data type that allows to store sufficiently large numbers for global DoF indices is <code>unsigned int</code> given that it allows to store numbers between 0 and slightly more than 4 billion (on most systems, where integers are 32-bit). In fact, this is what <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> is.</p>
<p>So, why not just use <code>unsigned int</code> right away? deal.II used to do this until version 7.3. However, deal.II supports very large computations (via the framework discussed in <a class="el" href="step_40.html">step-40</a>) that may have more than 4 billion unknowns when spread across a few thousand processors. Consequently, there are situations where <code>unsigned int</code> is not sufficiently large and we need a 64-bit unsigned integral type. To make this possible, we introduced <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> which by default is defined as simply <code>unsigned int</code> whereas it is possible to define it as <code>unsigned long long int</code> if necessary, by passing a particular flag during configuration (see the ReadMe file).</p>
<p>This covers the technical aspect. But there is also a documentation purpose: everywhere in the library and codes that are built on it, if you see a place using the data type <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, you immediately know that the quantity that is being referenced is, in fact, a global dof index. No such meaning would be apparent if we had just used <code>unsigned int</code> (which may also be a local index, a boundary indicator, a material id, etc.). Immediately knowing what a variable refers to also helps avoid errors: it's quite clear that there must be a bug if you see an object of type <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> being assigned to variable of type <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, even though they are both represented by unsigned integers and the compiler will, consequently, not complain.</p>
<p>In more practical terms what the presence of this type means is that during assembly, we create a \(4\times 4\) matrix (in 2d, using a \(Q_1\) element) of the contributions of the cell we are currently sitting on, and then we need to add the elements of this matrix to the appropriate elements of the global (system) matrix. For this, we need to get at the global indices of the degrees of freedom that are local to the current cell, for which we will always use the following piece of the code: </p><div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p> where <code>local_dof_indices</code> is declared as </p><div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p> The name of this variable might be a bit of a misnomer &ndash; it stands for "the global indices of those degrees of freedom locally defined on the current cell" &ndash; but variables that hold this information are universally named this way throughout the library.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> is not the only type defined in this namespace. Rather, there is a whole family, including <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, and <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>. All of these are alias for integer data types but, as explained above, they are used throughout the library so that (i) the intent of a variable becomes more easily discerned, and (ii) so that it becomes possible to change the actual type to a larger one if necessary without having to go through the entire library and figure out whether a particular use of <code>unsigned int</code> corresponds to, say, a material indicator.</dd></dl>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Manynewincludefiles"></a> </p><h3>Many new include files</h3>
<p>These include files are already known to you. They declare the classes which handle triangulations and enumeration of degrees of freedom:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div></div><!-- fragment --><p>And this is the file in which the functions are declared that create grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>This file contains the description of the Lagrange interpolation finite element:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>And this file is needed for the creation of sparsity patterns of sparse matrices, as shown in previous examples:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The next two files are needed for assembling the matrix using quadrature on each cell. The classes declared in them will be explained below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div></div><!-- fragment --><p>The following three include files we need for the treatment of boundary values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>We're now almost to the end. The second to last group of include files is for the linear algebra which we employ to solve the system of equations arising from the finite element discretization of the Laplace equation. We will use vectors and full matrices for assembling the system of equations locally on each cell, and transfer the results into a sparse matrix. We will then use a Conjugate Gradient solver to solve the problem, for which we need a preconditioner (in this program, we use the identity preconditioner which does nothing, but we need to include the file anyway):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, this is for output to a file and to the console:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>...and this is to import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep3codeclass"></a> </p><h3>The <code>Step3</code> class</h3>
<p>Instead of the procedural programming of previous examples, we encapsulate everything into a class for this program. The class consists of functions which each perform certain aspects of a finite element program, a <code>main</code> function which controls what is done first and what is done next, and a list of member variables.</p>
<p>The public part of the class is rather short: it has a constructor and a function <code>run</code> that is called from the outside and acts as something like the <code>main</code> function: it coordinates which operations of this class shall be run in which order. Everything else in the class, i.e. all the functions that actually do anything, are in the private section of the class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div></div><!-- fragment --><p>Then there are the member functions that mostly do what their names suggest and whose have been discussed in the introduction already. Since they do not need to be called from outside, they are made private to this class.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>And finally we have some member variables. There are variables describing the triangulation and the global numbering of the degrees of freedom (we will specify the exact polynomial degree of the finite element in the constructor of this class)...</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>          fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>    dof_handler;</div></div><!-- fragment --><p>...variables for the sparsity pattern and values of the system matrix resulting from the discretization of the Laplace equation...</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>...and variables which will hold the right hand side and solution vectors.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Step3Step3"></a> </p><h4>Step3::Step3</h4>
<p>Here comes the constructor. It does not much more than first to specify that we want bi-linear elements (denoted by the parameter to the finite element object, which indicates the polynomial degree), and to associate the dof_handler variable to the triangulation we use. (Note that the triangulation isn't set up with a mesh at all at the present time, but the <a class="el" href="classDoFHandler.html">DoFHandler</a> doesn't care: it only wants to know which triangulation it will be associated with, and it only starts to care about an actual mesh once you try to distribute degree of freedom on the mesh using the distribute_dofs() function.) All the other member variables of the Step3 class have a default constructor which does all we want.</p>
<div class="fragment"><div class="line">Step3::Step3()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step3make_grid"></a> </p><h4>Step3::make_grid</h4>
<p>Now, the first thing we've got to do is to generate the triangulation on which we would like to do our computation and number each vertex with a degree of freedom. We have seen these two steps in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a> before, respectively.</p>
<p>This function does the first part, creating the mesh. We create the grid and refine all cells five times. Since the initial grid (which is the square \([-1,1] \times [-1,1]\)) consists of only one cell, the final grid has 32 times 32 cells, for a total of 1024.</p>
<p>Unsure that 1024 is the correct number? We can check that by outputting the number of cells using the <code><a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells()</a></code> function on the triangulation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We call the <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> function, rather than <a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">Triangulation::n_cells()</a>. Here, <em>active</em> means the cells that aren't refined any further. We stress the adjective "active" since there are more cells, namely the parent cells of the finest cells, their parents, etc, up to the one cell which made up the initial grid. Of course, on the next coarser level, the number of cells is one quarter that of the cells on the finest level, i.e. 256, then 64, 16, 4, and 1. If you called <code><a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">triangulation.n_cells()</a></code> instead in the code above, you would consequently get a value of 1365 instead. On the other hand, the number of cells (as opposed to the number of active cells) is not typically of much interest, so there is no good reason to print it.</dd></dl>
<p><a class="anchor" id="Step3setup_system"></a> </p><h4>Step3::setup_system</h4>
<p>Next we enumerate all the degrees of freedom and set up matrix and vector objects to hold the system data. Enumerating is done by using <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>, as we have seen in the <a class="el" href="step_2.html">step-2</a> example. Since we use the <a class="el" href="classFE__Q.html">FE_Q</a> class and have set the polynomial degree to 1 in the constructor, i.e. bilinear elements, this associates one degree of freedom with each vertex. While we're at generating output, let us also take a look at how many degrees of freedom are generated:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div></div><!-- fragment --><p>There should be one DoF for each vertex. Since we have a 32 times 32 grid, the number of DoFs should be 33 times 33, or 1089.</p>
<p>As we have seen in the previous example, we set up a sparsity pattern by first creating a temporary structure, tagging those entries that might be nonzero, and then copying the data over to the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object that can then be used by the system matrix.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div></div><!-- fragment --><p>Note that the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object does not hold the values of the matrix, it only stores the places where entries are. The entries themselves are stored in objects of type <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, of which our variable system_matrix is one.</p>
<p>The distinction between sparsity pattern and matrix was made to allow several matrices to use the same sparsity pattern. This may not seem relevant here, but when you consider the size which matrices can have, and that it may take some time to build the sparsity pattern, this becomes important in large-scale problems if you have to store several matrices in your program.</p>
<div class="fragment"><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The last thing to do in this function is to set the sizes of the right hand side vector and the solution vector to the right values:</p>
<div class="fragment"><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3assemble_system"></a> </p><h4>Step3::assemble_system</h4>
<p>The next step is to compute the entries of the matrix and right hand side that form the linear system from which we compute the solution. This is the central function of each finite element program and we have discussed the primary steps in the introduction already.</p>
<p>The general approach to assemble matrices and vectors is to loop over all cells, and on each cell compute the contribution of that cell to the global matrix and right hand side by quadrature. The point to realize now is that we need the values of the shape functions at the locations of quadrature points on the real cell. However, both the finite element shape functions as well as the quadrature points are only defined on the reference cell. They are therefore of little help to us, and we will in fact hardly ever query information about finite element shape functions or quadrature points from these objects directly.</p>
<p>Rather, what is required is a way to map this data from the reference cell to the real cell. Classes that can do that are derived from the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> class, though one again often does not have to deal with them directly: many functions in the library can take a mapping object as argument, but when it is omitted they simply resort to the standard bilinear Q1 mapping. We will go this route, and not bother with it for the moment (we come back to this in <a class="el" href="step_10.html">step-10</a>, <a class="el" href="step_11.html">step-11</a>, and <a class="el" href="step_12.html">step-12</a>).</p>
<p>So what we now have is a collection of three classes to deal with: finite element, quadrature, and mapping objects. That's too much, so there is one type of class that orchestrates information exchange between these three: the <a class="el" href="classFEValues.html">FEValues</a> class. If given one instance of each three of these objects (or two, and an implicit linear mapping), it will be able to provide you with information about values and gradients of shape functions at quadrature points on a real cell.</p>
<p>Using all this, we will assemble the linear system for this problem in the following function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div></div><!-- fragment --><p>Ok, let's start: we need a quadrature formula for the evaluation of the integrals on each cell. Let's take a Gauss formula with two quadrature points in each direction, i.e. a total of four points since we are in 2D. This quadrature formula integrates polynomials of degrees up to three exactly (in 1D). It is easy to check that this is sufficient for the present problem:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div></div><!-- fragment --><p>And we initialize the object which we have briefly talked about above. It needs to be told which finite element we want to use, and the quadrature points and their weights (jointly described by a <a class="el" href="classQuadrature.html">Quadrature</a> object). As mentioned, we use the implied Q1 mapping, rather than specifying one ourselves explicitly. Finally, we have to tell it what we want it to compute on each cell: we need the values of the shape functions at the quadrature points (for the right hand side \((\varphi_i,f)\)), their gradients (for the matrix entries \((\nabla \varphi_i, \nabla \varphi_j)\)), and also the weights of the quadrature points and the determinants of the Jacobian transformations from the reference cell to the real cells.</p>
<p>This list of what kind of information we actually need is given as a collection of flags as the third argument to the constructor of <a class="el" href="classFEValues.html">FEValues</a>. Since these values have to be recomputed, or updated, every time we go to a new cell, all of these flags start with the prefix <code>update_</code> and then indicate what it actually is that we want updated. The flag to give if we want the values of the shape functions computed is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea" title="Shape function values. ">update_values</a>; for the gradients it is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20" title="Shape function gradients. ">update_gradients</a>. The determinants of the Jacobians and the quadrature weights are always used together, so only the products (Jacobians times weights, or short <code>JxW</code>) are computed; since we need them, we have to list <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85" title="Transformed quadrature weights. ">update_JxW_values</a> as well:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                      quadrature_formula,</div><div class="line">                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>The advantage of this approach is that we can specify what kind of information we actually need on each cell. It is easily understandable that this approach can significantly speed up finite element computations, compared to approaches where everything, including second derivatives, normal vectors to cells, etc are computed on each cell, regardless of whether they are needed or not.</p>
<dl class="section note"><dt>Note</dt><dd>The syntax <code>update_values | update_gradients | update_JxW_values</code> is not immediately obvious to anyone not used to programming bit operations in C for years already. First, <code>operator|</code> is the <em>bitwise or operator</em>, i.e., it takes two integer arguments that are interpreted as bit patterns and returns an integer in which every bit is set for which the corresponding bit is set in at least one of the two arguments. For example, consider the operation <code>9|10</code>. In binary, <code>9=0b1001</code> (where the prefix <code>0b</code> indicates that the number is to be interpreted as a binary number) and <code>10=0b1010</code>. Going through each bit and seeing whether it is set in one of the argument, we arrive at <code>0b1001|0b1010=0b1011</code> or, in decimal notation, <code>9|10=11</code>. The second piece of information you need to know is that the various <code>update_*</code> flags are all integers that have <em>exactly one bit set</em>. For example, assume that <code>update_values=0b00001=1</code>, <code>update_gradients=0b00010=2</code>, <code>update_JxW_values=0b10000=16</code>. Then <code>update_values | update_gradients | update_JxW_values = 0b10011 = 19</code>. In other words, we obtain a number that <em>encodes a binary mask representing all of the operations you want to happen</em>, where each operation corresponds to exactly one bit in the integer that, if equal to one, means that a particular piece should be updated on each cell and, if it is zero, means that we need not compute it. In other words, even though <code>operator|</code> is the <em>bitwise OR operation</em>, what it really represents is <em>I want this AND that AND the other</em>. Such binary masks are quite common in C programming, but maybe not so in higher level languages like C++, but serve the current purpose quite well.</dd></dl>
<p>For use further down below, we define a shortcut for a value that will be used very frequently. Namely, an abbreviation for the number of degrees of freedom on each cell (since we are in 2D and degrees of freedom are associated with vertices only, this number is four, but we rather want to write the definition of this variable in a way that does not preclude us from later choosing a different finite element that has a different number of degrees of freedom per cell, or work in a different space dimension).</p>
<p>In general, it is a good idea to use a symbolic name instead of hard-coding these numbers even if you know them, since for example, you may want to change the finite element at some time. Changing the element would have to be done in a different function and it is easy to forget to make a corresponding change in another part of the program. It is better to not rely on your own calculations, but instead ask the right object for the information: Here, we ask the finite element to tell us about the number of degrees of freedom per cell and we will get the correct number regardless of the space dimension or polynomial degree we may have chosen elsewhere in the program.</p>
<p>The shortcut here, defined primarily to discuss the basic concept and not because it saves a lot of typing, will then make the following loops a bit more readable. You will see such shortcuts in many places in larger programs, and <code>dofs_per_cell</code> is one that is more or less the conventional name for this kind of object.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div></div><!-- fragment --><p>Now, we said that we wanted to assemble the global matrix and vector cell-by-cell. We could write the results directly into the global matrix, but this is not very efficient since access to the elements of a sparse matrix is slow. Rather, we first compute the contribution of each cell in a small matrix with the degrees of freedom on the present cell, and only transfer them to the global matrix when the computations are finished for this cell. We do the same for the right hand side vector. So let's first allocate these objects (these being local objects, all degrees of freedom are coupling with all others, and we should use a full matrix object rather than a sparse one for the local operations; everything will be transferred to a global sparse matrix later on):</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div></div><!-- fragment --><p>When assembling the contributions of each cell, we do this with the local numbering of the degrees of freedom (i.e. the number running from zero through dofs_per_cell-1). However, when we transfer the result into the global matrix, we have to know the global numbers of the degrees of freedom. When we query them, we need a scratch (temporary) array for these numbers (see the discussion at the end of the introduction for the type, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, used here):</p>
<div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Now for the loop over all cells. We have seen before how this works for a triangulation. A <a class="el" href="classDoFHandler.html">DoFHandler</a> has cell iterators that are exactly analogous to those of a <a class="el" href="classTriangulation.html">Triangulation</a>, but with extra information about the degrees of freedom for the finite element you're using. Looping over the active cells of a degree-of-freedom handler works the same as for a triangulation.</p>
<p>Note that we declare the type of the cell as <code>const auto &amp;</code> instead of <code>auto</code> this time around. In step 1, we were modifying the cells of the triangulation by flagging them with refinement indicators. Here we're only examining the cells without modifying them, so it's good practice to declare <code>cell</code> as <code>const</code> in order to enforce this invariant.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We are now sitting on one cell, and we would like the values and gradients of the shape functions be computed, as well as the determinants of the Jacobian matrices of the mapping between reference cell and true cell, at the quadrature points. Since all these values depend on the geometry of the cell, we have to have the <a class="el" href="classFEValues.html">FEValues</a> object re-compute them on each cell:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div></div><!-- fragment --><p>Next, reset the local cell's contributions to global matrix and global right hand side to zero, before we fill them:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">cell_rhs    = 0;</div></div><!-- fragment --><p>Now it is time to start integration over the cell, which we do by looping over all quadrature points, which we will number by q_index.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>First assemble the matrix: For the Laplace problem, the matrix on each cell is the integral over the gradients of shape function i and j. Since we do not integrate, but rather use quadrature, this is the sum over all quadrature points of the integrands times the determinant of the Jacobian matrix at the quadrature point times the weight of this quadrature point. You can get the gradient of shape function \(i\) at quadrature point with number q_index by using <code>fe_values.shape_grad(i,q_index)</code>; this gradient is a 2-dimensional vector (in fact it is of type <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;, with here dim=2) and the product of two such vectors is the scalar product, i.e. the product of the two shape_grad function calls is the dot product. This is in turn multiplied by the Jacobian determinant and the quadrature point weight (that one gets together by the call to <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a> ). Finally, this is repeated for all shape functions \(i\) and \(j\):</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div></div><!-- fragment --><p>We then do the same thing for the right hand side. Here, the integral is over the shape function i times the right hand side function, which we choose to be the function with constant value one (more interesting examples will be considered in the following programs).</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                    1. *                                <span class="comment">// f(x_q)</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">}</div></div><!-- fragment --><p>Now that we have the contribution of this cell, we have to transfer it to the global matrix and right hand side. To this end, we first have to find out which global numbers the degrees of freedom on this cell have. Let's simply ask the cell for that information:</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>Then again loop over all shape functions i and j and transfer the local elements to the global matrix. The global numbers can be obtained using local_dof_indices[i]:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    system_matrix.add(local_dof_indices[i],</div><div class="line">                      local_dof_indices[j],</div><div class="line">                      cell_matrix(i, j));</div></div><!-- fragment --><p>And again, we do the same thing for the right hand side vector.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">}</div></div><!-- fragment --><p>Now almost everything is set up for the solution of the discrete system. However, we have not yet taken care of boundary values (in fact, Laplace's equation without Dirichlet boundary values is not even uniquely solvable, since you can add an arbitrary constant to the discrete solution). We therefore have to do something about the situation.</p>
<p>For this, we first obtain a list of the degrees of freedom on the boundary and the value the shape function shall have there. For simplicity, we only interpolate the boundary value function, rather than projecting it onto the boundary. There is a function in the library which does exactly this: <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>. Its parameters are (omitting parameters for which default values exist and that we don't care about): the <a class="el" href="classDoFHandler.html">DoFHandler</a> object to get the global numbers of the degrees of freedom on the boundary; the component of the boundary where the boundary values shall be interpolated; the boundary value function itself; and the output object.</p>
<p>The component of the boundary is meant as follows: in many cases, you may want to impose certain boundary values only on parts of the boundary. For example, you may have inflow and outflow boundaries in fluid dynamics, or clamped and free parts of bodies in deformation computations of bodies. Then you will want to denote these different parts of the boundary by indicators, and tell the interpolate_boundary_values function to only compute the boundary values on a certain part of the boundary (e.g. the clamped part, or the inflow boundary). By default, all boundaries have a 0 boundary indicator, unless otherwise specified. If sections of the boundary have different boundary conditions, you have to number those parts with different boundary indicators. The function call below will then only determine boundary values for those parts of the boundary for which the boundary indicator is in fact the zero specified as the second argument.</p>
<p>The function describing the boundary values is an object of type <a class="el" href="classFunction.html">Function</a> or of a derived class. One of the derived classes is <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a>, which describes (not unexpectedly) a function which is zero everywhere. We create such an object in-place and pass it to the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function.</p>
<p>Finally, the output object is a list of pairs of global degree of freedom numbers (i.e. the number of the degrees of freedom on the boundary) and their boundary values (which are zero here for all entries). This mapping of DoF numbers to boundary values is done by the <code>std::map</code> class.</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                         boundary_values);</div></div><!-- fragment --><p>Now that we got the list of boundary DoFs and their respective boundary values, let's use them to modify the system of equations accordingly. This is done by the following function call:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3solve"></a> </p><h4>Step3::solve</h4>
<p>The following function simply solves the discretized equation. As the system is quite a large one for direct solvers such as Gauss elimination or LU decomposition, we use a Conjugate Gradient algorithm. You should remember that the number of variables here (only 1089) is a very small number for finite element computations, where 100.000 is a more usual number. For this number of variables, direct methods are no longer usable and you are forced to use methods like CG.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div></div><!-- fragment --><p>First, we need to have an object that knows how to tell the CG algorithm when to stop. This is done by using a <a class="el" href="classSolverControl.html">SolverControl</a> object, and as stopping criterion we say: stop after a maximum of 1000 iterations (which is far more than is needed for 1089 variables; see the results section to find out how many were really used), and stop if the norm of the residual is below \(10^{-12}\). In practice, the latter criterion will be the one which stops the iteration:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div></div><!-- fragment --><p>Then we need the solver itself. The template parameter to the <a class="el" href="classSolverCG.html">SolverCG</a> class is the type of the vectors, and leaving the empty angle brackets would indicate that we are taking the default argument (which is <code><a class="el" href="classVector.html">Vector</a>&lt;double&gt;</code>). However, we explicitly mention the template argument:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div></div><!-- fragment --><p>Now solve the system of equations. The CG solver takes a preconditioner as its fourth argument. We don't feel ready to delve into this yet, so we tell it to use the identity operation as preconditioner:</p>
<div class="fragment"><div class="line">solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>Now that the solver has done its job, the solution variable contains the nodal values of the solution function.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3output_results"></a> </p><h4>Step3::output_results</h4>
<p>The last part of a typical finite element program is to output the results and maybe do some postprocessing (for example compute the maximal stress values at the boundary, or the average flux across the outflow, etc). We have no such postprocessing here, but we would like to write the solution to a file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>To write the output to a file, we need an object which knows about output formats and the like. This is the <a class="el" href="classDataOut.html">DataOut</a> class, and we need an object of that type:</p>
<div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div></div><!-- fragment --><p>Now we have to tell it where to take the values from which it shall write. We tell it which <a class="el" href="classDoFHandler.html">DoFHandler</a> object to use, and the solution vector (and the name by which the solution variable shall appear in the output file). If we had more than one vector which we would like to look at in the output (for example right hand sides, errors per cell, etc) we would add them as well:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div></div><!-- fragment --><p>After the <a class="el" href="classDataOut.html">DataOut</a> object knows which data it is to work on, we have to tell it to process them into something the back ends can handle. The reason is that we have separated the frontend (which knows about how to treat <a class="el" href="classDoFHandler.html">DoFHandler</a> objects and data vectors) from the back end (which knows many different output formats) and use an intermediate data format to transfer data from the front- to the backend. The data is transformed into this intermediate format by the following function:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div></div><!-- fragment --><p>Now we have everything in place for the actual output. Just open a file and write the data into it, using VTK format (there are many other functions in the <a class="el" href="classDataOut.html">DataOut</a> class we are using here that can write the data in postscript, AVS, GMV, Gnuplot, or some other file formats):</p>
<div class="fragment"><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3run"></a> </p><h4>Step3::run</h4>
<p>Finally, the last function of this class is the main function which calls all the other functions of the <code>Step3</code> class. The order in which this is done resembles the order in which most finite element programs work. Since the names are mostly self-explanatory, there is not much to comment about:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>This is the main function of the program. Since the concept of a main function is mostly a remnant from the pre-object oriented era before C++ programming, it often does not do much more than creating an object of the top-level class and calling its principle function.</p>
<p>Finally, the first line of the function is used to enable output of some diagnostics that deal.II can generate. The <code>deallog</code> variable (which stands for deal-log, not de-allog) represents a stream to which some parts of the library write output. For example, iterative solvers will generate diagnostics (starting residual, number of solver steps, final residual) as can be seen when running this tutorial program.</p>
<p>The output of <code>deallog</code> can be written to the console, to a file, or both. Both are disabled by default since over the years we have learned that a program should only generate output when a user explicitly asks for it. But this can be changed, and to explain how this can be done, we need to explain how <code>deallog</code> works: When individual parts of the library want to log output, they open a "context" or "section" into which this output will be placed. At the end of the part that wants to write output, one exits this section again. Since a function may call another one from within the scope where this output section is open, output may in fact be nested hierarchically into these sections. The <a class="el" href="classLogStream.html">LogStream</a> class of which <code>deallog</code> is a variable calls each of these sections a "prefix" because all output is printed with this prefix at the left end of the line, with prefixes separated by colons. There is always a default prefix called "DEAL" (a hint at deal.II's history as the successor of a previous library called "DEAL" and from which the <a class="el" href="classLogStream.html">LogStream</a> class is one of the few pieces of code that were taken into deal.II).</p>
<p>By default, <code>logstream</code> only outputs lines with zero prefixes &ndash; i.e., all output is disabled because the default "DEAL" prefix is always there. But one can set a different maximal number of prefixes for lines that should be output to something larger, and indeed here we set it to two by calling <a class="el" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">LogStream::depth_console()</a>. This means that for all screen output, a context that has pushed one additional prefix beyond the default "DEAL" is allowed to print its output to the screen ("console"), whereas all further nested sections that would have three or more prefixes active would write to <code>deallog</code>, but <code>deallog</code> does not forward this output to the screen. Thus, running this example (or looking at the "Results" section), you will see the solver statistics prefixed with "DEAL:CG", which is two prefixes. This is sufficient for the context of the current program, but you will see examples later on (e.g., in <a class="el" href="step_22.html">step-22</a>) where solvers are nested more deeply and where you may get useful information by setting the depth even higher.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of the program looks as follows: </p><div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">DEAL:cg::Starting value 0.121094</div><div class="line">DEAL:cg::Convergence step 48 value 5.33692e-13</div></div><!-- fragment --><p>The first two lines is what we wrote to <code>cout</code>. The last two lines were generated without our intervention by the CG solver. The first two lines state the residual at the start of the iteration, while the last line tells us that the solver needed 47 iterations to bring the norm of the residual to 5.3e-13, i.e. below the threshold 1e-12 which we have set in the `solve' function. We will show in the next program how to suppress this output, which is sometimes useful for debugging purposes, but often clutters up the screen display.</p>
<p>Apart from the output shown above, the program generated the file <code>solution.vtk</code>, which is in the VTK format that is widely used by many visualization programs today &ndash; including the two heavy-weights <a href="https://www.llnl.gov/visit">VisIt</a> and <a href="https://www.paraview.org">Paraview</a> that are the most commonly used programs for this purpose today.</p>
<p>Using VisIt, it is not very difficult to generate a picture of the solution like this: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.solution-3.png" alt="Visualization of the solution of step-3"/>
</div>
   </td></tr>
</table>
<p>It shows both the solution and the mesh, elevated above the \(x\)- \(y\) plane based on the value of the solution at each point. Of course the solution here is not particularly exciting, but that is a result of both what the Laplace equation represents and the right hand side \(f(\mathbf x)=1\) we have chosen for this program: The Laplace equation describes (among many other uses) the vertical deformation of a membrane subject to an external (also vertical) force. In the current example, the membrane's borders are clamped to a square frame with no vertical variation; a constant force density will therefore intuitively lead to a membrane that simply bulges upward &ndash; like the one shown above.</p>
<p>VisIt and Paraview both allow playing with various kinds of visualizations of the solution. Several video lectures show how to use these programs. See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.11.html">video lecture 11</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.32.html">video lecture 32</a>.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>If you want to play around a little bit with this program, here are a few suggestions: </p>
<ul>
<li>
<p class="startli">Change the geometry and mesh: In the program, we have generated a square domain and mesh by using the <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code> function. However, the <code><a class="el" href="namespaceGridGenerator.html">GridGenerator</a></code> has a good number of other functions as well. Try an L-shaped domain, a ring, or other domains you find there. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Change the boundary condition: The code uses the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> function to generate zero boundary conditions. However, you may want to try non-zero constant boundary values using <code>ConstantFunction&lt;2&gt;(1)</code> instead of <code>ZeroFunction&lt;2&gt;()</code> to have unit Dirichlet boundary values. More exotic functions are described in the documentation of the <a class="el" href="namespaceFunctions.html">Functions</a> namespace, and you may pick one to describe your particular boundary values. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Modify the type of boundary condition: Presently, what happens is that we use Dirichlet boundary values all around, since the default is that all boundary parts have boundary indicator zero, and then we tell the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function to interpolate boundary values to zero on all boundary components with indicator zero. </p>
<p>We can change this behavior if we assign parts of the boundary different indicators. For example, try this immediately after calling <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>: </p><div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>()-&gt;face(0)-&gt;set_boundary_id(1);</div></div><!-- fragment --><p>What this does is it first asks the triangulation to return an iterator that points to the first active cell. Of course, this being the coarse mesh for the triangulation of a square, the triangulation has only a single cell at this moment, and it is active. Next, we ask the cell to return an iterator to its first face, and then we ask the face to reset the boundary indicator of that face to 1. What then follows is this: When the mesh is refined, faces of child cells inherit the boundary indicator of their parents, i.e. even on the finest mesh, the faces on one side of the square have boundary indicator 1. Later, when we get to interpolating boundary conditions, the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> call will only produce boundary values for those faces that have zero boundary indicator, and leave those faces alone that have a different boundary indicator. What this then does is to impose Dirichlet boundary conditions on the former, and homogeneous Neumann conditions on the latter (i.e. zero normal derivative of the solution, unless one adds additional terms to the right hand side of the variational equality that deal with potentially non-zero Neumann conditions). You will see this if you run the program.</p>
<p>An alternative way to change the boundary indicator is to label the boundaries based on the Cartesian coordinates of the face centers. For example, we can label all of the cells along the top and bottom boundaries with a boundary indicator 1 by checking to see if the cell centers' y-coordinates are within a tolerance (here 1e-12) of -1 and 1. Try this immediately after calling <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, as before: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (-1.0)) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 ||</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (1.0)) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12)</div><div class="line">    face-&gt;set_boundary_id(1);</div></div><!-- fragment --><p> Although this code is a bit longer than before, it is useful for complex geometries, as it does not require knowledge of face labels.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A slight variation of the last point would be to set different boundary values as above, but then use a different boundary value function for boundary indicator one. In practice, what you have to do is to add a second call to <code>interpolate_boundary_values</code> for boundary indicator one: </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         1,</div><div class="line">                                         <a class="code" href="classFunctions_1_1ConstantFunction.html">ConstantFunction&lt;2&gt;</a>(1.),</div><div class="line">                                         boundary_values);</div></div><!-- fragment --><p> If you have this call immediately after the first one to this function, then it will interpolate boundary values on faces with boundary indicator 1 to the unit value, and merge these interpolated values with those previously computed for boundary indicator 0. The result will be that we will get discontinuous boundary values, zero on three sides of the square, and one on the fourth.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Observe convergence: We will only discuss computing errors in norms in <a class="el" href="step_7.html">step-7</a>, but it is easy to check that computations converge already here. For example, we could evaluate the value of the solution in a single point and compare the value for different numbers of global refinement (the number of global refinement steps is set in <code>LaplaceProblem::make_grid</code> above). To evaluate the solution at a point, say at \((\frac 13, \frac 13)\), we could add the following code to the <code>LaplaceProblem::output_results</code> function: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Solution at (1/3,1/3): &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, solution,</div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1./3, 1./3))</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p> For 1 through 9 global refinement steps, we then get the following sequence of point values: </p><table align="center" class="doxtable">
<tr>
<th># of refinements </th><th>\(u_h(\frac 13,\frac13)\)  </th></tr>
<tr>
<td>1 </td><td>0.166667  </td></tr>
<tr>
<td>2 </td><td>0.227381  </td></tr>
<tr>
<td>3 </td><td>0.237375  </td></tr>
<tr>
<td>4 </td><td>0.240435  </td></tr>
<tr>
<td>5 </td><td>0.241140  </td></tr>
<tr>
<td>6 </td><td>0.241324  </td></tr>
<tr>
<td>7 </td><td>0.241369  </td></tr>
<tr>
<td>8 </td><td>0.241380  </td></tr>
<tr>
<td>9 </td><td>0.241383  </td></tr>
</table>
<p>By noticing that the difference between each two consecutive values reduces by about a factor of 4, we can conjecture that the "correct" value may be \(u(\frac 13, \frac 13)\approx 0.241384\). In fact, if we assumed this to be the correct value, we could show that the sequence above indeed shows \({\cal O}(h^2)\) convergence &mdash; theoretically, the convergence order should be \({\cal O}(h^2 |\log h|)\) but the symmetry of the domain and the mesh may lead to the better convergence order observed.</p>
<p>A slight variant of this would be to repeat the test with quadratic elements. All you need to do is to set the polynomial degree of the finite element to two in the constructor <code>LaplaceProblem::LaplaceProblem</code>.</p>
<p class="endli"></p>
</li>
<li>
Convergence of the mean: A different way to see that the solution actually converges (to something &mdash; we can't tell whether it's really the correct value!) is to compute the mean of the solution. To this end, add the following code to <code>LaplaceProblem::output_results</code>: <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mean value: &quot;</span></div><div class="line">          &lt;&lt; VectorTools::compute_mean_value (dof_handler,</div><div class="line">                                              <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                              solution,</div><div class="line">                                              0)</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --> The documentation of the function explains what the second and fourth parameters mean, while the first and third should be obvious. Doing the same study again where we change the number of global refinement steps, we get the following result: <table align="center" class="doxtable">
<tr>
<th># of refinements </th><th>\(\int_\Omega u_h(x)\; dx\)  </th></tr>
<tr>
<td>0 </td><td>0.09375000  </td></tr>
<tr>
<td>1 </td><td>0.12790179  </td></tr>
<tr>
<td>2 </td><td>0.13733440  </td></tr>
<tr>
<td>3 </td><td>0.13976069  </td></tr>
<tr>
<td>4 </td><td>0.14037251  </td></tr>
<tr>
<td>5 </td><td>0.14052586  </td></tr>
<tr>
<td>6 </td><td>0.14056422  </td></tr>
<tr>
<td>7 </td><td>0.14057382  </td></tr>
<tr>
<td>8 </td><td>0.14057622  </td></tr>
</table>
Again, the difference between two adjacent values goes down by about a factor of four, indicating convergence as \({\cal O}(h^2)\). </li>
</ul>
<p><a class="anchor" id="UsingHDF5tooutputthesolutionandadditionaldata"></a></p><h3>Using HDF5 to output the solution and additional data</h3>
<p>HDF5 is a commonly used format that can be read by many scripting languages (e.g. R or Python). It is not difficult to get deal.II to produce some HDF5 files that can then be used in external scripts to postprocess some of the data generated by this program. Here are some ideas on what is possible.</p>
<p><a class="anchor" id="Changingtheoutputtoh5"></a></p><h4>Changing the output to .h5</h4>
<p>To fully make use of the automation we first need to introduce a private variable for the number of global refinement steps <code>unsigned int n_refinement_steps </code>, which will be used for the output filename. In <code>make_grid()</code> we then replace <code>triangulation.refine_global(5);</code> with </p><div class="fragment"><div class="line">n_refinement_steps = 5;</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div></div><!-- fragment --><p> The deal.II library has two different HDF5 bindings, one in the <a class="el" href="namespaceHDF5.html">HDF5</a> namespace (for interfacing to general-purpose data files) and another one in <a class="el" href="classDataOut.html">DataOut</a> (specifically for writing files for the visualization of solutions). Although the <a class="el" href="namespaceHDF5.html">HDF5</a> deal.II binding supports both serial and MPI, the HDF5 <a class="el" href="classDataOut.html">DataOut</a> binding only supports parallel output. For this reason we need to initialize an MPI communicator with only one processor. This is done by adding the following code. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> Next we change the <code>Step3::output_results()</code> output routine as described in the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> namespace documentation: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename_h5 = <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_refinement_steps) + <span class="stringliteral">&quot;.h5&quot;</span>;</div><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, filename_h5, MPI_COMM_WORLD);</div></div><!-- fragment --><p> The resulting file can then be visualized just like the VTK file that the original version of the tutorial produces; but, since HDF5 is a more general file format, it can also easily be processed in scripting languages for other purposes.</p>
<p><a class="anchor" id="Addingthepointvalueandthemeanseeextensionaboveintotheh5file"></a></p><h4>Adding the point value and the mean (see extension above) into the .h5 file</h4>
<p>After outputting the solution, the file can be opened again to include more datasets. This allows us to keep all the necessary information of our experiment in a single result file, which can then be read and processed by some postprocessing script. (Have a look at HDF5::Group::write_dataset() for further information on the possible output options.)</p>
<p>To make this happen, we first include the necessary header into our file : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hdf5_8h.html">deal.II/base/hdf5.h</a>&gt;</span></div></div><!-- fragment --><p> Adding the following lines to the end of our output routine adds the information about the value of the solution at a particular point, as well as the mean value of the solution, to our HDF5 file : </p><div class="fragment"><div class="line">HDF5::File data_file(filename_h5, HDF5::File::FileAccessMode::open, MPI_COMM_WORLD);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a>(1);</div><div class="line">point_value[0] = <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, solution,</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1./3, 1./3));</div><div class="line">data_file.write_dataset(<span class="stringliteral">&quot;point_value&quot;</span>, point_value);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> mean_value(1);</div><div class="line">mean_value[0] = VectorTools::compute_mean_value(dof_handler,</div><div class="line">                                                <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                                solution, 0);</div><div class="line">data_file.write_dataset(<span class="stringliteral">&quot;mean_value&quot;</span>,mean_value);</div></div><!-- fragment --><p><a class="anchor" id="UsingRandggplot2togenerateplots"></a></p><h3>Using R and ggplot2 to generate plots</h3>
<p>The data put into HDF5 files above can then be used from scripting languages for further postprocessing. In the following, let us show how this can, in particular, be done with the <a href="https://en.wikipedia.org/wiki/R_(programming_language)">R programming language</a>, a widely used language in statistical data analysis. (Similar things can also be done in Python, for example.) If you are unfamiliar with R and ggplot2 you could check out the data carpentry course on R <a href="https://datacarpentry.org/R-ecology-lesson/index.html">here</a>. Furthermore, since most search engines struggle with searches of the form "R + topic", we recommend using the specializes service <a href="http://rseek.org">RSeek </a> instead.</p>
<p>The most prominent difference between R and other languages is that the assignment operator (<code>a = 5</code>) is typically written as <code>a &lt;- 5</code>. As the latter is considered standard we will use it in our examples as well. To open the <code>.h5</code> file in R you have to install the <a href="https://bioconductor.org/packages/release/bioc/html/rhdf5.html">rhdf5</a> package, which is a part of the Bioconductor package.</p>
<p>First we will include all necessary packages and have a look at how the data is structured in our file. </p><div class="fragment"><div class="line">library(rhdf5)     # library for handling HDF5 files</div><div class="line">library(ggplot2)   # main plotting library</div><div class="line">library(grDevices) # needed for output to PDF</div><div class="line">library(viridis)   # contains good colormaps for sequential data</div><div class="line"></div><div class="line">refinement &lt;- 5</div><div class="line">h5f &lt;- H5Fopen(paste(&quot;solution_&quot;,refinement,&quot;.h5&quot;,sep=&quot;&quot;))</div><div class="line">print(h5f)</div></div><!-- fragment --><p> This gives the following output </p><div class="fragment"><div class="line">HDF5 FILE</div><div class="line">   name /</div><div class="line">filename</div><div class="line"></div><div class="line">    name       otype  dclass     dim</div><div class="line">0 cells       H5I_DATASET INTEGER  x 1024</div><div class="line">1 mean_value  H5I_DATASET FLOAT   1</div><div class="line">2 nodes       H5I_DATASET FLOAT    x 1089</div><div class="line">3 point_value H5I_DATASET FLOAT   1</div><div class="line">4 solution    H5I_DATASET FLOAT    x 1089</div></div><!-- fragment --><p> The datasets can be accessed by <code>h5f$name</code>. The function <code>dim(h5f$cells)</code> gives us the dimensions of the matrix that is used to store our cells. We can see the following three matrices, as well as the two additional data points we added. </p><ul>
<li>
<code>cells</code>: a 4x1024 matrix that stores the (C++) vertex indices for each cell </li>
<li>
<code>nodes</code>: a 2x1089 matrix storing the position values (x,y) for our cell vertices </li>
<li>
<code>solution</code>: a 1x1089 matrix storing the values of our solution at each vertex </li>
</ul>
<p>Now we can use this data to generate various plots. Plotting with ggplot2 usually splits into two steps. At first the data needs to be manipulated and added to a <code>data.frame</code>. After that, a <code>ggplot</code> object is constructed and manipulated by adding plot elements to it.</p>
<p><code>nodes</code> and <code>cells</code> contain all the information we need to plot our grid. The following code wraps all the data into one dataframe for plotting our grid: </p><div class="fragment"><div class="line"># Counting in R starts at 1 instead of 0, so we need to increment all</div><div class="line"># vertex indices by one:</div><div class="line">cell_ids &lt;- h5f@f$cells+1</div><div class="line"></div><div class="line"># Store the x and y positions of each vertex in one big vector in a</div><div class="line"># cell by cell fashion (every 4 entries belong to one cell):</div><div class="line">cells_x &lt;- h5f@f$nodes[1,][cell_ids]</div><div class="line">cells_y &lt;- h5f@f$nodes[2,][cell_ids]</div><div class="line"></div><div class="line"># Construct a vector that stores the matching cell by cell grouping</div><div class="line"># (1,1,1,1,2,2,2,2,...):</div><div class="line">groups &lt;- rep(1:ncol(cell_ids),each=4)</div><div class="line"></div><div class="line"># Finally put everything into one dataframe:</div><div class="line">meshdata &lt;- data.frame(x = cells_x, y = cells_y, id = groups)</div></div><!-- fragment --><p>With the finished dataframe we have everything we need to plot our grid: </p><div class="fragment"><div class="line">pdf (paste(&quot;grid_&quot;,refinement,&quot;.pdf&quot;,sep=&quot;&quot;),width = 5,height = 5) # Open new PDF file</div><div class="line">plt &lt;- ggplot(meshdata,aes(x=x,y=y,group=id))                      # Construction of our plot</div><div class="line">                                                                   # object, at first only data</div><div class="line"></div><div class="line">plt &lt;- plt + geom_polygon(fill=&quot;white&quot;,colour=&quot;black&quot;)             # Actual plotting of the grid as polygons</div><div class="line">plt &lt;- plt + ggtitle(paste(&quot;grid at refinement level #&quot;,refinement))</div><div class="line"></div><div class="line">print(plt)                                                         # Show the current state of the plot/add it to the pdf</div><div class="line">dev.off()                                                          # Close PDF file</div></div><!-- fragment --><p>The contents of this file then look as follows (not very exciting, but you get the idea): </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.grid_5.png" alt="Grid after 5 refinement steps of step-3"/>
</div>
   </td></tr>
</table>
<p>We can also visualize the solution itself, and this is going to look more interesting. To make a 2D pseudocolor plot of our solution we will use <code>geom_raster</code>. This function needs a structured grid, i.e. uniform in x and y directions. Luckily our data at this point is structured in the right way. The following code plots a pseudocolor representation of our surface into a new PDF: </p><div class="fragment"><div class="line">pdf (paste(&quot;pseudocolor_&quot;,refinement,&quot;.pdf&quot;,sep=&quot;&quot;),width = 5,height = 4.2) # Open new PDF file</div><div class="line">colordata &lt;- data.frame(x = h5f@f$nodes[1,],y = h5f@f$nodes[2,] , solution = h5f@f$solution[1,])</div><div class="line">plt &lt;- ggplot(colordata,aes(x=x,y=y,fill=solution))</div><div class="line">plt &lt;- plt + geom_raster(interpolate=TRUE)</div><div class="line">plt &lt;- plt + scale_fill_viridis()</div><div class="line">plt &lt;- plt + ggtitle(paste(&quot;solution at refinement level #&quot;,refinement))</div><div class="line"></div><div class="line">print(plt)</div><div class="line">dev.off()</div><div class="line">H5Fclose(h5f) # Close the HDF5 file</div></div><!-- fragment --><p> This is now going to look as follows: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.pseudocolor_5.png" alt="Solution after 5 refinement steps of step-3"/>
</div>
   </td></tr>
</table>
<p>For plotting the converge curves we need to re-run the C++ code multiple times with different values for <code>n_refinement_steps</code> starting from 1. Since every file only contains a single data point we need to loop over them and concatenate the results into a single vector. </p><div class="fragment"><div class="line">n_ref &lt;- 8   # Maximum refinement level for which results are existing</div><div class="line"></div><div class="line"># First we initiate all vectors with the results of the first level</div><div class="line">h5f   &lt;- H5Fopen(&quot;solution_1.h5&quot;)</div><div class="line">dofs  &lt;- dim(h5f@f$solution)[2]</div><div class="line">mean  &lt;- h5f@f$mean_value</div><div class="line">point &lt;- h5f@f$point_value</div><div class="line">H5Fclose(h5f)</div><div class="line"></div><div class="line">for (reflevel in 2:n_ref)</div><div class="line">{</div><div class="line">   h5f   &lt;- H5Fopen(paste(&quot;solution_&quot;,reflevel,&quot;.h5&quot;,sep=&quot;&quot;))</div><div class="line">   dofs  &lt;- c(dofs,dim(h5f$solution)[2])</div><div class="line">   mean  &lt;- c(mean,h5f$mean_value)</div><div class="line">   point &lt;- c(point,h5f$point_value)</div><div class="line">   H5Fclose(h5f)</div><div class="line">}</div></div><!-- fragment --><p> As we are not interested in the values themselves but rather in the error compared to a "exact" solution we will assume our highest refinement level to be that solution and omit it from the data. </p><div class="fragment"><div class="line"># Calculate the error w.r.t. our maximum refinement step</div><div class="line">mean_error  &lt;- abs(mean[1:n_ref-1]-mean[n_ref])</div><div class="line">point_error &lt;- abs(point[1:n_ref-1]-point[n_ref])</div><div class="line"></div><div class="line"># Remove the highest value from our DoF data</div><div class="line">dofs     &lt;- dofs[1:n_ref-1]</div><div class="line">convdata &lt;- data.frame(dofs = dofs, mean_value= mean_error, point_value = point_error)</div></div><!-- fragment --><p> Now we have all the data available to generate our plots. It is often useful to plot errors on a log-log scale, which is accomplished in the following code: </p><div class="fragment"><div class="line">pdf (paste(<span class="stringliteral">&quot;convergence.pdf&quot;</span>,sep=<span class="stringliteral">&quot;&quot;</span>),width = 5,height = 4.2)</div><div class="line">plt &lt;- ggplot(convdata,mapping=aes(x = dofs, y = mean_value))</div><div class="line">plt &lt;- plt+geom_line()</div><div class="line">plt &lt;- plt+labs(x=&quot;<span class="preprocessor">#DoFs&quot;,y = &quot;mean value error&quot;)</span></div><div class="line">plt &lt;- plt+scale_x_log10()+scale_y_log10()</div><div class="line">print(plt)</div><div class="line"></div><div class="line">plt &lt;- ggplot(convdata,mapping=aes(x = dofs, y = point_value))</div><div class="line">plt &lt;- plt+geom_line()</div><div class="line">plt &lt;- plt+labs(x=&quot;<span class="preprocessor">#DoFs&quot;,y = &quot;point value error&quot;)</span></div><div class="line">plt &lt;- plt+scale_x_log10()+scale_y_log10()</div><div class="line">print(plt)</div><div class="line"></div><div class="line">dev.off()</div></div><!-- fragment --><p> This results in the following plot that shows how the errors in the mean value and the solution value at the chosen point nicely converge to zero: </p><table style="width:50%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.convergence_mean.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.convergence_point.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, 1999,</span></div><div class="line"><span class="comment"> *          Guido Kanschat, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">Step3::Step3()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            1. *                                <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_2.html">step-2</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Thebasicsetupoffiniteelementmethods">The basic set up of
 finite element methods</a><a
 href="#Thebasicsetupoffiniteelementmethods">The basic set up of finite
 element methods</a>
 <li><a href="#Shouldwemultiplybyatestfunctionfromtheleftorfromtheright">
 Should we multiply by a test function from the left or from the right?
 </a><a href="#Shouldwemultiplybyatestfunctionfromtheleftorfromtheright">
 Should we multiply by a test function from the left or from the right? </a>
 <li><a href="#Computingthematrixandrighthandsidevector"> Computing the
 matrix and right hand side vector </a><a
 href="#Computingthematrixandrighthandsidevector"> Computing the matrix and
 right hand side vector </a>
 <li><a href="#Abouttheimplementation">About the implementation</a><a
 href="#Abouttheimplementation">About the implementation</a>
 <li><a href="#Anoteontypes"> A note on types </a><a href="#Anoteontypes"> A
 note on types </a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Manynewincludefiles">Many new include files</a><a
 href="#Manynewincludefiles">Many new include files</a>
 <li><a href="#ThecodeStep3codeclass">The <code>Step3</code> class</a><a
 href="#ThecodeStep3codeclass">The <code>Step3</code> class</a>
 <ul>
 <li><a href="#Step3Step3">Step3::Step3</a><a
 href="#Step3Step3">Step3::Step3</a>
 <li><a href="#Step3make_grid">Step3::make_grid</a><a
 href="#Step3make_grid">Step3::make_grid</a>
 <li><a href="#Step3setup_system">Step3::setup_system</a><a
 href="#Step3setup_system">Step3::setup_system</a>
 <li><a href="#Step3assemble_system">Step3::assemble_system</a><a
 href="#Step3assemble_system">Step3::assemble_system</a>
 <li><a href="#Step3solve">Step3::solve</a><a
 href="#Step3solve">Step3::solve</a>
 <li><a href="#Step3output_results">Step3::output_results</a><a
 href="#Step3output_results">Step3::output_results</a>
 <li><a href="#Step3run">Step3::run</a><a href="#Step3run">Step3::run</a>
 </ul>
 <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a
 href="#Thecodemaincodefunction">The <code>main</code> function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 <li><a href="#UsingHDF5tooutputthesolutionandadditionaldata">Using HDF5 to
 output the solution and additional data</a><a
 href="#UsingHDF5tooutputthesolutionandadditionaldata">Using HDF5 to output
 the solution and additional data</a>
 <ul>
 <li><a href="#Changingtheoutputtoh5"> Changing the output to .h5</a><a
 href="#Changingtheoutputtoh5"> Changing the output to .h5</a>
 <li><a href="#Addingthepointvalueandthemeanseeextensionaboveintotheh5file">
 Adding the point value and the mean (see extension above) into the .h5
 file</a><a
 href="#Addingthepointvalueandthemeanseeextensionaboveintotheh5file"> Adding
 the point value and the mean (see extension above) into the .h5 file</a>
 </ul>
 <li><a href="#UsingRandggplot2togenerateplots"> Using R and ggplot2 to
 generate plots</a><a href="#UsingRandggplot2togenerateplots"> Using R and
 ggplot2 to generate plots</a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.10.html">video lecture 10</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) <a class="anchor" id="Thebasicsetupoffiniteelementmethods"></a><h3>The basic set up of finite element methods</h3>
</dd></dl>
<p>This is the first example where we actually use finite elements to computesomething. Wewill solve a simple version of Poisson's equation with zero boundaryvalues, but a nonzero right hand side: </p><p class="formulaDsp">
\begin{align*} -\Delta u &amp;= f \qquad\qquad &amp; \text{in}\ \Omega, \\ u &amp;= 0 \qquad\qquad &amp; \text{on}\ \partial\Omega. \end{align*}
</p>
<p> We will solve this equation on the square, \(\Omega=[-1,1]^2\) , for whichyou've already learned how to generate a mesh in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a> . Inthis program, we will also only consider the particular case \(f(\mathbf x)=1\) and come back to how to implement the more generalcase in the next tutorial program, <a class="el" href="step_4.html">step-4</a> . If you've learned about the basics of the finite element method, you willremember the steps we need to take to approximate the solution \(u\) by a finitedimensional approximation. Specifically, we first need to derive the weak formof the equation above, which we obtain by multiplying the equation by a testfunction \(\varphi\) <em>from the left</em> (we will come back to the reason formultiplying from the left and not from the right below) and integrating overthe domain \(\Omega\) : </p><p class="formulaDsp">
\begin{align*} -\int_\Omega \varphi \Delta u = \int_\Omega \varphi f. \end{align*}
</p>
<p> This can be integrated by parts: </p><p class="formulaDsp">
\begin{align*} \int_\Omega \nabla\varphi \cdot \nabla u - \int_{\partial\Omega} \varphi \mathbf{n}\cdot \nabla u = \int_\Omega \varphi f. \end{align*}
</p>
<p> The test function \(\varphi\) has to satisfy the same kind of boundaryconditions (in mathematical terms: it needs to come from the tangent space ofthe set in which we seek the solution), so on the boundary \(\varphi=0\) andconsequently the weak form we are looking for reads </p><p class="formulaDsp">
\begin{align*} (\nabla\varphi, \nabla u) = (\varphi, f), \end{align*}
</p>
<p> where we have used the common notation \((a,b)=\int_\Omega a\; b\) . The problemthen asks for a function \(u\) for which this statement is true for all testfunctions \(\varphi\) from the appropriate space (which here is the space \(H^1\) ). Of course we can't find such a function on a computer in the general case, andinstead we seek an approximation \(u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) , where the \(U_j\) are unknown expansion coefficients we need to determine(the "degrees of
 freedom" of this problem), and \(\varphi_i(\mathbf x)\) are thefinite element shape functions we will use. To define these shape functions,we need the following:</p>
<ul>
<li>A mesh on which to define shape functions. You have already seen how to generate and manipulate the objects that describe meshes in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a> .</li>
<li>A finite element that describes the shape functions we want to use on the reference cell (which in deal.II is always the unit interval \([0,1]\) , the unit square \([0,1]^2\) or the unit cube \([0,1]^3\) , depending on which space dimension you work in). In <a class="el" href="step_2.html">step-2</a> , we had already used an object of type FE_Q&lt;2&gt;, which denotes the usual Lagrange elements that define shape functions by interpolation on support points. The simplest one is FE_Q&lt;2&gt;(1), which uses polynomial degree 1. In 2d, these are often referred to as <em>bilinear</em>, since they are linear in each of the two coordinates of the reference cell. (In 1d, they would be <em>linear</em> and in 3d <em>tri-linear</em>; however, in the deal.II documentation, we will frequently not make this distinction and simply always call these functions "linear".)</li>
<li>A <a class="el" href="classDoFHandler.html">DoFHandler</a> object that enumerates all the degrees of freedom on the mesh, taking the reference cell description the finite element object provides as the basis. You've also already seen how to do this in <a class="el" href="step_2.html">step-2</a> .</li>
<li>A mapping that tells how the shape functions on the real cell are obtained from the shape functions defined by the finite element class on the reference cell. By default, unless you explicitly say otherwise, deal.II will use a (bi-, tri-)linear mapping for this, so in most cases you don't have to worry about this step. Through these steps, we now have a set of functions \(\varphi_i\) , and we candefine the weak form of the discrete problem: Find a function \(u_h\) , i.e., findthe expansion coefficients \(U_j\) mentioned above, so that <p class="formulaDsp">
\begin{align*} (\nabla\varphi_i, \nabla u_h) = (\varphi_i, f), \qquad\qquad i=0\ldots N-1. \end{align*}
</p>
 Note that we here follow the convention that everything is counted starting atzero, as common in C and C++. This equation can be rewritten as a linearsystem if you insert the representation \(u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) and then observe that <p class="formulaDsp">
\begin{align*} (\nabla\varphi_i, \nabla u_h) &amp;= \left(\nabla\varphi_i, \nabla \Bigl[\sum_j U_j \varphi_j\Bigr]\right) \\ &amp;= \sum_j \left(\nabla\varphi_i, \nabla \left[U_j \varphi_j\right]\right) \\ &amp;= \sum_j \left(\nabla\varphi_i, \nabla \varphi_j \right) U_j. \end{align*}
</p>
 With this, the problem reads: Find a vector \(U\) so that <p class="formulaDsp">
\begin{align*} A U = F, \end{align*}
</p>
 where the matrix \(A\) and the right hand side \(F\) are defined as <p class="formulaDsp">
\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j), \\ F_i &amp;= (\varphi_i, f). \end{align*}
</p>
</li>
</ul>
<p><a class="anchor" id="Shouldwemultiplybyatestfunctionfromtheleftorfromtheright"></a></p><h3>Should we multiply by a test function from the left or from the right? </h3>
<p>Before we move on with describing how these quantities can be computed, notethat if we had multiplied the original equation from the <em>right</em> by atest function rather than from the left, then we would have obtained a linearsystem of the form </p><p class="formulaDsp">
\begin{align*} U^T A = F^T \end{align*}
</p>
<p> with a row vector \(F^T\) . By transposing this system, this is of courseequivalent to solving </p><p class="formulaDsp">
\begin{align*} A^T U = F \end{align*}
</p>
<p> which here is the same as above since \(A=A^T\) . But in general is not,and in order to avoidany sort of confusion, experience has shown that simply getting into the habitof multiplying the equation from the left rather than from the right (as isoften done in the mathematical literature) avoids a common class of errors asthe matrix is automatically correct and does not need to be transposed whencomparing theory and implementation. See <a class="el" href="step_9.html">step-9</a> for the first example in thistutorial where we have a non-symmetric bilinear form for which it makes adifference whether we multiply from the right or from the left.</p>
<p><a class="anchor" id="Computingthematrixandrighthandsidevector"></a></p><h3>Computing the matrix and right hand side vector </h3>
<p>Now we know what we need (namely: objects that hold the matrix andvectors, as well as ways to compute \(A_{ij},F_i\) ), and we can look at what ittakes to make that happen:</p>
<ul>
<li>The object for \(A\) is of type <a class="el" href="classSparseMatrix.html">SparseMatrix</a> while those for \(U\) and \(F\) are of type <a class="el" href="classVector.html">Vector</a>. We will see in the program below what classes are used to solve linear systems.</li>
<li>We need a way to form the integrals. In the finite element method, this is most commonly done using quadrature, i.e. the integrals are replaced by a weighted sum over a set of points on each cell. That is, we first split the integral over \(\Omega\) into integrals over all cells, <p class="formulaDsp">
\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j) = \sum_{K \in {\mathbb T}} \int_K \nabla\varphi_i \cdot \nabla \varphi_j, \\ F_i &amp;= (\varphi_i, f) = \sum_{K \in {\mathbb T}} \int_K \varphi_i f, \end{align*}
</p>
 and then approximate each cell's contribution by quadrature: <p class="formulaDsp">
\begin{align*} A^K_{ij} &amp;= \int_K \nabla\varphi_i \cdot \nabla \varphi_j \approx \sum_q \nabla\varphi_i(\mathbf x^K_q) \cdot \nabla \varphi_j(\mathbf x^K_q) w_q^K, \\ F^K_i &amp;= \int_K \varphi_i f \approx \sum_q \varphi_i(\mathbf x^K_q) f(\mathbf x^K_q) w^K_q, \end{align*}
</p>
 where \(\mathbf x^K_q\) is the \(q\) th quadrature point on cell \(K\) , and \(w^K_q\) the \(q\) th quadrature weight. There are different parts to what is needed in doing this, and we will discuss them in turn next.</li>
<li>First, we need a way to describe the location \(\mathbf x_q^K\) of quadrature points and their weights \(w^K_q\) . They are usually mapped from the reference cell in the same way as shape functions, i.e., implicitly using the <a class="el" href="classMappingQ1.html">MappingQ1</a> class or, if you explicitly say so, through one of the other classes derived from <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>. The locations and weights on the reference cell are described by objects derived from the <a class="el" href="classQuadrature.html">Quadrature</a> base class. Typically, one chooses a quadrature formula (i.e. a set of points and weights) so that the quadrature exactly equals the integral in the matrix; this can be achieved because all factors in the integral are polynomial, and is done by Gaussian quadrature formulas, implemented in the <a class="el" href="classQGauss.html">QGauss</a> class.</li>
<li>We then need something that can help us evaluate \(\varphi_i(\mathbf x^K_q)\) on cell \(K\) . This is what the <a class="el" href="classFEValues.html">FEValues</a> class does: it takes a finite element objects to describe \(\varphi\) on the reference cell, a quadrature object to describe the quadrature points and weights, and a mapping object (or implicitly takes the <a class="el" href="classMappingQ1.html">MappingQ1</a> class) and provides values and derivatives of the shape functions on the real cell \(K\) as well as all sorts of other information needed for integration, at the quadrature points located on \(K\) . <a class="el" href="classFEValues.html">FEValues</a> really is the central class in the assembly process. One way you canview it is as follows: The <a class="el" href="classFiniteElement.html">FiniteElement</a> and derived classes describe shape<em>functions</em>, i.e., infinite dimensional objects: functions have values atevery point. We need this for theoretical reasons because we want to performour analysis with integrals over functions. However, for a computer, this is avery difficult concept, since they can in general only deal with a finiteamount of information, and so we replace integrals by sums over quadraturepoints that we obtain by mapping (the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> object) using points defined ona reference cell (the <a class="el" href="classQuadrature.html">Quadrature</a> object) onto points on the real cell. Inessence, we reduce the problem to one where we only need a finite amount ofinformation, namely shape function values and derivatives, quadrature weights,normal vectors, etc, exclusively at a finite set of points. The <a class="el" href="classFEValues.html">FEValues</a> classis the one that brings the three components together and provides this finiteset of information on a particular cell \(K\) . You will see it in action when weassemble the linear system below. It is noteworthy that all of this could also be achieved if you simply createdthese three objects yourself in an application program, and juggled theinformation yourself. However, this would neither be simpler (the FEValuesclass provides exactly the kind of information you actually need) nor faster:the <a class="el" href="classFEValues.html">FEValues</a> class is highly optimized to only compute on each cell theparticular information you need; if anything can be re-used from the previouscell, then it will do so, and there is a lot of code in that class to makesure things are cached wherever this is advantageous. The final piece of this introduction is to mention that after a linearsystem is obtained, it is solved using an iterative solver and thenpostprocessed: we create an output file using the <a class="el" href="classDataOut.html">DataOut</a> class that can thenbe visualized using one of the common visualization programs. <dl class="section note"><dt>Note</dt><dd>The preceding overview of all the important steps of any finite elementimplementation has its counterpart in deal.II: The library can naturally begrouped into a number of "modules" that cover the basic concepts justoutlined. You can access these modules through the tab at the top of thispage. An overview of the most fundamental groups of concepts is also availableon the <a href="index.html">front page of the deal.II manual</a>.</dd></dl>
<a class="anchor" id="Abouttheimplementation"></a><h3>About the implementation</h3>
</li>
</ul>
<p>Although this is the simplest possible equation you can solve using the finiteelement method, this program shows the basic structure of most finiteelement programs and also serves as the template that almost all of thefollowing programs will essentially follow. Specifically, the main class ofthis program looks like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> Step3 ();</div><div class="line"> <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keywordtype">void</span> make_grid ();</div><div class="line"> <span class="keywordtype">void</span> setup_system ();</div><div class="line"> <span class="keywordtype">void</span> assemble_system ();</div><div class="line"> <span class="keywordtype">void</span> solve ();</div><div class="line"> <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line"> <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>     <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>              fe;</div><div class="line"> <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>        dof_handler;</div><div class="line"></div><div class="line"> <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line"> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line"> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>This follows the object oriented programming mantra of <a href="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)">data encapsulation</a>, i.e. we do our best to hide almost all internal details ofthis class in private members that are not accessible to the outside. Let's start with the member variables: These follow the building blocks wehave outlined above in the bullet points, namely we need a <a class="el" href="classTriangulation.html">Triangulation</a> and aDoFHandler object, and a finite element object that describes the kinds ofshape functions we want to use. The second group of objects relate to thelinear algebra: the system matrix and right hand side as well as the solutionvector, and an object that describes the sparsity pattern of the matrix. Thisis all this class needs (and the essentials that any solver for a stationaryPDE requires) and that needs to survive throughout the entire program. Incontrast to this, the <a class="el" href="classFEValues.html">FEValues</a> object we need for assembly is only requiredthroughout assembly, and so we create it as a local object in the functionthat does that and destroy it again at its end. Secondly, let's look at the member functions. These, as well, already form thecommon structure that almost all following tutorial programs will use: </p><ul>
<li>
<code>make_grid()</code> : This is what one could call a <em>preprocessing function</em>. As its name suggests, it sets up the object that stores the triangulation. In later examples, it could also deal with boundary conditions, geometries, etc. </li>
<li>
<code>setup_system()</code> : This then is the function in which all the other data structures are set up that are needed to solve the problem. In particular, it will initialize the <a class="el" href="classDoFHandler.html">DoFHandler</a> object and correctly size the various objects that have to do with the linear algebra. This function is often separated from the preprocessing function above because, in a time dependent program, it may be called at least every few time steps whenever the mesh is adaptively refined (something we will see how to do in <a class="el" href="step_6.html">step-6</a> ). On the other hand, setting up the mesh itself in the preprocessing function above is done only once at the beginning of the program and is, therefore, separated into its own function. </li>
<li>
<code>assemble_system()</code> : This, then is where the contents of the matrix and right hand side are computed, as discussed at length in the introduction above. Since doing something with this linear system is conceptually very different from computing its entries, we separate it from the following function. </li>
<li>
<code>solve()</code> : This then is the function in which we compute the solution \(U\) of the linear system \(AU=F\) . In the current program, this is a simple task since the matrix is so simple, but it will become a significant part of a program's size whenever the problem is not so trivial any more (see, for example, <a class="el" href="step_20.html">step-20</a> , <a class="el" href="step_22.html">step-22</a> , or <a class="el" href="step_31.html">step-31</a> once you've learned a bit more about the library). </li>
<li>
<code>output_results()</code> : Finally, when you have computed a solution, you probably want to do something with it. For example, you may want to output it in a format that can be visualized, or you may want to compute quantities you are interested in: say, heat fluxes in a heat exchanger, air friction coefficients of a wing, maximum bridge loads, or simply the value of the numerical solution at a point. This function is therefore the place for postprocessing your solution. </li>
</ul>
<p>All of this is held together by the single public function (other than theconstructor), namely the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function. It is the one that iscalled from the place where an object of this type is created, and it is theone that calls all the other functions in their proper order. Encapsulatingthis operation into the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function, rather than calling allthe other functions from <code>main()</code> makes sure that youcan change how the separation of concerns within this class isimplemented. For example, if one of the functions becomes too big, you cansplit it up into two, and the only places you have to be concerned aboutchanging as a consequence are within this very same class, and not anywhereelse. As mentioned above, you will see this general structure &mdash; sometimes withvariants in spelling of the functions' names, but in essentially this order ofseparation of functionality &mdash; again in many of thefollowing tutorial programs.</p>
<p><a class="anchor" id="Anoteontypes"></a></p><h3>A note on types </h3>
<p>deal.II defines a number of integral types via alias in namespace <a class="el" href="namespacetypes.html">types</a>. (In the previous sentence, the word "integral" is used as the <em>adjective</em>that corresponds to the noun "integer". It shouldn't be confused with the<em>noun</em> "integral" that represents the area or volume under a curveor surface. The adjective "integral" is widely used in the C++ world incontexts such as "integral type", "integral constant", etc.)In particular, in this program you will see <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> in a couple ofplaces: an integer type that is used to denote the <em>global</em> index of adegree of freedom, i.e., the index of a particular degree of freedom within theDoFHandler object that is defined on top of a triangulation (as opposed to theindex of a particular degree of freedom within a particular cell). For thecurrent program (as well as almost all of the tutorial programs), you will havea few thousand to maybe a few million unknowns globally (and, for \(Q_1\) elements, you will have 4 <em>locally on each cell</em> in 2d and 8 in 3d).Consequently, a data type that allows to store sufficiently large numbers forglobal DoF indices is <code>unsigned int</code> given that it allows to storenumbers between 0 and slightly more than 4 billion (on most systems, whereintegers are 32-bit). In fact, this is what <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> is. So, why not just use <code>unsigned int</code> right away? deal.II used to dothis until version 7.3. However, deal.II supports very large computations (viathe framework discussed in <a class="el" href="step_40.html">step-40</a> ) that may have more than 4 billion unknownswhen spread across a few thousand processors. Consequently, there aresituations where <code>unsigned int</code> is not sufficiently large and weneed a 64-bit unsigned integral type. To make this possible, we introduced <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> which by default is defined as simply <code>unsignedint</code> whereas it is possible to define it as <code>unsigned long longint</code> if necessary, by passing a particular flag during configuration(see the ReadMe file). This covers the technical aspect. But there is also a documentation purpose:everywhere in the library and codes that are built on it, if you see a placeusing the data type <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, you immediately know that thequantity that is being referenced is, in fact, a global dof index. No suchmeaning would be apparent if we had just used <code>unsigned int</code> (whichmay also be a local index, a boundary indicator, a material id,etc.). Immediately knowing what a variable refers to also helps avoid errors:it's quite clear that there must be a bug if you see an object of type <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> being assigned to variable of type <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, even though they are both represented by unsignedintegers and the compiler will, consequently, not complain. In more practical terms what the presence of this type means is that duringassembly, we create a \(4\times 4\) matrix (in 2d, using a \(Q_1\) element) of thecontributions of the cell we are currently sitting on, and then we need to addthe elements of this matrix to the appropriate elements of the global (system)matrix. For this, we need to get at the global indices of the degrees offreedom that are local to the current cell, for which we will always use thefollowing piece of the code: </p><div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p> where <code>local_dof_indices</code> is declared as </p><div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p> The name of this variable might be a bit of a misnomer</p>
<ul>
<li>it stands for "theglobal indices of those degrees of freedom locally defined on the currentcell"</li>
<li>but variables that hold this information are universally named thisway throughout the library. <dl class="section note"><dt>Note</dt><dd><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> is not the only type defined in this namespace.Rather, there is a whole family, including <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, and <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>. All of these are alias for integerdata types but, as explained above, they are used throughout the library so that(i) the intent of a variable becomes more easily discerned, and (ii) so that itbecomes possible to change the actual type to a larger one if necessary withouthaving to go through the entire library and figure out whether a particular useof <code>unsigned int</code> corresponds to, say, a material indicator.</dd></dl>
<a class="anchor" id="CommProg"></a> <h1>The commented program</h1>
</li>
</ul>
<p><a class="anchor" id="Manynewincludefiles"></a> </p><h3>Many new include files</h3>
<p>These include files are already known to you. They declare the classes which handle triangulations and enumeration of degrees of freedom:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div></div><!-- fragment --><p>And this is the file in which the functions are declared that create grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>This file contains the description of the Lagrange interpolation finite element:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>And this file is needed for the creation of sparsity patterns of sparse matrices, as shown in previous examples:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The next two files are needed for assembling the matrix using quadrature on each cell. The classes declared in them will be explained below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div></div><!-- fragment --><p>The following three include files we need for the treatment of boundary values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>We're now almost to the end. The second to last group of include files is for the linear algebra which we employ to solve the system of equations arising from the finite element discretization of the Laplace equation. We will use vectors and full matrices for assembling the system of equations locally on each cell, and transfer the results into a sparse matrix. We will then use a Conjugate Gradient solver to solve the problem, for which we need a preconditioner (in this program, we use the identity preconditioner which does nothing, but we need to include the file anyway):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, this is for output to a file and to the console:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>...and this is to import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep3codeclass"></a> </p><h3>The <code>Step3</code> class</h3>
<p>Instead of the procedural programming of previous examples, we encapsulate everything into a class for this program. The class consists of functions which each perform certain aspects of a finite element program, a <code>main</code> function which controls what is done first and what is done next, and a list of member variables.</p>
<p>The public part of the class is rather short: it has a constructor and a function <code>run</code> that is called from the outside and acts as something like the <code>main</code> function: it coordinates which operations of this class shall be run in which order. Everything else in the class, i.e. all the functions that actually do anything, are in the private section of the class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">Step3();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div></div><!-- fragment --><p>Then there are the member functions that mostly do what their names suggest and whose have been discussed in the introduction already. Since they do not need to be called from outside, they are made private to this class.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line"><span class="keywordtype">void</span> make_grid();</div><div class="line"><span class="keywordtype">void</span> setup_system();</div><div class="line"><span class="keywordtype">void</span> assemble_system();</div><div class="line"><span class="keywordtype">void</span> solve();</div><div class="line"><span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>And finally we have some member variables. There are variables describing the triangulation and the global numbering of the degrees of freedom (we will specify the exact polynomial degree of the finite element in the constructor of this class)...</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>          fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>    dof_handler;</div></div><!-- fragment --><p>...variables for the sparsity pattern and values of the system matrix resulting from the discretization of the Laplace equation...</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>...and variables which will hold the right hand side and solution vectors.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Step3Step3"></a> </p><h4>Step3::Step3</h4>
<p>Here comes the constructor. It does not much more than first to specify that we want bi-linear elements (denoted by the parameter to the finite element object, which indicates the polynomial degree), and to associate the dof_handler variable to the triangulation we use. (Note that the triangulation isn't set up with a mesh at all at the present time, but the <a class="el" href="classDoFHandler.html">DoFHandler</a> doesn't care: it only wants to know which triangulation it will be associated with, and it only starts to care about an actual mesh once you try to distribute degree of freedom on the mesh using the distribute_dofs() function.) All the other member variables of the Step3 class have a default constructor which does all we want.</p>
<div class="fragment"><div class="line">Step3::Step3()</div><div class="line">: fe(1)</div><div class="line">, dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step3make_grid"></a> </p><h4>Step3::make_grid</h4>
<p>Now, the first thing we've got to do is to generate the triangulation on which we would like to do our computation and number each vertex with a degree of freedom. We have seen these two steps in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a> before, respectively.</p>
<p>This function does the first part, creating the mesh. We create the grid and refine all cells five times. Since the initial grid (which is the square \([-1,1] \times [-1,1]\) ) consists of only one cell, the final grid has 32 times 32 cells, for a total of 1024.</p>
<p>Unsure that 1024 is the correct number? We can check that by outputting the number of cells using the <code><a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells()</a></code> function on the triangulation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation,</div><div class="line"></div><div class="line">-1, 1);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We call the <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> function, rather than <a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">Triangulation::n_cells()</a>. Here, <em>active</em> means the cells that aren't refined any further. We stress the adjective "active" since there are more cells, namely the parent cells of the finest cells, their parents, etc, up to the one cell which made up the initial grid. Of course, on the next coarser level, the number of cells is one quarter that of the cells on the finest level, i.e. 256, then 64, 16, 4, and 1. If you called <code><a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">triangulation.n_cells()</a></code> instead in the code above, you would consequently get a value of 1365 instead. On the other hand, the number of cells (as opposed to the number of active cells) is not typically of much interest, so there is no good reason to print it.</dd></dl>
<p><a class="anchor" id="Step3setup_system"></a> </p><h4>Step3::setup_system</h4>
<p>Next we enumerate all the degrees of freedom and set up matrix and vector objects to hold the system data. Enumerating is done by using <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>, as we have seen in the <a class="el" href="step_2.html">step-2</a> example. Since we use the <a class="el" href="classFE__Q.html">FE_Q</a> class and have set the polynomial degree to 1 in the constructor, i.e. bilinear elements, this associates one degree of freedom with each vertex. While we're at generating output, let us also take a look at how many degrees of freedom are generated:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>There should be one DoF for each vertex. Since we have a 32 times 32 grid, the number of DoFs should be 33 times 33, or 1089.</p>
<p>As we have seen in the previous example, we set up a sparsity pattern by first creating a temporary structure, tagging those entries that might be nonzero, and then copying the data over to the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object that can then be used by the system matrix.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div></div><!-- fragment --><p>Note that the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object does not hold the values of the matrix, it only stores the places where entries are. The entries themselves are stored in objects of type <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, of which our variable system_matrix is one. The distinction between sparsity pattern and matrix was made to allow several matrices to use the same sparsity pattern. This may not seem relevant here, but when you consider the size which matrices can have, and that it may take some time to build the sparsity pattern, this becomes important in large-scale problems if you have to store several matrices in your program.</p>
<div class="fragment"><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The last thing to do in this function is to set the sizes of the right hand side vector and the solution vector to the right values:</p>
<div class="fragment"><div class="line">solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3assemble_system"></a> </p><h4>Step3::assemble_system</h4>
<p>The next step is to compute the entries of the matrix and right hand side that form the linear system from which we compute the solution. This is the central function of each finite element program and we have discussed the primary steps in the introduction already.</p>
<p>The general approach to assemble matrices and vectors is to loop over all cells, and on each cell compute the contribution of that cell to the global matrix and right hand side by quadrature. The point to realize now is that we need the values of the shape functions at the locations of quadrature points on the real cell. However, both the finite element shape functions as well as the quadrature points are only defined on the reference cell. They are therefore of little help to us, and we will in fact hardly ever query information about finite element shape functions or quadrature points from these objects directly.</p>
<p>Rather, what is required is a way to map this data from the reference cell to the real cell. Classes that can do that are derived from the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> class, though one again often does not have to deal with them directly: many functions in the library can take a mapping object as argument, but when it is omitted they simply resort to the standard bilinear Q1 mapping. We will go this route, and not bother with it for the moment (we come back to this in <a class="el" href="step_10.html">step-10</a> , <a class="el" href="step_11.html">step-11</a> , and <a class="el" href="step_12.html">step-12</a> ).</p>
<p>So what we now have is a collection of three classes to deal with: finite element, quadrature, and mapping objects. That's too much, so there is one type of class that orchestrates information exchange between these three: the <a class="el" href="classFEValues.html">FEValues</a> class. If given one instance of each three of these objects (or two, and an implicit linear mapping), it will be able to provide you with information about values and gradients of shape functions at quadrature points on a real cell.</p>
<p>Using all this, we will assemble the linear system for this problem in the following function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div></div><!-- fragment --><p>Ok, let's start: we need a quadrature formula for the evaluation of the integrals on each cell. Let's take a Gauss formula with two quadrature points in each direction, i.e. a total of four points since we are in 2D. This quadrature formula integrates polynomials of degrees up to three exactly (in 1D). It is easy to check that this is sufficient for the present problem:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div></div><!-- fragment --><p>And we initialize the object which we have briefly talked about above. It needs to be told which finite element we want to use, and the quadrature points and their weights (jointly described by a <a class="el" href="classQuadrature.html">Quadrature</a> object). As mentioned, we use the implied Q1 mapping, rather than specifying one ourselves explicitly. Finally, we have to tell it what we want it to compute on each cell: we need the values of the shape functions at the quadrature points (for the right hand side \((\varphi_i,f)\) ), their gradients (for the matrix entries \((\nabla \varphi_i, \nabla \varphi_j)\) ), and also the weights of the quadrature points and the determinants of the Jacobian transformations from the reference cell to the real cells. This list of what kind of information we actually need is given as a collection of flags as the third argument to the constructor of <a class="el" href="classFEValues.html">FEValues</a>. Since these values have to be recomputed, or updated, every time we go to a new cell, all of these flags start with the prefix <code>update_</code> and then indicate what it actually is that we want updated. The flag to give if we want the values of the shape functions computed is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea" title="Shape function values. ">update_values</a>; for the gradients it is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20" title="Shape function gradients. ">update_gradients</a>. The determinants of the Jacobians and the quadrature weights are always used together, so only the products (Jacobians times weights, or short <code>JxW</code> ) are computed; since we need them, we have to list <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85" title="Transformed quadrature weights. ">update_JxW_values</a> as well:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                      quadrature_formula,</div><div class="line">                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>The advantage of this approach is that we can specify what kind of information we actually need on each cell. It is easily understandable that this approach can significantly speed up finite element computations, compared to approaches where everything, including second derivatives, normal vectors to cells, etc are computed on each cell, regardless of whether they are needed or not.</p>
<dl class="section note"><dt>Note</dt><dd>The syntax <code>update_values | update_gradients | update_JxW_values</code> is not immediately obvious to anyone not used to programming bit operations in C for years already. First, <code>operator|</code> is the <em>bitwise or operator</em>, i.e., it takes two integer arguments that are interpreted as bit patterns and returns an integer in which every bit is set for which the corresponding bit is set in at least one of the two arguments. For example, consider the operation <code>9|10</code>. In binary, <code>9=0b1001</code> (where the prefix <code>0b</code> indicates that the number is to be interpreted as a binary number) and <code>10=0b1010</code> . Going through each bit and seeing whether it is set in one of the argument, we arrive at <code>0b1001|0b1010=0b1011</code> or, in decimal notation, <code>9|10=11</code> . The second piece of information you need to know is that the various <code>update_*</code> flags are all integers that have <em>exactly one bit set</em>. For example, assume that <code>update_values=0b00001=1</code> , <code>update_gradients=0b00010=2</code> , <code>update_JxW_values=0b10000=16</code> . Then <code>update_values | update_gradients | update_JxW_values = 0b10011 = 19</code>. In other words, we obtain a number that <em>encodes a binary mask representing all of the operations you want to happen</em>, where each operation corresponds to exactly one bit in the integer that, if equal to one, means that a particular piece should be updated on each cell and, if it is zero, means that we need not compute it. In other words, even though <code>operator|</code> is the <em>bitwise OR operation</em>, what it really represents is <em>I want this AND that AND the other</em>. Such binary masks are quite common in C programming, but maybe not so in higher level languages like C++, but serve the current purpose quite well.</dd></dl>
<p>For use further down below, we define a shortcut for a value that will be used very frequently. Namely, an abbreviation for the number of degrees of freedom on each cell (since we are in 2D and degrees of freedom are associated with vertices only, this number is four, but we rather want to write the definition of this variable in a way that does not preclude us from later choosing a different finite element that has a different number of degrees of freedom per cell, or work in a different space dimension). In general, it is a good idea to use a symbolic name instead of hard-coding these numbers even if you know them, since for example, you may want to change the finite element at some time. Changing the element would have to be done in a different function and it is easy to forget to make a corresponding change in another part of the program. It is better to not rely on your own calculations, but instead ask the right object for the information: Here, we ask the finite element to tell us about the number of degrees of freedom per cell and we will get the correct number regardless of the space dimension or polynomial degree we may have chosen elsewhere in the program. The shortcut here, defined primarily to discuss the basic concept and not because it saves a lot of typing, will then make the following loops a bit more readable. You will see such shortcuts in many places in larger programs, and <code>dofs_per_cell</code> is one that is more or less the conventional name for this kind of object.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div></div><!-- fragment --><p>Now, we said that we wanted to assemble the global matrix and vector cell-by-cell. We could write the results directly into the global matrix, but this is not very efficient since access to the elements of a sparse matrix is slow. Rather, we first compute the contribution of each cell in a small matrix with the degrees of freedom on the present cell, and only transfer them to the global matrix when the computations are finished for this cell. We do the same for the right hand side vector. So let's first allocate these objects (these being local objects, all degrees of freedom are coupling with all others, and we should use a full matrix object rather than a sparse one for the local operations; everything will be transferred to a global sparse matrix later on):</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div></div><!-- fragment --><p>When assembling the contributions of each cell, we do this with the local numbering of the degrees of freedom (i.e. the number running from zero through dofs_per_cell-1). However, when we transfer the result into the global matrix, we have to know the global numbers of the degrees of freedom. When we query them, we need a scratch (temporary) array for these numbers (see the discussion at the end of the introduction for the type, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, used here):</p>
<div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Now for the loop over all cells. We have seen before how this works for a triangulation. A <a class="el" href="classDoFHandler.html">DoFHandler</a> has cell iterators that are exactly analogous to those of a <a class="el" href="classTriangulation.html">Triangulation</a>, but with extra information about the degrees of freedom for the finite element you're using. Looping over the active cells of a degree-of-freedom handler works the same as for a triangulation. Note that we declare the type of the cell as <code>const auto &amp;</code> instead of <code>auto</code> this time around. In step 1, we were modifying the cells of the triangulation by flagging them with refinement indicators. Here we're only examining the cells without modifying them, so it's good practice to declare <code>cell</code> as <code>const</code> in order to enforce this invariant.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We are now sitting on one cell, and we would like the values and gradients of the shape functions be computed, as well as the determinants of the Jacobian matrices of the mapping between reference cell and true cell, at the quadrature points. Since all these values depend on the geometry of the cell, we have to have the <a class="el" href="classFEValues.html">FEValues</a> object re-compute them on each cell:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div></div><!-- fragment --><p>Next, reset the local cell's contributions to global matrix and global right hand side to zero, before we fill them:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">cell_rhs    = 0;</div></div><!-- fragment --><p>Now it is time to start integration over the cell, which we do by looping over all quadrature points, which we will number by q_index.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>First assemble the matrix: For the Laplace problem, the matrix on each cell is the integral over the gradients of shape function i and j. Since we do not integrate, but rather use quadrature, this is the sum over all quadrature points of the integrands times the determinant of the Jacobian matrix at the quadrature point times the weight of this quadrature point. You can get the gradient of shape function \(i\) at quadrature point with number q_index by using <code>fe_values.shape_grad(i,q_index)</code> ; this gradient is a 2-dimensional vector (in fact it is of type <a class="el" href="classTensor.html">Tensor</a> &lt;1,dim&gt;, with here dim=2) and the product of two such vectors is the scalar product, i.e. the product of the two shape_grad function calls is the dot product. This is in turn multiplied by the Jacobian determinant and the quadrature point weight (that one gets together by the call to <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a> ). Finally, this is repeated for all shape functions \(i\) and \(j\) :</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) <span class="comment">// grad phi_i(x_q)</span></div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) <span class="comment">// grad phi_j(x_q)</span></div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div></div><!-- fragment --><p>We then do the same thing for the right hand side. Here, the integral is over the shape function i times the right hand side function, which we choose to be the function with constant value one (more interesting examples will be considered in the following programs).</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) <span class="comment">// phi_i(x_q)</span></div><div class="line">                    1.                                <span class="comment">// f(x_q)</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">}</div></div><!-- fragment --><p>Now that we have the contribution of this cell, we have to transfer it to the global matrix and right hand side. To this end, we first have to find out which global numbers the degrees of freedom on this cell have. Let's simply ask the cell for that information:</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>Then again loop over all shape functions i and j and transfer the local elements to the global matrix. The global numbers can be obtained using local_dof_indices[i]:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    system_matrix.add(local_dof_indices[i],</div><div class="line">                      local_dof_indices[j],</div><div class="line">                      cell_matrix(i, j));</div></div><!-- fragment --><p>And again, we do the same thing for the right hand side vector.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">}</div></div><!-- fragment --><p>Now almost everything is set up for the solution of the discrete system. However, we have not yet taken care of boundary values (in fact, Laplace's equation without Dirichlet boundary values is not even uniquely solvable, since you can add an arbitrary constant to the discrete solution). We therefore have to do something about the situation. For this, we first obtain a list of the degrees of freedom on the boundary and the value the shape function shall have there. For simplicity, we only interpolate the boundary value function, rather than projecting it onto the boundary. There is a function in the library which does exactly this: <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>. Its parameters are (omitting parameters for which default values exist and that we don't care about): the <a class="el" href="classDoFHandler.html">DoFHandler</a> object to get the global numbers of the degrees of freedom on the boundary; the component of the boundary where the boundary values shall be interpolated; the boundary value function itself; and the output object. The component of the boundary is meant as follows: in many cases, you may want to impose certain boundary values only on parts of the boundary. For example, you may have inflow and outflow boundaries in fluid dynamics, or clamped and free parts of bodies in deformation computations of bodies. Then you will want to denote these different parts of the boundary by indicators, and tell the interpolate_boundary_values function to only compute the boundary values on a certain part of the boundary (e.g. the clamped part, or the inflow boundary). By default, all boundaries have a 0 boundary indicator, unless otherwise specified. If sections of the boundary have different boundary conditions, you have to number those parts with different boundary indicators. The function call below will then only determine boundary values for those parts of the boundary for which the boundary indicator is in fact the zero specified as the second argument. The function describing the boundary values is an object of type <a class="el" href="classFunction.html">Function</a> or of a derived class. One of the derived classes is <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a>, which describes (not unexpectedly) a function which is zero everywhere. We create such an object in-place and pass it to the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function. Finally, the output object is a list of pairs of global degree of freedom numbers (i.e. the number of the degrees of freedom on the boundary) and their boundary values (which are zero here for all entries). This mapping of DoF numbers to boundary values is done by the <code>std::map</code> class.</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                         boundary_values);</div></div><!-- fragment --><p>Now that we got the list of boundary DoFs and their respective boundary values, let's use them to modify the system of equations accordingly. This is done by the following function call:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                   system_matrix,</div><div class="line">                                   solution,</div><div class="line">                                   system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3solve"></a> </p><h4>Step3::solve</h4>
<p>The following function simply solves the discretized equation. As the system is quite a large one for direct solvers such as Gauss elimination or LU decomposition, we use a Conjugate Gradient algorithm. You should remember that the number of variables here (only 1089) is a very small number for finite element computations, where 100.000 is a more usual number. For this number of variables, direct methods are no longer usable and you are forced to use methods like CG.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div></div><!-- fragment --><p>First, we need to have an object that knows how to tell the CG algorithm when to stop. This is done by using a <a class="el" href="classSolverControl.html">SolverControl</a> object, and as stopping criterion we say: stop after a maximum of 1000 iterations (which is far more than is needed for 1089 variables; see the results section to find out how many were really used), and stop if the norm of the residual is below \(10^{-12}\) . In practice, the latter criterion will be the one which stops the iteration:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div></div><!-- fragment --><p>Then we need the solver itself. The template parameter to the <a class="el" href="classSolverCG.html">SolverCG</a> class is the type of the vectors, and leaving the empty angle brackets would indicate that we are taking the default argument (which is <code><a class="el" href="classVector.html">Vector</a>&lt;double&gt;</code> ). However, we explicitly mention the template argument:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div></div><!-- fragment --><p>Now solve the system of equations. The CG solver takes a preconditioner as its fourth argument. We don't feel ready to delve into this yet, so we tell it to use the identity operation as preconditioner:</p>
<div class="fragment"><div class="line">solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>Now that the solver has done its job, the solution variable contains the nodal values of the solution function.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3output_results"></a> </p><h4>Step3::output_results</h4>
<p>The last part of a typical finite element program is to output the results and maybe do some postprocessing (for example compute the maximal stress values at the boundary, or the average flux across the outflow, etc). We have no such postprocessing here, but we would like to write the solution to a file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>To write the output to a file, we need an object which knows about output formats and the like. This is the <a class="el" href="classDataOut.html">DataOut</a> class, and we need an object of that type:</p>
<div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div></div><!-- fragment --><p>Now we have to tell it where to take the values from which it shall write. We tell it which <a class="el" href="classDoFHandler.html">DoFHandler</a> object to use, and the solution vector (and the name by which the solution variable shall appear in the output file). If we had more than one vector which we would like to look at in the output (for example right hand sides, errors per cell, etc) we would add them as well:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div></div><!-- fragment --><p>After the <a class="el" href="classDataOut.html">DataOut</a> object knows which data it is to work on, we have to tell it to process them into something the back ends can handle. The reason is that we have separated the frontend (which knows about how to treat <a class="el" href="classDoFHandler.html">DoFHandler</a> objects and data vectors) from the back end (which knows many different output formats) and use an intermediate data format to transfer data from the front- to the backend. The data is transformed into this intermediate format by the following function:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div></div><!-- fragment --><p>Now we have everything in place for the actual output. Just open a file and write the data into it, using VTK format (there are many other functions in the <a class="el" href="classDataOut.html">DataOut</a> class we are using here that can write the data in postscript, AVS, GMV, Gnuplot, or some other file formats):</p>
<div class="fragment"><div class="line">std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3run"></a> </p><h4>Step3::run</h4>
<p>Finally, the last function of this class is the main function which calls all the other functions of the <code>Step3</code> class. The order in which this is done resembles the order in which most finite element programs work. Since the names are mostly self-explanatory, there is not much to comment about:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">make_grid();</div><div class="line">setup_system();</div><div class="line">assemble_system();</div><div class="line">solve();</div><div class="line">output_results();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>This is the main function of the program. Since the concept of a main function is mostly a remnant from the pre-object oriented era before C++ programming, it often does not do much more than creating an object of the top-level class and calling its principle function.</p>
<p>Finally, the first line of the function is used to enable output of some diagnostics that deal.II can generate. The <code>deallog</code> variable (which stands for deal-log, not de-allog) represents a stream to which some parts of the library write output. For example, iterative solvers will generate diagnostics (starting residual, number of solver steps, final residual) as can be seen when running this tutorial program.</p>
<p>The output of <code>deallog</code> can be written to the console, to a file, or both. Both are disabled by default since over the years we have learned that a program should only generate output when a user explicitly asks for it. But this can be changed, and to explain how this can be done, we need to explain how <code>deallog</code> works: When individual parts of the library want to log output, they open a "context" or "section" into which this output will be placed. At the end of the part that wants to write output, one exits this section again. Since a function may call another one from within the scope where this output section is open, output may in fact be nested hierarchically into these sections. The <a class="el" href="classLogStream.html">LogStream</a> class of which <code>deallog</code> is a variable calls each of these sections a "prefix" because all output is printed with this prefix at the left end of the line, with prefixes separated by colons. There is always a default prefix called "DEAL" (a hint at deal.II's history as the successor of a previous library called "DEAL" and from which the <a class="el" href="classLogStream.html">LogStream</a> class is one of the few pieces of code that were taken into deal.II).</p>
<p>By default, <code>logstream</code> only outputs lines with zero prefixes</p>
<ul>
<li>i.e., all output is disabled because the default "DEAL" prefix is always there. But one can set a different maximal number of prefixes for lines that should be output to something larger, and indeed here we set it to two by calling <a class="el" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">LogStream::depth_console()</a>. This means that for all screen output, a context that has pushed one additional prefix beyond the default "DEAL" is allowed to print its output to the screen ("console"), whereas all further nested sections that would have three or more prefixes active would write to <code>deallog</code>, but <code>deallog</code> does not forward this output to the screen. Thus, running this example (or looking at the "Results" section), you will see the solver statistics prefixed with "DEAL:CG", which is two prefixes. This is sufficient for the context of the current program, but you will see examples later on (e.g., in <a class="el" href="step_22.html">step-22</a> ) where solvers are nested more deeply and where you may get useful information by setting the depth even higher.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">Step3 laplace_problem;</div><div class="line">laplace_problem.run();</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of the program looks as follows: </p><div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">DEAL:cg::Starting value 0.121094</div><div class="line">DEAL:cg::Convergence step 48 value 5.33692e-13</div></div><!-- fragment --><p>The first two lines is what we wrote to <code>cout</code> . The lasttwo lines were generated without our intervention by the CGsolver. The first two lines state the residual at the start of theiteration, while the last line tells us that the solver needed 47iterations to bring the norm of the residual to 5.3e-13, i.e. belowthe threshold 1e-12 which we have set in the `solve' function. We willshow in the next program how to suppress this output, which issometimes useful for debugging purposes, but often clutters up thescreen display. Apart from the output shown above, the program generated the file <code>solution.vtk</code> , which is in the VTK format that is widelyused by many visualization programs today</p>
<ul>
<li>including the twoheavy-weights <a href="https://www.llnl.gov/visit">VisIt</a> and<a href="https://www.paraview.org">Paraview</a> that are the mostcommonly used programs for this purpose today. Using VisIt, it is not very difficult to generate a picture of thesolution like this: <table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.solution-3.png" alt="Visualization of the solution of step-3"/>
</div>
   </td></tr>
</table>
It shows both the solution and the mesh, elevated above the \(x\) - \(y\) planebased on the value of the solution at each point. Of course the solutionhere is not particularly exciting, but that is a result of both what theLaplace equation represents and the right hand side \(f(\mathbf x)=1\) wehave chosen for this program: The Laplace equation describes (among manyother uses) the vertical deformation of a membrane subject to an external(also vertical) force. In the current example, the membrane's bordersare clamped to a square frame with no vertical variation; a constantforce density will therefore intuitively lead to a membrane thatsimply bulges upward</li>
<li>like the one shown above. VisIt and Paraview both allow playing with various kinds of visualizationsof the solution. Several video lectures show how to use these programs. See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.11.html">video lecture 11</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.32.html">video lecture 32</a>.</li>
</ul>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>If you want to play around a little bit with this program, here are a fewsuggestions: </p>
<ul>
<li>
Change the geometry and mesh: In the program, we have generated a square domain and mesh by using the <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code> function. However, the <code><a class="el" href="namespaceGridGenerator.html">GridGenerator</a></code> has a good number of other functions as well. Try an L-shaped domain, a ring, or other domains you find there.  </li>
<li>
Change the boundary condition: The code uses the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> function to generate zero boundary conditions. However, you may want to try non-zero constant boundary values using <code>ConstantFunction&lt;2&gt;(1)</code> instead of <code>ZeroFunction&lt;2&gt;()</code> to have unit Dirichlet boundary values. More exotic functions are described in the documentation of the <a class="el" href="namespaceFunctions.html">Functions</a> namespace, and you may pick one to describe your particular boundary values.  </li>
<li>
<p class="startli">Modify the type of boundary condition: Presently, what happens is that we use Dirichlet boundary values all around, since the default is that all boundary parts have boundary indicator zero, and then we tell the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function to interpolate boundary values to zero on all boundary components with indicator zero. </p>
<p>We can change this behavior if we assign parts of the boundary different indicators. For example, try this immediately after calling <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>: </p><div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>()-&gt;face(0)-&gt;set_boundary_id(1);</div></div><!-- fragment --><p>What this does is it first asks the triangulation to return an iterator that points to the first active cell. Of course, this being the coarse mesh for the triangulation of a square, the triangulation has only a single cell at this moment, and it is active. Next, we ask the cell to return an iterator to its first face, and then we ask the face to reset the boundary indicator of that face to 1. What then follows is this: When the mesh is refined, faces of child cells inherit the boundary indicator of their parents, i.e. even on the finest mesh, the faces on one side of the square have boundary indicator 1. Later, when we get to interpolating boundary conditions, the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> call will only produce boundary values for those faces that have zero boundary indicator, and leave those faces alone that have a different boundary indicator. What this then does is to impose Dirichlet boundary conditions on the former, and homogeneous Neumann conditions on the latter (i.e. zero normal derivative of the solution, unless one adds additional terms to the right hand side of the variational equality that deal with potentially non-zero Neumann conditions). You will see this if you run the program. An alternative way to change the boundary indicator is to label the boundaries based on the Cartesian coordinates of the face centers. For example, we can label all of the cells along the top and bottom boundaries with a boundary indicator 1 by checking to see if the cell centers' y-coordinates are within a tolerance (here 1e-12) of</p>
<ul>
<li>and 1. Try this immediately after calling <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, as before: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line"> <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1)</div><div class="line"></div><div class="line">- (-1.0)) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 ||</div><div class="line">     <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1)</div><div class="line"></div><div class="line">- (1.0)) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12)</div><div class="line">   face-&gt;set_boundary_id(1);</div></div><!-- fragment --> Although this code is a bit longer than before, it is useful for complex geometries, as it does not require knowledge of face labels. </li>
</ul>
</li>
<li>
A slight variation of the last point would be to set different boundary values as above, but then use a different boundary value function for boundary indicator one. In practice, what you have to do is to add a second call to <code>interpolate_boundary_values</code> for boundary indicator one: <div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                  1,</div><div class="line">                  <a class="code" href="classFunctions_1_1ConstantFunction.html">ConstantFunction&lt;2&gt;</a>(1.),</div><div class="line">                  boundary_values);</div></div><!-- fragment --> If you have this call immediately after the first one to this function, then it will interpolate boundary values on faces with boundary indicator 1 to the unit value, and merge these interpolated values with those previously computed for boundary indicator 0. The result will be that we will get discontinuous boundary values, zero on three sides of the square, and one on the fourth. </li>
<li>
Observe convergence: We will only discuss computing errors in norms in <a class="el" href="step_7.html">step-7</a> , but it is easy to check that computations converge already here. For example, we could evaluate the value of the solution in a single point and compare the value for different numbers of global refinement (the number of global refinement steps is set in <code>LaplaceProblem::make_grid</code> above). To evaluate the solution at a point, say at \((\frac 13, \frac 13)\) , we could add the following code to the <code>LaplaceProblem::output_results</code> function: <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Solution at (1/3,1/3): &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, solution,</div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1./3, 1./3))</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --> For 1 through 9 global refinement steps, we then get the following sequence of point values: <table align="center" class="doxtable">
<tr>
<th># of refinements </th><th>\(u_h(\frac 13,\frac13)\)  </th></tr>
<tr>
<td>1 </td><td>0.166667  </td></tr>
<tr>
<td>2 </td><td>0.227381  </td></tr>
<tr>
<td>3 </td><td>0.237375  </td></tr>
<tr>
<td>4 </td><td>0.240435  </td></tr>
<tr>
<td>5 </td><td>0.241140  </td></tr>
<tr>
<td>6 </td><td>0.241324  </td></tr>
<tr>
<td>7 </td><td>0.241369  </td></tr>
<tr>
<td>8 </td><td>0.241380  </td></tr>
<tr>
<td>9 </td><td>0.241383  </td></tr>
</table>
By noticing that the difference between each two consecutive values reduces by about a factor of 4, we can conjecture that the "correct" value may be \(u(\frac 13, \frac 13)\approx 0.241384\) . In fact, if we assumed this to be the correct value, we could show that the sequence above indeed shows \({\cal O}(h^2)\) convergence &mdash; theoretically, the convergence order should be \({\cal O}(h^2 |\log h|)\) but the symmetry of the domain and the mesh may lead to the better convergence order observed. A slight variant of this would be to repeat the test with quadratic elements. All you need to do is to set the polynomial degree of the finite element to two in the constructor <code>LaplaceProblem::LaplaceProblem</code> . </li>
<li>
Convergence of the mean: A different way to see that the solution actually converges (to something &mdash; we can't tell whether it's really the correct value!) is to compute the mean of the solution. To this end, add the following code to <code>LaplaceProblem::output_results</code> : <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mean value: &quot;</span></div><div class="line">          &lt;&lt; VectorTools::compute_mean_value (dof_handler,</div><div class="line">                        <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                        solution,</div><div class="line">                        0)</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --> The documentation of the function explains what the second and fourth parameters mean, while the first and third should be obvious. Doing the same study again where we change the number of global refinement steps, we get the following result: <table align="center" class="doxtable">
<tr>
<th># of refinements </th><th>\(\int_\Omega u_h(x)\; dx\)  </th></tr>
<tr>
<td>0 </td><td>0.09375000  </td></tr>
<tr>
<td>1 </td><td>0.12790179  </td></tr>
<tr>
<td>2 </td><td>0.13733440  </td></tr>
<tr>
<td>3 </td><td>0.13976069  </td></tr>
<tr>
<td>4 </td><td>0.14037251  </td></tr>
<tr>
<td>5 </td><td>0.14052586  </td></tr>
<tr>
<td>6 </td><td>0.14056422  </td></tr>
<tr>
<td>7 </td><td>0.14057382  </td></tr>
<tr>
<td>8 </td><td>0.14057622  </td></tr>
</table>
Again, the difference between two adjacent values goes down by about a factor of four, indicating convergence as \({\cal O}(h^2)\) . </li>
</ul>
<p><a class="anchor" id="UsingHDF5tooutputthesolutionandadditionaldata"></a></p><h3>Using HDF5 to output the solution and additional data</h3>
<p>HDF5 is a commonly used format that can be read by many scriptinglanguages (e.g. R or Python). It is not difficult to get deal.II toproduce some HDF5 files that can then be used in external scripts topostprocess some of the data generated by this program. Here are someideas on what is possible.</p>
<p><a class="anchor" id="Changingtheoutputtoh5"></a></p><h4>Changing the output to .h5</h4>
<p>To fully make use of the automation we first need to introduce a private variable for the number ofglobal refinement steps <code>unsigned int n_refinement_steps </code> , which will be used for the output filename.In <code>make_grid()</code> we then replace <code>triangulation.refine_global(5);</code> with </p><div class="fragment"><div class="line">n_refinement_steps = 5;</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div></div><!-- fragment --><p> The deal.II library has two different HDF5 bindings, one in the HDF5namespace (for interfacing to general-purpose data files)and another one in <a class="el" href="classDataOut.html">DataOut</a> (specifically for writing files for thevisualization of solutions).Although the <a class="el" href="namespaceHDF5.html">HDF5</a> deal.II binding supports both serial and MPI, the HDF5 <a class="el" href="classDataOut.html">DataOut</a> bindingonly supports parallel output.For this reason we need to initialize an MPIcommunicator with only one processor. This is done by adding the following code. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line"><a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><p> Next we change the <code>Step3::output_results()</code> output routine asdescribed in the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> namespace documentation: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename_h5 = <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_refinement_steps) + <span class="stringliteral">&quot;.h5&quot;</span>;</div><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, filename_h5, MPI_COMM_WORLD);</div></div><!-- fragment --><p> The resulting file can then be visualized just like the VTK file thatthe original version of the tutorial produces; but, since HDF5 is amore general file format, it can also easily be processed in scriptinglanguages for other purposes.</p>
<p><a class="anchor" id="Addingthepointvalueandthemeanseeextensionaboveintotheh5file"></a></p><h4>Adding the point value and the mean (see extension above) into the .h5 file</h4>
<p>After outputting the solution, the file can be opened again to includemore datasets. This allows us to keep all the necessary informationof our experiment in a single result file, which can then be read andprocessed by some postprocessing script.(Have a look at HDF5::Group::write_dataset() for furtherinformation on the possible output options.) To make this happen, we first include the necessary header into our file : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hdf5_8h.html">deal.II/base/hdf5.h</a>&gt;</span></div></div><!-- fragment --><p> Adding the following lines to the endof our output routine adds the information about the value of thesolution at a particular point, as well as the mean value of thesolution, to our HDF5 file : </p><div class="fragment"><div class="line">HDF5::File data_file(filename_h5, HDF5::File::FileAccessMode::open, MPI_COMM_WORLD);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a>(1);</div><div class="line">point_value[0] = <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, solution,</div><div class="line">                                       <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1./3, 1./3));</div><div class="line">data_file.write_dataset(<span class="stringliteral">&quot;point_value&quot;</span>, point_value);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> mean_value(1);</div><div class="line">mean_value[0] = VectorTools::compute_mean_value(dof_handler,</div><div class="line">                                             <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                             solution, 0);</div><div class="line">data_file.write_dataset(<span class="stringliteral">&quot;mean_value&quot;</span>,mean_value);</div></div><!-- fragment --><p><a class="anchor" id="UsingRandggplot2togenerateplots"></a></p><h3>Using R and ggplot2 to generate plots</h3>
<p>The data put into HDF5 files above can then be used from scriptinglanguages for further postprocessing. In the following, let us showhow this can, in particular, be done with the<a href="https://en.wikipedia.org/wiki/R_(programming_language)">R programming language</a>, a widely used language in statistical dataanalysis. (Similar things can also be done in Python, for example.)If you are unfamiliar with R and ggplot2 you could check out the data carpentry course on R<a href="https://datacarpentry.org/R-ecology-lesson/index.html">here</a>.Furthermore, since most search engines struggle with searches of the form "R + topic",we recommend using the specializes service <a href="http://rseek.org">RSeek </a> instead. The most prominent difference between R and other languages is thatthe assignment operator (<code>a = 5</code>) is typically written as<code>a &lt;- 5</code>. As the latter is considered standard we will use it in our examples as well.To open the <code>.h5</code> file in R you have to install the <a href="https://bioconductor.org/packages/release/bioc/html/rhdf5.html">rhdf5</a> package, which is a part of the Bioconductor package. First we will include all necessary packages and have a look at how the data is structured in our file. </p><div class="fragment"><div class="line">library(rhdf5)     # library for handling HDF5 files</div><div class="line">library(ggplot2)   # main plotting library</div><div class="line">library(grDevices) # needed for output to PDF</div><div class="line">library(viridis)   # contains good colormaps for sequential data</div><div class="line"></div><div class="line">refinement &lt;- 5</div><div class="line">h5f &lt;- H5Fopen(paste(&quot;solution_&quot;,refinement,&quot;.h5&quot;,sep=&quot;&quot;))</div><div class="line">print(h5f)</div></div><!-- fragment --><p> This gives the following output </p><div class="fragment"><div class="line">HDF5 FILE</div><div class="line">name /</div><div class="line">filename</div><div class="line"></div><div class="line"> name       otype  dclass     dim</div><div class="line">0 cells       H5I_DATASET INTEGER  x 1024</div><div class="line">1 mean_value  H5I_DATASET FLOAT   1</div><div class="line">2 nodes       H5I_DATASET FLOAT    x 1089</div><div class="line">3 point_value H5I_DATASET FLOAT   1</div><div class="line">4 solution    H5I_DATASET FLOAT    x 1089</div></div><!-- fragment --><p> The datasets can be accessed by <code>h5f$name</code> . The function <code>dim(h5f$cells)</code> gives us the dimensions of the matrixthat is used to store our cells.We can see the following three matrices, as well as the twoadditional data points we added. </p><ul>
<li>
<code>cells</code> : a 4x1024 matrix that stores the (C++) vertex indices for each cell </li>
<li>
<code>nodes</code> : a 2x1089 matrix storing the position values (x,y) for our cell vertices </li>
<li>
<code>solution</code> : a 1x1089 matrix storing the values of our solution at each vertex </li>
</ul>
<p>Now we can use this data to generate various plots. Plotting with ggplot2 usually splits into two steps.At first the data needs to be manipulated and added to a <code>data.frame</code> .After that, a <code>ggplot</code> object is constructed and manipulated by adding plot elements to it. <code>nodes</code> and <code>cells</code> contain all the information we need to plot our grid.The following code wraps all the data into one dataframe for plotting our grid: </p><div class="fragment"><div class="line"># Counting in R starts at 1 instead of 0, so we need to increment all</div><div class="line"># vertex indices by one:</div><div class="line">cell_ids &lt;- h5f@f$cells+1</div><div class="line"></div><div class="line"># Store the x and y positions of each vertex in one big vector in a</div><div class="line"># cell by cell fashion (every 4 entries belong to one cell):</div><div class="line">cells_x &lt;- h5f@f$nodes[1,][cell_ids]</div><div class="line">cells_y &lt;- h5f@f$nodes[2,][cell_ids]</div><div class="line"></div><div class="line"># Construct a vector that stores the matching cell by cell grouping</div><div class="line"># (1,1,1,1,2,2,2,2,...):</div><div class="line">groups &lt;- rep(1:ncol(cell_ids),each=4)</div><div class="line"></div><div class="line"># Finally put everything into one dataframe:</div><div class="line">meshdata &lt;- data.frame(x = cells_x, y = cells_y, id = groups)</div></div><!-- fragment --><p>With the finished dataframe we have everything we need to plot our grid: </p><div class="fragment"><div class="line">pdf (paste(&quot;grid_&quot;,refinement,&quot;.pdf&quot;,sep=&quot;&quot;),width = 5,height = 5) # Open new PDF file</div><div class="line">plt &lt;- ggplot(meshdata,aes(x=x,y=y,group=id))                      # Construction of our plot</div><div class="line">                                                                # object, at first only data</div><div class="line"></div><div class="line">plt &lt;- plt + geom_polygon(fill=&quot;white&quot;,colour=&quot;black&quot;)             # Actual plotting of the grid as polygons</div><div class="line">plt &lt;- plt + ggtitle(paste(&quot;grid at refinement level #&quot;,refinement))</div><div class="line"></div><div class="line">print(plt)                                                         # Show the current state of the plot/add it to the pdf</div><div class="line">dev.off()                                                          # Close PDF file</div></div><!-- fragment --><p>The contents of this file then look as follows (not very exciting, butyou get the idea): </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.grid_5.png" alt="Grid after 5 refinement steps of step-3"/>
</div>
   </td></tr>
</table>
<p>We can also visualize the solution itself, and this is going to lookmore interesting.To make a 2D pseudocolor plot of our solution we will use <code>geom_raster</code> .This function needs a structured grid, i.e. uniform in x and y directions.Luckily our data at this point is structured in the right way.The following code plots a pseudocolor representation of our surface into a new PDF: </p><div class="fragment"><div class="line">pdf (paste(&quot;pseudocolor_&quot;,refinement,&quot;.pdf&quot;,sep=&quot;&quot;),width = 5,height = 4.2) # Open new PDF file</div><div class="line">colordata &lt;- data.frame(x = h5f@f$nodes[1,],y = h5f@f$nodes[2,] , solution = h5f@f$solution[1,])</div><div class="line">plt &lt;- ggplot(colordata,aes(x=x,y=y,fill=solution))</div><div class="line">plt &lt;- plt + geom_raster(interpolate=TRUE)</div><div class="line">plt &lt;- plt + scale_fill_viridis()</div><div class="line">plt &lt;- plt + ggtitle(paste(&quot;solution at refinement level #&quot;,refinement))</div><div class="line"></div><div class="line">print(plt)</div><div class="line">dev.off()</div><div class="line">H5Fclose(h5f) # Close the HDF5 file</div></div><!-- fragment --><p> This is now going to look as follows: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.pseudocolor_5.png" alt="Solution after 5 refinement steps of step-3"/>
</div>
   </td></tr>
</table>
<p>For plotting the converge curves we need to re-run the C++ code multiple times with different values for <code>n_refinement_steps</code> starting from 1.Since every file only contains a single data point we need to loop over them and concatenate the results into a single vector. </p><div class="fragment"><div class="line">n_ref &lt;- 8   # Maximum refinement level for which results are existing</div><div class="line"></div><div class="line"># First we initiate all vectors with the results of the first level</div><div class="line">h5f   &lt;- H5Fopen(&quot;solution_1.h5&quot;)</div><div class="line">dofs  &lt;- dim(h5f@f$solution)[2]</div><div class="line">mean  &lt;- h5f@f$mean_value</div><div class="line">point &lt;- h5f@f$point_value</div><div class="line">H5Fclose(h5f)</div><div class="line"></div><div class="line">for (reflevel in 2:n_ref)</div><div class="line">{</div><div class="line">h5f   &lt;- H5Fopen(paste(&quot;solution_&quot;,reflevel,&quot;.h5&quot;,sep=&quot;&quot;))</div><div class="line">dofs  &lt;- c(dofs,dim(h5f$solution)[2])</div><div class="line">mean  &lt;- c(mean,h5f$mean_value)</div><div class="line">point &lt;- c(point,h5f$point_value)</div><div class="line">H5Fclose(h5f)</div><div class="line">}</div></div><!-- fragment --><p> As we are not interested in the values themselves but rather in the error compared to a "exact" solution we willassume our highest refinement level to be that solution and omit it from the data. </p><div class="fragment"><div class="line"># Calculate the error w.r.t. our maximum refinement step</div><div class="line">mean_error  &lt;- abs(mean[1:n_ref-1]-mean[n_ref])</div><div class="line">point_error &lt;- abs(point[1:n_ref-1]-point[n_ref])</div><div class="line"></div><div class="line"># Remove the highest value from our DoF data</div><div class="line">dofs     &lt;- dofs[1:n_ref-1]</div><div class="line">convdata &lt;- data.frame(dofs = dofs, mean_value= mean_error, point_value = point_error)</div></div><!-- fragment --><p> Now we have all the data available to generate our plots.It is often useful to plot errors on a log-log scale, which isaccomplished in the following code: </p><div class="fragment"><div class="line">pdf (paste(<span class="stringliteral">&quot;convergence.pdf&quot;</span>,sep=<span class="stringliteral">&quot;&quot;</span>),width = 5,height = 4.2)</div><div class="line">plt &lt;- ggplot(convdata,mapping=aes(x = dofs, y = mean_value))</div><div class="line">plt &lt;- plt+geom_line()</div><div class="line">plt &lt;- plt+labs(x=&quot;<span class="preprocessor">#DoFs&quot;,y = &quot;mean value error&quot;)</span></div><div class="line">plt &lt;- plt+scale_x_log10()+scale_y_log10()</div><div class="line">print(plt)</div><div class="line"></div><div class="line">plt &lt;- ggplot(convdata,mapping=aes(x = dofs, y = point_value))</div><div class="line">plt &lt;- plt+geom_line()</div><div class="line">plt &lt;- plt+labs(x=&quot;<span class="preprocessor">#DoFs&quot;,y = &quot;point value error&quot;)</span></div><div class="line">plt &lt;- plt+scale_x_log10()+scale_y_log10()</div><div class="line">print(plt)</div><div class="line"></div><div class="line">dev.off()</div></div><!-- fragment --><p> This results in the following plot that shows how the errors in themean value and the solution value at the chosen point nicely convergeto zero: </p><table style="width:50%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.convergence_mean.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.convergence_point.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, 1999,</span></div><div class="line"><span class="comment"> *          Guido Kanschat, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">Step3::Step3()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            1. *                                <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_2.html">step-2</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thebasicsetupoffiniteelementmethods">The basic set up of finite element methods</a>
        <li><a href="#Shouldwemultiplybyatestfunctionfromtheleftorfromtheright"> Should we multiply by a test function from the left or from the right? </a>
        <li><a href="#Computingthematrixandrighthandsidevector"> Computing the matrix and right hand side vector </a>
        <li><a href="#Abouttheimplementation">About the implementation</a>
        <li><a href="#Anoteontypes"> A note on types </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Manynewincludefiles">Many new include files</a>
        <li><a href="#ThecodeStep3codeclass">The <code>Step3</code> class</a>
      <ul>
        <li><a href="#Step3Step3">Step3::Step3</a>
        <li><a href="#Step3make_grid">Step3::make_grid</a>
        <li><a href="#Step3setup_system">Step3::setup_system</a>
        <li><a href="#Step3assemble_system">Step3::assemble_system</a>
        <li><a href="#Step3solve">Step3::solve</a>
        <li><a href="#Step3output_results">Step3::output_results</a>
        <li><a href="#Step3run">Step3::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
        <li><a href="#UsingHDF5tooutputthesolutionandadditionaldata">Using HDF5 to output the solution and additional data</a>
      <ul>
        <li><a href="#Changingtheoutputtoh5"> Changing the output to .h5</a>
        <li><a href="#Addingthepointvalueandthemeanseeextensionaboveintotheh5file"> Adding the point value and the mean (see extension above) into the .h5 file</a>
      </ul>
        <li><a href="#UsingRandggplot2togenerateplots"> Using R and ggplot2 to generate plots</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-3/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.10.html">video lecture 10</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p><a class="anchor" id="Thebasicsetupoffiniteelementmethods"></a></p><h3>The basic set up of finite element methods</h3>
<p>这是第一个我们实际使用有限元来计算的例子。我们将解决一个简单的泊松方程，其边界值为零，但右手边非零。</p>
<p class="formulaDsp">
\begin{align*} -\Delta u &amp;= f \qquad\qquad &amp; \text{in}\ \Omega, \\ u &amp;= 0 \qquad\qquad &amp; \text{on}\ \partial\Omega. \end{align*}
</p>
<p>我们将在正方形 \(\Omega=[-1,1]^2\) 上求解这个方程，你已经在步骤1和步骤2中学习了如何生成网格。在这个程序中，我们也将只考虑 \(f(\mathbf x)=1\) 这个特殊情况，并在下一个教程程序中再来讨论如何实现更一般的情况，即步骤4。</p>
<p>如果你学过有限元方法的基本知识，你会记得我们需要采取的步骤，用有限维度的近似方法来近似解 \(u\) 。具体来说，我们首先需要推导出上述方程的弱形式，通过将方程乘以测试函数 \(\varphi\) <em>from the left</em>（我们将在下面回到从左而非从右相乘的原因）并在域 \(\Omega\) 上积分得到。</p>
<p class="formulaDsp">
\begin{align*} -\int_\Omega \varphi \Delta u = \int_\Omega \varphi f. \end{align*}
</p>
<p>这可以通过部件进行整合。</p>
<p class="formulaDsp">
\begin{align*} \int_\Omega \nabla\varphi \cdot \nabla u - \int_{\partial\Omega} \varphi \mathbf{n}\cdot \nabla u = \int_\Omega \varphi f. \end{align*}
</p>
<p>测试函数 \(\varphi\) 必须满足同样的边界条件（用数学术语来说：它需要来自我们寻求解决方案的集合的切线空间），因此在边界上 \(\varphi=0\) ，因此我们正在寻找的弱形式为</p>
<p class="formulaDsp">
\begin{align*} (\nabla\varphi, \nabla u) = (\varphi, f), \end{align*}
</p>
<p>其中我们使用了常用的符号 \((a,b)=\int_\Omega a\; b\) 。然后，问题要求从适当的空间（这里是空间 \(H^1\) ）中找出一个函数 \(u\) ，对于该函数，这一声明对于所有测试函数 \(\varphi\) 都是真的。</p>
<p>当然，在一般情况下，我们无法在计算机上找到这样的函数，而是寻求一个近似值 \(u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) ，其中 \(U_j\) 是我们需要确定的未知膨胀系数（这个问题的 "自由度"）， \(\varphi_i(\mathbf x)\) 是我们将使用的有限元形状函数。为了定义这些形状函数，我们需要以下内容。</p>
<ul>
<li>一个用来定义形状函数的网格。你已经看到如何在步骤1和步骤2中生成和操作描述网格的对象。</li>
<li>一个描述我们想在参考单元上使用的形状函数的有限元（在deal.II中总是单位间隔 \([0,1]\) 、单位正方形 \([0,1]^2\) 或单位立方体 \([0,1]^3\) ，取决于你在哪个空间维度工作）。在步骤2中，我们已经使用了FE_Q&lt;2&gt;类型的对象，它表示通常的拉格朗日元素，通过对支持点的插值来定义形状函数。最简单的是FE_Q&lt;2&gt;(1)，它使用1度的多项式。在2D中，这些通常被称为<em>bilinear</em>，因为它们在参考单元的两个坐标中都是线性的。(在1d中，它们是<em>linear</em>，在3d中是<em>tri-linear</em>；然而，在deal.II文档中，我们经常不做这种区分，而总是简单地称这些函数为 "线性"。)</li>
<li>一个DoFHandler对象，以有限元对象提供的参考单元描述为基础，枚举网格上的所有自由度。你也已经在步骤2中看到了如何做到这一点。</li>
<li>一个映射，告诉你如何从参考单元上的有限元类定义的形状函数中获得实数单元上的形状函数。默认情况下，除非你明确说明，否则deal.II将使用（双，三）线性映射，所以在大多数情况下，你不必担心这个步骤。</li>
</ul>
<p>通过这些步骤，我们现在有一组函数 \(\varphi_i\) ，我们可以定义离散问题的弱形式：找到一个函数 \(u_h\) ，即找到上面提到的扩展系数 \(U_j\) ，以便</p>
<p class="formulaDsp">
\begin{align*} (\nabla\varphi_i, \nabla u_h) = (\varphi_i, f), \qquad\qquad i=0\ldots N-1. \end{align*}
</p>
<p>请注意，我们在此遵循惯例，即一切从零开始计算，这在C和C++中很常见。如果你插入表示法 \(u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) ，这个方程可以重写为一个线性系统，然后观察到</p>
<p class="formulaDsp">
\begin{align*} (\nabla\varphi_i, \nabla u_h) &amp;= \left(\nabla\varphi_i, \nabla \Bigl[\sum_j U_j \varphi_j\Bigr]\right) \\ &amp;= \sum_j \left(\nabla\varphi_i, \nabla \left[U_j \varphi_j\right]\right) \\ &amp;= \sum_j \left(\nabla\varphi_i, \nabla \varphi_j \right) U_j. \end{align*}
</p>
<p>有了这个，问题就成了。找到一个向量 \(U\) ，以便</p>
<p class="formulaDsp">
\begin{align*} A U = F, \end{align*}
</p>
<p>其中矩阵 \(A\) 和右手边 \(F\) 定义为</p>
<p class="formulaDsp">
\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j), \\ F_i &amp;= (\varphi_i, f). \end{align*}
</p>
<p><a class="anchor" id="Shouldwemultiplybyatestfunctionfromtheleftorfromtheright"></a></p><h3>Should we multiply by a test function from the left or from the right? </h3>
<p>在我们继续描述如何计算这些数量之前，请注意，如果我们从<em>right</em>乘以一个测试函数而不是从左边乘以原方程，那么我们将得到一个形式为的线性系统</p>
<p class="formulaDsp">
\begin{align*} U^T A = F^T \end{align*}
</p>
<p>有一个行向量 \(F^T\) 。通过转置这个系统，这当然等同于解决了</p>
<p class="formulaDsp">
\begin{align*} A^T U = F \end{align*}
</p>
<p>这里与上面的 \(A=A^T\) 相同。但一般来说不是，为了避免任何形式的混淆，经验表明，只要养成从左边而不是从右边乘方程的习惯（正如数学文献中经常做的那样），就可以避免一类常见的错误，因为在比较理论和实现时，矩阵会自动正确，不需要转置。本教程的第一个例子见第9步，我们有一个非对称的双线性方程，对于这个方程，我们从右面还是从左面相乘是有区别的。</p>
<p><a class="anchor" id="Computingthematrixandrighthandsidevector"></a></p><h3>Computing the matrix and right hand side vector </h3>
<p>现在我们知道我们需要什么（即：持有矩阵和向量的对象，以及计算 \(A_{ij},F_i\) 的方法），我们可以看看需要什么来实现这一点。</p>
<ul>
<li>\(A\) 的对象是SparseMatrix类型，而 \(U\) 和 \(F\) 的对象则是Vector类型。我们将在下面的程序中看到哪些类是用来解决线性系统的。</li>
<li><p class="startli">我们需要一种方法来形成积分。在有限元方法中，最常见的是使用正交法，也就是说，积分被每个单元上的一组点的加权和所取代。也就是说，我们首先将 \(\Omega\) 的积分分成所有单元的积分， </p><p class="formulaDsp">
\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j) = \sum_{K \in {\mathbb T}} \int_K \nabla\varphi_i \cdot \nabla \varphi_j, \\ F_i &amp;= (\varphi_i, f) = \sum_{K \in {\mathbb T}} \int_K \varphi_i f, \end{align*}
</p>
<p class="startli">然后用正交法对每个单元的贡献进行近似。 </p><p class="formulaDsp">
\begin{align*} A^K_{ij} &amp;= \int_K \nabla\varphi_i \cdot \nabla \varphi_j \approx \sum_q \nabla\varphi_i(\mathbf x^K_q) \cdot \nabla \varphi_j(\mathbf x^K_q) w_q^K, \\ F^K_i &amp;= \int_K \varphi_i f \approx \sum_q \varphi_i(\mathbf x^K_q) f(\mathbf x^K_q) w^K_q, \end{align*}
</p>
<p class="startli">其中 \(\mathbf x^K_q\) 是 \(q\) 单元上的第三个正交点 \(K\) ， \(w^K_q\) 是 \(q\) 的正交权。这样做需要有不同的部分，接下来我们将依次讨论它们。</p>
</li>
<li>首先，我们需要一种方法来描述正交点的位置 \(\mathbf x_q^K\) 和它们的权重 \(w^K_q\) 。它们通常以与形状函数相同的方式从参考单元映射出来，即隐含地使用MappingQ1类，或者，如果你明确地说，通过从Mapping派生的其他类之一。参考单元上的位置和权重由派生自正交基类的对象来描述。通常，人们选择一个正交公式（即一组点和权重），使正交正好等于矩阵中的积分；这可以实现，因为积分中的所有因子都是多项式，由高斯正交公式完成，在QGauss类中实现。</li>
<li>然后我们需要一些东西来帮助我们在 \(K\) 单元上评估 \(\varphi_i(\mathbf x^K_q)\) 。这就是FEValues类的作用：它需要一个有限元对象来描述参考单元上的 \(\varphi\) ，一个正交对象来描述正交点和权重，以及一个映射对象（或隐含地采用MappingQ1类），并在位于 \(K\) 的正交点上提供形状函数的值和导数，以及积分所需的各种其他信息。</li>
</ul>
<p>FEValues确实是装配过程中的核心类。你可以这样看待它。FiniteElement和派生类描述了形状<em>functions</em>，即无限维度的对象：函数在每一点都有值。由于理论上的原因，我们需要这样做，因为我们想用函数的积分来进行分析。然而，对于计算机来说，这是一个非常困难的概念，因为它们一般只能处理有限的信息量，所以我们用正交点上的和来代替积分，我们通过使用定义在参考单元（正交对象）上的点映射（映射对象）到真实单元上的点来获得。实质上，我们将问题简化为我们只需要有限的信息，即形状函数值和导数、正交权重、法向量等，只需要在有限的点集合上。FEValues类就是将这三个部分结合在一起，并在一个特定的单元上提供这个有限的信息集 \(K\) 。当我们组装下面的线性系统时，你会看到它的作用。</p>
<p>值得注意的是，如果你只是在应用程序中自己创建这三个对象，并自己处理这些信息，那么所有这些也都可以实现。然而，这样做既不简单（FEValues类提供的正是你实际需要的信息），也不快：FEValues类经过高度优化，只在每个单元中计算你需要的特定信息；如果有任何东西可以从上一个单元中重复使用，那么它就会这样做，而且该类中有很多代码可以确保在有利的地方进行缓存。</p>
<p>这个介绍的最后一块是要提到，在得到一个线性系统后，要用迭代求解器进行求解，然后进行后处理：我们用DataOut类创建一个输出文件，然后可以用一个常见的可视化程序进行可视化。</p>
<dl class="section note"><dt>Note</dt><dd>前面对任何有限元实现的所有重要步骤的概述，在deal.II中也有对应的内容：该库可以自然地归纳为若干 "模块"，涵盖刚才概述的基本概念。你可以通过本页面顶部的标签访问这些模块。在<a href="index.html">front page of the deal.II manual</a>上也有对最基本的概念组的概述。</dd></dl>
<p><a class="anchor" id="Abouttheimplementation"></a></p><h3>About the implementation</h3>
<p>虽然这是你能用有限元方法解决的最简单的方程，但这个程序显示了大多数有限元程序的基本结构，也是几乎所有下面的程序基本上都会遵循的模板。具体来说，这个程序的主类看起来像这样。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Step3 ();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> ();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid ();</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>     <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>              fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>        dof_handler;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>这遵循了<a href="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)">data encapsulation</a>的面向对象编程口号，也就是说，我们尽力将这个类的几乎所有内部细节隐藏在外部无法访问的私有成员中。</p>
<p>让我们从成员变量开始。这些遵循我们在上面的要点中所概述的构建模块，即我们需要一个三角形和一个DoFHandler对象，以及一个描述我们想要使用的各种形状函数的有限元对象。第二组对象与线性代数有关：系统矩阵和右手边以及解向量，还有一个描述矩阵稀疏模式的对象。这就是这个类所需要的全部内容（也是任何静止PDE的求解器所需要的基本内容），并且需要在整个程序中存活。与此相反，我们在装配时需要的FEValues对象只在整个装配过程中需要，因此我们在进行装配的函数中把它作为一个局部对象来创建，并在结束时再次销毁它。</p>
<p>其次，让我们来看看成员函数。这些，也已经构成了几乎所有下面的教程程序都会使用的共同结构。 </p><ul>
<li>
<code>make_grid()</code> : 这就是人们所说的<em>preprocessing function</em>。顾名思义，它设置了存储三角图的对象。在以后的例子中，它还可以处理边界条件、几何形状等。 </li>
<li>
<code>setup_system()</code> : 这是一个函数，其中设置了解决问题所需的所有其他数据结构。特别是，它将初始化DoFHandler对象并正确确定与线性代数有关的各种对象的大小。这个函数通常与上面的预处理函数分开，因为在一个与时间相关的程序中，每当网格被自适应细化时（我们将在步骤6中看到如何做），它可能至少每隔几个时间步就会被调用。另一方面，在上面的预处理函数中，设置网格本身只在程序开始时进行一次，因此，它被分离成自己的函数。 </li>
<li>
<code>assemble_system()</code> : 这就是计算矩阵和右手边的内容的地方，在上面的介绍中已经详细讨论过。由于对这个线性系统进行处理在概念上与计算其条目有很大不同，我们将其与以下函数分开。 </li>
<li>
<code>solve()</code> : 这就是我们计算线性系统 \(U\) 的解的函数。在当前的程序中，这是一个简单的任务，因为矩阵是如此简单，但只要问题不再那么微不足道，它就会成为程序规模的重要部分（例如，一旦你对库有了更多的了解，请参阅步骤20，步骤22，或步骤31）。 </li>
<li>
<code>output_results()</code> : 最后，当你计算出一个解决方案后，你可能想用它做一些事情。例如，你可能想以可视化的格式输出它，或者你可能想计算你感兴趣的量：例如，热交换器中的热通量、机翼的空气摩擦系数、最大桥梁载荷，或者仅仅是某一点上的数值解的值。因此，这个函数是对你的解进行后处理的地方。 </li>
</ul>
<p>所有这些都是由单一的公共函数（除构造函数外），即 <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> 函数来支撑的。它是在创建这种类型的对象的地方被调用的，它是按正确顺序调用所有其他函数的函数。把这个操作封装到 <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> 函数中，而不是从 <code>main()</code> 中调用所有其他函数，确保你可以改变这个类中的关注点分离的实现方式。例如，如果其中一个函数变得太大了，你可以把它分成两个，而你唯一需要关注的地方就是这个类中的变化，而不是其他地方。</p>
<p>如上所述，你会看到这种一般的结构&amp;mdash；有时在函数名称的拼写上会有一些变化，但基本上是按照这种功能分离的顺序&amp;mdash；在下面的许多教程程序中也是如此。</p>
<p><a class="anchor" id="Anoteontypes"></a></p><h3>A note on types </h3>
<p>deal.II通过命名空间 <a class="el" href="namespacetypes.html">types</a>. 中的别名定义了一些积分类型（在前一句中，"积分 "一词被用作与名词 "整数 "相对应的<em>adjective</em>。它不应该与表示曲线或曲面下的面积或体积的<em>noun</em>"积分 "混淆起来。形容词 "积分 "在C++世界中被广泛使用，如 "积分类型"、"积分常数 "等。）特别是，在这个程序中，你会在几个地方看到 <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> ：一个整数类型，用来表示自由度的<em>global</em>索引，即在定义在三角形之上的DoFHandler对象中特定自由度的索引（而不是特定单元中的特定自由度的索引）。对于当前的程序（以及几乎所有的教程程序），你将有几千个到几百万个全局未知数（而且，对于 \(Q_1\) 元素，你将有4个<em>locally on each cell</em>的2D和8个3D）。因此，允许为全局DoF指数存储足够大的数字的数据类型是 <code>unsigned int</code> ，因为它允许存储0到略高于40亿的数字（在大多数系统中，整数是32位的）。事实上，这就是 <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> 的作用。</p>
<p>那么，为什么不马上使用 <code>unsigned int</code> 呢？deal.II在7.3版本之前一直是这样做的。然而，deal.II支持非常大的计算（通过步骤40中讨论的框架），当分布在几千个处理器上时，可能有超过40亿个未知数。因此，有些情况下 <code>unsigned int</code> 不够大，我们需要一个64位的无符号积分类型。为了实现这一点，我们引入了 <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> ，它默认被定义为<code>unsigned int</code>，而如果有必要，可以通过在配置过程中传递一个特定的标志，将其定义为<code>unsigned long long int</code>（见ReadMe文件）。</p>
<p>这涵盖了技术方面。但是还有一个文档的目的：在图书馆和建立在它之上的代码中，如果你看到一个地方使用数据类型 <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, ，你就会立即知道被引用的数量实际上是一个全局dof指数。如果我们只是使用 <code>unsigned int</code> （它也可能是一个局部索引，一个边界指示器，一个材料ID，等等），就不会有这样的意义了。立即知道一个变量指的是什么也有助于避免错误：如果你看到一个 <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> 类型的对象被分配给 <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, 类型的变量，这很明显一定有一个错误，尽管它们都是用无符号整数表示，因此编译器不会抱怨。</p>
<p>在更实际的情况下，这种类型的存在意味着在装配过程中，我们创建一个 \(4\times 4\) 矩阵（在2d中，使用 \(Q_1\) 元素）来表示我们当前所在单元的贡献，然后我们需要将这个矩阵的元素添加到全局（系统）矩阵的相应元素中。为此，我们需要获得当前单元的局部自由度的全局指数，为此我们将始终使用下面这段代码。</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p>其中 <code>local_dof_indices</code> 被声明为</p>
<div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p>这个变量的名字可能有点名不副实&ndash;它代表 "在当前单元上局部定义的那些自由度的全局指数"&ndash;但持有这种信息的变量在整个库中普遍是这样命名的。</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> 并不是这个命名空间中定义的唯一类型。相反，有一整个系列，包括 <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, 和 <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>. 所有这些都是整数数据类型的别名，但正如上面所解释的，它们被用于整个库，以便（i）变量的意图变得更容易辨别，以及（ii）如果有必要，可以将实际类型改为一个更大的类型，而不必翻阅整个库，找出 <code>unsigned int</code> 的特定使用是否对应于，例如，一个材料指标。</dd></dl>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Manynewincludefiles"></a> </p><h3>Many new include files</h3>
<p>These include files are already known to you. They declare the classes which handle triangulations and enumeration of degrees of freedom:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div></div><!-- fragment --><p>And this is the file in which the functions are declared that create grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>This file contains the description of the Lagrange interpolation finite element:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>And this file is needed for the creation of sparsity patterns of sparse matrices, as shown in previous examples:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The next two files are needed for assembling the matrix using quadrature on each cell. The classes declared in them will be explained below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div></div><!-- fragment --><p>The following three include files we need for the treatment of boundary values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>We're now almost to the end. The second to last group of include files is for the linear algebra which we employ to solve the system of equations arising from the finite element discretization of the Laplace equation. We will use vectors and full matrices for assembling the system of equations locally on each cell, and transfer the results into a sparse matrix. We will then use a Conjugate Gradient solver to solve the problem, for which we need a preconditioner (in this program, we use the identity preconditioner which does nothing, but we need to include the file anyway):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, this is for output to a file and to the console:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>...and this is to import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep3codeclass"></a> </p><h3>The <code>Step3</code> class</h3>
<p>Instead of the procedural programming of previous examples, we encapsulate everything into a class for this program. The class consists of functions which each perform certain aspects of a finite element program, a <code>main</code> function which controls what is done first and what is done next, and a list of member variables.</p>
<p>The public part of the class is rather short: it has a constructor and a function <code>run</code> that is called from the outside and acts as something like the <code>main</code> function: it coordinates which operations of this class shall be run in which order. Everything else in the class, i.e. all the functions that actually do anything, are in the private section of the class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div></div><!-- fragment --><p>Then there are the member functions that mostly do what their names suggest and whose have been discussed in the introduction already. Since they do not need to be called from outside, they are made private to this class.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>And finally we have some member variables. There are variables describing the triangulation and the global numbering of the degrees of freedom (we will specify the exact polynomial degree of the finite element in the constructor of this class)...</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>          fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>    dof_handler;</div></div><!-- fragment --><p>...variables for the sparsity pattern and values of the system matrix resulting from the discretization of the Laplace equation...</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>...and variables which will hold the right hand side and solution vectors.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Step3Step3"></a> </p><h4>Step3::Step3</h4>
<p>Here comes the constructor. It does not much more than first to specify that we want bi-linear elements (denoted by the parameter to the finite element object, which indicates the polynomial degree), and to associate the dof_handler variable to the triangulation we use. (Note that the triangulation isn't set up with a mesh at all at the present time, but the <a class="el" href="classDoFHandler.html">DoFHandler</a> doesn't care: it only wants to know which triangulation it will be associated with, and it only starts to care about an actual mesh once you try to distribute degree of freedom on the mesh using the distribute_dofs() function.) All the other member variables of the Step3 class have a default constructor which does all we want.</p>
<div class="fragment"><div class="line">Step3::Step3()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step3make_grid"></a> </p><h4>Step3::make_grid</h4>
<p>Now, the first thing we've got to do is to generate the triangulation on which we would like to do our computation and number each vertex with a degree of freedom. We have seen these two steps in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a> before, respectively.</p>
<p>This function does the first part, creating the mesh. We create the grid and refine all cells five times. Since the initial grid (which is the square \([-1,1] \times [-1,1]\)) consists of only one cell, the final grid has 32 times 32 cells, for a total of 1024.</p>
<p>Unsure that 1024 is the correct number? We can check that by outputting the number of cells using the <code><a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells()</a></code> function on the triangulation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We call the <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> function, rather than <a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">Triangulation::n_cells()</a>. Here, <em>active</em> means the cells that aren't refined any further. We stress the adjective "active" since there are more cells, namely the parent cells of the finest cells, their parents, etc, up to the one cell which made up the initial grid. Of course, on the next coarser level, the number of cells is one quarter that of the cells on the finest level, i.e. 256, then 64, 16, 4, and 1. If you called <code><a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">triangulation.n_cells()</a></code> instead in the code above, you would consequently get a value of 1365 instead. On the other hand, the number of cells (as opposed to the number of active cells) is not typically of much interest, so there is no good reason to print it.</dd></dl>
<p><a class="anchor" id="Step3setup_system"></a> </p><h4>Step3::setup_system</h4>
<p>Next we enumerate all the degrees of freedom and set up matrix and vector objects to hold the system data. Enumerating is done by using <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>, as we have seen in the <a class="el" href="step_2.html">step-2</a> example. Since we use the <a class="el" href="classFE__Q.html">FE_Q</a> class and have set the polynomial degree to 1 in the constructor, i.e. bilinear elements, this associates one degree of freedom with each vertex. While we're at generating output, let us also take a look at how many degrees of freedom are generated:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div></div><!-- fragment --><p>There should be one DoF for each vertex. Since we have a 32 times 32 grid, the number of DoFs should be 33 times 33, or 1089.</p>
<p>As we have seen in the previous example, we set up a sparsity pattern by first creating a temporary structure, tagging those entries that might be nonzero, and then copying the data over to the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object that can then be used by the system matrix.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div></div><!-- fragment --><p>Note that the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object does not hold the values of the matrix, it only stores the places where entries are. The entries themselves are stored in objects of type <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, of which our variable system_matrix is one.</p>
<p>The distinction between sparsity pattern and matrix was made to allow several matrices to use the same sparsity pattern. This may not seem relevant here, but when you consider the size which matrices can have, and that it may take some time to build the sparsity pattern, this becomes important in large-scale problems if you have to store several matrices in your program.</p>
<div class="fragment"><div class="line">system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The last thing to do in this function is to set the sizes of the right hand side vector and the solution vector to the right values:</p>
<div class="fragment"><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3assemble_system"></a> </p><h4>Step3::assemble_system</h4>
<p>The next step is to compute the entries of the matrix and right hand side that form the linear system from which we compute the solution. This is the central function of each finite element program and we have discussed the primary steps in the introduction already.</p>
<p>The general approach to assemble matrices and vectors is to loop over all cells, and on each cell compute the contribution of that cell to the global matrix and right hand side by quadrature. The point to realize now is that we need the values of the shape functions at the locations of quadrature points on the real cell. However, both the finite element shape functions as well as the quadrature points are only defined on the reference cell. They are therefore of little help to us, and we will in fact hardly ever query information about finite element shape functions or quadrature points from these objects directly.</p>
<p>Rather, what is required is a way to map this data from the reference cell to the real cell. Classes that can do that are derived from the <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> class, though one again often does not have to deal with them directly: many functions in the library can take a mapping object as argument, but when it is omitted they simply resort to the standard bilinear Q1 mapping. We will go this route, and not bother with it for the moment (we come back to this in <a class="el" href="step_10.html">step-10</a>, <a class="el" href="step_11.html">step-11</a>, and <a class="el" href="step_12.html">step-12</a>).</p>
<p>So what we now have is a collection of three classes to deal with: finite element, quadrature, and mapping objects. That's too much, so there is one type of class that orchestrates information exchange between these three: the <a class="el" href="classFEValues.html">FEValues</a> class. If given one instance of each three of these objects (or two, and an implicit linear mapping), it will be able to provide you with information about values and gradients of shape functions at quadrature points on a real cell.</p>
<p>Using all this, we will assemble the linear system for this problem in the following function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div></div><!-- fragment --><p>Ok, let's start: we need a quadrature formula for the evaluation of the integrals on each cell. Let's take a Gauss formula with two quadrature points in each direction, i.e. a total of four points since we are in 2D. This quadrature formula integrates polynomials of degrees up to three exactly (in 1D). It is easy to check that this is sufficient for the present problem:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div></div><!-- fragment --><p>And we initialize the object which we have briefly talked about above. It needs to be told which finite element we want to use, and the quadrature points and their weights (jointly described by a <a class="el" href="classQuadrature.html">Quadrature</a> object). As mentioned, we use the implied Q1 mapping, rather than specifying one ourselves explicitly. Finally, we have to tell it what we want it to compute on each cell: we need the values of the shape functions at the quadrature points (for the right hand side \((\varphi_i,f)\)), their gradients (for the matrix entries \((\nabla \varphi_i, \nabla \varphi_j)\)), and also the weights of the quadrature points and the determinants of the Jacobian transformations from the reference cell to the real cells.</p>
<p>This list of what kind of information we actually need is given as a collection of flags as the third argument to the constructor of <a class="el" href="classFEValues.html">FEValues</a>. Since these values have to be recomputed, or updated, every time we go to a new cell, all of these flags start with the prefix <code>update_</code> and then indicate what it actually is that we want updated. The flag to give if we want the values of the shape functions computed is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea" title="Shape function values. ">update_values</a>; for the gradients it is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20" title="Shape function gradients. ">update_gradients</a>. The determinants of the Jacobians and the quadrature weights are always used together, so only the products (Jacobians times weights, or short <code>JxW</code>) are computed; since we need them, we have to list <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85" title="Transformed quadrature weights. ">update_JxW_values</a> as well:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                      quadrature_formula,</div><div class="line">                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>The advantage of this approach is that we can specify what kind of information we actually need on each cell. It is easily understandable that this approach can significantly speed up finite element computations, compared to approaches where everything, including second derivatives, normal vectors to cells, etc are computed on each cell, regardless of whether they are needed or not.</p>
<dl class="section note"><dt>Note</dt><dd>The syntax <code>update_values | update_gradients | update_JxW_values</code> is not immediately obvious to anyone not used to programming bit operations in C for years already. First, <code>operator|</code> is the <em>bitwise or operator</em>, i.e., it takes two integer arguments that are interpreted as bit patterns and returns an integer in which every bit is set for which the corresponding bit is set in at least one of the two arguments. For example, consider the operation <code>9|10</code>. In binary, <code>9=0b1001</code> (where the prefix <code>0b</code> indicates that the number is to be interpreted as a binary number) and <code>10=0b1010</code>. Going through each bit and seeing whether it is set in one of the argument, we arrive at <code>0b1001|0b1010=0b1011</code> or, in decimal notation, <code>9|10=11</code>. The second piece of information you need to know is that the various <code>update_*</code> flags are all integers that have <em>exactly one bit set</em>. For example, assume that <code>update_values=0b00001=1</code>, <code>update_gradients=0b00010=2</code>, <code>update_JxW_values=0b10000=16</code>. Then <code>update_values | update_gradients | update_JxW_values = 0b10011 = 19</code>. In other words, we obtain a number that <em>encodes a binary mask representing all of the operations you want to happen</em>, where each operation corresponds to exactly one bit in the integer that, if equal to one, means that a particular piece should be updated on each cell and, if it is zero, means that we need not compute it. In other words, even though <code>operator|</code> is the <em>bitwise OR operation</em>, what it really represents is <em>I want this AND that AND the other</em>. Such binary masks are quite common in C programming, but maybe not so in higher level languages like C++, but serve the current purpose quite well.</dd></dl>
<p>For use further down below, we define a shortcut for a value that will be used very frequently. Namely, an abbreviation for the number of degrees of freedom on each cell (since we are in 2D and degrees of freedom are associated with vertices only, this number is four, but we rather want to write the definition of this variable in a way that does not preclude us from later choosing a different finite element that has a different number of degrees of freedom per cell, or work in a different space dimension).</p>
<p>In general, it is a good idea to use a symbolic name instead of hard-coding these numbers even if you know them, since for example, you may want to change the finite element at some time. Changing the element would have to be done in a different function and it is easy to forget to make a corresponding change in another part of the program. It is better to not rely on your own calculations, but instead ask the right object for the information: Here, we ask the finite element to tell us about the number of degrees of freedom per cell and we will get the correct number regardless of the space dimension or polynomial degree we may have chosen elsewhere in the program.</p>
<p>The shortcut here, defined primarily to discuss the basic concept and not because it saves a lot of typing, will then make the following loops a bit more readable. You will see such shortcuts in many places in larger programs, and <code>dofs_per_cell</code> is one that is more or less the conventional name for this kind of object.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div></div><!-- fragment --><p>Now, we said that we wanted to assemble the global matrix and vector cell-by-cell. We could write the results directly into the global matrix, but this is not very efficient since access to the elements of a sparse matrix is slow. Rather, we first compute the contribution of each cell in a small matrix with the degrees of freedom on the present cell, and only transfer them to the global matrix when the computations are finished for this cell. We do the same for the right hand side vector. So let's first allocate these objects (these being local objects, all degrees of freedom are coupling with all others, and we should use a full matrix object rather than a sparse one for the local operations; everything will be transferred to a global sparse matrix later on):</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div></div><!-- fragment --><p>When assembling the contributions of each cell, we do this with the local numbering of the degrees of freedom (i.e. the number running from zero through dofs_per_cell-1). However, when we transfer the result into the global matrix, we have to know the global numbers of the degrees of freedom. When we query them, we need a scratch (temporary) array for these numbers (see the discussion at the end of the introduction for the type, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, used here):</p>
<div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Now for the loop over all cells. We have seen before how this works for a triangulation. A <a class="el" href="classDoFHandler.html">DoFHandler</a> has cell iterators that are exactly analogous to those of a <a class="el" href="classTriangulation.html">Triangulation</a>, but with extra information about the degrees of freedom for the finite element you're using. Looping over the active cells of a degree-of-freedom handler works the same as for a triangulation.</p>
<p>Note that we declare the type of the cell as <code>const auto &amp;</code> instead of <code>auto</code> this time around. In step 1, we were modifying the cells of the triangulation by flagging them with refinement indicators. Here we're only examining the cells without modifying them, so it's good practice to declare <code>cell</code> as <code>const</code> in order to enforce this invariant.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><p>We are now sitting on one cell, and we would like the values and gradients of the shape functions be computed, as well as the determinants of the Jacobian matrices of the mapping between reference cell and true cell, at the quadrature points. Since all these values depend on the geometry of the cell, we have to have the <a class="el" href="classFEValues.html">FEValues</a> object re-compute them on each cell:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div></div><!-- fragment --><p>Next, reset the local cell's contributions to global matrix and global right hand side to zero, before we fill them:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">cell_rhs    = 0;</div></div><!-- fragment --><p>Now it is time to start integration over the cell, which we do by looping over all quadrature points, which we will number by q_index.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  {</div></div><!-- fragment --><p>First assemble the matrix: For the Laplace problem, the matrix on each cell is the integral over the gradients of shape function i and j. Since we do not integrate, but rather use quadrature, this is the sum over all quadrature points of the integrands times the determinant of the Jacobian matrix at the quadrature point times the weight of this quadrature point. You can get the gradient of shape function \(i\) at quadrature point with number q_index by using <code>fe_values.shape_grad(i,q_index)</code>; this gradient is a 2-dimensional vector (in fact it is of type <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;, with here dim=2) and the product of two such vectors is the scalar product, i.e. the product of the two shape_grad function calls is the dot product. This is in turn multiplied by the Jacobian determinant and the quadrature point weight (that one gets together by the call to <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a> ). Finally, this is repeated for all shape functions \(i\) and \(j\):</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div></div><!-- fragment --><p>We then do the same thing for the right hand side. Here, the integral is over the shape function i times the right hand side function, which we choose to be the function with constant value one (more interesting examples will be considered in the following programs).</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                    1. *                                <span class="comment">// f(x_q)</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">}</div></div><!-- fragment --><p>Now that we have the contribution of this cell, we have to transfer it to the global matrix and right hand side. To this end, we first have to find out which global numbers the degrees of freedom on this cell have. Let's simply ask the cell for that information:</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>Then again loop over all shape functions i and j and transfer the local elements to the global matrix. The global numbers can be obtained using local_dof_indices[i]:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    system_matrix.add(local_dof_indices[i],</div><div class="line">                      local_dof_indices[j],</div><div class="line">                      cell_matrix(i, j));</div></div><!-- fragment --><p>And again, we do the same thing for the right hand side vector.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">}</div></div><!-- fragment --><p>Now almost everything is set up for the solution of the discrete system. However, we have not yet taken care of boundary values (in fact, Laplace's equation without Dirichlet boundary values is not even uniquely solvable, since you can add an arbitrary constant to the discrete solution). We therefore have to do something about the situation.</p>
<p>For this, we first obtain a list of the degrees of freedom on the boundary and the value the shape function shall have there. For simplicity, we only interpolate the boundary value function, rather than projecting it onto the boundary. There is a function in the library which does exactly this: <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>. Its parameters are (omitting parameters for which default values exist and that we don't care about): the <a class="el" href="classDoFHandler.html">DoFHandler</a> object to get the global numbers of the degrees of freedom on the boundary; the component of the boundary where the boundary values shall be interpolated; the boundary value function itself; and the output object.</p>
<p>The component of the boundary is meant as follows: in many cases, you may want to impose certain boundary values only on parts of the boundary. For example, you may have inflow and outflow boundaries in fluid dynamics, or clamped and free parts of bodies in deformation computations of bodies. Then you will want to denote these different parts of the boundary by indicators, and tell the interpolate_boundary_values function to only compute the boundary values on a certain part of the boundary (e.g. the clamped part, or the inflow boundary). By default, all boundaries have a 0 boundary indicator, unless otherwise specified. If sections of the boundary have different boundary conditions, you have to number those parts with different boundary indicators. The function call below will then only determine boundary values for those parts of the boundary for which the boundary indicator is in fact the zero specified as the second argument.</p>
<p>The function describing the boundary values is an object of type <a class="el" href="classFunction.html">Function</a> or of a derived class. One of the derived classes is <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a>, which describes (not unexpectedly) a function which is zero everywhere. We create such an object in-place and pass it to the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function.</p>
<p>Finally, the output object is a list of pairs of global degree of freedom numbers (i.e. the number of the degrees of freedom on the boundary) and their boundary values (which are zero here for all entries). This mapping of DoF numbers to boundary values is done by the <code>std::map</code> class.</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                         boundary_values);</div></div><!-- fragment --><p>Now that we got the list of boundary DoFs and their respective boundary values, let's use them to modify the system of equations accordingly. This is done by the following function call:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3solve"></a> </p><h4>Step3::solve</h4>
<p>The following function simply solves the discretized equation. As the system is quite a large one for direct solvers such as Gauss elimination or LU decomposition, we use a Conjugate Gradient algorithm. You should remember that the number of variables here (only 1089) is a very small number for finite element computations, where 100.000 is a more usual number. For this number of variables, direct methods are no longer usable and you are forced to use methods like CG.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div></div><!-- fragment --><p>First, we need to have an object that knows how to tell the CG algorithm when to stop. This is done by using a <a class="el" href="classSolverControl.html">SolverControl</a> object, and as stopping criterion we say: stop after a maximum of 1000 iterations (which is far more than is needed for 1089 variables; see the results section to find out how many were really used), and stop if the norm of the residual is below \(10^{-12}\). In practice, the latter criterion will be the one which stops the iteration:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div></div><!-- fragment --><p>Then we need the solver itself. The template parameter to the <a class="el" href="classSolverCG.html">SolverCG</a> class is the type of the vectors, and leaving the empty angle brackets would indicate that we are taking the default argument (which is <code><a class="el" href="classVector.html">Vector</a>&lt;double&gt;</code>). However, we explicitly mention the template argument:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div></div><!-- fragment --><p>Now solve the system of equations. The CG solver takes a preconditioner as its fourth argument. We don't feel ready to delve into this yet, so we tell it to use the identity operation as preconditioner:</p>
<div class="fragment"><div class="line">solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>Now that the solver has done its job, the solution variable contains the nodal values of the solution function.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3output_results"></a> </p><h4>Step3::output_results</h4>
<p>The last part of a typical finite element program is to output the results and maybe do some postprocessing (for example compute the maximal stress values at the boundary, or the average flux across the outflow, etc). We have no such postprocessing here, but we would like to write the solution to a file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>To write the output to a file, we need an object which knows about output formats and the like. This is the <a class="el" href="classDataOut.html">DataOut</a> class, and we need an object of that type:</p>
<div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div></div><!-- fragment --><p>Now we have to tell it where to take the values from which it shall write. We tell it which <a class="el" href="classDoFHandler.html">DoFHandler</a> object to use, and the solution vector (and the name by which the solution variable shall appear in the output file). If we had more than one vector which we would like to look at in the output (for example right hand sides, errors per cell, etc) we would add them as well:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div></div><!-- fragment --><p>After the <a class="el" href="classDataOut.html">DataOut</a> object knows which data it is to work on, we have to tell it to process them into something the back ends can handle. The reason is that we have separated the frontend (which knows about how to treat <a class="el" href="classDoFHandler.html">DoFHandler</a> objects and data vectors) from the back end (which knows many different output formats) and use an intermediate data format to transfer data from the front- to the backend. The data is transformed into this intermediate format by the following function:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div></div><!-- fragment --><p>Now we have everything in place for the actual output. Just open a file and write the data into it, using VTK format (there are many other functions in the <a class="el" href="classDataOut.html">DataOut</a> class we are using here that can write the data in postscript, AVS, GMV, Gnuplot, or some other file formats):</p>
<div class="fragment"><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3run"></a> </p><h4>Step3::run</h4>
<p>Finally, the last function of this class is the main function which calls all the other functions of the <code>Step3</code> class. The order in which this is done resembles the order in which most finite element programs work. Since the names are mostly self-explanatory, there is not much to comment about:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>This is the main function of the program. Since the concept of a main function is mostly a remnant from the pre-object oriented era before C++ programming, it often does not do much more than creating an object of the top-level class and calling its principle function.</p>
<p>Finally, the first line of the function is used to enable output of some diagnostics that deal.II can generate. The <code>deallog</code> variable (which stands for deal-log, not de-allog) represents a stream to which some parts of the library write output. For example, iterative solvers will generate diagnostics (starting residual, number of solver steps, final residual) as can be seen when running this tutorial program.</p>
<p>The output of <code>deallog</code> can be written to the console, to a file, or both. Both are disabled by default since over the years we have learned that a program should only generate output when a user explicitly asks for it. But this can be changed, and to explain how this can be done, we need to explain how <code>deallog</code> works: When individual parts of the library want to log output, they open a "context" or "section" into which this output will be placed. At the end of the part that wants to write output, one exits this section again. Since a function may call another one from within the scope where this output section is open, output may in fact be nested hierarchically into these sections. The <a class="el" href="classLogStream.html">LogStream</a> class of which <code>deallog</code> is a variable calls each of these sections a "prefix" because all output is printed with this prefix at the left end of the line, with prefixes separated by colons. There is always a default prefix called "DEAL" (a hint at deal.II's history as the successor of a previous library called "DEAL" and from which the <a class="el" href="classLogStream.html">LogStream</a> class is one of the few pieces of code that were taken into deal.II).</p>
<p>By default, <code>logstream</code> only outputs lines with zero prefixes &ndash; i.e., all output is disabled because the default "DEAL" prefix is always there. But one can set a different maximal number of prefixes for lines that should be output to something larger, and indeed here we set it to two by calling <a class="el" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">LogStream::depth_console()</a>. This means that for all screen output, a context that has pushed one additional prefix beyond the default "DEAL" is allowed to print its output to the screen ("console"), whereas all further nested sections that would have three or more prefixes active would write to <code>deallog</code>, but <code>deallog</code> does not forward this output to the screen. Thus, running this example (or looking at the "Results" section), you will see the solver statistics prefixed with "DEAL:CG", which is two prefixes. This is sufficient for the context of the current program, but you will see examples later on (e.g., in <a class="el" href="step_22.html">step-22</a>) where solvers are nested more deeply and where you may get useful information by setting the depth even higher.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-3/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>程序的输出看起来如下。</p>
<div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">DEAL:cg::Starting value 0.121094</div><div class="line">DEAL:cg::Convergence step 48 value 5.33692e-13</div></div><!-- fragment --><p>前两行是我们写给 <code>cout</code> 的内容。最后两行是CG求解器在没有我们的干预下生成的。前两行说明了迭代开始时的残差，而最后一行告诉我们求解器需要47次迭代才能使残差的规范值达到5.3e-13，即低于我们在 "solve "函数中设置的阈值1e-12。我们将在下一个程序中展示如何抑制这种输出，这种输出有时对调试很有用，但往往会使屏幕显示变得混乱。</p>
<p>除了上面显示的输出，该程序还生成了文件 <code>solution.vtk</code> ，该文件为VTK格式，被当今许多可视化程序广泛使用&ndash;包括两个重量级的<a href="https://www.llnl.gov/visit">VisIt</a>和<a href="https://www.paraview.org">Paraview</a>，是当今最常使用的程序。</p>
<p>使用VisIt，生成一张像这样的解决方案的图片并不是很困难。 </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.solution-3.png" alt="Visualization of the solution of step-3"/>
</div>
   </td></tr>
</table>
<p>它同时显示了解和网格，根据每一点的解的值提升到 \(x\) - \(y\) 平面之上。当然，这里的解并不特别令人兴奋，但这是拉普拉斯方程所代表的内容和我们为这个程序选择的右手边 \(f(\mathbf x)=1\) 的结果。拉普拉斯方程描述了（在许多其他用途中）受外部（也是垂直）力作用的膜的垂直变形。在目前的例子中，膜的边界被夹在一个没有垂直变化的方形框架上；因此，一个恒定的力密度将直观地导致膜简单地向上隆起&ndash;就像上图所示。</p>
<p>VisIt和Paraview都允许玩各种可视化的解决方案。几个视频讲座展示了如何使用这些程序。 See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.11.html">video lecture 11</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.32.html">video lecture 32</a>.</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>如果你想用这个程序玩一玩，这里有几个建议。 </p>
<ul>
<li>
<p class="startli">改变几何图形和网格。在程序中，我们通过使用 <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code> 函数生成了一个方形域和网格。然而， <code><a class="el" href="namespaceGridGenerator.html">GridGenerator</a></code> 也有大量的其他函数。试试L形域，环形域，或其他你在那里找到的域。 </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">改变边界条件。代码使用 <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> 函数来生成零边界条件。然而，你可能想用 <code>ConstantFunction&lt;2&gt;(1)</code> 而不是 <code>ZeroFunction&lt;2&gt;()</code> 尝试非零常数边界值，以获得单位Dirichlet边界值。在函数命名空间的文档中描述了更多的奇异函数，你可以选择一个来描述你的特定边界值。 </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">修改边界条件的类型。目前，发生的情况是，我们在周围使用迪里希特边界值，因为默认情况是所有边界部分的边界指标为零，然后我们告诉 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> 函数，在所有指标为零的边界部分上将边界值插值为零。 </p>
<p>如果我们给边界的部分分配不同的指标，我们可以改变这种行为。例如，在调用 <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>:</p><div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>()-&gt;face(0)-&gt;set_boundary_id(1);</div></div><!-- fragment --><p>后立即尝试这样做。</p>
<p>这样做的目的是，首先要求三角剖分返回一个迭代器，指向第一个活动单元。当然，由于这是一个正方形的三角测量的粗略网格，此刻三角测量只有一个单元，而且它是活动的。接下来，我们要求单元格返回它的第一个面的迭代器，然后我们要求面将该面的边界指标重置为1。接下来的事情就是这样。当网格被细化时，子单元的面会继承其父母的边界指示器，也就是说，即使在最细的网格上，广场一侧的面的边界指示器为1。稍后，当我们要插值边界条件时， <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> 调用将只为那些边界指标为零的面产生边界值，而对那些具有不同边界指标的面则不予理会。这样做的目的是对前者施加Dirichlet边界条件，而对后者施加同质的Neumann条件（即解的法向导数为零，除非在变分等式的右侧添加额外的条款来处理潜在的非零Neumann条件）。如果你运行该程序，你会看到这一点。</p>
<p>另一种改变边界指标的方法是根据面中心的笛卡尔坐标来标注边界。 例如，我们可以通过检查单元格中心的y坐标是否在-1和1的公差（这里是1e-12）范围内，将沿上下边界的所有单元格标记为边界指示器1。在调用 <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, 后，像以前一样立即尝试这样做。</p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (-1.0)) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 ||</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()(1) - (1.0)) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12)</div><div class="line">    face-&gt;set_boundary_id(1);</div></div><!-- fragment --><p>虽然这段代码比以前长了一些，但它对复杂的几何形状很有用，因为它不需要脸部标签的知识。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">最后一点的一个小变化是像上面那样设置不同的边界值，但随后为边界指标一使用不同的边界值函数。在实践中，你要做的是为边界指标一增加对 <code>interpolate_boundary_values</code> 的第二次调用。</p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         1,</div><div class="line">                                         <a class="code" href="classFunctions_1_1ConstantFunction.html">ConstantFunction&lt;2&gt;</a>(1.),</div><div class="line">                                         boundary_values);</div></div><!-- fragment --><p>如果你在这个函数的第一个调用之后立即进行这个调用，那么它将把边界指标为1的面的边界值内插到单位值，并将这些内插值与之前计算的边界指标为0的值合并。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">观察收敛情况。我们将只讨论第7步中规范的计算误差，但很容易检查计算在这里已经收敛了。例如，我们可以在一个点上评估解的值，并比较不同的全局细化的值（全局细化的步骤数在上面的 <code>LaplaceProblem::make_grid</code> 中设定）。为了评估某个点的解决方案，例如在 \((\frac 13, \frac 13)\) ，我们可以在 <code>LaplaceProblem::output_results</code> 函数中加入以下代码。</p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Solution at (1/3,1/3): &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, solution,</div><div class="line">                                      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1./3, 1./3))</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>对于1到9个全局细化步骤，我们就会得到以下的点值序列。 </p><table align="center" class="doxtable">
<tr>
<th># of refinements </th><th>\(u_h(\frac 13,\frac13)\)  </th></tr>
<tr>
<td>1 </td><td>0.166667  </td></tr>
<tr>
<td>2 </td><td>0.227381  </td></tr>
<tr>
<td>3 </td><td>0.237375  </td></tr>
<tr>
<td>4 </td><td>0.240435  </td></tr>
<tr>
<td>5 </td><td>0.241140  </td></tr>
<tr>
<td>6 </td><td>0.241324  </td></tr>
<tr>
<td>7 </td><td>0.241369  </td></tr>
<tr>
<td>8 </td><td>0.241380  </td></tr>
<tr>
<td>9 </td><td>0.241383  </td></tr>
</table>
<p>通过注意到每两个连续值之间的差异减少了大约4倍，我们可以猜测 "正确 "的值可能是 \(u(\frac 13, \frac 13)\approx 0.241384\) 。事实上，如果我们假设这是正确的值，我们可以证明上面的序列确实显示了 \({\cal O}(h^2)\) 的收敛&amp;mdash；理论上，收敛顺序应该是 \({\cal O}(h^2 |\log h|)\) ，但是领域和网格的对称性可能导致了观察到的更好的收敛顺序。</p>
<p>这方面的一个小变种是用二次元重复测试。你需要做的就是在构造函数中把有限元的多项式程度设置为2 <code>LaplaceProblem::LaplaceProblem</code> 。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">平均值的收敛。一个不同的方法是计算解的平均数，以了解解是否真的收敛了（收敛到什么程度&amp;mdash；我们无法判断它是否真的是正确的值！）。为此，在 <code>LaplaceProblem::output_results</code> 中添加以下代码：</p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mean value: &quot;</span></div><div class="line">          &lt;&lt; VectorTools::compute_mean_value (dof_handler,</div><div class="line">                                              <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                              solution,</div><div class="line">                                              0)</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p class="endli">该函数的文档解释了第二和第四个参数的含义，而第一和第三个参数应该是很明显的。再次做同样的研究，我们改变了全局细化步骤的数量，我们得到以下结果。 </p><table align="center" class="doxtable">
<tr>
<th># of refinements </th><th>\(\int_\Omega u_h(x)\; dx\)  </th></tr>
<tr>
<td>0 </td><td>0.09375000  </td></tr>
<tr>
<td>1 </td><td>0.12790179  </td></tr>
<tr>
<td>2 </td><td>0.13733440  </td></tr>
<tr>
<td>3 </td><td>0.13976069  </td></tr>
<tr>
<td>4 </td><td>0.14037251  </td></tr>
<tr>
<td>5 </td><td>0.14052586  </td></tr>
<tr>
<td>6 </td><td>0.14056422  </td></tr>
<tr>
<td>7 </td><td>0.14057382  </td></tr>
<tr>
<td>8 </td><td>0.14057622  </td></tr>
</table>
<p>同样，两个相邻值之间的差异下降了约四倍，表明收敛为 \({\cal O}(h^2)\) 。 </p>
</li>
</ul>
<p><a class="anchor" id="UsingHDF5tooutputthesolutionandadditionaldata"></a></p><h3>Using HDF5 to output the solution and additional data</h3>
<p>HDF5是一种常用的格式，可以被许多脚本语言（如R或Python）读取。让deal.II产生一些HDF5文件并不困难，然后可以在外部脚本中使用，对该程序产生的一些数据进行后处理。这里有一些关于可能的想法。</p>
<p><a class="anchor" id="Changingtheoutputtoh5"></a></p><h4>Changing the output to .h5</h4>
<p>为了充分利用自动化，我们首先需要为全局细化步骤的数量引入一个私有变量 <code>unsigned int n_refinement_steps </code> ，它将被用于输出文件名。在 <code>make_grid()</code> we then replace <code>triangulation.refine_global(5);</code> 中用</p>
<div class="fragment"><div class="line">n_refinement_steps = 5;</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div></div><!-- fragment --><p>deal.II库有两个不同的HDF5绑定，一个在HDF5命名空间（用于对接通用数据文件），另一个在DataOut（专门用于为解决方案的可视化写文件）。尽管HDF5 deal.II绑定支持串行和MPI，但HDF5 DataOut绑定只支持并行输出。由于这个原因，我们需要初始化一个只有一个处理器的MPI通信器。这可以通过添加以下代码来实现。</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>接下来我们改变 <code>Step3::output_results()</code> 的输出例程，如DataOutBase命名空间文档中所述。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename_h5 = <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_refinement_steps) + <span class="stringliteral">&quot;.h5&quot;</span>;</div><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, filename_h5, MPI_COMM_WORLD);</div></div><!-- fragment --><p>然后，产生的文件可以被可视化，就像教程的原始版本产生的VTK文件一样；但是，由于HDF5是一种更通用的文件格式，它也可以很容易地用脚本语言处理，用于其他目的。</p>
<p><a class="anchor" id="Addingthepointvalueandthemeanseeextensionaboveintotheh5file"></a></p><h4>Adding the point value and the mean (see extension above) into the .h5 file</h4>
<p>在输出解决方案后，可以再次打开该文件以包括更多的数据集。 这使得我们可以将实验的所有必要信息保存在一个结果文件中，然后可以由一些后处理脚本来读取和处理。关于可能的输出选项，请看 HDF5::Group::write_dataset() 的进一步信息）。</p>
<p>为了实现这一点，我们首先将必要的头文件纳入我们的文件。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hdf5_8h.html">deal.II/base/hdf5.h</a>&gt;</span></div></div><!-- fragment --><p>在我们的输出例程的末尾添加以下几行，将关于某一点的解的值，以及解的平均值的信息添加到我们的HDF5文件中。</p>
<div class="fragment"><div class="line">HDF5::File data_file(filename_h5, HDF5::File::FileAccessMode::open, MPI_COMM_WORLD);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a>(1);</div><div class="line">point_value[0] = <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, solution,</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1./3, 1./3));</div><div class="line">data_file.write_dataset(<span class="stringliteral">&quot;point_value&quot;</span>, point_value);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> mean_value(1);</div><div class="line">mean_value[0] = VectorTools::compute_mean_value(dof_handler,</div><div class="line">                                                <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                                solution, 0);</div><div class="line">data_file.write_dataset(<span class="stringliteral">&quot;mean_value&quot;</span>,mean_value);</div></div><!-- fragment --><p><a class="anchor" id="UsingRandggplot2togenerateplots"></a></p><h3>Using R and ggplot2 to generate plots</h3>
<p>上述放入HDF5文件的数据，然后可以从脚本语言中使用，进行进一步的后处理。在下文中，让我们展示一下，特别是如何用<a href="https://en.wikipedia.org/wiki/R_(programming_language)">R programming language</a>这个在统计数据分析中广泛使用的语言来完成。(例如，类似的事情也可以在Python中完成。)如果你不熟悉R和ggplot2，你可以看看R的数据木工课程<a href="https://datacarpentry.org/R-ecology-lesson/index.html">here</a>。此外，由于大多数搜索引擎对 "R+主题 "这种形式的搜索很吃力，我们建议使用专门的服务<a href="http://rseek.org">RSeek </a>来代替。</p>
<p>R和其他语言最突出的区别是，赋值运算符（<code>a = 5</code>）通常被写成<code>a &lt;- 5</code>。由于后者被认为是标准的，我们将在我们的例子中也使用它。要在R语言中打开&lt;tt&gt;.h5文件，你必须安装<a href="https://bioconductor.org/packages/release/bioc/html/rhdf5.html">rhdf5</a>包，它是Bioconductor软件包的一部分。</p>
<p>首先，我们将包括所有必要的包，并看看我们文件中的数据是如何结构化的。</p>
<div class="fragment"><div class="line">library(rhdf5)     # library for handling HDF5 files</div><div class="line">library(ggplot2)   # main plotting library</div><div class="line">library(grDevices) # needed for output to PDF</div><div class="line">library(viridis)   # contains good colormaps for sequential data</div><div class="line"></div><div class="line"></div><div class="line">refinement &lt;- 5</div><div class="line">h5f &lt;- H5Fopen(paste(&quot;solution_&quot;,refinement,&quot;.h5&quot;,sep=&quot;&quot;))</div><div class="line">print(h5f)</div></div><!-- fragment --><p>这给出了以下输出</p>
<div class="fragment"><div class="line">HDF5 FILE</div><div class="line">   name /</div><div class="line">filename</div><div class="line"></div><div class="line"></div><div class="line">    name       otype  dclass     dim</div><div class="line">0 cells       H5I_DATASET INTEGER  x 1024</div><div class="line">1 mean_value  H5I_DATASET FLOAT   1</div><div class="line">2 nodes       H5I_DATASET FLOAT    x 1089</div><div class="line">3 point_value H5I_DATASET FLOAT   1</div><div class="line">4 solution    H5I_DATASET FLOAT    x 1089</div></div><!-- fragment --><p>数据集可以通过 <code>h5f$name</code> 访问。函数 <code>dim(h5f$cells)</code> 给我们提供了用于存储我们单元格的矩阵的尺寸。我们可以看到以下三个矩阵，以及我们添加的两个额外数据点。 </p><ul>
<li>
<code>cells</code> ：一个4x1024的矩阵，存储每个单元的（C++）顶点指数 </li>
<li>
<code>nodes</code> ：一个2x1089的矩阵，存储我们单元顶点的位置值（x，y） </li>
<li>
<code>solution</code> : 一个1x1089的矩阵，存储我们的解决方案在每个顶点的值 </li>
</ul>
<p>现在我们可以使用这些数据来生成各种图表。用ggplot2作图通常分为两步。首先，数据需要被处理并添加到一个 <code>data.frame</code> 。之后，构建一个 <code>ggplot</code> 对象，并通过向其添加绘图元素来进行操作。</p>
<p><code>nodes</code> and <code>cells</code> 包含我们绘制网格所需的所有信息。下面的代码将所有的数据打包成一个数据框架，用于绘制我们的网格。</p>
<div class="fragment"><div class="line"># Counting in R starts at 1 instead of 0, so we need to increment all</div><div class="line"># vertex indices by one:</div><div class="line">cell_ids &lt;- h5f@f$cells+1</div><div class="line"></div><div class="line"></div><div class="line"># Store the x and y positions of each vertex in one big vector in a</div><div class="line"># cell by cell fashion (every 4 entries belong to one cell):</div><div class="line">cells_x &lt;- h5f@f$nodes[1,][cell_ids]</div><div class="line">cells_y &lt;- h5f@f$nodes[2,][cell_ids]</div><div class="line"></div><div class="line"></div><div class="line"># Construct a vector that stores the matching cell by cell grouping</div><div class="line"># (1,1,1,1,2,2,2,2,...):</div><div class="line">groups &lt;- rep(1:ncol(cell_ids),each=4)</div><div class="line"></div><div class="line"></div><div class="line"># Finally put everything into one dataframe:</div><div class="line">meshdata &lt;- data.frame(x = cells_x, y = cells_y, id = groups)</div></div><!-- fragment --><p>有了完成的数据框架，我们就有了绘制网格所需的一切。</p>
<div class="fragment"><div class="line">pdf (paste(&quot;grid_&quot;,refinement,&quot;.pdf&quot;,sep=&quot;&quot;),width = 5,height = 5) # Open new PDF file</div><div class="line">plt &lt;- ggplot(meshdata,aes(x=x,y=y,group=id))                      # Construction of our plot</div><div class="line">                                                                   # object, at first only data</div><div class="line"></div><div class="line"></div><div class="line">plt &lt;- plt + geom_polygon(fill=&quot;white&quot;,colour=&quot;black&quot;)             # Actual plotting of the grid as polygons</div><div class="line">plt &lt;- plt + ggtitle(paste(&quot;grid at refinement level #&quot;,refinement))</div><div class="line"></div><div class="line"></div><div class="line">print(plt)                                                         # Show the current state of the plot/add it to the pdf</div><div class="line">dev.off()                                                          # Close PDF file</div></div><!-- fragment --><p>这个文件的内容看起来如下（不是很令人兴奋，但你会明白的）。 </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.grid_5.png" alt="Grid after 5 refinement steps of step-3"/>
</div>
   </td></tr>
</table>
<p>我们还可以将解决方案本身可视化，这看起来会更有趣。为了给我们的解决方案做一个二维伪色图，我们将使用 <code>geom_raster</code> 。这个函数需要一个结构化的网格，即在x和y方向上是均匀的。幸运的是，我们在这一点上的数据是以正确的方式结构化的。下面的代码将我们的曲面的伪彩色表示法绘制成一个新的PDF。</p>
<div class="fragment"><div class="line">pdf (paste(&quot;pseudocolor_&quot;,refinement,&quot;.pdf&quot;,sep=&quot;&quot;),width = 5,height = 4.2) # Open new PDF file</div><div class="line">colordata &lt;- data.frame(x = h5f@f$nodes[1,],y = h5f@f$nodes[2,] , solution = h5f@f$solution[1,])</div><div class="line">plt &lt;- ggplot(colordata,aes(x=x,y=y,fill=solution))</div><div class="line">plt &lt;- plt + geom_raster(interpolate=TRUE)</div><div class="line">plt &lt;- plt + scale_fill_viridis()</div><div class="line">plt &lt;- plt + ggtitle(paste(&quot;solution at refinement level #&quot;,refinement))</div><div class="line"></div><div class="line"></div><div class="line">print(plt)</div><div class="line">dev.off()</div><div class="line">H5Fclose(h5f) # Close the HDF5 file</div></div><!-- fragment --><p>现在的情况是这样的。 </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.pseudocolor_5.png" alt="Solution after 5 refinement steps of step-3"/>
</div>
   </td></tr>
</table>
<p>为了绘制收敛曲线，我们需要从1开始用不同的 <code>n_refinement_steps</code> 值多次重新运行C++代码。由于每个文件只包含一个数据点，我们需要对它们进行循环，并将结果串联成一个矢量。</p>
<div class="fragment"><div class="line">n_ref &lt;- 8   # Maximum refinement level for which results are existing</div><div class="line"></div><div class="line"></div><div class="line"># First we initiate all vectors with the results of the first level</div><div class="line">h5f   &lt;- H5Fopen(&quot;solution_1.h5&quot;)</div><div class="line">dofs  &lt;- dim(h5f@f$solution)[2]</div><div class="line">mean  &lt;- h5f@f$mean_value</div><div class="line">point &lt;- h5f@f$point_value</div><div class="line">H5Fclose(h5f)</div><div class="line"></div><div class="line"></div><div class="line">for (reflevel in 2:n_ref)</div><div class="line">{</div><div class="line">   h5f   &lt;- H5Fopen(paste(&quot;solution_&quot;,reflevel,&quot;.h5&quot;,sep=&quot;&quot;))</div><div class="line">   dofs  &lt;- c(dofs,dim(h5f$solution)[2])</div><div class="line">   mean  &lt;- c(mean,h5f$mean_value)</div><div class="line">   point &lt;- c(point,h5f$point_value)</div><div class="line">   H5Fclose(h5f)</div><div class="line">}</div></div><!-- fragment --><p>由于我们对数值本身不感兴趣，而是对与 "精确 "解决方案相比的误差感兴趣，我们将假设我们的最高细化水平是该解决方案，并从数据中省略它。</p>
<div class="fragment"><div class="line"># Calculate the error w.r.t. our maximum refinement step</div><div class="line">mean_error  &lt;- abs(mean[1:n_ref-1]-mean[n_ref])</div><div class="line">point_error &lt;- abs(point[1:n_ref-1]-point[n_ref])</div><div class="line"></div><div class="line"></div><div class="line"># Remove the highest value from our DoF data</div><div class="line">dofs     &lt;- dofs[1:n_ref-1]</div><div class="line">convdata &lt;- data.frame(dofs = dofs, mean_value= mean_error, point_value = point_error)</div></div><!-- fragment --><p>现在我们有所有的数据可以用来生成我们的图。在对数尺度上绘制误差往往是有用的，这在下面的代码中可以实现。</p>
<div class="fragment"><div class="line">pdf (paste(<span class="stringliteral">&quot;convergence.pdf&quot;</span>,sep=<span class="stringliteral">&quot;&quot;</span>),width = 5,height = 4.2)</div><div class="line">plt &lt;- ggplot(convdata,mapping=aes(x = dofs, y = mean_value))</div><div class="line">plt &lt;- plt+geom_line()</div><div class="line">plt &lt;- plt+labs(x=&quot;<span class="preprocessor">#DoFs&quot;,y = &quot;mean value error&quot;)</span></div><div class="line">plt &lt;- plt+scale_x_log10()+scale_y_log10()</div><div class="line">print(plt)</div><div class="line"></div><div class="line"></div><div class="line">plt &lt;- ggplot(convdata,mapping=aes(x = dofs, y = point_value))</div><div class="line">plt &lt;- plt+geom_line()</div><div class="line">plt &lt;- plt+labs(x=&quot;<span class="preprocessor">#DoFs&quot;,y = &quot;point value error&quot;)</span></div><div class="line">plt &lt;- plt+scale_x_log10()+scale_y_log10()</div><div class="line">print(plt)</div><div class="line"></div><div class="line"></div><div class="line">dev.off()</div></div><!-- fragment --><p>这就产生了下面的图，显示了均值和所选点的解值的误差如何很好地收敛到零。 </p><table style="width:50%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.convergence_mean.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.extensions.convergence_point.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, 1999,</span></div><div class="line"><span class="comment"> *          Guido Kanschat, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">Step3::Step3()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            1. *                                <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
