<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_4.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-4 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-4 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_3.html">step-3</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeStep4codeclasstemplate">The <code>Step4</code> class template</a>
        <li><a href="#Righthandsideandboundaryvalues">Right hand side and boundary values</a>
        <li><a href="#ImplementationofthecodeStep4codeclass">Implementation of the <code>Step4</code> class</a>
      <ul>
        <li><a href="#Step4Step4">Step4::Step4</a>
        <li><a href="#Step4make_grid">Step4::make_grid</a>
        <li><a href="#Step4setup_system">Step4::setup_system</a>
        <li><a href="#Step4assemble_system">Step4::assemble_system</a>
        <li><a href="#Step4solve">Step4::solve</a>
        <li><a href="#Step4output_results">Step4::output_results</a>
        <li><a href="#Step4run">Step4::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.12.html">video lecture 12</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.13.html">video lecture 13</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>deal.II has a unique feature which we call ``dimension independent programming''. You may have noticed in the previous examples that many classes had a number in angle brackets suffixed to them. This is to indicate that for example the triangulation in two and three space dimensions are different, but related data types. We could as well have called them <code>Triangulation2d</code> and <code>Triangulation3d</code> instead of <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2&gt;</code> and <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3&gt;</code> to name the two classes, but this has an important drawback: assume you have a function which does exactly the same functionality, but on 2d or 3d triangulations, depending on which dimension we would like to solve the equation in presently (if you don't believe that it is the common case that a function does something that is the same in all dimensions, just take a look at the code below - there are almost no distinctions between 2d and 3d!). We would have to write the same function twice, once working on <code>Triangulation2d</code> and once working with a <code>Triangulation3d</code>. This is an unnecessary obstacle in programming and leads to a nuisance to keep the two function in sync (at best) or difficult to find errors if the two versions get out of sync (at worst; this would probably the more common case).</p>
<p>Such obstacles can be circumvented by using some template magic as provided by the C++ language: templatized classes and functions are not really classes or functions but only a pattern depending on an as-yet undefined data type parameter or on a numerical value which is also unknown at the point of definition. However, the compiler can build proper classes or functions from these templates if you provide it with the information that is needed for that. Of course, parts of the template can depend on the template parameters, and they will be resolved at the time of compilation for a specific template parameter. For example, consider the following piece of code: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">};</div></div><!-- fragment --><p>At the point where the compiler sees this function, it does not know anything about the actual value of <code>dim</code>. The only thing the compiler has is a template, i.e. a blueprint, to generate functions <code>make_grid</code> if given a particular value of <code>dim</code>. Since <code>dim</code> has an unknown value, there is no code the compiler can generate for the moment.</p>
<p>However, if later down the compiler would encounter code that looks, for example, like this, </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">make_grid (triangulation);</div></div><!-- fragment --><p> then the compiler will deduce that the function <code>make_grid</code> for <code>dim==2</code> was requested and will compile the template above into a function with dim replaced by 2 everywhere, i.e. it will compile the function as if it were defined as </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">};</div></div><!-- fragment --><p>However, it is worth to note that the function <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code> depends on the dimension as well, so in this case, the compiler will call the function <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>&lt;2&gt;</code> while if dim were 3, it would call <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>&lt;3&gt;</code> which might be (and actually is) a totally unrelated function.</p>
<p>The same can be done with member variables. Consider the following function, which might in turn call the above one: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> make_grid_and_dofs (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  make_grid (triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler(triangulation);</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p> This function has a member variable of type <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;</code>. Again, the compiler can't compile this function until it knows for which dimension. If you call this function for a specific dimension as above, the compiler will take the template, replace all occurrences of dim by the dimension for which it was called, and compile it. If you call the function several times for different dimensions, it will compile it several times, each time calling the right <code>make_grid</code> function and reserving the right amount of memory for the member variable; note that the size of a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> might, and indeed does, depend on the space dimension.</p>
<p>The deal.II library is built around this concept of dimension-independent programming, and therefore allows you to program in a way that will not need to distinguish between the space dimensions. It should be noted that in only a very few places is it necessary to actually compare the dimension using <code>if</code>s or <code>switch</code>es. However, since the compiler has to compile each function for each dimension separately, even there it knows the value of <code>dim</code> at the time of compilation and will therefore be able to optimize away the <code>if</code> statement along with the unused branch.</p>
<p>In this example program, we will show how to program dimension independently (which in fact is even simpler than if you had to take care about the dimension) and we will extend the Laplace problem of the last example to a program that runs in two and three space dimensions at the same time. Other extensions are the use of a non-constant right hand side function and of non-zero boundary values.</p>
<dl class="section note"><dt>Note</dt><dd>When using templates, C++ imposes all sorts of syntax constraints that make it sometimes a bit difficult to understand why exactly something has to be written this way. A typical example is the need to use the keyword <code>typename</code> in so many places. If you are not entirely familiar with this already, then several of these difficulties are explained in the deal.II Frequently Asked Questions (FAQ) linked to from the <a href="http://www.dealii.org/">deal.II homepage</a>.</dd></dl>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first few (many?) include files have already been used in the previous example, so we will not explain their meaning here again.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This is new, however: in the previous example we got some unwanted output from the linear solvers. If we want to suppress it, we have to include this file and add a single line somewhere to the program (see the main() function below for that):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div></div><!-- fragment --><p>The final step, as in previous programs, is to import all the deal.II class and function names into the global namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep4codeclasstemplate"></a> </p><h3>The <code>Step4</code> class template</h3>
<p>This is again the same <code>Step4</code> class as in the previous example. The only difference is that we have now declared it as a class with a template parameter, and the template parameter is of course the spatial dimension in which we would like to solve the Laplace equation. Of course, several of the member variables depend on this dimension as well, in particular the <a class="el" href="classTriangulation.html">Triangulation</a> class, which has to represent quadrilaterals or hexahedra, respectively. Apart from this, everything is as before.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step4</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step4();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideandboundaryvalues"></a> </p><h3>Right hand side and boundary values</h3>
<p>In the following, we declare two more classes denoting the right hand side and the non-homogeneous Dirichlet boundary values. Both are functions of a dim-dimensional space variable, so we declare them as templates as well.</p>
<p>Each of these classes is derived from a common, abstract base class <a class="el" href="classFunction.html">Function</a>, which declares the common interface which all functions have to follow. In particular, concrete classes have to overload the <code>value</code> function, which takes a point in dim-dimensional space as parameters and returns the value at that point as a <code>double</code> variable.</p>
<p>The <code>value</code> function takes a second argument, which we have here named <code>component</code>: This is only meant for vector-valued functions, where you may want to access a certain component of the vector at the point <code>p</code>. However, our functions are scalar, so we need not worry about this parameter and we will not use it in the implementation of the functions. Inside the library's header files, the <a class="el" href="classFunction.html">Function</a> base class's declaration of the <code>value</code> function has a default value of zero for the component, so we will access the <code>value</code> function of the right hand side with only one parameter, namely the point where we want to evaluate the function. A value for the component can then simply be omitted for scalar functions.</p>
<p><a class="el" href="classFunction.html">Function</a> objects are used in lots of places in the library (for example, in <a class="el" href="step_3.html">step-3</a> we used a <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> instance as an argument to <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>) and this is the first tutorial where we define a new class that inherits from <a class="el" href="classFunction.html">Function</a>. Since we only ever call <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value()</a>, we could get away with just a plain function (and this is what is done in <a class="el" href="step_5.html">step-5</a>), but since this is a tutorial we inherit from <a class="el" href="classFunction.html">Function</a> for the sake of example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>If you are not familiar with what the keywords <code>virtual</code> and <code>override</code> in the function declarations above mean, you will probably want to take a look at your favorite C++ book or an online tutorial such as <a href="http://www.cplusplus.com/doc/tutorial/polymorphism/">http://www.cplusplus.com/doc/tutorial/polymorphism/</a> . In essence, what is happening here is that <a class="el" href="classFunction.html">Function&lt;dim&gt;</a> is an "abstract" base class that declares a certain "interface" &ndash; a set of functions one can call on objects of this kind. But it does not actually <em>implement</em> these functions: it just says "this is how Function objects look like", but what kind of function it actually is, is left to derived classes that implement the <code>value()</code> function.</p>
<p>Deriving one class from another is often called an "is-a" relationship function. Here, the <code>RightHandSide</code> class "is a" <a class="el" href="classFunction.html">Function</a> class because it implements the interface described by the <a class="el" href="classFunction.html">Function</a> base class. (The actual implementation of the <code>value()</code> function is in the code block below.) The <code>virtual</code> keyword then means "Yes, the
 function here is one that can be overridden by derived classes", and the <code>override</code> keyword means "Yes, this is in fact a function we know
 has been declared as part of the base class". The <code>override</code> keyword is not strictly necessary, but is an insurance against typos: If we get the name of the function or the type of one argument wrong, the compiler will warn us by stating "You say that this function overrides one in a base class, but I don't actually know any such function with this name and these arguments."</p>
<p>But back to the concrete case here: For this tutorial, we choose as right hand side the function \(4(x^4+y^4)\) in 2D, or \(4(x^4+y^4+z^4)\) in 3D. We could write this distinction using an if-statement on the space dimension, but here is a simple way that also allows us to use the same function in 1D (or in 4D, if you should desire to do so), by using a short loop. Fortunately, the compiler knows the size of the loop at compile time (remember that at the time when you define the template, the compiler doesn't know the value of <code>dim</code>, but when it later encounters a statement or declaration <code>RightHandSide&lt;2&gt;</code>, it will take the template, replace all occurrences of dim by 2 and compile the resulting function). In other words, at the time of compiling this function, the number of times the body will be executed is known, and the compiler can minimize the overhead needed for the loop; the result will be as fast as if we had used the formulas above right away.</p>
<p>The last thing to note is that a <code><a class="el" href="classPoint.html">Point</a>&lt;dim&gt;</code> denotes a point in dim-dimensional space, and its individual components (i.e. \(x\), \(y\), ... coordinates) can be accessed using the () operator (in fact, the [] operator will work just as well) with indices starting at zero as usual in C and C++.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    return_value += 4.0 * std::pow(p(i), 4.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>As boundary values, we choose \(x^2+y^2\) in 2D, and \(x^2+y^2+z^2\) in 3D. This happens to be equal to the square of the vector from the origin to the point at which we would like to evaluate the function, irrespective of the dimension. So that is what we return:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeStep4codeclass"></a> </p><h3>Implementation of the <code>Step4</code> class</h3>
<p>Next for the implementation of the class template that makes use of the functions above. As before, we will write everything as templates that have a formal parameter <code>dim</code> that we assume unknown at the time we define the template functions. Only later, the compiler will find a declaration of <code>Step4&lt;2&gt;</code> (in the <code>main</code> function, actually) and compile the entire class with <code>dim</code> replaced by 2, a process referred to as `instantiation of a template'. When doing so, it will also replace instances of <code>RightHandSide&lt;dim&gt;</code> by <code>RightHandSide&lt;2&gt;</code> and instantiate the latter class from the class template.</p>
<p>In fact, the compiler will also find a declaration <code>Step4&lt;3&gt;</code> in <code>main()</code>. This will cause it to again go back to the general <code>Step4&lt;dim&gt;</code> template, replace all occurrences of <code>dim</code>, this time by 3, and compile the class a second time. Note that the two instantiations <code>Step4&lt;2&gt;</code> and <code>Step4&lt;3&gt;</code> are completely independent classes; their only common feature is that they are both instantiated from the same general template, but they are not convertible into each other, for example, and share no code (both instantiations are compiled completely independently).</p>
<p><a class="anchor" id="Step4Step4"></a> </p><h4>Step4::Step4</h4>
<p>After this introduction, here is the constructor of the <code>Step4</code> class. It specifies the desired polynomial degree of the finite elements and associates the <a class="el" href="classDoFHandler.html">DoFHandler</a> to the triangulation just as in the previous example program, <a class="el" href="step_3.html">step-3</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step4&lt;dim&gt;::Step4()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step4make_grid"></a> </p><h4>Step4::make_grid</h4>
<p>Grid creation is something inherently dimension dependent. However, as long as the domains are sufficiently similar in 2D or 3D, the library can abstract for you. In our case, we would like to again solve on the square \([-1,1]\times [-1,1]\) in 2D, or on the cube \([-1,1] \times [-1,1] \times [-1,1]\) in 3D; both can be termed <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, so we may use the same function in whatever dimension we are. Of course, the functions that create a hypercube in two and three dimensions are very much different, but that is something you need not care about. Let the library handle the difficult things.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4setup_system"></a> </p><h4>Step4::setup_system</h4>
<p>This function looks exactly like in the previous example, although it performs actions that in their details are quite different if <code>dim</code> happens to be 3. The only significant difference from a user's perspective is the number of cells resulting, which is much higher in three than in two space dimensions!</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4assemble_system"></a> </p><h4>Step4::assemble_system</h4>
<p>Unlike in the previous example, we would now like to use a non-constant right hand side function and non-zero boundary values. Both are tasks that are readily achieved with only a few new lines of code in the assemblage of the matrix and right hand side.</p>
<p>More interesting, though, is the way we assemble matrix and right hand side vector dimension independently: there is simply no difference to the two-dimensional case. Since the important objects used in this function (quadrature formula, <a class="el" href="classFEValues.html">FEValues</a>) depend on the dimension by way of a template parameter as well, they can take care of setting up properly everything for the dimension for which this function is compiled. By declaring all classes which might depend on the dimension using a template parameter, the library can make nearly all work for you and you don't have to care about most things.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div></div><!-- fragment --><p>We wanted to have a non-constant right hand side, so we use an object of the class declared above to generate the necessary data. Since this right hand side object is only used locally in the present function, we declare it here as a local variable:</p>
<div class="fragment"><div class="line">RightHandSide&lt;dim&gt; right_hand_side;</div></div><!-- fragment --><p>Compared to the previous example, in order to evaluate the non-constant right hand side function we now also need the quadrature points on the cell we are presently on (previously, we only required values and gradients of the shape function from the <a class="el" href="classFEValues.html">FEValues</a> object, as well as the quadrature weights, <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a> ). We can tell the <a class="el" href="classFEValues.html">FEValues</a> object to do for us by also giving it the <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a" title="Transformed quadrature points. ">update_quadrature_points</a> flag:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>We then again define the same abbreviation as in the previous program. The value of this variable of course depends on the dimension which we are presently using, but the <a class="el" href="classFiniteElement.html">FiniteElement</a> class does all the necessary work for you and you don't have to care about the dimension dependent parts:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next, we again have to loop over all cells and assemble local contributions. Note, that a cell is a quadrilateral in two space dimensions, but a hexahedron in 3D. In fact, the <code>active_cell_iterator</code> data type is something different, depending on the dimension we are in, but to the outside world they look alike and you will probably never see a difference. In any case, the real type is hidden by using <code>auto</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    cell_matrix = 0;</div><div class="line">    cell_rhs    = 0;</div></div><!-- fragment --><p>Now we have to assemble the local matrix and right hand side. This is done exactly like in the previous example, but now we revert the order of the loops (which we can safely do since they are independent of each other) and merge the loops for the local matrix and the local vector as far as possible to make things a bit faster.</p>
<p>Assembling the right hand side presents the only significant difference to how we did things in <a class="el" href="step_3.html">step-3</a>: Instead of using a constant right hand side with value 1, we use the object representing the right hand side and evaluate it at the quadrature points:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;x_q = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index);</div><div class="line">      cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                      right_hand_side.value(x_q) *        <span class="comment">// f(x_q)</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">    }</div></div><!-- fragment --><p>As a final remark to these loops: when we assemble the local contributions into <code>cell_matrix(i,j)</code>, we have to multiply the gradients of shape functions \(i\) and \(j\) at point number q_index and multiply it with the scalar weights JxW. This is what actually happens: <code>fe_values.shape_grad(i,q_index)</code> returns a <code>dim</code> dimensional vector, represented by a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> object, and the operator* that multiplies it with the result of <code>fe_values.shape_grad(j,q_index)</code> makes sure that the <code>dim</code> components of the two vectors are properly contracted, and the result is a scalar floating point number that then is multiplied with the weights. Internally, this operator* makes sure that this happens correctly for all <code>dim</code> components of the vectors, whether <code>dim</code> be 2, 3, or any other space dimension; from a user's perspective, this is not something worth bothering with, however, making things a lot simpler if one wants to write code dimension independently.</p>
<p>With the local systems assembled, the transfer into the global matrix and right hand side is done exactly as before, but here we have again merged some loops for efficiency:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        system_matrix.add(local_dof_indices[i],</div><div class="line">                          local_dof_indices[j],</div><div class="line">                          cell_matrix(i, j));</div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>As the final step in this function, we wanted to have non-homogeneous boundary values in this example, unlike the one before. This is a simple task, we only have to replace the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> used there by an object of the class which describes the boundary values we would like to use (i.e. the <code>BoundaryValues</code> class declared above):</p>
<p>The function <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> will only work on faces that have been marked with boundary indicator 0 (because that's what we say the function should work on with the second argument below). If there are faces with boundary id other than 0, then the function interpolate_boundary_values will do nothing on these faces. For the Laplace equation doing nothing is equivalent to assuming that on those parts of the boundary a zero Neumann boundary condition holds.</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4solve"></a> </p><h4>Step4::solve</h4>
<p>Solving the linear system of equations is something that looks almost identical in most programs. In particular, it is dimension independent, so this function is copied verbatim from the previous example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>We have made one addition, though: since we suppress output from the linear solvers, we have to print the number of iterations by hand.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4output_results"></a> </p><h4>Step4::output_results</h4>
<p>This function also does what the respective one did in <a class="el" href="step_3.html">step-3</a>. No changes here for dimension independence either.</p>
<p>Since the program will run both 2d and 3d versions of the Laplace solver, we use the dimension in the filename to generate distinct filenames for each run (in a better program, one would check whether <code>dim</code> can have other values than 2 or 3, but we neglect this here for the sake of brevity).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(dim == 2 ? <span class="stringliteral">&quot;solution-2d.vtk&quot;</span> : <span class="stringliteral">&quot;solution-3d.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4run"></a> </p><h4>Step4::run</h4>
<p>This is the function which has the top-level control over everything. Apart from one line of additional output, it is the same as for the previous example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step4&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>And this is the main function. It also looks mostly like in <a class="el" href="step_3.html">step-3</a>, but if you look at the code below, note how we first create a variable of type <code>Step4&lt;2&gt;</code> (forcing the compiler to compile the class template with <code>dim</code> replaced by <code>2</code>) and run a 2d simulation, and then we do the whole thing over in 3d.</p>
<p>In practice, this is probably not what you would do very frequently (you probably either want to solve a 2d problem, or one in 3d, but not both at the same time). However, it demonstrates the mechanism by which we can simply change which dimension we want in a single place, and thereby force the compiler to recompile the dimension independent class templates for the dimension we request. The emphasis here lies on the fact that we only need to change a single place. This makes it rather trivial to debug the program in 2d where computations are fast, and then switch a single place to a 3 to run the much more computing intensive program in 3d for `real' computations.</p>
<p>Each of the two blocks is enclosed in braces to make sure that the <code>laplace_problem_2d</code> variable goes out of scope (and releases the memory it holds) before we move on to allocate memory for the 3d case. Without the additional braces, the <code>laplace_problem_2d</code> variable would only be destroyed at the end of the function, i.e. after running the 3d problem, and would needlessly hog memory while the 3d run could actually use it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  {</div><div class="line">    Step4&lt;2&gt; laplace_problem_2d;</div><div class="line">    laplace_problem_2d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Step4&lt;3&gt; laplace_problem_3d;</div><div class="line">    laplace_problem_3d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of the program looks as follows (the number of iterations may vary by one or two, depending on your computer, since this is often dependent on the round-off accuracy of floating point operations, which differs between processors): </p><div class="fragment"><div class="line">Solving problem in 2 space dimensions.</div><div class="line">   Number of active cells: 256</div><div class="line">   Total number of cells: 341</div><div class="line">   Number of degrees of freedom: 289</div><div class="line">   26 CG iterations needed to obtain convergence.</div><div class="line">Solving problem in 3 space dimensions.</div><div class="line">   Number of active cells: 4096</div><div class="line">   Total number of cells: 4681</div><div class="line">   Number of degrees of freedom: 4913</div><div class="line">   30 CG iterations needed to obtain convergence.</div></div><!-- fragment --><p> It is obvious that in three spatial dimensions the number of cells and therefore also the number of degrees of freedom is much higher. What cannot be seen here, is that besides this higher number of rows and columns in the matrix, there are also significantly more entries per row of the matrix in three space dimensions. Together, this leads to a much higher numerical effort for solving the system of equation, which you can feel in the run time of the two solution steps when you actually run the program.</p>
<p>The program produces two files: <code>solution-2d.vtk</code> and <code>solution-3d.vtk</code>, which can be viewed using the programs VisIt or Paraview (in case you do not have these programs, you can easily change the output format in the program to something which you can view more easily). Visualizing solutions is a bit of an art, but it can also be fun, so you should play around with your favorite visualization tool to get familiar with its functionality. Here's what I have come up with for the 2d solution:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.solution-2d.png"/>
</div>
 <p>(See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.11.html">video lecture 11</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.32.html">video lecture 32</a>.) The picture shows the solution of the problem under consideration as a 3D plot. As can be seen, the solution is almost flat in the interior of the domain and has a higher curvature near the boundary. This, of course, is due to the fact that for Laplace's equation the curvature of the solution is equal to the right hand side and that was chosen as a quartic polynomial which is nearly zero in the interior and is only rising sharply when approaching the boundaries of the domain; the maximal values of the right hand side function are at the corners of the domain, where also the solution is moving most rapidly. It is also nice to see that the solution follows the desired quadratic boundary values along the boundaries of the domain. It can also be useful to verify a computed solution against an analytical solution. For an explanation of this technique, see <a class="el" href="step_7.html">step-7</a>.</p>
<p>On the other hand, even though the picture does not show the mesh lines explicitly, you can see them as little kinks in the solution. This clearly indicates that the solution hasn't been computed to very high accuracy and that to get a better solution, we may have to compute on a finer mesh.</p>
<p>In three spatial dimensions, visualization is a bit more difficult. The left picture shows the solution and the mesh it was computed on on the surface of the domain. This is nice, but it has the drawback that it completely hides what is happening on the inside. The picture on the right is an attempt at visualizing the interior as well, by showing surfaces where the solution has constant values (as indicated by the legend at the top left). Isosurface pictures look best if one makes the individual surfaces slightly transparent so that it is possible to see through them and see what's behind.</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.solution-3d.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.contours-3d.png"/>
</div>
   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>A final remark on visualization: the idea of visualization is to give insight, which is not the same as displaying information. In particular, it is easy to overload a picture with information, but while it shows more information it makes it also more difficult to glean insight. As an example, the program I used to generate these pictures, VisIt, by default puts tick marks on every axis, puts a big fat label "X Axis" on the \(x\) axis and similar for the other axes, shows the file name from which the data was taken in the top left and the name of the user doing so and the time and date on the bottom right. None of this is important here: the axes are equally easy to make out because the tripod at the bottom left is still visible, and we know from the program that the domain is \([-1,1]^3\), so there is no need for tick marks. As a consequence, I have switched off all the extraneous stuff in the picture: the art of visualization is to reduce the picture to those parts that are important to see what one wants to see, but no more.</dd></dl>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Essentially the possibilities for playing around with the program are the same as for the previous one, except that they will now also apply to the 3d case. For inspiration read up on <a href="step_3.html#extensions" target="body">possible extensions in the documentation of step 3</a>.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step4</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step4();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    return_value += 4.0 * std::pow(p(i), 4.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step4&lt;dim&gt;::Step4()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;x_q = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index);</div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            right_hand_side.value(x_q) *        <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(dim == 2 ? <span class="stringliteral">&quot;solution-2d.vtk&quot;</span> : <span class="stringliteral">&quot;solution-3d.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step4&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  {</div><div class="line">    Step4&lt;2&gt; laplace_problem_2d;</div><div class="line">    laplace_problem_2d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Step4&lt;3&gt; laplace_problem_3d;</div><div class="line">    laplace_problem_3d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_3.html">step-3</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeStep4codeclasstemplate">The <code>Step4</code> class template</a><a href="#ThecodeStep4codeclasstemplate">The <code>Step4</code> class template</a>
        <li><a href="#Righthandsideandboundaryvalues">Right hand side and boundary values</a><a href="#Righthandsideandboundaryvalues">Right hand side and boundary values</a>
        <li><a href="#ImplementationofthecodeStep4codeclass">Implementation of the <code>Step4</code> class</a><a href="#ImplementationofthecodeStep4codeclass">Implementation of the <code>Step4</code> class</a>
      <ul>
        <li><a href="#Step4Step4">Step4::Step4</a><a href="#Step4Step4">Step4::Step4</a>
        <li><a href="#Step4make_grid">Step4::make_grid</a><a href="#Step4make_grid">Step4::make_grid</a>
        <li><a href="#Step4setup_system">Step4::setup_system</a><a href="#Step4setup_system">Step4::setup_system</a>
        <li><a href="#Step4assemble_system">Step4::assemble_system</a><a href="#Step4assemble_system">Step4::assemble_system</a>
        <li><a href="#Step4solve">Step4::solve</a><a href="#Step4solve">Step4::solve</a>
        <li><a href="#Step4output_results">Step4::output_results</a><a href="#Step4output_results">Step4::output_results</a>
        <li><a href="#Step4run">Step4::run</a><a href="#Step4run">Step4::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<pre class="fragment">@note The material presented here is also discussed in &lt;a href="http://www.math.colostate.edu/~bangerth/videos.676.12.html"&gt;video lecture 12&lt;/a&gt;, &lt;a href="http://www.math.colostate.edu/~bangerth/videos.676.13.html"&gt;video lecture 13&lt;/a&gt;. (All video lectures are also available &lt;a href="http://www.math.colostate.edu/~bangerth/videos.html"&gt;here&lt;/a&gt;.)  
</pre><p> deal.II has a unique feature which we call``dimension independent programming''. You may have noticed in theprevious examples that many classes had a number in angle bracketssuffixed to them. This is to indicate that for example thetriangulation in two and three space dimensions are different, butrelated data types. We could as well have called them <code>Triangulation2d</code> and <code>Triangulation3d</code> insteadof <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2&gt;</code> and <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3&gt;</code> to name the two classes, but thishas an important drawback: assume you have a function which doesexactly the same functionality, but on 2d or 3d triangulations,depending on which dimension we would like to solve the equation inpresently (if you don't believe that it is the common case that afunction does something that is the same in all dimensions, just takea look at the code below</p>
<ul>
<li>there are almost no distinctions between 2dand 3d!). We would have to write the same function twice, onceworking on <code>Triangulation2d</code> and once working with a <code>Triangulation3d</code> . This is an unnecessary obstacle inprogramming and leads to a nuisance to keep the two function in sync(at best) or difficult to find errors if the two versions get out ofsync (at worst; this would probably the more common case).</li>
</ul>
<p>Such obstacles can be circumvented by using some template magic asprovided by the C++ language: templatized classes and functions arenot really classes or functions but only a pattern depending on anas-yet undefined data type parameter or on a numerical value which isalso unknown at the point of definition. However, the compiler canbuild proper classes or functions from these templates if you provideit with the information that is needed for that. Of course, parts ofthe template can depend on the template parameters, and they will beresolved at the time of compilation for a specific templateparameter. For example, consider the following piece of code: </p><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation)</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation,</div><div class="line">  </div><div class="line">-1, 1);</div><div class="line">  };</div></div><!-- fragment --><p>At the point where the compiler sees this function, it does not knowanything about the actual value of <code>dim</code> . The only thing the compiler has isa template, i.e. a blueprint, to generatefunctions <code>make_grid</code> if given a particular value of <code>dim</code>. Since <code>dim</code> has an unknown value, there is nocode the compiler can generate for the moment.</p>
<p>However, if later down the compiler would encounter code that looks, forexample, like this, </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">make_grid (triangulation);</div></div><!-- fragment --><p> then the compiler will deduce that the function <code>make_grid</code> for <code>dim==2</code> wasrequested and will compile the template above into a function with dim replacedby 2 everywhere, i.e. it will compile the function as if it were definedas </p><div class="fragment"><div class="line">  <span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation,</div><div class="line">  </div><div class="line">-1, 1);</div><div class="line">  };</div></div><!-- fragment --><p>However, it is worth to note that the function <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code> depends on the dimension aswell, so in this case, the compiler will call the function <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>&lt;2&gt;</code> while if dim were 3,it would call <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>&lt;3&gt;</code> whichmight be (and actually is) a totally unrelated function.</p>
<p>The same can be done with member variables. Consider the followingfunction, which might in turn call the above one: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> make_grid_and_dofs (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  make_grid (triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler(triangulation);</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p> This function has a member variable of type <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;</code> . Again, the compiler can'tcompile this function until it knows for which dimension. If you callthis function for a specific dimension as above, the compiler willtake the template, replace all occurrences of dim by the dimension forwhich it was called, and compile it. If you call the function severaltimes for different dimensions, it will compile it several times, eachtime calling the right <code>make_grid</code> function and reserving the rightamount of memory for the member variable; note that the size of a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> might, and indeed does, depend on the space dimension.</p>
<p>The deal.II library is built around this conceptof dimension-independent programming, and therefore allows you to program ina way that will not need todistinguish between the space dimensions. It should be noted that inonly a very few places is it necessary to actually compare thedimension using <code>if</code>s or <code>switch</code> es. However, since the compilerhas to compile each function for each dimension separately, even thereit knows the value of <code>dim</code> at the time of compilation and willtherefore be able to optimize away the <code>if</code> statement along with theunused branch.</p>
<p>In this example program, we will show how to program dimensionindependently (which in fact is even simpler than if you had to takecare about the dimension) and we will extend the Laplace problem ofthe last example to a program that runs in two and three spacedimensions at the same time. Other extensions are the use of anon-constant right hand side function and of non-zero boundary values.</p>
<pre class="fragment">@note   When using templates, C++ imposes all sorts of syntax constraints thatmake it sometimes a bit difficult to understand why exactly something has tobe written this way. A typical example is the need to use the keyword  &lt;code&gt;typename&lt;/code&gt;   in so many places. If you are not entirely familiar withthis already, then several of these difficulties are explained in the deal.IIFrequently Asked Questions (FAQ) linked to from the &lt;a
</pre><p> href="http://www.dealii.org/"&gt;deal.II homepage.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first few (many?) include files have already been used in the previous example, so we will not explain their meaning here again.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This is new, however: in the previous example we got some unwanted output from the linear solvers. If we want to suppress it, we have to include this file and add a single line somewhere to the program (see the main() function below for that):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div></div><!-- fragment --><p>The final step, as in previous programs, is to import all the deal.II class and function names into the global namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep4codeclasstemplate"></a> </p><h3>The <code>Step4</code> class template</h3>
<p>This is again the same <code>Step4</code> class as in the previous example. The only difference is that we have now declared it as a class with a template parameter, and the template parameter is of course the spatial dimension in which we would like to solve the Laplace equation. Of course, several of the member variables depend on this dimension as well, in particular the <a class="el" href="classTriangulation.html">Triangulation</a> class, which has to represent quadrilaterals or hexahedra, respectively. Apart from this, everything is as before.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step4</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step4();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"> </div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"> </div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"> </div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"> </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideandboundaryvalues"></a> </p><h3>Right hand side and boundary values</h3>
<p>In the following, we declare two more classes denoting the right hand side and the non-homogeneous Dirichlet boundary values. Both are functions of a dim-dimensional space variable, so we declare them as templates as well.</p>
<p>Each of these classes is derived from a common, abstract base class <a class="el" href="classFunction.html">Function</a>, which declares the common interface which all functions have to follow. In particular, concrete classes have to overload the <code>value</code> function, which takes a point in dim-dimensional space as parameters and returns the value at that point as a <code>double</code> variable.</p>
<p>The <code>value</code> function takes a second argument, which we have here named <code>component</code> : This is only meant for vector-valued functions, where you may want to access a certain component of the vector at the point <code>p</code> . However, our functions are scalar, so we need not worry about this parameter and we will not use it in the implementation of the functions. Inside the library's header files, the <a class="el" href="classFunction.html">Function</a> base class's declaration of the <code>value</code> function has a default value of zero for the component, so we will access the <code>value</code> function of the right hand side with only one parameter, namely the point where we want to evaluate the function. A value for the component can then simply be omitted for scalar functions.</p>
<p><a class="el" href="classFunction.html">Function</a> objects are used in lots of places in the library (for example, in <a class="el" href="step_3.html">step-3</a> we used a <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> instance as an argument to <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>) and this is the first tutorial where we define a new class that inherits from <a class="el" href="classFunction.html">Function</a>. Since we only ever call <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value()</a>, we could get away with just a plain function (and this is what is done in <a class="el" href="step_5.html">step-5</a> ), but since this is a tutorial we inherit from <a class="el" href="classFunction.html">Function</a> for the sake of example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>If you are not familiar with what the keywords <code>virtual</code> and <code>override</code> in the function declarations above mean, you will probably want to take a look at your favorite C++ book or an online tutorial such as <a href="http://www.cplusplus.com/doc/tutorial/polymorphism/">http://www.cplusplus.com/doc/tutorial/polymorphism/</a> . In essence, what is happening here is that <a class="el" href="classFunction.html">Function&lt;dim&gt;</a> is an "abstract" base class that declares a certain "interface"</p>
<ul>
<li>a set of functions one can call on objects of this kind. But it does not actuallyimplement* these functions: it just says "this is how Function objects look like", but what kind of function it actually is, is left to derived classes that implement the <code>value()</code> function.</li>
</ul>
<p>Deriving one class from another is often called an "is-a" relationship function. Here, the <code>RightHandSide</code> class "is a" <a class="el" href="classFunction.html">Function</a> class because it implements the interface described by the <a class="el" href="classFunction.html">Function</a> base class. (The actual implementation of the <code>value()</code> function is in the code block below.) The <code>virtual</code> keyword then means "Yes, the function here is one that can be overridden by derived classes", and the <code>override</code> keyword means "Yes, this is in fact a function we know has been declared as part of the base class". The <code>override</code> keyword is not strictly necessary, but is an insurance against typos: If we get the name of the function or the type of one argument wrong, the compiler will warn us by stating "You say that this function overrides one in a base class, but I don't actually know any such function with this name and these arguments."</p>
<p>But back to the concrete case here: For this tutorial, we choose as right hand side the function \(4(x^4+y^4)\) in 2D, or \(4(x^4+y^4+z^4)\) in 3D. We could write this distinction using an if-statement on the space dimension, but here is a simple way that also allows us to use the same function in 1D (or in 4D, if you should desire to do so), by using a short loop. Fortunately, the compiler knows the size of the loop at compile time (remember that at the time when you define the template, the compiler doesn't know the value of <code>dim</code> , but when it later encounters a statement or declaration <code>RightHandSide&lt;2&gt;</code> , it will take the template, replace all occurrences of dim by 2 and compile the resulting function). In other words, at the time of compiling this function, the number of times the body will be executed is known, and the compiler can minimize the overhead needed for the loop; the result will be as fast as if we had used the formulas above right away.</p>
<p>The last thing to note is that a <code><a class="el" href="classPoint.html">Point</a>&lt;dim&gt;</code> denotes a point in dim-dimensional space, and its individual components (i.e. \(x\) , \(y\) , ... coordinates) can be accessed using the () operator (in fact, the [] operator will work just as well) with indices starting at zero as usual in C and C++.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    return_value += 4.0 std::pow(p(i), 4.0);</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>As boundary values, we choose \(x^2+y^2\) in 2D, and \(x^2+y^2+z^2\) in 3D. This happens to be equal to the square of the vector from the origin to the point at which we would like to evaluate the function, irrespective of the dimension. So that is what we return:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeStep4codeclass"></a> </p><h3>Implementation of the <code>Step4</code> class</h3>
<p>Next for the implementation of the class template that makes use of the functions above. As before, we will write everything as templates that have a formal parameter <code>dim</code> that we assume unknown at the time we define the template functions. Only later, the compiler will find a declaration of <code>Step4&lt;2&gt;</code> (in the <code>main</code> function, actually) and compile the entire class with <code>dim</code> replaced by 2, a process referred to as `instantiation of a template'. When doing so, it will also replace instances of <code>RightHandSide&lt;dim&gt;</code> by <code>RightHandSide&lt;2&gt;</code> and instantiate the latter class from the class template.</p>
<p>In fact, the compiler will also find a declaration <code>Step4&lt;3&gt;</code> in <code>main()</code> . This will cause it to again go back to the general <code>Step4&lt;dim&gt;</code> template, replace all occurrences of <code>dim</code> , this time by 3, and compile the class a second time. Note that the two instantiations <code>Step4&lt;2&gt;</code> and <code>Step4&lt;3&gt;</code> are completely independent classes; their only common feature is that they are both instantiated from the same general template, but they are not convertible into each other, for example, and share no code (both instantiations are compiled completely independently).</p>
<p><a class="anchor" id="Step4Step4"></a> </p><h4>Step4::Step4</h4>
<p>After this introduction, here is the constructor of the <code>Step4</code> class. It specifies the desired polynomial degree of the finite elements and associates the <a class="el" href="classDoFHandler.html">DoFHandler</a> to the triangulation just as in the previous example program, <a class="el" href="step_3.html">step-3</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step4&lt;dim&gt;::Step4()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step4make_grid"></a> </p><h4>Step4::make_grid</h4>
<p>Grid creation is something inherently dimension dependent. However, as long as the domains are sufficiently similar in 2D or 3D, the library can abstract for you. In our case, we would like to again solve on the square \([-1,1]\times [-1,1]\) in 2D, or on the cube \([-1,1] \times [-1,1] \times [-1,1]\) in 3D; both can be termed <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, so we may use the same function in whatever dimension we are. Of course, the functions that create a hypercube in two and three dimensions are very much different, but that is something you need not care about. Let the library handle the difficult things.</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"> <span class="keywordtype">void</span> Step4&lt;dim&gt;::make_grid()</div><div class="line"> {</div><div class="line">   <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation,</div><div class="line">  </div><div class="line">-1, 1);</div><div class="line">   triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line">  </div><div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">             &lt;&lt; std::endl</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">             &lt;&lt; std::endl;</div><div class="line"> }</div></div><!-- fragment --><p><a class="anchor" id="Step4setup_system"></a> </p><h4>Step4::setup_system</h4>
<p>This function looks exactly like in the previous example, although it performs actions that in their details are quite different if <code>dim</code> happens to be 3. The only significant difference from a user's perspective is the number of cells resulting, which is much higher in three than in two space dimensions!</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"> </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"> </div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"> </div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4assemble_system"></a> </p><h4>Step4::assemble_system</h4>
<p>Unlike in the previous example, we would now like to use a non-constant right hand side function and non-zero boundary values. Both are tasks that are readily achieved with only a few new lines of code in the assemblage of the matrix and right hand side.</p>
<p>More interesting, though, is the way we assemble matrix and right hand side vector dimension independently: there is simply no difference to the two-dimensional case. Since the important objects used in this function (quadrature formula, <a class="el" href="classFEValues.html">FEValues</a>) depend on the dimension by way of a template parameter as well, they can take care of setting up properly everything for the dimension for which this function is compiled. By declaring all classes which might depend on the dimension using a template parameter, the library can make nearly all work for you and you don't have to care about most things.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div></div><!-- fragment --><p>We wanted to have a non-constant right hand side, so we use an object of the class declared above to generate the necessary data. Since this right hand side object is only used locally in the present function, we declare it here as a local variable:</p>
<div class="fragment"><div class="line">RightHandSide&lt;dim&gt; right_hand_side;</div></div><!-- fragment --><p>Compared to the previous example, in order to evaluate the non-constant right hand side function we now also need the quadrature points on the cell we are presently on (previously, we only required values and gradients of the shape function from the <a class="el" href="classFEValues.html">FEValues</a> object, as well as the quadrature weights, <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a> ). We can tell the <a class="el" href="classFEValues.html">FEValues</a> object to do for us by also giving it the <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a" title="Transformed quadrature points. ">update_quadrature_points</a> flag:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>We then again define the same abbreviation as in the previous program. The value of this variable of course depends on the dimension which we are presently using, but the <a class="el" href="classFiniteElement.html">FiniteElement</a> class does all the necessary work for you and you don't have to care about the dimension dependent parts:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next, we again have to loop over all cells and assemble local contributions. Note, that a cell is a quadrilateral in two space dimensions, but a hexahedron in 3D. In fact, the <code>active_cell_iterator</code> data type is something different, depending on the dimension we are in, but to the outside world they look alike and you will probably never see a difference. In any case, the real type is hidden by using <code>auto</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    cell_matrix = 0;</div><div class="line">    cell_rhs    = 0;</div></div><!-- fragment --><p>Now we have to assemble the local matrix and right hand side. This is done exactly like in the previous example, but now we revert the order of the loops (which we can safely do since they are independent of each other) and merge the loops for the local matrix and the local vector as far as possible to make things a bit faster. Assembling the right hand side presents the only significant difference to how we did things in <a class="el" href="step_3.html">step-3</a> : Instead of using a constant right hand side with value 1, we use the object representing the right hand side and evaluate it at the quadrature points:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) <span class="comment">// grad phi_i(x_q)</span></div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) <span class="comment">// grad phi_j(x_q)</span></div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;x_q = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index);</div><div class="line">      cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) <span class="comment">// phi_i(x_q)</span></div><div class="line">                      right_hand_side.value(x_q)        <span class="comment">// f(x_q)</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">    }</div></div><!-- fragment --><p>As a final remark to these loops: when we assemble the local contributions into <code>cell_matrix(i,j)</code> , we have to multiply the gradients of shape functions \(i\) and \(j\) at point number q_index and multiply it with the scalar weights JxW. This is what actually happens: <code>fe_values.shape_grad(i,q_index)</code> returns a <code>dim</code> dimensional vector, represented by a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> object, and the operator* that multiplies it with the result of <code>fe_values.shape_grad(j,q_index)</code> makes sure that the <code>dim</code> components of the two vectors are properly contracted, and the result is a scalar floating point number that then is multiplied with the weights. Internally, this operator* makes sure that this happens correctly for all <code>dim</code> components of the vectors, whether <code>dim</code> be 2, 3, or any other space dimension; from a user's perspective, this is not something worth bothering with, however, making things a lot simpler if one wants to write code dimension independently.</p>
<p>With the local systems assembled, the transfer into the global matrix and right hand side is done exactly as before, but here we have again merged some loops for efficiency:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        system_matrix.add(local_dof_indices[i],</div><div class="line">                          local_dof_indices[j],</div><div class="line">                          cell_matrix(i, j));</div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>As the final step in this function, we wanted to have non-homogeneous boundary values in this example, unlike the one before. This is a simple task, we only have to replace the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> used there by an object of the class which describes the boundary values we would like to use (i.e. the <code>BoundaryValues</code> class declared above): The function <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> will only work on faces that have been marked with boundary indicator 0 (because that's what we say the function should work on with the second argument below). If there are faces with boundary id other than 0, then the function interpolate_boundary_values will do nothing on these faces. For the Laplace equation doing nothing is equivalent to assuming that on those parts of the boundary a zero Neumann boundary condition holds.</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4solve"></a> </p><h4>Step4::solve</h4>
<p>Solving the linear system of equations is something that looks almost identical in most programs. In particular, it is dimension independent, so this function is copied verbatim from the previous example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>We have made one addition, though: since we suppress output from the linear solvers, we have to print the number of iterations by hand.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4output_results"></a> </p><h4>Step4::output_results</h4>
<p>This function also does what the respective one did in <a class="el" href="step_3.html">step-3</a> . No changes here for dimension independence either.</p>
<p>Since the program will run both 2d and 3d versions of the Laplace solver, we use the dimension in the filename to generate distinct filenames for each run (in a better program, one would check whether <code>dim</code> can have other values than 2 or 3, but we neglect this here for the sake of brevity).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"> </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"> </div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"> </div><div class="line">  std::ofstream output(dim == 2 ? <span class="stringliteral">&quot;solution-2d.vtk&quot;</span> : <span class="stringliteral">&quot;solution-3d.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4run"></a> </p><h4>Step4::run</h4>
<p>This is the function which has the top-level control over everything. Apart from one line of additional output, it is the same as for the previous example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step4&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>And this is the main function. It also looks mostly like in <a class="el" href="step_3.html">step-3</a> , but if you look at the code below, note how we first create a variable of type <code>Step4&lt;2&gt;</code> (forcing the compiler to compile the class template with <code>dim</code> replaced by <code>2</code> ) and run a 2d simulation, and then we do the whole thing over in 3d.</p>
<p>In practice, this is probably not what you would do very frequently (you probably either want to solve a 2d problem, or one in 3d, but not both at the same time). However, it demonstrates the mechanism by which we can simply change which dimension we want in a single place, and thereby force the compiler to recompile the dimension independent class templates for the dimension we request. The emphasis here lies on the fact that we only need to change a single place. This makes it rather trivial to debug the program in 2d where computations are fast, and then switch a single place to a 3 to run the much more computing intensive program in 3d for `real' computations.</p>
<p>Each of the two blocks is enclosed in braces to make sure that the <code>laplace_problem_2d</code> variable goes out of scope (and releases the memory it holds) before we move on to allocate memory for the 3d case. Without the additional braces, the <code>laplace_problem_2d</code> variable would only be destroyed at the end of the function, i.e. after running the 3d problem, and would needlessly hog memory while the 3d run could actually use it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  {</div><div class="line">    Step4&lt;2&gt; laplace_problem_2d;</div><div class="line">    laplace_problem_2d.run();</div><div class="line">  }</div><div class="line"> </div><div class="line">  {</div><div class="line">    Step4&lt;3&gt; laplace_problem_3d;</div><div class="line">    laplace_problem_3d.run();</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of the program looks as follows (the number of iterationsmay vary by one or two, depending on your computer, since this isoften dependent on the round-off accuracy of floating pointoperations, which differs between processors): </p><div class="fragment"><div class="line">Solving problem in 2 space dimensions.</div><div class="line">   Number of active cells: 256</div><div class="line">   Total number of cells: 341</div><div class="line">   Number of degrees of freedom: 289</div><div class="line">   26 CG iterations needed to obtain convergence.</div><div class="line">Solving problem in 3 space dimensions.</div><div class="line">   Number of active cells: 4096</div><div class="line">   Total number of cells: 4681</div><div class="line">   Number of degrees of freedom: 4913</div><div class="line">   30 CG iterations needed to obtain convergence.</div></div><!-- fragment --><p> It is obvious that in three spatial dimensions the number of cells andtherefore also the number of degrees of freedom ismuch higher. What cannot be seen here, is that besides this highernumber of rows and columns in the matrix, there are also significantlymore entries per row of the matrix in three spacedimensions. Together, this leads to a much higher numerical effort forsolving the system of equation, which you can feel in the run time of the twosolution steps when you actually run the program.</p>
<p>The program produces two files: <code>solution-2d.vtk</code> and <code>solution-3d.vtk</code> , which can be viewed using the programsVisIt or Paraview (in case you do not have these programs, you can easilychange theoutput format in the program to something which you can view moreeasily). Visualizing solutions is a bit of an art, but it can also be fun, soyou should play around with your favorite visualization tool to get familiarwith its functionality. Here's what I have come up with for the 2d solution: </p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.solution-2d.png"/>
</div>
 <p>( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.11.html">video lecture 11</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.32.html">video lecture 32</a>.) The picture shows the solution of the problem under consideration asa 3D plot. As can be seen, the solution is almost flat in the interiorof the domain and has a higher curvature near the boundary. This, ofcourse, is due to the fact that for Laplace's equation the curvatureof the solution is equal to the right hand side and that was chosen asa quartic polynomial which is nearly zero in the interior and is onlyrising sharply when approaching the boundaries of the domain; themaximal values of the right hand side function are at the corners ofthe domain, where also the solution is moving most rapidly.It is also nice to see that the solution follows the desired quadraticboundary values along the boundaries of the domain.It can also be useful to verify a computed solution against an analyticalsolution. For an explanation of this technique, see <a class="el" href="step_7.html">step-7</a> . On the other hand, even though the picture does not show the mesh linesexplicitly, you can see them as little kinks in the solution. This clearlyindicates that the solution hasn't been computed to very high accuracy andthat to get a better solution, we may have to compute on a finer mesh. In three spatial dimensions, visualization is a bit more difficult. The leftpicture shows the solution and the mesh it was computed on on the surface ofthe domain. This is nice, but it has the drawback that it completely hideswhat is happening on the inside. The picture on the right is an attempt atvisualizing the interior as well, by showing surfaces where the solution hasconstant values (as indicated by the legend at the top left). Isosurfacepictures look best if one makes the individual surfaces slightly transparentso that it is possible to see through them and see what's behind. </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.solution-3d.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.contours-3d.png"/>
</div>
   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>A final remark on visualization: the idea of visualization is to give insight,which is not the same as displaying information. In particular, it is easy tooverload a picture with information, but while it shows more information itmakes it also more difficult to glean insight. As an example, the program Iused to generate these pictures, VisIt, by default puts tick marks on everyaxis, puts a big fat label "X Axis" on the \(x\) axis and similar for the otheraxes, shows the file name from which the data was taken in the top left andthe name of the user doing so and the time and date on the bottom right. Noneof this is importanthere: the axes are equally easy to make out because the tripod at the bottomleft is still visible, and we know from the program that the domain is \([-1,1]^3\) , so there is no need for tick marks. As a consequence, I haveswitched off all the extraneous stuff in the picture: the art of visualizationis to reduce the picture to those parts that are important to see what onewants to see, but no more.</dd></dl>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Essentially the possibilities for playing around with the program are the sameas for the previous one, except that they will now also apply to the 3dcase. For inspiration read up on <a href="step_3.html#extensions" target="body">possible extensions in the documentation of step 3</a>.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step4</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step4();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    return_value += 4.0 * std::pow(p(i), 4.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step4&lt;dim&gt;::Step4()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;x_q = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index);</div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            right_hand_side.value(x_q) *        <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(dim == 2 ? <span class="stringliteral">&quot;solution-2d.vtk&quot;</span> : <span class="stringliteral">&quot;solution-3d.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step4&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  {</div><div class="line">    Step4&lt;2&gt; laplace_problem_2d;</div><div class="line">    laplace_problem_2d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Step4&lt;3&gt; laplace_problem_3d;</div><div class="line">    laplace_problem_3d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_3.html">step-3</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeStep4codeclasstemplate">The <code>Step4</code> class template</a>
        <li><a href="#Righthandsideandboundaryvalues">Right hand side and boundary values</a>
        <li><a href="#ImplementationofthecodeStep4codeclass">Implementation of the <code>Step4</code> class</a>
      <ul>
        <li><a href="#Step4Step4">Step4::Step4</a>
        <li><a href="#Step4make_grid">Step4::make_grid</a>
        <li><a href="#Step4setup_system">Step4::setup_system</a>
        <li><a href="#Step4assemble_system">Step4::assemble_system</a>
        <li><a href="#Step4solve">Step4::solve</a>
        <li><a href="#Step4output_results">Step4::output_results</a>
        <li><a href="#Step4run">Step4::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-4/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.12.html">video lecture 12</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.13.html">video lecture 13</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>deal.II "" <code>Triangulation2d</code> and <code>Triangulation3d</code>  <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2&gt;</code>  <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3&gt;</code> 2D3D2D3D <code>Triangulation2d</code>  <code>Triangulation3d</code> </p>
<p>C++</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">};</div></div><!-- fragment --><p> <code>dim</code>  <code>make_grid</code> </p>
<p></p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">make_grid (triangulation);</div></div><!-- fragment --><p> <code>make_grid</code>  <code>dim==2</code> 2dim</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">};</div></div><!-- fragment --><p> <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code>  <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>&lt;2&gt;</code> dim3 <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>&lt;3&gt;</code> </p>
<p></p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> make_grid_and_dofs (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  make_grid (triangulation);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler(triangulation);</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p> <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;</code> dim <code>make_grid</code>  <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> </p>
<p>deal.II <code>if</code>s or <code>switch</code> es <code>dim</code>  <code>if</code> </p>
<p></p>
<dl class="section note"><dt>Note</dt><dd>C++ <code>typename</code> <a href="http://www.dealii.org/">deal.II homepage</a>deal.IIFAQ</dd></dl>
<p>&lt;&ndash;</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first few (many?) include files have already been used in the previous example, so we will not explain their meaning here again.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This is new, however: in the previous example we got some unwanted output from the linear solvers. If we want to suppress it, we have to include this file and add a single line somewhere to the program (see the main() function below for that):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div></div><!-- fragment --><p>The final step, as in previous programs, is to import all the deal.II class and function names into the global namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep4codeclasstemplate"></a> </p><h3>The <code>Step4</code> class template</h3>
<p>This is again the same <code>Step4</code> class as in the previous example. The only difference is that we have now declared it as a class with a template parameter, and the template parameter is of course the spatial dimension in which we would like to solve the Laplace equation. Of course, several of the member variables depend on this dimension as well, in particular the <a class="el" href="classTriangulation.html">Triangulation</a> class, which has to represent quadrilaterals or hexahedra, respectively. Apart from this, everything is as before.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step4</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step4();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideandboundaryvalues"></a> </p><h3>Right hand side and boundary values</h3>
<p>In the following, we declare two more classes denoting the right hand side and the non-homogeneous Dirichlet boundary values. Both are functions of a dim-dimensional space variable, so we declare them as templates as well.</p>
<p>Each of these classes is derived from a common, abstract base class <a class="el" href="classFunction.html">Function</a>, which declares the common interface which all functions have to follow. In particular, concrete classes have to overload the <code>value</code> function, which takes a point in dim-dimensional space as parameters and returns the value at that point as a <code>double</code> variable.</p>
<p>The <code>value</code> function takes a second argument, which we have here named <code>component</code>: This is only meant for vector-valued functions, where you may want to access a certain component of the vector at the point <code>p</code>. However, our functions are scalar, so we need not worry about this parameter and we will not use it in the implementation of the functions. Inside the library's header files, the <a class="el" href="classFunction.html">Function</a> base class's declaration of the <code>value</code> function has a default value of zero for the component, so we will access the <code>value</code> function of the right hand side with only one parameter, namely the point where we want to evaluate the function. A value for the component can then simply be omitted for scalar functions.</p>
<p><a class="el" href="classFunction.html">Function</a> objects are used in lots of places in the library (for example, in <a class="el" href="step_3.html">step-3</a> we used a <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> instance as an argument to <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>) and this is the first tutorial where we define a new class that inherits from <a class="el" href="classFunction.html">Function</a>. Since we only ever call <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value()</a>, we could get away with just a plain function (and this is what is done in <a class="el" href="step_5.html">step-5</a>), but since this is a tutorial we inherit from <a class="el" href="classFunction.html">Function</a> for the sake of example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>If you are not familiar with what the keywords <code>virtual</code> and <code>override</code> in the function declarations above mean, you will probably want to take a look at your favorite C++ book or an online tutorial such as <a href="http://www.cplusplus.com/doc/tutorial/polymorphism/">http://www.cplusplus.com/doc/tutorial/polymorphism/</a> . In essence, what is happening here is that <a class="el" href="classFunction.html">Function&lt;dim&gt;</a> is an "abstract" base class that declares a certain "interface" &ndash; a set of functions one can call on objects of this kind. But it does not actually <em>implement</em> these functions: it just says "this is how Function objects look like", but what kind of function it actually is, is left to derived classes that implement the <code>value()</code> function.</p>
<p>Deriving one class from another is often called an "is-a" relationship function. Here, the <code>RightHandSide</code> class "is a" <a class="el" href="classFunction.html">Function</a> class because it implements the interface described by the <a class="el" href="classFunction.html">Function</a> base class. (The actual implementation of the <code>value()</code> function is in the code block below.) The <code>virtual</code> keyword then means "Yes, the
   function here is one that can be overridden by derived classes", and the <code>override</code> keyword means "Yes, this is in fact a function we know
   has been declared as part of the base class". The <code>override</code> keyword is not strictly necessary, but is an insurance against typos: If we get the name of the function or the type of one argument wrong, the compiler will warn us by stating "You say that this function overrides one in a base class, but I don't actually know any such function with this name and these arguments."</p>
<p>But back to the concrete case here: For this tutorial, we choose as right hand side the function \(4(x^4+y^4)\) in 2D, or \(4(x^4+y^4+z^4)\) in 3D. We could write this distinction using an if-statement on the space dimension, but here is a simple way that also allows us to use the same function in 1D (or in 4D, if you should desire to do so), by using a short loop. Fortunately, the compiler knows the size of the loop at compile time (remember that at the time when you define the template, the compiler doesn't know the value of <code>dim</code>, but when it later encounters a statement or declaration <code>RightHandSide&lt;2&gt;</code>, it will take the template, replace all occurrences of dim by 2 and compile the resulting function). In other words, at the time of compiling this function, the number of times the body will be executed is known, and the compiler can minimize the overhead needed for the loop; the result will be as fast as if we had used the formulas above right away.</p>
<p>The last thing to note is that a <code><a class="el" href="classPoint.html">Point</a>&lt;dim&gt;</code> denotes a point in dim-dimensional space, and its individual components (i.e. \(x\), \(y\), ... coordinates) can be accessed using the () operator (in fact, the [] operator will work just as well) with indices starting at zero as usual in C and C++.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    return_value += 4.0 * std::pow(p(i), 4.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>As boundary values, we choose \(x^2+y^2\) in 2D, and \(x^2+y^2+z^2\) in 3D. This happens to be equal to the square of the vector from the origin to the point at which we would like to evaluate the function, irrespective of the dimension. So that is what we return:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeStep4codeclass"></a> </p><h3>Implementation of the <code>Step4</code> class</h3>
<p>Next for the implementation of the class template that makes use of the functions above. As before, we will write everything as templates that have a formal parameter <code>dim</code> that we assume unknown at the time we define the template functions. Only later, the compiler will find a declaration of <code>Step4&lt;2&gt;</code> (in the <code>main</code> function, actually) and compile the entire class with <code>dim</code> replaced by 2, a process referred to as `instantiation of a template'. When doing so, it will also replace instances of <code>RightHandSide&lt;dim&gt;</code> by <code>RightHandSide&lt;2&gt;</code> and instantiate the latter class from the class template.</p>
<p>In fact, the compiler will also find a declaration <code>Step4&lt;3&gt;</code> in <code>main()</code>. This will cause it to again go back to the general <code>Step4&lt;dim&gt;</code> template, replace all occurrences of <code>dim</code>, this time by 3, and compile the class a second time. Note that the two instantiations <code>Step4&lt;2&gt;</code> and <code>Step4&lt;3&gt;</code> are completely independent classes; their only common feature is that they are both instantiated from the same general template, but they are not convertible into each other, for example, and share no code (both instantiations are compiled completely independently).</p>
<p><a class="anchor" id="Step4Step4"></a> </p><h4>Step4::Step4</h4>
<p>After this introduction, here is the constructor of the <code>Step4</code> class. It specifies the desired polynomial degree of the finite elements and associates the <a class="el" href="classDoFHandler.html">DoFHandler</a> to the triangulation just as in the previous example program, <a class="el" href="step_3.html">step-3</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step4&lt;dim&gt;::Step4()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step4make_grid"></a> </p><h4>Step4::make_grid</h4>
<p>Grid creation is something inherently dimension dependent. However, as long as the domains are sufficiently similar in 2D or 3D, the library can abstract for you. In our case, we would like to again solve on the square \([-1,1]\times [-1,1]\) in 2D, or on the cube \([-1,1] \times [-1,1] \times [-1,1]\) in 3D; both can be termed <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, so we may use the same function in whatever dimension we are. Of course, the functions that create a hypercube in two and three dimensions are very much different, but that is something you need not care about. Let the library handle the difficult things.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4setup_system"></a> </p><h4>Step4::setup_system</h4>
<p>This function looks exactly like in the previous example, although it performs actions that in their details are quite different if <code>dim</code> happens to be 3. The only significant difference from a user's perspective is the number of cells resulting, which is much higher in three than in two space dimensions!</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4assemble_system"></a> </p><h4>Step4::assemble_system</h4>
<p>Unlike in the previous example, we would now like to use a non-constant right hand side function and non-zero boundary values. Both are tasks that are readily achieved with only a few new lines of code in the assemblage of the matrix and right hand side.</p>
<p>More interesting, though, is the way we assemble matrix and right hand side vector dimension independently: there is simply no difference to the two-dimensional case. Since the important objects used in this function (quadrature formula, <a class="el" href="classFEValues.html">FEValues</a>) depend on the dimension by way of a template parameter as well, they can take care of setting up properly everything for the dimension for which this function is compiled. By declaring all classes which might depend on the dimension using a template parameter, the library can make nearly all work for you and you don't have to care about most things.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div></div><!-- fragment --><p>We wanted to have a non-constant right hand side, so we use an object of the class declared above to generate the necessary data. Since this right hand side object is only used locally in the present function, we declare it here as a local variable:</p>
<div class="fragment"><div class="line">RightHandSide&lt;dim&gt; right_hand_side;</div></div><!-- fragment --><p>Compared to the previous example, in order to evaluate the non-constant right hand side function we now also need the quadrature points on the cell we are presently on (previously, we only required values and gradients of the shape function from the <a class="el" href="classFEValues.html">FEValues</a> object, as well as the quadrature weights, <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a> ). We can tell the <a class="el" href="classFEValues.html">FEValues</a> object to do for us by also giving it the <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a" title="Transformed quadrature points. ">update_quadrature_points</a> flag:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>We then again define the same abbreviation as in the previous program. The value of this variable of course depends on the dimension which we are presently using, but the <a class="el" href="classFiniteElement.html">FiniteElement</a> class does all the necessary work for you and you don't have to care about the dimension dependent parts:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next, we again have to loop over all cells and assemble local contributions. Note, that a cell is a quadrilateral in two space dimensions, but a hexahedron in 3D. In fact, the <code>active_cell_iterator</code> data type is something different, depending on the dimension we are in, but to the outside world they look alike and you will probably never see a difference. In any case, the real type is hidden by using <code>auto</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    cell_matrix = 0;</div><div class="line">    cell_rhs    = 0;</div></div><!-- fragment --><p>Now we have to assemble the local matrix and right hand side. This is done exactly like in the previous example, but now we revert the order of the loops (which we can safely do since they are independent of each other) and merge the loops for the local matrix and the local vector as far as possible to make things a bit faster.</p>
<p>Assembling the right hand side presents the only significant difference to how we did things in <a class="el" href="step_3.html">step-3</a>: Instead of using a constant right hand side with value 1, we use the object representing the right hand side and evaluate it at the quadrature points:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;x_q = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index);</div><div class="line">      cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                      right_hand_side.value(x_q) *        <span class="comment">// f(x_q)</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">    }</div></div><!-- fragment --><p>As a final remark to these loops: when we assemble the local contributions into <code>cell_matrix(i,j)</code>, we have to multiply the gradients of shape functions \(i\) and \(j\) at point number q_index and multiply it with the scalar weights JxW. This is what actually happens: <code>fe_values.shape_grad(i,q_index)</code> returns a <code>dim</code> dimensional vector, represented by a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> object, and the operator* that multiplies it with the result of <code>fe_values.shape_grad(j,q_index)</code> makes sure that the <code>dim</code> components of the two vectors are properly contracted, and the result is a scalar floating point number that then is multiplied with the weights. Internally, this operator* makes sure that this happens correctly for all <code>dim</code> components of the vectors, whether <code>dim</code> be 2, 3, or any other space dimension; from a user's perspective, this is not something worth bothering with, however, making things a lot simpler if one wants to write code dimension independently.</p>
<p>With the local systems assembled, the transfer into the global matrix and right hand side is done exactly as before, but here we have again merged some loops for efficiency:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        system_matrix.add(local_dof_indices[i],</div><div class="line">                          local_dof_indices[j],</div><div class="line">                          cell_matrix(i, j));</div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>As the final step in this function, we wanted to have non-homogeneous boundary values in this example, unlike the one before. This is a simple task, we only have to replace the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> used there by an object of the class which describes the boundary values we would like to use (i.e. the <code>BoundaryValues</code> class declared above):</p>
<p>The function <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> will only work on faces that have been marked with boundary indicator 0 (because that's what we say the function should work on with the second argument below). If there are faces with boundary id other than 0, then the function interpolate_boundary_values will do nothing on these faces. For the Laplace equation doing nothing is equivalent to assuming that on those parts of the boundary a zero Neumann boundary condition holds.</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4solve"></a> </p><h4>Step4::solve</h4>
<p>Solving the linear system of equations is something that looks almost identical in most programs. In particular, it is dimension independent, so this function is copied verbatim from the previous example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>We have made one addition, though: since we suppress output from the linear solvers, we have to print the number of iterations by hand.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4output_results"></a> </p><h4>Step4::output_results</h4>
<p>This function also does what the respective one did in <a class="el" href="step_3.html">step-3</a>. No changes here for dimension independence either.</p>
<p>Since the program will run both 2d and 3d versions of the Laplace solver, we use the dimension in the filename to generate distinct filenames for each run (in a better program, one would check whether <code>dim</code> can have other values than 2 or 3, but we neglect this here for the sake of brevity).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(dim == 2 ? <span class="stringliteral">&quot;solution-2d.vtk&quot;</span> : <span class="stringliteral">&quot;solution-3d.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step4run"></a> </p><h4>Step4::run</h4>
<p>This is the function which has the top-level control over everything. Apart from one line of additional output, it is the same as for the previous example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step4&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>And this is the main function. It also looks mostly like in <a class="el" href="step_3.html">step-3</a>, but if you look at the code below, note how we first create a variable of type <code>Step4&lt;2&gt;</code> (forcing the compiler to compile the class template with <code>dim</code> replaced by <code>2</code>) and run a 2d simulation, and then we do the whole thing over in 3d.</p>
<p>In practice, this is probably not what you would do very frequently (you probably either want to solve a 2d problem, or one in 3d, but not both at the same time). However, it demonstrates the mechanism by which we can simply change which dimension we want in a single place, and thereby force the compiler to recompile the dimension independent class templates for the dimension we request. The emphasis here lies on the fact that we only need to change a single place. This makes it rather trivial to debug the program in 2d where computations are fast, and then switch a single place to a 3 to run the much more computing intensive program in 3d for `real' computations.</p>
<p>Each of the two blocks is enclosed in braces to make sure that the <code>laplace_problem_2d</code> variable goes out of scope (and releases the memory it holds) before we move on to allocate memory for the 3d case. Without the additional braces, the <code>laplace_problem_2d</code> variable would only be destroyed at the end of the function, i.e. after running the 3d problem, and would needlessly hog memory while the 3d run could actually use it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  {</div><div class="line">    Step4&lt;2&gt; laplace_problem_2d;</div><div class="line">    laplace_problem_2d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Step4&lt;3&gt; laplace_problem_3d;</div><div class="line">    laplace_problem_3d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-4/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></p>
<div class="fragment"><div class="line">Solving problem in 2 space dimensions.</div><div class="line">   Number of active cells: 256</div><div class="line">   Total number of cells: 341</div><div class="line">   Number of degrees of freedom: 289</div><div class="line">   26 CG iterations needed to obtain convergence.</div><div class="line">Solving problem in 3 space dimensions.</div><div class="line">   Number of active cells: 4096</div><div class="line">   Total number of cells: 4681</div><div class="line">   Number of degrees of freedom: 4913</div><div class="line">   30 CG iterations needed to obtain convergence.</div></div><!-- fragment --><p></p>
<p> <code>solution-2d.vtk</code>  <code>solution-3d.vtk</code> VisItParaview2D</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.solution-2d.png"/>
</div>
 <p></p>
<p>( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.11.html">video lecture 11</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.32.html">video lecture 32</a>.) 7</p>
<p></p>
<p></p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.solution-3d.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-4.contours-3d.png"/>
</div>
   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>VisIt \(x\)  "X" \([-1,1]^3\) </dd></dl>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>3D<a href="step_3.html#extensions" target="body">possible extensions in the documentation of step 3</a></p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step4</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step4();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    return_value += 4.0 * std::pow(p(i), 4.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step4&lt;dim&gt;::Step4()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;x_q = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index);</div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            right_hand_side.value(x_q) *        <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>())</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step4&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(dim == 2 ? <span class="stringliteral">&quot;solution-2d.vtk&quot;</span> : <span class="stringliteral">&quot;solution-3d.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step4&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  {</div><div class="line">    Step4&lt;2&gt; laplace_problem_2d;</div><div class="line">    laplace_problem_2d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Step4&lt;3&gt; laplace_problem_3d;</div><div class="line">    laplace_problem_3d.run();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
