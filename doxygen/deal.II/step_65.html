<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_65.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-65 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-65 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_49.html">step-49</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Workingwithmanifolds">Working with manifolds</a>
      <ul>
        <li><a href="#Whatwewant">What we want</a>
      </ul>
        <li><a href="#TheclassTransfiniteInterpolationManifold">The class TransfiniteInterpolationManifold</a>
      <ul>
        <li><a href="#Howitworks">How it works</a>
      </ul>
        <li><a href="#Transfiniteinterpolationisexpensiveandhowtodealwithit">Transfinite interpolation is expensive and how to deal with it</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Analyticalsolutionandcoefficient">Analytical solution and coefficient</a>
        <li><a href="#ThePoissonProblemclass">The PoissonProblem class</a>
        <li><a href="#Gridcreationandinitializationofthemanifolds">Grid creation and initialization of the manifolds</a>
        <li><a href="#Setupofdatastructures">Setup of data structures</a>
        <li><a href="#Assemblyofthesystemmatrixandrighthandside">Assembly of the system matrix and right hand side</a>
        <li><a href="#Solutionofthelinearsystem">Solution of the linear system</a>
        <li><a href="#Outputofthesolutionandcomputationoferrors">Output of the solution and computation of errors</a>
        <li><a href="#ThePoissonProblemrunfunction">The PoissonProblem::run() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
</p>
<p><br />
</p>
<p><em> This program was contributed by Martin Kronbichler. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program presents an advanced manifold class, <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>, and how to work around its main disadvantage, the relatively high cost.</p>
<p><a class="anchor" id="Workingwithmanifolds"></a></p><h3>Working with manifolds</h3>
<p><a class="anchor" id="Whatwewant"></a></p><h4>What we want</h4>
<p>In many applications, the finite element mesh must be able to represent a relatively complex geometry. In the <a class="el" href="step_1.html">step-1</a>, <a class="el" href="step_49.html">step-49</a>, and <a class="el" href="step_53.html">step-53</a> tutorial programs, some techniques to generate grids available within the deal.II library have been introduced. Given a base mesh, deal.II is then able to create a finer mesh by subdividing the cells into children, either uniformly or only in selected parts of the computational domain. Besides the basic meshing capabilities collected in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, deal.II also comes with interfaces to read in meshes generated by (quad- and hex-only) mesh generators using the functions of namespace <a class="el" href="classGridIn.html">GridIn</a>, as for example demonstrated in <a class="el" href="step_5.html">step-5</a>. A fundamental limitation of externally generated meshes is that the information provided by the generated cells in the mesh only consists of the position of the vertices and their connectivity, without the context of the underlying geometry that used to be available in the mesh generator that originally created this mesh. This becomes problematic once the mesh is refined within deal.II and additional points need to be placed. The <a class="el" href="step_54.html">step-54</a> tutorial program shows how to overcome this limitation by using CAD surfaces in terms of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> library, and <a class="el" href="step_53.html">step-53</a> by providing the same kind of information programmatically from within the source code.</p>
<p>Within deal.II, the placement of new points during mesh refinement or for the definition of higher order mappings is controlled by manifold objects, see the <a class="el" href="group__manifold.html">manifold module</a> for details. To give an example, consider the following situation of a two-dimensional annulus (with pictures taken from the manifold module). If we start with an initial mesh of 10 cells and refine the mesh three times globally without attaching any manifolds, we would obtain the following mesh:</p>
<div class="image">
<img src="hypershell-nothing.png" alt="hypershell-nothing.png"/>
</div>
<p> The picture looks like this because, by default, deal.II only knows where to put the vertices of child cells by averaging the locations of the vertices of the parent cell. This yields a polygonal domain whose faces are the edges of the original (coarse mesh) cells. Obviously, we must attach a curved description to the boundary faces of the triangulation to reproduce the circular shape upon mesh refinement, like in the following picture:</p>
<div class="image">
<img src="hypershell-boundary-only.png" alt="hypershell-boundary-only.png"/>
</div>
<p> This is better: At least the inner and outer boundaries are now approaching real circles if we continue to refine the mesh. However, the mesh in this picture is still not optimal for an annulus in the sense that the <em>interior</em> lines from one cell to the next have kinks at certain vertices, and one would rather like to use the following mesh:</p>
<div class="image">
<img src="hypershell-all.png" alt="hypershell-all.png"/>
</div>
<p> In this last (optimal) case, which is also the default produced by <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, the curved manifold description (in this case a polar manifold description) is applied not only to the boundary faces, but to the whole domain. Whenever the triangulation requests a new point, e.g., the mid point of the edges or the cells when it refines a cell into four children, it will place them along the respective mid points in the polar coordinate system. By contrast, the case above where only the boundary was subject to the polar manifold, only mid points along the boundary would be placed along the curved description, whereas mid points in the interior would be computed by suitable averages of the surrounding points in the Cartesian coordinate system (see the <a class="el" href="group__manifold.html">manifold module</a> for more details).</p>
<p>At this point, one might assume that curved volume descriptions are the way to go. This is generally not wrong, though it is sometimes not so easy to describe how exactly this should work. Here are a couple of examples:</p>
<ul>
<li>Imagine that the mesh above had actually been a disk, not just a ring. In that case the polar manifold degenerates at the origin and would not produce reasonable new points. In fact, defining a manifold description for things that are supposed "to look round" but might have points at or close to the origin is surprisingly very difficult.</li>
<li>A similar thing happens at the origin of the three-dimensional ball when one tries to attach a spherical manifold to the whole volume &ndash; in this case, the computation of new manifold points would abort with an exception.</li>
<li>CAD geometries often only describe the boundary of the domain, in a similar way to how we only attached a manifold to the boundary in the second picture above. Similarly, <a class="el" href="step_54.html">step-54</a> only uses the CAD geometry to generate a surface mesh (maybe because that is what is needed to solve the problem in question), but if one wanted to solve a problem in the water or the air around the ship described there, we would need to have a volume mesh. The question is then how exactly we should describe what is supposed to happen in the interior of the domain.</li>
</ul>
<p>These simple examples make it clear that for many interesting cases we must step back from the desire to have an analytic curved description for the full volume: There will need to be <em>some</em> kind of information that leads to curvature also in the interior, but it must be possible to do this without actually writing down an explicit formula that describes the kind of geometry.</p>
<p>So what happens if we don't do anything at all in the interior and only describe the surface as a manifold? Sometimes, as in the ring shown above, the result is not terrible. But sometimes it is. Consider the case of a torus (e.g. generated with <a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">GridGenerator::torus()</a>) with a <a class="el" href="classTorusManifold.html">TorusManifold</a> object attached to the surface only, no additional manifolds on the interior cells and faces, and with six cells in toroidal direction before refinement. If the mesh is refined once, we would obtain the following mesh, shown with the upper half of the mesh clipped away:</p>
<div class="image">
<img src="torus_no_inner_manifold.png" alt="torus_no_inner_manifold.png"/>
</div>
<p> This is clearly sub-optimal. Indeed, if we had started with fewer than the six cells shown above in toroidal direction, the mapping actually inverts in some regions because the new points placed along interior cells intersect with the boundary as they are not following the circular shape along the toroidal direction. The simple case of a torus can still be fixed because we know that the toroidal direction follows a cylindrical coordinate system, so attaching a <a class="el" href="classTorusManifold.html">TorusManifold</a> to the surface combined with <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> with appropriate periodicity in toroidal direction applied to all interior entities would produce a high-quality mesh as follows, now shown with two top cells hidden:</p>
<div class="image">
<img src="torus_cylindrical_inner_manifold.png" alt="torus_cylindrical_inner_manifold.png"/>
</div>
<p> This mesh is pretty good, but obviously it is linked to a good description of the volume, which we lack in other cases. Actually, there is an imperfection also in this case, as we can see some unnatural kinks of two adjacent cells in the interior of the domain which are hidden by the top two boundary cells, as opposed to the following setup (the default manifolds applied by <a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">GridGenerator::torus()</a> and using the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>):</p>
<div class="image">
<img src="torus_transfinite_manifold.png" alt="torus_transfinite_manifold.png"/>
</div>
<p> <a class="anchor" id="TheclassTransfiniteInterpolationManifold"></a></p><h3>The class <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a></h3>
<p>In order to find a better strategy, let us look at the two-dimensional disk again (that is also the base entity rotated along the toroidal direction in the torus). As we learned above, we can only apply the curved polar description to the boundary (or a rim of cells sufficiently far away from the origin) but must eventually transition to a straight description towards the disk's center. If we use a flat manifold in the interior of the cells (i.e., one in which new vertices are created by averaging of the adjacent existing ones) and a polar manifold only for the boundary of the disk, we get the following mesh upon four global refinements:</p>
<div class="image">
<img src="circular_mesh_only_boundary_manifold.png" alt="circular_mesh_only_boundary_manifold.png"/>
</div>
<p> That's not a terrible mesh. At the same time, if you know that the original coarse mesh consisted of a single square in the middle, with four caps around it, then it's not hard to see every refinement step that happened to this mesh to get the picture above.</p>
<p>While the triangulation class of deal.II tries to propagate information from the boundary into the interior when creating new points, the reach of this algorithm is limited:</p>
<div class="image">
<img src="circular_mesh_boundary_cells.png" alt="circular_mesh_boundary_cells.png"/>
</div>
<p> The picture above highlights those cells on the disk that are touching the boundary and where boundary information could in principle be taken into account when only looking at a single cell at the time. Clearly, the area where some curvature can be taken into account gets more limited as the mesh is refined, thus creating the seemingly irregular spots in the mesh: When computing the center of any one of the boundary cells in the leftmost picture, the ideal position is the mid point between the outer circle and the cell in the middle. This is exactly what is used for the first refinement step in the <a class="el" href="classTriangulation.html">Triangulation</a> class. However, for the second refinement all interior edges as well as the interior cell layers can only add points according to a flat manifold description.</p>
<p>At this point, we realize what would be needed to create a better mesh: For <em>all</em> new points in <em>any</em> child cell that is created within the red shaded layer on the leftmost picture, we want to compute the interpolation with respect to the curvature in the area covered by the respective coarse cell. This is achieved by adding the class <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to the highlighted cells of the coarse grid in the leftmost panel of the figure above. This class adheres to the general manifold interfaces, i.e., given any set of points within its domain of definition, it can compute weighted averages conforming to the manifold (using a formula that will be given in a minute). These weighted averages are used whenever the mesh is refined, or when a higher order mapping (such as <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> or <a class="el" href="classMappingC1.html">MappingC1</a>) is evaluated on a given cell subject to this manifold. Using this manifold on the shaded cells of the coarse grid of the disk (i.e., not only in the outer-most layer of cells) produces the following mesh upon four global steps of refinement:</p>
<div class="image">
<img src="circular_mesh_transfinite_interpolation.png" alt="circular_mesh_transfinite_interpolation.png"/>
</div>
<p> There are still some kinks in the lines of this mesh, but they are restricted to the faces between coarse mesh cells, whereas the rest of the mesh is about as smooth as one would like. Indeed, given a straight-sided central cell, this representation is the best possible one as all mesh cells follow a smooth transition from the straight sides in the square block in the interior to the circular shape on the boundary. (One could possibly do a bit better by allowing some curvature also in the central square block, that eventually vanishes as the center is approached.)</p>
<p><a class="anchor" id="Howitworks"></a></p><h4>How it works</h4>
<p>In the simple case of a disk with one curved and three straight edges, we can explicitly write down how to achieve the blending of the shapes. For this, it is useful to map the physical cell, like the top one, back to the reference coordinate system \((\xi,\eta)\in (0,1)^2\) where we compute averages between certain points. If we were to use a simple bilinear map spanned by four vertices \((x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)\), the image of a point \((\xi, \eta)\in (0,1)^2\) would be </p><p class="formulaDsp">
\begin{align*} (x,y) = (1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) + (1-\xi)\eta (x_2,y_2) + \xi\eta (x_3,y_3). \end{align*}
</p>
<p>For the case of the curved surface, we want to modify this formula. For the top cell of the coarse mesh of the disk, we can assume that the points \((x_0,y_0)\) and \((x_1,y_1)\) sit along the straight line at the lower end and the points \((x_2,y_2)\) and \((x_3,y_3)\) are connected by a quarter circle along the top. We would then map a point \((\xi, \eta)\) as </p><p class="formulaDsp">
\begin{align*} (x,y) = (1-\eta) \big[(1-\xi) (x_0,y_0) + \xi (x_1,y_1)\big] + \eta \mathbf{c}_3(\xi), \end{align*}
</p>
<p> where \(\mathbf{c}_3(\xi)\) is a curve that describes the \((x,y)\) coordinates of the quarter circle in terms of an arclength parameter \(\xi\in (0,1)\). This represents a linear interpolation between the straight lower edge and the curved upper edge of the cell, and is the basis for the picture shown above.</p>
<p>This formula is easily generalized to the case where all four edges are described by a curve rather than a straight line. We call the four functions, parameterized by a single coordinate \(\xi\) or \(\eta\) in the horizontal and vertical directions, \(\mathbf{c}_0, \mathbf{c}_1, \mathbf{c}_2, \mathbf{c}_3\) for the left, right, lower, and upper edge of a quadrilateral, respectively. The interpolation then reads </p><p class="formulaDsp">
\begin{align*} (x,y) =&amp; (1-\xi)\mathbf{c}_0(\eta) + \xi \mathbf{c}_1(\eta) +(1-\eta)\mathbf{c}_2(\xi) + \eta \mathbf{c}_3(\xi)\\ &amp;-\big[(1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) + (1-\xi)\eta (x_2,y_2) + \xi\eta (x_3,y_3)\big]. \end{align*}
</p>
<p>This formula assumes that the boundary curves match and coincide with the vertices \((x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)\), e.g. \(\mathbf{c}_0(0) = (x_0,y_0)\) or \(\mathbf{c}_0(1) = (x_2,y_2)\). The subtraction of the bilinear interpolation in the second line of the formula makes sure that the prescribed curves are followed exactly on the boundary: Along each of the four edges, we need to subtract the contribution of the two adjacent edges evaluated in the corners, which is then simply a vertex position. It is easy to check that the formula for the circle above is reproduced if three of the four curves \(\mathbf{c}_i\) are straight and thus coincide with the bilinear interpolation.</p>
<p>This formula, called transfinite interpolation, was introduced in 1973 by <a href="https://doi.org/10.1002%2Fnme.1620070405">Gordon and Hall</a>. Even though transfinite interpolation essentially only represents a linear blending of the bounding curves, the interpolation exactly follows the boundary curves for each real number \(\xi\in (0,1)\) or \(\eta\in (0,1)\), i.e., it interpolates in an infinite number of points, which was the original motivation to label this variant of interpolation a transfinite one by Gordon and Hall. Another interpretation is that the transfinite interpolation interpolates from the left and right and the top and bottom linearly, from which we need to subtract the bilinear interpolation to ensure a unit weight in the interior of the domain.</p>
<p>The transfinite interpolation is easily generalized to three spatial dimensions. In that case, the interpolation allows to blend 6 different surface descriptions for any of the quads of a three-dimensional cell and 12 edge descriptions for the lines of a cell. Again, to ensure a consistent map, it is necessary to subtract the contribution of edges and add the contribution of vertices again to make the curves follow the prescribed surface or edge description. In the three-dimensional case, it is also possible to use a transfinite interpolation from a curved edge both into the adjacent faces and the adjacent cells.</p>
<p>The interpolation of the transfinite interpolation in deal.II is general in the sense that it can deal with arbitrary curves. It will evaluate the curves in terms of their original coordinates of the \(d\)-dimensional space but with one (or two, in the case of edges in 3D) coordinate held fixed at \(0\) or \(1\) to ensure that any other manifold class, including CAD files if desired, can be applied out of the box. Transfinite interpolation is a standard ingredient in mesh generators, so the main strength of the integration of this feature within the deal.II library is to enable it during adaptive refinement and coarsening of the mesh, and for creating higher-degree mappings that use manifolds to insert additional points beyond the mesh vertices.</p>
<p>As a final remark on transfinite interpolation, we mention that the mesh refinement strategies in deal.II in absence of a volume manifold description are also based on the weights of the transfinite interpolation and optimal in that sense. The difference is that the default algorithm sees only one cell at a time, and so will apply the optimal algorithm only on those cells touching the curved manifolds. In contrast, using the transfinite mapping on entire <em>patches</em> of cells (originating from one coarser cell) allows to use the transfinite interpolation method in a way that propagates information from the boundary to cells far away.</p>
<p><a class="anchor" id="Transfiniteinterpolationisexpensiveandhowtodealwithit"></a></p><h3>Transfinite interpolation is expensive and how to deal with it</h3>
<p>A mesh with a transfinite manifold description is typically set up in two steps. The first step is to create a coarse mesh (or read it in from a file) and to attach a curved manifold to some of the mesh entities. For the above example of the disk, we attach a polar manifold to the faces along the outer circle (this is done automatically by <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>). Before we start refining the mesh, we then assign a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to all interior cells and edges of the mesh, which of course needs to be based on some manifold id that we have assigned to those entities (everything except the circle on the boundary). It does not matter whether we also assign a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to the inner square of the disk or not because the transfinite interpolation on a coarse cell with straight edges (or flat faces in 3d) simply yields subdivided children with straight edges (flat faces).</p>
<p>Later, when the mesh is refined or when a higher-order mapping is set up based on this mesh, the cells will query the underlying manifold object for new points. This process takes a set of surrounding points, for example the four vertices of a two-dimensional cell, and a set of weights to each of these points, for definition a new point. For the mid point of a cell, each of the four vertices would get weight 0.25. For the transfinite interpolation manifold, the process of building weighted sums requires some serious work. By construction, we want to combine the points in terms of the reference coordinates \(\xi\) and \(\eta\) (or \(\xi, \eta, \zeta\) in 3D) of the surrounding points. However, the interface of the manifold classes in deal.II does not get the reference coordinates of the surrounding points (as they are not stored globally) but rather the physical coordinates only. Thus, the first step the transfinite interpolation manifold has to do is to invert the mapping and find the reference coordinates within one of the coarse cells of the transfinite interpolation (e.g. one of the four shaded coarse-grid cells of the disk mesh above). This inversion is done by a Newton iteration (or rather, finite-difference based Newton scheme combined with Broyden's method) and queries the transfinite interpolation according to the formula above several times. Each of these queries in turn might call an expensive manifold, e.g. a spherical description of a ball, and be expensive on its own. Since the <a class="el" href="classManifold.html">Manifold</a> interface class of deal.II only provides a set of points, the transfinite interpolation initially does not even know to which coarse grid cell the set of surrounding points belong to and needs to search among several cells based on some heuristics. In terms of <a href="https://en.wikipedia.org/wiki/Atlas_(topology)#Charts">charts</a>, one could describe the implementation of the transfinite interpolation as an <a href="https://en.wikipedia.org/wiki/Atlas_(topology)">atlas</a>-based implementation: Each cell of the initial coarse grid of the triangulation represents a chart with its own reference space, and the surrounding manifolds provide a way to transform from the chart space (i.e., the reference cell) to the physical space. The collection of the charts of the coarse grid cells is an atlas, and as usual, the first thing one does when looking up something in an atlas is to find the right chart.</p>
<p>Once the reference coordinates of the surrounding points have been found, a new point in the reference coordinate system is computed by a simple weighted sum. Finally, the reference point is inserted into the formula for the transfinite interpolation, which gives the desired new point.</p>
<p>In a number of cases, the curved manifold is not only used during mesh refinement, but also to ensure a curved representation of boundaries within the cells of the computational domain. This is a necessity to guarantee high-order convergence for high-order polynomials on complex geometries anyway, but sometimes an accurate geometry is also desired with linear shape functions. This is often done by polynomial descriptions of the cells and called the isoparametric concept if the polynomial degree to represent the curved mesh elements is the same as the degree of the polynomials for the numerical solution. If the degree of the geometry is higher or lower than the solution, one calls that a super- or sub-parametric geometry representation, respectively. In deal.II, the standard class for polynomial representation is <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>. If, for example, this class is used with polynomial degree \(4\) in 3D, a total of 125 (i.e., \((4+1)^3\)) points are needed for the interpolation. Among these points, 8 are the cell's vertices and already available from the mesh, but the other 117 need to be provided by the manifold. In case the transfinite interpolation manifold is used, we can imagine that going through the pull-back into reference coordinates of some yet to be determined coarse cell, followed by subsequent push-forward on each of the 117 points, is a lot of work and can be very time consuming.</p>
<p>What makes things worse is that the structure of many programs is such that the mapping is queried several times independently for the same cell. Its primary use is in the assembly of the linear system, i.e., the computation of the system matrix and the right hand side, via the <code>mapping</code> argument of the <a class="el" href="classFEValues.html">FEValues</a> object. However, also the interpolation of boundary values, the computation of numerical errors, writing the output, and evaluation of error estimators must involve the same mapping to ensure a consistent interpretation of the solution vectors. Thus, even a linear stationary problem that is solved once will evaluate the points of the mapping several times. For the cubic case in 3D mentioned above, this means computing 117 points per cell by an expensive algorithm many times. The situation is more pressing for nonlinear or time-dependent problems where those operations are done over and over again.</p>
<p>As the manifold description via a transfinite interpolation can easily be hundreds of times more expensive than a similar query on a flat manifold, it makes sense to compute the additional points only once and use them in all subsequent calls. The deal.II library provides the class <a class="el" href="classMappingQCache.html">MappingQCache</a> for exactly this purpose. The cache is typically not overly big compared to the memory consumed by a system matrix, as will become clear when looking at the results of this tutorial program. The usage of <a class="el" href="classMappingQCache.html">MappingQCache</a> is simple: Once the mesh has been set up (or changed during refinement), we call <a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">MappingQCache::initialize()</a> with the desired triangulation as well as a desired mapping as arguments. The initialization then goes through all cells of the mesh and queries the given mapping for its additional points. Those get stored for an identifier of the cell so that they can later be returned whenever the mapping computes some quantities related to the cell (like the Jacobians of the map between the reference and physical coordinates).</p>
<p>As a final note, we mention that the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> also makes the refinement of the mesh more expensive. In this case, the <a class="el" href="classMappingQCache.html">MappingQCache</a> does not help because it would compute points that can subsequently not be re-used; there currently does not exist a more efficient mechanism in deal.II. However, the mesh refinement contains many other expensive steps as well, so it is not as big as an issue compared to the rest of the computation. It also only happens at most once per time step or nonlinear iteration.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>In this tutorial program, the usage of <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> is exemplified in combination with <a class="el" href="classMappingQCache.html">MappingQCache</a>. The test case is relatively simple and takes up the solution stages involved in many typical programs, e.g., the <a class="el" href="step_6.html">step-6</a> tutorial program. As a geometry, we select one prototype use of <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>, namely a setup involving a spherical ball that is in turn surrounded by a cube. Such a setup would be used, for example, for a spherical inclusion embedded in a background medium, and if that inclusion has different material properties that require that the interface between the two materials needs to be tracked by element interfaces. A visualization of the grid is given here:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-65-mesh.png"/>
</div>
<p>For this case, we want to attach a spherical description to the surface inside the domain and use the transfinite interpolation to smoothly switch to the straight lines of the outer cube and the cube at the center of the ball.</p>
<p>Within the program, we will follow a typical flow in finite element programs, starting from the setup of <a class="el" href="classDoFHandler.html">DoFHandler</a> and sparsity patterns, the assembly of a linear system for solving the Poisson equation with a jumping coefficient, its solution with a simple iterative method, computation of some numerical error with <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> as well as an error estimator. We record timings for each section and run the code twice. In the first run, we hand a <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> object to each stage of the program separately, where points get re-computed over and over again. In the second run, we use <a class="el" href="classMappingQCache.html">MappingQCache</a> instead.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The include files for this tutorial are essentially the same as in <a class="el" href="step_6.html">step-6</a>. Importantly, the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class we will be using is provided by <code>deal.II/grid/manifold_lib.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>The only new include file is the one for the <a class="el" href="classMappingQCache.html">MappingQCache</a> class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__cache_8h.html">deal.II/fe/mapping_q_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step65</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Analyticalsolutionandcoefficient"></a> </p><h3>Analytical solution and coefficient</h3>
<p>In this tutorial program, we want to solve the Poisson equation with a coefficient that jumps along a sphere of radius 0.5, and using a constant right hand side of value \(f(\mathbf{x}) = -3\). (This setup is similar to <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_6.html">step-6</a>, but the concrete values for the coefficient and the right hand side are different.) Due to the jump in the coefficient, the analytical solution must have a kink where the coefficient switches from one value to the other. To keep things simple, we select an analytical solution that is quadratic in all components, i.e., \(u(x,y,z) = x^2 + y^2 + z^2\) in the ball of radius 0.5 and \(u(x,y,z) = 0.1(x^2 + y^2 + z^2) + 0.25-0.025\) in the outer part of the domain. This analytical solution is compatible with the right hand side in case the coefficient is 0.5 in the inner ball and 5 outside. It is also continuous along the circle of radius 0.5.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">      <span class="keywordflow">return</span> p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.1 * p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() + (0.25 - 0.025);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  <a class="code" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">      <span class="keywordflow">return</span> 2. * p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.2 * p;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> coefficient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">    <span class="keywordflow">return</span> 0.5;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 5.0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThePoissonProblemclass"></a> </p><h3>The PoissonProblem class</h3>
<p>The implementation of the Poisson problem is very similar to what we used in the <a class="el" href="step_5.html">step-5</a> tutorial program. The two main differences are that we pass a mapping object to the various steps in the program in order to switch between two mapping representations as explained in the introduction, and the <code>timer</code> object (of type <a class="el" href="classTimerOutput.html">TimerOutput</a>) that will be used for measuring the run times in the various cases. (The concept of mapping objects was first introduced in <a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a>, in case you want to look up the use of these classes.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PoissonProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PoissonProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> create_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;      system_matrix;</div><div class="line">  Vector&lt;double&gt;            solution;</div><div class="line">  Vector&lt;double&gt;            system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p>In the constructor, we set up the timer object to record wall times but be quiet during the normal execution. We will query it for timing details in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem::run()</a></code> function. Furthermore, we select a relatively high polynomial degree of three for the finite element in use.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PoissonProblem&lt;dim&gt;::PoissonProblem()</div><div class="line">  : fe(3)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Gridcreationandinitializationofthemanifolds"></a> </p><h3>Grid creation and initialization of the manifolds</h3>
<p>The next function presents the typical usage of <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. The first step is to create the desired grid, which can be done by composition of two grids from <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>. The inner ball mesh is simple enough: We run <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a> centered at the origin with radius 0.5 (third function argument). The second mesh is more interesting and constructed as follows: We want to have a mesh that is spherical in the interior but flat on the outer surface. Furthermore, the mesh topology of the inner ball should be compatible with the outer grid in the sense that their vertices coincide so as to allow the two grid to be merged. The grid coming out of <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> fulfills the requirements on the inner side in case it is created with \(2d\) coarse cells (6 coarse cells in 3D which we are going to use) &ndash; this is the same number of cells as there are boundary faces for the ball. For the outer surface, we use the fact that the 6 faces on the surface of the shell without a manifold attached would degenerate to the surface of a cube. What we are still missing is the radius of the outer shell boundary. Since we desire a cube of extent \([-1, 1]\) and the 6-cell shell puts its 8 outer vertices at the 8 opposing diagonals, we must translate the points \((\pm 1, \pm 1, \pm 1)\) into a radius: Clearly, the radius must be \(\sqrt{d}\) in \(d\) dimensions, i.e., \(\sqrt{3}\) for the three-dimensional case we want to consider.</p>
<p>Thus, we have a plan: After creating the inner triangulation for the ball and the one for the outer shell, we merge those two grids but remove all manifolds that the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> may have set from the resulting triangulation, to ensure that we have full control over manifolds. In particular, we want additional points added on the boundary during refinement to follow a flat manifold description. To start the process of adding more appropriate manifold ids, we assign the manifold id 0 to all mesh entities (cells, faces, lines), which will later be associated with the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. Then, we must identify the faces and lines that are along the sphere of radius 0.5 and mark them with a different manifold id, so as to then assign a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to those. We will choose the manifold id of 1. Since we have thrown away all manifolds that pre-existed after calling <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, we manually go through the cells of the mesh and all their faces. We have found a face on the sphere if all four vertices have a radius of 0.5, or, as we write in the program, have \(r^2-0.25 \approx 0\). Note that we call <code>cell-&gt;face(f)-&gt;set_all_manifold_ids(1)</code> to set the manifold id both on the faces and the surrounding lines. Furthermore, we want to distinguish the cells inside the ball and outside the ball by a material id for visualization, corresponding to the picture in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::create_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_inner;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria_inner, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_outer;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    tria_outer, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5, std::sqrt(dim), 2 * dim);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria_inner, tria_outer, triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordtype">bool</span> face_at_sphere_boundary = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : face-&gt;vertex_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (std::abs(face-&gt;vertex(v).norm_square() - 0.25) &gt; 1e-12)</div><div class="line">                face_at_sphere_boundary = <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">          <span class="keywordflow">if</span> (face_at_sphere_boundary)</div><div class="line">            face-&gt;set_all_manifold_ids(1);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;center().norm_square() &lt; 0.25)</div><div class="line">        cell-&gt;set_material_id(1);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        cell-&gt;set_material_id(0);</div><div class="line">    }</div></div><!-- fragment --><p>With all cells, faces and lines marked appropriately, we can attach the <a class="el" href="classManifold.html">Manifold</a> objects to those numbers. The entities with manifold id 1 will get a spherical manifold, whereas the other entities, which have the manifold id 0, will be assigned the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. As mentioned in the introduction, we must explicitly initialize the manifold with the current mesh using a call to <a class="el" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">TransfiniteInterpolationManifold::initialize()</a> in order to pick up the coarse mesh cells and the manifolds attached to the boundaries of those cells. We also note that the manifold objects we create locally in this function are allowed to go out of scope (as they do at the end of the function scope), because the <a class="el" href="classTriangulation.html">Triangulation</a> object internally copies them.</p>
<p>With all manifolds attached, we will finally go about and refine the mesh a few times to create a sufficiently large test case.</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> transfinite_manifold;</div><div class="line">  transfinite_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, transfinite_manifold);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(9 - 2 * dim);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Setupofdatastructures"></a> </p><h3>Setup of data structures</h3>
<p>The following function is well-known from other tutorials in that it enumerates the degrees of freedom, creates a constraint object and sets up a sparse matrix for the linear system. The only thing worth mentioning is the fact that the function receives a reference to a mapping object that we then pass to the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function to ensure that our boundary values are evaluated on the high-order mesh used for assembly. In the present example, it does not really matter because the outer surfaces are flat, but for curved outer cells this leads to more accurate approximation of the boundary values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute constraints&quot;</span>);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, ExactSolution&lt;dim&gt;(), constraints);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyofthesystemmatrixandrighthandside"></a> </p><h3>Assembly of the system matrix and right hand side</h3>
<p>The function that assembles the linear system is also well known from the previous tutorial programs. One thing to note is that we set the number of quadrature points to the polynomial degree plus two, not the degree plus one as in most other tutorials. This is because we expect some extra accuracy as the mapping also involves a degree one more than the polynomials for the solution.</p>
<p>The only somewhat unusual code in the assembly is the way we compute the cell matrix. Rather than using three nested loop over the quadrature point index, the row, and the column of the matrix, we first collect the derivatives of the shape function, multiplied by the square root of the product of the coefficient and the integration factor <code>JxW</code> in a separate matrix <code>partial_matrix</code>. To compute the cell matrix, we then execute <code>cell_matrix = partial_matrix * transpose(partial_matrix)</code> in the line <code>partial_matrix.mTmult(cell_matrix, partial_matrix);</code>. To understand why this works, we realize that the matrix-matrix multiplication performs a summation over the columns of <code>partial_matrix</code>. If we denote the coefficient by \(a(\mathbf{x}_q)\), the entries in the temporary matrix are \(\sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k}\). If we take the product of the <em>i</em>th row with the <em>j</em>th column of that matrix, we compute a nested sum involving \(\sum_q \sum_{k=1}^d \sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k} = \sum_q \sum_{k=1}^d\text{det}(J) w_q a(x)\frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k}\), which is exactly the terms needed for the bilinear form of the Laplace equation.</p>
<p>The reason for choosing this somewhat unusual scheme is due to the heavy work involved in computing the cell matrix for a relatively high polynomial degree in 3D. As we want to highlight the cost of the mapping in this tutorial program, we better do the assembly in an optimized way in order to not chase bottlenecks that have been solved by the community already. Matrix-matrix multiplication is one of the best optimized kernels in the HPC context, and the <a class="el" href="classFullMatrix.html#ac074fc1dc416f8cd75bb01d820e74aa0">FullMatrix::mTmult()</a> function will call into those optimized BLAS functions. If the user has provided a good BLAS library when configuring deal.II (like OpenBLAS or Intel's MKL), the computation of the cell matrix will execute close to the processor's peak arithmetic performance. As a side note, we mention that despite an optimized matrix-matrix multiplication, the current strategy is sub-optimal in terms of complexity as the work to be done is proportional to \((p+1)^9\) operations for degree \(p\) (this also applies to the usual evaluation with <a class="el" href="classFEValues.html">FEValues</a>). One could compute the cell matrix with \(\mathcal O((p+1)^7)\) operations by utilizing the tensor product structure of the shape functions, as is done by the matrix-free framework in deal.II. We refer to <a class="el" href="step_37.html">step-37</a> and the documentation of the tensor-product-aware evaluators <a class="el" href="classFEEvaluation.html">FEEvaluation</a> for details on how an even more efficient cell matrix computation could be realized.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Assemble linear system&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> partial_matrix(dofs_per_cell, dim * n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0.;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient =</div><div class="line">            coefficient(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                partial_matrix(i, q_index * dim + d) =</div><div class="line">                  <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index) * current_coefficient) *</div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">              cell_rhs(i) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                 (-dim) *                            <span class="comment">// f(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      partial_matrix.mTmult(cell_matrix, partial_matrix);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solutionofthelinearsystem"></a> </p><h3>Solution of the linear system</h3>
<p>For solving the linear system, we pick a simple Jacobi-preconditioned conjugate gradient solver, similar to the settings in the early tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Solve linear system&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionRelaxation.html#a73fb0eab08209d015a20797c19127588">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of solver iterations:  &quot;</span></div><div class="line">            &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Outputofthesolutionandcomputationoferrors"></a> </p><h3>Output of the solution and computation of errors</h3>
<p>In the next function we do various post-processing steps with the solution, all of which involve the mapping in one way or the other.</p>
<p>The first operation we do is to write the solution as well as the material ids to a VTU file. This is similar to what was done in many other tutorial programs. The new ingredient presented in this tutorial program is that we want to ensure that the data written to the file used for visualization is actually a faithful representation of what is used internally by deal.II. That is because most of the visualization data formats only represent cells by their vertex coordinates, but have no way of representing the curved boundaries that are used in deal.II when using higher order mappings &ndash; in other words, what you see in the visualization tool is not actually what you are computing on. (The same, incidentally, is true when using higher order shape functions: Most visualization tools only render bilinear/trilinear representations. This is discussed in detail in <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>.)</p>
<p>So we need to ensure that a high-order representation is written to the file. We need to consider two particular topics. Firstly, we tell the <a class="el" href="classDataOut.html">DataOut</a> object via the <a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> that we intend to interpret the subdivisions of the elements as a high-order Lagrange polynomial rather than a collection of bilinear patches. Recent visualization programs, like ParaView version 5.5 or newer, can then render a high-order solution (see a <a href="https://github.com/dealii/dealii/wiki/Notes-on-visualizing-high-order-output">wiki page</a> for more details). Secondly, we need to make sure that the mapping is passed to the <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> method. Finally, the <a class="el" href="classDataOut.html">DataOut</a> class only prints curved faces for <em>boundary</em> cells by default, so we need to ensure that also inner cells are printed in a curved representation via the mapping.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Write output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; material_ids(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      material_ids[cell-&gt;active_cell_index()] = cell-&gt;material_id();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(material_ids, <span class="stringliteral">&quot;material_ids&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                           fe.degree,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">    std::ofstream file(</div><div class="line">      (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">       <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 10 + 2 * dim) +</div><div class="line">       <span class="stringliteral">&quot;.vtu&quot;</span>)</div><div class="line">        .c_str());</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(file);</div><div class="line">  }</div></div><!-- fragment --><p>The next operation in the postprocessing function is to compute the \(L_2\) and \(H^1\) errors against the analytical solution. As the analytical solution is a quadratic polynomial, we expect a very accurate result at this point. If we were solving on a simple mesh with planar faces and a coefficient whose jumps are aligned with the faces between cells, then we would expect the numerical result to coincide with the analytical solution up to roundoff accuracy. However, since we are using deformed cells following a sphere, which are only tracked by polynomials of degree 4 (one more than the degree for the finite elements), we will see that there is an error around \(10^{-7}\). We could get more accuracy by increasing the polynomial degree or refining the mesh.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error norms&quot;</span>);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; norm_per_cell_p(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactSolution&lt;dim&gt;(),</div><div class="line">                                    norm_per_cell_p,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   L2 error vs exact solution:   &quot;</span></div><div class="line">            &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactSolution&lt;dim&gt;(),</div><div class="line">                                    norm_per_cell_p,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   H1 error vs exact solution:   &quot;</span></div><div class="line">            &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The final post-processing operation we do here is to compute an error estimate with the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>. We use the exact same settings as in the <a class="el" href="step_6.html">step-6</a> tutorial program, except for the fact that we also hand in the mapping to ensure that errors are evaluated along the curved element, consistent with the remainder of the program. However, we do not really use the result here to drive a mesh adaptation step (that would refine the mesh around the material interface along the sphere), as the focus here is on the cost of this operation.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error estimator&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      mapping,</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Max cell-wise error estimate: &quot;</span></div><div class="line">              &lt;&lt; estimated_error_per_cell.linfty_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThePoissonProblemrunfunction"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem::run()</a> function</h3>
<p>Finally, we define the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function that controls how we want to execute this program (which is called by the main() function in the usual way). We start by calling the <code>create_grid()</code> function that sets up our geometry with the appropriate manifolds. We then run two instances of a solver chain, starting from the setup of the equations, the assembly of the linear system, its solution with a simple iterative solver, and the postprocessing discussed above. The two instances differ in the way they use the mapping. The first uses a conventional <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> mapping object which we initialize to a degree one more than we use for the finite element &ndash; after all, we expect the geometry representation to be the bottleneck as the analytic solution is only a quadratic polynomial. (In reality, things are interlinked to quite some extent because the evaluation of the polynomials in real coordinates involves the mapping of a higher-degree polynomials, which represent some smooth rational functions. As a consequence, higher-degree polynomials still pay off, so it does not make sense to increase the degree of the mapping further.) Once the first pass is completed, we let the timer print a summary of the compute times of the individual stages.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  create_grid();</div><div class="line"></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;====== Running with the basic MappingQGeneric class ====== &quot;</span></div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">    setup_system(mapping);</div><div class="line">    assemble_system(mapping);</div><div class="line">    solve();</div><div class="line">    postprocess(mapping);</div><div class="line"></div><div class="line">    timer.print_summary();</div><div class="line">    timer.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">  }</div></div><!-- fragment --><p>For the second instance, we instead set up the <a class="el" href="classMappingQCache.html">MappingQCache</a> class. Its use is very simple: After constructing it (with the degree, given that we want it to show the correct degree functionality in other contexts), we fill the cache via the <a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">MappingQCache::initialize()</a> function. At this stage, we specify which mapping we want to use (obviously, the same <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> as previously in order to repeat the same computations) for the cache, and then run through the same functions again, now handing in the modified mapping. In the end, we again print the accumulated wall times since the reset to see how the times compare to the original setting.</p>
<div class="fragment"><div class="line">    {</div><div class="line">      std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;====== Running with the optimized MappingQCache class ====== &quot;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQCache.html">MappingQCache&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Initialize mapping cache&quot;</span>);</div><div class="line">        mapping.initialize(<a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>(fe.degree + 1), triangulation);</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Memory consumption cache:     &quot;</span></div><div class="line">                &lt;&lt; 1e-6 * mapping.memory_consumption() &lt;&lt; <span class="stringliteral">&quot; MB&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">    }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step65</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Step65::PoissonProblem&lt;3&gt; test_program;</div><div class="line">  test_program.run();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>If we run the three-dimensional version of this program with polynomials of degree three, we get the following program output:</p>
<div class="fragment"><div class="line">&gt; make run</div><div class="line">Scanning dependencies of target step-65</div><div class="line">[ 33%] Building CXX <span class="keywordtype">object</span> CMakeFiles/step-65.dir/step-65.cc.o</div><div class="line">[ 66%] Linking CXX executable step-65</div><div class="line">[ 66%] Built target step-65</div><div class="line">[100%] Run step-65 with Release configuration</div><div class="line"></div><div class="line">====== Running with the basic <a class="code" href="classMappingQGeneric.html">MappingQGeneric</a> <span class="keyword">class </span>======</div><div class="line"></div><div class="line">   Number of active cells:       6656</div><div class="line">   Number of degrees of freedom: 181609</div><div class="line">   Number of solver iterations:  285</div><div class="line">   <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> error vs exact solution:   8.99339e-08</div><div class="line">   H1 error vs exact solution:   6.45341e-06</div><div class="line">   Max cell-wise error estimate: 0.00743406</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      49.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble linear system          |         1 |       5.8s |        12% |</div><div class="line">| Compute constraints             |         1 |     0.109s |      0.22% |</div><div class="line">| Compute error estimator         |         1 |      16.5s |        33% |</div><div class="line">| Compute error norms             |         1 |      9.11s |        18% |</div><div class="line">| Solve linear system             |         1 |      9.92s |        20% |</div><div class="line">| Write output                    |         1 |      4.85s |       9.8% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">====== Running with the optimized <a class="code" href="classMappingQCache.html">MappingQCache</a> class ======</div><div class="line"></div><div class="line">   Memory consumption cache:     22.9981 MB</div><div class="line">   Number of active cells:       6656</div><div class="line">   Number of degrees of freedom: 181609</div><div class="line">   Number of solver iterations:  285</div><div class="line">   <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> error vs exact solution:   8.99339e-08</div><div class="line">   H1 error vs exact solution:   6.45341e-06</div><div class="line">   Max cell-wise error estimate: 0.00743406</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      18.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble linear system          |         1 |      1.44s |       7.8% |</div><div class="line">| Compute constraints             |         1 |   0.00336s |         0% |</div><div class="line">| Compute error estimator         |         1 |     0.476s |       2.6% |</div><div class="line">| Compute error norms             |         1 |     0.505s |       2.7% |</div><div class="line">| Initialize mapping cache        |         1 |      4.96s |        27% |</div><div class="line">| Solve linear system             |         1 |      9.95s |        54% |</div><div class="line">| Write output                    |         1 |     0.875s |       4.8% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">[100%] Built target run</div></div><!-- fragment --><p>Before discussing the timings, we look at the memory consumption for the <a class="el" href="classMappingQCache.html">MappingQCache</a> object: Our program prints that it utilizes 23 MB of memory. If we relate this number to the memory consumption of a single (solution or right hand side) vector, which is 1.5 MB (namely, 181,609 elements times 8 bytes per entry in double precision), or to the memory consumed by the system matrix and the sparsity pattern (which is 274 MB), we realize that it is not an overly heavy data structure, given its benefits.</p>
<p>With respect to the timers, we see a clear improvement in the overall run time of the program by a factor of 2.7. If we disregard the iterative solver, which is the same in both cases (and not optimal, given the simple preconditioner we use, and the fact that sparse matrix-vector products waste operations for cubic polynomials), the advantage is a factor of almost 5. This is pretty impressive for a linear stationary problem, and cost savings would indeed be much more prominent for time-dependent and nonlinear problems where assembly is called several times. If we look into the individual components, we get a clearer picture of what is going on and why the cache is so efficient: In the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> case, essentially every operation that involves a mapping take at least 5 seconds to run. The norm computation runs two <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> functions, which each take almost 5 seconds. (The computation of constraints is cheaper because it only evaluates the mapping in cells at the boundary for the interpolation of boundary conditions.) If we compare these 5 seconds to the time it takes to fill the <a class="el" href="classMappingQCache.html">MappingQCache</a>, which is 5.2 seconds (for all cells, not just the active ones), it becomes obvious that the computation of the mapping support points dominates over everything else in the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> case. Perhaps the most striking result is the time for the error estimator, labeled "Compute error
estimator", where the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> implementation takes 17.3 seconds and the <a class="el" href="classMappingQCache.html">MappingQCache</a> variant less than 0.5 seconds. The reason why the former is so expensive (three times more expensive than the assembly, for instance) is that the error estimation involves evaluation of quantities over faces, where each face in the mesh requests additional points of the mapping that in turn go through the very expensive <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class. As there are six faces per cell, this happens much more often than in assembly. Again, <a class="el" href="classMappingQCache.html">MappingQCache</a> nicely eliminates the repeated evaluation, aggregating all the expensive steps involving the manifold in a single initialization call that gets repeatedly used.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2019 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> * This tutorial program was contributed by Martin Kronbichler</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__cache_8h.html">deal.II/fe/mapping_q_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step65</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">        <span class="keywordflow">return</span> p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>();</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0.1 * p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() + (0.25 - 0.025);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">        <span class="keywordflow">return</span> 2. * p;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0.2 * p;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> coefficient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">      <span class="keywordflow">return</span> 0.5;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 5.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PoissonProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PoissonProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> create_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;      system_matrix;</div><div class="line">    Vector&lt;double&gt;            solution;</div><div class="line">    Vector&lt;double&gt;            system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PoissonProblem&lt;dim&gt;::PoissonProblem()</div><div class="line">    : fe(3)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::create_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_inner;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria_inner, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_outer;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">      tria_outer, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5, std::sqrt(dim), 2 * dim);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria_inner, tria_outer, triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordtype">bool</span> face_at_sphere_boundary = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : face-&gt;vertex_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (std::abs(face-&gt;vertex(v).norm_square() - 0.25) &gt; 1e-12)</div><div class="line">                  face_at_sphere_boundary = <span class="keyword">false</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">if</span> (face_at_sphere_boundary)</div><div class="line">              face-&gt;set_all_manifold_ids(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;center().norm_square() &lt; 0.25)</div><div class="line">          cell-&gt;set_material_id(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          cell-&gt;set_material_id(0);</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> transfinite_manifold;</div><div class="line">    transfinite_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, transfinite_manifold);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(9 - 2 * dim);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute constraints&quot;</span>);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        mapping, dof_handler, 0, ExactSolution&lt;dim&gt;(), constraints);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Assemble linear system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> partial_matrix(dofs_per_cell, dim * n_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0.;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient =</div><div class="line">              coefficient(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                  partial_matrix(i, q_index * dim + d) =</div><div class="line">                    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index) * current_coefficient) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">                cell_rhs(i) +=</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                   (-dim) *                            <span class="comment">// f(x_q)</span></div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        partial_matrix.mTmult(cell_matrix, partial_matrix);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Solve linear system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionRelaxation.html#a73fb0eab08209d015a20797c19127588">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of solver iterations:  &quot;</span></div><div class="line">              &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Write output&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">      <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">      flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;double&gt; material_ids(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        material_ids[cell-&gt;active_cell_index()] = cell-&gt;material_id();</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(material_ids, <span class="stringliteral">&quot;material_ids&quot;</span>);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                             fe.degree,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">      std::ofstream file(</div><div class="line">        (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">         <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 10 + 2 * dim) +</div><div class="line">         <span class="stringliteral">&quot;.vtu&quot;</span>)</div><div class="line">          .c_str());</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(file);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error norms&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;double&gt; norm_per_cell_p(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        ExactSolution&lt;dim&gt;(),</div><div class="line">                                        norm_per_cell_p,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   L2 error vs exact solution:   &quot;</span></div><div class="line">                &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        ExactSolution&lt;dim&gt;(),</div><div class="line">                                        norm_per_cell_p,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   H1 error vs exact solution:   &quot;</span></div><div class="line">                &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error estimator&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        mapping,</div><div class="line">        dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Max cell-wise error estimate: &quot;</span></div><div class="line">                &lt;&lt; estimated_error_per_cell.linfty_norm() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    create_grid();</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;====== Running with the basic MappingQGeneric class ====== &quot;</span></div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">      timer.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;====== Running with the optimized MappingQCache class ====== &quot;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQCache.html">MappingQCache&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Initialize mapping cache&quot;</span>);</div><div class="line">        mapping.initialize(<a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>(fe.degree + 1), triangulation);</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Memory consumption cache:     &quot;</span></div><div class="line">                &lt;&lt; 1e-6 * mapping.memory_consumption() &lt;&lt; <span class="stringliteral">&quot; MB&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">    }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step65</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Step65::PoissonProblem&lt;3&gt; test_program;</div><div class="line">  test_program.run();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_49.html">step-49</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Workingwithmanifolds">Working with manifolds</a><a href="#Workingwithmanifolds">Working with manifolds</a>
      <ul>
        <li><a href="#Whatwewant">What we want</a><a href="#Whatwewant">What we want</a>
      </ul>
        <li><a href="#TheclassTransfiniteInterpolationManifold">The class TransfiniteInterpolationManifold</a><a href="#TheclassTransfiniteInterpolationManifold">The class TransfiniteInterpolationManifold</a>
      <ul>
        <li><a href="#Howitworks">How it works</a><a href="#Howitworks">How it works</a>
      </ul>
        <li><a href="#Transfiniteinterpolationisexpensiveandhowtodealwithit">Transfinite interpolation is expensive and how to deal with it</a><a href="#Transfiniteinterpolationisexpensiveandhowtodealwithit">Transfinite interpolation is expensive and how to deal with it</a>
        <li><a href="#Thetestcase">The test case</a><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Analyticalsolutionandcoefficient">Analytical solution and coefficient</a><a href="#Analyticalsolutionandcoefficient">Analytical solution and coefficient</a>
        <li><a href="#ThePoissonProblemclass">The PoissonProblem class</a><a href="#ThePoissonProblemclass">The PoissonProblem class</a>
        <li><a href="#Gridcreationandinitializationofthemanifolds">Grid creation and initialization of the manifolds</a><a href="#Gridcreationandinitializationofthemanifolds">Grid creation and initialization of the manifolds</a>
        <li><a href="#Setupofdatastructures">Setup of data structures</a><a href="#Setupofdatastructures">Setup of data structures</a>
        <li><a href="#Assemblyofthesystemmatrixandrighthandside">Assembly of the system matrix and right hand side</a><a href="#Assemblyofthesystemmatrixandrighthandside">Assembly of the system matrix and right hand side</a>
        <li><a href="#Solutionofthelinearsystem">Solution of the linear system</a><a href="#Solutionofthelinearsystem">Solution of the linear system</a>
        <li><a href="#Outputofthesolutionandcomputationoferrors">Output of the solution and computation of errors</a><a href="#Outputofthesolutionandcomputationoferrors">Output of the solution and computation of errors</a>
        <li><a href="#ThePoissonProblemrunfunction">The PoissonProblem::run() function</a><a href="#ThePoissonProblemrunfunction">The PoissonProblem::run() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a><a href="#Programoutput">Program output</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 </p><pre class="fragment">&lt;br&gt;  
</pre><p> <em> This program was contributed by Martin Kronbichler. </em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program presents an advanced manifold class,<a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>, and how to work around its maindisadvantage, the relatively high cost. <a class="anchor" id="Workingwithmanifolds"></a></p><h3>Working with manifolds</h3>
<p><a class="anchor" id="Whatwewant"></a></p><h4>What we want</h4>
<p>In many applications, the finite element mesh must be able to represent arelatively complex geometry. In the <a class="el" href="step_1.html">step-1</a> , <a class="el" href="step_49.html">step-49</a> , and <a class="el" href="step_53.html">step-53</a> tutorialprograms, some techniques to generate grids available within the deal.IIlibrary have been introduced. Given a base mesh, deal.II is then able tocreate a finer mesh by subdividing the cells into children, either uniformlyor only in selected parts of the computational domain. Besides the basicmeshing capabilities collected in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, deal.II alsocomes with interfaces to read in meshes generated by (quad- and hex-only) meshgenerators using the functions of namespace <a class="el" href="classGridIn.html">GridIn</a>, as for exampledemonstrated in <a class="el" href="step_5.html">step-5</a> . A fundamental limitation ofexternally generated meshes is that the information provided by the generatedcells in the mesh only consists of the position of the vertices and theirconnectivity, without the context of the underlying geometry that used to beavailable in the mesh generator that originally created this mesh. Thisbecomes problematic once the mesh is refined within deal.II and additionalpoints need to be placed. The <a class="el" href="step_54.html">step-54</a> tutorial program shows how toovercome this limitation by using CAD surfaces in terms of the OpenCASCADElibrary, and <a class="el" href="step_53.html">step-53</a> by providing the same kind of informationprogrammatically from within the source code. Within deal.II, the placement of new points during mesh refinement or for thedefinition of higher order mappings is controlled by manifold objects, see the <a class="el" href="group__manifold.html">manifold module</a>for details.To give an example, consider the following situation of a two-dimensionalannulus (with pictures taken from the manifold module). If we start with aninitial mesh of 10 cells and refine the mesh three times globally withoutattaching any manifolds, we would obtain the following mesh: </p><div class="image">
<img src="hypershell-nothing.png" alt="hypershell-nothing.png"/>
</div>
<p> The picture looks like this because, by default, deal.II only knowswhere to put the vertices of child cells by averaging the locations ofthe vertices of the parent cell. This yields a polygonal domain whosefaces are the edges of the original (coarse mesh) cells.Obviously, we must attach a curved description to the boundary faces of thetriangulation to reproduce the circular shape upon mesh refinement, like inthe following picture: </p><div class="image">
<img src="hypershell-boundary-only.png" alt="hypershell-boundary-only.png"/>
</div>
<p> This is better: At least the inner and outer boundaries are nowapproaching real circles if we continue to refine the mesh.However, the mesh in this picture is still not optimal for an annulus in thesense that the <em>interior</em> lines from one cell to the next have kinks at certain vertices,and one would rather like to use the following mesh: </p><div class="image">
<img src="hypershell-all.png" alt="hypershell-all.png"/>
</div>
<p> In this last (optimal) case, which is also the default produced by <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, the curved manifold description (in this case apolar manifold description) is applied not only to the boundary faces, but tothe whole domain. Whenever the triangulation requests a new point, e.g., themid point of the edges or the cells when it refines a cell into four children,it will place them along the respective mid points in the polar coordinatesystem. By contrast, the case above where only the boundary was subject to thepolar manifold, only mid points along the boundary would be placed along thecurved description, whereas mid points in the interior would be computed bysuitable averages of the surrounding points in the Cartesian coordinate system(see the <a class="el" href="group__manifold.html">manifold module</a> for more details). At this point, one might assume that curved volume descriptions are the way togo. This is generally not wrong, though it is sometimes not so easy todescribe how exactly this should work. Here are a couple of examples:</p>
<ul>
<li>Imagine that the mesh above had actually been a disk, not just a ring. In that case the polar manifold degenerates at the origin and would not produce reasonable new points. In fact, defining a manifold description for things that are supposed "to look round" but might have points at or close to the origin is surprisingly very difficult.</li>
<li>A similar thing happens at the origin of the three-dimensional ball when one tries to attach a spherical manifold to the whole volume &ndash; in this case, the computation of new manifold points would abort with an exception.</li>
<li>CAD geometries often only describe the boundary of the domain, in a similar way to how we only attached a manifold to the boundary in the second picture above. Similarly, <a class="el" href="step_54.html">step-54</a> only uses the CAD geometry to generate a surface mesh (maybe because that is what is needed to solve the problem in question), but if one wanted to solve a problem in the water or the air around the ship described there, we would need to have a volume mesh. The question is then how exactly we should describe what is supposed to happen in the interior of the domain. These simple examples make it clear thatfor many interesting cases we must step back from the desire to have ananalytic curved description for the full volume: There will need to be<em>some</em> kind of information that leads to curvature also in theinterior, but it must be possible to do this without actually writingdown an explicit formula that describes the kind of geometry. So what happens if we don't do anything at all in the interior andonly describe the surface as a manifold? Sometimes, as in the ringshown above, the result is not terrible. But sometimes it is. Consider thecase of a torus (e.g. generated with <a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">GridGenerator::torus()</a>) with aTorusManifold object attached to the surface only, no additional manifolds onthe interior cells and faces, and with six cells in toroidal direction beforerefinement. If the mesh is refined once, we would obtain the following mesh,shown with the upper half of the mesh clipped away: <div class="image">
<img src="torus_no_inner_manifold.png" alt="torus_no_inner_manifold.png"/>
</div>
 This is clearly sub-optimal. Indeed, if we had started with fewer thanthe six cells shown above in toroidal direction, the mapping actuallyinverts in some regionsbecause the new points placed along interior cells intersect with the boundaryas they are not following the circular shape along the toroidal direction. Thesimple case of a torus can still be fixed because we know that the toroidaldirection follows a cylindrical coordinate system, so attaching aTorusManifold to the surface combined with <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> withappropriate periodicity in toroidal direction applied to all interior entitieswould produce a high-quality mesh as follows, now shown with two top cellshidden: <div class="image">
<img src="torus_cylindrical_inner_manifold.png" alt="torus_cylindrical_inner_manifold.png"/>
</div>
 This mesh is pretty good, but obviously it is linked to a good description ofthe volume, which we lack in other cases. Actually, there is an imperfectionalso in this case, as we can see some unnatural kinks of two adjacent cells inthe interior of the domain which are hidden by the top two boundary cells, asopposed to the following setup (the default manifolds applied by <a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">GridGenerator::torus()</a> and using the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>): <div class="image">
<img src="torus_transfinite_manifold.png" alt="torus_transfinite_manifold.png"/>
</div>
 <a class="anchor" id="TheclassTransfiniteInterpolationManifold"></a><h3>The class <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a></h3>
</li>
</ul>
<p>In order to find a better strategy, let us look at the two-dimensional diskagain (that is also the base entity rotated along the toroidal direction inthe torus). As we learned above, we can only apply the curved polardescription to the boundary (or a rim of cells sufficiently far away from theorigin) but must eventually transition to a straight description towards thedisk's center. If we use a flat manifold in the interior of the cells(i.e., one in which new vertices are created by averaging of theadjacent existing ones) and apolar manifold only for the boundary of the disk, we get the following meshupon four global refinements: </p><div class="image">
<img src="circular_mesh_only_boundary_manifold.png" alt="circular_mesh_only_boundary_manifold.png"/>
</div>
<p> That's not a terrible mesh. At the same time,if you know that the original coarse mesh consisted of a single squarein the middle, with four caps around it, then it's not hard to seeevery refinement step that happened to this mesh to get the pictureabove. While the triangulation class of deal.II tries to propagate information fromthe boundary into the interior when creating new points, the reach of thisalgorithm is limited: </p><div class="image">
<img src="circular_mesh_boundary_cells.png" alt="circular_mesh_boundary_cells.png"/>
</div>
<p> The picture above highlights those cells on the disk that are touching theboundary and where boundary information could in principle be taken intoaccount when only looking at a single cell at the time. Clearly, the areawhere some curvature can be taken into account gets more limited as the meshis refined, thus creating the seemingly irregular spots in the mesh: Whencomputing the center of any one of the boundary cells in the leftmost picture,the ideal position is the mid point between the outer circle and the cell inthe middle. This is exactly what is used for the first refinement step in theTriangulation class. However, for the second refinement all interior edges aswell as the interior cell layers can only add points according to a flatmanifold description. At this point, we realize what would be needed to create a better mesh: For<em>all</em> new points in <em>any</em> child cell that is created within the red shadedlayer on the leftmost picture, we want to compute the interpolation withrespect to the curvature in the area covered by the respective coarsecell. This is achieved by adding the class <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> tothe highlighted cells of the coarse grid in the leftmost panel of the figureabove. This class adheres to the general manifold interfaces, i.e., given anyset of points within its domain of definition, it can compute weightedaverages conforming to the manifold (using a formula that will be given in aminute). These weighted averages are used whenever the mesh is refined, orwhen a higher order mapping (such as <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> or <a class="el" href="classMappingC1.html">MappingC1</a>)is evaluated on a given cellsubject to this manifold. Using this manifold on the shaded cells of thecoarse grid of the disk (i.e., not only in the outer-most layer ofcells) produces the following mesh upon four globalsteps of refinement: </p><div class="image">
<img src="circular_mesh_transfinite_interpolation.png" alt="circular_mesh_transfinite_interpolation.png"/>
</div>
<p> There are still some kinks in the lines of this mesh, but they arerestricted to the faces between coarse mesh cells, whereas the rest ofthe mesh is about as smooth as one would like. Indeed,given a straight-sided central cell, this representation is the best possibleone as all mesh cells follow a smooth transition from the straight sides inthe square block in the interior to the circular shape on the boundary. (Onecould possibly do a bit better by allowing some curvature also in the centralsquare block, that eventually vanishes as the center is approached.)</p>
<p><a class="anchor" id="Howitworks"></a></p><h4>How it works</h4>
<p>In the simple case of a disk with one curved and three straight edges, we canexplicitly write down how to achieve the blending of the shapes. For this, itis useful to map the physical cell, like the top one, back to the referencecoordinate system \((\xi,\eta)\in (0,1)^2\) where we compute averages betweencertain points. If we were to use a simple bilinear map spanned by fourvertices \((x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)\) , the image of a point \((\xi, \eta)\in (0,1)^2\) would be </p><p class="formulaDsp">
\begin{align*} (x,y) = (1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) + (1-\xi)\eta (x_2,y_2) + \xi\eta (x_3,y_3). \end{align*}
</p>
<p>For the case of the curved surface, we want to modify this formula. For thetop cell of the coarse mesh of the disk, we can assume that the points \((x_0,y_0)\) and \((x_1,y_1)\) sit along the straight line at the lower end andthe points \((x_2,y_2)\) and \((x_3,y_3)\) are connected by a quarter circle alongthe top. We would then map a point \((\xi, \eta)\) as </p><p class="formulaDsp">
\begin{align*} (x,y) = (1-\eta) \big[(1-\xi) (x_0,y_0) + \xi (x_1,y_1)\big] + \eta \mathbf{c}_3(\xi), \end{align*}
</p>
<p> where \(\mathbf{c}_3(\xi)\) is a curve that describes the \((x,y)\) coordinates ofthe quarter circle in terms of an arclength parameter \(\xi\in (0,1)\) . Thisrepresents a linear interpolation between the straight lower edge and thecurved upper edge of the cell, and is the basis for the picture shown above. This formula is easily generalized to the case where all four edges aredescribed by a curve rather than a straight line. We call the four functions,parameterized by a single coordinate \(\xi\) or \(\eta\) in the horizontal andvertical directions, \(\mathbf{c}_0, \mathbf{c}_1, \mathbf{c}_2, \mathbf{c}_3\) for the left, right, lower, and upper edge of aquadrilateral, respectively. The interpolation then reads </p><p class="formulaDsp">
\begin{align*} (x,y) =&amp; (1-\xi)\mathbf{c}_0(\eta) + \xi \mathbf{c}_1(\eta) +(1-\eta)\mathbf{c}_2(\xi) + \eta \mathbf{c}_3(\xi)\\ &amp;-\big[(1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) + (1-\xi)\eta (x_2,y_2) + \xi\eta (x_3,y_3)\big]. \end{align*}
</p>
<p>This formula assumes that the boundary curves match and coincide with thevertices \((x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)\) , e.g. \(\mathbf{c}_0(0) = (x_0,y_0)\) or \(\mathbf{c}_0(1) = (x_2,y_2)\) . The subtraction of the bilinearinterpolation in the second line of the formula makes sure that the prescribedcurves are followed exactly on the boundary: Along each of the four edges, weneed to subtract the contribution of the two adjacent edges evaluated in thecorners, which is then simply a vertex position. It is easy to checkthat the formula for the circle above is reproduced if three of the fourcurves \(\mathbf{c}_i\) are straight and thus coincide with the bilinearinterpolation. This formula, called transfinite interpolation, was introduced in 1973 by <a href="https://doi.org/10.1002%2Fnme.1620070405">Gordon and Hall</a>. Eventhough transfinite interpolation essentially only represents a linear blendingof the bounding curves, the interpolation exactly follows the boundary curvesfor each real number \(\xi\in (0,1)\) or \(\eta\in (0,1)\) , i.e., it interpolatesin an infinite number of points, which was the original motivation to labelthis variant of interpolation a transfinite one by Gordon and Hall. Anotherinterpretation is that the transfinite interpolation interpolates from theleft and right and the top and bottom linearly, from which we need to subtractthe bilinear interpolation to ensure a unit weight in the interior of thedomain. The transfinite interpolation is easily generalized to three spatialdimensions. In that case, the interpolation allows to blend 6 differentsurface descriptions for any of the quads of a three-dimensional cell and 12edge descriptions for the lines of a cell. Again, to ensure a consistent map,it is necessary to subtract the contribution of edges and add the contributionof vertices again to make the curves follow the prescribed surface or edgedescription. In the three-dimensional case, it is also possible to use atransfinite interpolation from a curved edge both into the adjacent faces andthe adjacent cells. The interpolation of the transfinite interpolation in deal.II is general inthe sense that it can deal with arbitrary curves. It will evaluate the curvesin terms of their original coordinates of the \(d\) -dimensional space but withone (or two, in the case of edges in 3D) coordinate held fixed at \(0\) or \(1\) to ensurethat any other manifold class, including CAD files if desired, can be appliedout of the box. Transfinite interpolation is a standard ingredient in meshgenerators, so the main strength of the integration of this feature within thedeal.II library is to enable it during adaptive refinement and coarsening ofthe mesh, and for creating higher-degree mappings that use manifolds to insertadditional points beyond the mesh vertices. As a final remark on transfinite interpolation, we mention that the meshrefinement strategies in deal.II in absence of a volume manifold descriptionare also based on the weights of the transfinite interpolation and optimal inthat sense. The difference is that the default algorithm sees only onecell at a time, and so will apply the optimal algorithm only on thosecells touching the curved manifolds. In contrast, using thetransfinite mapping on entire <em>patches</em> of cells (originatingfrom one coarser cell) allows to use the transfinite interpolationmethod in a way that propagates information from the boundary to cellsfar away.</p>
<p><a class="anchor" id="Transfiniteinterpolationisexpensiveandhowtodealwithit"></a></p><h3>Transfinite interpolation is expensive and how to deal with it</h3>
<p>A mesh with a transfinite manifold description is typically set up in twosteps. The first step is to create a coarse mesh (or read it in from a file) and toattach a curved manifold to some of the mesh entities. For the above exampleof the disk, we attach a polar manifold to the faces along the outer circle(this is done automatically by   GridGenerator::hyper_ball()). Before we startrefining the mesh, we then assign a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to allinterior cells and edges of the mesh, which of course needs to be based onsome manifold id that we have assigned to those entities (everything exceptthe circle on the boundary). It does not matter whether we also assign aTransfiniteInterpolationManifold to the inner square of the disk or notbecause the transfinite interpolation on a coarse cell with straightedges (or flat faces in 3d) simply yields subdivided children withstraight edges (flat faces). Later, when the mesh is refined or when a higher-order mapping is set up basedon this mesh, the cells will query the underlying manifold object for newpoints. This process takes a set of surrounding points, for example the fourvertices of a two-dimensional cell, and a set of weights to each of thesepoints, for definition a new point. For the mid point of a cell, each of thefour vertices would get weight 0.25. For the transfinite interpolationmanifold, the process of building weighted sums requires some serious work. Byconstruction, we want to combine the points in terms of the referencecoordinates \(\xi\) and \(\eta\) (or \(\xi, \eta, \zeta\) in 3D) of the surroundingpoints. However, the interface of the manifold classes in deal.II does not getthe reference coordinates of the surrounding points (as they are not storedglobally) but rather the physical coordinates only. Thus, the first step thetransfinite interpolation manifold has to do is to invert the mapping and findthe reference coordinates within one of the coarse cells of the transfiniteinterpolation (e.g. one of the four shaded coarse-grid cells of the disk meshabove). This inversion is done by a Newton iteration (or rather,finite-difference based Newton scheme combined with Broyden's method) andqueries the transfinite interpolation according to the formula above severaltimes. Each of these queries in turn might call an expensive manifold, e.g. aspherical description of a ball, and be expensive on its own. Since theManifold interface class of deal.II only provides a set of points, thetransfinite interpolation initially does not even know to which coarse gridcell the set of surrounding points belong to and needs to search among severalcells based on some heuristics. In terms of <a href="https://en.wikipedia.org/wiki/Atlas_(topology)#Charts">charts</a>,one could describe theimplementation of the transfinite interpolation as an <a href="https://en.wikipedia.org/wiki/Atlas_(topology)">atlas</a>-basedimplementation: Each cell of the initial coarse grid of the triangulationrepresents a chart with its own reference space, and the surrounding manifoldsprovide a way to transform from the chart space (i.e., the reference cell) tothe physical space. The collection of the charts of the coarse grid cells isan atlas, and as usual, the first thing one does when looking up something inan atlas is to find the right chart. Once the reference coordinates of the surrounding points have been found, anew point in the reference coordinate system is computed by a simple weightedsum. Finally, the reference point is inserted into the formula for thetransfinite interpolation, which gives the desired new point. In a number of cases, the curved manifold is not only used during meshrefinement, but also to ensure a curved representation of boundaries withinthe cells of the computational domain. This is a necessity to guaranteehigh-order convergence for high-order polynomials on complex geometriesanyway, but sometimes an accurate geometry is also desired with linear shapefunctions. This is often done by polynomial descriptions of the cells andcalled the isoparametric concept if the polynomial degree to represent thecurved mesh elements is the same as the degree of the polynomials for thenumerical solution. If the degree of the geometry is higher or lower than thesolution, one calls that a super- or sub-parametric geometry representation,respectively. In deal.II, the standard class for polynomial representation isMappingQGeneric. If, for example, this class is used with polynomial degree \(4\) in 3D, atotal of 125 (i.e., \((4+1)^3\) ) points are needed for theinterpolation. Among these points, 8 are the cell's vertices and alreadyavailable from the mesh, but the other 117 need to be provided by themanifold. In case the transfinite interpolation manifold is used, we canimagine that going through the pull-back into reference coordinates of someyet to be determined coarse cell, followed by subsequent push-forward on eachof the 117 points, is a lot of work and can be very time consuming. What makes things worse is that the structure of many programs is suchthat themapping is queried several times independently for the same cell. Its primaryuse is in the assembly of the linear system, i.e., the computation of thesystem matrix and the right hand side, via the <code>mapping</code> argument of theFEValues object. However, also the interpolation of boundary values, thecomputation of numerical errors, writing the output, and evaluation of errorestimators must involve the same mapping to ensure a consistent interpretationof the solution vectors. Thus, even a linear stationary problem that is solvedonce will evaluate the points of the mapping several times. For the cubic casein 3D mentioned above, this means computing 117 points per cell by anexpensive algorithm many times. The situation is more pressing for nonlinearor time-dependent problems where those operations are done over and overagain. As the manifold description via a transfinite interpolation can easily behundreds of times more expensive than a similar query on a flat manifold, itmakes sense to compute the additional points only once and use them in allsubsequent calls. The deal.II library provides the class <a class="el" href="classMappingQCache.html">MappingQCache</a> forexactly this purpose. The cache is typically not overly big compared to thememory consumed by a system matrix, as will become clear when looking at theresults of this tutorial program. The usage of <a class="el" href="classMappingQCache.html">MappingQCache</a> is simple: Oncethe mesh has been set up (or changed during refinement), we call <a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">MappingQCache::initialize()</a> with the desired triangulation as well as adesired mapping as arguments. The initialization then goes through all cellsof the mesh and queries the given mapping for its additional points. Those getstored for an identifier of the cell so that they can later be returnedwhenever the mapping computes some quantities related to the cell (like theJacobians of the map between the reference and physical coordinates). As a final note, we mention that the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> alsomakes the refinement of the mesh more expensive. In this case, theMappingQCache does not help because it would compute points that cansubsequently not be re-used; there currently does not exist a moreefficient mechanism in deal.II. However, the mesh refinement contains manyother expensive steps as well, so it is not as big as an issue compared to therest of the computation. It also only happens at most once per timestep or nonlinear iteration. <a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>In this tutorial program, the usage of <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> isexemplified in combination with <a class="el" href="classMappingQCache.html">MappingQCache</a>. The test case is relativelysimple and takes up the solution stages involved in many typical programs,e.g., the <a class="el" href="step_6.html">step-6</a> tutorial program. As a geometry, we select one prototype useof <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>, namely a setup involving a spherical ballthat is in turn surrounded by a cube. Such a setup would be used, for example,for a spherical inclusion embedded in a background medium, and if thatinclusion has different material properties that require that theinterface between the two materials needs to be tracked by element interfaces. Avisualization of the grid is given here: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-65-mesh.png"/>
</div>
<p> For this case, we want to attach a spherical description to the surface insidethe domain and use the transfinite interpolation to smoothly switch to thestraight lines of the outer cube and the cube at the center of the ball. Within the program, we will follow a typical flow in finite element programs,starting from the setup of <a class="el" href="classDoFHandler.html">DoFHandler</a> and sparsity patterns, the assembly of alinear system for solving the Poisson equation with a jumping coefficient, itssolution with a simple iterative method, computation of some numerical errorwith <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> as well as an error estimator. Werecord timings for each section and run the code twice. In the first run, wehand a <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> object to each stage of the program separately, wherepoints get re-computed over and over again. In the second run, we useMappingQCache instead.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The include files for this tutorial are essentially the same as in <a class="el" href="step_6.html">step-6</a> . Importantly, the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class we will be using is provided by <code>deal.II/grid/manifold_lib.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>The only new include file is the one for the <a class="el" href="classMappingQCache.html">MappingQCache</a> class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__cache_8h.html">deal.II/fe/mapping_q_cache.h</a>&gt;</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step65</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Analyticalsolutionandcoefficient"></a> </p><h3>Analytical solution and coefficient</h3>
<p>In this tutorial program, we want to solve the Poisson equation with a coefficient that jumps along a sphere of radius 0.5, and using a constant right hand side of value \(f(\mathbf{x}) = -3\) . (This setup is similar to <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_6.html">step-6</a> , but the concrete values for the coefficient and the right hand side are different.) Due to the jump in the coefficient, the analytical solution must have a kink where the coefficient switches from one value to the other. To keep things simple, we select an analytical solution that is quadratic in all components, i.e., \(u(x,y,z) = x^2 + y^2 + z^2\) in the ball of radius 0.5 and \(u(x,y,z) = 0.1(x^2 + y^2 + z^2) + 0.25-0.025\) in the outer part of the domain. This analytical solution is compatible with the right hand side in case the coefficient is 0.5 in the inner ball and 5 outside. It is also continuous along the circle of radius 0.5.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">         <span class="keywordflow">return</span> p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>();</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">         <span class="keywordflow">return</span> 0.1 p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() + (0.25</div><div class="line">  </div><div class="line">- 0.025);</div><div class="line">     }</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">     <a class="code" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">         <span class="keywordflow">return</span> 2. p;</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">         <span class="keywordflow">return</span> 0.2 p;</div><div class="line">     }</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span> coefficient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">   {</div><div class="line">     <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">       <span class="keywordflow">return</span> 0.5;</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">       <span class="keywordflow">return</span> 5.0;</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="ThePoissonProblemclass"></a> </p><h3>The PoissonProblem class</h3>
<p>The implementation of the Poisson problem is very similar to what we used in the <a class="el" href="step_5.html">step-5</a> tutorial program. The two main differences are that we pass a mapping object to the various steps in the program in order to switch between two mapping representations as explained in the introduction, and the <code>timer</code> object (of type <a class="el" href="classTimerOutput.html">TimerOutput</a>) that will be used for measuring the run times in the various cases. (The concept of mapping objects was first introduced in <a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a> , in case you want to look up the use of these classes.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PoissonProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PoissonProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> create_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;      system_matrix;</div><div class="line">  Vector&lt;double&gt;            solution;</div><div class="line">  Vector&lt;double&gt;            system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p>In the constructor, we set up the timer object to record wall times but be quiet during the normal execution. We will query it for timing details in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem::run()</a></code> function. Furthermore, we select a relatively high polynomial degree of three for the finite element in use.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PoissonProblem&lt;dim&gt;::PoissonProblem()</div><div class="line">  : fe(3)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Gridcreationandinitializationofthemanifolds"></a> </p><h3>Grid creation and initialization of the manifolds</h3>
<p>The next function presents the typical usage of <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. The first step is to create the desired grid, which can be done by composition of two grids from <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>. The inner ball mesh is simple enough: We run <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a> centered at the origin with radius 0.5 (third function argument). The second mesh is more interesting and constructed as follows: We want to have a mesh that is spherical in the interior but flat on the outer surface. Furthermore, the mesh topology of the inner ball should be compatible with the outer grid in the sense that their vertices coincide so as to allow the two grid to be merged. The grid coming out of <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> fulfills the requirements on the inner side in case it is created with \(2d\) coarse cells (6 coarse cells in 3D which we are going to use) &ndash; this is the same number of cells as there are boundary faces for the ball. For the outer surface, we use the fact that the 6 faces on the surface of the shell without a manifold attached would degenerate to the surface of a cube. What we are still missing is the radius of the outer shell boundary. Since we desire a cube of extent \([-1, 1]\) and the 6-cell shell puts its 8 outer vertices at the 8 opposing diagonals, we must translate the points \((\pm 1, \pm 1, \pm 1)\) into a radius: Clearly, the radius must be \(\sqrt{d}\) in \(d\) dimensions, i.e., \(\sqrt{3}\) for the three-dimensional case we want to consider. Thus, we have a plan: After creating the inner triangulation for the ball and the one for the outer shell, we merge those two grids but remove all manifolds that the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> may have set from the resulting triangulation, to ensure that we have full control over manifolds. In particular, we want additional points added on the boundary during refinement to follow a flat manifold description. To start the process of adding more appropriate manifold ids, we assign the manifold id 0 to all mesh entities (cells, faces, lines), which will later be associated with the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. Then, we must identify the faces and lines that are along the sphere of radius 0.5 and mark them with a different manifold id, so as to then assign a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to those. We will choose the manifold id of 1. Since we have thrown away all manifolds that pre-existed after calling <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, we manually go through the cells of the mesh and all their faces. We have found a face on the sphere if all four vertices have a radius of 0.5, or, as we write in the program, have \(r^2-0.25 \approx 0\) . Note that we call <code>cell-&gt;face(f)-&gt;set_all_manifold_ids(1)</code> to set the manifold id both on the faces and the surrounding lines. Furthermore, we want to distinguish the cells inside the ball and outside the ball by a material id for visualization, corresponding to the picture in the introduction.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::create_grid()</div><div class="line">   {</div><div class="line">     <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_inner;</div><div class="line">     <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria_inner, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5);</div><div class="line">  </div><div class="line">     <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_outer;</div><div class="line">     <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">       tria_outer, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5, std::sqrt(dim), 2 dim);</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria_inner, tria_outer, triangulation);</div><div class="line">  </div><div class="line">     triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">     triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">       {</div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">           {</div><div class="line">             <span class="keywordtype">bool</span> face_at_sphere_boundary = <span class="keyword">true</span>;</div><div class="line">             <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : face-&gt;vertex_indices())</div><div class="line">               {</div><div class="line">                 <span class="keywordflow">if</span> (std::abs(face-&gt;vertex(v).norm_square()</div><div class="line">  </div><div class="line">- 0.25) &gt; 1e-12)</div><div class="line">                   face_at_sphere_boundary = <span class="keyword">false</span>;</div><div class="line">               }</div><div class="line">             <span class="keywordflow">if</span> (face_at_sphere_boundary)</div><div class="line">               face-&gt;set_all_manifold_ids(1);</div><div class="line">           }</div><div class="line">         <span class="keywordflow">if</span> (cell-&gt;center().norm_square() &lt; 0.25)</div><div class="line">           cell-&gt;set_material_id(1);</div><div class="line">         <span class="keywordflow">else</span></div><div class="line">           cell-&gt;set_material_id(0);</div><div class="line">       }</div></div><!-- fragment --><p>With all cells, faces and lines marked appropriately, we can attach the <a class="el" href="classManifold.html">Manifold</a> objects to those numbers. The entities with manifold id 1 will get a spherical manifold, whereas the other entities, which have the manifold id 0, will be assigned the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. As mentioned in the introduction, we must explicitly initialize the manifold with the current mesh using a call to <a class="el" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">TransfiniteInterpolationManifold::initialize()</a> in order to pick up the coarse mesh cells and the manifolds attached to the boundaries of those cells. We also note that the manifold objects we create locally in this function are allowed to go out of scope (as they do at the end of the function scope), because the <a class="el" href="classTriangulation.html">Triangulation</a> object internally copies them. With all manifolds attached, we will finally go about and refine the mesh a few times to create a sufficiently large test case.</p>
<div class="fragment"><div class="line">     triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>());</div><div class="line">  </div><div class="line">     <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> transfinite_manifold;</div><div class="line">     transfinite_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">     triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, transfinite_manifold);</div><div class="line">  </div><div class="line">     triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(9</div><div class="line">  </div><div class="line">- 2 dim);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="Setupofdatastructures"></a> </p><h3>Setup of data structures</h3>
<p>The following function is well-known from other tutorials in that it enumerates the degrees of freedom, creates a constraint object and sets up a sparse matrix for the linear system. The only thing worth mentioning is the fact that the function receives a reference to a mapping object that we then pass to the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function to ensure that our boundary values are evaluated on the high-order mesh used for assembly. In the present example, it does not really matter because the outer surfaces are flat, but for curved outer cells this leads to more accurate approximation of the boundary values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute constraints&quot;</span>);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, ExactSolution&lt;dim&gt;(), constraints);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyofthesystemmatrixandrighthandside"></a> </p><h3>Assembly of the system matrix and right hand side</h3>
<p>The function that assembles the linear system is also well known from the previous tutorial programs. One thing to note is that we set the number of quadrature points to the polynomial degree plus two, not the degree plus one as in most other tutorials. This is because we expect some extra accuracy as the mapping also involves a degree one more than the polynomials for the solution. The only somewhat unusual code in the assembly is the way we compute the cell matrix. Rather than using three nested loop over the quadrature point index, the row, and the column of the matrix, we first collect the derivatives of the shape function, multiplied by the square root of the product of the coefficient and the integration factor <code>JxW</code> in a separate matrix <code>partial_matrix</code>. To compute the cell matrix, we then execute <code>cell_matrix = partial_matrix transpose(partial_matrix)</code> in the line <code>partial_matrix.mTmult(cell_matrix, partial_matrix);</code>. To understand why this works, we realize that the matrix-matrix multiplication performs a summation over the columns of <code>partial_matrix</code>. If we denote the coefficient by \(a(\mathbf{x}_q)\) , the entries in the temporary matrix are \(\sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k}\) . If we take the product of the <em>i</em>th row with the <em>j</em>th column of that matrix, we compute a nested sum involving \(\sum_q \sum_{k=1}^d \sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k} = \sum_q \sum_{k=1}^d\text{det}(J) w_q a(x)\frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k}\) , which is exactly the terms needed for the bilinear form of the Laplace equation. The reason for choosing this somewhat unusual scheme is due to the heavy work involved in computing the cell matrix for a relatively high polynomial degree in 3D. As we want to highlight the cost of the mapping in this tutorial program, we better do the assembly in an optimized way in order to not chase bottlenecks that have been solved by the community already. Matrix-matrix multiplication is one of the best optimized kernels in the HPC context, and the <a class="el" href="classFullMatrix.html#ac074fc1dc416f8cd75bb01d820e74aa0">FullMatrix::mTmult()</a> function will call into those optimized BLAS functions. If the user has provided a good BLAS library when configuring deal.II (like OpenBLAS or Intel's MKL), the computation of the cell matrix will execute close to the processor's peak arithmetic performance. As a side note, we mention that despite an optimized matrix-matrix multiplication, the current strategy is sub-optimal in terms of complexity as the work to be done is proportional to \((p+1)^9\) operations for degree \(p\) (this also applies to the usual evaluation with <a class="el" href="classFEValues.html">FEValues</a>). One could compute the cell matrix with \(\mathcal O((p+1)^7)\) operations by utilizing the tensor product structure of the shape functions, as is done by the matrix-free framework in deal.II. We refer to <a class="el" href="step_37.html">step-37</a> and the documentation of the tensor-product-aware evaluators <a class="el" href="classFEEvaluation.html">FEEvaluation</a> for details on how an even more efficient cell matrix computation could be realized.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Assemble linear system&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> partial_matrix(dofs_per_cell, dim n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0.;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient =</div><div class="line">            coefficient(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                partial_matrix(i, q_index dim + d) =</div><div class="line">                  <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index) current_coefficient)</div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">              cell_rhs(i) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) <span class="comment">// phi_i(x_q)</span></div><div class="line">                 (-dim)                            <span class="comment">// f(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      partial_matrix.mTmult(cell_matrix, partial_matrix);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solutionofthelinearsystem"></a> </p><h3>Solution of the linear system</h3>
<p>For solving the linear system, we pick a simple Jacobi-preconditioned conjugate gradient solver, similar to the settings in the early tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Solve linear system&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionRelaxation.html#a73fb0eab08209d015a20797c19127588">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of solver iterations:  &quot;</span></div><div class="line">            &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Outputofthesolutionandcomputationoferrors"></a> </p><h3>Output of the solution and computation of errors</h3>
<p>In the next function we do various post-processing steps with the solution, all of which involve the mapping in one way or the other. The first operation we do is to write the solution as well as the material ids to a VTU file. This is similar to what was done in many other tutorial programs. The new ingredient presented in this tutorial program is that we want to ensure that the data written to the file used for visualization is actually a faithful representation of what is used internally by deal.II. That is because most of the visualization data formats only represent cells by their vertex coordinates, but have no way of representing the curved boundaries that are used in deal.II when using higher order mappings</p>
<ul>
<li>in other words, what you see in the visualization tool is not actually what you are computing on. (The same, incidentally, is true when using higher order shape functions: Most visualization tools only render bilinear/trilinear representations. This is discussed in detail in <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>.) So we need to ensure that a high-order representation is written to the file. We need to consider two particular topics. Firstly, we tell the <a class="el" href="classDataOut.html">DataOut</a> object via the <a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> that we intend to interpret the subdivisions of the elements as a high-order Lagrange polynomial rather than a collection of bilinear patches. Recent visualization programs, like ParaView version 5.5 or newer, can then render a high-order solution (see a <a href="https://github.com/dealii/dealii/wiki/Notes-on-visualizing-high-order-output">wiki page</a> for more details). Secondly, we need to make sure that the mapping is passed to the <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> method. Finally, the <a class="el" href="classDataOut.html">DataOut</a> class only prints curved faces for <em>boundary</em> cells by default, so we need to ensure that also inner cells are printed in a curved representation via the mapping.</li>
</ul>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">   {</div><div class="line">     {</div><div class="line">       <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Write output&quot;</span>);</div><div class="line">  </div><div class="line">       <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  </div><div class="line">       <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">       flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">       data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  </div><div class="line">       data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">       data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  </div><div class="line">       Vector&lt;double&gt; material_ids(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">         material_ids[cell-&gt;active_cell_index()] = cell-&gt;material_id();</div><div class="line">       data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(material_ids, <span class="stringliteral">&quot;material_ids&quot;</span>);</div><div class="line">  </div><div class="line">       data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                              fe.degree,</div><div class="line">                              <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line">  </div><div class="line">       std::ofstream file(</div><div class="line">         (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">          <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>()</div><div class="line">  </div><div class="line">- 10 + 2 dim) +</div><div class="line">          <span class="stringliteral">&quot;.vtu&quot;</span>)</div><div class="line">           .c_str());</div><div class="line">  </div><div class="line">       data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(file);</div><div class="line">     }</div></div><!-- fragment --><p>The next operation in the postprocessing function is to compute the \(L_2\) and \(H^1\) errors against the analytical solution. As the analytical solution is a quadratic polynomial, we expect a very accurate result at this point. If we were solving on a simple mesh with planar faces and a coefficient whose jumps are aligned with the faces between cells, then we would expect the numerical result to coincide with the analytical solution up to roundoff accuracy. However, since we are using deformed cells following a sphere, which are only tracked by polynomials of degree 4 (one more than the degree for the finite elements), we will see that there is an error around \(10^{-7}\) . We could get more accuracy by increasing the polynomial degree or refining the mesh.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error norms&quot;</span>);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; norm_per_cell_p(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactSolution&lt;dim&gt;(),</div><div class="line">                                    norm_per_cell_p,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   L2 error vs exact solution:   &quot;</span></div><div class="line">            &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactSolution&lt;dim&gt;(),</div><div class="line">                                    norm_per_cell_p,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   H1 error vs exact solution:   &quot;</span></div><div class="line">            &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The final post-processing operation we do here is to compute an error estimate with the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>. We use the exact same settings as in the <a class="el" href="step_6.html">step-6</a> tutorial program, except for the fact that we also hand in the mapping to ensure that errors are evaluated along the curved element, consistent with the remainder of the program. However, we do not really use the result here to drive a mesh adaptation step (that would refine the mesh around the material interface along the sphere), as the focus here is on the cost of this operation.</p>
<div class="fragment"><div class="line">     {</div><div class="line">       <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error estimator&quot;</span>);</div><div class="line">  </div><div class="line">       <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">       <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">         mapping,</div><div class="line">         dof_handler,</div><div class="line">         <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(fe.degree + 1),</div><div class="line">         std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">         solution,</div><div class="line">         estimated_error_per_cell);</div><div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot;   Max cell-wise error estimate: &quot;</span></div><div class="line">                 &lt;&lt; estimated_error_per_cell.linfty_norm() &lt;&lt; std::endl;</div><div class="line">     }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="ThePoissonProblemrunfunction"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem::run()</a> function</h3>
<p>Finally, we define the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function that controls how we want to execute this program (which is called by the main() function in the usual way). We start by calling the <code>create_grid()</code> function that sets up our geometry with the appropriate manifolds. We then run two instances of a solver chain, starting from the setup of the equations, the assembly of the linear system, its solution with a simple iterative solver, and the postprocessing discussed above. The two instances differ in the way they use the mapping. The first uses a conventional <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> mapping object which we initialize to a degree one more than we use for the finite element &ndash; after all, we expect the geometry representation to be the bottleneck as the analytic solution is only a quadratic polynomial. (In reality, things are interlinked to quite some extent because the evaluation of the polynomials in real coordinates involves the mapping of a higher-degree polynomials, which represent some smooth rational functions. As a consequence, higher-degree polynomials still pay off, so it does not make sense to increase the degree of the mapping further.) Once the first pass is completed, we let the timer print a summary of the compute times of the individual stages.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  create_grid();</div><div class="line"></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;====== Running with the basic MappingQGeneric class ====== &quot;</span></div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">    setup_system(mapping);</div><div class="line">    assemble_system(mapping);</div><div class="line">    solve();</div><div class="line">    postprocess(mapping);</div><div class="line"></div><div class="line">    timer.print_summary();</div><div class="line">    timer.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">  }</div></div><!-- fragment --><p>For the second instance, we instead set up the <a class="el" href="classMappingQCache.html">MappingQCache</a> class. Its use is very simple: After constructing it (with the degree, given that we want it to show the correct degree functionality in other contexts), we fill the cache via the <a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">MappingQCache::initialize()</a> function. At this stage, we specify which mapping we want to use (obviously, the same <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> as previously in order to repeat the same computations) for the cache, and then run through the same functions again, now handing in the modified mapping. In the end, we again print the accumulated wall times since the reset to see how the times compare to the original setting.</p>
<div class="fragment"><div class="line">    {</div><div class="line">      std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;====== Running with the optimized MappingQCache class ====== &quot;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <a class="code" href="classMappingQCache.html">MappingQCache&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Initialize mapping cache&quot;</span>);</div><div class="line">        mapping.initialize(<a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>(fe.degree + 1), triangulation);</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Memory consumption cache:     &quot;</span></div><div class="line">                &lt;&lt; 1e-6 mapping.memory_consumption() &lt;&lt; <span class="stringliteral">&quot; MB&quot;</span> &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"> </div><div class="line">      timer.print_summary();</div><div class="line">    }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step65</span></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Step65::PoissonProblem&lt;3&gt; test_program;</div><div class="line">  test_program.run();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>If we run the three-dimensional version of this program with polynomials ofdegree three, we get the following program output: </p><div class="fragment"><div class="line">&gt; make run</div><div class="line">Scanning dependencies of target step-65</div><div class="line">[ 33%] Building CXX <span class="keywordtype">object</span> CMakeFiles/step-65.dir/step-65.cc.o</div><div class="line">[ 66%] Linking CXX executable step-65</div><div class="line">[ 66%] Built target step-65</div><div class="line">[100%] Run step-65 with Release configuration</div><div class="line">  </div><div class="line">====== Running with the basic <a class="code" href="classMappingQGeneric.html">MappingQGeneric</a> <span class="keyword">class </span>======</div><div class="line">  </div><div class="line">   Number of active cells:       6656</div><div class="line">   Number of degrees of freedom: 181609</div><div class="line">   Number of solver iterations:  285</div><div class="line">   <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> error vs exact solution:   8.99339e-08</div><div class="line">   H1 error vs exact solution:   6.45341e-06</div><div class="line">   Max cell-wise error estimate: 0.00743406</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      49.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble linear system          |         1 |       5.8s |        12% |</div><div class="line">| Compute constraints             |         1 |     0.109s |      0.22% |</div><div class="line">| Compute error estimator         |         1 |      16.5s |        33% |</div><div class="line">| Compute error norms             |         1 |      9.11s |        18% |</div><div class="line">| Solve linear system             |         1 |      9.92s |        20% |</div><div class="line">| Write output                    |         1 |      4.85s |       9.8% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">  </div><div class="line">====== Running with the optimized <a class="code" href="classMappingQCache.html">MappingQCache</a> class ======</div><div class="line">  </div><div class="line">   Memory consumption cache:     22.9981 MB</div><div class="line">   Number of active cells:       6656</div><div class="line">   Number of degrees of freedom: 181609</div><div class="line">   Number of solver iterations:  285</div><div class="line">   <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> error vs exact solution:   8.99339e-08</div><div class="line">   H1 error vs exact solution:   6.45341e-06</div><div class="line">   Max cell-wise error estimate: 0.00743406</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      18.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble linear system          |         1 |      1.44s |       7.8% |</div><div class="line">| Compute constraints             |         1 |   0.00336s |         0% |</div><div class="line">| Compute error estimator         |         1 |     0.476s |       2.6% |</div><div class="line">| Compute error norms             |         1 |     0.505s |       2.7% |</div><div class="line">| Initialize mapping cache        |         1 |      4.96s |        27% |</div><div class="line">| Solve linear system             |         1 |      9.95s |        54% |</div><div class="line">| Write output                    |         1 |     0.875s |       4.8% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">  </div><div class="line">[100%] Built target run</div></div><!-- fragment --><p>Before discussing the timings, we look at the memory consumption for theMappingQCache object: Our program prints that it utilizes 23 MB ofmemory. If we relate this number to the memory consumption of a single(solution or right hand side) vector,which is 1.5 MB (namely, 181,609 elements times 8 bytes per entry indouble precision), or to the memory consumed by thesystem matrix and the sparsity pattern (which is 274 MB), we realize that it isnot an overly heavy data structure, given its benefits. With respect to the timers, we see a clear improvement in the overall run timeof the program by a factor of 2.7. If we disregard the iterative solver, whichis the same in both cases (and not optimal, given the simple preconditioner weuse, and the fact that sparse matrix-vector products waste operations forcubic polynomials), the advantage is a factor of almost 5. This is prettyimpressive for a linear stationary problem, and cost savings would indeed bemuch more prominent for time-dependent and nonlinear problems where assemblyis called several times. If we look into the individual components, we get aclearer picture of what is going on and why the cache is so efficient: In theMappingQGeneric case, essentially every operation that involves a mapping takeat least 5 seconds to run. The norm computation runs two <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> functions, which each take almost 5seconds. (The computation of constraints is cheaper because it only evaluatesthe mapping in cells at the boundary for the interpolation of boundaryconditions.) If we compare these 5 seconds to the time it takes to fill theMappingQCache, which is 5.2 seconds (for all cells, not just the active ones),it becomes obvious that the computation of the mapping support pointsdominates over everything else in the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> case. Perhaps the moststriking result is the time for the error estimator, labeled "Compute errorestimator", where the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> implementation takes 17.3 seconds andthe <a class="el" href="classMappingQCache.html">MappingQCache</a> variant less than 0.5 seconds. The reason why the former isso expensive (three times more expensive than the assembly, for instance) isthat the error estimation involves evaluation of quantities over faces, whereeach face in the mesh requests additional points of the mapping that in turngo through the very expensive <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class. As thereare six faces per cell, this happens much more often than in assembly. Again,<a class="el" href="classMappingQCache.html">MappingQCache</a> nicely eliminates the repeated evaluation, aggregating all theexpensive steps involving the manifold in a single initialization call thatgets repeatedly used.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2019 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> * This tutorial program was contributed by Martin Kronbichler</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__cache_8h.html">deal.II/fe/mapping_q_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step65</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">        <span class="keywordflow">return</span> p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>();</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0.1 * p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() + (0.25 - 0.025);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">        <span class="keywordflow">return</span> 2. * p;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0.2 * p;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> coefficient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">      <span class="keywordflow">return</span> 0.5;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 5.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PoissonProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PoissonProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> create_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;      system_matrix;</div><div class="line">    Vector&lt;double&gt;            solution;</div><div class="line">    Vector&lt;double&gt;            system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PoissonProblem&lt;dim&gt;::PoissonProblem()</div><div class="line">    : fe(3)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::create_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_inner;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria_inner, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_outer;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">      tria_outer, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5, std::sqrt(dim), 2 * dim);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria_inner, tria_outer, triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordtype">bool</span> face_at_sphere_boundary = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : face-&gt;vertex_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (std::abs(face-&gt;vertex(v).norm_square() - 0.25) &gt; 1e-12)</div><div class="line">                  face_at_sphere_boundary = <span class="keyword">false</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">if</span> (face_at_sphere_boundary)</div><div class="line">              face-&gt;set_all_manifold_ids(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;center().norm_square() &lt; 0.25)</div><div class="line">          cell-&gt;set_material_id(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          cell-&gt;set_material_id(0);</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> transfinite_manifold;</div><div class="line">    transfinite_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, transfinite_manifold);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(9 - 2 * dim);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute constraints&quot;</span>);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        mapping, dof_handler, 0, ExactSolution&lt;dim&gt;(), constraints);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Assemble linear system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> partial_matrix(dofs_per_cell, dim * n_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0.;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient =</div><div class="line">              coefficient(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                  partial_matrix(i, q_index * dim + d) =</div><div class="line">                    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index) * current_coefficient) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">                cell_rhs(i) +=</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                   (-dim) *                            <span class="comment">// f(x_q)</span></div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        partial_matrix.mTmult(cell_matrix, partial_matrix);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Solve linear system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionRelaxation.html#a73fb0eab08209d015a20797c19127588">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of solver iterations:  &quot;</span></div><div class="line">              &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Write output&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">      <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">      flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;double&gt; material_ids(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        material_ids[cell-&gt;active_cell_index()] = cell-&gt;material_id();</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(material_ids, <span class="stringliteral">&quot;material_ids&quot;</span>);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                             fe.degree,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">      std::ofstream file(</div><div class="line">        (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">         <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 10 + 2 * dim) +</div><div class="line">         <span class="stringliteral">&quot;.vtu&quot;</span>)</div><div class="line">          .c_str());</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(file);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error norms&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;double&gt; norm_per_cell_p(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        ExactSolution&lt;dim&gt;(),</div><div class="line">                                        norm_per_cell_p,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   L2 error vs exact solution:   &quot;</span></div><div class="line">                &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        ExactSolution&lt;dim&gt;(),</div><div class="line">                                        norm_per_cell_p,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   H1 error vs exact solution:   &quot;</span></div><div class="line">                &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error estimator&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        mapping,</div><div class="line">        dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Max cell-wise error estimate: &quot;</span></div><div class="line">                &lt;&lt; estimated_error_per_cell.linfty_norm() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    create_grid();</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;====== Running with the basic MappingQGeneric class ====== &quot;</span></div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">      timer.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;====== Running with the optimized MappingQCache class ====== &quot;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQCache.html">MappingQCache&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Initialize mapping cache&quot;</span>);</div><div class="line">        mapping.initialize(<a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>(fe.degree + 1), triangulation);</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Memory consumption cache:     &quot;</span></div><div class="line">                &lt;&lt; 1e-6 * mapping.memory_consumption() &lt;&lt; <span class="stringliteral">&quot; MB&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">    }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step65</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Step65::PoissonProblem&lt;3&gt; test_program;</div><div class="line">  test_program.run();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_49.html">step-49</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Workingwithmanifolds">Working with manifolds</a>
      <ul>
        <li><a href="#Whatwewant">What we want</a>
      </ul>
        <li><a href="#TheclassTransfiniteInterpolationManifold">The class TransfiniteInterpolationManifold</a>
      <ul>
        <li><a href="#Howitworks">How it works</a>
      </ul>
        <li><a href="#Transfiniteinterpolationisexpensiveandhowtodealwithit">Transfinite interpolation is expensive and how to deal with it</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Analyticalsolutionandcoefficient">Analytical solution and coefficient</a>
        <li><a href="#ThePoissonProblemclass">The PoissonProblem class</a>
        <li><a href="#Gridcreationandinitializationofthemanifolds">Grid creation and initialization of the manifolds</a>
        <li><a href="#Setupofdatastructures">Setup of data structures</a>
        <li><a href="#Assemblyofthesystemmatrixandrighthandside">Assembly of the system matrix and right hand side</a>
        <li><a href="#Solutionofthelinearsystem">Solution of the linear system</a>
        <li><a href="#Outputofthesolutionandcomputationoferrors">Output of the solution and computation of errors</a>
        <li><a href="#ThePoissonProblemrunfunction">The PoissonProblem::run() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-65/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Martin Kronbichler. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>本教程程序介绍了一个高级流形类&ndash;TransfiniteInterpolationManifold，以及如何解决其主要缺点&ndash;相对较高的成本。</p>
<p><a class="anchor" id="Workingwithmanifolds"></a></p><h3>Working with manifolds</h3>
<p><a class="anchor" id="Whatwewant"></a></p><h4>What we want</h4>
<p>在许多应用中，有限元网格必须能够表示一个相对复杂的几何体。在<a class="el" href="step_1.html">step-1</a>、<a class="el" href="step_49.html">step-49</a>和<a class="el" href="step_53.html">step-53</a>教程程序中，已经介绍了deal.II库中可用的一些生成网格的技术。给定一个基础网格，deal.II能够通过将单元格均匀地或仅在计算域的选定部分细分为子单元来创建一个更细的网格。除了GridGenerator命名空间中的基本网格划分功能外，deal.II还提供了一些接口，可以使用命名空间GridIn的功能读入由（仅四边形和六边形）网格生成器生成的网格，例如在步骤5中演示。外部生成的网格的一个基本限制是，网格中生成的单元所提供的信息只包括顶点的位置和它们的连接性，而没有最初创建这个网格的网格生成器所提供的底层几何体的背景。一旦网格在deal.II中被细化，需要放置更多的点，这就成了问题。第54步教程程序显示了如何通过使用OpenCASCADE库方面的CAD曲面来克服这个限制，第53步通过在源代码内以编程方式提供同类信息。</p>
<p>在deal.II中，网格细化过程中新点的放置或高阶映射的定义由流形对象控制，详见 <a class="el" href="group__manifold.html">流形模块</a>。举个例子，考虑以下二维环形的情况（图片取自流形模块）。如果我们从10个单元的初始网格开始，在不附加任何流形的情况下全局细化网格三次，我们将得到以下网格。</p>
<div class="image">
<img src="hypershell-nothing.png" alt="hypershell-nothing.png"/>
</div>
<p>图片看起来是这样的，因为在默认情况下，deal.II只知道通过平均父单元的顶点位置来放置子单元的顶点。这就产生了一个多边形域，其面是原始（粗略的网格）单元的边缘。很明显，我们必须对三角形的边界面附加一个曲线描述，以便在网格细化时重现圆形，就像下图一样。</p>
<div class="image">
<img src="hypershell-boundary-only.png" alt="hypershell-boundary-only.png"/>
</div>
<p>这样就好多了。如果我们继续细化网格，至少现在的内外边界已经接近真实的圆了。然而，这幅图中的网格对于环形来说仍然不是最佳的，因为从一个单元到下一个单元的<em>interior</em>线在某些顶点上有扭结，人们宁愿使用下面的网格。</p>
<div class="image">
<img src="hypershell-all.png" alt="hypershell-all.png"/>
</div>
<p>在这最后一种（最佳）情况下，也是由 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, 产生的默认情况，曲线流形描述（在这种情况下是极地流形描述）不仅适用于边界面，而且适用于整个域。每当三角化要求一个新的点，例如，当它将一个单元细化为四个子单元时，边缘或单元的中点，它将沿着极坐标系统中各自的中点来放置它们。相比之下，上面那种只有边界受制于极地流形的情况，只有沿边界的中点会沿着曲线描述放置，而内部的中点会通过直角坐标系中周围点的合适平均值来计算（更多细节见 <a class="el" href="group__manifold.html">流形模块</a>）。</p>
<p>在这一点上，人们可能会认为曲线形的体积描述是一种方式。这一般来说是不会错的，尽管有时并不那么容易描述这到底应该如何工作。这里有几个例子。</p>
<ul>
<li>想象一下，上面的网格实际上是一个圆盘，而不只是一个环。 在这种情况下，极地流形会在原点退化，不会产生合理的新点。事实上，为那些应该 "看起来是圆的 "但可能在原点或接近原点的东西定义流形描述是令人惊讶的非常困难的。</li>
<li>当人们试图将球形流形附加到整个体积上时，类似的事情也会发生在三维球的原点；在这种情况下，新流形点的计算会因异常而中止。</li>
<li>CAD几何体通常只描述域的边界，就像我们在上面第二张图中只把流形附在边界上一样。同样地，<a class="el" href="step_54.html">step-54</a>只使用CAD几何体来生成表面网格（也许是因为这是解决相关问题所需要的），但是如果想解决那里描述的水或船周围空气中的问题，我们就需要有一个体积网格。那么问题来了，我们应该如何准确地描述域的内部应该发生什么。</li>
</ul>
<p>这些简单的例子清楚地表明，对于许多有趣的情况，我们必须从对全体积的分析性曲率描述的愿望中退一步。将需要有<em>some</em>种导致曲率也在内部的信息，但必须有可能做到这一点，而不需要实际写下描述那种几何的明确公式。</p>
<p>那么，如果我们不在内部做任何事情，只把表面描述为流形，会发生什么呢？有时，如上图所示的环，结果并不可怕。但有时却很糟糕。考虑一个环状体的情况（例如用 <a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">GridGenerator::torus()</a>) 生成的环状体，只在表面附加一个TorusManifold对象，内部单元和面没有附加流形，细化前有六个单元在环状方向。如果对网格进行一次细化，我们将得到如下的网格，图中显示的是网格的上半部分被剪切掉了。</p>
<div class="image">
<img src="torus_no_inner_manifold.png" alt="torus_no_inner_manifold.png"/>
</div>
<p>这显然是次优的。事实上，如果我们从少于上面显示的环形方向的六个单元开始，映射在某些区域实际上是倒置的，因为沿着内部单元放置的新点与边界相交，因为它们不是沿着环形方向的圆形。环形的简单情况仍然可以被固定下来，因为我们知道环形方向是沿着圆柱坐标系的，所以在曲面上附加一个TorusManifold，结合CylindricalManifold，在环形方向上有适当的周期性，应用于所有的内部实体，将产生一个高质量的网格，如下所示，现在有两个顶部的单元被隐藏起来。</p>
<div class="image">
<img src="torus_cylindrical_inner_manifold.png" alt="torus_cylindrical_inner_manifold.png"/>
</div>
<p>这个网格是相当不错的，但显然它与对体积的良好描述有关，而我们在其他情况下缺乏这种描述。实际上，在这种情况下也有一个不完美之处，因为我们可以看到域的内部的两个相邻单元的一些不自然的扭结，这些扭结被顶部的两个边界单元所隐藏，与下面的设置相反（由 <a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">GridGenerator::torus()</a> 应用的默认流形并使用TransfiniteInterpolationManifold）。</p>
<div class="image">
<img src="torus_transfinite_manifold.png" alt="torus_transfinite_manifold.png"/>
</div>
<p><a class="anchor" id="TheclassTransfiniteInterpolationManifold"></a></p><h3>The class <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a></h3>
<p>为了找到一个更好的策略，让我们再看看二维圆盘（这也是沿环形方向旋转的环形实体的基础）。正如我们上面所学到的，我们只能将弯曲的极坐标描述应用于边界（或离原点足够远的单元的边缘），但最终必须过渡到对圆盘中心的直线描述。如果我们在单元的内部使用平坦的流形（也就是说，新的顶点是通过相邻的现有顶点的平均化而产生的），而极地流形只用于圆盘的边界，那么在进行四次全局细化之后，我们会得到以下网格。</p>
<div class="image">
<img src="circular_mesh_only_boundary_manifold.png" alt="circular_mesh_only_boundary_manifold.png"/>
</div>
<p>这并不是一个可怕的网格。同时，如果你知道最初的粗略网格是由中间的一个正方形和周围的四个盖子组成的，那么就不难看出这个网格的每一个细化步骤都是为了得到上面的图片。</p>
<p>虽然deal.II的三角测量类在创建新点时试图将信息从边界传播到内部，但这种算法的影响范围是有限的。</p>
<div class="image">
<img src="circular_mesh_boundary_cells.png" alt="circular_mesh_boundary_cells.png"/>
</div>
<p>上图突出了盘面上那些触及边界的单元，在当时只看一个单元的情况下，原则上可以考虑边界信息。显然，随着网格的细化，可以考虑到一些曲率的区域变得更加有限，因此在网格中形成了看似不规则的点。当计算最左边图片中任何一个边界单元的中心时，理想的位置是外圈和中间的单元之间的中点。这正是三角剖分类中第一个细化步骤所使用的内容。然而，对于第二次细化，所有的内部边缘以及内部单元格层只能根据平面流形描述来加点。</p>
<p>在这一点上，我们意识到需要什么来创建一个更好的网格。对于<em>all</em>子单元中的<em>any</em>新点，即在最左边的红色阴影层内创建的单元，我们要计算相对于各自粗单元覆盖区域内的曲率的插值。这可以通过在上图最左边面板的粗略网格的高亮单元中添加TransfiniteInterpolationManifold类来实现。该类遵守一般流形接口，即在其定义域内给定任何一组点，它可以计算符合流形的加权平均数（使用的公式将在一分钟后给出）。这些加权平均数在细化网格的时候，或者在给定单元上评估符合该流形的高阶映射（如MappingQGeneric或MappingC1）的时候都会用到。在圆盘粗网格的阴影单元上使用该流形（即不仅仅是最外层的单元），在经过四个全局步骤的细化后产生以下网格。</p>
<div class="image">
<img src="circular_mesh_transfinite_interpolation.png" alt="circular_mesh_transfinite_interpolation.png"/>
</div>
<p>这个网格的线条仍有一些扭结，但它们仅限于粗大的网格单元之间的面，而网格的其他部分则如人们所希望的那样平滑。事实上，给定一个直边的中心单元，这个表示法是最好的，因为所有的网格单元都遵循一个平滑的过渡，从内部的方形块的直边到边界的圆形。(我们可以做得更好一些，在中心的方形块中也允许一些曲率，随着中心的接近，这些曲率最终会消失)。</p>
<p><a class="anchor" id="Howitworks"></a></p><h4>How it works</h4>
<p>在一个有一条曲线和三条直线的圆盘的简单情况下，我们可以明确写下如何实现形状的混合。为此，将物理单元（如顶部的单元）映射回参考坐标系 \((\xi,\eta)\in (0,1)^2\) 是很有用的，在那里我们计算某些点之间的平均数。如果我们使用一个由四个顶点 \((x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)\) 跨越的简单双线性地图，一个点 \((\xi, \eta)\in (0,1)^2\) 的图像将是</p>
<p class="formulaDsp">
\begin{align*} (x,y) = (1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) + (1-\xi)\eta (x_2,y_2) + \xi\eta (x_3,y_3). \end{align*}
</p>
<p>对于曲面的情况，我们要修改这个公式。对于圆盘粗略网格的顶部单元，我们可以假设点 \((x_0,y_0)\) 和 \((x_1,y_1)\) 位于下端的直线上，点 \((x_2,y_2)\) 和 \((x_3,y_3)\) 沿顶部由一个四分之一圆连接。然后我们将点 \((\xi, \eta)\) 映射为</p>
<p class="formulaDsp">
\begin{align*} (x,y) = (1-\eta) \big[(1-\xi) (x_0,y_0) + \xi (x_1,y_1)\big] + \eta \mathbf{c}_3(\xi), \end{align*}
</p>
<p>其中 \(\mathbf{c}_3(\xi)\) 是一条曲线，用一个arclength参数 \(\xi\in (0,1)\) 来描述四分之一圆的 \((x,y)\) 坐标。这代表了单元格的直线下边缘和曲线上边缘之间的线性插值，也是上图的基础。</p>
<p>这个公式很容易被推广到所有四条边都由曲线而不是直线描述的情况。我们称这四个函数为 \(\xi\) 或 \(\eta\) ，在水平和垂直方向上，分别为四边形的左、右、下和上边缘的参数。然后，内插法为</p>
<p class="formulaDsp">
\begin{align*} (x,y) =&amp; (1-\xi)\mathbf{c}_0(\eta) + \xi \mathbf{c}_1(\eta) +(1-\eta)\mathbf{c}_2(\xi) + \eta \mathbf{c}_3(\xi)\\ &amp;-\big[(1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) + (1-\xi)\eta (x_2,y_2) + \xi\eta (x_3,y_3)\big]. \end{align*}
</p>
<p>这个公式假设边界曲线与顶点 \((x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)\) ，例如 \(\mathbf{c}_0(0) = (x_0,y_0)\) 或 \(\mathbf{c}_0(1) = (x_2,y_2)\) 匹配和重合。公式第二行的双线性插值的减法确保了在边界上完全遵循规定的曲线：沿着四条边中的每一条，我们需要减去在角上评估的两条相邻边的贡献，这时的贡献只是一个顶点位置。很容易检查出，如果四条曲线中的三条 \(\mathbf{c}_i\) 是直的，从而与双线性插值重合，那么上面的圆的公式就再现了。</p>
<p>这个公式被称为转折内插，由<a href="https://doi.org/10.1002%2Fnme.1620070405">Gordon and Hall</a>在1973年提出。尽管转义插值本质上只表示边界曲线的线性混合，但插值完全遵循每个实数 \(\xi\in (0,1)\) 或 \(\eta\in (0,1)\) 的边界曲线，也就是说，它插值的点数是无限的，这也是Gordon和Hall将这种插值的变体称为转义插值的最初动机。另一种解释是，无限插值从左右和上下线性插值，我们需要从中减去双线性插值，以确保在域的内部有一个单位重量。</p>
<p>无限插值很容易被推广到三个空间维度。在这种情况下，插值允许为一个三维单元的任何一个四边形混合6种不同的表面描述，为一个单元的线混合12种边缘描述。同样，为了确保地图的一致性，有必要减去边缘的贡献，再加上顶点的贡献，使曲线遵循规定的表面或边缘描述。在三维的情况下，也可以使用从曲线边缘到相邻面和相邻单元的转折插值。</p>
<p>在处理.II中的转置插值是通用的，因为它可以处理任意的曲线。它将以 \(d\) -维空间的原始坐标来评估曲线，但有一个（或两个，在三维的边缘情况下）坐标固定在 \(0\) 或 \(1\) ，以确保任何其他流形类，包括CAD文件（如果需要），都可以应用于开箱。无限插值是网格生成器的标准成分，因此在deal.II库中集成这一功能的主要优势是在自适应细化和粗化网格时启用，以及用于创建更高程度的映射，使用流形来插入网格顶点以外的额外点。</p>
<p>关于无限插值的最后一句话，我们提到在没有体积流形描述的情况下，deal.II中的网格细化策略也是基于无限插值的权重，在这个意义上是最优的。不同的是，默认算法一次只看到一个单元，因此将只对那些接触曲面流形的单元应用最优算法。相反，在整个&lt;i&gt;patches个单元上使用转义映射（源于一个较粗的单元），可以用转义插值法，将信息从边界传播到远处的单元。</p>
<p><a class="anchor" id="Transfiniteinterpolationisexpensiveandhowtodealwithit"></a></p><h3>Transfinite interpolation is expensive and how to deal with it</h3>
<p>一个具有无限流形描述的网格通常分两步建立。第一步是创建一个粗略的网格（或者从文件中读入），并在一些网格实体上附加一个曲面流形。对于上面的圆盘例子，我们将极坐标流形附加到沿外圆的面（这是由 <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>). 自动完成的）在我们开始细化网格之前，我们再为网格的所有内部单元和边缘分配一个TransfiniteInterpolationManifold，当然，这需要基于我们分配给这些实体的一些流形ID（除了边界上的圆以外的一切）。我们是否也给圆盘的内部正方形分配一个TransfiniteInterpolationManifold并不重要，因为对具有直边（或3D中的平坦面）的粗单元进行Transfinite插值，只是产生具有直边（平坦面）的细分子。</p>
<p>之后，当网格被细化或基于此网格建立高阶映射时，单元将查询底层流形对象的新点。这个过程需要一组周围的点，例如一个二维单元的四个顶点，以及一组对这些点的权重，用于定义一个新的点。对于一个单元格的中间点，四个顶点中的每一个都将得到0.25的权重。对于无限插值流形，建立加权和的过程需要一些严肃的工作。根据结构，我们要根据周围点的参考坐标 \(\xi\) 和 \(\eta\) （或三维的 \(\xi, \eta, \zeta\) ）来组合这些点。然而，deal.II中流形类的接口并没有得到周围点的参考坐标（因为它们不是全局存储的），而只是物理坐标。因此，无限插值流形必须做的第一步是反转映射，并在无限插值的一个粗网格单元内找到参考坐标（例如，上述磁盘网格的四个阴影粗网格单元之一）。这种反演是通过牛顿迭代（或者说，基于有限差分的牛顿方案与布罗伊登方法相结合）完成的，并根据上述公式多次查询无限期插值。这些查询中的每一次都可能依次调用一个昂贵的流形，例如球的球形描述，并且本身就很昂贵。由于deal.II的Manifold接口类只提供了一组点，所以转置插值最初甚至不知道周围的点集属于哪个粗大的网格单元，需要根据一些启发式方法在几个单元中搜索。就<a href="https://en.wikipedia.org/wiki/Atlas_(topology)#Charts">charts</a>而言，我们可以把无限插值的实现描述为基于<a href="https://en.wikipedia.org/wiki/Atlas_(topology)">atlas</a>的实现。三角形初始粗网格的每个单元都代表一个有自己参考空间的图表，而周围的流形提供了一种从图表空间（即参考单元）到物理空间的转换方式。粗网格单元的图表的集合是一个图集，像往常一样，在图集中查找东西时，人们做的第一件事就是找到正确的图表。</p>
<p>一旦找到周围点的参考坐标，参考坐标系中的新点将通过简单的加权和计算出来。最后，参考点被插入到无限插值的公式中，这就得到了所需的新点。</p>
<p>在许多情况下，曲面流形不仅在网格细化过程中使用，而且还用于确保计算域单元内边界的曲面表示。这对于保证复杂几何上的高阶多项式的高阶收敛性是必须的，但有时对于线性形状函数也需要一个精确的几何。这通常是通过对单元的多项式描述来实现的，如果表示曲面网格元素的多项式程度与数值解的多项式程度相同，则称为等参数概念。如果几何体的度数高于或低于解的度数，则分别称为超参数或次参数的几何体表示。在deal.II中，多项式表示的标准类是MappingQGeneric。例如，如果在三维中使用这个类的多项式度数 \(4\) ，总共需要125个（即 \((4+1)^3\) ）点来进行内插。在这些点中，8个是单元的顶点，已经可以从网格中获得，但其他117个点需要由流形提供。如果使用无限插值流形，我们可以想象，通过回拉到一些尚未确定的粗略单元的参考坐标，然后在117个点中的每个点上进行后续的前推，是一个大量的工作，可能非常耗时。</p>
<p>更糟糕的是，许多程序的结构是这样的：对于同一个单元，映射被独立地查询了几次。它的主要用途是组装线性系统，即通过FEValues对象的<code>mapping</code>参数计算系统矩阵和右手边。然而，边界值的插值、数值误差的计算、输出的写入以及误差估计器的评估也必须涉及相同的映射，以确保对解向量的一致解释。因此，即使是解决一次的线性静止问题，也会多次评估映射的点。对于上面提到的三维案例，这意味着通过昂贵的算法多次计算每个单元的117个点。对于非线性或随时间变化的问题，情况更加紧迫，这些操作要反复进行。</p>
<p>由于通过无限插值进行流形描述的成本比对平流形的类似查询要高几百倍，所以只计算一次额外的点并在所有后续调用中使用这些点是有意义的。deal.II库提供的MappingQCache类正是为了这个目的。与系统矩阵所消耗的内存相比，这个缓存通常不会太大，在看这个教程程序的结果时就会明白。MappingQCache的用法很简单。一旦网格被设置好（或在细化过程中被改变），我们就调用 <a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">MappingQCache::initialize()</a> ，将所需的三角形以及所需的映射作为参数。然后，初始化会遍历网格的所有单元，并查询给定映射的附加点。这些点会被保存为单元的标识符，以便以后当映射计算一些与单元相关的量（如参考坐标和物理坐标之间的映射的Jacobian）时，它们可以被返回。</p>
<p>最后，我们提到，TransfiniteInterpolationManifold也使得网格的细化变得更加昂贵。在这种情况下，MappingQCache无济于事，因为它将计算随后不能再使用的点；目前在deal.II中不存在一个更有效的机制。然而，网格细化也包含许多其他昂贵的步骤，所以与其他计算相比，它并不是一个大问题。它在每个时间步长或非线性迭代中也最多只发生一次。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>在这个教程程序中，TransfiniteInterpolationManifold与MappingQCache的结合被举例说明。这个测试案例相对简单，占用了许多典型程序中涉及的解决阶段，例如步骤6的教程程序。作为一个几何体，我们选择了TransfiniteInterpolationManifold的一个使用原型，即涉及一个球形的设置，而这个球形又被一个立方体所包围。例如，这样的设置将用于嵌入背景介质中的球形包容物，如果该包容物具有不同的材料特性，需要通过元素界面来跟踪两种材料之间的界面。这里给出了一个可视化的网格。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-65-mesh.png"/>
</div>
<p>对于这种情况，我们要在域内的表面附加一个球形描述，并使用转折插值来平滑地切换到外部立方体的直线和球中心的立方体。</p>
<p>在该程序中，我们将遵循有限元程序的典型流程，从DoFHandler和稀疏模式的设置开始，组装一个线性系统来解决带有跳跃系数的泊松方程，用一个简单的迭代方法解决，用 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> 计算一些数值误差以及误差估计器。我们记录了每个部分的时间，并运行了两次代码。在第一次运行中，我们将一个MappingQGeneric对象分别交给程序的每个阶段，在这些阶段中，点被反复计算。在第二次运行中，我们用MappingQCache代替。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The include files for this tutorial are essentially the same as in <a class="el" href="step_6.html">step-6</a>. Importantly, the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class we will be using is provided by <code>deal.II/grid/manifold_lib.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>The only new include file is the one for the <a class="el" href="classMappingQCache.html">MappingQCache</a> class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__cache_8h.html">deal.II/fe/mapping_q_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step65</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Analyticalsolutionandcoefficient"></a> </p><h3>Analytical solution and coefficient</h3>
<p>In this tutorial program, we want to solve the Poisson equation with a coefficient that jumps along a sphere of radius 0.5, and using a constant right hand side of value \(f(\mathbf{x}) = -3\). (This setup is similar to <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_6.html">step-6</a>, but the concrete values for the coefficient and the right hand side are different.) Due to the jump in the coefficient, the analytical solution must have a kink where the coefficient switches from one value to the other. To keep things simple, we select an analytical solution that is quadratic in all components, i.e., \(u(x,y,z) = x^2 + y^2 + z^2\) in the ball of radius 0.5 and \(u(x,y,z) = 0.1(x^2 + y^2 + z^2) + 0.25-0.025\) in the outer part of the domain. This analytical solution is compatible with the right hand side in case the coefficient is 0.5 in the inner ball and 5 outside. It is also continuous along the circle of radius 0.5.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">      <span class="keywordflow">return</span> p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.1 * p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() + (0.25 - 0.025);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  <a class="code" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">      <span class="keywordflow">return</span> 2. * p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.2 * p;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> coefficient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">    <span class="keywordflow">return</span> 0.5;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 5.0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThePoissonProblemclass"></a> </p><h3>The PoissonProblem class</h3>
<p>The implementation of the Poisson problem is very similar to what we used in the <a class="el" href="step_5.html">step-5</a> tutorial program. The two main differences are that we pass a mapping object to the various steps in the program in order to switch between two mapping representations as explained in the introduction, and the <code>timer</code> object (of type <a class="el" href="classTimerOutput.html">TimerOutput</a>) that will be used for measuring the run times in the various cases. (The concept of mapping objects was first introduced in <a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a>, in case you want to look up the use of these classes.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PoissonProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PoissonProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> create_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;      system_matrix;</div><div class="line">  Vector&lt;double&gt;            solution;</div><div class="line">  Vector&lt;double&gt;            system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">};</div></div><!-- fragment --><p>In the constructor, we set up the timer object to record wall times but be quiet during the normal execution. We will query it for timing details in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem::run()</a></code> function. Furthermore, we select a relatively high polynomial degree of three for the finite element in use.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PoissonProblem&lt;dim&gt;::PoissonProblem()</div><div class="line">  : fe(3)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Gridcreationandinitializationofthemanifolds"></a> </p><h3>Grid creation and initialization of the manifolds</h3>
<p>The next function presents the typical usage of <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. The first step is to create the desired grid, which can be done by composition of two grids from <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>. The inner ball mesh is simple enough: We run <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a> centered at the origin with radius 0.5 (third function argument). The second mesh is more interesting and constructed as follows: We want to have a mesh that is spherical in the interior but flat on the outer surface. Furthermore, the mesh topology of the inner ball should be compatible with the outer grid in the sense that their vertices coincide so as to allow the two grid to be merged. The grid coming out of <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> fulfills the requirements on the inner side in case it is created with \(2d\) coarse cells (6 coarse cells in 3D which we are going to use) &ndash; this is the same number of cells as there are boundary faces for the ball. For the outer surface, we use the fact that the 6 faces on the surface of the shell without a manifold attached would degenerate to the surface of a cube. What we are still missing is the radius of the outer shell boundary. Since we desire a cube of extent \([-1, 1]\) and the 6-cell shell puts its 8 outer vertices at the 8 opposing diagonals, we must translate the points \((\pm 1, \pm 1, \pm 1)\) into a radius: Clearly, the radius must be \(\sqrt{d}\) in \(d\) dimensions, i.e., \(\sqrt{3}\) for the three-dimensional case we want to consider.</p>
<p>Thus, we have a plan: After creating the inner triangulation for the ball and the one for the outer shell, we merge those two grids but remove all manifolds that the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> may have set from the resulting triangulation, to ensure that we have full control over manifolds. In particular, we want additional points added on the boundary during refinement to follow a flat manifold description. To start the process of adding more appropriate manifold ids, we assign the manifold id 0 to all mesh entities (cells, faces, lines), which will later be associated with the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. Then, we must identify the faces and lines that are along the sphere of radius 0.5 and mark them with a different manifold id, so as to then assign a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to those. We will choose the manifold id of 1. Since we have thrown away all manifolds that pre-existed after calling <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, we manually go through the cells of the mesh and all their faces. We have found a face on the sphere if all four vertices have a radius of 0.5, or, as we write in the program, have \(r^2-0.25 \approx 0\). Note that we call <code>cell-&gt;face(f)-&gt;set_all_manifold_ids(1)</code> to set the manifold id both on the faces and the surrounding lines. Furthermore, we want to distinguish the cells inside the ball and outside the ball by a material id for visualization, corresponding to the picture in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::create_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_inner;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria_inner, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_outer;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    tria_outer, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5, std::sqrt(dim), 2 * dim);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria_inner, tria_outer, triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        {</div><div class="line">          <span class="keywordtype">bool</span> face_at_sphere_boundary = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : face-&gt;vertex_indices())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (std::abs(face-&gt;vertex(v).norm_square() - 0.25) &gt; 1e-12)</div><div class="line">                face_at_sphere_boundary = <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">          <span class="keywordflow">if</span> (face_at_sphere_boundary)</div><div class="line">            face-&gt;set_all_manifold_ids(1);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;center().norm_square() &lt; 0.25)</div><div class="line">        cell-&gt;set_material_id(1);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        cell-&gt;set_material_id(0);</div><div class="line">    }</div></div><!-- fragment --><p>With all cells, faces and lines marked appropriately, we can attach the <a class="el" href="classManifold.html">Manifold</a> objects to those numbers. The entities with manifold id 1 will get a spherical manifold, whereas the other entities, which have the manifold id 0, will be assigned the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>. As mentioned in the introduction, we must explicitly initialize the manifold with the current mesh using a call to <a class="el" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">TransfiniteInterpolationManifold::initialize()</a> in order to pick up the coarse mesh cells and the manifolds attached to the boundaries of those cells. We also note that the manifold objects we create locally in this function are allowed to go out of scope (as they do at the end of the function scope), because the <a class="el" href="classTriangulation.html">Triangulation</a> object internally copies them.</p>
<p>With all manifolds attached, we will finally go about and refine the mesh a few times to create a sufficiently large test case.</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> transfinite_manifold;</div><div class="line">  transfinite_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, transfinite_manifold);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(9 - 2 * dim);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Setupofdatastructures"></a> </p><h3>Setup of data structures</h3>
<p>The following function is well-known from other tutorials in that it enumerates the degrees of freedom, creates a constraint object and sets up a sparse matrix for the linear system. The only thing worth mentioning is the fact that the function receives a reference to a mapping object that we then pass to the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function to ensure that our boundary values are evaluated on the high-order mesh used for assembly. In the present example, it does not really matter because the outer surfaces are flat, but for curved outer cells this leads to more accurate approximation of the boundary values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute constraints&quot;</span>);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, ExactSolution&lt;dim&gt;(), constraints);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyofthesystemmatrixandrighthandside"></a> </p><h3>Assembly of the system matrix and right hand side</h3>
<p>The function that assembles the linear system is also well known from the previous tutorial programs. One thing to note is that we set the number of quadrature points to the polynomial degree plus two, not the degree plus one as in most other tutorials. This is because we expect some extra accuracy as the mapping also involves a degree one more than the polynomials for the solution.</p>
<p>The only somewhat unusual code in the assembly is the way we compute the cell matrix. Rather than using three nested loop over the quadrature point index, the row, and the column of the matrix, we first collect the derivatives of the shape function, multiplied by the square root of the product of the coefficient and the integration factor <code>JxW</code> in a separate matrix <code>partial_matrix</code>. To compute the cell matrix, we then execute <code>cell_matrix = partial_matrix * transpose(partial_matrix)</code> in the line <code>partial_matrix.mTmult(cell_matrix, partial_matrix);</code>. To understand why this works, we realize that the matrix-matrix multiplication performs a summation over the columns of <code>partial_matrix</code>. If we denote the coefficient by \(a(\mathbf{x}_q)\), the entries in the temporary matrix are \(\sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k}\). If we take the product of the <em>i</em>th row with the <em>j</em>th column of that matrix, we compute a nested sum involving \(\sum_q \sum_{k=1}^d \sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k} = \sum_q \sum_{k=1}^d\text{det}(J) w_q a(x)\frac{\partial \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k}\), which is exactly the terms needed for the bilinear form of the Laplace equation.</p>
<p>The reason for choosing this somewhat unusual scheme is due to the heavy work involved in computing the cell matrix for a relatively high polynomial degree in 3D. As we want to highlight the cost of the mapping in this tutorial program, we better do the assembly in an optimized way in order to not chase bottlenecks that have been solved by the community already. Matrix-matrix multiplication is one of the best optimized kernels in the HPC context, and the <a class="el" href="classFullMatrix.html#ac074fc1dc416f8cd75bb01d820e74aa0">FullMatrix::mTmult()</a> function will call into those optimized BLAS functions. If the user has provided a good BLAS library when configuring deal.II (like OpenBLAS or Intel's MKL), the computation of the cell matrix will execute close to the processor's peak arithmetic performance. As a side note, we mention that despite an optimized matrix-matrix multiplication, the current strategy is sub-optimal in terms of complexity as the work to be done is proportional to \((p+1)^9\) operations for degree \(p\) (this also applies to the usual evaluation with <a class="el" href="classFEValues.html">FEValues</a>). One could compute the cell matrix with \(\mathcal O((p+1)^7)\) operations by utilizing the tensor product structure of the shape functions, as is done by the matrix-free framework in deal.II. We refer to <a class="el" href="step_37.html">step-37</a> and the documentation of the tensor-product-aware evaluators <a class="el" href="classFEEvaluation.html">FEEvaluation</a> for details on how an even more efficient cell matrix computation could be realized.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Assemble linear system&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> partial_matrix(dofs_per_cell, dim * n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0.;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient =</div><div class="line">            coefficient(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                partial_matrix(i, q_index * dim + d) =</div><div class="line">                  <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index) * current_coefficient) *</div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">              cell_rhs(i) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                 (-dim) *                            <span class="comment">// f(x_q)</span></div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      partial_matrix.mTmult(cell_matrix, partial_matrix);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solutionofthelinearsystem"></a> </p><h3>Solution of the linear system</h3>
<p>For solving the linear system, we pick a simple Jacobi-preconditioned conjugate gradient solver, similar to the settings in the early tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Solve linear system&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionRelaxation.html#a73fb0eab08209d015a20797c19127588">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of solver iterations:  &quot;</span></div><div class="line">            &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Outputofthesolutionandcomputationoferrors"></a> </p><h3>Output of the solution and computation of errors</h3>
<p>In the next function we do various post-processing steps with the solution, all of which involve the mapping in one way or the other.</p>
<p>The first operation we do is to write the solution as well as the material ids to a VTU file. This is similar to what was done in many other tutorial programs. The new ingredient presented in this tutorial program is that we want to ensure that the data written to the file used for visualization is actually a faithful representation of what is used internally by deal.II. That is because most of the visualization data formats only represent cells by their vertex coordinates, but have no way of representing the curved boundaries that are used in deal.II when using higher order mappings &ndash; in other words, what you see in the visualization tool is not actually what you are computing on. (The same, incidentally, is true when using higher order shape functions: Most visualization tools only render bilinear/trilinear representations. This is discussed in detail in <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>.)</p>
<p>So we need to ensure that a high-order representation is written to the file. We need to consider two particular topics. Firstly, we tell the <a class="el" href="classDataOut.html">DataOut</a> object via the <a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> that we intend to interpret the subdivisions of the elements as a high-order Lagrange polynomial rather than a collection of bilinear patches. Recent visualization programs, like ParaView version 5.5 or newer, can then render a high-order solution (see a <a href="https://github.com/dealii/dealii/wiki/Notes-on-visualizing-high-order-output">wiki page</a> for more details). Secondly, we need to make sure that the mapping is passed to the <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> method. Finally, the <a class="el" href="classDataOut.html">DataOut</a> class only prints curved faces for <em>boundary</em> cells by default, so we need to ensure that also inner cells are printed in a curved representation via the mapping.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Write output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; material_ids(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      material_ids[cell-&gt;active_cell_index()] = cell-&gt;material_id();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(material_ids, <span class="stringliteral">&quot;material_ids&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                           fe.degree,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">    std::ofstream file(</div><div class="line">      (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">       <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 10 + 2 * dim) +</div><div class="line">       <span class="stringliteral">&quot;.vtu&quot;</span>)</div><div class="line">        .c_str());</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(file);</div><div class="line">  }</div></div><!-- fragment --><p>The next operation in the postprocessing function is to compute the \(L_2\) and \(H^1\) errors against the analytical solution. As the analytical solution is a quadratic polynomial, we expect a very accurate result at this point. If we were solving on a simple mesh with planar faces and a coefficient whose jumps are aligned with the faces between cells, then we would expect the numerical result to coincide with the analytical solution up to roundoff accuracy. However, since we are using deformed cells following a sphere, which are only tracked by polynomials of degree 4 (one more than the degree for the finite elements), we will see that there is an error around \(10^{-7}\). We could get more accuracy by increasing the polynomial degree or refining the mesh.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error norms&quot;</span>);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; norm_per_cell_p(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactSolution&lt;dim&gt;(),</div><div class="line">                                    norm_per_cell_p,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   L2 error vs exact solution:   &quot;</span></div><div class="line">            &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactSolution&lt;dim&gt;(),</div><div class="line">                                    norm_per_cell_p,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   H1 error vs exact solution:   &quot;</span></div><div class="line">            &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The final post-processing operation we do here is to compute an error estimate with the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>. We use the exact same settings as in the <a class="el" href="step_6.html">step-6</a> tutorial program, except for the fact that we also hand in the mapping to ensure that errors are evaluated along the curved element, consistent with the remainder of the program. However, we do not really use the result here to drive a mesh adaptation step (that would refine the mesh around the material interface along the sphere), as the focus here is on the cost of this operation.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error estimator&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      mapping,</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Max cell-wise error estimate: &quot;</span></div><div class="line">              &lt;&lt; estimated_error_per_cell.linfty_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThePoissonProblemrunfunction"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem::run()</a> function</h3>
<p>Finally, we define the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function that controls how we want to execute this program (which is called by the main() function in the usual way). We start by calling the <code>create_grid()</code> function that sets up our geometry with the appropriate manifolds. We then run two instances of a solver chain, starting from the setup of the equations, the assembly of the linear system, its solution with a simple iterative solver, and the postprocessing discussed above. The two instances differ in the way they use the mapping. The first uses a conventional <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> mapping object which we initialize to a degree one more than we use for the finite element &ndash; after all, we expect the geometry representation to be the bottleneck as the analytic solution is only a quadratic polynomial. (In reality, things are interlinked to quite some extent because the evaluation of the polynomials in real coordinates involves the mapping of a higher-degree polynomials, which represent some smooth rational functions. As a consequence, higher-degree polynomials still pay off, so it does not make sense to increase the degree of the mapping further.) Once the first pass is completed, we let the timer print a summary of the compute times of the individual stages.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  create_grid();</div><div class="line"></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;====== Running with the basic MappingQGeneric class ====== &quot;</span></div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">    setup_system(mapping);</div><div class="line">    assemble_system(mapping);</div><div class="line">    solve();</div><div class="line">    postprocess(mapping);</div><div class="line"></div><div class="line">    timer.print_summary();</div><div class="line">    timer.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">  }</div></div><!-- fragment --><p>For the second instance, we instead set up the <a class="el" href="classMappingQCache.html">MappingQCache</a> class. Its use is very simple: After constructing it (with the degree, given that we want it to show the correct degree functionality in other contexts), we fill the cache via the <a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">MappingQCache::initialize()</a> function. At this stage, we specify which mapping we want to use (obviously, the same <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> as previously in order to repeat the same computations) for the cache, and then run through the same functions again, now handing in the modified mapping. In the end, we again print the accumulated wall times since the reset to see how the times compare to the original setting.</p>
<div class="fragment"><div class="line">    {</div><div class="line">      std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;====== Running with the optimized MappingQCache class ====== &quot;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQCache.html">MappingQCache&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Initialize mapping cache&quot;</span>);</div><div class="line">        mapping.initialize(<a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>(fe.degree + 1), triangulation);</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Memory consumption cache:     &quot;</span></div><div class="line">                &lt;&lt; 1e-6 * mapping.memory_consumption() &lt;&lt; <span class="stringliteral">&quot; MB&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">    }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step65</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Step65::PoissonProblem&lt;3&gt; test_program;</div><div class="line">  test_program.run();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-65/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>如果我们用三度的多项式运行这个程序的三维版本，我们会得到以下程序输出。</p>
<div class="fragment"><div class="line">&gt; make run</div><div class="line">Scanning dependencies of target step-65</div><div class="line">[ 33%] Building CXX <span class="keywordtype">object</span> CMakeFiles/step-65.dir/step-65.cc.o</div><div class="line">[ 66%] Linking CXX executable step-65</div><div class="line">[ 66%] Built target step-65</div><div class="line">[100%] Run step-65 with Release configuration</div><div class="line"></div><div class="line"></div><div class="line">====== Running with the basic <a class="code" href="classMappingQGeneric.html">MappingQGeneric</a> <span class="keyword">class </span>======</div><div class="line"></div><div class="line"></div><div class="line">   Number of active cells:       6656</div><div class="line">   Number of degrees of freedom: 181609</div><div class="line">   Number of solver iterations:  285</div><div class="line">   <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> error vs exact solution:   8.99339e-08</div><div class="line">   H1 error vs exact solution:   6.45341e-06</div><div class="line">   Max cell-wise error estimate: 0.00743406</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      49.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble linear system          |         1 |       5.8s |        12% |</div><div class="line">| Compute constraints             |         1 |     0.109s |      0.22% |</div><div class="line">| Compute error estimator         |         1 |      16.5s |        33% |</div><div class="line">| Compute error norms             |         1 |      9.11s |        18% |</div><div class="line">| Solve linear system             |         1 |      9.92s |        20% |</div><div class="line">| Write output                    |         1 |      4.85s |       9.8% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line">====== Running with the optimized <a class="code" href="classMappingQCache.html">MappingQCache</a> class ======</div><div class="line"></div><div class="line"></div><div class="line">   Memory consumption cache:     22.9981 MB</div><div class="line">   Number of active cells:       6656</div><div class="line">   Number of degrees of freedom: 181609</div><div class="line">   Number of solver iterations:  285</div><div class="line">   <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> error vs exact solution:   8.99339e-08</div><div class="line">   H1 error vs exact solution:   6.45341e-06</div><div class="line">   Max cell-wise error estimate: 0.00743406</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      18.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble linear system          |         1 |      1.44s |       7.8% |</div><div class="line">| Compute constraints             |         1 |   0.00336s |         0% |</div><div class="line">| Compute error estimator         |         1 |     0.476s |       2.6% |</div><div class="line">| Compute error norms             |         1 |     0.505s |       2.7% |</div><div class="line">| Initialize mapping cache        |         1 |      4.96s |        27% |</div><div class="line">| Solve linear system             |         1 |      9.95s |        54% |</div><div class="line">| Write output                    |         1 |     0.875s |       4.8% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line">[100%] Built target run</div></div><!-- fragment --><p>在讨论时序之前，我们看一下MappingQCache对象的内存消耗。我们的程序打印出它占用了23MB的内存。如果我们把这个数字与单个（解或右侧）向量的内存消耗联系起来，即1.5MB（即181,609个元素乘以每条8字节的双精度），或者与系统矩阵和稀疏模式所消耗的内存联系起来（274MB），我们就会发现，考虑到它的好处，这并不是一个过于沉重的数据结构。</p>
<p>在计时器方面，我们看到程序的整体运行时间明显改善了2.7倍。如果我们不考虑迭代求解器，它在两种情况下都是一样的（考虑到我们使用的简单预处理程序，以及稀疏矩阵-向量乘积对立方多项式的操作浪费的事实，它并不是最佳的），优势是几乎5倍。这对于一个线性静止问题来说是相当令人印象深刻的，而对于时间依赖性和非线性问题来说，成本的节省确实要突出得多，因为在这些问题上，会多次调用装配。如果我们研究一下各个组件，我们就会更清楚地了解发生了什么，以及为什么缓存会如此高效。在MappingQGeneric的情况下，基本上每一个涉及到映射的操作都需要至少5秒的时间来运行。规范的计算运行了两个 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> 函数，每个都需要5秒。(约束条件的计算比较便宜，因为它只在边界的单元格中评估映射，用于边界条件的插值)。如果我们将这5秒与填充MappingQCache的时间相比较，即5.2秒（对于所有单元，而不仅仅是活动单元），很明显，在MappingQGeneric的情况下，映射支持点的计算比其他一切都重要。也许最引人注目的结果是误差估计器的时间，标记为 "计算误差估计器"，其中MappingQGeneric的实现需要17.3秒，而MappingQCache的变体不到0.5秒。前者如此昂贵的原因（比如说，比装配贵三倍）是误差估计涉及到对面的量的评估，其中网格中的每个面都要求映射的额外点，而这些点又要经过非常昂贵的TransfiniteInterpolationManifold类。由于每个单元有六个面，这种情况比在装配中发生得更频繁。同样，MappingQCache很好地消除了重复评估，将所有涉及流形的昂贵步骤汇总到一个被重复使用的初始化调用中。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2019 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> * This tutorial program was contributed by Martin Kronbichler</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__cache_8h.html">deal.II/fe/mapping_q_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step65</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">        <span class="keywordflow">return</span> p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>();</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0.1 * p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() + (0.25 - 0.025);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">        <span class="keywordflow">return</span> 2. * p;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0.2 * p;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> coefficient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25)</div><div class="line">      <span class="keywordflow">return</span> 0.5;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 5.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PoissonProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PoissonProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> create_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;      system_matrix;</div><div class="line">    Vector&lt;double&gt;            solution;</div><div class="line">    Vector&lt;double&gt;            system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PoissonProblem&lt;dim&gt;::PoissonProblem()</div><div class="line">    : fe(3)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::create_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_inner;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria_inner, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_outer;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">      tria_outer, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(), 0.5, std::sqrt(dim), 2 * dim);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria_inner, tria_outer, triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keywordtype">bool</span> face_at_sphere_boundary = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : face-&gt;vertex_indices())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (std::abs(face-&gt;vertex(v).norm_square() - 0.25) &gt; 1e-12)</div><div class="line">                  face_at_sphere_boundary = <span class="keyword">false</span>;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">if</span> (face_at_sphere_boundary)</div><div class="line">              face-&gt;set_all_manifold_ids(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;center().norm_square() &lt; 0.25)</div><div class="line">          cell-&gt;set_material_id(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          cell-&gt;set_material_id(0);</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> transfinite_manifold;</div><div class="line">    transfinite_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, transfinite_manifold);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(9 - 2 * dim);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute constraints&quot;</span>);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        mapping, dof_handler, 0, ExactSolution&lt;dim&gt;(), constraints);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Assemble linear system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> partial_matrix(dofs_per_cell, dim * n_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_rhs = 0.;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient =</div><div class="line">              coefficient(fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_index));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                  partial_matrix(i, q_index * dim + d) =</div><div class="line">                    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index) * current_coefficient) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_index)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">                cell_rhs(i) +=</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                   (-dim) *                            <span class="comment">// f(x_q)</span></div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));            <span class="comment">// dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        partial_matrix.mTmult(cell_matrix, partial_matrix);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Solve linear system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionRelaxation.html#a73fb0eab08209d015a20797c19127588">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of solver iterations:  &quot;</span></div><div class="line">              &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PoissonProblem&lt;dim&gt;::postprocess(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;mapping)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Write output&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">      <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">      flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;double&gt; material_ids(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        material_ids[cell-&gt;active_cell_index()] = cell-&gt;material_id();</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(material_ids, <span class="stringliteral">&quot;material_ids&quot;</span>);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                             fe.degree,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">      std::ofstream file(</div><div class="line">        (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">         <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 10 + 2 * dim) +</div><div class="line">         <span class="stringliteral">&quot;.vtu&quot;</span>)</div><div class="line">          .c_str());</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(file);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error norms&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;double&gt; norm_per_cell_p(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        ExactSolution&lt;dim&gt;(),</div><div class="line">                                        norm_per_cell_p,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   L2 error vs exact solution:   &quot;</span></div><div class="line">                &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        ExactSolution&lt;dim&gt;(),</div><div class="line">                                        norm_per_cell_p,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   H1 error vs exact solution:   &quot;</span></div><div class="line">                &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Compute error estimator&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        mapping,</div><div class="line">        dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Max cell-wise error estimate: &quot;</span></div><div class="line">                &lt;&lt; estimated_error_per_cell.linfty_norm() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PoissonProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    create_grid();</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;====== Running with the basic MappingQGeneric class ====== &quot;</span></div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">      timer.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;====== Running with the optimized MappingQCache class ====== &quot;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <a class="code" href="classMappingQCache.html">MappingQCache&lt;dim&gt;</a> mapping(fe.degree + 1);</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> scope(timer, <span class="stringliteral">&quot;Initialize mapping cache&quot;</span>);</div><div class="line">        mapping.initialize(<a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>(fe.degree + 1), triangulation);</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Memory consumption cache:     &quot;</span></div><div class="line">                &lt;&lt; 1e-6 * mapping.memory_consumption() &lt;&lt; <span class="stringliteral">&quot; MB&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system(mapping);</div><div class="line">      assemble_system(mapping);</div><div class="line">      solve();</div><div class="line">      postprocess(mapping);</div><div class="line"></div><div class="line">      timer.print_summary();</div><div class="line">    }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step65</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Step65::PoissonProblem&lt;3&gt; test_program;</div><div class="line">  test_program.run();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
