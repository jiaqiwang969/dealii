<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/include_2deal_8II-translator_2A-tutorial_2step-9_8h_source.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II-translator/A-tutorial/step-9.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_386d89ad50a3909c2af5a93b48d2c3ff.html">deal.II-translator</a></li><li class="navelem"><a class="el" href="dir_7812fe2bbb6fb6db2d3962cae8700ca0.html">A-tutorial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">step-9.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="include_2deal_8II-translator_2A-tutorial_2step-9_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; <span class="keyword">false</span>);</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;     sparsity_pattern.copy_from(dsp);</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;* </div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;     system_matrix.reinit(sparsity_pattern);</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;* </div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;     solution.reinit(dof_handler.n_dofs());</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;     system_rhs.reinit(dof_handler.n_dofs());</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;   }</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;* </div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160; </div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;* </div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;* </div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;*  In the following <span class="keyword">function</span>, the <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a> and right hand side are assembled. As stated in the documentation of the main <span class="keyword">class </span>above, it does not do this itself, but rather delegates to the function following next, utilizing the <a class="code" href="namespaceWorkStream.html">WorkStream</a> concept discussed in   @ref threads   .   </div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;*   If you have looked through the   @ref threads   module, you will have seen that assembling in <a class="code" href="namespaceparallel.html">parallel</a> does not take an incredible amount of extra code as <span class="keywordtype">long</span> as you diligently describe what the scratch and <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a> data objects are, and <span class="keywordflow">if</span> you define suitable <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a> <span class="keywordflow">for</span> the local assembly and the <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a> operation from local contributions to global objects. This done, the following will <span class="keywordflow">do</span> all the heavy lifting to <span class="keyword">get</span> these operations done on multiple threads on as many cores as you have in your system:</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;* </div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;* </div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;* @code</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;   <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system()</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;   {</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;     <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.begin_active(),</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                     dof_handler.end(),</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;                    <span class="keyword">this</span>,</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;                     &amp;AdvectionProblem::local_assemble_system,</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;                     &amp;AdvectionProblem::copy_local_to_global,</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                     AssemblyScratchData(fe),</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                     AssemblyCopyData());</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;   }</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;* </div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160; </div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;* </div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;* </div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;*  As already mentioned above, we need to have scratch objects <span class="keywordflow">for</span> the <a class="code" href="namespaceparallel.html">parallel</a> computation of local contributions. These objects contain <a class="code" href="classFEValues.html">FEValues</a> and <a class="code" href="classFEFaceValues.html">FEFaceValues</a> objects (as well as some arrays), and so we will need to have constructors and <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a> constructors that allow us to create them. For the cell terms we need the <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> and <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a> of the shape <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a>, the quadrature points in order to determine the source density and the advection field at a given <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>, and the weights of the quadrature points times the <a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a> of the Jacobian at these points. In contrast, <span class="keywordflow">for</span> the boundary integrals, we don<span class="stringliteral">&#39;t need the gradients, but rather the normal vectors to the cells. This determines which update flags we will have to pass to the constructors of the members of the class:</span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="stringliteral">   AdvectionProblem&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="stringliteral">     const FiniteElement&lt;dim&gt; &amp;fe)</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="stringliteral">     : fe_values(fe,</span></div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="stringliteral">                 QGauss&lt;dim&gt;(fe.degree + 1),</span></div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="stringliteral">                 update_values | update_gradients | update_quadrature_points |</span></div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="stringliteral">                   update_JxW_values)</span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="stringliteral">     , fe_face_values(fe,</span></div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="stringliteral">                      QGauss&lt;dim</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="stringliteral">- 1&gt;(fe.degree + 1),</span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="stringliteral">                      update_values | update_quadrature_points |</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="stringliteral">                        update_JxW_values | update_normal_vectors)</span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="stringliteral">     , rhs_values(fe_values.get_quadrature().size())</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="stringliteral">     , advection_directions(fe_values.get_quadrature().size())</span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="stringliteral">     , face_boundary_values(fe_face_values.get_quadrature().size())</span></div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="stringliteral">     , face_advection_directions(fe_face_values.get_quadrature().size())</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="stringliteral">   {}</span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="stringliteral">   AdvectionProblem&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="stringliteral">     const AssemblyScratchData &amp;scratch_data)</span></div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="stringliteral">     : fe_values(scratch_data.fe_values.get_fe(),</span></div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="stringliteral">                 scratch_data.fe_values.get_quadrature(),</span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="stringliteral">                 update_values | update_gradients | update_quadrature_points |</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="stringliteral">                   update_JxW_values)</span></div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="stringliteral">     , fe_face_values(scratch_data.fe_face_values.get_fe(),</span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="stringliteral">                      scratch_data.fe_face_values.get_quadrature(),</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="stringliteral">                      update_values | update_quadrature_points |</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="stringliteral">                        update_JxW_values | update_normal_vectors)</span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="stringliteral">     , rhs_values(scratch_data.rhs_values.size())</span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="stringliteral">     , advection_directions(scratch_data.advection_directions.size())</span></div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="stringliteral">     , face_boundary_values(scratch_data.face_boundary_values.size())</span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="stringliteral">     , face_advection_directions(scratch_data.face_advection_directions.size())</span></div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="stringliteral">   {}</span></div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="stringliteral">*  Now, this is the function that does the actual work. It is not very different from the   &lt;code&gt;assemble_system&lt;/code&gt;   functions of previous example programs, so we will again only comment on the differences. The mathematical stuff closely follows what we have said in the introduction.   </span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="stringliteral">*   There are a number of points worth mentioning here, though. The first one is that we have moved the FEValues and FEFaceValues objects into the ScratchData object. We have done so because the alternative would have been to simply create one every time we get into this function</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="stringliteral">*  -  i.e., on every cell. It now turns out that the FEValues classes were written with the explicit goal of moving everything that remains the same from cell to cell into the construction of the object, and only do as little work as possible in   FEValues::reinit()   whenever we move to a new cell. What this means is that it would be very expensive to create a new object of this kind in this function as we would have to do it for every cell</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="stringliteral">*  -  exactly the thing we wanted to avoid with the FEValues class. Instead, what we do is create it only once (or a small number of times) in the scratch objects and then re-use it as often as we can.   </span></div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="stringliteral">*   This begs the question of whether there are other objects we create in this function whose creation is expensive compared to its use. Indeed, at the top of the function, we declare all sorts of objects. The   &lt;code&gt;AdvectionField&lt;/code&gt;  ,   &lt;code&gt;RightHandSide&lt;/code&gt; and &lt;code&gt;BoundaryValues&lt;/code&gt;   do not cost much to create, so there is no harm here. However, allocating memory in creating the   &lt;code&gt;rhs_values&lt;/code&gt;   and similar variables below typically costs a significant amount of time, compared to just accessing the (temporary) values we store in them. Consequently, these would be candidates for moving into the   &lt;code&gt;AssemblyScratchData&lt;/code&gt;   class. We will leave this as an exercise.</span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="stringliteral">   void AdvectionProblem&lt;dim&gt;::local_assemble_system(</span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;<span class="stringliteral">     const typename DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span></div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="stringliteral">     AssemblyScratchData &amp;                                 scratch_data,</span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="stringliteral">     AssemblyCopyData &amp;                                    copy_data)</span></div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="stringliteral">*  We define some abbreviations to avoid unnecessarily long lines:</span></div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;<span class="stringliteral">     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();</span></div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;<span class="stringliteral">     const unsigned int n_q_points =</span></div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;<span class="stringliteral">       scratch_data.fe_values.get_quadrature().size();</span></div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;<span class="stringliteral">     const unsigned int n_face_q_points =</span></div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="stringliteral">       scratch_data.fe_face_values.get_quadrature().size();</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;<span class="stringliteral">*  We declare cell matrix and cell right hand side...</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="stringliteral">     copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;<span class="stringliteral">     copy_data.cell_rhs.reinit(dofs_per_cell);</span></div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<span class="stringliteral">*  ... an array to hold the global indices of the degrees of freedom of the cell on which we are presently working...</span></div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="stringliteral">     copy_data.local_dof_indices.resize(dofs_per_cell);</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="stringliteral">*  ... then initialize the   &lt;code&gt;FEValues&lt;/code&gt;   object...</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="stringliteral">     scratch_data.fe_values.reinit(cell);</span></div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;<span class="stringliteral">*  ... obtain the values of right hand side and advection directions at the quadrature points...</span></div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="stringliteral">     scratch_data.advection_field.value_list(</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="stringliteral">       scratch_data.fe_values.get_quadrature_points(),</span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="stringliteral">       scratch_data.advection_directions);</span></div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="stringliteral">     scratch_data.right_hand_side.value_list(</span></div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;<span class="stringliteral">       scratch_data.fe_values.get_quadrature_points(), scratch_data.rhs_values);</span></div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="stringliteral">*  ... set the value of the streamline diffusion parameter as described in the introduction...</span></div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="stringliteral">     const double delta = 0.1 cell-&gt;diameter();</span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="stringliteral">*  ... and assemble the local contributions to the system matrix and right hand side as also discussed above:</span></div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="stringliteral">     for (unsigned int q_point = 0; q_point &lt; n_q_points; ++q_point)</span></div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;<span class="stringliteral">       for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</span></div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;<span class="stringliteral">         {</span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;<span class="stringliteral">*  Alias the AssemblyScratchData object to keep the lines from getting too long:</span></div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="stringliteral">           const auto &amp;sd = scratch_data;</span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;<span class="stringliteral">           for (unsigned int j = 0; j &lt; dofs_per_cell; ++j)</span></div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;<span class="stringliteral">             copy_data.cell_matrix(i, j) +=</span></div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;<span class="stringliteral">               ((sd.fe_values.shape_value(i, q_point) +           // (phi_i +</span></div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;<span class="stringliteral">                 delta (sd.advection_directions[q_point]      // delta beta</span></div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;<span class="stringliteral">                          sd.fe_values.shape_grad(i, q_point))) // grad phi_i)</span></div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;<span class="stringliteral">                sd.advection_directions[q_point]                // beta</span></div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="stringliteral">                sd.fe_values.shape_grad(j, q_point))            // grad phi_j</span></div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="stringliteral">               sd.fe_values.JxW(q_point);                         // dx</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="stringliteral">           copy_data.cell_rhs(i) +=</span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="stringliteral">             (sd.fe_values.shape_value(i, q_point) +           // (phi_i +</span></div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;<span class="stringliteral">              delta (sd.advection_directions[q_point]      // delta beta</span></div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;<span class="stringliteral">                       sd.fe_values.shape_grad(i, q_point))) // grad phi_i)</span></div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;<span class="stringliteral">             sd.rhs_values[q_point]                          // f</span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="stringliteral">             sd.fe_values.JxW(q_point);                        // dx</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="stringliteral">         }</span></div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;<span class="stringliteral">*  Besides the cell terms which we have built up now, the bilinear form of the present problem also contains terms on the boundary of the domain. Therefore, we have to check whether any of the faces of this cell are on the boundary of the domain, and if so assemble the contributions of this face as well. Of course, the bilinear form only contains contributions from the   &lt;code&gt;inflow&lt;/code&gt;   part of the boundary, but to find out whether a certain part of a face of the present cell is part of the inflow boundary, we have to have information on the exact location of the quadrature points and on the direction of flow at this point; we obtain this information using the FEFaceValues object and only decide within the main loop whether a quadrature point is on the inflow boundary.</span></div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;<span class="stringliteral">     for (const auto &amp;face : cell-&gt;face_iterators())</span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;<span class="stringliteral">       if (face-&gt;at_boundary())</span></div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;<span class="stringliteral">         {</span></div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;<span class="stringliteral">*  Ok, this face of the present cell is on the boundary of the domain. Just as for the usual FEValues object which we have used in previous examples and also above, we have to reinitialize the FEFaceValues object for the present face:</span></div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;<span class="stringliteral">           scratch_data.fe_face_values.reinit(cell, face);</span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<span class="stringliteral">*  For the quadrature points at hand, we ask for the values of the inflow function and for the direction of flow:</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;<span class="stringliteral">           scratch_data.boundary_values.value_list(</span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;<span class="stringliteral">             scratch_data.fe_face_values.get_quadrature_points(),</span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;<span class="stringliteral">             scratch_data.face_boundary_values);</span></div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;<span class="stringliteral">           scratch_data.advection_field.value_list(</span></div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;<span class="stringliteral">             scratch_data.fe_face_values.get_quadrature_points(),</span></div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;<span class="stringliteral">             scratch_data.face_advection_directions);</span></div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;<span class="stringliteral">*  Now loop over all quadrature points and see whether this face is on the inflow or outflow part of the boundary. The normal vector points out of the cell: since the face is at the boundary, the normal vector points out of the domain, so if the advection direction points into the domain, its scalar product with the normal vector must be negative (to see why this is true, consider the scalar product definition that uses a cosine):</span></div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;<span class="stringliteral">           for (unsigned int q_point = 0; q_point &lt; n_face_q_points; ++q_point)</span></div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="stringliteral">             if (scratch_data.fe_face_values.normal_vector(q_point)</span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="stringliteral">                   scratch_data.face_advection_directions[q_point] &lt;</span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="stringliteral">                 0.)</span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;<span class="stringliteral">*  If the face is part of the inflow boundary, then compute the contributions of this face to the global matrix and right hand side, using the values obtained from the FEFaceValues object and the formulae discussed in the introduction:</span></div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;<span class="stringliteral">               for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</span></div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;<span class="stringliteral">                 {</span></div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;<span class="stringliteral">                   for (unsigned int j = 0; j &lt; dofs_per_cell; ++j)</span></div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;<span class="stringliteral">                     copy_data.cell_matrix(i, j)</span></div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;<span class="stringliteral">-=</span></div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="stringliteral">                       (scratch_data.face_advection_directions[q_point]</span></div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="stringliteral">                        scratch_data.fe_face_values.normal_vector(q_point)</span></div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;<span class="stringliteral">                        scratch_data.fe_face_values.shape_value(i, q_point)</span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;<span class="stringliteral">                        scratch_data.fe_face_values.shape_value(j, q_point)</span></div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;<span class="stringliteral">                        scratch_data.fe_face_values.JxW(q_point));</span></div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;<span class="stringliteral">                   copy_data.cell_rhs(i)</span></div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="stringliteral">-=</span></div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="stringliteral">                     (scratch_data.face_advection_directions[q_point]</span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="stringliteral">                      scratch_data.fe_face_values.normal_vector(q_point)</span></div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="stringliteral">                      scratch_data.face_boundary_values[q_point]</span></div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="stringliteral">                      scratch_data.fe_face_values.shape_value(i, q_point)</span></div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="stringliteral">                      scratch_data.fe_face_values.JxW(q_point));</span></div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="stringliteral">                 }</span></div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="stringliteral">         }</span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;<span class="stringliteral">*  The final piece of information the copy routine needs is the global indices of the degrees of freedom on this cell, so we end by writing them to the local array:</span></div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="stringliteral">     cell-&gt;get_dof_indices(copy_data.local_dof_indices);</span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="stringliteral">*  The second function we needed to write was the one that copies the local contributions the previous function computed (and put into the AssemblyCopyData object) into the global matrix and right hand side vector objects. This is essentially what we always had as the last block of code when assembling something on every cell. The following should therefore be pretty obvious:</span></div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;<span class="stringliteral">   void</span></div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="stringliteral">   AdvectionProblem&lt;dim&gt;::copy_local_to_global(const AssemblyCopyData &amp;copy_data)</span></div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;<span class="stringliteral">     hanging_node_constraints.distribute_local_to_global(</span></div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;<span class="stringliteral">       copy_data.cell_matrix,</span></div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;<span class="stringliteral">       copy_data.cell_rhs,</span></div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;<span class="stringliteral">       copy_data.local_dof_indices,</span></div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;<span class="stringliteral">       system_matrix,</span></div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="stringliteral">       system_rhs);</span></div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="stringliteral">*  Here comes the linear solver routine. As the system is no longer symmetric positive definite as in all the previous examples, we cannot use the Conjugate Gradient method anymore. Rather, we use a solver that is more general and does not rely on any special properties of the matrix: the GMRES method. GMRES, like the conjugate gradient method, requires a decent preconditioner: we use a Jacobi preconditioner here, which works well enough for this problem.</span></div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="stringliteral">   void AdvectionProblem&lt;dim&gt;::solve()</span></div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="stringliteral">     SolverControl               solver_control(std::max&lt;std::size_t&gt;(1000,</span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="stringliteral">                                                        system_rhs.size() / 10),</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="stringliteral">                                  1e-10 system_rhs.l2_norm());</span></div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;<span class="stringliteral">     SolverGMRES&lt;Vector&lt;double&gt;&gt; solver(solver_control);</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;<span class="stringliteral">     PreconditionJacobi&lt;SparseMatrix&lt;double&gt;&gt; preconditioner;</span></div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="stringliteral">     preconditioner.initialize(system_matrix, 1.0);</span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="stringliteral">     solver.solve(system_matrix, solution, system_rhs, preconditioner);</span></div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="stringliteral">     Vector&lt;double&gt; residual(dof_handler.n_dofs());</span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="stringliteral">     system_matrix.vmult(residual, solution);</span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="stringliteral">     residual</span></div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;<span class="stringliteral">-= system_rhs;</span></div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="stringliteral">     std::cout &lt;&lt; &quot;   Iterations required for convergence: &quot;</span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="stringliteral">               &lt;&lt; solver_control.last_step() &lt;&lt; &#39;</span>\n<span class="stringliteral">&#39;</span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="stringliteral">               &lt;&lt; &quot;   Max norm of residual:                &quot;</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="stringliteral">               &lt;&lt; residual.linfty_norm() &lt;&lt; &#39;</span>\n<span class="stringliteral">&#39;;</span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="stringliteral">     hanging_node_constraints.distribute(solution);</span></div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="stringliteral">*  The following function refines the grid according to the quantity described in the introduction. The respective computations are made in the class   &lt;code&gt;GradientEstimation&lt;/code&gt;  .</span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="stringliteral">   void AdvectionProblem&lt;dim&gt;::refine_grid()</span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="stringliteral">     Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</span></div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;<span class="stringliteral">     GradientEstimation::estimate(dof_handler,</span></div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;<span class="stringliteral">                                  solution,</span></div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="stringliteral">                                  estimated_error_per_cell);</span></div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="stringliteral">     GridRefinement::refine_and_coarsen_fixed_number(triangulation,</span></div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="stringliteral">                                                     estimated_error_per_cell,</span></div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;<span class="stringliteral">                                                     0.3,</span></div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;<span class="stringliteral">                                                     0.03);</span></div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="stringliteral">     triangulation.execute_coarsening_and_refinement();</span></div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="stringliteral">*  This function is similar to the one in step 6, but since we use a higher degree finite element we save the solution in a different way. Visualization programs like VisIt and Paraview typically only understand data that is associated with nodes: they cannot plot fifth-degree basis functions, which results in a very inaccurate picture of the solution we computed. To get around this we save multiple   &lt;em&gt;  patches  &lt;/em&gt;   per cell: in 2D we save 64 bilinear `cells&#39;</span> to the VTU file <span class="keywordflow">for each</span> cell, and in 3D we save 512. The <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a> result is that the visualization program will use a piecewise linear interpolation of the cubic basis <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a>: <span class="keyword">this</span> captures the solution detail and, with most screen resolutions, looks smooth. We save the grid in a separate step with no extra patches so that we have a visual representation of the cell faces.   </div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;*   Version 9.1 of deal.II gained the ability to write higher degree polynomials (i.e., write piecewise bicubic visualization data <span class="keywordflow">for</span> our piecewise bicubic solution) VTK and VTU output: however, not all recent versions of ParaView and VisIt (as of 2018) can read <span class="keyword">this</span> format, so we use the older, more <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98af25b68380698c53fa6da3e05379c0855">general</a> (but less efficient) approach here.</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;* </div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;* </div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;* @code</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;   <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<span class="keyword">   </span>{</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;     {</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;       <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;       std::ofstream output(<span class="stringliteral">&quot;grid-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;       grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, output);</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;     }</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;* </div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;     {</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;       <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;       data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;       data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;       data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(8);</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;* </div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;* </div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;*  VTU output can be expensive, both to compute and to write to disk. Here we ask ZLib, a compression library, to <a class="code" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress</a> the data in a way that maximizes throughput.</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;* </div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;* </div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;* @code</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;       <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;       vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;         DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;       data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(vtk_flags);</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;* </div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;       std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;       data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;     }</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;   }</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;* </div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160; </div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;* </div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;*  ... as is the main <a class="code" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop</a> (setup</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;* </div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;*  -  solve</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;* </div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;*  -  <a class="code" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine</a>), aside from the number of cycles and the <a class="code" href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">initial</a> grid:</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;* </div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;* </div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;* @code</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;   <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;   {</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 10; ++cycle)</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;       {</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;         std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;* </div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;         <span class="keywordflow">if</span> (cycle == 0)</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;           {</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;             <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;* </div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;-1, 1);</div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;             <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(3);</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;           }</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;         <span class="keywordflow">else</span></div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;           {</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;             refine_grid();</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;           }</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;* </div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160; </div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;         std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:              &quot;</span></div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;                   &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells() &lt;&lt; std::endl;</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;* </div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;         setup_system();</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;* </div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;         std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom:        &quot;</span></div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;                   &lt;&lt; dof_handler.n_dofs() &lt;&lt; std::endl;</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;* </div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;         assemble_system();</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;         solve();</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;         output_results(cycle);</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;       }</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;   }</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;* </div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160; </div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;* </div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;* </div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;*   &lt;a name=<span class="stringliteral">&quot;GradientEstimationclassimplementation&quot;</span>&gt;&lt;/a&gt;  &lt;h3&gt;GradientEstimation <span class="keyword">class </span>implementation&lt;/h3&gt;</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;* </div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;* </div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;*  Now <span class="keywordflow">for</span> the implementation of the   &lt;code&gt;GradientEstimation&lt;/code&gt;   <span class="keyword">class</span>. Let us start by defining constructors <span class="keywordflow">for</span> the   &lt;code&gt;EstimateScratchData&lt;/code&gt;   <span class="keyword">class </span>used by the   &lt;code&gt;estimate_cell()&lt;/code&gt;   function:</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;* </div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;* </div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;* @code</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;   template &lt;int dim&gt;</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;   GradientEstimation::EstimateScratchData&lt;dim&gt;::EstimateScratchData(</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;     const FiniteElement&lt;dim&gt; &amp;fe,</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;     const Vector&lt;double&gt; &amp;    solution,</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;     Vector&lt;float&gt; &amp;           error_per_cell)</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;     : fe_midpoint_value(fe,</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;                         QMidpoint&lt;dim&gt;(),</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;                         update_values | update_quadrature_points)</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;     , solution(solution)</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;     , error_per_cell(error_per_cell)</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;     , cell_midpoint_value(1)</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;     , neighbor_midpoint_value(1)</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;   {</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;* </div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;*  We allocate a vector to hold iterators to all active neighbors of a cell. We reserve the maximal number of active neighbors in order to avoid later reallocations. Note how <span class="keyword">this</span> maximal number of active neighbors is computed here.</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;* </div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;* </div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;* @code</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;     active_neighbors.reserve(<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::faces_per_cell</a></div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;                              <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::max_children_per_face</a>);</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;   }</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;* </div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160; </div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;   GradientEstimation::EstimateScratchData&lt;dim&gt;::EstimateScratchData(</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;     <span class="keyword">const</span> EstimateScratchData &amp;scratch_data)</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;     : fe_midpoint_value(scratch_data.fe_midpoint_value.get_fe(),</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;                         scratch_data.fe_midpoint_value.get_quadrature(),</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>)</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;     , solution(scratch_data.solution)</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;     , error_per_cell(scratch_data.error_per_cell)</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;     , cell_midpoint_value(1)</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;     , neighbor_midpoint_value(1)</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;   {}</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;* </div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160; </div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;* </div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;*  Next comes the implementation of the   &lt;code&gt;GradientEstimation&lt;/code&gt;   <span class="keyword">class</span>. The <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> <span class="keyword">function</span> does not much except <span class="keywordflow">for</span> delegating work to the other <span class="keyword">function</span>, but there is a bit of setup at the top.   </div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;*   Before starting with the work, we check that the vector into which the results are written has the right size. Programming mistakes in which <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a> forgets to size arguments correctly at the calling site are quite common. Because the resulting damage from not catching such errors is often subtle (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>.g., corruption of data somewhere in memory, or non-reproducible results), it is well worth the effort to check <span class="keywordflow">for</span> such things.</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;* </div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;* </div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;* @code</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;   <span class="keywordtype">void</span> GradientEstimation::estimate(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution,</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;                                     <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;        error_per_cell)</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;   {</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;       error_per_cell.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>(),</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;       ExcInvalidVectorLength(error_per_cell.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;                              dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()));</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;* </div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;     <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;                     dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;                     &amp;GradientEstimation::template estimate_cell&lt;dim&gt;,</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;                     std::function&lt;void(const EstimateCopyData &amp;)&gt;(),</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;                     EstimateScratchData&lt;dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>(),</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;                                              solution,</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;                                              error_per_cell),</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;                     EstimateCopyData());</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;   }</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;* </div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160; </div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;* </div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;*  Here comes the <span class="keyword">function</span> that estimates the local error by computing the finite difference approximation of the <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">gradient</a>. The <span class="keyword">function</span> <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> computes the list of active neighbors of the present cell and then computes the quantities described in the introduction <span class="keywordflow">for each</span> of the neighbors. The reason <span class="keywordflow">for</span> <span class="keyword">this</span> order is that it is not a <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a>-liner to find a given neighbor with locally refined meshes. In principle, an optimized implementation would find neighbors and the quantities depending on them in <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a> step, rather than <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> building a list of neighbors and in a <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a> step their contributions but we will gladly leave <span class="keyword">this</span> as an exercise. As discussed before, the worker <span class="keyword">function</span> passed to   <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>   works on <span class="stringliteral">&quot;scratch&quot;</span> objects that keep all temporary objects. This way, we <span class="keywordflow">do</span> not need to create and initialize objects that are expensive to initialize within the <span class="keyword">function</span> that does the work every time it is called <span class="keywordflow">for</span> a given cell. Such an argument is passed as the <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a> argument. The third argument would be a <span class="stringliteral">&quot;copy-data&quot;</span> object (see   @ref threads   <span class="keywordflow">for</span> more information) but we <span class="keywordflow">do</span> not actually use any of these here. Since   <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>()   insists on passing three arguments, we declare this function with three arguments, but simply ignore the last <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a>.   </div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;*   (This is unsatisfactory from an aesthetic perspective. It can be avoided by using an anonymous (lambda) function. If you allow, let us here show how. First, assume that we had declared this function to only take two arguments by omitting the unused last <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a>. Now,   <a class="code" href="namespaceWorkStream.html">WorkStream</a>::<a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>   still wants to <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a> this function with three arguments, so we need to find a way to &quot;forget&quot; the third argument in the <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a>. Simply passing   <a class="code" href="namespaceWorkStream.html">WorkStream</a>::<a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>   the pointer to the function as we do above will not do this</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;* </div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;*  -  the compiler will complain that a function declared to have two arguments is called with three arguments. However, we can do this by passing the following as the third argument to   <a class="code" href="namespaceWorkStream.html">WorkStream</a>::<a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>():     &lt;div class=CodeFragmentInTutorialComment&gt;</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;* </div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;* </div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;@code</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160; [](const typename <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::active_cell_iterator &amp;cell,</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;    EstimateScratchData&lt;dim&gt; &amp;                            scratch_data,</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;    EstimateCopyData &amp;)</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160; {</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;   GradientEstimation::estimate_cell&lt;dim&gt;(cell, scratch_data);</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160; }</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;* </div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160; &lt;/div&gt;   This is not much better than the solution implemented below: either the routine itself must take three arguments or it must be wrapped by something that takes three arguments. We don<span class="stringliteral">&#39;t use this since adding the unused argument at the beginning is simpler.   </span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="stringliteral">*   Now for the details:</span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;<span class="stringliteral">   void GradientEstimation::estimate_cell(</span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="stringliteral">     const typename DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span></div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="stringliteral">     EstimateScratchData&lt;dim&gt; &amp;                            scratch_data,</span></div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="stringliteral">     const EstimateCopyData &amp;)</span></div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="stringliteral">*  We need space for the tensor   &lt;code&gt;Y&lt;/code&gt;  , which is the sum of outer products of the y-vectors.</span></div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="stringliteral">     Tensor&lt;2, dim&gt; Y;</span></div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="stringliteral">*  First initialize the   &lt;code&gt;FEValues&lt;/code&gt;   object, as well as the   &lt;code&gt;Y&lt;/code&gt;   tensor:</span></div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;<span class="stringliteral">     scratch_data.fe_midpoint_value.reinit(cell);</span></div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="stringliteral">*  Now, before we go on, we first compute a list of all active neighbors of the present cell. We do so by first looping over all faces and see whether the neighbor there is active, which would be the case if it is on the same level as the present cell or one level coarser (note that a neighbor can only be once coarser than the present cell, as we only allow a maximal difference of one refinement over a face in deal.II). Alternatively, the neighbor could be on the same level and be further refined; then we have to find which of its children are next to the present cell and select these (note that if a child of a neighbor of an active cell that is next to this active cell, needs necessarily be active itself, due to the one-refinement rule cited above).     </span></div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;<span class="stringliteral">*   Things are slightly different in one space dimension, as there the one-refinement rule does not exist: neighboring active cells may differ in as many refinement levels as they like. In this case, the computation becomes a little more difficult, but we will explain this below.     </span></div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;<span class="stringliteral">*   Before starting the loop over all neighbors of the present cell, we have to clear the array storing the iterators to the active neighbors, of course.</span></div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="stringliteral">     scratch_data.active_neighbors.clear();</span></div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="stringliteral">     for (const auto face_n : cell-&gt;face_indices())</span></div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="stringliteral">       if (!cell-&gt;at_boundary(face_n))</span></div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="stringliteral">         {</span></div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="stringliteral">*  First define an abbreviation for the iterator to the face and the neighbor</span></div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;<span class="stringliteral">           const auto face     = cell-&gt;face(face_n);</span></div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="stringliteral">           const auto neighbor = cell-&gt;neighbor(face_n);</span></div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;<span class="stringliteral">*  Then check whether the neighbor is active. If it is, then it is on the same level or one level coarser (if we are not in 1D), and we are interested in it in any case.</span></div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="stringliteral">           if (neighbor-&gt;is_active())</span></div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="stringliteral">             scratch_data.active_neighbors.push_back(neighbor);</span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="stringliteral">           else</span></div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="stringliteral">             {</span></div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;<span class="stringliteral">*  If the neighbor is not active, then check its children.</span></div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;<span class="stringliteral">               if (dim == 1)</span></div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;<span class="stringliteral">                 {</span></div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;<span class="stringliteral">*  To find the child of the neighbor which bounds to the present cell, successively go to its right child if we are left of the present cell (n==0), or go to the left child if we are on the right (n==1), until we find an active cell.</span></div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;<span class="stringliteral">                   auto neighbor_child = neighbor;</span></div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;<span class="stringliteral">                   while (neighbor_child-&gt;has_children())</span></div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;<span class="stringliteral">                     neighbor_child = neighbor_child-&gt;child(face_n == 0 ? 1 : 0);</span></div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;<span class="stringliteral">*  As this used some non-trivial geometrical intuition, we might want to check whether we did it right, i.e., check whether the neighbor of the cell we found is indeed the cell we are presently working on. Checks like this are often useful and have frequently uncovered errors both in algorithms like the line above (where it is simple to involuntarily exchange   &lt;code&gt;n==1&lt;/code&gt; for &lt;code&gt;n==0&lt;/code&gt;   or the like) and in the library (the assumptions underlying the algorithm above could either be wrong, wrongly documented, or are violated due to an error in the library). One could in principle remove such checks after the program works for some time, but it might be a good things to leave it in anyway to check for changes in the library or in the algorithm above.                   </span></div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;<span class="stringliteral">*   Note that if this check fails, then this is certainly an error that is irrecoverable and probably qualifies as an internal error. We therefore use a predefined exception class to throw here.</span></div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;<span class="stringliteral">                   Assert(neighbor_child-&gt;neighbor(face_n == 0 ? 1 : 0) == cell,</span></div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;<span class="stringliteral">                          ExcInternalError());</span></div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;<span class="stringliteral">*  If the check succeeded, we push the active neighbor we just found to the stack we keep:</span></div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="stringliteral">                   scratch_data.active_neighbors.push_back(neighbor_child);</span></div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="stringliteral">                 }</span></div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="stringliteral">               else</span></div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;<span class="stringliteral">*  If we are not in 1d, we collect all neighbor children `behind&#39;</span> the subfaces of the current face and move on:</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;* </div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;* </div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;* @code</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_n = 0; subface_n &lt; face-&gt;n_children();</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;                      ++subface_n)</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;                   scratch_data.active_neighbors.push_back(</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;                     cell-&gt;neighbor_child_on_subface(face_n, subface_n));</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;             }</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;         }</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;* </div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;* </div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;*  OK, now that we have all the neighbors, lets start the computation on each of them. First we <span class="keywordflow">do</span> some preliminaries: find out about the <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> of the present cell and the solution at <span class="keyword">this</span> point. The latter is obtained as a vector of <span class="keyword">function</span> <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> at the quadrature points, of which there are only <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a>, of course. Likewise, the position of the <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> is the position of the <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> (and only) quadrature point in real space.</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;* </div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;* </div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;* @code</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;     <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> this_center =</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;       scratch_data.fe_midpoint_value.quadrature_point(0);</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;* </div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;     scratch_data.fe_midpoint_value.get_function_values(</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;       scratch_data.solution, scratch_data.cell_midpoint_value);</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;* </div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;* </div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;*  Now <a class="code" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop</a> over all active neighbors and collect the data we need.</div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;* </div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;</div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;* </div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;* @code</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;     <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> projected_gradient;</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;neighbor : scratch_data.active_neighbors)</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;       {</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;* </div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;*  Then <span class="keyword">get</span> the <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> of the neighbor cell and the <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a> of the finite element <span class="keyword">function</span> at that point. Note that <span class="keywordflow">for</span> <span class="keyword">this</span> information we have to reinitialize the   &lt;code&gt;<a class="code" href="classFEValues.html">FEValues</a>&lt;/code&gt;   <span class="keywordtype">object</span> <span class="keywordflow">for</span> the neighbor cell.</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;* </div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;* </div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;* @code</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;         scratch_data.fe_midpoint_value.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(neighbor);</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;         <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> neighbor_center =</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;           scratch_data.fe_midpoint_value.quadrature_point(0);</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;* </div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;         scratch_data.fe_midpoint_value.get_function_values(</div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;           scratch_data.solution, scratch_data.neighbor_midpoint_value);</div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;* </div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;* </div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;*  Compute the vector   &lt;code&gt;y&lt;/code&gt;   connecting the centers of the two cells. Note that as opposed to the introduction, we denote by   &lt;code&gt;y&lt;/code&gt;   the normalized difference vector, as <span class="keyword">this</span> is the quantity used everywhere in the computations.</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;* </div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;* </div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;* @code</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;         <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> y        = neighbor_center</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;* </div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;- this_center;</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;         <span class="keyword">const</span> <span class="keywordtype">double</span>   distance = y.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;         y /= distance;</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;* </div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;* </div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;*  Then add up the contribution of <span class="keyword">this</span> cell to the Y <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>...</div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;* </div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;</div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;* </div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;* @code</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dim; ++j)</div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;             Y[i][j] += y[i] y[j];</div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;* </div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;* </div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;*  ... and update the <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> of difference quotients:</div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;* </div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;* </div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;* @code</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;         projected_gradient += (scratch_data.neighbor_midpoint_value[0]</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;* </div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;-</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;                                scratch_data.cell_midpoint_value[0]) /</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;                               distance y;</div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;       }</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;* </div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;* </div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;*  If now, after collecting all the information from the neighbors, we can determine an approximation of the <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">gradient</a> <span class="keywordflow">for</span> the present cell, then we need to have passed over vectors   &lt;code&gt;y&lt;/code&gt;   which span the whole space, otherwise we would not have all components of the <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">gradient</a>. This is indicated by the invertibility of the <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.     </div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;*   If the <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a> is not invertible, then the present cell had an insufficient number of active neighbors. In contrast to all previous cases (where we raised exceptions) <span class="keyword">this</span> is, however, not a programming error: it is a runtime error that can happen in optimized mode even <span class="keywordflow">if</span> it ran well in debug mode, so it is reasonable to <span class="keywordflow">try</span> to <span class="keywordflow">catch</span> <span class="keyword">this</span> error also in optimized mode. For <span class="keyword">this</span> <span class="keywordflow">case</span>, there is the   &lt;code&gt;<a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>&lt;/code&gt;   macro: it checks the condition like the   &lt;code&gt;<a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>&lt;/code&gt;   macro, but not only in debug mode; it then outputs an error message, but instead of aborting the program as in the <span class="keywordflow">case</span> of the   &lt;code&gt;<a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>&lt;/code&gt;   macro, the exception is thrown <span class="keyword">using</span> the   &lt;code&gt;<span class="keywordflow">throw</span>&lt;/code&gt;   command of <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>++. This way, one has the possibility to <span class="keywordflow">catch</span> <span class="keyword">this</span> error and take reasonable counter actions. One such measure would be to <a class="code" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine</a> the grid globally, as the <span class="keywordflow">case</span> of insufficient directions can not occur <span class="keywordflow">if</span> every cell of the <a class="code" href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">initial</a> grid has been refined at least once.</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;* </div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;* </div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;* @code</div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;     <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Y) != 0, ExcInsufficientDirections());</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;* </div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;* </div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;*  If, on the other hand, the <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a> is invertible, then <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a> it, multiply the other quantity with it, and compute the estimated error <span class="keyword">using</span> <span class="keyword">this</span> quantity and the correct powers of the mesh width:</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;* </div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;* </div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;* @code</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> Y_inverse = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(Y);</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;* </div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">gradient</a> = Y_inverse projected_gradient;</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;* </div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;* </div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;*  The last part of <span class="keyword">this</span> <span class="keyword">function</span> is the one where we write into the element of the output vector what we have just computed. The address of <span class="keyword">this</span> vector has been stored in the scratch data object, and all we have to <span class="keywordflow">do</span> is know how to <span class="keyword">get</span> at the correct element inside <span class="keyword">this</span> vector</div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;* </div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;*  -  but we can ask the cell we<span class="stringliteral">&#39;re on the how-manyth active cell it is for this:</span></div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;<span class="stringliteral">     scratch_data.error_per_cell(cell-&gt;active_cell_index()) =</span></div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;<span class="stringliteral">       (std::pow(cell-&gt;diameter(), 1 + 1.0 dim / 2) gradient.norm());</span></div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;<span class="stringliteral"> } // namespace Step9</span></div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;Mainfunction&quot;&gt;&lt;/a&gt;  &lt;h3&gt;Main function&lt;/h3&gt;</span></div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;<span class="stringliteral">*  The   &lt;code&gt;main&lt;/code&gt;   function is similar to the previous examples. The primary difference is that we use MultithreadInfo to set the maximum number of threads (see the documentation module   @ref threads   &quot;Parallel computing with multiple processors accessing shared memory&quot; for more information). The number of threads used is the minimum of the environment variable DEAL_II_NUM_THREADS and the parameter of   &lt;code&gt;set_thread_limit&lt;/code&gt;  . If no value is given to   &lt;code&gt;set_thread_limit&lt;/code&gt;  , the default value from the Intel Threading Building Blocks (TBB) library is used. If the call to   &lt;code&gt;set_thread_limit&lt;/code&gt;   is omitted, the number of threads will be chosen by TBB independently of DEAL_II_NUM_THREADS.</span></div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;<span class="stringliteral"> int main()</span></div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;<span class="stringliteral"> {</span></div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="stringliteral">   using namespace dealii;</span></div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;<span class="stringliteral">   try</span></div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;<span class="stringliteral">     {</span></div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="stringliteral">       MultithreadInfo::set_thread_limit();</span></div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;<span class="stringliteral">       Step9::AdvectionProblem&lt;2&gt; advection_problem_2d;</span></div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;<span class="stringliteral">       advection_problem_2d.run();</span></div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;<span class="stringliteral">     }</span></div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;<span class="stringliteral">   catch (std::exception &amp;exc)</span></div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;<span class="stringliteral">     {</span></div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; std::endl</span></div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl</span></div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;<span class="stringliteral">                 &lt;&lt; exc.what() &lt;&lt; std::endl</span></div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;<span class="stringliteral">       return 1;</span></div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;<span class="stringliteral">     }</span></div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;<span class="stringliteral">   catch (...)</span></div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;<span class="stringliteral">     {</span></div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; std::endl</span></div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl</span></div><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;<span class="stringliteral">       return 1;</span></div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;<span class="stringliteral">     }</span></div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;<span class="stringliteral">   return 0;</span></div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;<span class="stringliteral"> }</span></div><div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;<span class="stringliteral">* &lt;a name=&quot;Results&quot;&gt;&lt;/a&gt;&lt;h1&gt;Results&lt;/h1&gt;</span></div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;<span class="stringliteral">* The results of this program are not particularly spectacular. Theyconsist of the console output, some grid files, and the solution oneach of these grids. First for the console output:</span></div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;<span class="stringliteral">Cycle 0:</span></div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;<span class="stringliteral">   Number of active cells:              64</span></div><div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        1681</span></div><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;<span class="stringliteral">   Iterations required for convergence: 298</span></div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;<span class="stringliteral">   Max norm of residual:                3.60316e-12</span></div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;<span class="stringliteral">Cycle 1:</span></div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;<span class="stringliteral">   Number of active cells:              124</span></div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        3537</span></div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;<span class="stringliteral">   Iterations required for convergence: 415</span></div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;<span class="stringliteral">   Max norm of residual:                3.70682e-12</span></div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;<span class="stringliteral">Cycle 2:</span></div><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;<span class="stringliteral">   Number of active cells:              247</span></div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        6734</span></div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;<span class="stringliteral">   Iterations required for convergence: 543</span></div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;<span class="stringliteral">   Max norm of residual:                7.19716e-13</span></div><div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="stringliteral">Cycle 3:</span></div><div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="stringliteral">   Number of active cells:              502</span></div><div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        14105</span></div><div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;<span class="stringliteral">   Iterations required for convergence: 666</span></div><div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;<span class="stringliteral">   Max norm of residual:                3.45628e-13</span></div><div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;<span class="stringliteral">Cycle 4:</span></div><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;<span class="stringliteral">   Number of active cells:              1003</span></div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        27462</span></div><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;<span class="stringliteral">   Iterations required for convergence: 1064</span></div><div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;<span class="stringliteral">   Max norm of residual:                1.86495e-13</span></div><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;<span class="stringliteral">Cycle 5:</span></div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;<span class="stringliteral">   Number of active cells:              1993</span></div><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        55044</span></div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;<span class="stringliteral">   Iterations required for convergence: 1251</span></div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;<span class="stringliteral">   Max norm of residual:                1.28765e-13</span></div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;<span class="stringliteral">Cycle 6:</span></div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;<span class="stringliteral">   Number of active cells:              3985</span></div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        108492</span></div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;<span class="stringliteral">   Iterations required for convergence: 2035</span></div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;<span class="stringliteral">   Max norm of residual:                6.78085e-14</span></div><div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;<span class="stringliteral">Cycle 7:</span></div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;<span class="stringliteral">   Number of active cells:              7747</span></div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        210612</span></div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;<span class="stringliteral">   Iterations required for convergence: 2187</span></div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;<span class="stringliteral">   Max norm of residual:                2.61457e-14</span></div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;<span class="stringliteral">Cycle 8:</span></div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;<span class="stringliteral">   Number of active cells:              15067</span></div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        406907</span></div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;<span class="stringliteral">   Iterations required for convergence: 3079</span></div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;<span class="stringliteral">   Max norm of residual:                2.9932e-14</span></div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;<span class="stringliteral">Cycle 9:</span></div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="stringliteral">   Number of active cells:              29341</span></div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;<span class="stringliteral">   Number of degrees of freedom:        780591</span></div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;<span class="stringliteral">   Iterations required for convergence: 3913</span></div><div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;<span class="stringliteral">   Max norm of residual:                8.15689e-15</span></div><div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;<span class="stringliteral">@endcode</span></div><div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;<span class="stringliteral">* Quite a number of cells are used on the finest level to resolve the features ofthe solution. Here are the fourth and tenth grids:  &lt;div class=&quot;twocolumn&quot; style=&quot;width: 80%&quot;&gt;</span></div><div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;<span class="stringliteral">  &lt;div&gt;</span></div><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;<span class="stringliteral">    &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-9-grid-3.png&quot;</span></div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;<span class="stringliteral">         alt=&quot;Fourth grid in the refinement cycle, showing some adaptivity to features.&quot;</span></div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="stringliteral">         width=&quot;400&quot; height=&quot;400&quot;&gt;</span></div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;<span class="stringliteral">  &lt;/div&gt;</span></div><div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;<span class="stringliteral">  &lt;div&gt;</span></div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;<span class="stringliteral">    &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-9-grid-9.png&quot;</span></div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;<span class="stringliteral">         alt=&quot;Tenth grid in the refinement cycle, showing that the waves are fully captured.&quot;</span></div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="stringliteral">         width=&quot;400&quot; height=&quot;400&quot;&gt;</span></div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;<span class="stringliteral">  &lt;/div&gt;</span></div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;<span class="stringliteral">&lt;/div&gt;  and the fourth and tenth solutions:  &lt;div class=&quot;twocolumn&quot; style=&quot;width: 80%&quot;&gt;</span></div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;<span class="stringliteral">  &lt;div&gt;</span></div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;<span class="stringliteral">    &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-9-solution-3.png&quot;</span></div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;<span class="stringliteral">         alt=&quot;Fourth solution, showing that we resolve most features but some</span></div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;<span class="stringliteral">         are sill unresolved and appear blury.&quot;</span></div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;<span class="stringliteral">         width=&quot;400&quot; height=&quot;400&quot;&gt;</span></div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;<span class="stringliteral">  &lt;/div&gt;</span></div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;<span class="stringliteral">  &lt;div&gt;</span></div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="stringliteral">    &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-9-solution-9.png&quot;</span></div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;<span class="stringliteral">         alt=&quot;Tenth solution, showing a fully resolved flow.&quot;</span></div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;<span class="stringliteral">         width=&quot;400&quot; height=&quot;400&quot;&gt;</span></div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="stringliteral">  &lt;/div&gt;</span></div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;<span class="stringliteral">&lt;/div&gt;  and both the grid and solution zoomed in:  &lt;div class=&quot;twocolumn&quot; style=&quot;width: 80%&quot;&gt;</span></div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;<span class="stringliteral">  &lt;div&gt;</span></div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;<span class="stringliteral">    &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-9-solution-3-zoom.png&quot;</span></div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="stringliteral">         alt=&quot;Detail of the fourth solution, showing that we resolve most</span></div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;<span class="stringliteral">         features but some are sill unresolved and appear blury. In particular,</span></div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="stringliteral">         the larger cells need to be refined.&quot;</span></div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="stringliteral">         width=&quot;400&quot; height=&quot;400&quot;&gt;</span></div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="stringliteral">  &lt;/div&gt;</span></div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="stringliteral">  &lt;div&gt;</span></div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="stringliteral">    &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-9-solution-9-zoom.png&quot;</span></div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="stringliteral">         alt=&quot;Detail of the tenth solution, showing that we needed a lot more</span></div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;<span class="stringliteral">         cells than were present in the fourth solution.&quot;</span></div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="stringliteral">         width=&quot;400&quot; height=&quot;400&quot;&gt;</span></div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="stringliteral">  &lt;/div&gt;</span></div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;<span class="stringliteral">&lt;/div&gt;  </span></div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;<span class="stringliteral">* The solution is created by that part that is transported along the wigglyadvection field from the left and lower boundaries to the top right, and thepart that is created by the source in the lower left corner, and the results ofwhich are also transported along. The grid shown above is well-adapted toresolve these features. The comparison between plots shows that, even though weare using a high-order approximation, we still need adaptive mesh refinement tofully resolve the wiggles.</span></div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;<span class="stringliteral">* &lt;a name=&quot;PlainProg&quot;&gt;&lt;/a&gt;&lt;h1&gt; The plain program&lt;/h1&gt;  @include &quot;step-9.cc&quot;  </span></div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="stringliteral">*</span></div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;<span class="stringliteral">*/</span></div><div class="ttc" id="group__feaccess_html_ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdoc">Shape function values. </div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00062">fe_update_flags.h:62</a></div></div>
<div class="ttc" id="classTriangulation_html_a5ea5c9957dbb566a562bbe2c0f3971e9"><div class="ttname"><a href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells</a></div><div class="ttdeci">unsigned int n_active_cells() const</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l12645">tria.cc:12645</a></div></div>
<div class="ttc" id="classDoFHandler_html_a7797f796c0be511fbc7f230ccc22532e"><div class="ttname"><a href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">DoFHandler::get_triangulation</a></div><div class="ttdeci">const Triangulation&lt; dim, spacedim &gt; &amp; get_triangulation() const</div></div>
<div class="ttc" id="group__MeshWorker_html_gad10f528ab87f39fbb0531d24f238b2f3"><div class="ttname"><a href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop</a></div><div class="ttdeci">void loop(ITERATOR begin, typename identity&lt; ITERATOR &gt;::type end, DOFINFO &amp;dinfo, INFOBOX &amp;info, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, ASSEMBLER &amp;assembler, const LoopControl &amp;lctrl=LoopControl())</div><div class="ttdef"><b>Definition:</b> <a href="loop_8h_source.html#l00449">loop.h:449</a></div></div>
<div class="ttc" id="symmetric__tensor_8h_html_a31fa20712aae4f3b8ab9f62729b464d3"><div class="ttname"><a href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a></div><div class="ttdeci">constexpr Number determinant(const SymmetricTensor&lt; 2, dim, Number &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="symmetric__tensor_8h_source.html#l02497">symmetric_tensor.h:2497</a></div></div>
<div class="ttc" id="structDataOutBase_1_1VtkFlags_html"><div class="ttname"><a href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a></div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8h_source.html#l00871">data_out_base.h:871</a></div></div>
<div class="ttc" id="classDataOutInterface_html_ac7280a24690b117454acfb0fa058299c"><div class="ttname"><a href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">DataOutInterface::set_flags</a></div><div class="ttdeci">void set_flags(const FlagType &amp;flags)</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08210">data_out_base.cc:8210</a></div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">LAPACKSupport::matrix</a></div><div class="ttdoc">Contents is actually a matrix. </div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00060">lapack_support.h:60</a></div></div>
<div class="ttc" id="namespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
<div class="ttc" id="classVector_html"><div class="ttname"><a href="classVector.html">Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="mapping__q1__eulerian_8h_source.html#l00033">mapping_q1_eulerian.h:33</a></div></div>
<div class="ttc" id="classGridOut_html_a8bd3a74b86d7c0eb792d2efca7f945f1"><div class="ttname"><a href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">GridOut::write_vtu</a></div><div class="ttdeci">void write_vtu(const Triangulation&lt; dim, spacedim &gt; &amp;tria, std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l03591">grid_out.cc:3591</a></div></div>
<div class="ttc" id="namespaceinternal_html_aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804"><div class="ttname"><a href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">internal::EvaluatorQuantity::value</a></div></div>
<div class="ttc" id="classDoFHandler_html_a7b510a66ee9ea25720f64220496126ec"><div class="ttname"><a href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">DoFHandler::end</a></div><div class="ttdeci">cell_iterator end() const</div><div class="ttdef"><b>Definition:</b> <a href="dof__handler_8cc_source.html#l02241">dof_handler.cc:2241</a></div></div>
<div class="ttc" id="classDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="structDataOutBase_1_1VtkFlags_html_a3be0d6de1c92b770e8664bce2fc7c107"><div class="ttname"><a href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">DataOutBase::VtkFlags::compression_level</a></div><div class="ttdeci">ZlibCompressionLevel compression_level</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8h_source.html#l00930">data_out_base.h:930</a></div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_aceda56512460bbad2f9fdb8a3d0e1e51"><div class="ttname"><a href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">LAPACKSupport::one</a></div><div class="ttdeci">static const types::blas_int one</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00198">lapack_support.h:198</a></div></div>
<div class="ttc" id="group__feaccess_html_ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdoc">Transformed quadrature points. </div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00097">fe_update_flags.h:97</a></div></div>
<div class="ttc" id="group__Exceptions_html_gafc0ca7ad85b3ebd64e8e51689ac85caf"><div class="ttname"><a href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a></div><div class="ttdeci">#define AssertThrow(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01519">exceptions.h:1519</a></div></div>
<div class="ttc" id="grid__out_8cc_html_a2cc229a4f1ffc75e83ed269d5f725729"><div class="ttname"><a href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="ttdeci">Point&lt; 2 &gt; second</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04588">grid_out.cc:4588</a></div></div>
<div class="ttc" id="namespaceWorkStream_html"><div class="ttname"><a href="namespaceWorkStream.html">WorkStream</a></div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l00079">work_stream.h:79</a></div></div>
<div class="ttc" id="classDoFHandler_html_ac1fedeb50b5f03b13d8b69f86e33f726"><div class="ttname"><a href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">DoFHandler::get_fe</a></div><div class="ttdeci">const FiniteElement&lt; dim, spacedim &gt; &amp; get_fe(const unsigned int index=0) const</div></div>
<div class="ttc" id="classPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; dim &gt;</a></div></div>
<div class="ttc" id="namespaceparallel_html"><div class="ttname"><a href="namespaceparallel.html">parallel</a></div><div class="ttdef"><b>Definition:</b> <a href="doc_2doxygen_2headers_2distributed_8h_source.html#l00150">distributed.h:150</a></div></div>
<div class="ttc" id="namespacePhysics_1_1Elasticity_1_1Kinematics_html_a09916360abaee5f1fb31994dbc96787b"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">Physics::Elasticity::Kinematics::C</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; C(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
<div class="ttc" id="structGeometryInfo_html"><div class="ttname"><a href="structGeometryInfo.html">GeometryInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="geometry__info_8h_source.html#l01515">geometry_info.h:1515</a></div></div>
<div class="ttc" id="classDoFHandler_html_a1a36dbbb4c54a7038c60ee9c8eab369a"><div class="ttname"><a href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active</a></div><div class="ttdeci">active_cell_iterator begin_active(const unsigned int level=0) const</div><div class="ttdef"><b>Definition:</b> <a href="dof__handler_8cc_source.html#l02225">dof_handler.cc:2225</a></div></div>
<div class="ttc" id="namespaceThreads_1_1internal_html_a8d237a30d09b13e0b5adbe0fd1dfb188"><div class="ttname"><a href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">Threads::internal::call</a></div><div class="ttdeci">void call(const std::function&lt; RT()&gt; &amp;function, internal::return_value&lt; RT &gt; &amp;ret_val)</div><div class="ttdef"><b>Definition:</b> <a href="thread__management_8h_source.html#l00346">thread_management.h:346</a></div></div>
<div class="ttc" id="namespaceUtilities_html_a6155277fd058eddb1504f9562cb1c04d"><div class="ttname"><a href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">Utilities::compress</a></div><div class="ttdeci">std::string compress(const std::string &amp;input)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00392">utilities.cc:392</a></div></div>
<div class="ttc" id="namespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a></div><div class="ttdef"><b>Definition:</b> <a href="evaluation__flags_8h_source.html#l00059">evaluation_flags.h:59</a></div></div>
<div class="ttc" id="namespaceUtilities_1_1MPI_html_ab544a3bf3301a6dd3e705ee352c5551b"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a></div><div class="ttdeci">T sum(const T &amp;t, const MPI_Comm &amp;mpi_communicator)</div></div>
<div class="ttc" id="group__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01415">exceptions.h:1415</a></div></div>
<div class="ttc" id="namespaceinternal_html_aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c"><div class="ttname"><a href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">internal::EvaluatorQuantity::gradient</a></div></div>
<div class="ttc" id="namespaceTrilinosWrappers_1_1internal_html_aee42c8e3004e2e81eac3c3356d3ec46b"><div class="ttname"><a href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">TrilinosWrappers::internal::end</a></div><div class="ttdeci">VectorType::value_type * end(VectorType &amp;V)</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix_8cc_source.html#l00067">trilinos_sparse_matrix.cc:67</a></div></div>
<div class="ttc" id="namespacePatterns_1_1Tools_html_a72743302dcb1a0fb1f2f8dc5122d299e"><div class="ttname"><a href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">Patterns::Tools::to_string</a></div><div class="ttdeci">std::string to_string(const T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l02231">patterns.h:2231</a></div></div>
<div class="ttc" id="classDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="data__out__dof__data_8h_source.html#l00902">data_out_dof_data.h:902</a></div></div>
<div class="ttc" id="classGridOut_html"><div class="ttname"><a href="classGridOut.html">GridOut</a></div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8h_source.html#l00979">grid_out.h:979</a></div></div>
<div class="ttc" id="classDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="classSymmetricTensor_html_a7c03a03a5fe823733e7af9f7e4267f81"><div class="ttname"><a href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">SymmetricTensor::determinant</a></div><div class="ttdeci">constexpr Number determinant(const SymmetricTensor&lt; 2, dim, Number &gt; &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="symmetric__tensor_8h_source.html#l02497">symmetric_tensor.h:2497</a></div></div>
<div class="ttc" id="grid__out_8cc_html_a827a345f29da7caeb588b11013869a01"><div class="ttname"><a href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="ttdeci">Point&lt; 2 &gt; first</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04587">grid_out.cc:4587</a></div></div>
<div class="ttc" id="namespaceAlgorithms_1_1Events_html_a15a12dfdadd39a026d192ad96cb6207b"><div class="ttname"><a href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">Algorithms::Events::initial</a></div><div class="ttdeci">const Event initial</div><div class="ttdef"><b>Definition:</b> <a href="event_8cc_source.html#l00065">event.cc:65</a></div></div>
<div class="ttc" id="classTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, dim &gt;</a></div></div>
<div class="ttc" id="classDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="classDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler&lt; dim &gt;</a></div></div>
<div class="ttc" id="classVector_html_a81dcfa5c77bdd426603386c0844149ae"><div class="ttname"><a href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">Vector::size</a></div><div class="ttdeci">size_type size() const</div></div>
<div class="ttc" id="namespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="classFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00039">fe.h:39</a></div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_a45557450a3c1ae0e74d7ddf12c43bc98af25b68380698c53fa6da3e05379c0855"><div class="ttname"><a href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98af25b68380698c53fa6da3e05379c0855">LAPACKSupport::general</a></div><div class="ttdoc">No special properties. </div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00114">lapack_support.h:114</a></div></div>
<div class="ttc" id="data__out__base_8cc_html_a8188ef4709fc9a4cc076d37447783ba1"><div class="ttname"><a href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a></div><div class="ttdeci">Point&lt; 3 &gt; center</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l00170">data_out_base.cc:170</a></div></div>
<div class="ttc" id="namespaceWorkStream_html_ab8ceb010811941c351803b671a19fb73"><div class="ttname"><a href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a></div><div class="ttdeci">void run(const std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;colored_iterators, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l01151">work_stream.h:1151</a></div></div>
<div class="ttc" id="namespaceOpenCASCADE_html_a9509efa83e3b2fa42616fe0623cba696"><div class="ttname"><a href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">OpenCASCADE::point</a></div><div class="ttdeci">Point&lt; spacedim &gt; point(const gp_Pnt &amp;p, const double tolerance=1e-10)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00188">utilities.cc:188</a></div></div>
<div class="ttc" id="namespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a></div><div class="ttdef"><b>Definition:</b> <a href="evaluation__flags_8h_source.html#l00054">evaluation_flags.h:54</a></div></div>
<div class="ttc" id="symmetric__tensor_8h_html_a3656e2f6095f612536b06139a6a2ca39"><div class="ttname"><a href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a></div><div class="ttdeci">constexpr SymmetricTensor&lt; 2, dim, Number &gt; invert(const SymmetricTensor&lt; 2, dim, Number &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="symmetric__tensor_8h_source.html#l03289">symmetric_tensor.h:3289</a></div></div>
<div class="ttc" id="p4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
<div class="ttc" id="classTensor_html_afd0934b4edd71063f66a9c67540e79fc"><div class="ttname"><a href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">Tensor::norm</a></div><div class="ttdeci">numbers::NumberTraits&lt; Number &gt;::real_type norm() const</div></div>
<div class="ttc" id="classDataOutInterface_html_a93c780f93105e0daaa76c6c43694b4ae"><div class="ttname"><a href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu</a></div><div class="ttdeci">void write_vtu(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07232">data_out_base.cc:7232</a></div></div>
<div class="ttc" id="namespaceinternal_1_1VectorOperations_html_a40c8daa0881cff0123fbaeb08929f5cb"><div class="ttname"><a href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">internal::VectorOperations::copy</a></div><div class="ttdeci">void copy(const T *begin, const T *end, U *dest)</div><div class="ttdef"><b>Definition:</b> <a href="vector__operations__internal_8h_source.html#l00069">vector_operations_internal.h:69</a></div></div>
<div class="ttc" id="namespaceGridRefinement_html_a1cf30058b31ce7f9b389e8310bb9fc54"><div class="ttname"><a href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">GridRefinement::refine</a></div><div class="ttdeci">void refine(Triangulation&lt; dim, spacedim &gt; &amp;tria, const Vector&lt; Number &gt; &amp;criteria, const double threshold, const unsigned int max_to_mark=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00168">grid_refinement.cc:168</a></div></div>
<div class="ttc" id="namespaceinternal_1_1p4est_html_a4b980c7b4b4d9984e93d73c7d30173ea"><div class="ttname"><a href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">internal::p4est::functions</a></div><div class="ttdeci">int(&amp;) functions(const void *v1, const void *v2)</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00339">p4est_wrappers.cc:339</a></div></div>
<div class="ttc" id="namespaceWorkStream_1_1internal_1_1tbb__no__coloring_html_a8673698a405bf47aa24002aeb6d76d70"><div class="ttname"><a href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WorkStream::internal::tbb_no_coloring::run</a></div><div class="ttdeci">void run(const Iterator &amp;begin, const typename identity&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l00562">work_stream.h:562</a></div></div>
<div class="ttc" id="classFEFaceValues_html"><div class="ttname"><a href="classFEFaceValues.html">FEFaceValues</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00041">fe.h:41</a></div></div>
<div class="ttc" id="classFEValues_html_a21f914e63d588e2652a9514620653d77"><div class="ttname"><a href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a></div><div class="ttdeci">void reinit(const TriaIterator&lt; DoFCellAccessor&lt; dim, spacedim, level_dof_access &gt;&gt; &amp;cell)</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8cc_source.html#l04515">fe_values.cc:4515</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
