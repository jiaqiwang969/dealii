<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/DEALGlossary.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Glossary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Glossary </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>本词汇表解释了一些在deal.II的类文件中经常使用的术语。词汇表通常只给出了一个特定概念的微观观点；如果你对大局感到困惑，那么也值得参考 <a class="el" href="index.html">index</a> 页上的类的总体概述。 </p><dl>
<dt class="glossary"><a class="anchor" id="GlossActive"></a><b>Active cells</b> </dt>
<dd><p class="startdd">如果一个单元格、面或边没有被进一步细化，即没有子代，那么它被定义为<em>active</em>。一旦一个单元、面或边成为父级，它就不再活跃。除非使用多网格算法，否则活动单元是唯一携带自由度的单元。 </p>
<p>人工单元的概念对于在每个处理器上存储整个网格的三角计算没有意义，即 <a class="el" href="classTriangulation.html">Triangulation</a> 类。 </p>
<p class="enddd"></p>
</dd>
<dt class=" glossary"><a class="anchor" id="GlossBlockLA"></a><b>Block (linear algebra)</b>。 </dt>
<dd><p class="startdd">将一个矩阵或向量作为单个块的集合来处理往往很方便。例如，在 <a class="el" href="step_20.html">step-20</a> （和其他教程程序）中，我们要考虑全局线性系统 \(Ax=b\) 的形式 </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} M &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> 。 其中 \(U,P\) 分别是速度和压力自由度的值， \(M\) 是速度空间上的质量矩阵， \(B\) 对应于负发散算子， \(B^T\) 是其转置，对应于负梯度。 使用这种分解为块的方法，人们可以定义基于方程组中存在的单个算子（例如，在 <a class="el" href="step_20.html">step-20</a> 的情况下，Schur补码）的预处理程序，而不是整个矩阵。实质上，块被用来反映线性代数中PDE系统的结构，特别是允许对具有多个解决方案组件的问题进行模块化求解。另一方面，矩阵和右手边的向量也可以作为一个单元来处理，这在线性系统的装配过程中是很方便的，例如，当人们可能不想对各个组件进行区分时，或者对于不关心块结构的外Krylov空间求解器（例如，如果只有预处理程序需要块结构）。 将矩阵和向量分割成块是由BlockSparseMatrix、BlockVector和相关类支持的。参见 <a class="el" href="group__LAC.html">Linear algebra classes</a> 模块中对各种线性代数类的概述。这些对象呈现出两个接口：一个使对象看起来像一个具有全局索引操作的矩阵或向量，另一个使对象看起来像一个可以被单独处理的子块的集合。根据上下文，人们可能希望使用一个或另一个接口。 通常，人们通过将构成物理量组的自由度（例如所有速度）归入线性系统的各个块来定义矩阵或向量的子结构。这在下面关于 <a class="el" href="DEALGlossary.html#GlossBlock">块（有限元）</a> 的词汇条中有更详细的定义。 </p>
<p>对于离散化的目的，块是更好的概念，因为并不总是能够解决一个解决方案的各个组成部分。特别是对于非 原始  元素来说，就是这种情况。以使用FE_RaviartThomas元素的混合拉普拉斯系统的解为例（见 <a class="el" href="step_20.html">step-20</a> ）。在那里，第一个<code>dim</code>分量是方向性速度。由于形状函数是这些的线性组合，这些<code>dim</code>分量只构成一个单一的块。另一方面，压力变量是标量，将构成第二个块，但在<code>dim+1</code>st分量中。 每个块的最小尺寸由底层有限元决定（对于标量元素，一个块由一个分量组成，但以FE_RaviartThomas为例，一个块由<code>dim</code>分量组成）。然而，几个这样的最小块可以随意组合成用户定义的块，并根据应用情况进行组合。例如，对于<b>Q</b><sub>2</sub><sup><em>d</em></sup>-<b>Q</b><sub>1</sub>（Taylor-Hood）Stokes元素，有<em>d</em>+1个组件，原则上每个组件可以形成自己的块。但我们通常更感兴趣的是只有两个块，其中一个由所有的速度矢量分量组成（即这个块将有<em>d</em>分量），另一个只有一个压力分量。 <em>Implementation:</em> deal.II有许多不同的有限元类，它们都是从FiniteElement基类派生出来的（见 <a class="el" href="group__feall.html">有限元类模块</a> ）。除了一个例外，无论它们是标量还是矢量值，它们都定义了一个单一的块：有限元通过其 <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components()</a> 函数定义的所有矢量分量构成一个单一的块，即 <a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElement::n_blocks()</a> 返回一个。 例外的是FESystem类，它采取多个较简单的元素，并将它们连接成较复杂的元素。因此，它可以有一个以上的块。一个FESystem有多少个块，就有多少个基础元素乘以它们的倍数（参见FESystem的构造函数来理解这个说法）。换句话说，它并不关心每个基础元素有多少个块，因此，你可以通过创建对象产生一个只有两个块的斯托克斯元素 </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div></div><!-- fragment --><p> 另一方面，我们可以用dim+1块产生一个类似的对象，使用 </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div></div><!-- fragment --><p> 除了块的数量外，这两个对象在所有实际用途上都是一样的，但是。 <em>Global degrees of freedom:</em> 虽然我们在上面用矢量值解函数的矢量分量（或者，等同于用矢量值有限元空间）来定义块，但有限元的每个形状函数都是一个或另一个块的一部分。因此，我们可以将定义在DoFHandler上的所有自由度划分为各个块。由于默认情况下DoFHandler类以一种或多或少的随机方式列举自由度，你首先要调用 <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> 函数以确保所有对应于单个块的自由度被连续列举。 关于这个主题的更多信息可以在FESystem的文档中找到， <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块和其中参考的教程程序。 <em>Selecting blocks:</em> 许多函数允许你将其操作限制在某些矢量分量或块上。例如，插值边界值的函数就是这种情况：人们可能只想插值有限元场的速度块的边界值，而不想插值压力块。这样做的方法是给这类函数传递一个BlockMask参数，见 <a class="el" href="DEALGlossary.html#GlossBlockMask">本词汇表的block mask条目</a> 。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlockMask"></a><b>Block mask</b>&lt;/dt </dt>
<dd><p class="startdd">就像人们可以认为元素是由物理矢量分量（见 <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a> ）或逻辑块（见 <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a> ）组成的一样，经常需要为不打算在有限元空间的<em>all</em>块上运行的操作选择一组此类块。使用BlockMask类来选择要操作的块。 块掩码的工作方式与构件掩码基本相同，包括BlockMask类与ComponentMask类有类似的语义。参见 <a class="el" href="DEALGlossary.html#GlossComponentMask">关于组件掩码的词汇表条目 </a> 以获得更多信息。</p>
<dl class="section note"><dt>Note</dt><dd>虽然组件和块为具有多个向量分量的有限元提供了两种交替但同样有效的观点，但事实上，在整个库中，你可以传递ComponentMask参数而不是BlockMask参数的地方要多得多。幸运的是，一个可以转换为另一个，使用的语法 <code>fe.component_mask(block_mask)</code> where <code>block_mask</code> 是BlockMask类型的一个变量。换句话说，如果你有一个块掩码，但需要调用一个只接受组件掩码的函数，可以用这种语法来获得必要的组件掩码。 <b>Creation of block masks:</b> 块掩码通常是通过要求有限元从某些选定的矢量分量中生成块掩码来创建的，使用这样的代码，我们创建的掩码只表示斯托克斯元的速度分量（见 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> ）。 <div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1),                     1);     <span class="comment">// Q1 element for the pressure</span></div><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (pressure);</div></div><!-- fragment --> 结果是一个区块掩码，在1d以及2d和3d中，其值为 <code>[false, true]</code> 。同样地，使用 <div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> velocity_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (velocities);</div></div><!-- fragment --> 在任何维度上都会产生一个掩码 <code>[true, false]</code> 。 然而，请注意，如果我们以下列方式定义有限元。 <div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div></div><!-- fragment --> 那么代码 <div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (pressure);</div></div><!-- fragment --> 将产生一个块掩码，在2d中具有元素 <code>[false, false, true]</code> ，因为该元素具有 <code>dim+1</code> 成分和同样多的块。参见 <a class="el" href="DEALGlossary.html#GlossBlock">本词汇表的块条目 </a> 中关于块具体代表什么的讨论。 </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBoundaryForm"></a><b>Boundary form</b>&lt;/dt </dt>
<dd>对于二维空间中的二维三角，边界形式是一个定义在面的向量。它是单元格表面上坐标向量的图像的向量乘积。它是一个对表面的法线矢量，指向外侧，具有表面元素的长度。 一个更普遍的定义是（至少到这个矢量的长度为止），它正是考虑分项积分时必须的那个矢量，即形式为 \(\int_\Omega \text{div} \vec \phi = -\int_{\partial\Omega} \vec n \cdot \vec \phi\) 的等式。使用这个定义也解释了在嵌入空间 <code>spacedim</code> 的维数 <code>dim</code> 的域（和相应的三角形）的情况下，这个向量应该是什么：在这种情况下，边界形式仍然是一个定义在三角形面上的向量；它与边界的所有切线方向正交，并且在域的切线平面内。请注意，这与情况 <code>dim==spacedim</code> 是兼容的，因为那里的切平面是整个空间 \({\mathbb R}^\text{dim}\) 。 在任何一种情况下，矢量的长度都等于参考面到当前单元面的变换行列式。  </dd>
<dt class=" glossary"><a class="anchor" id="GlossBoundaryIndicator"></a><b>Boundary indicator</b>。 </dt>
<dd><p class="startdd">在Triangulation对象中，边界的每一部分都可以与一个唯一的数字（类型为 <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) ，用于确定哪种边界条件将被应用到边界的特定部分。边界是由单元格的面组成的，在三维中，是这些面的边缘。 默认情况下，一个网格的所有边界指标都是零，除非你从一个网格文件中读取，并特别将其设置为不同的内容，或者你使用了命名空间GridGenerator中的一个网格生成函数，该函数有一个 <a class="el" href="DEALGlossary.html#GlossColorization">着色 </a> 选项。一个典型的将部分边界指示器设置为其他东西的代码会是这样的，这里将所有位于 \(x=-1\) 的面的边界指示器设置为42。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_face_iterators())</div><div class="line">  <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;center()[0] ==</div><div class="line"></div><div class="line">-1)</div><div class="line">      face-&gt;set_boundary_id (42);</div></div><!-- fragment --><p> 这调用了函数 <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">TriaAccessor::set_boundary_id</a>. 在3D中，可能也适合调用 <a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">TriaAccessor::set_all_boundary_ids</a> 来代替每个选定的面。要查询某个特定面或边的边界指标，请使用 <a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">TriaAccessor::boundary_id</a>. 。 DoFTools和VectorTools命名空间中的许多函数都需要参数来指定边界的哪一部分，而且它们特别提到了boundary_ids。例如 <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a>, <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>, <a class="el" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a> 和 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>. 。</p>
<dl class="section note"><dt>Note</dt><dd>边界指标在网格细化时从母面和边继承到子面。关于边界指示器的更多信息，也在三角形类的文档中的一个部分介绍。</dd>
<dd>
对于 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 类型的平行三角形，仅在开始时设置一次边界指标是不够的。参见 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 的类文件中关于这个主题的长篇讨论。 </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCoarseMesh"></a><b>Coarse mesh</b> </dt>
<dd><p class="startdd">deal.II中的 "粗网格
"是一个三角形对象，它只由未被细化的单元组成，也就是说，在这个网格中没有单元是另一个单元的孩子。这通常是deal.II中最初构建三角形的方式，例如，使用命名空间GridGenerator中的（大部分）函数，GridIn类中的函数，或者直接使用函数 <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a>. 当然，我们可以在这样的网格上进行计算，但大多数时候（例如，参见几乎所有的教程程序），我们首先要全局地细化粗略的网格（使用 <a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global()</a>), 或自适应地细化（在这种情况下，首先计算一个细化准则，然后计算命名空间GridRefinement中的一个函数，最后调用 <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a>). ），然后网格就不再是 "粗网格"，而是 "细化网格"。 三角形对象以<em>levels</em>的方式存储单元：特别是，粗网格的所有单元都在零层。他们的子单元（如果我们在粗网格上执行 <code>Triangulation::refine_global(1)</code> ）将在第一层，等等。三角形的粗网格（在上一段的意义上）正好由三角形的零级单元组成。(它们是否处于活动状态(即没有子代)或已被细化，对这个定义并不重要)。</p>
<p>在这些情况下，在算法中经常需要唯一地引用一个粗略的网格单元。因为当前进程中的三角剖分对象实际上并没有存储整个粗网格，所以我们需要为每个粗网格单元设置一个全局唯一的标识符，这个标识符与本地存储的三角剖分零级中的索引无关。这个全局唯一的ID被称为 "粗略单元ID"。它可以通过以下函数调用来访问 </p><div class="fragment"><div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.coarse_cell_index_to_coarse_cell_id (coarse_cell-&gt;index());</div></div><!-- fragment --><p> 其中<code>triangulation</code>是指向零级单元的迭代器<code>coarse_cell</code>所属的三角结构。这里，<code>coarse_cell-&gt;index()</code>返回该单元在其细化层次中的索引（见 <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">TriaAccessor::index()</a>). 这是一个介于零和并行计算中当前进程上存储的粗网格单元数量之间的数字；它唯一地标识了该并行进程上的一个单元，但不同的并行进程可能对位于不同坐标的不同单元使用该索引。 对于那些在每个进程上存储所有粗略网格单元的类， <a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">Triangulation::coarse_cell_index_to_coarse_cell_id()</a> 只是返回可能的参数值的排列组合。在最简单的情况下，例如对于一个顺序的或并行的共享三角形，该函数实际上将简单地返回参数的值。对于其他情况，如 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, ，粗略单元ID的排序与粗略单元索引的排序不一样。最后，对于诸如 <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>, 这样的类，该函数返回全局唯一的ID，它来自一个更大的可能指数集，而不是实际存储在当前进程上的粗放单元的指数。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossColorization"></a><b>Colorization</b> </dt>
<dd><p class="startdd"><em> Colorization </em> 是用不同的标签标记三角图的某些部分的过程。颜色 <em> 一词的使用来自制图学，即通过给地图上的国家分配不同的颜色，使它们在视觉上相互区别。使用相同的术语 <em> 着色 </em> 在数学中很常见，尽管我们给不同的区域分配整数而不是色调。交易.II将两个过程称为着色。 </p><ol>
<li>
GridGenerator命名空间中的大多数函数都采取一个可选的参数 <code>colorize</code> 。这个参数控制边界的不同部分是否会被分配不同的 <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">边界指标</a>。 一些函数也会分配不同的 <a class="el" href="DEALGlossary.html#GlossMaterialId">材料指标</a>。  </li>
<li>
函数 <a class="el" href="namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">GraphColoring::make_graph_coloring()</a> 计算一个三角形的分解（更确切地说，是一个迭代器的范围）。没有两个相邻的单元被赋予相同的颜色。  </li>
</ol>
<p>。</em></p>
<p class="enddd"><em> </em></p>
</dd>
<dt class=" glossary"><a class="anchor" id="GlossComponent"></a><b>Component</b>。 </dt>
<dd><p class="startdd"><em> 当考虑方程组时，其中的解不仅仅是一个单一的标量函数，我们说我们有一个<em>vector system</em>与一个<em>vector-valued solution</em>。例如，在 <a class="el" href="step_8.html">step-8</a> 中考虑的弹性方程的矢量解是 \(u=(u_x,u_y,u_z)^T\) ，由三个坐标方向上的位移组成。然后，该解决方案有三个元素。同样， <a class="el" href="step_22.html">step-22</a> 中考虑的三维斯托克斯方程有四个元素。 \(u=(v_x,v_y,v_z,p)^T\) .我们在交易二中称矢量值解的元素为<em>components</em>。为了得到良好的解决，对于解有 \(n\) 个元素，需要有 \(n\) 个偏微分方程来描述它们。这个概念在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中讨论得很详细。 在有限元程序中，人们经常想解决这个矢量值解决方案的单个元素（组件），或组件的集合。例如，我们在 <a class="el" href="step_8.html">step-8</a> 中做了大量的工作，在 <a class="el" href="group__vector__valued.html">处理矢量值问题 </a> 模块中也提供了大量的文档。如果你只考虑偏微分方程（而不是其离散化），那么<em>components</em>的概念是自然的。 对于一个给定的有限元，可以使用 <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElementData::n_components()</a> 函数查询组件的数量，可以使用 <a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">FiniteElement::get_nonzero_components()</a>. 找出对于一个给定的有限元形状函数，哪些向量组件是非零的。 形状函数的各个组件的值和梯度（如果元素是原始的）可以使用参考单元上的 <a class="el" href="classFiniteElement.html#a247fccbd72723a07fc8c17ac093d3156">FiniteElement::shape_value_component()</a> 和 <a class="el" href="classFiniteElement.html#a7f026ed19fcc589476f11d69de4a3419">FiniteElement::shape_grad_component()</a> 函数查询。 <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">FEValues::shape_value_component()</a> 和 <a class="el" href="classFEValuesBase.html#a71e93aa182f3acd34abd020538f3bc39">FEValues::shape_grad_component()</a> 函数在实数单元上做同样的事情。也请参见FiniteElement和FEValues类的文档。 <em>Selecting components:</em> 许多函数允许你将其操作限制在某些向量组件或块上。例如，插值边界值的函数就是这种情况：人们可能只想插值一个有限元场的速度分量的边界值，而不想插值压力分量。这样做的方法是给这类函数传递一个ComponentMask参数，见 <a class="el" href="DEALGlossary.html#GlossComponentMask">本词汇表的组件掩码条目</a> 。 </em></p>
<p class="enddd"><em> </em></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossComponentMask"></a><b>Component mask</b>。 </dt>
<dd><p class="startdd"><em> 当使用矢量值元素（见 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> ）来解决方程组时，人们经常希望将一些操作限制在只有某些解决变量。例如，在求解斯托克斯方程时，人们可能希望只插值速度分量的边界值而不插值压力。在deal.II中，这通常是通过传递函数a&lt;i&gt;component mask</em>完成的。分量掩码总是被指定为ComponentMask对象，我们可以把它看作一个数组，其条目数与有限元的分量一样多（例如，在Stokes情况下，有 <code>dim+1</code> 个分量），每个条目要么为真，要么为假。在这个例子中，我们只想插值斯托克斯系统的速度分量的边界值，那么这个分量掩码将是 <code>[true, true, false]</code> in 2d and <code>[true, true, true, false]</code> ，在3D中表示不应设置压力变量的边界值（解决方案中的最后一个 <code>dim+1</code> 矢量分量。 有许多函数采取这样的分量掩码，例如 DoFTools::make_zero_boundary_values, <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, <a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator::estimate</a>, 等。在某些情况下，有多个具有这些名称的函数，但只有其中一些具有分量掩码参数。 <b>Semantics of component masks:</b> 许多函数，接受一个已经默认构建的分量掩码对象，表示<em>all components</em>，也就是说，就像向量有正确的长度，并且只填充了 <code>true</code> 值。原因是默认初始化的对象可以使用代码片断 <code><a class="el" href="classComponentMask.html">ComponentMask()</a></code> 来构建到位，因此可以在函数签名中作为默认参数使用。 换句话说，ComponentMask对象可以处于两种状态中的一种。它们可以被一个非零长度的布尔运算向量初始化；在这种情况下，它们代表一个特定长度的掩码，其中一些元素可能是真，另一些可能是假。或者，ComponentMask可能已经被默认初始化了（使用默认构造函数），在这种情况下，它代表了一个长度不确定的数组（即适合这种情况的长度），其中<em>every entry</em>为真。 <b>Creation of component masks:</b> 分量掩码通常是通过要求有限元从某些选定的分量中生成一个分量掩码来创建的，使用这样的代码，我们创建一个掩码，只表示斯托克斯元的速度分量（见 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> ）。 </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> pressure_mask = stokes_fe.component_mask (pressure);</div></div><!-- fragment --><p> 结果是一个组件掩码，在2d中，它的值是 <code>[false, false, true]</code> 。同样地，使用 </p><div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> velocity_mask = stokes_fe.component_mask (velocities);</div></div><!-- fragment --><p> 在2d中会产生一个掩码 <code>[true, true, false]</code> 。当然，在3D中，结果将是 <code>[true, true, true, false]</code> 。</p>
<dl class="section note"><dt>Note</dt><dd>并非所有的组件掩码都有意义。例如，如果你有一个2D的FE_RaviartThomas对象，那么有一个 <code>[true, false]</code> 形式的元件掩码是没有任何意义的，因为你试图选择一个有限元的单个矢量元件，其中每个形状函数都有 \(x\) 和 \(y\) 速度。从本质上讲，虽然你当然可以创建这样的分量掩码，但你对它无能为力。 </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCompress"></a><b>Compressing distributed vectors and matrices</b> &lt;/td </dt>
<dd><p class="startdd">对于并行计算，deal.II使用PETScWrappers和TrilinosWrappers命名空间中定义的向量和矩阵类。当使用MPI在parallel中运行程序时，这些类只在当前处理器上存储一定数量的行或元素，而向量或矩阵的其余部分则存储在属于我们MPI宇宙的其他处理器上。当你组装线性系统时，这就出现了一定的问题：我们向矩阵和右手边的向量添加元素，这些元素可能在本地存储，也可能不在。有时，我们也可能只想<em>set</em>一个元素，而不是向其添加。 PETSc和Trilinos都允许添加或设置没有本地存储的元素。在这种情况下，他们将我们想要存储或添加的值写入缓存，我们需要调用其中一个函数 <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">TrilinosWrappers::VectorBase::compress()</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">TrilinosWrappers::SparseMatrix::compress()</a>, <a class="el" href="classPETScWrappers_1_1VectorBase.html#a6166fa37985a73755a2982af055f1a0a">PETScWrappers::VectorBase::compress()</a> 或 <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">PETScWrappers::MatrixBase::compress()</a> ，然后将缓存中的值运送到拥有应该被添加或写入的元素的MPI进程。由于MPI模型只允许从发送方发起通信（也就是说，它不是一个远程过程调用），这些函数是集体的，也就是说，它们需要被所有处理器调用。 然而，有一个障碍：PETSc和Trilinos都需要知道这些 <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> 函数调用的操作是适用于添加元素还是设置元素。 在某些情况下，并不是所有的处理器都在添加元素，例如，当使用一个非常 <a class="el" href="DEALGlossary.html#GlossCoarseMesh">GlossCoarseMesh</a> 的 "粗略（初始）网格 " 时，一个处理器并不拥有任何单元。出于这个原因，compress()需要一个VectorOperation类型的参数，它可以是::add，或者::insert。从7.3版本开始，这个参数对向量和矩阵是必须的。 简而言之，你需要在以下情况下调用compress()（而且只在这些情况下，虽然在其他情况下调用compress()只是花费一些性能）。 1.在你的矩阵和向量的汇编循环结束时。如果你直接写条目或者使用 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a>. 使用 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>. ，就需要这样做。 2.当你完成了对矩阵/向量中单个元素的设置，然后再进行其他操作（向元素添加，其他操作如缩放、求解、读取等）。使用 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>. 。 3.和2.一样，但用于向单个元素加值。使用 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>. 。 所有其他的操作，如缩放或添加向量，赋值，调用deal.II（VectorTools，AffineConstraints，...）或求解器都不需要调用compress()。 </p>
<dl class="section note"><dt>Note</dt><dd>压缩是一个只适用于向量的操作，其元素在一个并行的MPI宇宙中被一个且唯一的处理器拥有。它不适用于 <a class="el" href="DEALGlossary.html#GlossGhostedVector">有幽灵元素的向量</a> 。</dd></dl>
</dd>
<dt class=" glossary"><a class="anchor" id="GlossConcept"></a><b>Concepts in deal.II</b>。 </dt>
<dd><p class="startdd">在deal.II中，有几个地方我们要求模板中的类型与某个接口相匹配或以某种方式行事：这种约束在C++中被称为 <em> 概念 </em> 。更多信息请参见 <a class="el" href="group__Concepts.html">Concepts, or expectations on template parameters</a> 中的讨论和deal.II中的概念列表。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDimension"></a><b>Dimensions <code>dim</code> and <code>spacedim</code></b> &lt;/dt </dt>
<dd><p class="startdd">deal.II中的许多类和函数有两个模板参数， <code>dim</code> 和 <code>spacedim</code>. 一个例子是基本的Triangulation类。 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim=dim&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classTriangulation.html">Triangulation</a> {...};</div></div><!-- fragment --><p> 在所有这些上下文中，你看到<code>dim</code>和<code>spacedim</code>被引用，这些参数有以下含义。 </p><ul>
<li>
<code>dim</code> 表示网格的维度。例如，一个由线段组成的网格是一维的，因此对应于<code>dim==1</code>。由四边形组成的网格为<code>dim==2</code>，六面体的网格为<code>dim==3</code>。  </li>
<li>
<code>spacedim</code> 表示这种网格所在空间的维度。一般来说，一维网格生活在一维空间中，同样，二维和三维网格也是如此，它们将二维和三维领域细分。因此， <code>spacedim模板参数的默认值等于</code> <code>dim</code>. ，但情况并不一定如此。例如，我们可能想解决地球表面的沉积物迁移方程。在这种情况下，域是地球的二维表面（<code>dim==2</code>），它生活在三维坐标系中（<code>spacedim==3</code>）。  </li>
</ul>
<p>。 更一般地说，deal.II可以用来解决嵌入高维空间的<a href="https://en.wikipedia.org/wiki/Manifold">manifolds</a>上的偏微分方程。换句话说，这两个模板参数需要满足<code>dim &lt;= spacedim'，尽管在许多应用中，我们只需满足</code>dim == spacedim'。 按照几何学的惯例，我们说 "二维
"被定义为<code>spacedim-dim</code>。换句话说，一个由四边形组成的三角形，其坐标是三维的（我们将使用<code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code>对象）具有 "codimension one"。 这两个参数不一样的使用例子显示在 <a class="el" href="step_34.html">step-34</a> , <a class="el" href="step_38.html">step-38</a> , <a class="el" href="step_54.html">step-54</a> 。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDoF"></a><b>Degree of freedom</b>。 </dt>
<dd>术语 "自由度"（通常缩写为 "DoF"）在有限元界通常用来表示两个略有不同但相关的事情。首先是我们想把有限元解表示为形状函数的线性组合，形式为 \(u_h(\mathbf{x}) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf{x})\) 。这里， \(U_j\) 是一个膨胀系数的向量。因为我们还不知道它们的值（我们将计算它们作为线性或非线性系统的解），它们被称为 "未知数 "或 "自由度"。该术语的第二个含义可以解释如下。对有限元问题的数学描述通常是说，我们正在寻找一个满足某些方程组的有限维函数 \(u_h \in V_h\) （例如， \(a(u_h,\varphi_h)=(f,\varphi_h)\) 的所有测试函数 \(\varphi_h\in V_h\) ）。换句话说，我们在这里说的是，解决方案需要位于某个空间 \(V_h\) 中。然而，为了在计算机上实际解决这个问题，我们需要选择这个空间的一个基；这就是我们在上面用系数 \(U_j\) 展开 \(u_h(\mathbf x)\) 时使用的形状函数 \(\varphi_j(\mathbf{x})\) 的集合。当然，空间 \(V_h\) 的基数有很多，但我们将特别选择由传统上在网格单元上局部定义的有限元函数描述的基数。在这种情况下描述 "自由度 "需要我们简单地 <em>enumerate</em> 空间的基函数 \(V_h\) 。对于 \(Q_1\) 元素，这意味着简单地以某种方式列举网格的顶点，但对于更高的元素，还必须列举与网格的边、面或单元内部有关的形状函数。提供这种列举 \(V_h\) 的基础函数的类被称为DoFHandler。 列举自由度的过程在deal.II中被称为 "分配DoF"。  </dd>
<dt class=" glossary"><a class="anchor" id="GlossDirectionFlag"></a><b>Direction flags</b>。 </dt>
<dd><p class="startdd"><em>direction flag</em>用于嵌入高维空间的三角形中，表示单元的方向，并使流形具有方向性。它使用 <a class="el" href="classCellAccessor.html#ae146ea059e9c27cb3e040b92d5c4e152">CellAccessor::direction_flag()</a> 进行访问，并在创建三角化时由三角化类进行设置。你可以使用 <a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">Triangulation::flip_all_direction_flags()</a> 函数来改变一个三角形的所有方向标志。 这个标志对于像这样的情况是必须的：假设我们有一个嵌入二维空间的一维网格。 </p><div class="image">
<img src="direction_flag.png" alt="direction_flag.png"/>
<div class="caption">
One dimensional mesh in two dimensions</div></div>
<p>在一维空间的一维网格中，我们总是可以确保一个单元的左边顶点的位置比右边顶点的位置的值要小。然而，如果我们将网格嵌入到一个高维空间中，我们就不能再这样做了。例如，上面的网格中的单元格可以用下面的顶点集来描述。&lt;code&gt;(0,1), (1,2), (3,2), (4,3), (4,5) 。(作为附带说明，注意这里我们有顶点</p>
<ul>
<li>例如，顶点2</li>
<li>是一个以上的单元的右端点）。)如果我们把每个单元的法线定义为与连接线的第一个顶点和第二个顶点的矢量垂直的单位矢量，那么我们最终会得到如下图所示。 <div class="image">
<img src="direction_flag_normals.png" alt="direction_flag_normals.png"/>
<div class="caption">
Normal vectors</div></div>
换句话说，这个一维流形是没有方向的。我们原则上可以在创建这样的网格时恢复顶点的顺序（尽管有很好的理由不这样做，例如，这个网格可能是由提取二维网格的表面网格产生的，而我们希望保留每个线段的顶点顺序，因为它们目前与二维单元的面的顶点顺序一致）。在deal.II中选择的另一种策略是简单地与每个单元关联，法线应该是该单元的左边还是右边的法线。在上面的例子中，五个单元格的标志将是&lt;code&gt;true, true, false, false, true。根据每个单元格上的标志值，将右法线乘以正负1，就可以得到一组为流形定位的法线向量。 类似的问题发生在三个空间维度的二维网格上。我们注意到，如果二维流形不可定向，就不可能找到一致的方向标志；目前deal.II不支持这种流形。 </li>
</ul>
</dd>
<dt class=" glossary"><a class="anchor" id="GlossDistorted"></a><b>Distorted cells</b>。 </dt>
<dd><p class="startdd"><em>distorted cell</em>是指从参考单元到实数单元的映射有一个雅各布系数，其行列式在单元的某处为非正值。通常情况下，我们只在单元格的顶点检查这个行列式的符号。函数 <a class="el" href="structGeometryInfo.html#af047ab1fe45077a53df9cd8212fc790c">GeometryInfo::alternating_form_at_vertices</a> 可以计算这些顶点的行列式。 举例来说，如果所有的行列式都是大致相等的数值，并且在 \(h^\text{dim}\) 的顺序上，那么这个单元格就是好的形状。例如，一个正方形单元或面的行列式等于 \(h^\text{dim}\) ，而一个强剪切的平行四边形的行列式则小得多。同样地，一个边长很不相等的单元格会有差异很大的行列式。反之，一个被夹住的单元，其中两个或多个顶点的位置被折叠成一个点，在这个位置的行列式为零。最后，一个倒置或扭曲的单元，其中两个顶点的位置是失序的，将有负的行列式。 下面两张图片显示了2D和3D的一个完好的单元，一个捏合的单元和一个扭曲的单元。 </p><div class="image">
<img src="distorted_2d.png" alt="distorted_2d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 2d.</div></div>
<div class="image">
<img src="distorted_3d.png" alt="distorted_3d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 3d.</div></div>
<p>扭曲的细胞可以以两种不同的方式出现。原始的 <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗略网格 </a> 可能已经包含了这样的单元，或者它们可能是由于移动或扭曲了一个相对较大的网格而产生的。 如果在创建三角网格时给出适当的标志，那么由GridGenerator和GridIn中的各种函数调用的函数 <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation</a>, （但也可以由用户代码调用，见 <a class="el" href="step_14.html">step-14</a> 和 <a class="el" href="step_49.html">step-49</a> 末尾的例子]，将通过抛出一个类型为 <a class="el" href="structTriangulation_1_1DistortedCellList.html">Triangulation::DistortedCellList</a>. 的异常来提示创建带有变形单元的粗略网格。 如果你不打算在这些单元上装配任何东西，创建带有变形单元（尤其是塌陷/针状单元）的网格是合法的。例如，考虑这样一种情况：人们想模拟一种有液体填充的裂缝的弹性材料的行为，如一个储油罐。如果压力变得太大，裂缝就会被关闭</p>
<p>而离散裂缝体积的单元被折叠成零体积。只要你不在这些单元上进行积分来模拟流体的行为（如果裂缝的体积为零，就不存在任何流体），这样的网格是完全合法的。因此， <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation</a> 不是简单地中止程序，而是抛出一个异常，其中包含一个被扭曲的单元的列表；这个异常可以被捕获，如果你认为你可以忽略这个条件，你可以通过对捕获的异常不做任何反应。 函数 <a class="el" href="namespaceGridTools.html#a1c7bb95bc2bbb09d6f02651d7be1527d">GridTools::fix_up_distorted_child_cells</a> 在某些情况下，可以通过移动具有未扭曲父单元的扭曲子单元的顶点来修复精化网格上的扭曲单元。 请注意，Triangulation类默认不测试是否存在扭曲的单元，因为确定一个单元是否扭曲并不是一个便宜的操作。如果你想让Triangulation对象测试单元格的变形，你需要在创建对象时通过传递适当的标志来指定这一点。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="distributed_paper"></a><b>Distributed computing paper</b>&lt;/dt </dt>
<dd><p class="startdd">"分布式计算论文 "是W. Bangerth, C. Burstedde, T. Heister和M. Kronbichler的一篇论文，题为 "大规模并行通用有限元代码的算法和数据结构"，描述了deal.II中并行分布式计算的实现，即不仅像 <a class="el" href="step_17.html">step-17</a> 中的线性系统被分割到不同机器的计算，还包括三角计算和DoFHandler对象。实质上，它是 <a class="el" href="namespaceparallel_1_1distributed.html">parallel::distributed</a> 命名空间和 <a class="el" href="step_40.html">step-40</a> 中所用技术的指南。 该论文的完整参考资料如下。 </p><div class="fragment"><div class="line">@Article{BBHK11,</div><div class="line">author =       {Wolfgang Bangerth and Carsten Burstedde and Timo Heister</div><div class="line">               and Martin Kronbichler},</div><div class="line">title =        {Algorithms and data structures for massively parallel generic</div><div class="line">adaptive finite element codes},</div><div class="line">journal =      {ACM Trans. Math. Softw.},</div><div class="line">year =         2011,</div><div class="line">volume =       38,</div><div class="line">pages =        {14/1--28}}</div></div><!-- fragment --><p class="enddd">对于大规模的并行计算，deal.II建立在<a href="http://www.p4est.org/" target="_top">p4est</a>库的基础上。如果你使用这个功能，也请引用他们网站上列出的p4est论文。  </p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossFaceOrientation"></a><b>Face orientation</b> </dt>
<dd><p class="startdd">在三角测量中，通过应用右手边规则（x,y），可以从面的方向推导出面的法向量。</p>
<p>-&gt; 法线）。) 我们注意到，在2D的标准方向中，面0和面2的法线指向单元格，面1和面3的法线指向外部。在3D中，面0、2和4的法线指向单元格内，而面1、3和5的法线指向外面。这些信息同样可以从 <a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">GeometryInfo&lt;dim&gt;::unit_normal_orientation</a>. 中查询到。 然而，事实证明，大量的三维网格不能满足这个约定。这是由于一个单元的面的约定已经暗示了相邻单元的东西，因为它们共享一个共同的面，对第一个单元的固定也固定了两个单元的相对面的法向量。很容易构建单元格循环的案例，对于这些案例，我们无法为所有面找到与该约定一致的方向。 由于这个原因，上述惯例只是我们所说的 <em> 标准方向 </em> ...II实际上允许3d中的面具有标准方向，或者其相反的方向，在这种情况下，构成单元格的线会有还原的顺序，法向量会有相反的方向。你可以通过调用<code>cell-&gt;face_orientation(face_no)</code>来询问一个单元是否有标准方向：如果结果是 <code>true</code>, ，那么这个面有标准方向，否则它的法向量就会指向另一个方向。在应用程序中，你需要这个信息的地方其实并不多，但库中有几个地方用到了这个。注意，在2D中，结果总是 <code>true</code>. 。然而，虽然2D中的每个面总是在标准方向上，但你有时可以指定一些东西来假设不是这样的；一个例子是函数 <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a>. 。 还有两个描述面的方向的标志：face_flip和face_rotation。这些的一些文档存在于GeometryInfo类中。 <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> 函数中给出了它们在用户代码中的使用实例。 </p>
<p>（在矢量值的情况下，除了支持点 \(\hat{\mathbf{x}}_i\) 外，唯一需要提供的其他信息是<em>vector component</em> \(c(i)\) 第1个节点函数对应的，因此 \(\Psi_i[\varphi]=\varphi(\hat{\mathbf{x}}_i)_{c(i)}\) 。 另一方面，还有其他种类的元素不是这样定义的。例如，对于最低阶的Raviart-Thomas元素（见FE_RaviartThomas类），节点函数评估的不是一个具有 <code>dim</code> 分量的矢量值有限元函数的各个分量，而是这个矢量的<em>normal component</em>。 \(\Psi_i[\varphi] = \varphi(\hat{\mathbf{x}}_i) \cdot \mathbf{n}_i \) ，其中 \(\mathbf{n}_i\) 是 \(\hat{\mathbf{x}}_i\) 所在的单元格面的法向量。换句话说，当在 \(\hat{\mathbf{x}}_i\) 处评估时，节点函数是 \(\varphi\) 组件的<em>linear combination</em>。类似的事情也发生在BDM、ABF和Nedelec元素上（见FE_BDM、FE_ABF、FE_Nedelec类）。 在这些情况下，元素没有 <em>support points</em> ，因为它不是纯粹的插值；但是，在定义形状函数时，仍然涉及某种插值，因为节点函数仍然需要在特殊点上进行点评估 \(\hat{\mathbf{x}}_i\) 。在这些情况下，我们称这些点为<em>generalized support points</em>。 最后，还有一些元素仍然不适合这个方案。例如，一些层次化的基函数（例如，见FE_Q_Hierarchical元素）的定义是这样的：节点函数是有限元函数的<em>moments</em>，2d的 \(\Psi_i[\varphi] = \int_{\hat{K}} \varphi(\hat{\mathbf{x}}) {\hat{x}_1}^{p_1(i)} {\hat{x}_2}^{p_2(i)} \) ，同样，3d的 \(p_d(i)\) 是形状函数 \(i\) 描述的矩的顺序。其他一些元素使用边或面的矩。在所有这些情况下，节点函数根本不是通过插值定义的，那么这些元素既没有支持点，也没有广义支持点。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="geometry_paper"></a><b>geometry paper</b> </dt>
<dd><p class="startdd">"geometry paper "是L. Heltai, W. Bangerth, M. Kronbichler, and A. Mola的一篇论文，题目是 "在有限元计算中使用精确几何信息"，描述deal.II如何描述域的几何信息。特别是，它讨论了Manifold类所基于的算法基础，以及它需要为网格细化、法向量的计算和其他许多几何学进入有限元计算的地方提供什么样的信息。 这篇论文目前可在arXiv网站https://arxiv.org/abs/1910.09824。这篇论文的完整参考资料如下。 </p><div class="fragment"><div class="line">@misc{heltai2019using,</div><div class="line"> title={Using exact geometry information in finite element computations},</div><div class="line"> author={Luca Heltai and Wolfgang Bangerth and Martin Kronbichler and Andrea Mola},</div><div class="line"> year={2019},</div><div class="line"> eprint={1910.09824},</div><div class="line"> archivePrefix={arXiv},</div><div class="line"> primaryClass={math.NA}</div><div class="line">}</div></div><!-- fragment --><p>  幽灵单元层由所有与任何本地拥有的单元相邻的面、边或顶点的单元组成，这些单元本身并不是本地拥有的。换句话说，幽灵细胞完全包围了本地拥有的细胞的子域（当然，域的边界除外）。 幽灵单元的概念对于在每个处理器上存储整个网格的三角计算没有意义，即三角计算和 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 类。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossGhostedVector"></a><b>Ghosted vectors</b> </dt>
<dd><p class="startdd">在并行计算中，向量一般有两种情况：没有和有鬼魂元素。没有鬼魂元素的向量在处理器之间唯一地划分了向量元素：每个向量条目正好有一个处理器拥有它，而且这个处理器是唯一存储这个条目的值的。换句话说，如果零号处理器存储了一个向量的0...49号元素，一号处理器存储了50...99号元素，那么一号处理器访问这个向量的42号元素就不走运了：它没有被存储在这里，也无法评估其值。这将导致一个断言。 另一方面，在很多情况下，我们需要知道不属于本地的向量元素，例如在本地拥有的单元上评估解决方案（见 <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> ），其中一个自由度位于我们不属于本地的单元的接口处（在这种情况下，它必须是 <a class="el" href="DEALGlossary.html#GlossGhostCell">幽灵单元</a> ），而邻近的单元可能是所有者</p>
<p>因为人们经常需要这些值，所以有第二种矢量，通常称为 "幽灵矢量"。幽灵向量在每个处理器上存储一些元素，而该处理器不是所有者。对于这样的向量，你可以读取你当前所在的处理器所存储的那些元素，但你不能写入这些元素，因为要做到这一点，需要将新的值传播给所有其他拥有这个值副本的处理器（这些处理器的列表可能是当前处理器不知道的，也没有办法有效地找到）。因为你不能写进重影向量，所以初始化这样一个向量的唯一方法是通过从一个非重影向量的赋值。这意味着我们必须从其他处理器中导入那些我们想在本地存储的元素。 幽灵向量的实际存储方式在并行向量的各种实现中是不同的。对于PETSc（以及相应的 <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> 类），重影向量存储的元素与非重影向量相同，另外还有一些由其他处理器拥有的额外元素。换句话说，每个元素在所有的处理器中都有一个明确的所有者，那些当前处理器存储但不拥有的元素（即 "幽灵元素"）只是其他地方的主值的镜像。</p>
<ul>
<li>因此，被称为 "幽灵"。 parallel::distributed::Vector 类也是这种情况。 另一方面，在Trilinos中（因此在 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>), 中，鬼魂向量仅仅是元素分布重叠的平行向量的一个视图。幽灵化的 "Trilinos向量本身不知道哪些条目是幽灵化的，哪些是局部拥有的。事实上，一个重影向量甚至可能不会存储所有非重影向量在当前处理器上会存储的元素。因此，对于Trilinos向量来说，不存在我们在非鬼魂情况下（或在PETSc情况下）所拥有的向量元素的
"所有者 "的概念，"鬼魂元素 "这个名字可能有误导性，因为在这个观点中，我们在本地可用的每个元素可能也会被存储在其他地方，但即使是这样，本地元素也不是一个主要位置的镜像值，因为每个元素没有所有者。</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 文档模块提供了不同种类的向量通常用于何处的简要概述。 </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="hp_paper"></a><b>hp-paper</b> </dt>
<dd><p class="startdd">"hp-paper "是W. Bangerth和O. Kayser-Herold的一篇论文，题目是 "hp有限元软件的数据结构和要求"，它描述了在实现deal.II的hp-framework时使用的许多算法和数据结构。特别是，它总结了许多使用连续元素的hp-有限元必须考虑的棘手问题。 这篇论文的完整参考资料如下。 </p><div class="fragment"><div class="line">@Article{BK07,</div><div class="line">author =       {Wolfgang Bangerth and Oliver Kayser-Herold},</div><div class="line">title =        {Data Structures and Requirements for hp Finite Element</div><div class="line">               Software},</div><div class="line">journal =      {ACM Trans. Math. Softw.},</div><div class="line">year =         2009,</div><div class="line">volume =       36,</div><div class="line">number =       1,</div><div class="line">pages =        {4/1--4/31}</div><div class="line">}</div></div><!-- fragment --><p> 它可以从<a href="http://www.math.colostate.edu/~bangerth/publications.html">http://www.math.colostate.edu/~bangerth/publications.html</a>中获得，也可以参见<a href="https://www.dealii.org/publications.html#details">deal.II publications</a>了解详情。 那篇论文中显示的数字例子是用稍加修改的 <a class="el" href="step_27.html">step-27</a> 版本生成的。与该教程程序的主要区别是，该程序中的各种操作都是为该论文计时的，以比较不同的选项，并表明 \(hp\) 方法确实不是那么昂贵。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedCell"></a><b>Locally owned cell</b> </dt>
<dd><p class="startdd">当使用分布式网格时，这个概念标识了所有单元的一个子集，见 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块。在这样的网格中，每个单元正好被一个处理器所拥有。本地拥有的是那些由当前处理器拥有的。</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedDof"></a><b>Locally owned degrees of freedom</b> </dt>
<dd><p class="startdd">当使用分布式网格时，这个概念标识了所有自由度的一个子集，见 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块。 本地拥有的自由度生活在本地拥有的单元上。由于自由度只属于一个处理器，不同处理器所拥有的单元之间的接口上的自由度可能属于一个或另一个处理器，所以并非本地拥有的单元上的所有自由度也是本地拥有的自由度。 本地拥有的自由度是 <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">本地活动自由度 </a> 的一个子集。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyActiveDof"></a><b>Locally active degrees of freedom</b> </dt>
<dd><p class="startdd">这个概念在使用分布式网格时识别所有自由度的子集，见 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块。 本地活动的自由度是那些生活在本地拥有的单元上的自由度。因此，在不同处理器拥有的单元之间的界面上的自由度属于一个以上处理器的本地活动自由度集合。</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyRelevantDof"></a><b>Locally relevant degrees of freedom</b> </dt>
<dd><p class="startdd">当使用分布式网格时，这个概念确定了所有自由度的一个子集，见 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块。 本地相关的自由度是那些生活在本地拥有的或幽灵单元上的自由度。因此，它们可能被不同的处理器所拥有。 本地相关自由度是 <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">本地活动自由度 </a> 的超集。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossManifoldIndicator"></a><b>Manifold indicator</b> &lt;/td </dt>
<dd><p class="startdd">构成三角网格的每个对象（单元格、面、边等），都与一个唯一的编号（类型为 <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) ，用于识别网格细化时哪个流形对象负责生成新点。 默认情况下，一个网格的所有流形指标都被设置为 <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>. 。一个典型的代码将一个对象上的流形指标设置为其他内容，看起来像这样，这里将所有中心的 \(x\) 分量小于0的单元的流形指标设置为42。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;center()[0] &lt; 0)</div><div class="line">  cell-&gt;set_manifold_id (42);</div></div><!-- fragment --><p>这里我们调用函数 <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id()</a>. 。也可以用调用 <a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">TriaAccessor::set_all_manifold_ids</a> 来代替，以递归地设置每个面（和边，如果是3D）的流形标识。要查询某个特定对象边缘的流形指标，请使用 <a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">TriaAccessor::manifold_id()</a>. 。 上面的代码只是设置了Triangulation的特定部分的流形指标，但它本身并没有改变Triangulation类在网格细化中对待这个对象的方式。为此，你需要调用 <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> 来将流形对象与特定的流形指标联系起来。这允许Triangulation对象使用不同的方法来寻找单元格、面或边上的新点进行细化；默认情况下，所有面和边都使用FlatManifold对象。</p>
<dl class="section note"><dt>Note</dt><dd>在网格细化时，流形指标会从父类继承到子类。关于流形指示器的更多信息，也在Triangulation类的文档部分以及 <a class="el" href="group__manifold.html">流形文档模块 </a> 中介绍。歧管指标在 <a class="el" href="step_53.html">step-53</a> 和 <a class="el" href="step_54.html">step-54</a> 中使用。  </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__manifold.html">关于歧管的模块</a></dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMaterialId"></a><b>Material id</b> </dt>
<dd><p class="startdd">三角形的每个单元都有一个叫做 "材料ID
"的属性。它通常用于具有异质系数的问题，以确定一个单元在域的哪一部分，因此，系数应该在这个特定的单元上具有哪个值。在实践中，一个单元的材料ID通常用于识别哪些单元属于域的特定部分，例如，当你有不同的材料（钢铁、混凝土、木材），但都属于同一个域。在组装双线性表格的过程中，我们通常会查询与某一单元相关的材料ID，并使用它来确定（例如，通过表格查询，或一连串的if-else语句）该单元的正确材料系数是多少。 这个材料ID可以在构建三角形时设置（通过CellData数据结构），也可以在之后通过使用单元格迭代器设置。关于这个功能的典型使用，请看 <a class="el" href="step_28.html">step-28</a> 的教程程序。GridGenerator命名空间的函数通常将所有单元的材料ID设置为0。当通过GridIn类读取三角图时，不同的输入文件格式有不同的约定，但通常是明确指定材料ID，如果没有，则GridIn简单地将其设置为零。因为一个单元的材料是与域的特定区域相关的，所以材料ID在网格细化时由子单元从其父单元继承。 材料ID的设置和查询使用 <a class="el" href="classCellAccessor.html#ae4769702cd7ab67a61b25778ea3021b2">CellAccessor::material_id</a>, <a class="el" href="classCellAccessor.html#a861d3679d23d3f4365f724c9cfe5fd77">CellAccessor::set_material_id</a> 和 <a class="el" href="classCellAccessor.html#a2b49d85f8793f5a95d6c50797c07be2b">CellAccessor::recursively_set_material_id</a> 函数。 </p>
<p>当通过命令行调用启动一个并行程序时，如 </p><div class="fragment"><div class="line">mpirun</div><div class="line"></div><div class="line">-np 32 ./step-17</div></div><!-- fragment --><p> （或者在你的集群上使用的批处理提交系统中使用的等价物）MPI系统启动32份 <a class="el" href="step_17.html">step-17</a> 的可执行文件。其中每个都可以访问 <code>MPI_COMM_WORLD</code> 通信器，然后由所有32个处理器组成，每个都有自己的等级。这个MPI宇宙中的一个进程子集后来可以同意创建其他通信器，只允许在一个进程子集之间进行通信。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMPIProcess"></a><b>MPI Process</b> </dt>
<dd><p class="startdd">在分布式内存机器上运行并行作业时，人们几乎总是使用MPI。在那里，一个命令行调用，如 </p><div class="fragment"><div class="line">mpirun</div><div class="line"></div><div class="line">-np 32 ./step-17</div></div><!-- fragment --><p> （或在你的集群上使用的批处理提交系统中使用的等价物）启动32份 <a class="el" href="step_17.html">step-17</a> 的可执行文件。其中一些实际上可能在同一台机器上运行，但一般来说，它们将在不同的机器上运行，不能直接访问对方的内存空间。 每个进程只能立即访问其自身内存空间中的对象。一个进程不能从其他进程的内存中读取或写入。因此，进程可以通信的唯一方式是互相发送消息。也就是说（正如在 <a class="el" href="step_17.html">step-17</a> 的介绍中所解释的那样），人们通常会调用更高级别的MPI函数，而作为通信器一部分的所有进程都参与其中。一个例子是计算一组整数的总和，每个进程提供总和的一个项。 </p>
<p>在每个通信器中，每个进程都有一个独特的等级，与所有其他进程的等级不同，可以在MPI通信调用中识别一个接收方或发送方。在一个处理器上运行的每个进程都可以通过调用 <a class="el" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process()</a>. 查询自己在通信器中的等级。 参与通信器的进程总数（即通信器的<em>size</em>）可以通过调用 <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>.  获得。</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="mg_paper"></a><b>Multigrid paper</b> </dt>
<dd><p class="startdd">"multigrid paper "是B. Janssen和G. Kanschat的一篇论文，题为 "Adaptive Multilevel Methods with Local Smoothing for H1- and Hcurl-Conforming High Order Finite Element Methods"，它描述了在实现deal.II的多网格框架时所用的许多算法和数据结构。它是实现
@ref step_16 "step-16" 中用于多网格方法的类的基础。 本文的完整参考资料如下。 </p><div class="fragment"><div class="line">@article{janssen2011adaptive,</div><div class="line">title=    {Adaptive Multilevel Methods with Local Smoothing for H^1- and H^{curl}-Conforming High Order Finite Element Methods},</div><div class="line">author=   {Janssen, B{\&quot;a}rbel and Kanschat, Guido},</div><div class="line">journal=  {SIAM Journal on Scientific Computing},</div><div class="line">volume=   {33},</div><div class="line">number=   {4},</div><div class="line">pages=    {2095--2114},</div><div class="line">year=     {2011},</div><div class="line">publisher={SIAM}}</div></div><!-- fragment --><p> 论文见<a href="http://dx.doi.org/10.1137/090778523">DOI:10.1137/090778523</a>，更多细节见<a href="https://www.dealii.org/publications.html#details">deal.II publications</a>。 </p>
<p class="enddd"></p>
</dd>
<dt class=" glossary"><a class="anchor" id="GlossNodes"></a><b>Node values or node functionals</b>。 </dt>
<dd><p class="startdd">习惯上将有限元定义为一个三联体 \((K,P,\Psi)\) 其中</p>
<ul>
<li>\(K\) 是单元格，在deal.II中这总是一个线段、四边形或六面体。</li>
<li>\(P\) 是一个有限维空间，例如，从 <a class="el" href="DEALGlossary.html#GlossReferenceCell">参考单元 </a>映射到 \(K\) 的多项式空间。</li>
<li>\(\Psi\) 是 "节点函数 "的集合，即函数 \(\Psi_i : P \rightarrow {\mathbb R}\) 。 \(P\) 的维度必须等于节点函数的数量。有了这个定义，我们可以定义局部函数空间的基础，即一组 "形状函数" \(\varphi_j\in P\) ，要求 \(\Psi_i(\varphi_j) = \delta_{ij}\) ，其中 \(\delta\) 是克朗克三角。 这种对有限元的定义有几个优点，涉及分析和实施。对于分析来说，它意味着与某些空间 (<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">FiniteElementData::Conformity</a>), 的一致性，例如连续性，是由节点函数决定的。在deal.II中，它有助于大大简化像FE_RaviartThomas这样的复杂元素的实现。 节点函数的例子是 <a class="el" href="DEALGlossary.html#GlossSupport">支持点 </a> 中的值和关于Legendre多项式的矩。例子。 <table class="doxtable">
<tr>
<th>Element </th><th>Function space </th><th>Node values </th></tr>
<tr>
<th><a class="el" href="classFE__Q.html">FE_Q</a>, <a class="el" href="classFE__DGQ.html">FE_DGQ</a> </th><td><em>Q<sub>k</sub></em> </td><td>values in support points </td></tr>
<tr>
<th><a class="el" href="classFE__DGP.html">FE_DGP</a> </th><td><em>P<sub>k</sub></em> </td><td>moments with respect to Legendre polynomials </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> (2d) </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>moments on edges and in the interior </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomasNodal.html">FE_RaviartThomasNodal</a> </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>Gauss points on edges(faces) and anisotropic Gauss points in the interior </td></tr>
</table>
如上所述，有限元的构造允许编写描述有限元的代码，只需提供一个多项式空间（无需给它任何特定的基础）。</li>
<li>任何方便的都是完全足够的）和节点函数。例如，在 <a class="el" href="classFiniteElement.html#a97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> 函数中就用到了这一点。 </li>
</ul>
</dd>
<dt class="glossary"><a class="anchor" id="GlossParallelScaling"></a><b>Parallel scaling</b> </dt>
<dd><p class="startdd">当我们说一个并行程序可以 "扩展
"时，我们的意思是，如果我们让它解决的问题变大，程序不会变得过于缓慢（或占用过多的内存），如果我们保持问题大小不变但增加处理它的处理器（或内核）数量，运行时间和内存消耗将按比例减少。 更具体地说，想想一个问题，其大小由一个数字 \(N\) 给出（可以是单元格的数量，未知数的数量，或其他一些指示性的数量，如解决它所需的CPU周期的数量），对于这个问题，你有 \(P\) 个处理器可用于解决。在一个理想的世界里，这个程序需要的运行时间是 \({\cal O}(N/P)\) ，这意味着我们可以通过提供更多的处理器将运行时间减少到任何想要的值。同样，为了使程序具有可扩展性，其总体内存消耗需要为 \({\cal O}(N)\) ，在每个参与的进程上需要为 \({\cal O}(N/P)\) ，这再次意味着我们可以通过提供足够多的处理器，将任何问题纳入计算机附加在每个处理器上的固定内存量。 对于可扩展性的实际评估，我们经常区分 "强 "和 "弱
"可扩展性。这些评估渐进式的声明，如 \({\cal O}(N/P)\) 极限中的运行时间 \(N\rightarrow \infty\) 和/或 \(P\rightarrow \infty\) 。具体来说，当我们说一个程序是 "强可扩展性
"时，我们的意思是，如果我们有一个固定大小的问题 \(N\) ，那么我们可以通过向该问题投掷更多的处理器来减少运行时间和内存消耗（在每个处理器上）与 \(P\) 成反比。特别是，强可扩展性意味着，如果我们提供两倍的处理器，那么每个进程的运行时间和内存消耗都将减少2倍。换句话说，通过提供越来越多的处理器，我们可以越来越快地解决<em>same problem</em>的问题。 相反，"弱可扩展性
"是指如果我们将问题大小 \(N\) 增加一个固定的系数，并将可用于解决问题的处理器 \(P\) 的数量增加相同的系数，那么整体运行时间（以及每个处理器的内存消耗）保持不变。换句话说，我们可以通过提供越来越多的处理器，在相同的壁时钟时间内解决<em>larger and larger problems</em>。 在这个理论意义上，没有一个程序是真正可扩展的。相反，一旦 \(N\) 或 \(P\) 的增长超过一定的限度，所有的程序就不再具有可扩展性。因此，我们经常说 "程序可以扩展到4000个核心"，或者 "程序可以扩展到100,000,000个未知数
"这样的话。程序不能无限制扩展的原因有很多；这些都可以通过查看（相对简单的） <a class="el" href="step_17.html">step-17</a> 教程程序来说明。</p>
<ul>
<li>序列部分。许多程序都有不能或不能并行化的代码部分，也就是说，一个处理器必须做一定的、固定的工作量，不会因为周围总共有 \(P\) 个处理器而减少。在 <a class="el" href="step_17.html">step-17</a> 中，生成图形输出时就是这种情况：一个处理器为整个问题创建图形输出，也就是说，它需要做 \({\cal O}(N)\) 工作。这意味着这个函数的运行时间为 \({\cal O}(N)\) ，而不考虑 \(P\) ，因此整个程序将无法达到 \({\cal O}(N/P)\) 的运行时间，而是有一个可以描述为 \(c_1N/P + c_2N\) 的运行时间，其中第一项来自可扩展的操作，如组装线性系统，而后者来自在进程0上生成图形输出。如果 \(c_2\) 足够小，那么程序可能看起来对小数量的处理器具有强扩展性，但最终强扩展性将停止。此外，程序也不能弱扩展，因为在以相同的速度增加处理器数量 \(P\) 的同时，增加问题的大小 \(N\) 并不能保持这一个函数的运行时间不变。</li>
<li>重复的数据结构。在 <a class="el" href="step_17.html">step-17</a> 中，每个处理器存储整个网格。也就是说，每个处理器都要存储一个大小为 \({\cal O}(N)\) 的数据结构，而不考虑 \(P\) 。最终，如果我们使问题的大小足够大，即使我们增加处理器的数量，这也会溢出每个处理器的内存空间。因此，很明显，这种复制的数据结构可以防止程序弱速扩展。 但它也阻止了程序的强扩展，因为为了创建一个大小为 \({\cal O}(N)\) 的对象，至少要写到 \({\cal O}(N)\) 的内存位置，要花费 \({\cal O}(N)\) 的CPU时间。因此，如果我们提供越来越多的处理器，整个算法的一个组成部分不会表现为 \({\cal O}(N/P)\) 。</li>
<li>通信。仅举一个例子，如果你想计算一个向量的 \(l_2\) 常数，而所有MPI进程都存储了一些条目，那么每个进程都需要计算其自身条目的平方之和（这需要 \({\cal O}(N/P)\) 时间，因此可以完美扩展），但随后每个进程都需要将其部分之和发送到一个进程，将它们全部相加并取平方根。在最好的情况下，发送一个包含单个数字的信息需要恒定的时间，而不考虑进程的总体数量。因此，同样地，每一个做通信的程序都不能强势扩展，因为程序中有些部分的CPU时间要求并不随着你为固定规模分配的处理器数量而减少 \(P\) 。在现实中，情况实际上更糟糕：参与一个通信步骤的进程越多，一般来说需要的时间就越长，例如，因为要把所有人的贡献加起来的那个进程必须把所有的东西加起来，需要 \({\cal O}(P)\) 时间。换句话说，CPU的时间<em>increases</em>与进程的数量有关，因此不仅阻止了程序的强扩展，而且也阻止了弱扩展。实际上，MPI库并不通过将每个消息发送到一个进程，然后将所有的东西加起来来实现 \(l_2\) 规范；相反，它们在树上做成对的减少，而不是像 \({\cal O}(P)\) 那样增长运行时间，而是像 \({\cal O}(\log_2 P)\) 那样，以发送更多消息为代价。尽管如此，根本的一点是，当你增加更多的处理器时，运行时间将以 \(P\) 的方式增长，而不管操作的实际实现方式如何，因此它不能扩展。) 这些以及其他阻碍程序完美扩展的原因可以在<a href="https://en.wikipedia.org/wiki/Amdahl%27s_law"><em>Amdahl's law</em><em>Amdahl's law</em></a>中总结出来，即如果程序整体工作的一部分 \(\alpha\) 可以并行化，即可以在 \({\cal O}(\alpha W/P)\) 时间内运行，而程序工作的一部分 \(1-\alpha\) 不能并行化（即。它包括只有一个进程可以做的工作，例如在 <a class="el" href="step_17.html">step-17</a> 中生成图形输出；或者每个进程都必须以复制的方式执行，例如将带有本地贡献的消息发送到一个专门的进程进行积累），那么程序的总体运行时间将是 <p class="formulaDsp">
\begin{align*} T = {\cal O}\left(\alpha \frac WP + (1-\alpha)W \right). \end{align*}
</p>
 因此，你得到的 "加速"，即你的程序在 \(P\) 处理器上的运行速度与在单个进程上运行程序相比的系数（假设这是可能的），将是 <p class="formulaDsp">
\begin{align*} S = \frac{W}{\alpha \frac WP + (1-\alpha)W} = \frac{P}{\alpha + (1-\alpha)P}. \end{align*}
</p>
 如果 \(\alpha&lt;1\) ，对所有实际存在的程序来说都是如此，那么 \(S\rightarrow \frac{1}{1-\alpha}\) 就是 \(P\rightarrow \infty\) ，这意味着有一个点，在这个点上，在问题上投入更多的处理器不会再有任何明显的回报。 在实践中，重要的是<em>up to which problem size</em>或<em>up to which number of processes</em>或<em>down to which size of local problems \({\cal}(N/P)\)</em>一个程序的规模。对于deal.II，经验表明，在大多数具有合理快速网络的集群上，人们可以解决多达几十亿个未知数的问题，最多有几千个处理器，而每个进程的未知数则在40,000到100,000之间。最后一个数字是最相关的：如果你有一个问题，例如 \(10^8\) 未知数，那么在1000-2500个处理器上解决它是有意义的，因为每个进程处理的自由度数量保持在40000以上。因此，每个进程都有足够的工作要做，所以 \({\cal O}(1)\) 的通信时间并不占优势。但是用1万或10万个处理器来解决这样的问题是没有意义的，因为这些处理器的每个局部问题都变得非常小，以至于它们大部分时间都在等待通信，而不是在做自己部分的工作。  </li>
</ul>
</dd>
<dt class="glossary"><a class="anchor" id="GlossPeriodicConstraints"></a><b>Periodic boundary conditions</b> </dt>
<dd><p class="startdd">周期性边界条件经常在只有部分物理相关域被建模时使用。人们假设解决方案只是在被认为是周期性的边界上周期性地继续。在deal.II中，通过 <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a> 和 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a>. 支持这一点。一旦使用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> ，还必须调用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity()</a> 以确保所有进程知道周期性边界两边的三角化的相关部分。一个典型的分布式三角剖分的过程是。</p>
<ul>
<li>创建一个网格</li>
<li>使用 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> （三角法）收集周期面</li>
<li>使用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity()</a> 将周期性信息添加到网格中。</li>
<li>使用 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>) 收集周期性面孔</li>
<li>使用 <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a> 添加周期性约束。 这方面的一个例子可以在 <a class="el" href="step_45.html">step-45</a> 中找到。 </li>
</ul>
</dd>
<dt class="glossary"><a class="anchor" id="GlossPrimitive"></a><b>Primitive finite elements</b> </dt>
<dd>如果一个有限元素（由其形状函数描述）存在一个从形状函数数到矢量 <a class="el" href="DEALGlossary.html#GlossComponent">分量 </a> 的唯一关系，那么它就是基元。这意味着，如果一个元素是原始的，那么矢量值元素的每个形状函数正好有一个非零分量。这尤其包括所有标量元素以及通过FESystem类从其他基元（例如标量）元素组装的矢量值元素，如 <a class="el" href="step_8.html">step-8</a> 、 <a class="el" href="step_29.html">step-29</a> 、 <a class="el" href="step_22.html">step-22</a> 和其他一些元素所示。另一方面， <a class="el" href="step_20.html">step-20</a> 和 <a class="el" href="step_21.html">step-21</a> 中使用的FE_RaviartThomas类或FE_Nedelec类提供了非原始有限元，因为在那里，每个矢量值形状函数可能有几个非零分量。  </dd>
<dt class="glossary"><a class="anchor" id="GlossReferenceCell"></a><b>Reference cell</b> </dt>
<dd>超立方体[0,1]<sup>dim</sup>，所有参数化的有限元形状函数都在其上定义。参考单元的许多属性由GeometryInfo类描述。  </dd>
<dt class="glossary"><a class="anchor" id="GlossSerialization"></a><b>Serialization</b>。 </dt>
<dd><p class="startdd">术语 "序列化
"指的是将一个对象的状态写入一个流中，然后再检索它的过程。一个典型的用例是将程序的状态保存到磁盘上，以便以后可能的复活，通常是在长期运行的计算的检查点/重启策略的背景下，或者在不是很可靠的计算机上（例如，在非常大的集群上，个别节点偶尔会出现故障，然后导致整个MPI作业的中断）。在这两种情况下，人们希望偶尔保存程序的状态，以便在失败时，可以在那个点重新启动，而不是从头开始运行。 deal.II通过实现<a href="http://www.boost.org/doc/libs/1_62_0/libs/serialization/doc/index.html" target="_top">BOOST serialization</a>库的必要接口，实现了序列化设施。关于如何保存和恢复对象的例子见那里。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossShape"></a><b>Shape functions</b> </dt>
<dd><p class="startdd">有限元基函数对单个网格单元的限制。 </p>
<p>对于基于MPI并行化的程序，但每个处理器都存储整个三角形（例如， <a class="el" href="step_17.html">step-17</a> 和 <a class="el" href="step_18.html">step-18</a> ，但不是 <a class="el" href="step_40.html">step-40</a> ），子域ID通过划分网格分配给单元，然后每个MPI进程只对它 "拥有
"的单元工作，即。属于处理器拥有的子域（传统上，这是子域id的情况，其数值与MPI通信器中MPI进程的等级一致）。分区通常使用 <a class="el" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">GridTools::partition()</a> 函数完成，但也可以使用任何其他方法来完成。(另外， <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 类可以用类似的方法自动划分网格)。 除了常规的子域id，还有第二套密切相关的标志，与每个单元相关。"水平子域id"。这些标志不仅存在于活动单元，而且事实上存在于网格层次结构中的每个单元。它们的含义完全类似于常规的子域id，但它们是由 <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">CellAccessor::level_subdomain_id()</a> 和 <a class="el" href="classCellAccessor.html#a2bfad9f24d9ddbc86883614639d4886d">CellAccessor::set_level_subdomain_id()</a> 函数读写的。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSupport"></a><b>Support points</b> </dt>
<dd><p class="startdd">根据定义，支持点是那些 \(p_i\) ，使得对于形状函数 \(v_j\) 持有 \(v_j(p_i) = \delta_{ij}\) 。因此，有限元插值可以由支持点中的值唯一地定义。 拉格朗日元素填充由 <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">FiniteElement::get_unit_support_points()</a>, 访问的矢量，这样函数 <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">FiniteElement::has_support_points()</a> 返回<code>真</code>。当然，这些支持点是在 <a class="el" href="DEALGlossary.html#GlossReferenceCell">GlossReferenceCell</a> 的 "参考单元 " 上。 然后，可以使用FEValues（与Mapping结合使用）来访问实际网格单元上的支持点。</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossTargetComponent"></a><b>Target component</b> </dt>
<dd><p class="startdd">当向量和矩阵被按分量分组到块中时，通常希望将几个原始分量收集到一个块中。例如，这可能是将斯托克斯系统的速度分组为一个单一的块。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUserFlags"></a><b>User flags</b> </dt>
<dd><p class="startdd">一个三角图为用户标志提供每行、四边形等一个比特。 这个字段可以像所有其他数据一样使用迭代器进行访问，使用的语法是 </p><div class="fragment"><div class="line">cell-&gt;set_user_flag();                <span class="comment">// set the user flag of a cell</span></div><div class="line"><span class="keywordflow">if</span> (cell-&gt;user_flag_set() == <span class="keyword">false</span>)   <span class="comment">// if cell hasn&#39;t been flagged yet</span></div><div class="line">  {</div><div class="line">     cell-&gt;face(0)-&gt;set_user_flag();  <span class="comment">// flag its first face</span></div><div class="line">  }</div></div><!-- fragment --><p> 通常情况下，如果一个算法走过所有的单元，并且需要另一个单元，例如邻居，是否已经被处理过的信息，那么这个用户标志就会被使用。同样，它也可以用来标记边界上的面、四边形或线，对它们已经进行了一些操作。后者通常是有用的，因为一个循环，如 </p><div class="fragment"><div class="line"><span class="comment">// in 3d</span></div><div class="line"><span class="keywordflow">for</span> (cell=dof_handler.begin_active();</div><div class="line">     cell!=dof_handler.end(); ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">         <span class="keywordflow">do</span> something with <span class="keyword">this</span> line</div><div class="line">      }</div></div><!-- fragment --><p> 不止一次地遇到一些边界线。因此，人们会在循环的主体中设置该行的用户标志，并且只有在用户标志先前没有被设置的情况下才会进入主体。有一些额外的函数可以通过迭代器接口访问；更多信息请参见TriaAccessor类。请注意，没有用户标志可以与顶点相关联；然而，由于顶点是连续编号的，这可以很容易地在用户代码中使用一个bools矢量来模拟。 有两个函数， <a class="el" href="classTriangulation.html#a6a9971ee882f15fe521afc4e079383b5">Triangulation::save_user_flags</a> 和 <a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">Triangulation::load_user_flags</a> 可以从一个流或一个bools向量中写入和读取这些标志。与 <a class="el" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">Triangulation::save_refine_flags</a> 和 <a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">Triangulation::load_refine_flags</a>, 不同的是，这两个函数存储和读取所有使用过的线、四边形等的标志，即不仅是活动的标志。 如果你想存储更多具体的用户标志，你可以使用函数 <a class="el" href="classTriangulation.html#a2b7d8e059d6f8f903879eea858215fb8">Triangulation::save_user_flags_line</a> 和 <a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">Triangulation::load_user_flags_line</a> ，对四边形等也是如此。 至于细化和粗化标志，这些函数有两个版本，一个是从流中读/写，一个是从<code>向量中读/写 &lt;bool&gt;</code>. 后者用于临时存储标志，而第一个用于将其存储在文件中。 在使用前用 <a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">Triangulation::clear_user_flags()</a> 函数清除用户标志是很好的做法，因为经常需要在多个函数中使用这些标志。如果在调用一个需要这些标志的函数时，这些标志可能还在使用中，那么这个函数应该按照上述方法保存和恢复这些标志。</p>
<dl class="section note"><dt>Note</dt><dd>如果需要在单元格、行或面中存储更多的信息，而不仅仅是一个布尔标志，那么请参见 <a class="el" href="DEALGlossary.html#GlossUserData">用户数据</a> 。 </dd></dl>
<p>用户数据的存储和检索方式如下。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (cell=dof_handler.begin_active();</div><div class="line">     cell!=dof_handler.end(); ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">        cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;set_user_index(42);</div><div class="line">      }</div></div><!-- fragment --><p> 同样地，有函数 <a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">TriaAccessor::set_user_pointer</a> 用来设置指针， <a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">TriaAccessor::user_index</a> 和 <a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">TriaAccessor::user_pointer</a> 用来检索索引和指针。要清除所有的用户索引或指针，请使用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a>. 与标志一样，有一些函数允许保存和恢复用户数据，可以是网格层次结构的所有实体，也可以是线、四边形或六边形的单独数据。有一些额外的函数可以通过迭代器接口访问；更多信息请参见TriaAccessor类。</p>
<dl class="section note"><dt>Note</dt><dd>用户指针和用户索引被存储在同一个地方。为了避免不必要的转换，Triangulation会检查其中哪一个正在使用，并且不允许访问另一个，直到 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 被调用。</dd>
<dd>
关于 <code>void</code> 指针的类型安全缺失的常规警告显然在这里得到了体现；类型的正确性等的责任完全在于指针的使用者。 </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="workstream_paper"></a><b>WorkStream paper</b> </dt>
<dd><p class="startdd">"WorkStream paper "是B. Turcksin、M. Kronbichler和W. Bangerth的一篇论文，讨论了WorkStream的设计和实现。WorkStream的核心是一种设计模式，即在有限元代码中反复使用的东西，因此，可以通用地实现。特别是，本文阐述了这种模式的动机，然后提出了实现它的不同方法。它还比较了不同实现方式的性能。 本文的完整参考资料如下。 </p><div class="fragment"><div class="line">@Article{TKB16,</div><div class="line">author =       {Bruno Turcksin and Martin Kronbichler and Wolfgang Bangerth},</div><div class="line">title =        {\textit{WorkStream}</div><div class="line"></div><div class="line">-- a design pattern for multicore-enabled finite element computations},</div><div class="line">journal =      {accepted for publication in the ACM Trans. Math. Softw.},</div><div class="line">year =         2016</div><div class="line">}</div></div><!-- fragment --><p> 它可以从<a href="http://www.math.colostate.edu/~bangerth/publications.html">http://www.math.colostate.edu/~bangerth/publications.html</a>中获得，详细情况也见<a href="https://www.dealii.org/publications.html#details">deal.II publications</a>。 </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossZOrder"></a><b>Z order</b> </dt>
<dd><p class="startdd">单元的 "Z顺序 "描述了一个单元被遍历的顺序。 因为单元格的创建顺序会影响到单元格的顺序，所以对于两个相同的网格，你遍历单元格的顺序可能会发生变化。例如，想想一个有两个单元的1d（粗）网格。如果你先精炼其中的第一个单元，然后再精炼另一个单元，那么你将以不同的顺序遍历精炼层1上的四个单元，而不是先精炼第二个粗单元，再精炼第一个粗单元。 这种顺序对于几乎所有的应用都是完全实用的，因为在大多数情况下，以何种顺序遍历单元实际上并不重要。此外，它允许使用导致特别低的高速缓存失误频率的数据结构，因此对高性能计算应用来说是有效的。 另一方面，在某些情况下，人们希望以特定的、可重复的顺序遍历单元，这只取决于网格本身，而不是其创建历史或任何其他看似任意的设计决定。Z顺序 "是实现这一目标的方法之一。
@image html simple-mesh-0.png "A coarse mesh"   @image html simple-mesh-1.png "The mesh after one refinement cycle"   @image html simple-mesh-2.png "The mesh after two refinement cycles"   @image html simple-mesh-3.png "The mesh after three refinement cycles" 。 注意第2层的单元格是如何按照它们被创建的顺序排列的。这并不总是如此：如果中间有单元格被移除，那么新创建的单元格就会填上这样产生的洞）。 那么deal.II遍历细胞的 "自然 "顺序将是0.0</p>
<p>-&gt; 1.0</p>
<p>-&gt; 1.1</p>
<p>-&gt; 1.2</p>
<p>-&gt; 1.3</p>
<p>-&gt; 2.0</p>
<p>-&gt; 2.1</p>
<p>-&gt; 2.2</p>
<p>-&gt; 2.3</p>
<p>-&gt; 2.4 -&gt; 2.5</p>
<p>-&gt; 2.6</p>
<div class="image">
<img src="simple-mesh-tree.png" alt="simple-mesh-tree.png"/>
<div class="caption">
The tree that corresponds to the mesh after three refinement cycles</div></div>
<p>另一方面，Z顺序对应于树的一个特定的深度优先的遍历。即：从一个单元格开始，如果它有孩子，那么就遍历这些单元格的孩子；只要一个孩子有孩子，这个规则就递归应用。 对于上面给定的网格，这产生了以下的顺序。0.0</p>
<p>-&gt; 1.0</p>
<p>-&gt; 2.4</p>
<p>-&gt; 2.5</p>
<p>-&gt; 2.6</p>
<p>-&gt; 2.7</p>
<p>-&gt; 1.1</p>
<p>-&gt; 1.2</p>
<p>-&gt; 1.3 -&gt; 1.4</p>
<p>-&gt; 2.0</p>
<p>-&gt; 2.1</p>
<p>-&gt; 2.2</p>
<p>-&gt; (同样，如果你只关心活动单元，那么就把0.0、1.0和1.3从这个列表中删除。)因为单元格的子代顺序是明确定义的（相对于每一层内的单元格顺序），这种 "分层
"遍历是有意义的，尤其是独立于一个三角形的历史。 在实践中，它很容易使用递归函数来实现。 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> visit_cells_hierarchically (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;has_children())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;cell-&gt;n_children(); ++c)</div><div class="line">      visit_cells_hierarchically (cell-&gt;child(c));</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      ... <span class="keywordflow">do</span> whatever you wanted to <span class="keywordflow">do</span> on each cell ...;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> 这个函数然后被调用如下。 </p><div class="fragment"><div class="line"><span class="comment">// loop over all coarse mesh cells</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.begin(0);</div><div class="line">     cell != <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.end(); ++cell)</div><div class="line">  visit_cells_hierarchically (cell);</div></div><!-- fragment --><p class="enddd">最后，作为对术语 "Z
"顺序的解释：如果你按照这种分层方式出现的顺序画一条穿过所有单元格的线，那么它在每个精炼的单元格上看起来就像一个左-右倒置的Z。事实上，这样定义的曲线可以被认为是一条空间填充曲线，有时也被称为 "莫顿排序"，见https://en.wikipedia.org/wiki/Z-order_curve 。  </p>
</dd>
</dl>
<p>This glossary explains a few terms that are frequently used in the documentation of classes of deal.II. The glossary often only gives a microscopic view of a particular concept; if you struggle with the bigger picture, it may therefore also be worth to consult the global overview of classes on the <a class="el" href="index.html">index</a> page.</p>
<dl>
<dt class="glossary"><a class="anchor" id="GlossActive"></a><b>Active cells</b> </dt>
<dd><p class="startdd">A cell, face, or edge is defined as <em>active</em> if it is not refined any further, i.e., if it does not have children. Once a cell, face, or edge becomes a parent it is no longer active. Unless working with a multigrid algorithm, active cells are the only ones carrying degrees of freedom. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossArtificialCell"></a><b>Artificial cells</b> </dt>
<dd><p class="startdd">If a mesh is distributed across multiple MPI processes using the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class, each processor stores only the cells it owns, one layer of adjacent cells that are owned by other processors (called <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>), all coarse level cells, and all cells that are necessary to maintain the invariant that adjacent cells must differ by at most one refinement level. The cells stored on each process that are not owned by this process and that are not ghost cells are called "artificial cells", and for these cells the predicate <code>cell-&gt;is_artificial()</code> returns true. Artificial cells are guaranteed to exist in the globally distributed mesh but they may be further refined on other processors. See the <a class="el" href="DEALGlossary.html#distributed_paper">Distributed Computing paper</a> for more information.</p>
<p>The concept of artificial cells has no meaning for triangulations that store the entire mesh on each processor, i.e. the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlockLA"></a><b>Block (linear algebra)</b>  </dt>
<dd><p class="startdd">It is often convenient to treat a matrix or vector as a collection of individual blocks. For example, in <a class="el" href="step_20.html">step-20</a> (and other tutorial programs), we want to consider the global linear system \(Ax=b\) in the form </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} M &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> where \(U,P\) are the values of velocity and pressure degrees of freedom, respectively, \(M\) is the mass matrix on the velocity space, \(B\) corresponds to the negative divergence operator, and \(B^T\) is its transpose and corresponds to the negative gradient.</p>
<p>Using such a decomposition into blocks, one can then define preconditioners that are based on the individual operators that are present in a system of equations (for example the Schur complement, in the case of <a class="el" href="step_20.html">step-20</a>), rather than the entire matrix. In essence, blocks are used to reflect the structure of a PDE system in linear algebra, in particular allowing for modular solvers for problems with multiple solution components. On the other hand, the matrix and right hand side vector can also treated as a unit, which is convenient for example during assembly of the linear system when one may not want to make a distinction between the individual components, or for an outer Krylov space solver that doesn't care about the block structure (e.g. if only the preconditioner needs the block structure).</p>
<p>Splitting matrices and vectors into blocks is supported by the <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, <a class="el" href="classBlockVector.html">BlockVector</a>, and related classes. See the overview of the various linear algebra classes in the <a class="el" href="group__LAC.html">Linear algebra classes</a> module. The objects present two interfaces: one that makes the object look like a matrix or vector with global indexing operations, and one that makes the object look like a collection of sub-blocks that can be individually addressed. Depending on context, one may wish to use one or the other interface.</p>
<p>Typically, one defines the sub-structure of a matrix or vector by grouping the degrees of freedom that make up groups of physical quantities (for example all velocities) into individual blocks of the linear system. This is defined in more detail below in the glossary entry on <a class="el" href="DEALGlossary.html#GlossBlock">Block (finite element)</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlock"></a><b>Block (finite element)</b> </dt>
<dd><p class="startdd"><em>Intent:</em> Blocks are a generalization of <a class="el" href="DEALGlossary.html#GlossComponent">components</a> in that they group together one or more components of a vector-valued finite element that one would like to consider jointly. One often wants to do this to define operators that correspond to the structure of a (part of a) differential operator acting on the vector-valued solution, such as the Schur complement solver in <a class="el" href="step_20.html">step-20</a>, or the block solvers and preconditioners of <a class="el" href="step_22.html">step-22</a>.</p>
<p>For the purpose of a discretization, blocks are the better concept to use since it is not always possible to address individual components of a solution. This is, in particular, the case for non-<a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> elements. Take for instance the solution of the mixed Laplacian system with the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> element (see <a class="el" href="step_20.html">step-20</a>). There, the first <code>dim</code> components are the directional velocities. Since the shape functions are linear combinations of those, these <code>dim</code> components constitute only a single block. On the other hand, the pressure variable is scalar and would form a the second block, but in the <code>dim+1</code>st component.</p>
<p>The minimal size of each block is dictated by the underlying finite element (a block consists of a single component for scalar elements, but in the case of the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>, for example, a block consists of <code>dim</code> components). However, several such minimal blocks can be grouped together into user defined blocks at will, and in accordance with the application. For instance, for the <b>Q</b><sub>2</sub><sup><em>d</em></sup>-<b>Q</b><sub>1</sub> (Taylor-Hood) Stokes element, there are <em>d</em>+1 components each of which could in principle form its own block. But we are typically more interested in having only two blocks, one of which consists of all the velocity vector components (i.e. this block would have <em>d</em> components) and the other having only the single pressure component.</p>
<p><em>Implementation:</em> deal.II has a number of different finite element classes, all of which are derived from the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class (see the <a class="el" href="group__feall.html">module on finite element classes</a>). With one exception, whether they are scalar or vector valued, they all define a single block: all vector components the finite element defines through its <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components()</a> function form a single block, i.e. <a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElement::n_blocks()</a> returns one.</p>
<p>The exception is the <a class="el" href="classFESystem.html">FESystem</a> class that takes multiple simpler elements and connects them into more complicated ones. Consequently, it can have more than one block. A <a class="el" href="classFESystem.html">FESystem</a> has as many blocks as it has base elements times their multiplicity (see the constructors of <a class="el" href="classFESystem.html">FESystem</a> to understand this statement). In other words, it does not care how many blocks each base element has, and consequently you can produce a Stokes element that has only two blocks by creating the object </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div></div><!-- fragment --><p> On the other hand, we could have produced a similar object with dim+1 blocks using </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div></div><!-- fragment --><p> With the exception of the number of blocks, the two objects are the same for all practical purposes, however.</p>
<p><em>Global degrees of freedom:</em> While we have defined blocks above in terms of the vector components of a vector-valued solution function (or, equivalently, in terms of the vector-valued finite element space), every shape function of a finite element is part of one block or another. Consequently, we can partition all degrees of freedom defined on a <a class="el" href="classDoFHandler.html">DoFHandler</a> into individual blocks. Since by default the <a class="el" href="classDoFHandler.html">DoFHandler</a> class enumerates degrees of freedom in a more or less random way, you will first want to call the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function to make sure that all degrees of freedom that correspond to a single block are enumerated consecutively.</p>
<p>If you do this, you naturally partition matrices and vectors into blocks as well (see <a class="el" href="DEALGlossary.html#GlossBlockLA">block (linear algebra)). In most cases, when</a> you subdivide a matrix or vector into blocks, you do so by creating one block for each block defined by the finite element (i.e. in most practical cases the <a class="el" href="classFESystem.html">FESystem</a> object). However, this needs not be so: the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function allows to group several vector components or finite element blocks into the same logical block (see, for example, the <a class="el" href="step_22.html">step-22</a> or <a class="el" href="step_31.html">step-31</a> tutorial programs, as opposed to <a class="el" href="step_20.html">step-20</a>). As a consequence, using this feature, we can achieve the same result, i.e. subdividing matrices into \(2\times 2\) blocks and vectors into 2 blocks, for the second way of creating a Stokes element outlined above using an extra argument as we would have using the first way of creating the Stokes element with two blocks right away.</p>
<p>More information on this topic can be found in the documentation of <a class="el" href="classFESystem.html">FESystem</a>, the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module and the tutorial programs referenced therein.</p>
<p><em>Selecting blocks:</em> Many functions allow you to restrict their operation to certain vector components or blocks. For example, this is the case for the functions that interpolate boundary values: one may want to only interpolate the boundary values for the velocity block of a finite element field but not the pressure block. The way to do this is by passing a <a class="el" href="classBlockMask.html">BlockMask</a> argument to such functions, see the <a class="el" href="DEALGlossary.html#GlossBlockMask">block mask entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlockMask"></a><b>Block mask</b>  </dt>
<dd><p class="startdd">In much the same way as one can think of elements as being composed of physical vector components (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a>) or logical blocks (see <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a>), there is frequently a need to select a set of such blocks for operations that are not intended to be run on <em>all</em> blocks of a finite element space. Selecting which blocks to work on happens using the <a class="el" href="classBlockMask.html">BlockMask</a> class.</p>
<p>Block masks work in much the same way as component masks, including the fact that the <a class="el" href="classBlockMask.html">BlockMask</a> class has similar semantics to the <a class="el" href="classComponentMask.html">ComponentMask</a> class. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary entry on component masks</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>While components and blocks provide two alternate but equally valid viewpoints on finite elements with multiple vector components, the fact is that throughout the library there are far more places where you can pass a <a class="el" href="classComponentMask.html">ComponentMask</a> argument rather than a <a class="el" href="classBlockMask.html">BlockMask</a> argument. Fortunately, one can be converted into the other, using the syntax <code>fe.component_mask(block_mask)</code> where <code>block_mask</code> is a variable of type <a class="el" href="classBlockMask.html">BlockMask</a>. In other words, if you have a block mask but need to call a function that only accepts a component mask, this syntax can be used to obtain the necessary component mask.</dd></dl>
<p><b>Creation of block masks:</b> Block masks are typically created by asking the finite element to generate a block mask from certain selected vector components using code such as this where we create a mask that only denotes the velocity components of a Stokes element (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>): </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1),                     1);     <span class="comment">// Q1 element for the pressure</span></div><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.block_mask (pressure);</div></div><!-- fragment --><p> The result is a block mask that, in 1d as well as 2d and 3d, would have values <code>[false, true]</code>. Similarly, using </p><div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> velocity_mask = stokes_fe.block_mask (velocities);</div></div><!-- fragment --><p> would result in a mask <code>[true, false]</code> in any dimension.</p>
<p>Note, however, that if we had defined the finite element in the following way: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div></div><!-- fragment --><p> then the code </p><div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (pressure);</div></div><!-- fragment --><p> would yield a block mask that in 2d has elements <code>[false, false, true]</code> because the element has <code>dim+1</code> components and equally many blocks. See the discussion on what a block represents exactly in the <a class="el" href="DEALGlossary.html#GlossBlock">block entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBoundaryForm"></a><b>Boundary form</b>  </dt>
<dd><p class="startdd">For a dim-dimensional triangulation in dim-dimensional space, the boundary form is a vector defined on faces. It is the vector product of the image of coordinate vectors on the surface of the unit cell. It is a vector normal to the surface, pointing outwards and having the length of the surface element.</p>
<p>A more general definition would be that (at least up to the length of this vector) it is exactly that vector that is necessary when considering integration by parts, i.e. equalities of the form \(\int_\Omega \text{div} \vec \phi = -\int_{\partial\Omega} \vec n \cdot \vec \phi\). Using this definition then also explains what this vector should be in the case of domains (and corresponding triangulations) of dimension <code>dim</code> that are embedded in a space <code>spacedim</code>: in that case, the boundary form is still a vector defined on the faces of the triangulation; it is orthogonal to all tangent directions of the boundary and within the tangent plane of the domain. Note that this is compatible with case <code>dim==spacedim</code> since there the tangent plane is the entire space \({\mathbb R}^\text{dim}\).</p>
<p>In either case, the length of the vector equals the determinant of the transformation of reference face to the face of the current cell. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBoundaryIndicator"></a><b>Boundary indicator</b>  </dt>
<dd><p class="startdd">In a <a class="el" href="classTriangulation.html">Triangulation</a> object, every part of the boundary may be associated with a unique number (of type <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) that is used to determine what kinds of boundary conditions are to be applied to a particular part of a boundary. The boundary is composed of the faces of the cells and, in 3d, the edges of these faces.</p>
<p>By default, all boundary indicators of a mesh are zero, unless you are reading from a mesh file that specifically sets them to something different, or unless you use one of the mesh generation functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> that have a <a class="el" href="DEALGlossary.html#GlossColorization">colorize</a> option. A typical piece of code that sets the boundary indicator on part of the boundary to something else would look like this, here setting the boundary indicator to 42 for all faces located at \(x=-1\): </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_face_iterators())</div><div class="line">  <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;center()[0] == -1)</div><div class="line">      face-&gt;set_boundary_id (42);</div></div><!-- fragment --><p> This calls functions <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">TriaAccessor::set_boundary_id</a>. In 3d, it may also be appropriate to call <a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">TriaAccessor::set_all_boundary_ids</a> instead on each of the selected faces. To query the boundary indicator of a particular face or edge, use <a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">TriaAccessor::boundary_id</a>.</p>
<p>Many of the functions in namespaces <a class="el" href="namespaceDoFTools.html">DoFTools</a> and <a class="el" href="namespaceVectorTools.html">VectorTools</a> take arguments that specify which part of the boundary to work on, and they specifically refer to boundary_ids. Examples are <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a>, <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>, <a class="el" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a> and <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Boundary indicators are inherited from mother faces and edges to their children upon mesh refinement. Some more information about boundary indicators is also presented in a section of the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class.</dd>
<dd>
For parallel triangulations of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, it is not enough to set boundary indicators only once at the beginning. See the long discussion on this topic in the class documentation of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> . </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCoarseMesh"></a><b>Coarse mesh</b> </dt>
<dd><p class="startdd">A "coarse mesh" in deal.II is a triangulation object that consists only of cells that are not refined, i.e., a mesh in which no cell is a child of another cell. This is generally how triangulations are first constructed in deal.II, for example using (most of) the functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>, the functions in class <a class="el" href="classGridIn.html">GridIn</a>, or directly using the function <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a>. One can of course do computations on such meshes, but most of the time (see, for example, almost any of the tutorial programs) one first refines the coarse mesh globally (using <a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global()</a>), or adaptively (in that case first computing a refinement criterion, then one of the functions in namespace <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>, and finally calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a>). The mesh is then no longer a "coarse mesh", but a "refined mesh".</p>
<p>In some contexts, we also use the phrase "the coarse mesh of a
     triangulation", and by that mean that set of cells that the triangulation started out with, i.e., from which all the currently <a class="el" href="DEALGlossary.html#GlossActive">active cells</a> of the triangulation have been obtained by mesh refinement. (Some of the coarse mesh cells may of course also be active if they have never been refined.)</p>
<p><a class="el" href="classTriangulation.html">Triangulation</a> objects store cells in <em>levels</em>: in particular, all cells of a coarse mesh are on level zero. Their children (if we executed <code>Triangulation::refine_global(1)</code> on a coarse mesh) would then be at level one, etc. The coarse mesh of a triangulation (in the sense of the previous paragraph) then consists of exactly the level-zero cells of a triangulation. (Whether they are active (i.e., have no children) or have been refined is not important for this definition.)</p>
<p>Most of the triangulation classes in deal.II store the entire coarse mesh along with at least some of the refined cells. (Both the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> classes actually store <em>all</em> cells of the entire mesh, whereas some other classes such as <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> only store <em>some</em> of the <a class="el" href="DEALGlossary.html#GlossActive">active cells</a> on each process in a parallel computation.) In those cases, one can query the triangulation for all coarse mesh cells. Other triangulation classes (e.g., <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>) only store a part of the coarse mesh. See also <a class="el" href="DEALGlossary.html#GlossCoarseCellId">the concept of coarse cell ids</a> for that case. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCoarseCellId"></a><b>Coarse cell ID</b> </dt>
<dd><p class="startdd">Most of the triangulation classes in deal.II, notably <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, store the entire <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a> of a triangulation on each process of a parallel computation. On the other hand, this is not the case for other classes, notably for <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>, which is designed for cases where even the coarse mesh is too large to be stored on each process and needs to be partitioned.</p>
<p>In those cases, it is often necessary in algorithms to reference a coarse mesh cell uniquely. Because the triangulation object on the current process does not actually store the entire coarse mesh, one needs to have a globally unique identifier for each coarse mesh cell that is independent of the index within level zero of the triangulation stored locally. This globally unique ID is called the "coarse cell ID". It can be accessed via the function call </p><div class="fragment"><div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.coarse_cell_index_to_coarse_cell_id (coarse_cell-&gt;index());</div></div><!-- fragment --><p> where <code>triangulation</code> is the triangulation to which the iterator <code>coarse_cell</code> pointing to a cell at level zero belongs. Here, <code>coarse_cell-&gt;index()</code> returns the index of that cell within its refinement level (see <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">TriaAccessor::index()</a>). This is a number between zero and the number of coarse mesh cells stored on the current process in a parallel computation; it uniquely identifies a cell on that parallel process, but different parallel processes may use that index for different cells located at different coordinates.</p>
<p>For those classes that store all coarse mesh cells on each process, the <a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">Triangulation::coarse_cell_index_to_coarse_cell_id()</a> simply returns a permutation of the possible argument values. In the simplest cases, such as for a sequential or a parallel shared triangulation, the function will in fact simply return the value of the argument. For others, such as <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, the ordering of coarse cell IDs is not the same as the ordering of coarse cell indices. Finally, for classes such as <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>, the function returns the globally unique ID, which is from a larger set of possible indices than the indices of the coarse cells actually stored on the current process. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossColorization"></a><b>Colorization</b> </dt>
<dd><p class="startdd"><em>Colorization</em> is the process of marking certain parts of a <a class="el" href="classTriangulation.html">Triangulation</a> with different labels. The use of the word <em>color</em> comes from cartography, where countries on a map are made visually distinct from each other by assigning them different colors. Using the same term <em>coloring</em> is common in mathematics, even though we assign integers and not hues to different regions. deal.II refers to two processes as coloring:</p>
<ol>
<li>
Most of the functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace take an optional argument <code>colorize</code>. This argument controls whether or not the different parts of the boundary will be assigned different <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">boundary indicators</a>. Some functions also assign different <a class="el" href="DEALGlossary.html#GlossMaterialId">material indicators</a> as well. </li>
<li>
The function <a class="el" href="namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">GraphColoring::make_graph_coloring()</a> computes a decomposition of a <a class="el" href="classTriangulation.html">Triangulation</a> (more exactly, a range of iterators). No two adjacent cells are given the same color. </li>
</ol>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossComponent"></a><b>Component</b>  </dt>
<dd><p class="startdd">When considering systems of equations in which the solution is not just a single scalar function, we say that we have a <em>vector system</em> with a <em>vector-valued solution</em>. For example, the vector solution in the elasticity equation considered in <a class="el" href="step_8.html">step-8</a> is \(u=(u_x,u_y,u_z)^T\) consisting of the displacements in each of the three coordinate directions. The solution then has three elements. Similarly, the 3d Stokes equation considered in <a class="el" href="step_22.html">step-22</a> has four elements: \(u=(v_x,v_y,v_z,p)^T\). We call the elements of the vector-valued solution <em>components</em> in deal.II. To be well-posed, for the solution to have \(n\) components, there need to be \(n\) partial differential equations to describe them. This concept is discussed in great detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p>In finite element programs, one frequently wants to address individual elements (components) of this vector-valued solution, or sets of components. For example, we do this extensively in <a class="el" href="step_8.html">step-8</a>, and a lot of documentation is also provided in the module on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>. If you are thinking only in terms of the partial differential equation (not in terms of its discretization), then the concept of <em>components</em> is the natural one.</p>
<p>On the other hand, when talking about finite elements and degrees of freedom, <em>components</em> are not always the correct concept because components are not always individually addressable. In particular, this is the case for <a class="el" href="DEALGlossary.html#GlossPrimitive">non-primitive finite elements</a>. Similarly, one may not always <em>want</em> to address individual components but rather sets of components &mdash; e.g. all velocity components together, and separate from the pressure in the Stokes system, without further splitting the velocities into their individual components. In either case, the correct concept to think in is that of a <a class="el" href="DEALGlossary.html#GlossBlock">block</a>. Since each component, if individually addressable, is also a block, thinking in terms of blocks is most frequently the better strategy.</p>
<p>For a given finite element, the number of components can be queried using the <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElementData::n_components()</a> function, and you can find out which vector components are nonzero for a given finite element shape function using <a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">FiniteElement::get_nonzero_components()</a>. The values and gradients of individual components of a shape function (if the element is primitive) can be queried using the <a class="el" href="classFiniteElement.html#a247fccbd72723a07fc8c17ac093d3156">FiniteElement::shape_value_component()</a> and <a class="el" href="classFiniteElement.html#a7f026ed19fcc589476f11d69de4a3419">FiniteElement::shape_grad_component()</a> functions on the reference cell. The <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">FEValues::shape_value_component()</a> and <a class="el" href="classFEValuesBase.html#a71e93aa182f3acd34abd020538f3bc39">FEValues::shape_grad_component()</a> functions do the same on a real cell. See also the documentation of the <a class="el" href="classFiniteElement.html">FiniteElement</a> and <a class="el" href="classFEValues.html">FEValues</a> classes.</p>
<p><em>Selecting components:</em> Many functions allow you to restrict their operation to certain vector components or blocks. For example, this is the case for the functions that interpolate boundary values: one may want to only interpolate the boundary values for the velocity components of a finite element field but not the pressure component. The way to do this is by passing a <a class="el" href="classComponentMask.html">ComponentMask</a> argument to such functions, see the <a class="el" href="DEALGlossary.html#GlossComponentMask">component mask entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossComponentMask"></a><b>Component mask</b>  </dt>
<dd><p class="startdd">When using vector-valued elements (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>) to solve systems of equations, one frequently wants to restrict some operations to only certain solution variables. For example, when solving the Stokes equations, one may wish to only interpolate boundary values for the velocity components but not the pressure. In deal.II, this is typically done by passing functions a <em>component mask</em>. Component masks are always specified as a <a class="el" href="classComponentMask.html">ComponentMask</a> object which one can think of as an array with as many entries as the finite element has components (e.g., in the Stokes case, there are <code>dim+1</code> components) and where each entry is either true or false. In the example where we would like to interpolate boundary values only for the velocity components of the Stokes system, this component mask would then be <code>[true, true, false]</code> in 2d and <code>[true, true, true, false]</code> in 3d to indicate that no boundary values shall be set for the pressure variable (the last of the <code>dim+1</code> vector components of the solution.</p>
<p>There are many functions that take such component masks, for example DoFTools::make_zero_boundary_values, <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, <a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator::estimate</a>, etc. In some cases, there are multiple functions with these names but only some of them have a component mask argument.</p>
<p><b>Semantics of component masks:</b> Many of the functions that take a component mask object that has been default constructed to indicate <em>all components</em>, i.e., as if the vector had the correct length and was filled with only <code>true</code> values. The reason is that default initialized objects can be constructed in place using the code snippet <code><a class="el" href="classComponentMask.html">ComponentMask()</a></code> and can thus be used as a default argument in function signatures.</p>
<p>In other words, <a class="el" href="classComponentMask.html">ComponentMask</a> objects can be in one of two states: They can have been initialized by a vector of booleans with a nonzero length; in that case, they represent a mask of a particular length where some elements may be true and others may be false. Or, the <a class="el" href="classComponentMask.html">ComponentMask</a> may have been default initialized (using the default constructor) in which case it represents an array of indefinite length (i.e., a length appropriate to the circumstances) in which <em>every entry</em> is true.</p>
<p><b>Creation of component masks:</b> Component masks are typically created by asking the finite element to generate a component mask from certain selected components using code such as this where we create a mask that only denotes the velocity components of a Stokes element (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>): </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> pressure_mask = stokes_fe.component_mask (pressure);</div></div><!-- fragment --><p> The result is a component mask that, in 2d, would have values <code>[false, false, true]</code>. Similarly, using </p><div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> velocity_mask = stokes_fe.component_mask (velocities);</div></div><!-- fragment --><p> would result in a mask <code>[true, true, false]</code> in 2d. Of course, in 3d, the result would be <code>[true, true, true, false]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Just as one can think of composed elements as being made up of <a class="el" href="DEALGlossary.html#GlossComponent">components</a> or <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a>, there are component masks (represented by the <a class="el" href="classComponentMask.html">ComponentMask</a> class) and <a class="el" href="DEALGlossary.html#GlossBlockMask">block masks</a> (represented by the <a class="el" href="classBlockMask.html">BlockMask</a> class). The <a class="el" href="classFiniteElement.html">FiniteElement</a> class has functions that convert between the two kinds of objects.</dd>
<dd>
Not all component masks actually make sense. For example, if you have a <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object in 2d, then it doesn't make any sense to have a component mask of the form <code>[true, false]</code> because you try to select individual vector components of a finite element where each shape function has both \(x\) and \(y\) velocities. In essence, while you can of course create such a component mask, there is nothing you can do with it. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCompress"></a><b>Compressing distributed vectors and matrices</b>  </dt>
<dd><p class="startdd">For parallel computations, deal.II uses the vector and matrix classes defined in the <a class="el" href="namespacePETScWrappers.html">PETScWrappers</a> and <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> namespaces. When running programs in parallel using MPI, these classes only store a certain number of rows or elements on the current processor, whereas the rest of the vector or matrix is stored on the other processors that belong to our MPI universe. This presents a certain problem when you assemble linear systems: we add elements to the matrix and right hand side vectors that may or may not be stored locally. Sometimes, we may also want to just <em>set</em> an element, not add to it.</p>
<p>Both PETSc and Trilinos allow adding to or setting elements that are not locally stored. In that case, they write the value that we want to store or add into a cache, and we need to call one of the functions <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">TrilinosWrappers::VectorBase::compress()</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">TrilinosWrappers::SparseMatrix::compress()</a>, <a class="el" href="classPETScWrappers_1_1VectorBase.html#a6166fa37985a73755a2982af055f1a0a">PETScWrappers::VectorBase::compress()</a> or <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">PETScWrappers::MatrixBase::compress()</a> which will then ship the values in the cache to the MPI process that owns the element to which it is supposed to be added or written to. Due to the MPI model that only allows to initiate communication from the sender side (i.e. in particular, it is not a remote procedure call), these functions are collective, i.e. they need to be called by all processors.</p>
<p>There is one snag, however: both PETSc and Trilinos need to know whether the operation that these <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> functions invoke applies to adding elements or setting them. In some cases, not all processors may be adding elements, for example if a processor does not own any cells when using a very <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a>. For this reason, <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> takes an argument of type <a class="el" href="structVectorOperation.html">VectorOperation</a>, which can be either ::add, or ::insert. This argument is required for vectors and matrices starting with the 7.3 release.</p>
<p>In short, you need to call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> in the following cases (and only in those cases, though calling <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> in other cases just costs some performance):</p>
<ol type="1">
<li>At the end of your assembly loop on matrices and vectors. This needs to be done if you write entries directly or if you use <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a>. Use <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>.</li>
<li>When you are done setting individual elements in a matrix/vector before any other operations are done (adding to elements, other operations like scaling, solving, reading, etc.). Use <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>.</li>
<li>Like in 2., but for adding values to individual elements. Use <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>.</li>
</ol>
<p>All other operations like scaling or adding vectors, assignments, calls into deal.II (<a class="el" href="namespaceVectorTools.html">VectorTools</a>, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, ...) or solvers do not require calls to <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Compressing is an operation that only applies to vectors whose elements are uniquely owned by one and only one processor in a parallel MPI universe. It does not apply to <a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a>.</dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossConcept"></a><b>Concepts in deal.II</b>  </dt>
<dd><p class="startdd">There are several places in deal.II where we require that a type in a template match a certain interface or behave in a certain way: such constraints are called <em>concepts</em> in C++. See the discussion in <a class="el" href="group__Concepts.html">Concepts, or expectations on template parameters</a> for more information and a list of concepts in deal.II. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDimension"></a><b>Dimensions <code>dim</code> and <code>spacedim</code></b>  </dt>
<dd><p class="startdd">Many classes and functions in deal.II have two template parameters, <code>dim</code> and <code>spacedim</code>. An example is the basic <a class="el" href="classTriangulation.html">Triangulation</a> class: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim=dim&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classTriangulation.html">Triangulation</a> {...};</div></div><!-- fragment --><p> In all of these contexts where you see <code>dim</code> and <code>spacedim</code> referenced, these arguments have the following meaning:</p>
<ul>
<li>
<p class="startli"><code>dim</code> denotes the dimensionality of the mesh. For example, a mesh that consists of line segments is one-dimensional and consequently corresponds to <code>dim==1</code>. A mesh consisting of quadrilaterals then has <code>dim==2</code> and a mesh of hexahedra has <code>dim==3</code>.</p>
<p class="endli"></p>
</li>
<li>
<code>spacedim</code> denotes the dimensionality of the space in which such a mesh lives. Generally, one-dimensional meshes live in a one-dimensional space, and similarly for two-dimensional and three-dimensional meshes that subdivide two- and three-dimensional domains. Consequently, the <code>spacedim</code> template argument has a default equal to <code>dim</code>. But this need not be the case: For example, we may want to solve an equation for sediment transport on the surface of the Earth. In this case, the domain is the two-dimensional surface of the Earth (<code>dim==2</code>) that lives in a three-dimensional coordinate system (<code>spacedim==3</code>). </li>
</ul>
<p>More generally, deal.II can be used to solve partial differential equations on <a href="https://en.wikipedia.org/wiki/Manifold">manifolds</a> that are embedded in higher dimensional space. In other words, these two template arguments need to satisfy <code>dim &lt;= spacedim</code>, though in many applications one simply has <code>dim == spacedim</code>.</p>
<p>Following the convention in geometry, we say that the "codimension" is defined as <code>spacedim-dim</code>. In other words, a triangulation consisting of quadrilaterals whose coordinates are three-dimensional (for which we would then use a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> object) has "codimension one".</p>
<p>Examples of uses where these two arguments are not the same are shown in <a class="el" href="step_34.html">step-34</a>, <a class="el" href="step_38.html">step-38</a>, <a class="el" href="step_54.html">step-54</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDoF"></a><b>Degree of freedom</b>  </dt>
<dd><p class="startdd">The term "degree of freedom" (often abbreviated as "DoF") is commonly used in the finite element community to indicate two slightly different, but related things. The first is that we'd like to represent the finite element solution as a linear combination of shape functions, in the form \(u_h(\mathbf{x}) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf{x})\). Here, \(U_j\) is a vector of expansion coefficients. Because we don't know their values yet (we will compute them as the solution of a linear or nonlinear system), they are called "unknowns" or "degrees of freedom". The second meaning of the term can be explained as follows: A mathematical description of finite element problem is often to say that we are looking for a finite dimensional function \(u_h \in V_h\) that satisfies some set of equations (e.g. \(a(u_h,\varphi_h)=(f,\varphi_h)\) for all test functions \(\varphi_h\in V_h\)). In other words, all we say here that the solution needs to lie in some space \(V_h\). However, to actually solve this problem on a computer we need to choose a basis of this space; this is the set of shape functions \(\varphi_j(\mathbf{x})\) we have used above in the expansion of \(u_h(\mathbf x)\) with coefficients \(U_j\). There are of course many bases of the space \(V_h\), but we will specifically choose the one that is described by the finite element functions that are traditionally defined locally on the cells of the mesh. Describing "degrees of freedom" in this context requires us to simply <em>enumerate</em> the basis functions of the space \(V_h\). For \(Q_1\) elements this means simply enumerating the vertices of the mesh in some way, but for higher elements one also has to enumerate the shape functions that are associated with edges, faces, or cell interiors of the mesh. The class that provides this enumeration of the basis functions of \(V_h\) is called <a class="el" href="classDoFHandler.html">DoFHandler</a>. The process of enumerating degrees of freedom is referred to as "distributing DoFs" in deal.II. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDirectionFlag"></a><b>Direction flags</b>  </dt>
<dd><p class="startdd">The <em>direction flag</em> is used in triangulations embedded in a higher dimensional space to denote the orientation of cells and make the manifold oriented. It is accessed using <a class="el" href="classCellAccessor.html#ae146ea059e9c27cb3e040b92d5c4e152">CellAccessor::direction_flag()</a> and set by the <a class="el" href="classTriangulation.html">Triangulation</a> class upon creation of a triangulation. You can change all direction flags of a triangulation using the <a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">Triangulation::flip_all_direction_flags()</a> function.</p>
<p>The flag is necessary to make cases like this work: assume we have a one-dimensional mesh embedded in a two-dimensional space,</p>
<div class="image">
<img src="direction_flag.png" alt="direction_flag.png"/>
<div class="caption">
One dimensional mesh in two dimensions</div></div>
<p> In one dimensional meshes in one dimensional space, we can always make sure that the location of the left vertex of a cell has a smaller value than the location of the right vertex. However, if we embed a mesh in a higher dimensional space, we can no longer do this. For example, the cells in the mesh above may be described by the following vertex sets: <code>(0,1), (1,2), (3,2), (4,3), (4,5)</code>. (As a side remark, note that here we have vertices &ndash; e.g. vertex 2 &ndash; that are the right end points of more than one cell.) If we define the normal to each cell as that unit vector that is right perpendicular to the vector that connects the first to the second vertex of the line, then we would end up with the following picture:</p>
<div class="image">
<img src="direction_flag_normals.png" alt="direction_flag_normals.png"/>
<div class="caption">
Normal vectors</div></div>
<p> In other words, this one-dimensional manifold is not oriented. We could in principle revert the order of vertices when creating such a mesh (though there are good reasons not to do so, for example because this mesh may have resulted from extracting the surface mesh of a two dimensional mesh, and we want to preserve the order of vertices of each line segment because they currently match the order of vertices of the faces of the 2d cells). An alternative strategy, chosen in deal.II, is to simply associate with each cell whether the normal should be the left or right normal to the cell. (The default is right normals.) In the example above, the flags for the five cells would be <code>true, true, false, false, true</code>. Multiplying the right normal with plus or minus one, depending on the value of the flag on each cell, yields a set of normal vectors that orient the manifold.</p>
<p>Similar issues happen with two-dimensional meshes in three space dimensions. We note that it would not be possible to find consistent direction flags if the two-dimensional manifold is not orientable; such manifolds are not currently supported by deal.II. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDistorted"></a><b>Distorted cells</b>  </dt>
<dd><p class="startdd">A <em>distorted cell</em> is a cell for which the mapping from the reference cell to real cell has a Jacobian whose determinant is non-positive somewhere in the cell. Typically, we only check the sign of this determinant at the vertices of the cell. The function <a class="el" href="structGeometryInfo.html#af047ab1fe45077a53df9cd8212fc790c">GeometryInfo::alternating_form_at_vertices</a> computes these determinants at the vertices.</p>
<p>By way of example, if all of the determinants are of roughly equal value and on the order of \(h^\text{dim}\) then the cell is well-shaped. For example, a square cell or face has determinants equal to \(h^\text{dim}\) whereas a strongly sheared parallelogram has a determinant much smaller. Similarly, a cell with very unequal edge lengths will have widely varying determinants. Conversely, a pinched cell in which the location of two or more vertices is collapsed to a single point has a zero determinant at this location. Finally, an inverted or twisted cell in which the location of two vertices is out of order will have negative determinants.</p>
<p>The following two images show a well-formed, a pinched, and a twisted cell for both 2d and 3d:</p>
<div class="image">
<img src="distorted_2d.png" alt="distorted_2d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 2d.</div></div>
 <div class="image">
<img src="distorted_3d.png" alt="distorted_3d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 3d.</div></div>
<p> Distorted cells can appear in two different ways: The original <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a> can already contain such cells, or they can be created as the result of moving or distorting a mesh by a relatively large amount.</p>
<p>If the appropriate flag is given upon creation of a triangulation, the function <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation</a>, which is called by the various functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> and <a class="el" href="classGridIn.html">GridIn</a> (but can also be called from user code, see <a class="el" href="step_14.html">step-14</a> and the example at the end of <a class="el" href="step_49.html">step-49</a>), will signal the creation of coarse meshes with distorted cells by throwing an exception of type <a class="el" href="structTriangulation_1_1DistortedCellList.html">Triangulation::DistortedCellList</a>. There are legitimate cases for creating meshes with distorted cells (in particular collapsed/pinched cells) if you don't intend to assemble anything on these cells. For example, consider a case where one would like to simulate the behavior of an elastic material with a fluid-filled crack such as an oil reservoir. If the pressure becomes too large, the crack is closed &ndash; and the cells that discretize the crack volume are collapsed to zero volume. As long as you don't integrate over these cells to simulate the behavior of the fluid (of which there isn't any if the crack has zero volume), such meshes are perfectly legitimate. As a consequence, <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation</a> does not simply abort the program, but throws an exception that contains a list of cells that are distorted; this exception can be caught and, if you believe that you can ignore this condition, you can react by doing nothing with the caught exception.</p>
<p>The function <a class="el" href="namespaceGridTools.html#a1c7bb95bc2bbb09d6f02651d7be1527d">GridTools::fix_up_distorted_child_cells</a> can, in some cases, fix distorted cells on refined meshes by moving around the vertices of a distorted child cell that has an undistorted parent.</p>
<p>Note that the <a class="el" href="classTriangulation.html">Triangulation</a> class does not test for the presence of distorted cells by default, since the determination whether a cell is distorted or not is not a cheap operation. If you want a <a class="el" href="classTriangulation.html">Triangulation</a> object to test for distortion of cells, you need to specify this upon creation of the object by passing the appropriate flag. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="distributed_paper"></a> <b>Distributed computing paper</b>  </dt>
<dd><p class="startdd">The "distributed computing paper" is a paper by W. Bangerth, C. Burstedde, T. Heister and M. Kronbichler titled "Algorithms and Data
   Structures for Massively Parallel Generic Finite Element Codes" that describes the implementation of parallel distributed computing in deal.II, i.e. computations where not only the linear system is split onto different machines as in, for example, <a class="el" href="step_17.html">step-17</a>, but also the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. In essence, it is a guide to the <a class="el" href="namespaceparallel_1_1distributed.html">parallel::distributed</a> namespace and the techniques used in <a class="el" href="step_40.html">step-40</a>.</p>
<p>The full reference for the paper is as follows: </p><div class="fragment"><div class="line">@Article{BBHK11,</div><div class="line">  author =       {Wolfgang Bangerth and Carsten Burstedde and Timo Heister</div><div class="line">                  and Martin Kronbichler},</div><div class="line">  title =        {Algorithms and data structures for massively parallel generic</div><div class="line">  adaptive finite element codes},</div><div class="line">  journal =      {ACM Trans. Math. Softw.},</div><div class="line">  year =         2011,</div><div class="line">  volume =       38,</div><div class="line">  pages =        {14/1--28}}</div></div><!-- fragment --><p>For massively parallel computations, deal.II builds on the <a href="http://www.p4est.org/" target="_top">p4est</a> library. If you use this functionality, please also cite the p4est paper listed at their website. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossFaceOrientation"></a><b>Face orientation</b> </dt>
<dd><p class="startdd">In a triangulation, the normal vector to a face can be deduced from the face orientation by applying the right hand side rule (x,y -&gt; normal). We note, that in the standard orientation of faces in 2d, faces 0 and 2 have normals that point into the cell, and faces 1 and 3 have normals pointing outward. In 3d, faces 0, 2, and 4 have normals that point into the cell, while the normals of faces 1, 3, and 5 point outward. This information, again, can be queried from <a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">GeometryInfo&lt;dim&gt;::unit_normal_orientation</a>.</p>
<p>However, it turns out that a significant number of 3d meshes cannot satisfy this convention. This is due to the fact that the face convention for one cell already implies something for the neighbor, since they share a common face and fixing it for the first cell also fixes the normal vectors of the opposite faces of both cells. It is easy to construct cases of loops of cells for which this leads to cases where we cannot find orientations for all faces that are consistent with this convention.</p>
<p>For this reason, above convention is only what we call the <em>standard orientation</em>. deal.II actually allows faces in 3d to have either the standard direction, or its opposite, in which case the lines that make up a cell would have reverted orders, and the normal vector would have the opposite direction. You can ask a cell whether a given face has standard orientation by calling <code>cell-&gt;face_orientation(face_no)</code>: if the result is <code>true</code>, then the face has standard orientation, otherwise its normal vector is pointing the other direction. There are not very many places in application programs where you need this information actually, but a few places in the library make use of this. Note that in 2d, the result is always <code>true</code>. However, while every face in 2d is always in standard orientation, you can sometimes specify something to assume that this is not so; an example is the function <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a>.</p>
<p>There are two other flags that describe the orientation of a face: face_flip and face_rotation. Some documentation for these exists in the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. An example of their use in user code is given in the <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> function. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossGeneralizedSupport"></a><b>Generalized support points</b> </dt>
<dd><p class="startdd">"Generalized support points" are, as the name suggests, a generalization of <a class="el" href="DEALGlossary.html#GlossSupport">support points</a>. The latter are used to describe that a finite element simply <em>interpolates</em> values at individual points (the "support points"). If we call these points \(\hat{\mathbf{x}}_i\) (where the hat indicates that these points are defined on the reference cell \(\hat{K}\)), then one typically defines shape functions \(\varphi_j(\mathbf{x})\) in such a way that the <em>nodal functionals</em> \(\Psi_i[\cdot]\) simply evaluate the function at the support point, i.e., that \(\Psi_i[\varphi]=\varphi(\hat{\mathbf{x}}_i)\), and the basis is chosen so that \(\Psi_i[\varphi_j]=\delta_{ij}\) where \(\delta_{ij}\) is the Kronecker delta function. This leads to the common <a class="el" href="DEALGlossary.html#GlossLagrange">Lagrange elements</a>.</p>
<p>(In the vector valued case, the only other piece of information besides the support points \(\hat{\mathbf{x}}_i\) that one needs to provide is the <em>vector component</em> \(c(i)\) the \(i\)th node functional corresponds, so that \(\Psi_i[\varphi]=\varphi(\hat{\mathbf{x}}_i)_{c(i)}\).)</p>
<p>On the other hand, there are other kinds of elements that are not defined this way. For example, for the lowest order Raviart-Thomas element (see the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class), the node functional evaluates not individual components of a vector-valued finite element function with <code>dim</code> components, but the <em>normal component</em> of this vector: \(\Psi_i[\varphi] = \varphi(\hat{\mathbf{x}}_i) \cdot \mathbf{n}_i \), where the \(\mathbf{n}_i\) are the normal vectors to the face of the cell on which \(\hat{\mathbf{x}}_i\) is located. In other words, the node functional is a <em>linear combination</em> of the components of \(\varphi\) when evaluated at \(\hat{\mathbf{x}}_i\). Similar things happen for the BDM, ABF, and Nedelec elements (see the <a class="el" href="classFE__BDM.html">FE_BDM</a>, <a class="el" href="classFE__ABF.html">FE_ABF</a>, <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> classes).</p>
<p>In these cases, the element does not have <em>support points</em> because it is not purely interpolatory; however, some kind of interpolation is still involved when defining shape functions as the node functionals still require point evaluations at special points \(\hat{\mathbf{x}}_i\). In these cases, we call the points <em>generalized support points</em>.</p>
<p>Finally, there are elements that still do not fit into this scheme. For example, some hierarchical basis functions (see, for example the <a class="el" href="classFE__Q__Hierarchical.html">FE_Q_Hierarchical</a> element) are defined so that the node functionals are <em>moments</em> of finite element functions, \(\Psi_i[\varphi] = \int_{\hat{K}} \varphi(\hat{\mathbf{x}}) {\hat{x}_1}^{p_1(i)} {\hat{x}_2}^{p_2(i)} \) in 2d, and similarly for 3d, where the \(p_d(i)\) are the order of the moment described by shape function \(i\). Some other elements use moments over edges or faces. In all of these cases, node functionals are not defined through interpolation at all, and these elements then have neither support points, nor generalized support points. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="geometry_paper"></a><b>geometry paper</b> </dt>
<dd><p class="startdd">The "geometry paper" is a paper by L. Heltai, W. Bangerth, M. Kronbichler, and A. Mola, titled "Using exact geometry information in finite element computations", that describes how deal.II describes the geometry of domains. In particular, it discusses the algorithmic foundations on which the <a class="el" href="classManifold.html">Manifold</a> class is based, and what kind of information it needs to provide for mesh refinement, the computation of normal vectors, and the many other places where geometry enters into finite element computations.</p>
<p>The paper is currently available on arXiv at <a href="https://arxiv.org/abs/1910.09824">https://arxiv.org/abs/1910.09824</a> . The full reference for this paper is as follows: </p><div class="fragment"><div class="line">@misc{heltai2019using,</div><div class="line">    title={Using exact geometry information in finite element computations},</div><div class="line">    author={Luca Heltai and Wolfgang Bangerth and Martin Kronbichler and Andrea Mola},</div><div class="line">    year={2019},</div><div class="line">    eprint={1910.09824},</div><div class="line">    archivePrefix={arXiv},</div><div class="line">    primaryClass={math.NA}</div><div class="line">}</div></div><!-- fragment --> <p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossGhostCell"></a><b>Ghost cells</b> </dt>
<dd><p class="startdd">If a mesh is distributed across multiple MPI processes using the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class, each processor stores only the cells it owns, one layer of adjacent cells that are owned by other processors, all <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse level cells</a>, and all cells that are necessary to maintain the invariant that adjacent cells must differ by at most one refinement level. The cells stored on each process that are not owned by this process but that are adjacent to the ones owned by this process are called "ghost cells", and for these cells the predicate <code>cell-&gt;is_ghost()</code> returns true. Ghost cells are guaranteed to exist in the globally distributed mesh, i.e. these cells are actually owned by another process and are not further refined there. See the <a class="el" href="DEALGlossary.html#distributed_paper">Distributed Computing paper</a> for more information.</p>
<p>The layer of ghost cells consists of all cells that are face, edge, or vertex neighbors of any locally owned cell and that are not locally owned themselves. In other word, the ghost cells completely enclose the subdomain of locally owned cells (with the exception of the boundary of the domain, of course).</p>
<p>The concept of ghost cells has no meaning for triangulations that store the entire mesh on each processor, i.e. the <a class="el" href="classTriangulation.html">Triangulation</a> and the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> classes. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossGhostedVector"></a><b>Ghosted vectors</b> </dt>
<dd><p class="startdd">In parallel computations, vectors come in two general kinds: without and with ghost elements. Vectors without ghost elements uniquely partition the vector elements between processors: each vector entry has exactly one processor that owns it, and this is the only processor that stores the value of this entry. In other words, if processor zero stores elements 0...49 of a vector and processor one stores elements 50...99, then processor one is out of luck accessing element 42 of this vector: it is not stored here and the value can not be assessed. This will result in an assertion.</p>
<p>On the other hand, there are many situations where one needs to know vector elements that aren't locally owned, for example to evaluate the solution on a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>) for which one of the degrees of freedom is at an interface to a cell that we do not own locally (which, in this case must then be a <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cell</a>) and for which the neighboring cell may be the owner &ndash; in other words, the degree of freedom is not a <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned</a> but instead only a <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a>. The values of such degrees of freedom are typically stored on the machine that owns the degree of freedom and, consequently, would not be accessible on the current machine.</p>
<p>Because one often needs these values anyway, there is a second kind of vector, often called "ghosted vector". Ghosted vectors store some elements on each processor for which that processor is not the owner. For such vectors, you can read those elements that the processor you are currently on stores but you cannot write into them because to make this work would require propagating the new value to all other processors that have a copy of this value (the list of such processors may be something which the current processor does not know and has no way of finding out efficiently). Since you cannot write into ghosted vectors, the only way to initialize such a vector is by assignment from a non-ghosted vector. This implies having to import those elements we locally want to store from other processors.</p>
<p>The way ghosted vectors are actually stored is different between the various implementations of parallel vectors. For PETSc (and the corresponding <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> class), ghosted vectors store the same elements as non-ghosted ones would, plus some additional elements that are owned by other processors. In other words, for each element there is a clear owner among all of the processors and those elements that the current processor stores but does not own (i.e., the "ghost elements") are simply mirror images of a primary value somewhere else &ndash; thus, the name "ghost". This is also the case for the parallel::distributed::Vector class.</p>
<p>On the other hand, in Trilinos (and consequently in <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>), a ghosted vector is simply a view of the parallel vector where the element distributions overlap. The 'ghosted' Trilinos vector in itself has no idea of which entries are ghosted and which are locally owned. In fact, a ghosted vector may not even store all of the elements a non-ghosted vector would store on the current processor. Consequently, for Trilinos vectors, there is no notion of an 'owner' of vector elements in the way we have it in the the non-ghost case view (or in the PETSc case) and the name "ghost element" may be misleading since in this view, every element we have available locally may or may not be stored somewhere else as well, but even if it is, the local element is not a mirror value of a primary location as there is no owner of each element.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> documentation module provides a brief overview of where the different kinds of vectors are typically used. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="hp_paper"></a><b>hp-paper</b> </dt>
<dd><p class="startdd">The "hp-paper" is a paper by W. Bangerth and O. Kayser-Herold, titled "Data Structures and Requirements for hp Finite Element Software", that describes many of the algorithms and data structures used in the implementation of the hp-framework of deal.II. In particular, it summarizes many of the tricky points that have to be considered for hp-finite elements using continuous elements.</p>
<p>The full reference for this paper is as follows: </p><div class="fragment"><div class="line">@Article{BK07,</div><div class="line">  author =       {Wolfgang Bangerth and Oliver Kayser-Herold},</div><div class="line">  title =        {Data Structures and Requirements for hp Finite Element</div><div class="line">                  Software},</div><div class="line">  journal =      {ACM Trans. Math. Softw.},</div><div class="line">  year =         2009,</div><div class="line">  volume =       36,</div><div class="line">  number =       1,</div><div class="line">  pages =        {4/1--4/31}</div><div class="line">}</div></div><!-- fragment --><p> It is available from <a href="http://www.math.colostate.edu/~bangerth/publications.html">http://www.math.colostate.edu/~bangerth/publications.html</a>, also see <a href="https://www.dealii.org/publications.html#details">deal.II publications</a> for details.</p>
<p>The numerical examples shown in that paper are generated with a slightly modified version of <a class="el" href="step_27.html">step-27</a>. The main difference to that tutorial program is that various operations in the program were timed for the paper to compare different options and show that \(hp\) methods are really not all that expensive. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossInterpolation"></a><b>Interpolation with finite elements</b> </dt>
<dd><p class="startdd">The purpose of interpolation with finite elements is computing a vector of coefficients representing a finite element function, such that the <a class="el" href="DEALGlossary.html#GlossNodes">node values</a> of the original function and the finite element function coincide. Therefore, the interpolation process consists of evaluating all <a class="el" href="DEALGlossary.html#GlossNodes">node functionals</a> <em>N<sub>i</sub></em> for the given function <em>f</em> and store the result as entry <em>i</em> in the coefficient vector. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLagrange"></a><b>Lagrange elements</b> </dt>
<dd><p class="startdd">Finite elements based on Lagrangian interpolation at <a class="el" href="DEALGlossary.html#GlossSupport">support points</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedCell"></a><b>Locally owned cell</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all cells when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. In such meshes, each cell is owned by exactly one processor. The locally owned ones are those owned by the current processor.</p>
<p>Each processor in a parallel computation has a triangulation covering the entire domain that consists of cells that are locally owned, of <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a> and of <a class="el" href="DEALGlossary.html#GlossArtificialCell">artificial cells</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedDof"></a><b>Locally owned degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. Locally owned degrees of freedom live on locally owned cells. Since degrees of freedom are owned by only one processor, degrees of freedom on interfaces between cells owned by different processors may be owned by one or the other, so not all degrees of freedom on a locally owned cell are also locally owned degrees of freedom.</p>
<p>Locally owned DoFs are a subset of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyActiveDof"></a><b>Locally active degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. Locally active degrees of freedom are those that live on locally owned cells. Degrees of freedom on interfaces between cells owned by different processors therefore belong to the set of locally active degrees of freedom for more than one processor.</p>
<p>Locally active DoFs are a superset of the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned DoFs</a> and a subset of the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyRelevantDof"></a><b>Locally relevant degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. Locally relevant degrees of freedom are those that live on locally owned or ghost cells. Consequently, they may be owned by different processors.</p>
<p>Locally relevant DoFs are a superset of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs.</a> </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossManifoldIndicator"></a><b>Manifold indicator</b>  </dt>
<dd><p class="startdd">Every object that makes up a <a class="el" href="classTriangulation.html">Triangulation</a> (cells, faces, edges, etc.), is associated with a unique number (of type <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) that is used to identify which manifold object is responsible to generate new points when the mesh is refined.</p>
<p>By default, all manifold indicators of a mesh are set to <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>. A typical piece of code that sets the manifold indicator on a object to something else would look like this, here setting the manifold indicator to 42 for all cells whose center has an \(x\) component less than zero:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[0] &lt; 0)</div><div class="line">    cell-&gt;set_manifold_id (42);</div></div><!-- fragment --><p>Here we call the function <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id()</a>. It may also be appropriate to call <a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">TriaAccessor::set_all_manifold_ids</a> instead, to set recursively the manifold id on each face (and edge, if in 3d). To query the manifold indicator of a particular object edge, use <a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">TriaAccessor::manifold_id()</a>.</p>
<p>The code above only sets the manifold indicators of a particular part of the <a class="el" href="classTriangulation.html">Triangulation</a>, but it does not by itself change the way the <a class="el" href="classTriangulation.html">Triangulation</a> class treats this object for the purposes of mesh refinement. For this, you need to call <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> to associate a manifold object with a particular manifold indicator. This allows the <a class="el" href="classTriangulation.html">Triangulation</a> objects to use a different method of finding new points on cells, faces or edges to be refined; the default is to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object for all faces and edges.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classManifold.html">Manifold</a> indicators are inherited from parents to their children upon mesh refinement. Some more information about manifold indicators is also presented in a section of the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class as well as in the <a class="el" href="group__manifold.html">Manifold documentation module</a>. <a class="el" href="classManifold.html">Manifold</a> indicators are used in <a class="el" href="step_53.html">step-53</a> and <a class="el" href="step_54.html">step-54</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__manifold.html">The module on Manifolds</a></dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMaterialId"></a><b>Material id</b> </dt>
<dd><p class="startdd">Each cell of a triangulation has associated with it a property called "material id". It is commonly used in problems with heterogeneous coefficients to identify which part of the domain a cell is in and, consequently, which value the coefficient should have on this particular cell. In practice, the material id of a cell is typically used to identify which cells belong to a particular part of the domain, e.g., when you have different materials (steel, concrete, wood) that are all part of the same domain. One would then usually query the material id associated with a cell during assembly of the bilinear form, and use it to determine (e.g., by table lookup, or a sequence of if-else statements) what the correct material coefficients would be for that cell.</p>
<p>This material_id may be set upon construction of a triangulation (through the <a class="el" href="structCellData.html">CellData</a> data structure), or later through use of cell iterators. For a typical use of this functionality, see the <a class="el" href="step_28.html">step-28</a> tutorial program. The functions of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace typically set the material ID of all cells to zero. When reading a triangulation through the <a class="el" href="classGridIn.html">GridIn</a> class, different input file formats have different conventions, but typically either explicitly specify the material id, or if they don't, then <a class="el" href="classGridIn.html">GridIn</a> simply sets them to zero. Because the material of a cell is intended to pertain to a particular region of the domain, material ids are inherited by child cells from their parent upon mesh refinement.</p>
<p>The material id is set and queried using the <a class="el" href="classCellAccessor.html#ae4769702cd7ab67a61b25778ea3021b2">CellAccessor::material_id</a>, <a class="el" href="classCellAccessor.html#a861d3679d23d3f4365f724c9cfe5fd77">CellAccessor::set_material_id</a> and <a class="el" href="classCellAccessor.html#a2b49d85f8793f5a95d6c50797c07be2b">CellAccessor::recursively_set_material_id</a> functions. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMPICommunicator"></a><b>MPI Communicator</b> </dt>
<dd><p class="startdd">In the language of the Message Passing Interface (MPI), a communicator can be thought of as a mail system that allows sending messages to other members of the mail system. Within each communicator, each <a class="el" href="DEALGlossary.html#GlossMPIProcess">process</a> has a <a class="el" href="DEALGlossary.html#GlossMPIRank">rank</a> (the equivalent of a house number) that allows to identify senders and receivers of messages. It is not possible to send messages via a communicator to receivers that are not part of this communicator/mail service.</p>
<p>When starting a parallel program via a command line call such as </p><div class="fragment"><div class="line">mpirun -np 32 ./step-17</div></div><!-- fragment --><p> (or the equivalent used in the batch submission system used on your cluster) the MPI system starts 32 copies of the <a class="el" href="step_17.html">step-17</a> executable. Each of these has access to the <code>MPI_COMM_WORLD</code> communicator that then consists of all 32 processors, each with its own rank. A subset of processes within this MPI universe can later agree to create other communicators that allow communication between only a subset of processes. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMPIProcess"></a><b>MPI Process</b> </dt>
<dd><p class="startdd">When running parallel jobs on distributed memory machines, one almost always uses MPI. There, a command line call such as </p><div class="fragment"><div class="line">mpirun -np 32 ./step-17</div></div><!-- fragment --><p> (or the equivalent used in the batch submission system used on your cluster) starts 32 copies of the <a class="el" href="step_17.html">step-17</a> executable. Some of these may actually run on the same machine, but in general they will be running on different machines that do not have direct access to each other's memory space.</p>
<p>In the language of the Message Passing Interface (MPI), each of these copies of the same executable running on (possibly different) machines are called <em>processes</em>. The collection of all processes running in parallel is called the "MPI Universe" and is identified by the <a class="el" href="DEALGlossary.html#GlossMPICommunicator">MPI communicator</a> <code>MPI_COMM_WORLD</code>.</p>
<p>Each process has immediate access only to the objects in its own memory space. A process can not read from or write into the memory of other processes. As a consequence, the only way by which processes can communicate is by sending each other messages. That said (and as explained in the introduction to <a class="el" href="step_17.html">step-17</a>), one typically calls higher level MPI functions in which all processes that are part of a communicator participate. An example would be computing the sum over a set of integers where each process provides one term of the sum. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMPIRank"></a><b>MPI Rank</b> </dt>
<dd><p class="startdd">In the language of the Message Passing Interface (MPI), the <em>rank</em> of an <a class="el" href="DEALGlossary.html#GlossMPIProcess">MPI process</a> is the number this process carries within the set <code>MPI_COMM_WORLD</code> of all processes currently running as one parallel job. More correctly, it is the number within an <a class="el" href="DEALGlossary.html#GlossMPICommunicator">MPI communicator</a> that groups together a subset of all processes with one parallel job (where <code>MPI_COMM_WORLD</code> simply denotes the <em>complete</em> set of processes).</p>
<p>Within each communicator, each process has a unique rank, distinct from the all other processes' ranks, that allows identifying one recipient or sender in MPI communication calls. Each process, running on one processor, can inquire about its own rank within a communicator by calling <a class="el" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process()</a>. The total number of processes participating in a communicator (i.e., the <em>size</em> of the communicator) can be obtained by calling <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="mg_paper"></a><b>Multigrid paper</b> </dt>
<dd><p class="startdd">The "multigrid paper" is a paper by B. Janssen and G. Kanschat, titled "Adaptive Multilevel Methods with Local Smoothing for H1- and Hcurl-Conforming High Order Finite Element Methods", that describes many of the algorithms and data structures used in the implementation of the multigrid framework of deal.II. It underlies the implementation of the classes that are used in <a class="el" href="step_16.html">step-16</a> for multigrid methods.</p>
<p>The full reference for this paper is as follows: </p><div class="fragment"><div class="line">@article{janssen2011adaptive,</div><div class="line">  title=    {Adaptive Multilevel Methods with Local Smoothing for H^1- and H^{curl}-Conforming High Order Finite Element Methods},</div><div class="line">  author=   {Janssen, B{\&quot;a}rbel and Kanschat, Guido},</div><div class="line">  journal=  {SIAM Journal on Scientific Computing},</div><div class="line">  volume=   {33},</div><div class="line">  number=   {4},</div><div class="line">  pages=    {2095--2114},</div><div class="line">  year=     {2011},</div><div class="line">  publisher={SIAM}}</div></div><!-- fragment --><p> See <a href="http://dx.doi.org/10.1137/090778523">DOI:10.1137/090778523</a> for the paper and <a href="https://www.dealii.org/publications.html#details">deal.II publications</a> for more details. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossNodes"></a><b>Node values or node functionals</b>  </dt>
<dd><p class="startdd">It is customary to define a finite element as a triple \((K,P,\Psi)\) where</p><ul>
<li>\(K\) is the cell, where in deal.II this is always a line segment, quadrilateral, or hexahedron;</li>
<li>\(P\) is a finite-dimensional space, e.g., a polynomial space mapped from the <a class="el" href="DEALGlossary.html#GlossReferenceCell">reference cell</a> to \(K\);</li>
<li>\(\Psi\) is a set of "node functionals", i.e., functionals \(\Psi_i : P \rightarrow {\mathbb R}\). The dimension of \(P\) must be equal to the number of node functionals. With this definition, we can define a basis of the local function space, i.e., a set of "shape functions" \(\varphi_j\in P\), by requiring that \(\Psi_i(\varphi_j) = \delta_{ij}\), where \(\delta\) is the Kronecker delta.</li>
</ul>
<p>This definition of what a finite element is has several advantages, concerning analysis as well as implementation. For the analysis, it means that conformity with certain spaces (<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">FiniteElementData::Conformity</a>), e.g. continuity, is up to the node functionals. In deal.II, it helps simplifying the implementation of more complex elements like <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> considerably.</p>
<p>Examples for node functionals are values in <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> and moments with respect to Legendre polynomials. Examples:</p>
<table class="doxtable">
<tr>
<th>Element </th><th>Function space </th><th>Node values </th></tr>
<tr>
<th><a class="el" href="classFE__Q.html">FE_Q</a>, <a class="el" href="classFE__DGQ.html">FE_DGQ</a> </th><td><em>Q<sub>k</sub></em> </td><td>values in support points </td></tr>
<tr>
<th><a class="el" href="classFE__DGP.html">FE_DGP</a> </th><td><em>P<sub>k</sub></em> </td><td>moments with respect to Legendre polynomials </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> (2d) </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>moments on edges and in the interior </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomasNodal.html">FE_RaviartThomasNodal</a> </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>Gauss points on edges(faces) and anisotropic Gauss points in the interior </td></tr>
</table>
<p>The construction of finite elements as outlined above allows writing code that describes a finite element simply by providing a polynomial space (without having to give it any particular basis &ndash; whatever is convenient is entirely sufficient) and the nodal functionals. This is used, for example in the <a class="el" href="classFiniteElement.html#a97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> function. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossParallelScaling"></a><b>Parallel scaling</b> </dt>
<dd><p class="startdd">When we say that a parallel program "scales", what we mean is that the program does not become unduly slow (or takes unduly much memory) if we make the problem it solves larger, and that run time and memory consumption decrease proportionally if we keep the problem size the same but increase the number of processors (or cores) that work on it.</p>
<p>More specifically, think of a problem whose size is given by a number \(N\) (which could be the number of cells, the number of unknowns, or some other indicative quantity such as the number of CPU cycles necessary to solve it) and for which you have \(P\) processors available for solution. In an ideal world, the program would then require a run time of \({\cal O}(N/P)\), and this would imply that we could reduce the run time to any desired value by just providing more processors. Likewise, for a program to be scalable, its overall memory consumption needs to be \({\cal O}(N)\) and on each involved process needs to be \({\cal O}(N/P)\), again implying that we can fit any problem into the fixed amount of memory computers attach to each processor, by just providing sufficiently many processors.</p>
<p>For practical assessments of scalability, we often distinguish between "strong" and "weak" scalability. These assess asymptotic statements such as \({\cal O}(N/P)\) run time in the limits \(N\rightarrow \infty\) and/or \(P\rightarrow \infty\). Specifically, when we say that a program is "strongly scalable", we mean that if we have a problem of fixed size \(N\), then we can reduce the run time and memory consumption (on every processor) inversely proportional to \(P\) by just throwing more processors at the problem. In particular, strong scalability implies that if we provide twice as many processors, then run time and memory consumption on every process will be reduced by a factor of two. In other words, we can solve the <em>same problem</em> faster and faster by providing more and more processors.</p>
<p>Conversely, "weak scalability" means that if we increase the problem size \(N\) by a fixed factor, and increase the number of processors \(P\) available to solve the problem by the same factor, then the overall run time (and the memory consumption on every processor) remains the same. In other words, we can solve <em>larger and larger problems</em> within the same amount of wallclock time by providing more and more processors.</p>
<p>No program is truly scalable in this theoretical sense. Rather, all programs cease to scale once either \(N\) or \(P\) grows larger than certain limits. We therefore often say things such as "the program scales up to
   4,000 cores", or "the program scales up to 100,000,000 unknowns". There are a number of reasons why programs cannot scale without limit; these can all be illustrated by just looking at the (relatively simple) <a class="el" href="step_17.html">step-17</a> tutorial program:</p><ul>
<li>Sequential sections: Many programs have sections of code that either cannot or are not parallelized, i.e., where one processor has to do a certain, fixed amount of work that does not decrease just because there are a total of \(P\) processors around. In <a class="el" href="step_17.html">step-17</a>, this is the case when generating graphical output: one processor creates the graphical output for the entire problem, i.e., it needs to do \({\cal O}(N)\) work. That means that this function has a run time of \({\cal O}(N)\), regardless of \(P\), and consequently the overall program will not be able to achieve \({\cal O}(N/P)\) run time but have a run time that can be described as \(c_1N/P + c_2N\) where the first term comes from scalable operations such as assembling the linear system, and the latter from generating graphical output on process 0. If \(c_2\) is sufficiently small, then the program might look like it scales strongly for small numbers of processors, but eventually strong scalability will cease. In addition, the program can not scale weakly either because increasing the size \(N\) of the problem while increasing the number of processors \(P\) at the same rate does not keep the run time of this one function constant.</li>
<li>Duplicated data structures: In <a class="el" href="step_17.html">step-17</a>, each processor stores the entire mesh. That is, each processor has to store a data structure of size \({\cal O}(N)\), regardless of \(P\). Eventually, if we make the problem size large enough, this will overflow each processor's memory space even if we increase the number of processors. It is thus clear that such a replicated data structure prevents a program from scaling weakly. But it also prevents it from scaling strongly because in order to create an object of size \({\cal O}(N)\), one has to at the very least write into \({\cal O}(N)\) memory locations, costing \({\cal O}(N)\) in CPU time. Consequently, there is a component of the overall algorithm that does not behave as \({\cal O}(N/P)\) if we provide more and more processors.</li>
<li>Communication: If, to pick just one example, you want to compute the \(l_2\) norm of a vector of which all MPI processes store a few entries, then every process needs to compute the sum of squares of its own entries (which will require \({\cal O}(N/P)\) time, and consequently scale perfectly), but then every process needs to send their partial sum to one process that adds them all up and takes the square root. In the very best case, sending a message that contains a single number takes a constant amount of time, regardless of the overall number of processes. Thus, again, every program that does communication cannot scale strongly because there are parts of the program whose CPU time requirements do not decrease with the number of processors \(P\) you allocate for a fixed size \(N\). In reality, the situation is actually even worse: the more processes are participating in a communication step, the longer it will generally take, for example because the one process that has to add everyone's contributions has to add everything up, requiring \({\cal O}(P)\) time. In other words, CPU time <em>increases</em> with the number of processes, therefore not only preventing a program from scaling strongly, but also from scaling weakly. (In reality, MPI libraries do not implement \(l_2\) norms by sending every message to one process that then adds everything up; rather, they do pairwise reductions on a tree that doesn't grow the run time as \({\cal O}(P)\) but as \({\cal O}(\log_2 P)\), at the expense of more messages sent around. Be that as it may, the fundamental point is that as you add more processors, the run time will grow with \(P\) regardless of the way the operation is actually implemented, and it can therefore not scale.)</li>
</ul>
<p>These, and other reasons that prevent programs from scaling perfectly can be summarized in <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law"><em>Amdahl's law</em></a> that states that if a fraction \(\alpha\) of a program's overall work \(W\) can be parallelized, i.e., it can be run in \({\cal O}(\alpha W/P)\) time, and a fraction \(1-\alpha\) of the program's work can not be parallelized (i.e., it consists either of work that only one process can do, such as generating graphical output in <a class="el" href="step_17.html">step-17</a>; or that every process has to execute in a replicated way, such as sending a message with a local contribution to a dedicated process for accumulation), then the overall run time of the program will be </p><p class="formulaDsp">
\begin{align*} T = {\cal O}\left(\alpha \frac WP + (1-\alpha)W \right). \end{align*}
</p>
<p> Consequently, the "speedup" you get, i.e., the factor by which your programs run faster on \(P\) processors compared to running the program on a single process (assuming this is possible) would be </p><p class="formulaDsp">
\begin{align*} S = \frac{W}{\alpha \frac WP + (1-\alpha)W} = \frac{P}{\alpha + (1-\alpha)P}. \end{align*}
</p>
<p> If \(\alpha&lt;1\), which it is for all practically existing programs, then \(S\rightarrow \frac{1}{1-\alpha}\) as \(P\rightarrow \infty\), implying that there is a point where it does not pay off in any significant way any more to throw more processors at the problem.</p>
<p>In practice, what matters is <em>up to which problem size</em> or <em>up to which number of processes</em> or <em>down to which size of local problems \({\cal}(N/P)\)</em> a program scales. For deal.II, experience shows that on most clusters with a reasonable fast network, one can solve problems up to a few billion unknowns, up to a few thousand processors, and down to somewhere between 40,000 and 100,000 unknowns per process. The last number is the most relevant: if you have a problem with, say, \(10^8\) unknowns, then it makes sense to solve it on 1000-2500 processors since the number of degrees of freedom each process handles remains at more than 40,000. Consequently, there is enough work every process has to do so that the \({\cal O}(1)\) time for communication does not dominate. But it doesn't make sense to solve such a problem with 10,000 or 100,000 processors, since each of these processor's local problem becomes so small that they spend most of their time waiting for communication, rather than doing work on their part of the work. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossPeriodicConstraints"></a><b>Periodic boundary conditions</b> </dt>
<dd><p class="startdd">Periodic boundary condition are often used when only part of the physical relevant domain is modeled. One assumes that the solution simply continues periodically with respect to the boundaries that are considered periodic. In deal.II, support for this is through <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a> and <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a>. As soon as a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> is used also <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity()</a> has to be called to make sure that all the processes know about relevant parts of the triangulation on both sides of the periodic boundary. A typical process for distributed triangulations would be:</p><ol type="1">
<li>Create a mesh</li>
<li>Gather the periodic faces using <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> (<a class="el" href="classTriangulation.html">Triangulation</a>)</li>
<li>Add the periodicity information to the mesh using <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity()</a></li>
<li>Gather the periodic faces using <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>)</li>
<li>Add periodicity constraints using <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a></li>
</ol>
<p>An example for this can be found in <a class="el" href="step_45.html">step-45</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossPrimitive"></a><b>Primitive finite elements</b> </dt>
<dd><p class="startdd">A finite element (described by its shape functions) is primitive if there is a unique relation from shape function number to vector <a class="el" href="DEALGlossary.html#GlossComponent">component</a>. What this means is that each shape function of a vector-valued element has exactly one nonzero component if an element is primitive. This includes, in particular, all scalar elements as well as vector-valued elements assembled via the <a class="el" href="classFESystem.html">FESystem</a> class from other primitive (for example scalar) elements as shown in <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_29.html">step-29</a>, <a class="el" href="step_22.html">step-22</a> and several others. On the other hand, the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class used in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>, or the <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> class provide non-primitive finite elements because there, each vector-value shape function may have several non-zero components. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossReferenceCell"></a><b>Reference cell</b> </dt>
<dd><p class="startdd">The hypercube [0,1]<sup>dim</sup>, on which all parametric finite element shape functions are defined. Many properties of the reference cell are described by the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSerialization"></a><b>Serialization</b>  </dt>
<dd><p class="startdd">The term "serialization" refers to the process of writing the state of an object to a stream and later retrieve it again. A typical use case is to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job). In either case, one wants to occasionally save the state of the program so that, upon failure, one can restart it at that point rather than having to run it again from the beginning.</p>
<p>deal.II implements serialization facilities by implementing the necessary interfaces for the <a href="http://www.boost.org/doc/libs/1_62_0/libs/serialization/doc/index.html" target="_top">BOOST serialization</a> library. See there for examples on how to save and restore objects. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossShape"></a><b>Shape functions</b> </dt>
<dd><p class="startdd">The restriction of the finite element basis functions to a single grid cell. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSubdomainId"></a><b>Subdomain id</b> </dt>
<dd><p class="startdd">Each cell of a triangulation has associated with it a property called the "subdomain id" that can be queried using a call like <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> and that can be set for example by using <code>cell-&gt;set_subdomain_id(13)</code>. (These calls resolve to <a class="el" href="classCellAccessor.html#ae06835414c3c3f3359974f2c75a88033">CellAccessor::subdomain_id()</a> and <a class="el" href="classCellAccessor.html#a56098dab68574f96b42779d68c54269d">CellAccessor::set_subdomain_id()</a>, respectively.) While in principle this property can be used in any way application programs deem useful (it is simply an integer associated with each cell that can indicate whatever you want), at least for programs that run in parallel it usually denotes the <a class="el" href="DEALGlossary.html#GlossMPIRank">MPI rank</a> of the processor that "owns" this cell.</p>
<p>For programs that are parallelized based on MPI but where each processor stores the entire triangulation (as in, for example, <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a>, but not in <a class="el" href="step_40.html">step-40</a>), subdomain ids are assigned to cells by partitioning a mesh, and each MPI process then only works on those cells it "owns", i.e., that belong to a subdomain the processor owns (traditionally, this is the case for the subdomain id whose numerical value coincides with the rank of the MPI process within the MPI communicator). Partitioning is typically done using the <a class="el" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">GridTools::partition()</a> function, but any other method can also be used to do this. (Alternatively, the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> class can partition the mesh automatically using a similar approach.)</p>
<p>On the other hand, for programs that are parallelized using MPI but where meshes are held distributed across several processors using the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class, the subdomain id of cells is tied to the processor that owns the cell. In other words, querying the subdomain id of a cell tells you if the cell is owned by the current processor (i.e. if <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a> == triangulation.parallel::distributed::Triangulation::locally_owned_subdomain()</code>) or by another processor. In the parallel distributed case, subdomain ids are only assigned to cells that the current processor owns as well as the immediately adjacent <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>. Cells further away are held on each processor to ensure that every MPI process has access to the full <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> as well as to ensure the invariant that neighboring cells differ by at most one refinement level. These cells are called "artificial" (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">here</a>) and have the special subdomain id value types::artificial_subdomain_id.</p>
<p>In addition to regular subdomain ids, there is a second, closely related set of flags that are associated with each cell: "level subdomain ids." These exist not only for active cells but, in fact, for every cell in a mesh hierarchy. Their meaning is entirely analogous to the regular subdomain ids, but they are read and written by the <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">CellAccessor::level_subdomain_id()</a> and <a class="el" href="classCellAccessor.html#a2bfad9f24d9ddbc86883614639d4886d">CellAccessor::set_level_subdomain_id()</a> functions. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSupport"></a><b>Support points</b> </dt>
<dd><p class="startdd">Support points are by definition those points \(p_i\), such that for the shape functions \(v_j\) holds \(v_j(p_i) = \delta_{ij}\). Therefore, a finite element interpolation can be defined uniquely by the values in the support points.</p>
<p>Lagrangian elements fill the vector accessed by <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">FiniteElement::get_unit_support_points()</a>, such that the function <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">FiniteElement::has_support_points()</a> returns <code>true</code>. Naturally, these support points are on the <a class="el" href="DEALGlossary.html#GlossReferenceCell">reference cell</a>. Then, <a class="el" href="classFEValues.html">FEValues</a> can be used (in conjunction with a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>) to access support points on the actual grid cells.</p>
<dl class="section note"><dt>Note</dt><dd>The concept of <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> is restricted to the finite element families based on Lagrange interpolation. For a more general concept, see <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">generalized support points</a>. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossTargetComponent"></a><b>Target component</b> </dt>
<dd><p class="startdd">When vectors and matrices are grouped into blocks by component, it is often desirable to collect several of the original components into a single one. This could be for instance, grouping the velocities of a Stokes system into a single block. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUnitCell"></a><b>Unit cell</b> </dt>
<dd><p class="startdd">See <a class="el" href="DEALGlossary.html#GlossReferenceCell">Reference cell</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUnitSupport"></a><b>Unit support points</b> </dt>
<dd><p class="startdd">These are the <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> on the reference cell, defined in <a class="el" href="classFiniteElement.html">FiniteElement</a>. For example, the usual Q1 element in 1d has support points at <code>x=0</code> and <code>x=1</code> (and similarly, in higher dimensions at the vertices of the unit square or cube). On the other hand, higher order Lagrangian elements have unit support points also in the interior of the unit line, square, or cube. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUserFlags"></a><b>User flags</b> </dt>
<dd><p class="startdd">A triangulation offers one bit per line, quad, etc for user flags. This field can be accessed as all other data using iterators, using the syntax </p><div class="fragment"><div class="line">cell-&gt;set_user_flag();                <span class="comment">// set the user flag of a cell</span></div><div class="line"><span class="keywordflow">if</span> (cell-&gt;user_flag_set() == <span class="keyword">false</span>)   <span class="comment">// if cell hasn&#39;t been flagged yet</span></div><div class="line">  {</div><div class="line">     cell-&gt;face(0)-&gt;set_user_flag();  <span class="comment">// flag its first face</span></div><div class="line">  }</div></div><!-- fragment --><p> Typically, this user flag is used if an algorithm walks over all cells and needs information whether another cell, e.g. a neighbor, has already been processed. Similarly, it can be used to flag faces, quads or lines at the boundary for which some operation has already been performed. The latter is often useful since a loop such as </p><div class="fragment"><div class="line"><span class="comment">// in 3d</span></div><div class="line"><span class="keywordflow">for</span> (cell=dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell!=dof_handler.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">         <span class="keywordflow">do</span> something with <span class="keyword">this</span> line</div><div class="line">      }</div></div><!-- fragment --><p> encounters some boundary lines more than once. Consequently, one would set the user flag of the line in the body of the loop, and only enter the body if the user flag had not previously been set. There are a number of additional functions that can be accessed through the iterator interface; see the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class for more information. Note that there are no user flags that can be associated with vertices; however, since vertices are numbered consecutively, this can easily be emulated in user code using a vector of bools.</p>
<p>There are two functions, <a class="el" href="classTriangulation.html#a6a9971ee882f15fe521afc4e079383b5">Triangulation::save_user_flags</a> and <a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">Triangulation::load_user_flags</a> which write and read these flags to and from a stream or a vector of bools. Unlike <a class="el" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">Triangulation::save_refine_flags</a> and <a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">Triangulation::load_refine_flags</a>, these two functions store and read the flags of all used lines, quads, etc, i.e., not only of the active ones.</p>
<p>If you want to store more specific user flags, you can use the functions <a class="el" href="classTriangulation.html#a2b7d8e059d6f8f903879eea858215fb8">Triangulation::save_user_flags_line</a> and <a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">Triangulation::load_user_flags_line</a> and the similarly for quads, etc.</p>
<p>As for the refinement and coarsening flags, there exist two versions of these functions, one which reads/writes from a stream and one which does so from a <code>vector&lt;bool&gt;</code>. The latter is used to store flags temporarily, while the first is used to store them in a file.</p>
<p>It is good practice to clear the user flags using the <a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">Triangulation::clear_user_flags()</a> function before usage, since it is often necessary to use the flags in more than one function. If the flags may be in use at the time a function that needs them is called, then this function should save and restore the flags as described above.</p>
<dl class="section note"><dt>Note</dt><dd>If more information than just a single boolean flag needs to be stored with a cell, line, or face, then see about <a class="el" href="DEALGlossary.html#GlossUserData">user data</a>. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUserData"></a><b>User pointers and user indices</b> </dt>
<dd><p class="startdd">Just like the <a class="el" href="DEALGlossary.html#GlossUserFlags">user flags</a>, the <a class="el" href="classTriangulation.html">Triangulation</a> class offers a field for each line, quad and hex in which to store more descriptive data than just a single boolean flag. This is called "user data" and the data that can be stored in it is either a single unsigned integer or a void pointer. Both are typically used to index into a bigger array that contains more detailed data an application wants to attach to a mesh entity.</p>
<p>User data is stored and retrieved in the following manner: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (cell=dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell!=dof_handler.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">        cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;set_user_index(42);</div><div class="line">      }</div></div><!-- fragment --><p> Similarly, there are functions <a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">TriaAccessor::set_user_pointer</a> to set a pointer, and <a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">TriaAccessor::user_index</a> and <a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">TriaAccessor::user_pointer</a> to retrieve the index and pointer. To clear all user indices or pointers, use <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a>. As with flags, there are functions that allow to save and restore user data, either for all entities of the mesh hierarchy or for lines, quads or hexes separately. There are a number of additional functions that can be accessed through the iterator interface; see the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are stored in the same place. In order to avoid unwanted conversions, <a class="el" href="classTriangulation.html">Triangulation</a> checks which one of them is in use and does not allow access to the other one, until <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> has been called.</dd>
<dd>
The usual warning about the missing type safety of <code>void</code> pointers are obviously in place here; responsibility for correctness of types etc lies entirely with the user of the pointer. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="workstream_paper"></a><b>WorkStream paper</b> </dt>
<dd><p class="startdd">The "WorkStream paper" is a paper by B. Turcksin, M. Kronbichler and W. Bangerth that discusses the design and implementation of <a class="el" href="namespaceWorkStream.html">WorkStream</a>. <a class="el" href="namespaceWorkStream.html">WorkStream</a> is, at its core, a design pattern, i.e., something that is used over and over in finite element codes and that can, consequently, be implemented generically. In particular, the paper lays out the motivation for this pattern and then proposes different ways of implementing it. It also compares the performance of different implementations.</p>
<p>The full reference for this paper is as follows: </p><div class="fragment"><div class="line">@Article{TKB16,</div><div class="line">  author =       {Bruno Turcksin and Martin Kronbichler and Wolfgang Bangerth},</div><div class="line">  title =        {\textit{WorkStream} -- a design pattern for multicore-enabled finite element computations},</div><div class="line">  journal =      {accepted for publication in the ACM Trans. Math. Softw.},</div><div class="line">  year =         2016</div><div class="line">}</div></div><!-- fragment --><p> It is available from <a href="http://www.math.colostate.edu/~bangerth/publications.html">http://www.math.colostate.edu/~bangerth/publications.html</a>, also see <a href="https://www.dealii.org/publications.html#details">deal.II publications</a> for details. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossZOrder"></a><b>Z order</b> </dt>
<dd><p class="startdd">The "Z order" of cells describes an order in which cells are traversed.</p>
<p>By default, if you write a loop over all cells in deal.II, the cells will be traversed in an order where coarser cells (i.e., cells that were obtained from <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a> cells with fewer refinement steps) come before cells that are finer (i.e., cells that were obtained with more refinement steps). Within each refinement level, cells are traversed in an order that has something to do with the order in which they were created; in essence, however, this order is best of thought of as "unspecified": you will visit each cell on a given refinement level exactly once, in some order, but you should not make any assumptions about this order.</p>
<p>Because the order in which cells are created factors into the order of cells, it can happen that the order in which you traverse cells is different for two identical meshes. For example, think of a 1d (coarse) mesh with two cells: If you first refine the first of these cells and then the other, then you will traverse the four cells on refinement level 1 in a different order than if you had first refined the second coarse cell and then the first coarse cell.</p>
<p>This order is entirely practical for almost all applications because in most cases, it does not actually matter in which order one traverses cells. Furthermore, it allows using data structures that lead to particularly low cache miss frequencies and are therefore efficient for high performance computing applications.</p>
<p>On the other hand, there are cases where one would want to traverse cells in a particular, specified and reproducible order that only depends on the mesh itself, not its creation history or any other seemingly arbitrary design decisions. The "Z order" is one way to achieve this goal.</p>
<p>To explain the concept of the Z order, consider the following sequence of meshes (with each cell numbered using the "level.index" notation, where "level" is the number of refinements necessary to get from a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a> cell to a particular cell, and "index" the index of this cell within a particular refinement level):</p>
<div class="image">
<img src="simple-mesh-0.png" alt="simple-mesh-0.png"/>
<div class="caption">
A coarse mesh</div></div>
 <div class="image">
<img src="simple-mesh-1.png" alt="simple-mesh-1.png"/>
<div class="caption">
The mesh after one refinement cycle</div></div>
 <div class="image">
<img src="simple-mesh-2.png" alt="simple-mesh-2.png"/>
<div class="caption">
The mesh after two refinement cycles</div></div>
 <div class="image">
<img src="simple-mesh-3.png" alt="simple-mesh-3.png"/>
<div class="caption">
The mesh after three refinement cycles</div></div>
<p> Note how the cells on level 2 are ordered in the order in which they were created. (Which is not always the case: if cells had been removed in between, then newly created cells would have filled in the holes so created.)</p>
<p>The "natural" order in which deal.II traverses cells would then be 0.0 -&gt; 1.0 -&gt; 1.1 -&gt; 1.2 -&gt; 1.3 -&gt; 2.0 -&gt; 2.1 -&gt; 2.2 -&gt; 2.3 -&gt; 2.4 -&gt; 2.5 -&gt; 2.6 -&gt; 2.7. (If you want to traverse only over the <a class="el" href="DEALGlossary.html#GlossActive">active cells</a>, then omit all cells from this list that have children.) This can be thought of as the "lexicographic" order on the pairs of numbers "level.index", but because the index within each level is not well defined, this is not a particularly useful notion. Alternatively, one can also think of it as one possible breadth-first traversal of the tree that corresponds to this mesh and that represents the parent-child relationship between cells:</p>
<div class="image">
<img src="simple-mesh-tree.png" alt="simple-mesh-tree.png"/>
<div class="caption">
The tree that corresponds to the mesh after three refinement cycles</div></div>
<p> On the other hand, the Z order corresponds to a particular depth-first traversal of the tree. Namely: start with a cell, and if it has children then iterate over these cell's children; this rule is recursively applied as long as a child has children.</p>
<p>For the given mesh above, this yields the following order: 0.0 -&gt; 1.0 -&gt; 2.4 -&gt; 2.5 -&gt; 2.6 -&gt; 2.7 -&gt; 1.1 -&gt; 1.2 -&gt; 1.3 -&gt; 1.4 -&gt; 2.0 -&gt; 2.1 -&gt; 2.2 -&gt; 2.3. (Again, if you only care about active cells, then remove 0.0, 1.0, and 1.3 from this list.) Because the order of children of a cell is well defined (as opposed to the order of cells within each level), this "hierarchical" traversal makes sense and is, in particular, independent of the history of a triangulation.</p>
<p>In practice, it is easily implemented using a recursive function: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> visit_cells_hierarchically (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;has_children())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;cell-&gt;n_children(); ++c)</div><div class="line">      visit_cells_hierarchically (cell-&gt;child(c));</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      ... <span class="keywordflow">do</span> whatever you wanted to <span class="keywordflow">do</span> on each cell ...;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> This function is then called as follows: </p><div class="fragment"><div class="line"><span class="comment">// loop over all coarse mesh cells</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.begin(0);</div><div class="line">     cell != <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.end(); ++cell)</div><div class="line">  visit_cells_hierarchically (cell);</div></div><!-- fragment --><p>Finally, as an explanation of the term "Z" order: if you draw a line through all cells in the order in which they appear in this hierarchical fashion, then it will look like a left-right inverted Z on each refined cell. Indeed, the curve so defined can be thought of a space-filling curve and is also sometimes called "Morton ordering", see <a href="https://en.wikipedia.org/wiki/Z-order_curve">https://en.wikipedia.org/wiki/Z-order_curve</a> . </p>
<p class="enddd"></p>
</dd>
</dl>
<p>This glossary explains a few terms that are frequently used in the documentation of classes of deal.II. The glossary often only gives a microscopic view of a particular concept; if you struggle with the bigger picture, it may therefore also be worth to consult the global overview of classes on the <a class="el" href="index.html">index</a> page. </p><dl>
<dt class="glossary"><a class="anchor" id="GlossActive"></a><b>Active cells</b> </dt>
<dd><p class="startdd">A cell, face, or edge is defined as <em>active</em> if it is not refined any further, i.e., if it does not have children. Once a cell, face, or edge becomes a parent it is no longer active. Unless working with a multigrid algorithm, active cells are the only ones carrying degrees of freedom. </p>
<p>The concept of artificial cells has no meaning for triangulations that store the entire mesh on each processor, i.e. the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlockLA"></a><b>Block (linear algebra)</b> </dt>
<dd><p class="startdd">It is often convenient to treat a matrix or vector as a collection of individual blocks. For example, in <a class="el" href="step_20.html">step-20</a> (and other tutorial programs), we want to consider the global linear system \(Ax=b\) in the form </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} M &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> where \(U,P\) are the values of velocity and pressure degrees of freedom, respectively, \(M\) is the mass matrix on the velocity space, \(B\) corresponds to the negative divergence operator, and \(B^T\) is its transpose and corresponds to the negative gradient. Using such a decomposition into blocks, one can then define preconditioners that are based on the individual operators that are present in a system of equations (for example the Schur complement, in the case of <a class="el" href="step_20.html">step-20</a> ), rather than the entire matrix. In essence, blocks are used to reflect the structure of a PDE system in linear algebra, in particular allowing for modular solvers for problems with multiple solution components. On the other hand, the matrix and right hand side vector can also treated as a unit, which is convenient for example during assembly of the linear system when one may not want to make a distinction between the individual components, or for an outer Krylov space solver that doesn't care about the block structure (e.g. if only the preconditioner needs the block structure). Splitting matrices and vectors into blocks is supported by the <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, <a class="el" href="classBlockVector.html">BlockVector</a>, and related classes. See the overview of the various linear algebra classes in the <a class="el" href="group__LAC.html">Linear algebra classes</a> module. The objects present two interfaces: one that makes the object look like a matrix or vector with global indexing operations, and one that makes the object look like a collection of sub-blocks that can be individually addressed. Depending on context, one may wish to use one or the other interface. Typically, one defines the sub-structure of a matrix or vector by grouping the degrees of freedom that make up groups of physical quantities (for example all velocities) into individual blocks of the linear system. This is defined in more detail below in the glossary entry on <a class="el" href="DEALGlossary.html#GlossBlock">Block (finite element)</a>. </p>
<p>For the purpose of a discretization, blocks are the better concept to use since it is not always possible to address individual components of a solution. This is, in particular, the case for non- <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> elements. Take for instance the solution of the mixed Laplacian system with the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> element (see <a class="el" href="step_20.html">step-20</a> ). There, the first <code>dim</code> components are the directional velocities. Since the shape functions are linear combinations of those, these <code>dim</code> components constitute only a single block. On the other hand, the pressure variable is scalar and would form a the second block, but in the <code>dim+1</code>st component. The minimal size of each block is dictated by the underlying finite element (a block consists of a single component for scalar elements, but in the case of the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>, for example, a block consists of <code>dim</code> components). However, several such minimal blocks can be grouped together into user defined blocks at will, and in accordance with the application. For instance, for the <b>Q</b><sub>2</sub><sup><em>d</em></sup>-<b>Q</b><sub>1</sub> (Taylor-Hood) Stokes element, there are <em>d</em>+1 components each of which could in principle form its own block. But we are typically more interested in having only two blocks, one of which consists of all the velocity vector components (i.e. this block would have <em>d</em> components) and the other having only the single pressure component. <em>Implementation:</em> deal.II has a number of different finite element classes, all of which are derived from the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class (see the <a class="el" href="group__feall.html">module on finite element classes</a>). With one exception, whether they are scalar or vector valued, they all define a single block: all vector components the finite element defines through its <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components()</a> function form a single block, i.e. <a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElement::n_blocks()</a> returns one. The exception is the <a class="el" href="classFESystem.html">FESystem</a> class that takes multiple simpler elements and connects them into more complicated ones. Consequently, it can have more than one block. A <a class="el" href="classFESystem.html">FESystem</a> has as many blocks as it has base elements times their multiplicity (see the constructors of <a class="el" href="classFESystem.html">FESystem</a> to understand this statement). In other words, it does not care how many blocks each base element has, and consequently you can produce a Stokes element that has only two blocks by creating the object</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div></div><!-- fragment --><p> On the other hand, we could have produced a similar object with dim+1 blocks using</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div></div><!-- fragment --><p> With the exception of the number of blocks, the two objects are the same for all practical purposes, however. <em>Global degrees of freedom:</em> While we have defined blocks above in terms of the vector components of a vector-valued solution function (or, equivalently, in terms of the vector-valued finite element space), every shape function of a finite element is part of one block or another. Consequently, we can partition all degrees of freedom defined on a <a class="el" href="classDoFHandler.html">DoFHandler</a> into individual blocks. Since by default the <a class="el" href="classDoFHandler.html">DoFHandler</a> class enumerates degrees of freedom in a more or less random way, you will first want to call the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function to make sure that all degrees of freedom that correspond to a single block are enumerated consecutively. More information on this topic can be found in the documentation of <a class="el" href="classFESystem.html">FESystem</a>, the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module and the tutorial programs referenced therein. <em>Selecting blocks:</em> Many functions allow you to restrict their operation to certain vector components or blocks. For example, this is the case for the functions that interpolate boundary values: one may want to only interpolate the boundary values for the velocity block of a finite element field but not the pressure block. The way to do this is by passing a <a class="el" href="classBlockMask.html">BlockMask</a> argument to such functions, see the <a class="el" href="DEALGlossary.html#GlossBlockMask">block mask entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlockMask"></a><b>Block mask</b> </dt>
<dd><p class="startdd">In much the same way as one can think of elements as being composed of physical vector components (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a> ) or logical blocks (see <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a> ), there is frequently a need to select a set of such blocks for operations that are not intended to be run on <em>all</em> blocks of a finite element space. Selecting which blocks to work on happens using the <a class="el" href="classBlockMask.html">BlockMask</a> class. Block masks work in much the same way as component masks, including the fact that the <a class="el" href="classBlockMask.html">BlockMask</a> class has similar semantics to the <a class="el" href="classComponentMask.html">ComponentMask</a> class. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary entry on component masks</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>While components and blocks provide two alternate but equally valid viewpoints on finite elements with multiple vector components, the fact is that throughout the library there are far more places where you can pass a <a class="el" href="classComponentMask.html">ComponentMask</a> argument rather than a <a class="el" href="classBlockMask.html">BlockMask</a> argument. Fortunately, one can be converted into the other, using the syntax <code>fe.component_mask(block_mask)</code> where <code>block_mask</code> is a variable of type <a class="el" href="classBlockMask.html">BlockMask</a>. In other words, if you have a block mask but need to call a function that only accepts a component mask, this syntax can be used to obtain the necessary component mask. <b>Creation of block masks:</b> Block masks are typically created by asking the finite element to generate a block mask from certain selected vector components using code such as this where we create a mask that only denotes the velocity components of a Stokes element (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> ):</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1),                     1);     <span class="comment">// Q1 element for the pressure</span></div><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.block_mask (pressure);</div></div><!-- fragment --><p> The result is a block mask that, in 1d as well as 2d and 3d, would have values <code>[false, true]</code> . Similarly, using</p>
<div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> velocity_mask = stokes_fe.block_mask (velocities);</div></div><!-- fragment --><p> would result in a mask <code>[true, false]</code> in any dimension. Note, however, that if we had defined the finite element in the following way:</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div></div><!-- fragment --><p> then the code</p>
<div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (pressure);</div></div><!-- fragment --><p> would yield a block mask that in 2d has elements <code>[false, false, true]</code> because the element has <code>dim+1</code> components and equally many blocks. See the discussion on what a block represents exactly in the <a class="el" href="DEALGlossary.html#GlossBlock">block entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBoundaryForm"></a><b>Boundary form</b> </dt>
<dd><p class="startdd">For a dim-dimensional triangulation in dim-dimensional space, the boundary form is a vector defined on faces. It is the vector product of the image of coordinate vectors on the surface of the unit cell. It is a vector normal to the surface, pointing outwards and having the length of the surface element. A more general definition would be that (at least up to the length of this vector) it is exactly that vector that is necessary when considering integration by parts, i.e. equalities of the form \(\int_\Omega \text{div} \vec \phi = -\int_{\partial\Omega} \vec n \cdot \vec \phi\) . Using this definition then also explains what this vector should be in the case of domains (and corresponding triangulations) of dimension <code>dim</code> that are embedded in a space <code>spacedim</code> : in that case, the boundary form is still a vector defined on the faces of the triangulation; it is orthogonal to all tangent directions of the boundary and within the tangent plane of the domain. Note that this is compatible with case <code>dim==spacedim</code> since there the tangent plane is the entire space \({\mathbb R}^\text{dim}\) . In either case, the length of the vector equals the determinant of the transformation of reference face to the face of the current cell. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBoundaryIndicator"></a><b>Boundary indicator</b> </dt>
<dd><p class="startdd">In a <a class="el" href="classTriangulation.html">Triangulation</a> object, every part of the boundary may be associated with a unique number (of type <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) that is used to determine what kinds of boundary conditions are to be applied to a particular part of a boundary. The boundary is composed of the faces of the cells and, in 3d, the edges of these faces. By default, all boundary indicators of a mesh are zero, unless you are reading from a mesh file that specifically sets them to something different, or unless you use one of the mesh generation functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> that have a <a class="el" href="DEALGlossary.html#GlossColorization">colorize</a> option. A typical piece of code that sets the boundary indicator on part of the boundary to something else would look like this, here setting the boundary indicator to 42 for all faces located at \(x=-1\) :</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_face_iterators())</div><div class="line">  <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;center()[0] ==</div><div class="line"></div><div class="line">-1)</div><div class="line">      face-&gt;set_boundary_id (42);</div></div><!-- fragment --><p> This calls functions <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">TriaAccessor::set_boundary_id</a>. In 3d, it may also be appropriate to call <a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">TriaAccessor::set_all_boundary_ids</a> instead on each of the selected faces. To query the boundary indicator of a particular face or edge, use <a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">TriaAccessor::boundary_id</a>. Many of the functions in namespaces <a class="el" href="namespaceDoFTools.html">DoFTools</a> and <a class="el" href="namespaceVectorTools.html">VectorTools</a> take arguments that specify which part of the boundary to work on, and they specifically refer to boundary_ids. Examples are <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a>, <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>, <a class="el" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a> and <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Boundary indicators are inherited from mother faces and edges to their children upon mesh refinement. Some more information about boundary indicators is also presented in a section of the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class.</dd>
<dd>
For parallel triangulations of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, it is not enough to set boundary indicators only once at the beginning. See the long discussion on this topic in the class documentation of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> . </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCoarseMesh"></a><b>Coarse mesh</b> </dt>
<dd><p class="startdd">A "coarse mesh" in deal.II is a triangulation object that consists only of cells that are not refined, i.e., a mesh in which no cell is a child of another cell. This is generally how triangulations are first constructed in deal.II, for example using (most of) the functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>, the functions in class <a class="el" href="classGridIn.html">GridIn</a>, or directly using the function <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a>. One can of course do computations on such meshes, but most of the time (see, for example, almost any of the tutorial programs) one first refines the coarse mesh globally (using <a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global()</a>), or adaptively (in that case first computing a refinement criterion, then one of the functions in namespace <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>, and finally calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a>). The mesh is then no longer a "coarse mesh", but a "refined mesh". <a class="el" href="classTriangulation.html">Triangulation</a> objects store cells in <em>levels</em>: in particular, all cells of a coarse mesh are on level zero. Their children (if we executed <code>Triangulation::refine_global(1)</code> on a coarse mesh) would then be at level one, etc. The coarse mesh of a triangulation (in the sense of the previous paragraph) then consists of exactly the level-zero cells of a triangulation. (Whether they are active (i.e., have no children) or have been refined is not important for this definition.)</p>
<p>In those cases, it is often necessary in algorithms to reference a coarse mesh cell uniquely. Because the triangulation object on the current process does not actually store the entire coarse mesh, one needs to have a globally unique identifier for each coarse mesh cell that is independent of the index within level zero of the triangulation stored locally. This globally unique ID is called the "coarse cell ID". It can be accessed via the function call </p><div class="fragment"><div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.coarse_cell_index_to_coarse_cell_id (coarse_cell-&gt;index());</div></div><!-- fragment --><p> where <code>triangulation</code> is the triangulation to which the iterator <code>coarse_cell</code> pointing to a cell at level zero belongs. Here, <code>coarse_cell-&gt;index()</code> returns the index of that cell within its refinement level (see <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">TriaAccessor::index()</a>). This is a number between zero and the number of coarse mesh cells stored on the current process in a parallel computation; it uniquely identifies a cell on that parallel process, but different parallel processes may use that index for different cells located at different coordinates. For those classes that store all coarse mesh cells on each process, the <a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">Triangulation::coarse_cell_index_to_coarse_cell_id()</a> simply returns a permutation of the possible argument values. In the simplest cases, such as for a sequential or a parallel shared triangulation, the function will in fact simply return the value of the argument. For others, such as <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, the ordering of coarse cell IDs is not the same as the ordering of coarse cell indices. Finally, for classes such as <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>, the function returns the globally unique ID, which is from a larger set of possible indices than the indices of the coarse cells actually stored on the current process. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossColorization"></a><b>Colorization</b> </dt>
<dd><p class="startdd"><em> Colorization </em> is the process of marking certain parts of a <a class="el" href="classTriangulation.html">Triangulation</a> with different labels. The use of the word <em> color </em> comes from cartography, where countries on a map are made visually distinct from each other by assigning them different colors. Using the same term <em> coloring </em> is common in mathematics, even though we assign integers and not hues to different regions. deal.II refers to two processes as coloring: </p><ol>
<li>
Most of the functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace take an optional argument <code>colorize</code> . This argument controls whether or not the different parts of the boundary will be assigned different <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">boundary indicators</a>. Some functions also assign different <a class="el" href="DEALGlossary.html#GlossMaterialId">material indicators</a> as well.  </li>
<li>
The function <a class="el" href="namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">GraphColoring::make_graph_coloring()</a> computes a decomposition of a <a class="el" href="classTriangulation.html">Triangulation</a> (more exactly, a range of iterators). No two adjacent cells are given the same color.  </li>
</ol>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossComponent"></a><b>Component</b> </dt>
<dd><p class="startdd">When considering systems of equations in which the solution is not just a single scalar function, we say that we have a <em>vector system</em> with a <em>vector-valued solution</em>. For example, the vector solution in the elasticity equation considered in <a class="el" href="step_8.html">step-8</a> is \(u=(u_x,u_y,u_z)^T\) consisting of the displacements in each of the three coordinate directions. The solution then has three elements. Similarly, the 3d Stokes equation considered in <a class="el" href="step_22.html">step-22</a> has four elements: \(u=(v_x,v_y,v_z,p)^T\) . We call the elements of the vector-valued solution <em>components</em> in deal.II. To be well-posed, for the solution to have \(n\) components, there need to be \(n\) partial differential equations to describe them. This concept is discussed in great detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. In finite element programs, one frequently wants to address individual elements (components) of this vector-valued solution, or sets of components. For example, we do this extensively in <a class="el" href="step_8.html">step-8</a> , and a lot of documentation is also provided in the module on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>. If you are thinking only in terms of the partial differential equation (not in terms of its discretization), then the concept of <em>components</em> is the natural one. For a given finite element, the number of components can be queried using the <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElementData::n_components()</a> function, and you can find out which vector components are nonzero for a given finite element shape function using <a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">FiniteElement::get_nonzero_components()</a>. The values and gradients of individual components of a shape function (if the element is primitive) can be queried using the <a class="el" href="classFiniteElement.html#a247fccbd72723a07fc8c17ac093d3156">FiniteElement::shape_value_component()</a> and <a class="el" href="classFiniteElement.html#a7f026ed19fcc589476f11d69de4a3419">FiniteElement::shape_grad_component()</a> functions on the reference cell. The <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">FEValues::shape_value_component()</a> and <a class="el" href="classFEValuesBase.html#a71e93aa182f3acd34abd020538f3bc39">FEValues::shape_grad_component()</a> functions do the same on a real cell. See also the documentation of the <a class="el" href="classFiniteElement.html">FiniteElement</a> and <a class="el" href="classFEValues.html">FEValues</a> classes. <em>Selecting components:</em> Many functions allow you to restrict their operation to certain vector components or blocks. For example, this is the case for the functions that interpolate boundary values: one may want to only interpolate the boundary values for the velocity components of a finite element field but not the pressure component. The way to do this is by passing a <a class="el" href="classComponentMask.html">ComponentMask</a> argument to such functions, see the <a class="el" href="DEALGlossary.html#GlossComponentMask">component mask entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossComponentMask"></a><b>Component mask</b> </dt>
<dd><p class="startdd">When using vector-valued elements (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> ) to solve systems of equations, one frequently wants to restrict some operations to only certain solution variables. For example, when solving the Stokes equations, one may wish to only interpolate boundary values for the velocity components but not the pressure. In deal.II, this is typically done by passing functions a <em>component mask</em>. Component masks are always specified as a <a class="el" href="classComponentMask.html">ComponentMask</a> object which one can think of as an array with as many entries as the finite element has components (e.g., in the Stokes case, there are <code>dim+1</code> components) and where each entry is either true or false. In the example where we would like to interpolate boundary values only for the velocity components of the Stokes system, this component mask would then be <code>[true, true, false]</code> in 2d and <code>[true, true, true, false]</code> in 3d to indicate that no boundary values shall be set for the pressure variable (the last of the <code>dim+1</code> vector components of the solution. There are many functions that take such component masks, for example DoFTools::make_zero_boundary_values, <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, <a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator::estimate</a>, etc. In some cases, there are multiple functions with these names but only some of them have a component mask argument. <b>Semantics of component masks:</b> Many of the functions that take a component mask object that has been default constructed to indicate <em>all components</em>, i.e., as if the vector had the correct length and was filled with only <code>true</code> values. The reason is that default initialized objects can be constructed in place using the code snippet <code><a class="el" href="classComponentMask.html">ComponentMask()</a></code> and can thus be used as a default argument in function signatures. In other words, <a class="el" href="classComponentMask.html">ComponentMask</a> objects can be in one of two states: They can have been initialized by a vector of booleans with a nonzero length; in that case, they represent a mask of a particular length where some elements may be true and others may be false. Or, the <a class="el" href="classComponentMask.html">ComponentMask</a> may have been default initialized (using the default constructor) in which case it represents an array of indefinite length (i.e., a length appropriate to the circumstances) in which <em>every entry</em> is true. <b>Creation of component masks:</b> Component masks are typically created by asking the finite element to generate a component mask from certain selected components using code such as this where we create a mask that only denotes the velocity components of a Stokes element (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> ):</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> pressure_mask = stokes_fe.component_mask (pressure);</div></div><!-- fragment --><p> The result is a component mask that, in 2d, would have values <code>[false, false, true]</code> . Similarly, using</p>
<div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> velocity_mask = stokes_fe.component_mask (velocities);</div></div><!-- fragment --><p> would result in a mask <code>[true, true, false]</code> in 2d. Of course, in 3d, the result would be <code>[true, true, true, false]</code></p>
<dl class="section note"><dt>Note</dt><dd>Not all component masks actually make sense. For example, if you have a <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object in 2d, then it doesn't make any sense to have a component mask of the form <code>[true, false]</code> because you try to select individual vector components of a finite element where each shape function has both \(x\) and \(y\) velocities. In essence, while you can of course create such a component mask, there is nothing you can do with it. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCompress"></a><b>Compressing distributed vectors and matrices</b> </dt>
<dd><p class="startdd">For parallel computations, deal.II uses the vector and matrix classes defined in the <a class="el" href="namespacePETScWrappers.html">PETScWrappers</a> and <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> namespaces. When running programs in parallel using MPI, these classes only store a certain number of rows or elements on the current processor, whereas the rest of the vector or matrix is stored on the other processors that belong to our MPI universe. This presents a certain problem when you assemble linear systems: we add elements to the matrix and right hand side vectors that may or may not be stored locally. Sometimes, we may also want to just <em>set</em> an element, not add to it. Both PETSc and Trilinos allow adding to or setting elements that are not locally stored. In that case, they write the value that we want to store or add into a cache, and we need to call one of the functions <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">TrilinosWrappers::VectorBase::compress()</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">TrilinosWrappers::SparseMatrix::compress()</a>, <a class="el" href="classPETScWrappers_1_1VectorBase.html#a6166fa37985a73755a2982af055f1a0a">PETScWrappers::VectorBase::compress()</a> or <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">PETScWrappers::MatrixBase::compress()</a> which will then ship the values in the cache to the MPI process that owns the element to which it is supposed to be added or written to. Due to the MPI model that only allows to initiate communication from the sender side (i.e. in particular, it is not a remote procedure call), these functions are collective, i.e. they need to be called by all processors. There is one snag, however: both PETSc and Trilinos need to know whether the operation that these <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> functions invoke applies to adding elements or setting them. In some cases, not all processors may be adding elements, for example if a processor does not own any cells when using a very <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a>. For this reason, <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> takes an argument of type <a class="el" href="structVectorOperation.html">VectorOperation</a>, which can be either ::add, or ::insert. This argument is required for vectors and matrices starting with the 7.3 release. In short, you need to call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> in the following cases (and only in those cases, though calling <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> in other cases just costs some performance):</p><ol type="1">
<li>At the end of your assembly loop on matrices and vectors. This needs to be done if you write entries directly or if you use <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a>. Use <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>.</li>
<li>When you are done setting individual elements in a matrix/vector before any other operations are done (adding to elements, other operations like scaling, solving, reading, etc.). Use <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>.</li>
<li>Like in 2., but for adding values to individual elements. Use <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>. All other operations like scaling or adding vectors, assignments, calls into deal.II (<a class="el" href="namespaceVectorTools.html">VectorTools</a>, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, ...) or solvers do not require calls to <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a>. </li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Compressing is an operation that only applies to vectors whose elements are uniquely owned by one and only one processor in a parallel MPI universe. It does not apply to <a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a>.</dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossConcept"></a><b>Concepts in deal.II</b> </dt>
<dd><p class="startdd">There are several places in deal.II where we require that a type in a template match a certain interface or behave in a certain way: such constraints are called <em> concepts </em> in C++. See the discussion in <a class="el" href="group__Concepts.html">Concepts, or expectations on template parameters</a> for more information and a list of concepts in deal.II. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDimension"></a><b>Dimensions <code>dim</code> and <code>spacedim</code></b> </dt>
<dd><p class="startdd">Many classes and functions in deal.II have two template parameters, <code>dim</code> and <code>spacedim</code>. An example is the basic <a class="el" href="classTriangulation.html">Triangulation</a> class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim=dim&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classTriangulation.html">Triangulation</a> {...};</div></div><!-- fragment --><p> In all of these contexts where you see <code>dim</code> and <code>spacedim</code> referenced, these arguments have the following meaning: </p><ul>
<li>
<code>dim</code> denotes the dimensionality of the mesh. For example, a mesh that consists of line segments is one-dimensional and consequently corresponds to <code>dim==1</code>. A mesh consisting of quadrilaterals then has <code>dim==2</code> and a mesh of hexahedra has <code>dim==3</code>.  </li>
<li>
<code>spacedim</code> denotes the dimensionality of the space in which such a mesh lives. Generally, one-dimensional meshes live in a one-dimensional space, and similarly for two-dimensional and three-dimensional meshes that subdivide two- and three-dimensional domains. Consequently, the <code>spacedim</code> template argument has a default equal to <code>dim</code>. But this need not be the case: For example, we may want to solve an equation for sediment transport on the surface of the Earth. In this case, the domain is the two-dimensional surface of the Earth (<code>dim==2</code>) that lives in a three-dimensional coordinate system (<code>spacedim==3</code>).  </li>
</ul>
<p>More generally, deal.II can be used to solve partial differential equations on <a href="https://en.wikipedia.org/wiki/Manifold">manifolds</a> that are embedded in higher dimensional space. In other words, these two template arguments need to satisfy <code>dim &lt;= spacedim</code>, though in many applications one simply has <code>dim == spacedim</code>. Following the convention in geometry, we say that the "codimension" is defined as <code>spacedim-dim</code>. In other words, a triangulation consisting of quadrilaterals whose coordinates are three-dimensional (for which we would then use a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> object) has "codimension one". Examples of uses where these two arguments are not the same are shown in <a class="el" href="step_34.html">step-34</a> , <a class="el" href="step_38.html">step-38</a> , <a class="el" href="step_54.html">step-54</a> . </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDoF"></a><b>Degree of freedom</b> </dt>
<dd>The term "degree of freedom" (often abbreviated as "DoF") is commonly used in the finite element community to indicate two slightly different, but related things. The first is that we'd like to represent the finite element solution as a linear combination of shape functions, in the form \(u_h(\mathbf{x}) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf{x})\) . Here, \(U_j\) is a vector of expansion coefficients. Because we don't know their values yet (we will compute them as the solution of a linear or nonlinear system), they are called "unknowns" or "degrees of freedom". The second meaning of the term can be explained as follows: A mathematical description of finite element problem is often to say that we are looking for a finite dimensional function \(u_h \in V_h\) that satisfies some set of equations (e.g. \(a(u_h,\varphi_h)=(f,\varphi_h)\) for all test functions \(\varphi_h\in V_h\) ). In other words, all we say here that the solution needs to lie in some space \(V_h\) . However, to actually solve this problem on a computer we need to choose a basis of this space; this is the set of shape functions \(\varphi_j(\mathbf{x})\) we have used above in the expansion of \(u_h(\mathbf x)\) with coefficients \(U_j\) . There are of course many bases of the space \(V_h\) , but we will specifically choose the one that is described by the finite element functions that are traditionally defined locally on the cells of the mesh. Describing "degrees
of freedom" in this context requires us to simply <em>enumerate</em> the basis functions of the space \(V_h\) . For \(Q_1\) elements this means simply enumerating the vertices of the mesh in some way, but for higher elements one also has to enumerate the shape functions that are associated with edges, faces, or cell interiors of the mesh. The class that provides this enumeration of the basis functions of \(V_h\) is called <a class="el" href="classDoFHandler.html">DoFHandler</a>. The process of enumerating degrees of freedom is referred to as "distributing DoFs" in deal.II.  </dd>
<dt class="glossary"><a class="anchor" id="GlossDirectionFlag"></a><b>Direction flags</b> </dt>
<dd><p class="startdd">The <em>direction flag</em> is used in triangulations embedded in a higher dimensional space to denote the orientation of cells and make the manifold oriented. It is accessed using <a class="el" href="classCellAccessor.html#ae146ea059e9c27cb3e040b92d5c4e152">CellAccessor::direction_flag()</a> and set by the <a class="el" href="classTriangulation.html">Triangulation</a> class upon creation of a triangulation. You can change all direction flags of a triangulation using the <a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">Triangulation::flip_all_direction_flags()</a> function. The flag is necessary to make cases like this work: assume we have a one-dimensional mesh embedded in a two-dimensional space, </p><div class="image">
<img src="direction_flag.png" alt="direction_flag.png"/>
<div class="caption">
One dimensional mesh in two dimensions</div></div>
<p>In one dimensional meshes in one dimensional space, we can always make sure that the location of the left vertex of a cell has a smaller value than the location of the right vertex. However, if we embed a mesh in a higher dimensional space, we can no longer do this. For example, the cells in the mesh above may be described by the following vertex sets: <code>(0,1), (1,2), (3,2), (4,3), (4,5)</code>. (As a side remark, note that here we have vertices</p>
<ul>
<li>e.g. vertex 2</li>
<li>that are the right end points of more than one cell.) If we define the normal to each cell as that unit vector that is right perpendicular to the vector that connects the first to the second vertex of the line, then we would end up with the following picture: <div class="image">
<img src="direction_flag_normals.png" alt="direction_flag_normals.png"/>
<div class="caption">
Normal vectors</div></div>
In other words, this one-dimensional manifold is not oriented. We could in principle revert the order of vertices when creating such a mesh (though there are good reasons not to do so, for example because this mesh may have resulted from extracting the surface mesh of a two dimensional mesh, and we want to preserve the order of vertices of each line segment because they currently match the order of vertices of the faces of the 2d cells). An alternative strategy, chosen in deal.II, is to simply associate with each cell whether the normal should be the left or right normal to the cell. (The default is right normals.) In the example above, the flags for the five cells would be <code>true, true, false, false, true</code>. Multiplying the right normal with plus or minus one, depending on the value of the flag on each cell, yields a set of normal vectors that orient the manifold. Similar issues happen with two-dimensional meshes in three space dimensions. We note that it would not be possible to find consistent direction flags if the two-dimensional manifold is not orientable; such manifolds are not currently supported by deal.II. </li>
</ul>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDistorted"></a><b>Distorted cells</b> </dt>
<dd><p class="startdd">A <em>distorted cell</em> is a cell for which the mapping from the reference cell to real cell has a Jacobian whose determinant is non-positive somewhere in the cell. Typically, we only check the sign of this determinant at the vertices of the cell. The function <a class="el" href="structGeometryInfo.html#af047ab1fe45077a53df9cd8212fc790c">GeometryInfo::alternating_form_at_vertices</a> computes these determinants at the vertices. By way of example, if all of the determinants are of roughly equal value and on the order of \(h^\text{dim}\) then the cell is well-shaped. For example, a square cell or face has determinants equal to \(h^\text{dim}\) whereas a strongly sheared parallelogram has a determinant much smaller. Similarly, a cell with very unequal edge lengths will have widely varying determinants. Conversely, a pinched cell in which the location of two or more vertices is collapsed to a single point has a zero determinant at this location. Finally, an inverted or twisted cell in which the location of two vertices is out of order will have negative determinants. The following two images show a well-formed, a pinched, and a twisted cell for both 2d and 3d: </p><div class="image">
<img src="distorted_2d.png" alt="distorted_2d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 2d.</div></div>
 <div class="image">
<img src="distorted_3d.png" alt="distorted_3d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 3d.</div></div>
<p>Distorted cells can appear in two different ways: The original <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a> can already contain such cells, or they can be created as the result of moving or distorting a mesh by a relatively large amount. If the appropriate flag is given upon creation of a triangulation, the function <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation</a>, which is called by the various functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> and <a class="el" href="classGridIn.html">GridIn</a> (but can also be called from user code, see <a class="el" href="step_14.html">step-14</a> and the example at the end of <a class="el" href="step_49.html">step-49</a> ), will signal the creation of coarse meshes with distorted cells by throwing an exception of type <a class="el" href="structTriangulation_1_1DistortedCellList.html">Triangulation::DistortedCellList</a>. There are legitimate cases for creating meshes with distorted cells (in particular collapsed/pinched cells) if you don't intend to assemble anything on these cells. For example, consider a case where one would like to simulate the behavior of an elastic material with a fluid-filled crack such as an oil reservoir. If the pressure becomes too large, the crack is closed</p>
<ul>
<li>and the cells that discretize the crack volume are collapsed to zero volume. As long as you don't integrate over these cells to simulate the behavior of the fluid (of which there isn't any if the crack has zero volume), such meshes are perfectly legitimate. As a consequence, <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation</a> does not simply abort the program, but throws an exception that contains a list of cells that are distorted; this exception can be caught and, if you believe that you can ignore this condition, you can react by doing nothing with the caught exception. The function <a class="el" href="namespaceGridTools.html#a1c7bb95bc2bbb09d6f02651d7be1527d">GridTools::fix_up_distorted_child_cells</a> can, in some cases, fix distorted cells on refined meshes by moving around the vertices of a distorted child cell that has an undistorted parent. Note that the <a class="el" href="classTriangulation.html">Triangulation</a> class does not test for the presence of distorted cells by default, since the determination whether a cell is distorted or not is not a cheap operation. If you want a <a class="el" href="classTriangulation.html">Triangulation</a> object to test for distortion of cells, you need to specify this upon creation of the object by passing the appropriate flag. </li>
</ul>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="distributed_paper"></a><b>Distributed computing paper</b> </dt>
<dd><p class="startdd">The "distributed computing
paper" is a paper by W. Bangerth, C. Burstedde, T. Heister and M. Kronbichler titled "Algorithms and Data Structures for Massively Parallel
Generic Finite Element Codes" that describes the implementation of parallel distributed computing in deal.II, i.e. computations where not only the linear system is split onto different machines as in, for example, <a class="el" href="step_17.html">step-17</a> , but also the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. In essence, it is a guide to the <a class="el" href="namespaceparallel_1_1distributed.html">parallel::distributed</a> namespace and the techniques used in <a class="el" href="step_40.html">step-40</a> . The full reference for the paper is as follows:</p>
<div class="fragment"><div class="line">@Article{BBHK11,</div><div class="line">author =       {Wolfgang Bangerth and Carsten Burstedde and Timo Heister</div><div class="line">               and Martin Kronbichler},</div><div class="line">title =        {Algorithms and data structures for massively parallel generic</div><div class="line">adaptive finite element codes},</div><div class="line">journal =      {ACM Trans. Math. Softw.},</div><div class="line">year =         2011,</div><div class="line">volume =       38,</div><div class="line">pages =        {14/1--28}}</div></div><!-- fragment --><p>For massively parallel computations, deal.II builds on the <a href="http://www.p4est.org/" target="_top">p4est</a> library. If you use this functionality, please also cite the p4est paper listed at their website. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossFaceOrientation"></a><b>Face orientation</b> </dt>
<dd><p class="startdd">In a triangulation, the normal vector to a face can be deduced from the face orientation by applying the right hand side rule (x,y</p>
<p>-&gt; normal). We note, that in the standard orientation of faces in 2d, faces 0 and 2 have normals that point into the cell, and faces 1 and 3 have normals pointing outward. In 3d, faces 0, 2, and 4 have normals that point into the cell, while the normals of faces 1, 3, and 5 point outward. This information, again, can be queried from <a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">GeometryInfo&lt;dim&gt;::unit_normal_orientation</a>. However, it turns out that a significant number of 3d meshes cannot satisfy this convention. This is due to the fact that the face convention for one cell already implies something for the neighbor, since they share a common face and fixing it for the first cell also fixes the normal vectors of the opposite faces of both cells. It is easy to construct cases of loops of cells for which this leads to cases where we cannot find orientations for all faces that are consistent with this convention. For this reason, above convention is only what we call the <em> standard orientation </em> . deal.II actually allows faces in 3d to have either the standard direction, or its opposite, in which case the lines that make up a cell would have reverted orders, and the normal vector would have the opposite direction. You can ask a cell whether a given face has standard orientation by calling <code>cell-&gt;face_orientation(face_no)</code>: if the result is <code>true</code>, then the face has standard orientation, otherwise its normal vector is pointing the other direction. There are not very many places in application programs where you need this information actually, but a few places in the library make use of this. Note that in 2d, the result is always <code>true</code>. However, while every face in 2d is always in standard orientation, you can sometimes specify something to assume that this is not so; an example is the function <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a>. There are two other flags that describe the orientation of a face: face_flip and face_rotation. Some documentation for these exists in the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. An example of their use in user code is given in the <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> function. </p>
<p>(In the vector valued case, the only other piece of information besides the support points \(\hat{\mathbf{x}}_i\) that one needs to provide is the <em>vector component</em> \(c(i)\) the \(i\) th node functional corresponds, so that \(\Psi_i[\varphi]=\varphi(\hat{\mathbf{x}}_i)_{c(i)}\) .) On the other hand, there are other kinds of elements that are not defined this way. For example, for the lowest order Raviart-Thomas element (see the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class), the node functional evaluates not individual components of a vector-valued finite element function with <code>dim</code> components, but the <em>normal component</em> of this vector: \(\Psi_i[\varphi] = \varphi(\hat{\mathbf{x}}_i) \cdot \mathbf{n}_i \) , where the \(\mathbf{n}_i\) are the normal vectors to the face of the cell on which \(\hat{\mathbf{x}}_i\) is located. In other words, the node functional is a <em>linear combination</em> of the components of \(\varphi\) when evaluated at \(\hat{\mathbf{x}}_i\) . Similar things happen for the BDM, ABF, and Nedelec elements (see the <a class="el" href="classFE__BDM.html">FE_BDM</a>, <a class="el" href="classFE__ABF.html">FE_ABF</a>, <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> classes). In these cases, the element does not have <em>support points</em> because it is not purely interpolatory; however, some kind of interpolation is still involved when defining shape functions as the node functionals still require point evaluations at special points \(\hat{\mathbf{x}}_i\) . In these cases, we call the points <em>generalized support points</em>. Finally, there are elements that still do not fit into this scheme. For example, some hierarchical basis functions (see, for example the <a class="el" href="classFE__Q__Hierarchical.html">FE_Q_Hierarchical</a> element) are defined so that the node functionals are <em>moments</em> of finite element functions, \(\Psi_i[\varphi] = \int_{\hat{K}} \varphi(\hat{\mathbf{x}}) {\hat{x}_1}^{p_1(i)} {\hat{x}_2}^{p_2(i)} \) in 2d, and similarly for 3d, where the \(p_d(i)\) are the order of the moment described by shape function \(i\) . Some other elements use moments over edges or faces. In all of these cases, node functionals are not defined through interpolation at all, and these elements then have neither support points, nor generalized support points. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="geometry_paper"></a><b>geometry paper</b> </dt>
<dd><p class="startdd">The "geometry paper" is a paper by L. Heltai, W. Bangerth, M. Kronbichler, and A. Mola, titled "Using exact geometry information in
finite element computations", that describes how deal.II describes the geometry of domains. In particular, it discusses the algorithmic foundations on which the <a class="el" href="classManifold.html">Manifold</a> class is based, and what kind of information it needs to provide for mesh refinement, the computation of normal vectors, and the many other places where geometry enters into finite element computations. The paper is currently available on arXiv at <a href="https://arxiv.org/abs/1910.09824">https://arxiv.org/abs/1910.09824</a> . The full reference for this paper is as follows:</p>
<div class="fragment"><div class="line">@misc{heltai2019using,</div><div class="line"> title={Using exact geometry information in finite element computations},</div><div class="line"> author={Luca Heltai and Wolfgang Bangerth and Martin Kronbichler and Andrea Mola},</div><div class="line"> year={2019},</div><div class="line"> eprint={1910.09824},</div><div class="line"> archivePrefix={arXiv},</div><div class="line"> primaryClass={math.NA}</div><div class="line">}</div></div><!-- fragment --> <p>The layer of ghost cells consists of all cells that are face, edge, or vertex neighbors of any locally owned cell and that are not locally owned themselves. In other word, the ghost cells completely enclose the subdomain of locally owned cells (with the exception of the boundary of the domain, of course). The concept of ghost cells has no meaning for triangulations that store the entire mesh on each processor, i.e. the <a class="el" href="classTriangulation.html">Triangulation</a> and the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> classes. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossGhostedVector"></a><b>Ghosted vectors</b> </dt>
<dd><p class="startdd">In parallel computations, vectors come in two general kinds: without and with ghost elements. Vectors without ghost elements uniquely partition the vector elements between processors: each vector entry has exactly one processor that owns it, and this is the only processor that stores the value of this entry. In other words, if processor zero stores elements 0...49 of a vector and processor one stores elements 50...99, then processor one is out of luck accessing element 42 of this vector: it is not stored here and the value can not be assessed. This will result in an assertion. On the other hand, there are many situations where one needs to know vector elements that aren't locally owned, for example to evaluate the solution on a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> ) for which one of the degrees of freedom is at an interface to a cell that we do not own locally (which, in this case must then be a <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cell</a>) and for which the neighboring cell may be the owner</p>
<ul>
<li>in other words, the degree of freedom is not a <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned</a> but instead only a <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a>. The values of such degrees of freedom are typically stored on the machine that owns the degree of freedom and, consequently, would not be accessible on the current machine. Because one often needs these values anyway, there is a second kind of vector, often called "ghosted vector". Ghosted vectors store some elements on each processor for which that processor is not the owner. For such vectors, you can read those elements that the processor you are currently on stores but you cannot write into them because to make this work would require propagating the new value to all other processors that have a copy of this value (the list of such processors may be something which the current processor does not know and has no way of finding out efficiently). Since you cannot write into ghosted vectors, the only way to initialize such a vector is by assignment from a non-ghosted vector. This implies having to import those elements we locally want to store from other processors. The way ghosted vectors are actually stored is different between the various implementations of parallel vectors. For PETSc (and the corresponding <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> class), ghosted vectors store the same elements as non-ghosted ones would, plus some additional elements that are owned by other processors. In other words, for each element there is a clear owner among all of the processors and those elements that the current processor stores but does not own (i.e., the "ghost elements") are simply mirror images of a primary value somewhere else</li>
<li>thus, the name "ghost". This is also the case for the parallel::distributed::Vector class. On the other hand, in Trilinos (and consequently in <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>), a ghosted vector is simply a view of the parallel vector where the element distributions overlap. The 'ghosted' Trilinos vector in itself has no idea of which entries are ghosted and which are locally owned. In fact, a ghosted vector may not even store all of the elements a non-ghosted vector would store on the current processor. Consequently, for Trilinos vectors, there is no notion of an 'owner' of vector elements in the way we have it in the the non-ghost case view (or in the PETSc case) and the name "ghost element" may be misleading since in this view, every element we have available locally may or may not be stored somewhere else as well, but even if it is, the local element is not a mirror value of a primary location as there is no owner of each element.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> documentation module provides a brief overview of where the different kinds of vectors are typically used. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="hp_paper"></a><b>hp-paper</b> </dt>
<dd><p class="startdd">The "hp-paper" is a paper by W. Bangerth and O. Kayser-Herold, titled "Data
Structures and Requirements for hp Finite Element Software", that describes many of the algorithms and data structures used in the implementation of the hp-framework of deal.II. In particular, it summarizes many of the tricky points that have to be considered for hp-finite elements using continuous elements. The full reference for this paper is as follows:</p>
<div class="fragment"><div class="line">@Article{BK07,</div><div class="line">author =       {Wolfgang Bangerth and Oliver Kayser-Herold},</div><div class="line">title =        {Data Structures and Requirements for hp Finite Element</div><div class="line">               Software},</div><div class="line">journal =      {ACM Trans. Math. Softw.},</div><div class="line">year =         2009,</div><div class="line">volume =       36,</div><div class="line">number =       1,</div><div class="line">pages =        {4/1--4/31}</div><div class="line">}</div></div><!-- fragment --><p> It is available from <a href="http://www.math.colostate.edu/~bangerth/publications.html">http://www.math.colostate.edu/~bangerth/publications.html</a>, also see <a href="https://www.dealii.org/publications.html#details">deal.II publications</a> for details. The numerical examples shown in that paper are generated with a slightly modified version of <a class="el" href="step_27.html">step-27</a> . The main difference to that tutorial program is that various operations in the program were timed for the paper to compare different options and show that \(hp\) methods are really not all that expensive. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedCell"></a><b>Locally owned cell</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all cells when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. In such meshes, each cell is owned by exactly one processor. The locally owned ones are those owned by the current processor.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedDof"></a><b>Locally owned degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. Locally owned degrees of freedom live on locally owned cells. Since degrees of freedom are owned by only one processor, degrees of freedom on interfaces between cells owned by different processors may be owned by one or the other, so not all degrees of freedom on a locally owned cell are also locally owned degrees of freedom. Locally owned DoFs are a subset of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyActiveDof"></a><b>Locally active degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. Locally active degrees of freedom are those that live on locally owned cells. Degrees of freedom on interfaces between cells owned by different processors therefore belong to the set of locally active degrees of freedom for more than one processor.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyRelevantDof"></a><b>Locally relevant degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module. Locally relevant degrees of freedom are those that live on locally owned or ghost cells. Consequently, they may be owned by different processors. Locally relevant DoFs are a superset of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs.</a> </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossManifoldIndicator"></a><b>Manifold indicator</b> </dt>
<dd><p class="startdd">Every object that makes up a <a class="el" href="classTriangulation.html">Triangulation</a> (cells, faces, edges, etc.), is associated with a unique number (of type <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) that is used to identify which manifold object is responsible to generate new points when the mesh is refined. By default, all manifold indicators of a mesh are set to <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>. A typical piece of code that sets the manifold indicator on a object to something else would look like this, here setting the manifold indicator to 42 for all cells whose center has an \(x\) component less than zero:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;center()[0] &lt; 0)</div><div class="line">  cell-&gt;set_manifold_id (42);</div></div><!-- fragment --><p>Here we call the function <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id()</a>. It may also be appropriate to call <a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">TriaAccessor::set_all_manifold_ids</a> instead, to set recursively the manifold id on each face (and edge, if in 3d). To query the manifold indicator of a particular object edge, use <a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">TriaAccessor::manifold_id()</a>. The code above only sets the manifold indicators of a particular part of the <a class="el" href="classTriangulation.html">Triangulation</a>, but it does not by itself change the way the <a class="el" href="classTriangulation.html">Triangulation</a> class treats this object for the purposes of mesh refinement. For this, you need to call <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> to associate a manifold object with a particular manifold indicator. This allows the <a class="el" href="classTriangulation.html">Triangulation</a> objects to use a different method of finding new points on cells, faces or edges to be refined; the default is to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object for all faces and edges.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classManifold.html">Manifold</a> indicators are inherited from parents to their children upon mesh refinement. Some more information about manifold indicators is also presented in a section of the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class as well as in the <a class="el" href="group__manifold.html">Manifold documentation module</a>. <a class="el" href="classManifold.html">Manifold</a> indicators are used in <a class="el" href="step_53.html">step-53</a> and <a class="el" href="step_54.html">step-54</a> .  </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__manifold.html">The module on Manifolds</a></dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMaterialId"></a><b>Material id</b> </dt>
<dd><p class="startdd">Each cell of a triangulation has associated with it a property called "material id". It is commonly used in problems with heterogeneous coefficients to identify which part of the domain a cell is in and, consequently, which value the coefficient should have on this particular cell. In practice, the material id of a cell is typically used to identify which cells belong to a particular part of the domain, e.g., when you have different materials (steel, concrete, wood) that are all part of the same domain. One would then usually query the material id associated with a cell during assembly of the bilinear form, and use it to determine (e.g., by table lookup, or a sequence of if-else statements) what the correct material coefficients would be for that cell. This material_id may be set upon construction of a triangulation (through the <a class="el" href="structCellData.html">CellData</a> data structure), or later through use of cell iterators. For a typical use of this functionality, see the <a class="el" href="step_28.html">step-28</a> tutorial program. The functions of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace typically set the material ID of all cells to zero. When reading a triangulation through the <a class="el" href="classGridIn.html">GridIn</a> class, different input file formats have different conventions, but typically either explicitly specify the material id, or if they don't, then <a class="el" href="classGridIn.html">GridIn</a> simply sets them to zero. Because the material of a cell is intended to pertain to a particular region of the domain, material ids are inherited by child cells from their parent upon mesh refinement. The material id is set and queried using the <a class="el" href="classCellAccessor.html#ae4769702cd7ab67a61b25778ea3021b2">CellAccessor::material_id</a>, <a class="el" href="classCellAccessor.html#a861d3679d23d3f4365f724c9cfe5fd77">CellAccessor::set_material_id</a> and <a class="el" href="classCellAccessor.html#a2b49d85f8793f5a95d6c50797c07be2b">CellAccessor::recursively_set_material_id</a> functions. </p>
<p>When starting a parallel program via a command line call such as</p>
<div class="fragment"><div class="line">mpirun</div><div class="line"></div><div class="line">-np 32 ./step-17</div></div><!-- fragment --><p> (or the equivalent used in the batch submission system used on your cluster) the MPI system starts 32 copies of the <a class="el" href="step_17.html">step-17</a> executable. Each of these has access to the <code>MPI_COMM_WORLD</code> communicator that then consists of all 32 processors, each with its own rank. A subset of processes within this MPI universe can later agree to create other communicators that allow communication between only a subset of processes. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMPIProcess"></a><b>MPI Process</b> </dt>
<dd><p class="startdd">When running parallel jobs on distributed memory machines, one almost always uses MPI. There, a command line call such as</p>
<div class="fragment"><div class="line">mpirun</div><div class="line"></div><div class="line">-np 32 ./step-17</div></div><!-- fragment --><p> (or the equivalent used in the batch submission system used on your cluster) starts 32 copies of the <a class="el" href="step_17.html">step-17</a> executable. Some of these may actually run on the same machine, but in general they will be running on different machines that do not have direct access to each other's memory space. Each process has immediate access only to the objects in its own memory space. A process can not read from or write into the memory of other processes. As a consequence, the only way by which processes can communicate is by sending each other messages. That said (and as explained in the introduction to <a class="el" href="step_17.html">step-17</a> ), one typically calls higher level MPI functions in which all processes that are part of a communicator participate. An example would be computing the sum over a set of integers where each process provides one term of the sum. </p>
<p>Within each communicator, each process has a unique rank, distinct from the all other processes' ranks, that allows identifying one recipient or sender in MPI communication calls. Each process, running on one processor, can inquire about its own rank within a communicator by calling <a class="el" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process()</a>. The total number of processes participating in a communicator (i.e., the <em>size</em> of the communicator) can be obtained by calling <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="mg_paper"></a><b>Multigrid paper</b> </dt>
<dd><p class="startdd">The "multigrid paper" is a paper by B. Janssen and G. Kanschat, titled "Adaptive Multilevel Methods with Local Smoothing for H1- and
Hcurl-Conforming High Order Finite Element Methods", that describes many of the algorithms and data structures used in the implementation of the multigrid framework of deal.II. It underlies the implementation of the classes that are used in <a class="el" href="step_16.html">step-16</a> for multigrid methods. The full reference for this paper is as follows:</p>
<div class="fragment"><div class="line">@article{janssen2011adaptive,</div><div class="line">title=    {Adaptive Multilevel Methods with Local Smoothing for H^1- and H^{curl}-Conforming High Order Finite Element Methods},</div><div class="line">author=   {Janssen, B{\&quot;a}rbel and Kanschat, Guido},</div><div class="line">journal=  {SIAM Journal on Scientific Computing},</div><div class="line">volume=   {33},</div><div class="line">number=   {4},</div><div class="line">pages=    {2095--2114},</div><div class="line">year=     {2011},</div><div class="line">publisher={SIAM}}</div></div><!-- fragment --><p> See <a href="http://dx.doi.org/10.1137/090778523">DOI:10.1137/090778523</a> for the paper and <a href="https://www.dealii.org/publications.html#details">deal.II publications</a> for more details. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossNodes"></a><b>Node values or node functionals</b> </dt>
<dd><p class="startdd">It is customary to define a finite element as a triple \((K,P,\Psi)\) where</p>
<ul>
<li>\(K\) is the cell, where in deal.II this is always a line segment, quadrilateral, or hexahedron;</li>
<li>\(P\) is a finite-dimensional space, e.g., a polynomial space mapped from the <a class="el" href="DEALGlossary.html#GlossReferenceCell">reference cell</a> to \(K\) ;</li>
<li>\(\Psi\) is a set of "node functionals", i.e., functionals \(\Psi_i : P \rightarrow {\mathbb R}\) . The dimension of \(P\) must be equal to the number of node functionals. With this definition, we can define a basis of the local function space, i.e., a set of "shape functions" \(\varphi_j\in P\) , by requiring that \(\Psi_i(\varphi_j) = \delta_{ij}\) , where \(\delta\) is the Kronecker delta. This definition of what a finite element is has several advantages, concerning analysis as well as implementation. For the analysis, it means that conformity with certain spaces (<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">FiniteElementData::Conformity</a>), e.g. continuity, is up to the node functionals. In deal.II, it helps simplifying the implementation of more complex elements like <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> considerably. Examples for node functionals are values in <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> and moments with respect to Legendre polynomials. Examples: <table class="doxtable">
<tr>
<th>Element </th><th>Function space </th><th>Node values </th></tr>
<tr>
<th><a class="el" href="classFE__Q.html">FE_Q</a>, <a class="el" href="classFE__DGQ.html">FE_DGQ</a> </th><td><em>Q<sub>k</sub></em> </td><td>values in support points </td></tr>
<tr>
<th><a class="el" href="classFE__DGP.html">FE_DGP</a> </th><td><em>P<sub>k</sub></em> </td><td>moments with respect to Legendre polynomials </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> (2d) </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>moments on edges and in the interior </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomasNodal.html">FE_RaviartThomasNodal</a> </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>Gauss points on edges(faces) and anisotropic Gauss points in the interior </td></tr>
</table>
The construction of finite elements as outlined above allows writing code that describes a finite element simply by providing a polynomial space (without having to give it any particular basis</li>
<li>whatever is convenient is entirely sufficient) and the nodal functionals. This is used, for example in the <a class="el" href="classFiniteElement.html#a97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> function. </li>
</ul>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossParallelScaling"></a><b>Parallel scaling</b> </dt>
<dd><p class="startdd">When we say that a parallel program "scales", what we mean is that the program does not become unduly slow (or takes unduly much memory) if we make the problem it solves larger, and that run time and memory consumption decrease proportionally if we keep the problem size the same but increase the number of processors (or cores) that work on it. More specifically, think of a problem whose size is given by a number \(N\) (which could be the number of cells, the number of unknowns, or some other indicative quantity such as the number of CPU cycles necessary to solve it) and for which you have \(P\) processors available for solution. In an ideal world, the program would then require a run time of \({\cal O}(N/P)\) , and this would imply that we could reduce the run time to any desired value by just providing more processors. Likewise, for a program to be scalable, its overall memory consumption needs to be \({\cal O}(N)\) and on each involved process needs to be \({\cal O}(N/P)\) , again implying that we can fit any problem into the fixed amount of memory computers attach to each processor, by just providing sufficiently many processors. For practical assessments of scalability, we often distinguish between "strong" and "weak" scalability. These assess asymptotic statements such as \({\cal O}(N/P)\) run time in the limits \(N\rightarrow \infty\) and/or \(P\rightarrow \infty\) . Specifically, when we say that a program is "strongly scalable", we mean that if we have a problem of fixed size \(N\) , then we can reduce the run time and memory consumption (on every processor) inversely proportional to \(P\) by just throwing more processors at the problem. In particular, strong scalability implies that if we provide twice as many processors, then run time and memory consumption on every process will be reduced by a factor of two. In other words, we can solve the <em>same problem</em> faster and faster by providing more and more processors. Conversely, "weak scalability" means that if we increase the problem size \(N\) by a fixed factor, and increase the number of processors \(P\) available to solve the problem by the same factor, then the overall run time (and the memory consumption on every processor) remains the same. In other words, we can solve <em>larger and larger problems</em> within the same amount of wallclock time by providing more and more processors. No program is truly scalable in this theoretical sense. Rather, all programs cease to scale once either \(N\) or \(P\) grows larger than certain limits. We therefore often say things such as "the program scales up to 4,000 cores", or "the program scales up to
100,000,000 unknowns". There are a number of reasons why programs cannot scale without limit; these can all be illustrated by just looking at the (relatively simple) <a class="el" href="step_17.html">step-17</a> tutorial program:</p>
<ul>
<li>Sequential sections: Many programs have sections of code that either cannot or are not parallelized, i.e., where one processor has to do a certain, fixed amount of work that does not decrease just because there are a total of \(P\) processors around. In <a class="el" href="step_17.html">step-17</a> , this is the case when generating graphical output: one processor creates the graphical output for the entire problem, i.e., it needs to do \({\cal O}(N)\) work. That means that this function has a run time of \({\cal O}(N)\) , regardless of \(P\) , and consequently the overall program will not be able to achieve \({\cal O}(N/P)\) run time but have a run time that can be described as \(c_1N/P + c_2N\) where the first term comes from scalable operations such as assembling the linear system, and the latter from generating graphical output on process 0. If \(c_2\) is sufficiently small, then the program might look like it scales strongly for small numbers of processors, but eventually strong scalability will cease. In addition, the program can not scale weakly either because increasing the size \(N\) of the problem while increasing the number of processors \(P\) at the same rate does not keep the run time of this one function constant.</li>
<li>Duplicated data structures: In <a class="el" href="step_17.html">step-17</a> , each processor stores the entire mesh. That is, each processor has to store a data structure of size \({\cal O}(N)\) , regardless of \(P\) . Eventually, if we make the problem size large enough, this will overflow each processor's memory space even if we increase the number of processors. It is thus clear that such a replicated data structure prevents a program from scaling weakly. But it also prevents it from scaling strongly because in order to create an object of size \({\cal O}(N)\) , one has to at the very least write into \({\cal O}(N)\) memory locations, costing \({\cal O}(N)\) in CPU time. Consequently, there is a component of the overall algorithm that does not behave as \({\cal O}(N/P)\) if we provide more and more processors.</li>
<li>Communication: If, to pick just one example, you want to compute the \(l_2\) norm of a vector of which all MPI processes store a few entries, then every process needs to compute the sum of squares of its own entries (which will require \({\cal O}(N/P)\) time, and consequently scale perfectly), but then every process needs to send their partial sum to one process that adds them all up and takes the square root. In the very best case, sending a message that contains a single number takes a constant amount of time, regardless of the overall number of processes. Thus, again, every program that does communication cannot scale strongly because there are parts of the program whose CPU time requirements do not decrease with the number of processors \(P\) you allocate for a fixed size \(N\) . In reality, the situation is actually even worse: the more processes are participating in a communication step, the longer it will generally take, for example because the one process that has to add everyone's contributions has to add everything up, requiring \({\cal O}(P)\) time. In other words, CPU time <em>increases</em> with the number of processes, therefore not only preventing a program from scaling strongly, but also from scaling weakly. (In reality, MPI libraries do not implement \(l_2\) norms by sending every message to one process that then adds everything up; rather, they do pairwise reductions on a tree that doesn't grow the run time as \({\cal O}(P)\) but as \({\cal O}(\log_2 P)\) , at the expense of more messages sent around. Be that as it may, the fundamental point is that as you add more processors, the run time will grow with \(P\) regardless of the way the operation is actually implemented, and it can therefore not scale.) These, and other reasons that prevent programs from scaling perfectly can be summarized in <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law"><em>Amdahl's law</em><em>Amdahl's law</em></a> that states that if a fraction \(\alpha\) of a program's overall work \(W\) can be parallelized, i.e., it can be run in \({\cal O}(\alpha W/P)\) time, and a fraction \(1-\alpha\) of the program's work can not be parallelized (i.e., it consists either of work that only one process can do, such as generating graphical output in <a class="el" href="step_17.html">step-17</a> ; or that every process has to execute in a replicated way, such as sending a message with a local contribution to a dedicated process for accumulation), then the overall run time of the program will be</li>
</ul>
<p class="formulaDsp">
\begin{align*} T = {\cal O}\left(\alpha \frac WP + (1-\alpha)W \right). \end{align*}
</p>
<p> Consequently, the "speedup" you get, i.e., the factor by which your programs run faster on \(P\) processors compared to running the program on a single process (assuming this is possible) would be</p>
<p class="formulaDsp">
\begin{align*} S = \frac{W}{\alpha \frac WP + (1-\alpha)W} = \frac{P}{\alpha + (1-\alpha)P}. \end{align*}
</p>
<p> If \(\alpha&lt;1\) , which it is for all practically existing programs, then \(S\rightarrow \frac{1}{1-\alpha}\) as \(P\rightarrow \infty\) , implying that there is a point where it does not pay off in any significant way any more to throw more processors at the problem. In practice, what matters is <em>up to which problem size</em> or <em>up to which number of processes</em> or <em>down to which size of local problems \({\cal}(N/P)\)</em> a program scales. For deal.II, experience shows that on most clusters with a reasonable fast network, one can solve problems up to a few billion unknowns, up to a few thousand processors, and down to somewhere between 40,000 and 100,000 unknowns per process. The last number is the most relevant: if you have a problem with, say, \(10^8\) unknowns, then it makes sense to solve it on 1000-2500 processors since the number of degrees of freedom each process handles remains at more than 40,000. Consequently, there is enough work every process has to do so that the \({\cal O}(1)\) time for communication does not dominate. But it doesn't make sense to solve such a problem with 10,000 or 100,000 processors, since each of these processor's local problem becomes so small that they spend most of their time waiting for communication, rather than doing work on their part of the work.  </p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossPeriodicConstraints"></a><b>Periodic boundary conditions</b> </dt>
<dd><p class="startdd">Periodic boundary condition are often used when only part of the physical relevant domain is modeled. One assumes that the solution simply continues periodically with respect to the boundaries that are considered periodic. In deal.II, support for this is through <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a> and <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a>. As soon as a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> is used also <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity()</a> has to be called to make sure that all the processes know about relevant parts of the triangulation on both sides of the periodic boundary. A typical process for distributed triangulations would be:</p>
<ul>
<li>Create a mesh</li>
<li>Gather the periodic faces using <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> (<a class="el" href="classTriangulation.html">Triangulation</a>)</li>
<li>Add the periodicity information to the mesh using <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity()</a></li>
<li>Gather the periodic faces using <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>)</li>
<li>Add periodicity constraints using <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a> An example for this can be found in <a class="el" href="step_45.html">step-45</a> . </li>
</ul>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossPrimitive"></a><b>Primitive finite elements</b> </dt>
<dd><p class="startdd">A finite element (described by its shape functions) is primitive if there is a unique relation from shape function number to vector <a class="el" href="DEALGlossary.html#GlossComponent">component</a>. What this means is that each shape function of a vector-valued element has exactly one nonzero component if an element is primitive. This includes, in particular, all scalar elements as well as vector-valued elements assembled via the <a class="el" href="classFESystem.html">FESystem</a> class from other primitive (for example scalar) elements as shown in <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_29.html">step-29</a> , <a class="el" href="step_22.html">step-22</a> and several others. On the other hand, the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class used in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a> , or the <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> class provide non-primitive finite elements because there, each vector-value shape function may have several non-zero components. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossReferenceCell"></a><b>Reference cell</b> </dt>
<dd><p class="startdd">The hypercube [0,1]<sup>dim</sup>, on which all parametric finite element shape functions are defined. Many properties of the reference cell are described by the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSerialization"></a><b>Serialization</b> </dt>
<dd><p class="startdd">The term "serialization" refers to the process of writing the state of an object to a stream and later retrieve it again. A typical use case is to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job). In either case, one wants to occasionally save the state of the program so that, upon failure, one can restart it at that point rather than having to run it again from the beginning. deal.II implements serialization facilities by implementing the necessary interfaces for the <a href="http://www.boost.org/doc/libs/1_62_0/libs/serialization/doc/index.html" target="_top">BOOST serialization</a> library. See there for examples on how to save and restore objects. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossShape"></a><b>Shape functions</b> </dt>
<dd><p class="startdd">The restriction of the finite element basis functions to a single grid cell. </p>
<p>For programs that are parallelized based on MPI but where each processor stores the entire triangulation (as in, for example, <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> , but not in <a class="el" href="step_40.html">step-40</a> ), subdomain ids are assigned to cells by partitioning a mesh, and each MPI process then only works on those cells it "owns", i.e., that belong to a subdomain the processor owns (traditionally, this is the case for the subdomain id whose numerical value coincides with the rank of the MPI process within the MPI communicator). Partitioning is typically done using the <a class="el" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">GridTools::partition()</a> function, but any other method can also be used to do this. (Alternatively, the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> class can partition the mesh automatically using a similar approach.) In addition to regular subdomain ids, there is a second, closely related set of flags that are associated with each cell: "level subdomain ids." These exist not only for active cells but, in fact, for every cell in a mesh hierarchy. Their meaning is entirely analogous to the regular subdomain ids, but they are read and written by the <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">CellAccessor::level_subdomain_id()</a> and <a class="el" href="classCellAccessor.html#a2bfad9f24d9ddbc86883614639d4886d">CellAccessor::set_level_subdomain_id()</a> functions. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSupport"></a><b>Support points</b> </dt>
<dd><p class="startdd">Support points are by definition those points \(p_i\) , such that for the shape functions \(v_j\) holds \(v_j(p_i) = \delta_{ij}\) . Therefore, a finite element interpolation can be defined uniquely by the values in the support points. Lagrangian elements fill the vector accessed by <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">FiniteElement::get_unit_support_points()</a>, such that the function <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">FiniteElement::has_support_points()</a> returns <code>true</code>. Naturally, these support points are on the <a class="el" href="DEALGlossary.html#GlossReferenceCell">reference cell</a>. Then, <a class="el" href="classFEValues.html">FEValues</a> can be used (in conjunction with a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>) to access support points on the actual grid cells.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossTargetComponent"></a><b>Target component</b> </dt>
<dd><p class="startdd">When vectors and matrices are grouped into blocks by component, it is often desirable to collect several of the original components into a single one. This could be for instance, grouping the velocities of a Stokes system into a single block. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUserFlags"></a><b>User flags</b> </dt>
<dd><p class="startdd">A triangulation offers one bit per line, quad, etc for user flags. This field can be accessed as all other data using iterators, using the syntax </p><div class="fragment"><div class="line">cell-&gt;set_user_flag();                <span class="comment">// set the user flag of a cell</span></div><div class="line"><span class="keywordflow">if</span> (cell-&gt;user_flag_set() == <span class="keyword">false</span>)   <span class="comment">// if cell hasn&#39;t been flagged yet</span></div><div class="line">  {</div><div class="line">     cell-&gt;face(0)-&gt;set_user_flag();  <span class="comment">// flag its first face</span></div><div class="line">  }</div></div><!-- fragment --><p> Typically, this user flag is used if an algorithm walks over all cells and needs information whether another cell, e.g. a neighbor, has already been processed. Similarly, it can be used to flag faces, quads or lines at the boundary for which some operation has already been performed. The latter is often useful since a loop such as </p><div class="fragment"><div class="line"><span class="comment">// in 3d</span></div><div class="line"><span class="keywordflow">for</span> (cell=dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell!=dof_handler.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">         <span class="keywordflow">do</span> something with <span class="keyword">this</span> line</div><div class="line">      }</div></div><!-- fragment --><p> encounters some boundary lines more than once. Consequently, one would set the user flag of the line in the body of the loop, and only enter the body if the user flag had not previously been set. There are a number of additional functions that can be accessed through the iterator interface; see the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class for more information. Note that there are no user flags that can be associated with vertices; however, since vertices are numbered consecutively, this can easily be emulated in user code using a vector of bools. There are two functions, <a class="el" href="classTriangulation.html#a6a9971ee882f15fe521afc4e079383b5">Triangulation::save_user_flags</a> and <a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">Triangulation::load_user_flags</a> which write and read these flags to and from a stream or a vector of bools. Unlike <a class="el" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">Triangulation::save_refine_flags</a> and <a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">Triangulation::load_refine_flags</a>, these two functions store and read the flags of all used lines, quads, etc, i.e., not only of the active ones. If you want to store more specific user flags, you can use the functions <a class="el" href="classTriangulation.html#a2b7d8e059d6f8f903879eea858215fb8">Triangulation::save_user_flags_line</a> and <a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">Triangulation::load_user_flags_line</a> and the similarly for quads, etc. As for the refinement and coarsening flags, there exist two versions of these functions, one which reads/writes from a stream and one which does so from a <code>vector &lt;bool&gt;</code>. The latter is used to store flags temporarily, while the first is used to store them in a file. It is good practice to clear the user flags using the <a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">Triangulation::clear_user_flags()</a> function before usage, since it is often necessary to use the flags in more than one function. If the flags may be in use at the time a function that needs them is called, then this function should save and restore the flags as described above.</p>
<dl class="section note"><dt>Note</dt><dd>If more information than just a single boolean flag needs to be stored with a cell, line, or face, then see about <a class="el" href="DEALGlossary.html#GlossUserData">user data</a>. </dd></dl>
<p>User data is stored and retrieved in the following manner: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (cell=dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell!=dof_handler.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">        cell-&gt;line(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)-&gt;set_user_index(42);</div><div class="line">      }</div></div><!-- fragment --><p> Similarly, there are functions <a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">TriaAccessor::set_user_pointer</a> to set a pointer, and <a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">TriaAccessor::user_index</a> and <a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">TriaAccessor::user_pointer</a> to retrieve the index and pointer. To clear all user indices or pointers, use <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a>. As with flags, there are functions that allow to save and restore user data, either for all entities of the mesh hierarchy or for lines, quads or hexes separately. There are a number of additional functions that can be accessed through the iterator interface; see the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are stored in the same place. In order to avoid unwanted conversions, <a class="el" href="classTriangulation.html">Triangulation</a> checks which one of them is in use and does not allow access to the other one, until <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> has been called.</dd>
<dd>
The usual warning about the missing type safety of <code>void</code> pointers are obviously in place here; responsibility for correctness of types etc lies entirely with the user of the pointer. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="workstream_paper"></a><b>WorkStream paper</b> </dt>
<dd><p class="startdd">The "WorkStream paper" is a paper by B. Turcksin, M. Kronbichler and W. Bangerth that discusses the design and implementation of <a class="el" href="namespaceWorkStream.html">WorkStream</a>. <a class="el" href="namespaceWorkStream.html">WorkStream</a> is, at its core, a design pattern, i.e., something that is used over and over in finite element codes and that can, consequently, be implemented generically. In particular, the paper lays out the motivation for this pattern and then proposes different ways of implementing it. It also compares the performance of different implementations. The full reference for this paper is as follows:</p>
<div class="fragment"><div class="line">@Article{TKB16,</div><div class="line">author =       {Bruno Turcksin and Martin Kronbichler and Wolfgang Bangerth},</div><div class="line">title =        {\textit{WorkStream}</div><div class="line"></div><div class="line">-- a design pattern for multicore-enabled finite element computations},</div><div class="line">journal =      {accepted for publication in the ACM Trans. Math. Softw.},</div><div class="line">year =         2016</div><div class="line">}</div></div><!-- fragment --><p> It is available from <a href="http://www.math.colostate.edu/~bangerth/publications.html">http://www.math.colostate.edu/~bangerth/publications.html</a>, also see <a href="https://www.dealii.org/publications.html#details">deal.II publications</a> for details. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossZOrder"></a><b>Z order</b> </dt>
<dd><p class="startdd">The "Z order" of cells describes an order in which cells are traversed. Because the order in which cells are created factors into the order of cells, it can happen that the order in which you traverse cells is different for two identical meshes. For example, think of a 1d (coarse) mesh with two cells: If you first refine the first of these cells and then the other, then you will traverse the four cells on refinement level 1 in a different order than if you had first refined the second coarse cell and then the first coarse cell. This order is entirely practical for almost all applications because in most cases, it does not actually matter in which order one traverses cells. Furthermore, it allows using data structures that lead to particularly low cache miss frequencies and are therefore efficient for high performance computing applications. On the other hand, there are cases where one would want to traverse cells in a particular, specified and reproducible order that only depends on the mesh itself, not its creation history or any other seemingly arbitrary design decisions. The "Z order" is one way to achieve this goal. </p><div class="image">
<img src="simple-mesh-0.png" alt="simple-mesh-0.png"/>
<div class="caption">
A coarse mesh</div></div>
 <div class="image">
<img src="simple-mesh-1.png" alt="simple-mesh-1.png"/>
<div class="caption">
The mesh after one refinement cycle</div></div>
 <div class="image">
<img src="simple-mesh-2.png" alt="simple-mesh-2.png"/>
<div class="caption">
The mesh after two refinement cycles</div></div>
 <div class="image">
<img src="simple-mesh-3.png" alt="simple-mesh-3.png"/>
<div class="caption">
The mesh after three refinement cycles</div></div>
<p>Note how the cells on level 2 are ordered in the order in which they were created. (Which is not always the case: if cells had been removed in between, then newly created cells would have filled in the holes so created.) The "natural" order in which deal.II traverses cells would then be 0.0</p>
<p>-&gt; 1.0</p>
<p>-&gt; 1.1</p>
<p>-&gt; 1.2</p>
<p>-&gt; 1.3</p>
<p>-&gt; 2.0</p>
<p>-&gt; 2.1</p>
<p>-&gt; 2.2</p>
<p>-&gt; 2.3</p>
<p>-&gt; 2.4</p>
<p>-&gt; 2.5</p>
<p>-&gt; 2.6</p>
<div class="image">
<img src="simple-mesh-tree.png" alt="simple-mesh-tree.png"/>
<div class="caption">
The tree that corresponds to the mesh after three refinement cycles</div></div>
<p>On the other hand, the Z order corresponds to a particular depth-first traversal of the tree. Namely: start with a cell, and if it has children then iterate over these cell's children; this rule is recursively applied as long as a child has children. For the given mesh above, this yields the following order: 0.0</p>
<p>-&gt; 1.0</p>
<p>-&gt; 2.4</p>
<p>-&gt; 2.5</p>
<p>-&gt; 2.6</p>
<p>-&gt; 2.7</p>
<p>-&gt; 1.1</p>
<p>-&gt; 1.2</p>
<p>-&gt; 1.3</p>
<p>-&gt; 1.4</p>
<p>-&gt; 2.0</p>
<p>-&gt; 2.1</p>
<p>-&gt; 2.2</p>
<p>-&gt; 2.3. (Again, if you only care about active cells, then remove 0.0, 1.0, and 1.3 from this list.) Because the order of children of a cell is well defined (as opposed to the order of cells within each level), this "hierarchical" traversal makes sense and is, in particular, independent of the history of a triangulation. In practice, it is easily implemented using a recursive function: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> visit_cells_hierarchically (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;has_children())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;cell-&gt;n_children(); ++c)</div><div class="line">      visit_cells_hierarchically (cell-&gt;child(c));</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      ... <span class="keywordflow">do</span> whatever you wanted to <span class="keywordflow">do</span> on each cell ...;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> This function is then called as follows: </p><div class="fragment"><div class="line"><span class="comment">// loop over all coarse mesh cells</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> cell = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.begin(0);</div><div class="line">     cell != <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.end(); ++cell)</div><div class="line">  visit_cells_hierarchically (cell);</div></div><!-- fragment --><p>Finally, as an explanation of the term "Z" order: if you draw a line through all cells in the order in which they appear in this hierarchical fashion, then it will look like a left-right inverted Z on each refined cell. Indeed, the curve so defined can be thought of a space-filling curve and is also sometimes called "Morton ordering", see <a href="https://en.wikipedia.org/wiki/Z-order_curve">https://en.wikipedia.org/wiki/Z-order_curve</a> . </p>
<p class="enddd"></p>
</dd>
</dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
