<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_21.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-21 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-21 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_20.html">step-20</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetwophaseflowproblem">The two phase flow problem</a>
        <li><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Choosingatimestep">Choosing a time step</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeTwoPhaseFlowProblemcodeclass">The <code>TwoPhaseFlowProblem</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
      <ul>
        <li><a href="#Pressurerighthandside">Pressure right hand side</a>
        <li><a href="#Pressureboundaryvalues">Pressure boundary values</a>
        <li><a href="#Saturationboundaryvalues">Saturation boundary values</a>
        <li><a href="#Initialdata">Initial data</a>
      </ul>
        <li><a href="#Theinversepermeabilitytensor">The inverse permeability tensor</a>
      <ul>
        <li><a href="#Singlecurvingcrackpermeability">Single curving crack permeability</a>
        <li><a href="#Randommediumpermeability">Random medium permeability</a>
      </ul>
        <li><a href="#Theinversemobilityandsaturationfunctions">The inverse mobility and saturation functions</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
        <li><a href="#codeTwoPhaseFlowProblemcodeclassimplementation"><code>TwoPhaseFlowProblem</code> class implementation</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemTwoPhaseFlowProblem">TwoPhaseFlowProblem::TwoPhaseFlowProblem</a>
        <li><a href="#TwoPhaseFlowProblemmake_grid_and_dofs">TwoPhaseFlowProblem::make_grid_and_dofs</a>
        <li><a href="#TwoPhaseFlowProblemassemble_system">TwoPhaseFlowProblem::assemble_system</a>
        <li><a href="#TwoPhaseFlowProblemassemble_rhs_S">TwoPhaseFlowProblem::assemble_rhs_S</a>
        <li><a href="#TwoPhaseFlowProblemsolve">TwoPhaseFlowProblem::solve</a>
        <li><a href="#TwoPhaseFlowProblemoutput_results">TwoPhaseFlowProblem::output_results</a>
        <li><a href="#TwoPhaseFlowProblemproject_back_saturation">TwoPhaseFlowProblem::project_back_saturation</a>
        <li><a href="#TwoPhaseFlowProblemget_maximal_velocity">TwoPhaseFlowProblem::get_maximal_velocity</a>
        <li><a href="#TwoPhaseFlowProblemrun">TwoPhaseFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Solvers">Solvers</a>
        <li><a href="#Timestepping">Time stepping</a>
        <li><a href="#Adaptivity">Adaptivity</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Introduction"></a><a class="anchor" id="Intro"></a> </p><h1>Introduction</h1>
<p>This program grew out of a student project by Yan Li at Texas A&amp;M University. Most of the work for this program is by her.</p>
<p>In this project, we propose a numerical simulation for two phase flow problems in porous media. This problem includes one elliptic equation and one nonlinear, time dependent transport equation. This is therefore also the first time-dependent tutorial program (besides the somewhat strange time-dependence of <a class="el" href="step_18.html">step-18</a>).</p>
<p>The equations covered here are an extension of the material already covered in <a class="el" href="step_20.html">step-20</a>. In particular, they fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Thetwophaseflowproblem"></a></p><h3>The two phase flow problem</h3>
<p>Modeling of two phase flow in porous media is important for both environmental remediation and the management of petroleum and groundwater reservoirs. Practical situations involving two phase flow include the dispersal of a nonaqueous phase liquid in an aquifer, or the joint movement of a mixture of fluids such as oil and water in a reservoir. Simulation models, if they are to provide realistic predictions, must accurately account for these effects.</p>
<p>To derive the governing equations, consider two phase flow in a reservoir \(\Omega\) under the assumption that the movement of fluids is dominated by viscous effects; i.e. we neglect the effects of gravity, compressibility, and capillary pressure. Porosity will be considered to be constant. We will denote variables referring to either of the two phases using subscripts \(w\) and \(o\), short for water and oil. The derivation of the equations holds for other pairs of fluids as well, however.</p>
<p>The velocity with which molecules of each of the two phases move is determined by Darcy's law that states that the velocity is proportional to the pressure gradient: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}_{j} = -\frac{k_{rj}(S)}{\mu_{j}} \mathbf{K} \cdot \nabla p \end{eqnarray*}
</p>
<p> where \(\mathbf{u}_{j}\) is the velocity of phase \(j=o,w\), \(K\) is the permeability tensor, \(k_{rj}\) is the relative permeability of phase \(j\), \(p\) is the pressure and \(\mu_{j}\) is the viscosity of phase \(j\). Finally, \(S\) is the saturation (volume fraction), i.e. a function with values between 0 and 1 indicating the composition of the mixture of fluids. In general, the coefficients \(K, k_{rj}, \mu\) may be spatially dependent variables, and we will always treat them as non-constant functions in the following.</p>
<p>We combine Darcy's law with the statement of conservation of mass for each phase, </p><p class="formulaDsp">
\[ \textrm{div}\ \mathbf{u}_{j} = q_j, \]
</p>
<p> with a source term for each phase. By summing over the two phases, we can express the governing equations in terms of the so-called pressure equation: </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p)= q. \end{eqnarray*}
</p>
<p> Here, \(q\) is the sum source term, and </p><p class="formulaDsp">
\[ \lambda(S) = \frac{k_{rw}(S)}{\mu_{w}}+\frac{k_{ro}(S)}{\mu_{o}} \]
</p>
<p> is the total mobility.</p>
<p>So far, this looks like an ordinary stationary, Poisson-like equation that we can solve right away with the techniques of the first few tutorial programs (take a look at <a class="el" href="step_6.html">step-6</a>, for example, for something very similar). However, we have not said anything yet about the saturation, which of course is going to change as the fluids move around.</p>
<p>The second part of the equations is the description of the dynamics of the saturation, i.e., how the relative concentration of the two fluids changes with time. The saturation equation for the displacing fluid (water) is given by the following conservation law: </p><p class="formulaDsp">
\begin{eqnarray*} S_{t} + \nabla \cdot (F(S) \mathbf{u}) = q_{w}, \end{eqnarray*}
</p>
<p> which can be rewritten by using the product rule of the divergence operator in the previous equation: </p><p class="formulaDsp">
\begin{eqnarray*} S_{t} + F(S) \left[\nabla \cdot \mathbf{u}\right] + \mathbf{u} \cdot \left[ \nabla F(S)\right] = S_{t} + F(S) q + \mathbf{u} \cdot \nabla F(S) = q_{w}. \end{eqnarray*}
</p>
<p> Here, \(q=\nabla\cdot \mathbf{u}\) is the total influx introduced above, and \(q_{w}\) is the flow rate of the displacing fluid (water). These two are related to the fractional flow \(F(S)\) in the following way: </p><p class="formulaDsp">
\[ q_{w} = F(S) q, \]
</p>
<p> where the fractional flow is often parameterized via the (heuristic) expression </p><p class="formulaDsp">
\[ F(S) = \frac{k_{rw}(S)/\mu_{w}}{k_{rw}(S)/\mu_{w} + k_{ro}(S)/\mu_{o}}. \]
</p>
<p> Putting it all together yields the saturation equation in the following, advected form: </p><p class="formulaDsp">
\begin{eqnarray*} S_{t} + \mathbf{u} \cdot \nabla F(S) = 0, \end{eqnarray*}
</p>
<p> where \(\mathbf u\) is the total velocity </p><p class="formulaDsp">
\[ \mathbf{u} = \mathbf{u}_{o} + \mathbf{u}_{w} = -\lambda(S) \mathbf{K}\cdot\nabla p. \]
</p>
<p> Note that the advection equation contains the term \(\mathbf{u} \cdot \nabla F(S)\) rather than \(\mathbf{u} \cdot \nabla S\) to indicate that the saturation is not simply transported along; rather, since the two phases move with different velocities, the saturation can actually change even in the advected coordinate system. To see this, rewrite \(\mathbf{u} \cdot \nabla F(S) = \mathbf{u} F&#39;(S) \cdot \nabla S\) to observe that the <em>actual</em> velocity with which the phase with saturation \(S\) is transported is \(\mathbf u F&#39;(S)\) whereas the other phase is transported at velocity \(\mathbf u (1-F&#39;(S))\). \(F(S)\) is consequently often referred to as the <em>fractional flow</em>.</p>
<p>In summary, what we get are the following two equations: </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p) &amp;=&amp; q \qquad \textrm{in}\ \Omega\times[0,T], \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times[0,T]. \end{eqnarray*}
</p>
<p> Here, \(p=p(\mathbf x, t), S=S(\mathbf x, t)\) are now time dependent functions: while at every time instant the flow field is in equilibrium with the pressure (i.e. we neglect dynamic accelerations), the saturation is transported along with the flow and therefore changes over time, in turn affected the flow field again through the dependence of the first equation on \(S\).</p>
<p>This set of equations has a peculiar character: one of the two equations has a time derivative, the other one doesn't. This corresponds to the character that the pressure and velocities are coupled through an instantaneous constraint, whereas the saturation evolves over finite time scales.</p>
<p>Such systems of equations are called Differential Algebraic Equations (DAEs), since one of the equations is a differential equation, the other is not (at least not with respect to the time variable) and is therefore an "algebraic" equation. (The notation comes from the field of ordinary differential equations, where everything that does not have derivatives with respect to the time variable is necessarily an algebraic equation.) This class of equations contains pretty well-known cases: for example, the time dependent Stokes and Navier-Stokes equations (where the algebraic constraint is that the divergence of the flow field, \(\textrm{div}\ \mathbf u\), must be zero) as well as the time dependent Maxwell equations (here, the algebraic constraint is that the divergence of the electric displacement field equals the charge density, \(\textrm{div}\ \mathbf D = \rho\) and that the divergence of the magnetic flux density is zero: \(\textrm{div}\ \mathbf B = 0\)); even the quasistatic model of <a class="el" href="step_18.html">step-18</a> falls into this category. We will see that the different character of the two equations will inform our discretization strategy for the two equations.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>In the reservoir simulation community, it is common to solve the equations derived above by going back to the first order, mixed formulation. To this end, we re-introduce the total velocity \(\mathbf u\) and write the equations in the following form: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}+\mathbf{K}\lambda(S) \nabla p&amp;=&amp;0 \\ \nabla \cdot\mathbf{u} &amp;=&amp; q \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> This formulation has the additional benefit that we do not have to express the total velocity \(\mathbf u\) appearing in the transport equation as a function of the pressure, but can rather take the primary variable for it. Given the saddle point structure of the first two equations and their similarity to the mixed Laplace formulation we have introduced in <a class="el" href="step_20.html">step-20</a>, it will come as no surprise that we will use a mixed discretization again.</p>
<p>But let's postpone this for a moment. The first business we have with these equations is to think about the time discretization. In reservoir simulation, there is a rather standard algorithm that we will use here. It first solves the pressure using an implicit equation, then the saturation using an explicit time stepping scheme. The algorithm is called IMPES for IMplicit Pressure Explicit Saturation and was first proposed a long time ago: by Sheldon et al. in 1959 and Stone and Gardner in 1961 (J. W. Sheldon, B. Zondek and W. T. Cardwell: <em>One-dimensional, incompressible, non-capillary, two-phase fluid flow in a porous medium</em>, Trans. SPE AIME, 216 (1959), pp. 290-296; H. L. Stone and A. O. Gardner Jr: <em>Analysis of gas-cap or dissolved-gas reservoirs</em>, Trans. SPE AIME, 222 (1961), pp. 92-104). In a slightly modified form, this algorithm can be written as follows: for each time step, solve </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}^{n+1}+\mathbf{K}\lambda(S^n) \nabla p^{n+1}&amp;=&amp;0 \\ \nabla \cdot\mathbf{u}^{n+1} &amp;=&amp; q^{n+1} \\ \frac {S^{n+1}-S^n}{\triangle t} + \mathbf{u}^{n+1} \cdot \nabla F(S^n) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> where \(\triangle t\) is the length of a time step. Note how we solve the implicit pressure-velocity system that only depends on the previously computed saturation \(S^n\), and then do an explicit time step for \(S^{n+1}\) that only depends on the previously known \(S^n\) and the just computed \(\mathbf{u}^{n+1}\). This way, we never have to iterate for the nonlinearities of the system as we would have if we used a fully implicit method. (In a more modern perspective, this should be seen as an "operator
splitting" method. <a class="el" href="step_58.html">step-58</a> has a long description of the idea behind this.)</p>
<p>We can then state the problem in weak form as follows, by multiplying each equation with test functions \(\mathbf v\), \(\phi\), and \(\sigma\) and integrating terms by parts: </p><p class="formulaDsp">
\begin{eqnarray*} \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{u}^{n+1},\mathbf v\right)_\Omega - (p^{n+1}, \nabla\cdot\mathbf v)_\Omega &amp;=&amp; - (p^{n+1}, \mathbf v)_{\partial\Omega} \\ (\nabla \cdot\mathbf{u}^{n+1}, \phi)_\Omega &amp;=&amp; (q^{n+1},\phi)_\Omega \end{eqnarray*}
</p>
<p> Note that in the first term, we have to prescribe the pressure \(p^{n+1}\) on the boundary \(\partial\Omega\) as boundary values for our problem. \(\mathbf n\) denotes the unit outward normal vector to \(\partial K\), as usual.</p>
<p>For the saturation equation, we obtain after integrating by parts </p><p class="formulaDsp">
\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n), \nabla \cdot (\mathbf{u}^{n+1} \sigma)\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}, \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega. \end{eqnarray*}
</p>
<p> Using the fact that \(\nabla \cdot \mathbf{u}^{n+1}=q^{n+1}\), we can rewrite the cell term to get an equation as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n) \mathbf{u}^{n+1}, \nabla \sigma\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega + \triangle t \sum_K \left(F(S^n) q^{n+1}, \sigma\right)_K. \end{eqnarray*}
</p>
<p> We introduce an object of type <a class="el" href="classDiscreteTime.html">DiscreteTime</a> in order to keep track of the current value of time and time step in the code. This class encapsulates many complexities regarding adjusting time step size and stopping at a specified final time.</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>In each time step, we then apply the mixed finite method of <a class="el" href="step_20.html">step-20</a> to the velocity and pressure. To be well-posed, we choose Raviart-Thomas spaces \(RT_{k}\) for \(\mathbf{u}\) and discontinuous elements of class \(DGQ_{k}\) for \(p\). For the saturation, we will also choose \(DGQ_{k}\) spaces.</p>
<p>Since we have discontinuous spaces, we have to think about how to evaluate terms on the interfaces between cells, since discontinuous functions are not really defined there. In particular, we have to give a meaning to the last term on the left hand side of the saturation equation. To this end, let us define that we want to evaluate it in the following sense: </p><p class="formulaDsp">
\begin{eqnarray*} &amp;&amp;\left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \\ &amp;&amp;\qquad = \left(F(S^n_+) (\mathbf n \cdot \mathbf{u}^{n+1}_+), \sigma\right)_{\partial K_+} + \left(F(S^n_-) (\mathbf n \cdot \mathbf{u}^{n+1}_-), \sigma\right)_{\partial K_-}, \end{eqnarray*}
</p>
<p> where \(\partial K_{-} \dealcoloneq \{x\in \partial K, \mathbf{u}(x) \cdot \mathbf{n}&lt;0\}\) denotes the inflow boundary and \(\partial K_{+} \dealcoloneq \{\partial K \setminus \partial K_{-}\}\) is the outflow part of the boundary. The quantities \(S_+,\mathbf{u}_+\) then correspond to the values of these variables on the present cell, whereas \(S_-,\mathbf{u}_-\) (needed on the inflow part of the boundary of \(K\)) are quantities taken from the neighboring cell. Some more context on discontinuous element techniques and evaluation of fluxes can also be found in <a class="el" href="step_12.html">step-12</a> and <a class="el" href="step_12b.html">step-12b</a>.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<p>The linear solvers used in this program are a straightforward extension of the ones used in <a class="el" href="step_20.html">step-20</a> (but without <a class="el" href="classLinearOperator.html">LinearOperator</a>). Essentially, we simply have to extend everything from two to three solution components. If we use the discrete spaces mentioned above and put shape functions into the bilinear forms, we arrive at the following linear system to be solved for time step \(n+1\): </p><p class="formulaDsp">
\[ \left( \begin{array}{ccc} M^u(S^{n}) &amp; B^{T}&amp; 0\\ B &amp; 0 &amp; 0\\ \triangle t\; H &amp; 0&amp; M^S \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{n+1} \\ P^{n+1} \\ S^{n+1} \end{array} \right) = \left( \begin{array}{c} 0 \\ F_2 \\ F_3 \end{array} \right) \]
</p>
<p> where the individual matrices and vectors are defined as follows using shape functions \(\mathbf v_i\) (of type Raviart Thomas \(RT_k\)) for velocities and \(\phi_i\) (of type \(DGQ_k\)) for both pressures and saturations: </p><p class="formulaDsp">
\begin{eqnarray*} M^u(S^n)_{ij} &amp;=&amp; \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{v}_i,\mathbf v_j\right)_\Omega, \\ B_{ij} &amp;=&amp; -(\nabla \cdot \mathbf v_j, \phi_i)_\Omega, \\ H_{ij} &amp;=&amp; - \sum_K \left\{ \left(F(S^n) \mathbf v_i, \nabla \phi_j)\right)_K - \left(F(S^n_+) (\mathbf n \cdot (\mathbf v_i)_+), \phi_j\right)_{\partial K_+} - \left(F(S^n_-) (\mathbf n \cdot (\mathbf v_i)_-), \phi_j\right)_{\partial K_-}, \right\} \\ M^S_{ij} &amp;=&amp; (\phi_i, \phi_j)_\Omega, \\ (F_2)_i &amp;=&amp; -(q^{n+1},\phi_i)_\Omega, \\ (F_3)_i &amp;=&amp; (S^n,\phi_i)_\Omega +\triangle t \sum_K \left(F(S^n) q^{n+1}, \phi_i\right)_K. \end{eqnarray*}
</p>
<dl class="section note"><dt>Note</dt><dd>Due to historical accidents, the role of matrices \(B\) and \(B^T\) has been reverted in this program compared to <a class="el" href="step_20.html">step-20</a>. In other words, here \(B\) refers to the divergence and \(B^T\) to the gradient operators when it was the other way around in <a class="el" href="step_20.html">step-20</a>.</dd></dl>
<p>The system above presents a complication: Since the matrix \(H_{ij}\) depends on \(\mathbf u^{n+1}\) implicitly (the velocities are needed to determine which parts of the boundaries \(\partial K\) of cells are influx or outflux parts), we can only assemble this matrix after we have solved for the velocities.</p>
<p>The solution scheme then involves the following steps: </p><ol>
<li>
<p class="startli">Solve for the pressure \(p^{n+1}\) using the Schur complement technique introduced in <a class="el" href="step_20.html">step-20</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solve for the velocity \(\mathbf u^{n+1}\) as also discussed in <a class="el" href="step_20.html">step-20</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Compute the term \(F_3-\triangle t\; H \mathbf u^{n+1}\), using the just computed velocities.</p>
<p class="endli"></p>
</li>
<li>
Solve for the saturation \(S^{n+1}\). </li>
</ol>
<p>In this scheme, we never actually build the matrix \(H\), but rather generate the right hand side of the third equation once we are ready to do so.</p>
<p>In the program, we use a variable <code>solution</code> to store the solution of the present time step. At the end of each step, we copy its content, i.e. all three of its block components, into the variable <code>old_solution</code> for use in the next time step.</p>
<p><a class="anchor" id="Choosingatimestep"></a></p><h3>Choosing a time step</h3>
<p>A general rule of thumb in hyperbolic transport equations like the equation we have to solve for the saturation equation is that if we use an explicit time stepping scheme, then we should use a time step such that the distance that a particle can travel within one time step is no larger than the diameter of a single cell. In other words, here, we should choose </p><p class="formulaDsp">
\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p> Fortunately, we are in a position where we can do that: we only need the time step when we want to assemble the right hand side of the saturation equation, which is after we have already solved for \(\mathbf{u}^{n+1}\). All we therefore have to do after solving for the velocity is to loop over all quadrature points in the domain and determine the maximal magnitude of the velocity. We can then set the time step for the saturation equation to </p><p class="formulaDsp">
\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p>Why is it important to do this? If we don't, then we will end up with lots of places where our saturation is larger than one or less than zero, as can easily be verified. (Remember that the saturation corresponds to something like the water fraction in the fluid mixture, and therefore must physically be between 0 and 1.) On the other hand, if we choose our time step according to the criterion listed above, this only happens very very infrequently &mdash; in fact only once for the entire run of the program. However, to be on the safe side, however, we run a function <code>project_back_saturation</code> at the end of each time step, that simply projects the saturation back onto the interval \([0,1]\), should it have gotten out of the physical range. This is useful since the functions \(\lambda(S)\) and \(F(S)\) do not represent anything physical outside this range, and we should not expect the program to do anything useful once we have negative saturations or ones larger than one.</p>
<p>Note that we will have similar restrictions on the time step also in <a class="el" href="step_23.html">step-23</a> and <a class="el" href="step_24.html">step-24</a> where we solve the time dependent wave equation, another hyperbolic problem. We will also come back to the issue of time step choice below in the section on <a href="#extensions">possible extensions to this program</a>.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>For simplicity, this program assumes that there is no source, \(q=0\), and that the heterogeneous porous medium is isotropic \(\mathbf{K}(\mathbf{x}) = k(\mathbf{x}) \mathbf{I}\). The first one of these is a realistic assumption in oil reservoirs: apart from injection and production wells, there are usually no mechanisms for fluids to appear or disappear out of the blue. The second one is harder to justify: on a microscopic level, most rocks are isotropic, because they consist of a network of interconnected pores. However, this microscopic scale is out of the range of today's computer simulations, and we have to be content with simulating things on the scale of meters. On that scale, however, fluid transport typically happens through a network of cracks in the rock, rather than through pores. However, cracks often result from external stress fields in the rock layer (for example from tectonic faulting) and the cracks are therefore roughly aligned. This leads to a situation where the permeability is often orders of magnitude larger in the direction parallel to the cracks than perpendicular to the cracks. A problem typically faces in reservoir simulation, however, is that the modeler doesn't know the direction of cracks because oil reservoirs are not accessible to easy inspection. The only solution in that case is to assume an effective, isotropic permeability.</p>
<p>Whatever the matter, both of these restrictions, no sources and isotropy, would be easy to lift with a few lines of code in the program.</p>
<p>Next, for simplicity, our numerical simulation will be done on the unit cell \(\Omega = [0,1]\times [0,1]\) for \(t\in [0,T]\). Our initial conditions are \(S(\mathbf{x},0)=0\); in the oil reservoir picture, where \(S\) would indicate the water saturation, this means that the reservoir contains pure oil at the beginning. Note that we do not need any initial conditions for pressure or velocity, since the equations do not contain time derivatives of these variables. Finally, we impose the following pressure boundary conditions: </p><p class="formulaDsp">
\[ p(\mathbf{x},t)=1-x_1 \qquad \textrm{on}\ \partial\Omega. \]
</p>
<p> Since the pressure and velocity solve a mixed form Poisson equation, the imposed pressure leads to a resulting flow field for the velocity. On the other hand, this flow field determines whether a piece of the boundary is of inflow or outflow type, which is of relevance because we have to impose boundary conditions for the saturation on the inflow part of the boundary, </p><p class="formulaDsp">
\[ \Gamma_{in}(t) = \{\mathbf{x}\in\partial\Omega: \mathbf{n} \cdot \mathbf{u}(\mathbf{x},t) &lt; 0\}. \]
</p>
<p> On this inflow boundary, we impose the following saturation values: </p><p class="formulaDsp">
\begin{eqnarray} S(\mathbf{x},t) = 1 &amp; \textrm{on}\ \Gamma_{in}\cap\{x_1=0\}, \\ S(\mathbf{x},t) = 0 &amp; \textrm{on}\ \Gamma_{in}\backslash \{x_1=0\}. \end{eqnarray}
</p>
<p> In other words, we have pure water entering the reservoir at the left, whereas the other parts of the boundary are in contact with undisturbed parts of the reservoir and whenever influx occurs on these boundaries, pure oil will enter.</p>
<p>In our simulations, we choose the total mobility as </p><p class="formulaDsp">
\[ \lambda (S) = \frac{1.0}{\mu} S^2 +(1-S)^2 \]
</p>
<p> where we use \(\mu=0.2\) for the viscosity. In addition, the fractional flow of water is given by </p><p class="formulaDsp">
\[ F(S)=\frac{S^2}{S^2+\mu (1-S)^2} \]
</p>
<dl class="section note"><dt>Note</dt><dd>Coming back to this testcase in <a class="el" href="step_43.html">step-43</a> several years later revealed an oddity in the setup of this testcase. To this end, consider that we can rewrite the advection equation for the saturation as \(S_{t} + (\mathbf{u} F&#39;(S)) \cdot \nabla S = 0\). Now, at the initial time, we have \(S=0\), and with the given choice of function \(F(S)\), we happen to have \(F&#39;(0)=0\). In other words, at \(t=0\), the equation reduces to \(S_t=0\) for all \(\mathbf x\), so the saturation is zero everywhere and it is going to stay zero everywhere! This is despite the fact that \(\mathbf u\) is not necessarily zero: the combined fluid is moving, but we've chosen our partial flux \(F(S)\) in such a way that infinitesimal amounts of wetting fluid also only move at infinitesimal speeds (i.e., they stick to the medium more than the non-wetting phase in which they are embedded). That said, how can we square this with the knowledge that wetting fluid is invading from the left, leading to the flow patterns seen in the <a href="#Results">results section</a>? That's where we get into mathematics: Equations like the transport equation we are considering here have infinitely many solutions, but only one of them is physical: the one that results from the so-called viscosity limit, called the <a href="http://en.wikipedia.org/wiki/Viscosity_solution">viscosity solution</a>. The thing is that with discontinuous elements we arrive at this viscosity limit because using a numerical flux introduces a finite amount of artificial viscosity into the numerical scheme. On the other hand, in <a class="el" href="step_43.html">step-43</a>, we use an artificial viscosity that is proportional to \(\|\mathbf u F&#39;(S)\|\) on every cell, which at the initial time is zero. Thus, the saturation there is zero and remains zero; the solution we then get is <em>one</em> solution of the advection equation, but the method does not converge to the viscosity solution without further changes. We will therefore use a different initial condition in that program.</dd></dl>
<p>Finally, to come back to the description of the testcase, we will show results for computations with the two permeability functions introduced at the end of the results section of <a class="el" href="step_20.html">step-20</a>: </p><ul>
<li>
<p class="startli">A function that models a single, winding crack that snakes through the domain. In analogy to <a class="el" href="step_20.html">step-20</a>, but taking care of the slightly different geometry we have here, we describe this by the following function: </p><p class="formulaDsp">
\[ k(\mathbf x) = \max \left\{ e^{-\left(\frac{x_2-\frac 12 - 0.1\sin(10x_1)}{0.1}\right)^2}, 0.01 \right\}. \]
</p>
<p> Taking the maximum is necessary to ensure that the ratio between maximal and minimal permeability remains bounded. If we don't do that, permeabilities will span many orders of magnitude. On the other hand, the ratio between maximal and minimal permeability is a factor in the condition number of the Schur complement matrix, and if too large leads to problems for which our linear solvers will no longer converge properly.</p>
<p class="endli"></p>
</li>
<li>
A function that models a somewhat random medium. Here, we choose <p class="formulaDsp">
\begin{eqnarray*} k(\mathbf x) &amp;=&amp; \min \left\{ \max \left\{ \sum_{i=1}^N \sigma_i(\mathbf{x}), 0.01 \right\}, 4\right\}, \\ \sigma_i(\mathbf x) &amp;=&amp; e^{-\left(\frac{|\mathbf{x}-\mathbf{x}_i|}{0.05}\right)^2}, \end{eqnarray*}
</p>
 where the centers \(\mathbf{x}_i\) are \(N\) randomly chosen locations inside the domain. This function models a domain in which there are \(N\) centers of higher permeability (for example where rock has cracked) embedded in a matrix of more pristine, unperturbed background rock. Note that here we have cut off the permeability function both above and below to ensure a bounded condition number. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This program is an adaptation of <a class="el" href="step_20.html">step-20</a> and includes some technique of DG methods from <a class="el" href="step_12.html">step-12</a>. A good part of the program is therefore very similar to <a class="el" href="step_20.html">step-20</a> and we will not comment again on these parts. Only the new stuff will be discussed in more detail.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>All of these include files have been used before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>In this program, we use a tensor-valued coefficient. Since it may have a spatial dependence, we consider it a tensor-valued function. The following include file provides the <code><a class="el" href="classTensorFunction.html">TensorFunction</a></code> class that offers such functionality:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div></div><!-- fragment --><p>Additionally, we use the class <code><a class="el" href="classDiscreteTime.html">DiscreteTime</a></code> to perform operations related to time incrementation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeTwoPhaseFlowProblemcodeclass"></a> </p><h3>The <code>TwoPhaseFlowProblem</code> class</h3>
<p>This is the main class of the program. It is close to the one of <a class="el" href="step_20.html">step-20</a>, but with a few additional functions:</p>
<ul>
<li>
<p class="startli"><code>assemble_rhs_S</code> assembles the right hand side of the saturation equation. As explained in the introduction, this can't be integrated into <code>assemble_rhs</code> since it depends on the velocity that is computed in the first part of the time step.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>get_maximal_velocity</code> does as its name suggests. This function is used in the computation of the time step size.</p>
<p class="endli"></p>
</li>
<li>
<code>project_back_saturation</code> resets all saturation degrees of freedom with values less than zero to zero, and all those with saturations greater than one to one. </li>
</ul>
<p>The rest of the class should be pretty much obvious. The <code>viscosity</code> variable stores the viscosity \(\mu\) that enters several of the formulas in the nonlinear equations. The variable <code>time</code> keeps track of the time information within the simulation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_rhs_S();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>   solve();</div><div class="line">  <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">  <span class="keywordtype">void</span>   output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time;</div><div class="line">  <span class="keywordtype">double</span>       viscosity;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p><a class="anchor" id="Pressurerighthandside"></a> </p><h4>Pressure right hand side</h4>
<p>At present, the right hand side of the pressure equation is simply the zero function. However, the rest of the program is fully equipped to deal with anything else, if this is desired:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureRightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Pressureboundaryvalues"></a> </p><h4>Pressure boundary values</h4>
<p>The next are pressure boundary values. As mentioned in the introduction, we choose a linear pressure field:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Saturationboundaryvalues"></a> </p><h4>Saturation boundary values</h4>
<p>Then we also need boundary values on the inflow portions of the boundary. The question whether something is an inflow part is decided when assembling the right hand side, we only have to provide a functional description of the boundary values. This is as explained in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Initialdata"></a> </p><h4>Initial data</h4>
<p>Finally, we need initial data. In reality, we only need initial data for the saturation, but we are lazy, so we will later, before the first time step, simply interpolate the entire solution for the previous time step from a function that contains all vector components.</p>
<p>We therefore simply create a function that returns zero in all components. We do that by simply forward every function to the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> class. Why not use that right away in the places of this program where we presently use the <code>InitialValues</code> class? Because this way it is simpler to later go back and choose a different function for initial values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).<a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(p, component);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).<a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(p, values);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Theinversepermeabilitytensor"></a> </p><h3>The inverse permeability tensor</h3>
<p>As announced in the introduction, we implement two different permeability tensor fields. Each of them we put into a namespace of its own, so that it will be easy later to replace use of one by the other in the code.</p>
<p><a class="anchor" id="Singlecurvingcrackpermeability"></a> </p><h4>Single curving crack permeability</h4>
<p>The first function for the permeability was the one that models a single curving crack. It was already used at the end of <a class="el" href="step_20.html">step-20</a>, and its functional form is given in the introduction of the present tutorial program. As in some previous programs, we have to declare a (seemingly unnecessary) default constructor of the KInverse class to avoid warnings from some compilers:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                              (0.1 * 0.1)),</div><div class="line">                     0.01);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace SingleCurvingCrack</span></div></div><!-- fragment --><p><a class="anchor" id="Randommediumpermeability"></a> </p><h4>Random medium permeability</h4>
<p>This function does as announced in the introduction, i.e. it creates an overlay of exponentials at random places. There is one thing worth considering for this class. The issue centers around the problem that the class creates the centers of the exponentials using a random function. If we therefore created the centers each time we create an object of the present type, we would get a different list of centers each time. That's not what we expect from classes of this type: they should reliably represent the same function.</p>
<p>The solution to this problem is to make the list of centers a static member variable of this class, i.e. there exists exactly one such variable for the entire program, rather than for each object of this type. That's exactly what we are going to do.</p>
<p>The next problem, however, is that we need a way to initialize this variable. Since this variable is initialized at the beginning of the program, we can't use a regular member function for that since there may not be an object of this type around at the time. The C++ standard therefore says that only non-member and static member functions can be used to initialize a static variable. We use the latter possibility by defining a function <code>get_centers</code> that computes the list of center points when called.</p>
<p>Note that this class works just fine in both 2d and 3d, with the only difference being that we use more points in 3d: by experimenting we find that we need more exponentials in 3d than in 2d (we have more ground to cover, after all, if we want to keep the distance between centers roughly equal), so we choose 40 in 2d and 100 in 3d. For any other dimension, the function does presently not know what to do so simply throws an exception indicating exactly this.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>RandomMedium</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> permeability = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">            permeability += std::exp(-(points[p] - centers[i]).norm_square() /</div><div class="line">                                     (0.05 * 0.05));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / normalized_permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; get_centers()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">        (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">      std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          centers_list[i][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> centers_list;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;Point&lt;dim&gt;&gt;</div><div class="line">    KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line">} <span class="comment">// namespace RandomMedium</span></div></div><!-- fragment --><p><a class="anchor" id="Theinversemobilityandsaturationfunctions"></a> </p><h3>The inverse mobility and saturation functions</h3>
<p>There are two more pieces of data that we need to describe, namely the inverse mobility function and the saturation curve. Their form is also given in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>The linear solvers we use are also completely analogous to the ones used in <a class="el" href="step_20.html">step-20</a>. The following classes are therefore copied verbatim from there. Note that the classes here are not only copied from <a class="el" href="step_20.html">step-20</a>, but also duplicate classes in deal.II. In a future version of this example, they should be replaced by an efficient method, though. There is a single change: if the size of a linear system is small, i.e. when the mesh is very coarse, then it is sometimes not sufficient to set a maximum of <code>src.size()</code> CG iterations before the solver in the <code>vmult()</code> function converges. (This is, of course, a result of numerical round-off, since we know that on paper, the CG method converges in at most <code>src.size()</code> steps.) As a consequence, we set the maximum number of iterations equal to the maximum of the size of the linear system and 200.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(std::max&lt;unsigned int&gt;(src.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 200),</div><div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;          <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,</div><div class="line">                  <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>&gt; &amp;Minv)</div><div class="line">    : system_matrix(&amp;A)</div><div class="line">    , m_inverse(&amp;Minv)</div><div class="line">    , tmp1(A.block(0, 0).m())</div><div class="line">    , tmp2(A.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">    m_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt;           system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>&gt;&gt; m_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ApproximateSchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">    : system_matrix(&amp;A)</div><div class="line">    , tmp1(A.block(0, 0).m())</div><div class="line">    , tmp2(A.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">    system_matrix-&gt;block(0, 0).precondition_Jacobi(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="codeTwoPhaseFlowProblemcodeclassimplementation"></a> </p><h3><code>TwoPhaseFlowProblem</code> class implementation</h3>
<p>Here now the implementation of the main class. Much of it is actually copied from <a class="el" href="step_20.html">step-20</a>, so we won't comment on it in much detail. You should try to get familiar with that program first, then most of what is happening here should be mostly clear.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemTwoPhaseFlowProblem"></a> </p><h4>TwoPhaseFlowProblem::TwoPhaseFlowProblem</h4>
<p>First for the constructor. We use \(RT_k \times DQ_k \times DQ_k\) spaces. For initializing the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object, we don't set the time step size in the constructor because we don't have its value yet. The time step size is initially set to zero, but it will be computed before it is needed to increment time, as described in a subsection of the introduction. The time object internally prevents itself from being incremented when \(dt = 0\), forcing us to set a non-zero desired size for \(dt\) before advancing time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : degree(degree)</div><div class="line">  , fe(<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">       1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , n_refinement_steps(5)</div><div class="line">  , time(<span class="comment">/*start time*/</span> 0., <span class="comment">/*end time*/</span> 1.)</div><div class="line">  , viscosity(0.2)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemmake_grid_and_dofs"></a> </p><h4>TwoPhaseFlowProblem::make_grid_and_dofs</h4>
<p>This next function starts out with well-known functions calls that create and refine a mesh, and then associate degrees of freedom with it. It does all the same things as in <a class="el" href="step_20.html">step-20</a>, just now for three components instead of two.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_component =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>(dof_handler);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                     n_p = dofs_per_component[dim],</div><div class="line">                     n_s = dofs_per_component[dim + 1];</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(3, 3);</div><div class="line">  sparsity_pattern.block(0, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(0, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(0, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">  sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, sparsity_pattern);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">  solution.reinit(3);</div><div class="line">  solution.block(0).reinit(n_u);</div><div class="line">  solution.block(1).reinit(n_p);</div><div class="line">  solution.block(2).reinit(n_s);</div><div class="line">  solution.collect_sizes();</div><div class="line"></div><div class="line">  old_solution.reinit(3);</div><div class="line">  old_solution.block(0).reinit(n_u);</div><div class="line">  old_solution.block(1).reinit(n_p);</div><div class="line">  old_solution.block(2).reinit(n_s);</div><div class="line">  old_solution.collect_sizes();</div><div class="line"></div><div class="line">  system_rhs.reinit(3);</div><div class="line">  system_rhs.block(0).reinit(n_u);</div><div class="line">  system_rhs.block(1).reinit(n_p);</div><div class="line">  system_rhs.block(2).reinit(n_s);</div><div class="line">  system_rhs.collect_sizes();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemassemble_system"></a> </p><h4>TwoPhaseFlowProblem::assemble_system</h4>
<p>This is the function that assembles the linear system, or at least everything except the (1,3) block that depends on the still-unknown velocity computed during this time step (we deal with this in <code>assemble_rhs_S</code>). Much of it is again as in <a class="el" href="step_20.html">step-20</a>, but we have to deal with some nonlinearity this time. However, the top of the function is pretty much as usual (note that we set matrix and right hand side to zero at the beginning &mdash; something we didn't have to do for stationary problems since there we use each matrix object only once and it is empty at the beginning anyway).</p>
<p>Note that in its present form, the function uses the permeability implemented in the RandomMedium::KInverse class. Switching to the single curved crack permeability function is as simple as just changing the namespace name.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">  <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">  <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt;              old_solution_values(n_q_points,</div><div class="line">                                                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;1, dim&gt;&gt;&gt; old_solution_grads(</div><div class="line">    n_q_points, std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt;(dim + 2));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs    = 0;</div></div><!-- fragment --><p>Here's the first significant difference: We have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> (previously already used in <a class="el" href="step_9.html">step-9</a>, <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_15.html">step-15</a>), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div></div><!-- fragment --><p>Then we also have to get the values of the pressure right hand side and of the inverse permeability tensor at the quadrature points:</p>
<div class="fragment"><div class="line">pressure_right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    pressure_rhs_values);</div><div class="line">k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                     k_inverse_values);</div></div><!-- fragment --><p>With all this, we can now loop over all the quadrature points and shape functions on this cell and assemble those parts of the matrix and right hand side that we deal with in this function. The individual terms in the contributions should be self-explanatory given the explicit form of the bilinear form stated in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim + 1);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u = fe_values[velocities].value(i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_i_u = fe_values[velocities].divergence(i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_p     = fe_values[pressure].value(i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s     = fe_values[saturation].value(i, q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j_u =</div><div class="line">            fe_values[velocities].value(j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_j_u =</div><div class="line">            fe_values[velocities].divergence(j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_p = fe_values[pressure].value(j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = fe_values[saturation].value(j, q);</div><div class="line"></div><div class="line">          local_matrix(i, j) +=</div><div class="line">            (phi_i_u * k_inverse_values[q] *</div><div class="line">               mobility_inverse(old_s, viscosity) * phi_j_u -</div><div class="line">             div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u +</div><div class="line">             phi_i_s * phi_j_s) *</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      local_rhs(i) +=</div><div class="line">        (-phi_i_p * pressure_rhs_values[q]) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div></div><!-- fragment --><p>Next, we also have to deal with the pressure boundary values. This, again is as in <a class="el" href="step_20.html">step-20</a>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">    {</div><div class="line">      fe_face_values.reinit(cell, face);</div><div class="line"></div><div class="line">      pressure_boundary_values.value_list(</div><div class="line">        fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">              fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">            local_rhs(i) +=</div><div class="line">              -(phi_i_u * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                boundary_values[q] * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">          }</div><div class="line">    }</div></div><!-- fragment --><p>The final step in the loop over all cells is to transfer local contributions into the global matrix and right hand side vector:</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            local_matrix(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>So much for assembly of matrix and right hand side. Note that we do not have to interpolate and apply boundary values since they have all been taken care of in the weak form already.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemassemble_rhs_S"></a> </p><h4>TwoPhaseFlowProblem::assemble_rhs_S</h4>
<p>As explained in the introduction, we can only evaluate the right hand side of the saturation equation once the velocity has been computed. We therefore have this separate function to this end.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor(fe,</div><div class="line">                                            face_quadrature_formula,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values(n_q_points,</div><div class="line">                                                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face(n_face_q_points,</div><div class="line">                                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim +</div><div class="line">                                                                      2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face_neighbor(</div><div class="line">    n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values(n_q_points,</div><div class="line">                                                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim +</div><div class="line">                                                                     2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values_face(</div><div class="line">    n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  neighbor_saturation(n_face_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      local_rhs = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, present_solution_values);</div></div><!-- fragment --><p>First for the cell terms. These are, following the formulas in the introduction, \((S^n,\sigma)-(F(S^n) \mathbf{v}^{n+1},\nabla \sigma)\), where \(\sigma\) is the saturation component of the test function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_solution_values[q](dim + 1);</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        present_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = fe_values[saturation].value(i, q);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">        fe_values[saturation].gradient(i, q);</div><div class="line"></div><div class="line">      local_rhs(i) +=</div><div class="line">        (time.get_next_step_size() * fractional_flow(old_s, viscosity) *</div><div class="line">           present_u * grad_phi_i_s +</div><div class="line">         old_s * phi_i_s) *</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div></div><!-- fragment --><p>Secondly, we have to deal with the flux parts on the face boundaries. This was a bit more involved because we first have to determine which are the influx and outflux parts of the cell boundary. If we have an influx boundary, we need to evaluate the saturation on the other side of the face (or the boundary values, if we are at the boundary of the domain).</p>
<p>All this is a bit tricky, but has been explained in some detail already in <a class="el" href="step_9.html">step-9</a>. Take a look there how this is supposed to work!</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">        {</div><div class="line">          fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">          fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution,</div><div class="line">                                             old_solution_values_face);</div><div class="line">          fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution,</div><div class="line">                                             present_solution_values_face);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">            saturation_boundary_values.value_list(</div><div class="line">              fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span>         neighbor = cell-&gt;neighbor(face_no);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face =</div><div class="line">                cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">              fe_face_values_neighbor.reinit(neighbor, neighbor_face);</div><div class="line"></div><div class="line">              fe_face_values_neighbor.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">                old_solution, old_solution_values_face_neighbor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                neighbor_saturation[q] =</div><div class="line">                  old_solution_values_face_neighbor[q](dim + 1);</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">            {</div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                present_u_face[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values_face[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">                present_u_face * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                local_rhs(i) -=</div><div class="line">                  time.get_next_step_size() * normal_flux *</div><div class="line">                  fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                                     old_solution_values_face[q](dim + 1) :</div><div class="line">                                     neighbor_saturation[q]),</div><div class="line">                                  viscosity) *</div><div class="line">                  fe_face_values[saturation].value(i, q) *</div><div class="line">                  fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemsolve"></a> </p><h4>TwoPhaseFlowProblem::solve</h4>
<p>After all these preparations, we finally solve the linear system for velocity and pressure in the same way as in <a class="el" href="step_20.html">step-20</a>. After that, we have to deal with the saturation equation (see below):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;&gt; m_inverse(</div><div class="line">    system_matrix.block(0, 0));</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp2(solution.block(2).size());</div></div><!-- fragment --><p>First the pressure, using the pressure Schur complement of the first two equations:</p>
<div class="fragment"><div class="line">{</div><div class="line">  m_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">  system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">  schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"></div><div class="line">  SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(system_matrix, m_inverse);</div><div class="line"></div><div class="line">  ApproximateSchurComplement approximate_schur_complement(system_matrix);</div><div class="line"></div><div class="line">  InverseMatrix&lt;ApproximateSchurComplement&gt; preconditioner(</div><div class="line">    approximate_schur_complement);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                               1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 * schur_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Now the velocity:</p>
<div class="fragment"><div class="line">{</div><div class="line">  system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">  tmp *= -1;</div><div class="line">  tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">  m_inverse.vmult(solution.block(0), tmp);</div><div class="line">}</div></div><!-- fragment --><p>Finally, we have to take care of the saturation equation. The first business we have here is to determine the time step using the formula in the introduction. Knowing the shape of our domain and that we created the mesh by regular subdivision of cells, we can compute the diameter of each of our cells quite easily (in fact we use the linear extensions in coordinate directions of the cells, not the diameter). Note that we will learn a more general way to do this in <a class="el" href="step_24.html">step-24</a>, where we use the <a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a> function.</p>
<p>The maximal velocity we compute using a helper function to compute the maximal velocity defined below, and with all this we can evaluate our new time step length. We use the method DiscreteTime::set_desired_next_time_step() to suggest the new calculated value of the time step to the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object. In most cases, the time object uses the exact provided value to increment time. It some case, the step size may be modified further by the time object. For example, if the calculated time increment overshoots the end time, it is truncated accordingly.</p>
<div class="fragment"><div class="line">time.set_desired_next_step_size(std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">                                get_maximal_velocity());</div></div><!-- fragment --><p>The next step is to assemble the right hand side, and then to pass everything on for solution. At the end, we project back saturations onto the physically reasonable range:</p>
<div class="fragment"><div class="line">  assemble_rhs_S();</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_matrix.block(2, 2).m(),</div><div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.block(2).l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">    cg.solve(system_matrix.block(2, 2),</div><div class="line">             solution.block(2),</div><div class="line">             system_rhs.block(2),</div><div class="line">             <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    project_back_saturation();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  old_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemoutput_results"></a> </p><h4>TwoPhaseFlowProblem::output_results</h4>
<p>There is nothing surprising here. Since the program will do a lot of time steps, we create an output file only every fifth time step and skip all other time steps at the top of the file already.</p>
<p>When creating file names for output close to the bottom of the function, we convert the number of the time step to a string representation that is padded by leading zeros to four digits. We do this because this way all output file names have the same length, and consequently sort well when creating a directory listing.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (time.get_step_number() % 5 != 0)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_names;</div><div class="line">  <span class="keywordflow">switch</span> (dim)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(degree + 1);</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time.get_step_number(), 4) +</div><div class="line">                       <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemproject_back_saturation"></a> </p><h4>TwoPhaseFlowProblem::project_back_saturation</h4>
<p>In this function, we simply run over all saturation degrees of freedom and make sure that if they should have left the physically reasonable range, that they be reset to the interval \([0,1]\). To do this, we only have to loop over all saturation components of the solution vector; these are stored in the block 2 (block 0 are the velocities, block 1 are the pressures).</p>
<p>It may be instructive to note that this function almost never triggers when the time step is chosen as mentioned in the introduction. However, if we choose the timestep only slightly larger, we get plenty of values outside the proper range. Strictly speaking, the function is therefore unnecessary if we choose the time step small enough. In a sense, the function is therefore only a safety device to avoid situations where our entire solution becomes unphysical because individual degrees of freedom have become unphysical a few time steps earlier.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; solution.block(2).size(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">      solution.block(2)(i) = 0;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">      solution.block(2)(i) = 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemget_maximal_velocity"></a> </p><h4>TwoPhaseFlowProblem::get_maximal_velocity</h4>
<p>The following function is used in determining the maximal allowable time step. What it does is to loop over all quadrature points in the domain and find what the maximal magnitude of the velocity is.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        quadrature_formula(degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; solution_values(n_q_points,</div><div class="line">                                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, solution_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">            velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">          max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemrun"></a> </p><h4>TwoPhaseFlowProblem::run</h4>
<p>This is the final function of our main class. Its brevity speaks for itself. There are only two points worth noting: First, the function projects the initial values onto the finite element space at the beginning; the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function doing this requires an argument indicating the hanging node constraints. We have none in this program (we compute on a uniformly refined mesh), but the function requires the argument anyway, of course. So we have to create a constraint object. In its original state, constraint objects are unsorted, and have to be sorted (using the <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a> function) before they can be used. This is what we do here, and which is why we can't simply call the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function with an anonymous temporary object <code><a class="el" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;()</a></code> as the second argument.</p>
<p>The second point worth mentioning is that we only compute the length of the present time step in the middle of solving the linear system corresponding to each time step. We can therefore output the present time of a time step only at the end of the time step. We increment time by calling the method <a class="el" href="classDiscreteTime.html#aa10f7326a1a864ba38e28c86624fdd51">DiscreteTime::advance_time()</a> inside the loop. Since we are reporting the time and dt after we increment it, we have to call the method <a class="el" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">DiscreteTime::get_previous_step_size()</a> instead of <a class="el" href="classDiscreteTime.html#a07ea63ccba26b095eaa088719b98e85d">DiscreteTime::get_next_step_size()</a>. After many steps, when the simulation reaches the end time, the last dt is chosen by the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> class in such a way that the last step finishes exactly at the end time.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                           constraints,</div><div class="line">                           <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree + 2),</div><div class="line">                           InitialValues&lt;dim&gt;(),</div><div class="line">                           old_solution);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_step_number() + 1 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        time.advance_time();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time.get_current_time()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time.get_previous_step_size() &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step21</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>That's it. In the main function, we pass the degree of the finite element space to the constructor of the TwoPhaseFlowProblem object. Here, we use zero-th degree elements, i.e. \(RT_0\times DQ_0 \times DQ_0\). The rest is as in all the other programs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The code as presented here does not actually compute the results found on the web page. The reason is, that even on a decent computer it runs more than a day. If you want to reproduce these results, modify the end time of the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object to <code>250</code> within the constructor of TwoPhaseFlowProblem.</p>
<p>If we run the program, we get the following kind of output: </p><div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 4160 (2112+1024+1024)</div><div class="line"></div><div class="line">Timestep 1</div><div class="line">   22 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0326742, dt=0.0326742.</div><div class="line"></div><div class="line">Timestep 2</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0653816, dt=0.0327074.</div><div class="line"></div><div class="line">Timestep 3</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0980651, dt=0.0326836.</div><div class="line"></div><div class="line">...</div></div><!-- fragment --><p> As we can see, the time step is pretty much constant right from the start, which indicates that the velocities in the domain are not strongly dependent on changes in saturation, although they certainly are through the factor \(\lambda(S)\) in the pressure equation.</p>
<p>Our second observation is that the number of CG iterations needed to solve the pressure Schur complement equation drops from 22 to 17 between the first and the second time step (in fact, it remains around 17 for the rest of the computations). The reason is actually simple: Before we solve for the pressure during a time step, we don't reset the <code>solution</code> variable to zero. The pressure (and the other variables) therefore have the previous time step's values at the time we get into the CG solver. Since the velocities and pressures don't change very much as computations progress, the previous time step's pressure is actually a good initial guess for this time step's pressure. Consequently, the number of iterations we need once we have computed the pressure once is significantly reduced.</p>
<p>The final observation concerns the number of iterations needed to solve for the saturation, i.e. one. This shouldn't surprise us too much: the matrix we have to solve with is the mass matrix. However, this is the mass matrix for the \(DGQ_0\) element of piecewise constants where no element couples with the degrees of freedom on neighboring cells. The matrix is therefore a diagonal one, and it is clear that we should be able to invert this matrix in a single CG iteration.</p>
<p>With all this, here are a few movies that show how the saturation progresses over time. First, this is for the single crack model, as implemented in the <code>SingleCurvingCrack::KInverse</code> class:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.centerline.gif"/>
</div>
<p>As can be seen, the water rich fluid snakes its way mostly along the high-permeability zone in the middle of the domain, whereas the rest of the domain is mostly impermeable. This and the next movie are generated using <code>n_refinement_steps=7</code>, leading to a \(128\times 128\) mesh with some 16,000 cells and about 66,000 unknowns in total.</p>
<p>The second movie shows the saturation for the random medium model of class <code>RandomMedium::KInverse</code>, where we have randomly distributed centers of high permeability and fluid hops from one of these zones to the next:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random2d.gif"/>
</div>
<p>Finally, here is the same situation in three space dimensions, on a mesh with <code>n_refinement_steps=5</code>, which produces a mesh of some 32,000 cells and 167,000 degrees of freedom:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random3d.gif"/>
</div>
<p>To repeat these computations, all you have to do is to change the line </p><div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p> in the main function to </p><div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;3&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p> The visualization uses a cloud technique, where the saturation is indicated by colored but transparent clouds for each cell. This way, one can also see somewhat what happens deep inside the domain. A different way of visualizing would have been to show isosurfaces of the saturation evolving over time. There are techniques to plot isosurfaces transparently, so that one can see several of them at the same time like the layers of an onion.</p>
<p>So why don't we show such isosurfaces? The problem lies in the way isosurfaces are computed: they require that the field to be visualized is continuous, so that the isosurfaces can be generated by following contours at least across a single cell. However, our saturation field is piecewise constant and discontinuous. If we wanted to plot an isosurface for a saturation \(S=0.5\), chances would be that there is no single point in the domain where that saturation is actually attained. If we had to define isosurfaces in that context at all, we would have to take the interfaces between cells, where one of the two adjacent cells has a saturation greater than and the other cell a saturation less than 0.5. However, it appears that most visualization programs are not equipped to do this kind of transformation.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>There are a number of areas where this program can be improved. Three of them are listed below. All of them are, in fact, addressed in a tutorial program that forms the continuation of the current one: <a class="el" href="step_43.html">step-43</a>.</p>
<p><a class="anchor" id="Solvers"></a></p><h4>Solvers</h4>
<p>At present, the program is not particularly fast: the 2d random medium computation took about a day for the 1,000 or so time steps. The corresponding 3d computation took almost two days for 800 time steps. The reason why it isn't faster than this is twofold. First, we rebuild the entire matrix in every time step, although some parts such as the \(B\), \(B^T\), and \(M^S\) blocks never change.</p>
<p>Second, we could do a lot better with the solver and preconditioners. Presently, we solve the Schur complement \(B^TM^u(S)^{-1}B\) with a CG method, using \([B^T (\textrm{diag}(M^u(S)))^{-1} B]^{-1}\) as a preconditioner. Applying this preconditioner is expensive, since it involves solving a linear system each time. This may have been appropriate for <a class="el" href="step_20.html">step-20</a>, where we have to solve the entire problem only once. However, here we have to solve it hundreds of times, and in such cases it is worth considering a preconditioner that is more expensive to set up the first time, but cheaper to apply later on.</p>
<p>One possibility would be to realize that the matrix we use as preconditioner, \(B^T (\textrm{diag}(M^u(S)))^{-1} B\) is still sparse, and symmetric on top of that. If one looks at the flow field evolve over time, we also see that while \(S\) changes significantly over time, the pressure hardly does and consequently \(B^T (\textrm{diag}(M^u(S)))^{-1} B \approx B^T (\textrm{diag}(M^u(S^0)))^{-1} B\). In other words, the matrix for the first time step should be a good preconditioner also for all later time steps. With a bit of back-and-forthing, it isn't hard to actually get a representation of it as a <a class="el" href="classSparseMatrix.html">SparseMatrix</a> object. We could then hand it off to the <a class="el" href="classSparseMIC.html">SparseMIC</a> class to form a sparse incomplete Cholesky decomposition. To form this decomposition is expensive, but we have to do it only once in the first time step, and can then use it as a cheap preconditioner in the future. We could do better even by using the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class that produces not only an incomplete, but a complete decomposition of the matrix, which should yield an even better preconditioner.</p>
<p>Finally, why use the approximation \(B^T (\textrm{diag}(M^u(S)))^{-1} B\) to precondition \(B^T M^u(S)^{-1} B\)? The latter matrix, after all, is the mixed form of the Laplace operator on the pressure space, for which we use linear elements. We could therefore build a separate matrix \(A^p\) on the side that directly corresponds to the non-mixed formulation of the Laplacian, for example using the bilinear form \((\mathbf{K}\lambda(S^n) \nabla \varphi_i,\nabla\varphi_j)\). We could then form an incomplete or complete decomposition of this non-mixed matrix and use it as a preconditioner of the mixed form.</p>
<p>Using such techniques, it can reasonably be expected that the solution process will be faster by at least an order of magnitude.</p>
<p><a class="anchor" id="Timestepping"></a></p><h4>Time stepping</h4>
<p>In the introduction we have identified the time step restriction </p><p class="formulaDsp">
\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|} \]
</p>
<p> that has to hold globally, i.e. for all \(\mathbf x\). After discretization, we satisfy it by choosing </p><p class="formulaDsp">
\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p>This restriction on the time step is somewhat annoying: the finer we make the mesh the smaller the time step; in other words, we get punished twice: each time step is more expensive to solve and we have to do more time steps.</p>
<p>This is particularly annoying since the majority of the additional work is spent solving the implicit part of the equations, i.e. the pressure-velocity system, whereas it is the hyperbolic transport equation for the saturation that imposes the time step restriction.</p>
<p>To avoid this bottleneck, people have invented a number of approaches. For example, they may only re-compute the pressure-velocity field every few time steps (or, if you want, use different time step sizes for the pressure/velocity and saturation equations). This keeps the time step restriction on the cheap explicit part while it makes the solution of the implicit part less frequent. Experiments in this direction are certainly worthwhile; one starting point for such an approach is the paper by Zhangxin Chen, Guanren Huan and Baoyan Li: <em>An improved IMPES method for two-phase flow in porous media</em>, Transport in Porous Media, 54 (2004), pp. 361&mdash;376. There are certainly many other papers on this topic as well, but this one happened to land on our desk a while back.</p>
<p><a class="anchor" id="Adaptivity"></a></p><h4>Adaptivity</h4>
<p>Adaptivity would also clearly help. Looking at the movies, one clearly sees that most of the action is confined to a relatively small part of the domain (this particularly obvious for the saturation, but also holds for the velocities and pressures). Adaptivity can therefore be expected to keep the necessary number of degrees of freedom low, or alternatively increase the accuracy.</p>
<p>On the other hand, adaptivity for time dependent problems is not a trivial thing: we would have to change the mesh every few time steps, and we would have to transport our present solution to the next mesh every time we change it (something that the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class can help with). These are not insurmountable obstacles, but they do require some additional coding and more than we felt comfortable was worth packing into this tutorial program.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Yan Li, Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system();</div><div class="line">    <span class="keywordtype">void</span>   assemble_rhs_S();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   solve();</div><div class="line">    <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">    <span class="keywordtype">void</span>   output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time;</div><div class="line">    <span class="keywordtype">double</span>       viscosity;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).value(p, component);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).vector_value(p, values);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">          {</div><div class="line">            values[p].clear();</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">              <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                                (0.1 * 0.1)),</div><div class="line">                       0.01);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / permeability;</div><div class="line">          }</div><div class="line">      }</div><div class="line">    };</div><div class="line">  } <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>RandomMedium</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">          {</div><div class="line">            values[p].clear();</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> permeability = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">              permeability += std::exp(-(points[p] - centers[i]).norm_square() /</div><div class="line">                                       (0.05 * 0.05));</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / normalized_permeability;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; get_centers()</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">          (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">        std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            centers_list[i][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> centers_list;</div><div class="line">      }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt;</div><div class="line">      KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line">  } <span class="comment">// namespace RandomMedium</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(std::max&lt;unsigned int&gt;(src.size(), 200),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;          <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,</div><div class="line">                    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>&gt; &amp;Minv)</div><div class="line">      : system_matrix(&amp;A)</div><div class="line">      , m_inverse(&amp;Minv)</div><div class="line">      , tmp1(A.block(0, 0).m())</div><div class="line">      , tmp2(A.block(0, 0).m())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">      m_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">      system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt;           system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>&gt;&gt; m_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ApproximateSchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">      : system_matrix(&amp;A)</div><div class="line">      , tmp1(A.block(0, 0).m())</div><div class="line">      , tmp2(A.block(0, 0).m())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">      system_matrix-&gt;block(0, 0).precondition_Jacobi(tmp2, tmp1);</div><div class="line">      system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : degree(degree)</div><div class="line">    , fe(<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">         1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , n_refinement_steps(5)</div><div class="line">    , time(<span class="comment">/*start time*/</span> 0., <span class="comment">/*end time*/</span> 1.)</div><div class="line">    , viscosity(0.2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_component =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>(dof_handler);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                       n_p = dofs_per_component[dim],</div><div class="line">                       n_s = dofs_per_component[dim + 1];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(3, 3);</div><div class="line">    sparsity_pattern.block(0, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(0, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(0, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">    sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, sparsity_pattern);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    solution.reinit(3);</div><div class="line">    solution.block(0).reinit(n_u);</div><div class="line">    solution.block(1).reinit(n_p);</div><div class="line">    solution.block(2).reinit(n_s);</div><div class="line">    solution.collect_sizes();</div><div class="line"></div><div class="line">    old_solution.reinit(3);</div><div class="line">    old_solution.block(0).reinit(n_u);</div><div class="line">    old_solution.block(1).reinit(n_p);</div><div class="line">    old_solution.block(2).reinit(n_s);</div><div class="line">    old_solution.collect_sizes();</div><div class="line"></div><div class="line">    system_rhs.reinit(3);</div><div class="line">    system_rhs.block(0).reinit(n_u);</div><div class="line">    system_rhs.block(1).reinit(n_p);</div><div class="line">    system_rhs.block(2).reinit(n_s);</div><div class="line">    system_rhs.collect_sizes();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">    <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt;              old_solution_values(n_q_points,</div><div class="line">                                                                 Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;std::vector&lt;Tensor&lt;1, dim&gt;&gt;&gt; old_solution_grads(</div><div class="line">      n_q_points, std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt;(dim + 2));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line"></div><div class="line">        pressure_right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                            pressure_rhs_values);</div><div class="line">        k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim + 1);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u = fe_values[velocities].value(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_i_u = fe_values[velocities].divergence(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_p     = fe_values[pressure].value(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s     = fe_values[saturation].value(i, q);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j_u =</div><div class="line">                    fe_values[velocities].value(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_j_u =</div><div class="line">                    fe_values[velocities].divergence(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_p = fe_values[pressure].value(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = fe_values[saturation].value(j, q);</div><div class="line"></div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (phi_i_u * k_inverse_values[q] *</div><div class="line">                       mobility_inverse(old_s, viscosity) * phi_j_u -</div><div class="line">                     div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u +</div><div class="line">                     phi_i_s * phi_j_s) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (-phi_i_p * pressure_rhs_values[q]) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              fe_face_values.reinit(cell, face);</div><div class="line"></div><div class="line">              pressure_boundary_values.value_list(</div><div class="line">                fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                      fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                    local_rhs(i) +=</div><div class="line">                      -(phi_i_u * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                        boundary_values[q] * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              local_matrix(i, j));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor(fe,</div><div class="line">                                              face_quadrature_formula,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values(n_q_points,</div><div class="line">                                                    Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face(n_face_q_points,</div><div class="line">                                                         Vector&lt;double&gt;(dim +</div><div class="line">                                                                        2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face_neighbor(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values(n_q_points,</div><div class="line">                                                        Vector&lt;double&gt;(dim +</div><div class="line">                                                                       2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values_face(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 2));</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  neighbor_saturation(n_face_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        local_rhs = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, present_solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_solution_values[q](dim + 1);</div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                present_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = fe_values[saturation].value(i, q);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">                fe_values[saturation].gradient(i, q);</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (time.get_next_step_size() * fractional_flow(old_s, viscosity) *</div><div class="line">                   present_u * grad_phi_i_s +</div><div class="line">                 old_s * phi_i_s) *</div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          {</div><div class="line">            fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution,</div><div class="line">                                               old_solution_values_face);</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution,</div><div class="line">                                               present_solution_values_face);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">              saturation_boundary_values.value_list(</div><div class="line">                fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>         neighbor = cell-&gt;neighbor(face_no);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face =</div><div class="line">                  cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">                fe_face_values_neighbor.reinit(neighbor, neighbor_face);</div><div class="line"></div><div class="line">                fe_face_values_neighbor.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">                  old_solution, old_solution_values_face_neighbor);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                  neighbor_saturation[q] =</div><div class="line">                    old_solution_values_face_neighbor[q](dim + 1);</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                  present_u_face[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values_face[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">                  present_u_face * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  local_rhs(i) -=</div><div class="line">                    time.get_next_step_size() * normal_flux *</div><div class="line">                    fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                                       old_solution_values_face[q](dim + 1) :</div><div class="line">                                       neighbor_saturation[q]),</div><div class="line">                                    viscosity) *</div><div class="line">                    fe_face_values[saturation].value(i, q) *</div><div class="line">                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;&gt; m_inverse(</div><div class="line">      system_matrix.block(0, 0));</div><div class="line">    Vector&lt;double&gt; tmp(solution.block(0).size());</div><div class="line">    Vector&lt;double&gt; schur_rhs(solution.block(1).size());</div><div class="line">    Vector&lt;double&gt; tmp2(solution.block(2).size());</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      m_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"></div><div class="line">      SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(system_matrix, m_inverse);</div><div class="line"></div><div class="line">      ApproximateSchurComplement approximate_schur_complement(system_matrix);</div><div class="line"></div><div class="line">      InverseMatrix&lt;ApproximateSchurComplement&gt; preconditioner(</div><div class="line">        approximate_schur_complement);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 * schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, preconditioner);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      m_inverse.vmult(solution.block(0), tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">    time.set_desired_next_step_size(std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">                                    get_maximal_velocity());</div><div class="line"></div><div class="line">    assemble_rhs_S();</div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_matrix.block(2, 2).m(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.block(2).l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">      cg.solve(system_matrix.block(2, 2),</div><div class="line">               solution.block(2),</div><div class="line">               system_rhs.block(2),</div><div class="line">               <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">      project_back_saturation();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    old_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (time.get_step_number() % 5 != 0)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(degree + 1);</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time.get_step_number(), 4) +</div><div class="line">                         <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; solution.block(2).size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">        solution.block(2)(i) = 0;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">        solution.block(2)(i) = 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        quadrature_formula(degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; solution_values(n_q_points,</div><div class="line">                                                Vector&lt;double&gt;(dim + 2));</div><div class="line">    <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">              velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">            max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                           constraints,</div><div class="line">                           <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree + 2),</div><div class="line">                           InitialValues&lt;dim&gt;(),</div><div class="line">                           old_solution);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_step_number() + 1 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        time.advance_time();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time.get_current_time()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time.get_previous_step_size() &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step21</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_20.html">step-20</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetwophaseflowproblem">The two phase flow problem</a><a href="#Thetwophaseflowproblem">The two phase flow problem</a>
        <li><a href="#Timediscretization">Time discretization</a><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spacediscretization">Space discretization</a><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Linearsolvers">Linear solvers</a><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Choosingatimestep">Choosing a time step</a><a href="#Choosingatimestep">Choosing a time step</a>
        <li><a href="#Thetestcase">The test case</a><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeTwoPhaseFlowProblemcodeclass">The <code>TwoPhaseFlowProblem</code> class</a><a href="#ThecodeTwoPhaseFlowProblemcodeclass">The <code>TwoPhaseFlowProblem</code> class</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
      <ul>
        <li><a href="#Pressurerighthandside">Pressure right hand side</a><a href="#Pressurerighthandside">Pressure right hand side</a>
        <li><a href="#Pressureboundaryvalues">Pressure boundary values</a><a href="#Pressureboundaryvalues">Pressure boundary values</a>
        <li><a href="#Saturationboundaryvalues">Saturation boundary values</a><a href="#Saturationboundaryvalues">Saturation boundary values</a>
        <li><a href="#Initialdata">Initial data</a><a href="#Initialdata">Initial data</a>
      </ul>
        <li><a href="#Theinversepermeabilitytensor">The inverse permeability tensor</a><a href="#Theinversepermeabilitytensor">The inverse permeability tensor</a>
      <ul>
        <li><a href="#Singlecurvingcrackpermeability">Single curving crack permeability</a><a href="#Singlecurvingcrackpermeability">Single curving crack permeability</a>
        <li><a href="#Randommediumpermeability">Random medium permeability</a><a href="#Randommediumpermeability">Random medium permeability</a>
      </ul>
        <li><a href="#Theinversemobilityandsaturationfunctions">The inverse mobility and saturation functions</a><a href="#Theinversemobilityandsaturationfunctions">The inverse mobility and saturation functions</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
        <li><a href="#codeTwoPhaseFlowProblemcodeclassimplementation"><code>TwoPhaseFlowProblem</code> class implementation</a><a href="#codeTwoPhaseFlowProblemcodeclassimplementation"><code>TwoPhaseFlowProblem</code> class implementation</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemTwoPhaseFlowProblem">TwoPhaseFlowProblem::TwoPhaseFlowProblem</a><a href="#TwoPhaseFlowProblemTwoPhaseFlowProblem">TwoPhaseFlowProblem::TwoPhaseFlowProblem</a>
        <li><a href="#TwoPhaseFlowProblemmake_grid_and_dofs">TwoPhaseFlowProblem::make_grid_and_dofs</a><a href="#TwoPhaseFlowProblemmake_grid_and_dofs">TwoPhaseFlowProblem::make_grid_and_dofs</a>
        <li><a href="#TwoPhaseFlowProblemassemble_system">TwoPhaseFlowProblem::assemble_system</a><a href="#TwoPhaseFlowProblemassemble_system">TwoPhaseFlowProblem::assemble_system</a>
        <li><a href="#TwoPhaseFlowProblemassemble_rhs_S">TwoPhaseFlowProblem::assemble_rhs_S</a><a href="#TwoPhaseFlowProblemassemble_rhs_S">TwoPhaseFlowProblem::assemble_rhs_S</a>
        <li><a href="#TwoPhaseFlowProblemsolve">TwoPhaseFlowProblem::solve</a><a href="#TwoPhaseFlowProblemsolve">TwoPhaseFlowProblem::solve</a>
        <li><a href="#TwoPhaseFlowProblemoutput_results">TwoPhaseFlowProblem::output_results</a><a href="#TwoPhaseFlowProblemoutput_results">TwoPhaseFlowProblem::output_results</a>
        <li><a href="#TwoPhaseFlowProblemproject_back_saturation">TwoPhaseFlowProblem::project_back_saturation</a><a href="#TwoPhaseFlowProblemproject_back_saturation">TwoPhaseFlowProblem::project_back_saturation</a>
        <li><a href="#TwoPhaseFlowProblemget_maximal_velocity">TwoPhaseFlowProblem::get_maximal_velocity</a><a href="#TwoPhaseFlowProblemget_maximal_velocity">TwoPhaseFlowProblem::get_maximal_velocity</a>
        <li><a href="#TwoPhaseFlowProblemrun">TwoPhaseFlowProblem::run</a><a href="#TwoPhaseFlowProblemrun">TwoPhaseFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Solvers">Solvers</a><a href="#Solvers">Solvers</a>
        <li><a href="#Timestepping">Time stepping</a><a href="#Timestepping">Time stepping</a>
        <li><a href="#Adaptivity">Adaptivity</a><a href="#Adaptivity">Adaptivity</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Introduction"></a><a class="anchor" id="Intro"></a> </p><h1>Introduction</h1>
<p>This program grew out of a student project by Yan Li at Texas A&amp;MUniversity. Most of the work for this program is by her. In this project, we propose a numerical simulation for two phaseflow problems in porous media. This problem includes oneelliptic equation and one nonlinear, time dependent transportequation. This is therefore also the first time-dependent tutorialprogram (besides the somewhat strange time-dependence of <a class="el" href="step_18.html">step_18 </a>step-18"  "). The equations covered here are an extension of the material already covered in <a class="el" href="step_20.html">step-20</a> . In particular, they fall into the class ofvector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Thetwophaseflowproblem"></a></p><h3>The two phase flow problem</h3>
<p>Modeling of two phase flow in porous media is important for bothenvironmental remediation and the management of petroleum and groundwaterreservoirs. Practical situations involving two phase flow include thedispersal of a nonaqueous phase liquid in an aquifer, or the jointmovement of a mixture of fluids such as oil and water in areservoir. Simulation models, if they are to provide realisticpredictions, must accurately account for these effects. To derive the governing equations, consider two phase flow in areservoir \(\Omega\) under the assumption that the movement of fluids isdominated by viscous effects; i.e. we neglect the effects of gravity,compressibility, and capillary pressure. Porosity will be consideredto be constant. We will denote variables referring to either of the twophases using subscripts \(w\) and \(o\) , short for water and oil. Thederivation of the equations holds for other pairs of fluids as well,however. The velocity with which molecules of each of the two phases move isdetermined by Darcy's law that states that the velocity isproportional to the pressure gradient: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}_{j} = -\frac{k_{rj}(S)}{\mu_{j}} \mathbf{K} \cdot \nabla p \end{eqnarray*}
</p>
<p> where \(\mathbf{u}_{j}\) is the velocity of phase \(j=o,w\) , \(K\) is thepermeability tensor, \(k_{rj}\) is the relative permeability of phase \(j\) , \(p\) is thepressure and \(\mu_{j}\) is the viscosity of phase \(j\) . Finally, \(S\) isthe saturation (volume fraction), i.e. a function with values between0 and 1 indicating the composition of the mixture of fluids. Ingeneral, the coefficients \(K, k_{rj}, \mu\) may be spatially dependentvariables, and we will always treat them as non-constant functions inthe following. We combine Darcy's law with the statement of conservation of mass foreach phase, </p><p class="formulaDsp">
\[ \textrm{div}\ \mathbf{u}_{j} = q_j, \]
</p>
<p> a source term for each phase. By summing over the two phases,we can express the governing equations in terms of theso-called pressure equation: </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p)= q. \end{eqnarray*}
</p>
<p> Here, \(q\) is the sum source term, and </p><p class="formulaDsp">
\[ \lambda(S) = \frac{k_{rw}(S)}{\mu_{w}}+\frac{k_{ro}(S)}{\mu_{o}} \]
</p>
<p> the total mobility. So far, this looks like an ordinary stationary, Poisson-like equation that wecan solve right away with the techniques of the first few tutorial programs(take a look at <a class="el" href="step_6.html">step-6</a> , for example, for something verysimilar). However, we have not said anything yet about the saturation, whichof course is going to change as the fluids move around. The second part of the equations is the description of thedynamics of the saturation, i.e., how the relative concentration of thetwo fluids changes with time. The saturation equation for the displacingfluid (water) is given by the following conservation law: </p><p class="formulaDsp">
\begin{eqnarray*} S_{t} + \nabla \cdot (F(S) \mathbf{u}) = q_{w}, \end{eqnarray*}
</p>
<p> which can be rewritten by using the product rule of the divergence operatorin the previous equation: </p><p class="formulaDsp">
\begin{eqnarray*} S_{t} + F(S) \left[\nabla \cdot \mathbf{u}\right] + \mathbf{u} \cdot \left[ \nabla F(S)\right] = S_{t} + F(S) q + \mathbf{u} \cdot \nabla F(S) = q_{w}. \end{eqnarray*}
</p>
<p> Here, \(q=\nabla\cdot \mathbf{u}\) is the total influx introducedabove, and \(q_{w}\) is the flow rate of the displacing fluid (water).These two are related to the fractional flow \(F(S)\) in the following way: </p><p class="formulaDsp">
\[ q_{w} = F(S) q, \]
</p>
<p> the fractional flow is often parameterized via the (heuristic) expression </p><p class="formulaDsp">
\[ F(S) = \frac{k_{rw}(S)/\mu_{w}}{k_{rw}(S)/\mu_{w} + k_{ro}(S)/\mu_{o}}. \]
</p>
<p> it all together yields the saturation equation in the following,advected form: </p><p class="formulaDsp">
\begin{eqnarray*} S_{t} + \mathbf{u} \cdot \nabla F(S) = 0, \end{eqnarray*}
</p>
<p> where \(\mathbf u\) is the total velocity </p><p class="formulaDsp">
\[ \mathbf{u} = \mathbf{u}_{o} + \mathbf{u}_{w} = -\lambda(S) \mathbf{K}\cdot\nabla p. \]
</p>
<p> that the advection equation contains the term \(\mathbf{u} \cdot \nabla F(S)\) rather than \(\mathbf{u} \cdot \nabla S\) to indicate that the saturationis not simply transported along; rather, since the two phases move withdifferent velocities, the saturation can actually change even in the advectedcoordinate system. To see this, rewrite \(\mathbf{u} \cdot \nabla F(S) = \mathbf{u} F&#39;(S) \cdot \nabla S\) to observe that the <em>actual</em>velocity with which the phase with saturation \(S\) is transported is \(\mathbf u F&#39;(S)\) whereas the other phase is transported at velocity \(\mathbf u (1-F&#39;(S))\) . \(F(S)\) is consequently often referred to as the<em>fractional flow</em>. In summary, what we get are the following two equations: </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p) &amp;=&amp; q \qquad \textrm{in}\ \Omega\times[0,T], \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times[0,T]. \end{eqnarray*}
</p>
<p> Here, \(p=p(\mathbf x, t), S=S(\mathbf x, t)\) are now time dependentfunctions: while at every time instant the flow field is inequilibrium with the pressure (i.e. we neglect dynamicaccelerations), the saturation is transported along with the flow andtherefore changes over time, in turn affected the flow field againthrough the dependence of the first equation on \(S\) . This set of equations has a peculiar character: one of the twoequations has a time derivative, the other one doesn't. Thiscorresponds to the character that the pressure and velocities arecoupled through an instantaneous constraint, whereas the saturationevolves over finite time scales. Such systems of equations are called Differential Algebraic Equations(DAEs), since one of the equations is a differential equation, theother is not (at least not with respect to the time variable) and istherefore an "algebraic" equation. (The notation comes from the fieldof ordinary differential equations, where everything that does nothave derivatives with respect to the time variable is necessarily analgebraic equation.) This class of equations contains prettywell-known cases: for example, the time dependent Stokes andNavier-Stokes equations (where the algebraic constraint is that thedivergence of the flow field, \(\textrm{div}\ \mathbf u\) , must be zero)as well as the time dependent Maxwell equations (here, the algebraicconstraint is that the divergence of the electric displacement fieldequals the charge density, \(\textrm{div}\ \mathbf D = \rho\) and that thedivergence of the magnetic flux density is zero: \(\textrm{div}\ \mathbf B = 0\) ); even the quasistatic model of <a class="el" href="step_18.html">step-18</a> falls into thiscategory. We will see that the different character of the two equationswill inform our discretization strategy for the two equations.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>In the reservoir simulation community, it is common to solve the equationsderived above by going back to the first order, mixed formulation. To thisend, we re-introduce the total velocity \(\mathbf u\) and write the equations inthe following form: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}+\mathbf{K}\lambda(S) \nabla p&amp;=&amp;0 \\ \nabla \cdot\mathbf{u} &amp;=&amp; q \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> This formulation has the additional benefit that we do not have to express thetotal velocity \(\mathbf u\) appearing in the transport equation as a functionof the pressure, but can rather take the primary variable for it. Given thesaddle point structure of the first two equations and their similarity to themixed Laplace formulation we have introduced in <a class="el" href="step_20.html">step-20</a> , itwill come as no surprise that we will use a mixed discretization again. But let's postpone this for a moment. The first business we have with theseequations is to think about the time discretization. In reservoir simulation,there is a rather standard algorithm that we will use here. It first solvesthe pressure using an implicit equation, then the saturation using an explicittime stepping scheme. The algorithm is called IMPES for IMplicit PressureExplicit Saturation and was first proposed a long time ago: by Sheldon etal. in 1959 and Stone and Gardner in 1961 (J. W. Sheldon, B. Zondek andW. T. Cardwell: <em>One-dimensional, incompressible, non-capillary, two-phase fluid flow in a porous medium</em>, Trans. SPE AIME, 216 (1959), pp. 290-296; H.L. Stone and A. O. Gardner Jr: <em>Analysis of gas-cap or dissolved-gas reservoirs</em>, Trans. SPE AIME, 222 (1961), pp. 92-104).In a slightly modified form, this algorithm can bewritten as follows: for each time step, solve </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}^{n+1}+\mathbf{K}\lambda(S^n) \nabla p^{n+1}&amp;=&amp;0 \\ \nabla \cdot\mathbf{u}^{n+1} &amp;=&amp; q^{n+1} \\ \frac {S^{n+1}-S^n}{\triangle t} + \mathbf{u}^{n+1} \cdot \nabla F(S^n) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> where \(\triangle t\) is the length of a time step. Note how we solve theimplicit pressure-velocity system that only depends on the previously computedsaturation \(S^n\) , and then do an explicit time step for \(S^{n+1}\) that onlydepends on the previously known \(S^n\) and the just computed \(\mathbf{u}^{n+1}\) . This way, we never have to iterate for the nonlinearitiesof the system as we would have if we used a fully implicit method. (Ina more modern perspective, this should be seen as an "operatorsplitting" method. <a class="el" href="step_58.html">step-58</a> has a long description of the idea behind this.) We can then state the problem in weak form as follows, by multiplying eachequation with test functions \(\mathbf v\) , \(\phi\) , and \(\sigma\) and integratingterms by parts: </p><p class="formulaDsp">
\begin{eqnarray*} \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{u}^{n+1},\mathbf v\right)_\Omega - (p^{n+1}, \nabla\cdot\mathbf v)_\Omega &amp;=&amp; - (p^{n+1}, \mathbf v)_{\partial\Omega} \\ (\nabla \cdot\mathbf{u}^{n+1}, \phi)_\Omega &amp;=&amp; (q^{n+1},\phi)_\Omega \end{eqnarray*}
</p>
<p> Note that in the first term, we have to prescribe the pressure \(p^{n+1}\) onthe boundary \(\partial\Omega\) as boundary values for our problem. \(\mathbf n\) denotes the unit outward normal vector to \(\partial K\) , as usual. For the saturation equation, we obtain after integrating by parts </p><p class="formulaDsp">
\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n), \nabla \cdot (\mathbf{u}^{n+1} \sigma)\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}, \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega. \end{eqnarray*}
</p>
<p> Using the fact that \(\nabla \cdot \mathbf{u}^{n+1}=q^{n+1}\) , we can rewrite thecell term to get an equation as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n) \mathbf{u}^{n+1}, \nabla \sigma\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega + \triangle t \sum_K \left(F(S^n) q^{n+1}, \sigma\right)_K. \end{eqnarray*}
</p>
<p> We introduce an object of type <a class="el" href="classDiscreteTime.html">DiscreteTime</a> in order to keep track of thecurrent value of time and time step in the code. This class encapsulates manycomplexities regarding adjusting time step size and stopping at a specifiedfinal time.</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>In each time step, we then apply the mixed finite method of <a class="el" href="step_20.html">step_20 </a>step-20"  " to the velocity and pressure. To be well-posed, we chooseRaviart-Thomas spaces \(RT_{k}\) for \(\mathbf{u}\) and discontinuous elements ofclass \(DGQ_{k}\) for \(p\) . For the saturation, we will also choose \(DGQ_{k}\) spaces. Since we have discontinuous spaces, we have to think about how to evaluateterms on the interfaces between cells, since discontinuous functions are notreally defined there. In particular, we have to give a meaning to the lastterm on the left hand side of the saturation equation. To this end, let usdefine that we want to evaluate it in the following sense: </p><p class="formulaDsp">
\begin{eqnarray*} &amp;&amp;\left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \\ &amp;&amp;\qquad = \left(F(S^n_+) (\mathbf n \cdot \mathbf{u}^{n+1}_+), \sigma\right)_{\partial K_+} + \left(F(S^n_-) (\mathbf n \cdot \mathbf{u}^{n+1}_-), \sigma\right)_{\partial K_-}, \end{eqnarray*}
</p>
<p> where \(\partial K_{-} \dealcoloneq \{x\in \partial K, \mathbf{u}(x) \cdot \mathbf{n}&lt;0\}\) denotes the inflow boundary and \(\partial K_{+} \dealcoloneq \{\partial K \setminus \partial K_{-}\}\) is the outflow part of the boundary.The quantities \(S_+,\mathbf{u}_+\) then correspond to the values of thesevariables on the present cell, whereas \(S_-,\mathbf{u}_-\) (needed on theinflow part of the boundary of \(K\) ) are quantities taken from the neighboringcell. Some more context on discontinuous element techniques and evaluation offluxes can also be found in <a class="el" href="step_12.html">step-12</a> and <a class="el" href="step_12.html">step-12</a> b.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<p>The linear solvers used in this program are a straightforward extension of theones used in <a class="el" href="step_20.html">step-20</a> (but without <a class="el" href="classLinearOperator.html">LinearOperator</a>). Essentially, we simply haveto extend everything fromtwo to three solution components. If we use the discrete spacesmentioned above and put shape functions into the bilinear forms, wearrive at the following linear system to be solved for time step \(n+1\) : </p><p class="formulaDsp">
\[ \left( \begin{array}{ccc} M^u(S^{n}) &amp; B^{T}&amp; 0\\ B &amp; 0 &amp; 0\\ \triangle t\; H &amp; 0&amp; M^S \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{n+1} \\ P^{n+1} \\ S^{n+1} \end{array} \right) = \left( \begin{array}{c} 0 \\ F_2 \\ F_3 \end{array} \right) \]
</p>
<p> the individual matrices and vectors are defined as follows usingshape functions \(\mathbf v_i\) (of type Raviart Thomas \(RT_k\) ) forvelocities and \(\phi_i\) (of type \(DGQ_k\) ) for both pressures and saturations: </p><p class="formulaDsp">
\begin{eqnarray*} M^u(S^n)_{ij} &amp;=&amp; \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{v}_i,\mathbf v_j\right)_\Omega, \\ B_{ij} &amp;=&amp; -(\nabla \cdot \mathbf v_j, \phi_i)_\Omega, \\ H_{ij} &amp;=&amp; - \sum_K \left\{ \left(F(S^n) \mathbf v_i, \nabla \phi_j)\right)_K - \left(F(S^n_+) (\mathbf n \cdot (\mathbf v_i)_+), \phi_j\right)_{\partial K_+} - \left(F(S^n_-) (\mathbf n \cdot (\mathbf v_i)_-), \phi_j\right)_{\partial K_-}, \right\} \\ M^S_{ij} &amp;=&amp; (\phi_i, \phi_j)_\Omega, \\ (F_2)_i &amp;=&amp; -(q^{n+1},\phi_i)_\Omega, \\ (F_3)_i &amp;=&amp; (S^n,\phi_i)_\Omega +\triangle t \sum_K \left(F(S^n) q^{n+1}, \phi_i\right)_K. \end{eqnarray*}
</p>
<dl class="section note"><dt>Note</dt><dd>Due to historical accidents, the role of matrices \(B\) and \(B^T\) has been reverted in this program compared to <a class="el" href="step_20.html">step-20</a> . In other words,here \(B\) refers to the divergence and \(B^T\) to the gradient operatorswhen it was the other way around in <a class="el" href="step_20.html">step-20</a> . The system above presents a complication: Since the matrix \(H_{ij}\) depends on \(\mathbf u^{n+1}\) implicitly (the velocities are needed todetermine which parts of the boundaries \(\partial K\) of cells areinflux or outflux parts), we can only assemble this matrix after wehave solved for the velocities. The solution scheme then involves the following steps: <ol>
<li>
Solve for the pressure \(p^{n+1}\) using the Schur complement technique introduced in <a class="el" href="step_20.html">step-20</a> . </li>
<li>
Solve for the velocity \(\mathbf u^{n+1}\) as also discussed in <a class="el" href="step_20.html">step-20</a> . </li>
<li>
Compute the term \(F_3-\triangle t\; H \mathbf u^{n+1}\) , using the just computed velocities. </li>
<li>
Solve for the saturation \(S^{n+1}\) . </li>
</ol>
In this scheme, we never actually build the matrix \(H\) , but rathergenerate the right hand side of the third equation once we are readyto do so. In the program, we use a variable <code>solution</code> to store thesolution of the present time step. At the end of each step, we copyits content, i.e. all three of its block components, into the variable <code>old_solution</code> for use in the next time step.</dd></dl>
<p><a class="anchor" id="Choosingatimestep"></a></p><h3>Choosing a time step</h3>
<p>A general rule of thumb in hyperbolic transport equations like the equation wehave to solve for the saturation equation is that if we use an explicit timestepping scheme, then we should use a time step such that the distance that aparticle can travel within one time step is no larger than the diameter of asingle cell. In other words, here, we should choose </p><p class="formulaDsp">
\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p>, we are in a position where we can do that: we only need thetime step when we want to assemble the right hand side of the saturationequation, which is after we have already solved for \(\mathbf{u}^{n+1}\) . All wetherefore have to do after solving for the velocity is to loop over allquadrature points in the domain and determine the maximal magnitude of thevelocity. We can then set the time step for the saturation equation to </p><p class="formulaDsp">
\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p> Why is it important to do this? If we don't, then we will end up with lots ofplaces where our saturation is larger than one or less than zero, as caneasily be verified. (Remember that the saturation corresponds to somethinglike the water fraction in the fluid mixture, and therefore must physically bebetween 0 and 1.) On the other hand, if we choose our time step according tothe criterion listed above, this only happens very very infrequently &mdash;in fact only once for the entire run of the program. However, to be on thesafe side, however, we run a function <code>project_back_saturation</code> atthe end of each time step, that simply projects the saturation back onto theinterval \([0,1]\) , should it have gotten out of the physical range. This isuseful since the functions \(\lambda(S)\) and \(F(S)\) do not represent anythingphysical outside this range, and we should not expect the program to doanything useful once we have negative saturations or ones larger than one. Note that we will have similar restrictions on the time step also in <a class="el" href="step_23.html">step-23</a> and <a class="el" href="step_24.html">step-24</a> where we solve the time dependentwave equation, another hyperbolic problem. We will also come back to the issueof time step choice below in the section on <a href="#extensions">possible extensions to this program</a>.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>For simplicity, this program assumes that there is no source, \(q=0\) , and thatthe heterogeneous porous medium is isotropic \(\mathbf{K}(\mathbf{x}) = k(\mathbf{x}) \mathbf{I}\) . The first one of these is a realistic assumption inoil reservoirs: apart from injection and production wells, there are usuallyno mechanisms for fluids to appear or disappear out of the blue. The secondone is harder to justify: on a microscopic level, most rocks are isotropic,because they consist of a network of interconnected pores. However, thismicroscopic scale is out of the range of today's computer simulations, and wehave to be content with simulating things on the scale of meters. On thatscale, however, fluid transport typically happens through a network of cracksin the rock, rather than through pores. However, cracks often result fromexternal stress fields in the rock layer (for example from tectonic faulting)and the cracks are therefore roughly aligned. This leads to a situation wherethe permeability is often orders of magnitude larger in the direction parallelto the cracks than perpendicular to the cracks. A problem typically faces inreservoir simulation, however, is that the modeler doesn't know the directionof cracks because oil reservoirs are not accessible to easy inspection. Theonly solution in that case is to assume an effective, isotropic permeability. Whatever the matter, both of these restrictions, no sources and isotropy,would be easy to lift with a few lines of code in the program. Next, for simplicity, our numerical simulation will be done on theunit cell \(\Omega = [0,1]\times [0,1]\) for \(t\in [0,T]\) . Our initialconditions are \(S(\mathbf{x},0)=0\) ; in the oil reservoir picture, where \(S\) would indicate the water saturation, this means that the reservoir containspure oil at the beginning. Note that we do not need any initialconditions for pressure or velocity, since the equations do not contain timederivatives of these variables. Finally, we impose the following pressureboundary conditions: </p><p class="formulaDsp">
\[ p(\mathbf{x},t)=1-x_1 \qquad \textrm{on}\ \partial\Omega. \]
</p>
<p> the pressure and velocity solve a mixed form Poisson equation, theimposed pressure leads to a resulting flow field for the velocity. On theother hand, this flow field determines whether a piece of the boundary is ofinflow or outflow type, which is of relevance because we have to imposeboundary conditions for the saturation on the inflow part of the boundary, </p><p class="formulaDsp">
\[ \Gamma_{in}(t) = \{\mathbf{x}\in\partial\Omega: \mathbf{n} \cdot \mathbf{u}(\mathbf{x},t) &lt; 0\}. \]
</p>
<p> this inflow boundary, we impose the following saturation values: </p><p class="formulaDsp">
\begin{eqnarray} S(\mathbf{x},t) = 1 &amp; \textrm{on}\ \Gamma_{in}\cap\{x_1=0\}, \\ S(\mathbf{x},t) = 0 &amp; \textrm{on}\ \Gamma_{in}\backslash \{x_1=0\}. \end{eqnarray}
</p>
<p> In other words, we have pure water entering the reservoir at the left, whereasthe other parts of the boundary are in contact with undisturbed parts of thereservoir and whenever influx occurs on these boundaries, pure oil will enter. In our simulations, we choose the total mobility as </p><p class="formulaDsp">
\[ \lambda (S) = \frac{1.0}{\mu} S^2 +(1-S)^2 \]
</p>
<p> we use \(\mu=0.2\) for the viscosity. In addition, the fractional flow ofwater is given by </p><p class="formulaDsp">
\[ F(S)=\frac{S^2}{S^2+\mu (1-S)^2} \]
</p>
 <dl class="section note"><dt>Note</dt><dd>Coming back to this testcase in <a class="el" href="step_43.html">step-43</a> several years later revealed anoddity in the setup of this testcase. To this end, consider that we canrewrite the advection equation for the saturation as \(S_{t} + (\mathbf{u} F&#39;(S)) \cdot \nabla S = 0\) . Now, at the initial time, we have \(S=0\) , and withthe given choice of function \(F(S)\) , we happen to have \(F&#39;(0)=0\) . In otherwords, at \(t=0\) , the equation reduces to \(S_t=0\) for all \(\mathbf x\) , so thesaturation is zero everywhere and it is going to stay zero everywhere! This isdespite the fact that \(\mathbf u\) is not necessarily zero: the combined fluidis moving, but we've chosen our partial flux \(F(S)\) in such a way thatinfinitesimal amounts of wetting fluid also only move at infinitesimal speeds(i.e., they stick to the medium more than the non-wetting phase in which theyare embedded). That said, how can we square this with the knowledge thatwetting fluid is invading from the left, leading to the flow patterns seen inthe <a href="#Results">results section</a>? That's where we get intomathematics: Equations like the transport equation we are considering herehave infinitely many solutions, but only one of them is physical: the one thatresults from the so-called viscosity limit, called the <a href="http://en.wikipedia.org/wiki/Viscosity_solution">viscosity solution</a>. The thing is that with discontinuous elements we arrive at thisviscosity limit because using a numerical flux introduces a finite amount ofartificial viscosity into the numerical scheme. On the other hand, in <a class="el" href="step_43.html">step-43</a> ,we use an artificial viscosity that is proportional to \(\|\mathbf u F&#39;(S)\|\) on every cell, which at the initial time is zero. Thus, the saturation there iszero and remains zero; the solution we then get is <em>one</em> solution of theadvection equation, but the method does not converge to the viscosity solutionwithout further changes. We will therefore use a different initial condition inthat program.</dd></dl>
<p>Finally, to come back to the description of the testcase, we will show resultsfor computations with the two permeabilityfunctions introduced at the end of the results section of <a class="el" href="step_20.html">step_20 </a>step-20"  ": </p><ul>
<li>
A function that models a single, winding crack that snakes through the domain. In analogy to <a class="el" href="step_20.html">step-20</a> , but taking care of the slightly different geometry we have here, we describe this by the following function: <p class="formulaDsp">
\[ k(\mathbf x) = \max \left\{ e^{-\left(\frac{x_2-\frac 12 - 0.1\sin(10x_1)}{0.1}\right)^2}, 0.01 \right\}. \]
</p>
 Taking the maximum is necessary to ensure that the ratio between maximal and minimal permeability remains bounded. If we don't do that, permeabilities will span many orders of magnitude. On the other hand, the ratio between maximal and minimal permeability is a factor in the condition number of the Schur complement matrix, and if too large leads to problems for which our linear solvers will no longer converge properly. </li>
<li>
A function that models a somewhat random medium. Here, we choose <p class="formulaDsp">
\begin{eqnarray*} k(\mathbf x) &amp;=&amp; \min \left\{ \max \left\{ \sum_{i=1}^N \sigma_i(\mathbf{x}), 0.01 \right\}, 4\right\}, \\ \sigma_i(\mathbf x) &amp;=&amp; e^{-\left(\frac{|\mathbf{x}-\mathbf{x}_i|}{0.05}\right)^2}, \end{eqnarray*}
</p>
 where the centers \(\mathbf{x}_i\) are \(N\) randomly chosen locations inside the domain. This function models a domain in which there are \(N\) centers of higher permeability (for example where rock has cracked) embedded in a matrix of more pristine, unperturbed background rock. Note that here we have cut off the permeability function both above and below to ensure a bounded condition number. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This program is an adaptation of <a class="el" href="step_20.html">step-20</a> and includes some technique of DG methods from <a class="el" href="step_12.html">step-12</a> . A good part of the program is therefore very similar to <a class="el" href="step_20.html">step-20</a> and we will not comment again on these parts. Only the new stuff will be discussed in more detail.</p>
<pre class="fragment">&lt;a name="Includefiles"&gt;&lt;/a&gt;  &lt;h3&gt;Include files&lt;/h3&gt;
</pre><p>All of these include files have been used before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>In this program, we use a tensor-valued coefficient. Since it may have a spatial dependence, we consider it a tensor-valued function. The following include file provides the <code><a class="el" href="classTensorFunction.html">TensorFunction</a></code> class that offers such functionality:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div></div><!-- fragment --><p>Additionally, we use the class <code><a class="el" href="classDiscreteTime.html">DiscreteTime</a></code> to perform operations related to time incrementation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeTwoPhaseFlowProblemcodeclass"></a> </p><h3>The <code>TwoPhaseFlowProblem</code> class</h3>
<p>This is the main class of the program. It is close to the one of <a class="el" href="step_20.html">step-20</a> , but with a few additional functions: </p><ul>
<li>
<code>assemble_rhs_S</code> assembles the right hand side of the saturation equation. As explained in the introduction, this can't be integrated into <code>assemble_rhs</code> since it depends on the velocity that is computed in the first part of the time step. </li>
<li>
<code>get_maximal_velocity</code> does as its name suggests. This function is used in the computation of the time step size. </li>
<li>
<code>project_back_saturation</code> resets all saturation degrees of freedom with values less than zero to zero, and all those with saturations greater than one to one. </li>
</ul>
<p>The rest of the class should be pretty much obvious. The <code>viscosity</code> variable stores the viscosity \(\mu\) that enters several of the formulas in the nonlinear equations. The variable <code>time</code> keeps track of the time information within the simulation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_rhs_S();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>   solve();</div><div class="line">  <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">  <span class="keywordtype">void</span>   output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time;</div><div class="line">  <span class="keywordtype">double</span>       viscosity;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<pre class="fragment">&lt;a name="Pressurerighthandside"&gt;&lt;/a&gt;  &lt;h4&gt;Pressure right hand side&lt;/h4&gt;
</pre><p>At present, the right hand side of the pressure equation is simply the zero function. However, the rest of the program is fully equipped to deal with anything else, if this is desired:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureRightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Pressureboundaryvalues"></a> </p><h4>Pressure boundary values</h4>
<p>The next are pressure boundary values. As mentioned in the introduction, we choose a linear pressure field:</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     PressureBoundaryValues()</div><div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <span class="keywordflow">return</span> 1</div><div class="line">  </div><div class="line">- p[0];</div><div class="line">     }</div><div class="line">   };</div></div><!-- fragment --><p><a class="anchor" id="Saturationboundaryvalues"></a> </p><h4>Saturation boundary values</h4>
<p>Then we also need boundary values on the inflow portions of the boundary. The question whether something is an inflow part is decided when assembling the right hand side, we only have to provide a functional description of the boundary values. This is as explained in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Initialdata"></a> </p><h4>Initial data</h4>
<p>Finally, we need initial data. In reality, we only need initial data for the saturation, but we are lazy, so we will later, before the first time step, simply interpolate the entire solution for the previous time step from a function that contains all vector components. We therefore simply create a function that returns zero in all components. We do that by simply forward every function to the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> class. Why not use that right away in the places of this program where we presently use the <code>InitialValues</code> class? Because this way it is simpler to later go back and choose a different function for initial values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).<a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(p, component);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).<a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(p, values);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Theinversepermeabilitytensor"></a> </p><h3>The inverse permeability tensor</h3>
<p>As announced in the introduction, we implement two different permeability tensor fields. Each of them we put into a namespace of its own, so that it will be easy later to replace use of one by the other in the code.</p>
<pre class="fragment">&lt;a name="Singlecurvingcrackpermeability"&gt;&lt;/a&gt;  &lt;h4&gt;Single curving crack permeability&lt;/h4&gt;
</pre><p>The first function for the permeability was the one that models a single curving crack. It was already used at the end of <a class="el" href="step_20.html">step-20</a> , and its functional form is given in the introduction of the present tutorial program. As in some previous programs, we have to declare a (seemingly unnecessary) default constructor of the KInverse class to avoid warnings from some compilers:</p>
<div class="fragment"><div class="line">   <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">   {</div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">     {</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">       KInverse()</div><div class="line">         : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">       {}</div><div class="line">  </div><div class="line">       <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">       value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">       </span>{</div><div class="line">         <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">           {</div><div class="line">             values[p].clear();</div><div class="line">  </div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">               <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1]</div><div class="line">  </div><div class="line">- 0.5</div><div class="line">  </div><div class="line">- 0.1 std::sin(10 points[p][0]));</div><div class="line">  </div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">               <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline distance_to_flowline) /</div><div class="line">                                 (0.1 0.1)),</div><div class="line">                        0.01);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">               values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / permeability;</div><div class="line">           }</div><div class="line">       }</div><div class="line">     };</div><div class="line">   } <span class="comment">// namespace SingleCurvingCrack</span></div></div><!-- fragment --><p><a class="anchor" id="Randommediumpermeability"></a> </p><h4>Random medium permeability</h4>
<p>This function does as announced in the introduction, i.e. it creates an overlay of exponentials at random places. There is one thing worth considering for this class. The issue centers around the problem that the class creates the centers of the exponentials using a random function. If we therefore created the centers each time we create an object of the present type, we would get a different list of centers each time. That's not what we expect from classes of this type: they should reliably represent the same function. The solution to this problem is to make the list of centers a static member variable of this class, i.e. there exists exactly one such variable for the entire program, rather than for each object of this type. That's exactly what we are going to do. The next problem, however, is that we need a way to initialize this variable. Since this variable is initialized at the beginning of the program, we can't use a regular member function for that since there may not be an object of this type around at the time. The C++ standard therefore says that only non-member and static member functions can be used to initialize a static variable. We use the latter possibility by defining a function <code>get_centers</code> that computes the list of center points when called. Note that this class works just fine in both 2d and 3d, with the only difference being that we use more points in 3d: by experimenting we find that we need more exponentials in 3d than in 2d (we have more ground to cover, after all, if we want to keep the distance between centers roughly equal), so we choose 40 in 2d and 100 in 3d. For any other dimension, the function does presently not know what to do so simply throws an exception indicating exactly this.</p>
<div class="fragment"><div class="line">   <span class="keyword">namespace </span>RandomMedium</div><div class="line">   {</div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">     {</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">       KInverse()</div><div class="line">         : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">       {}</div><div class="line">  </div><div class="line">       <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">       value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">       </span>{</div><div class="line">         <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">           {</div><div class="line">             values[p].clear();</div><div class="line">  </div><div class="line">             <span class="keywordtype">double</span> permeability = 0;</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">               permeability += std::exp(-(points[p]</div><div class="line">  </div><div class="line">- centers[i]).norm_square() /</div><div class="line">                                        (0.05 0.05));</div><div class="line">  </div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">               <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">               values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / normalized_permeability;</div><div class="line">           }</div><div class="line">       }</div><div class="line">  </div><div class="line">     <span class="keyword">private</span>:</div><div class="line">       <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line">  </div><div class="line">       <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; get_centers()</div><div class="line">       {</div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">           (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line">  </div><div class="line">         std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">             centers_list[i][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line">  </div><div class="line">         <span class="keywordflow">return</span> centers_list;</div><div class="line">       }</div><div class="line">     };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     std::vector&lt;Point&lt;dim&gt;&gt;</div><div class="line">       KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line">   } <span class="comment">// namespace RandomMedium</span></div></div><!-- fragment --><p><a class="anchor" id="Theinversemobilityandsaturationfunctions"></a> </p><h3>The inverse mobility and saturation functions</h3>
<p>There are two more pieces of data that we need to describe, namely the inverse mobility function and the saturation curve. Their form is also given in the introduction:</p>
<div class="fragment"><div class="line">   <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">   {</div><div class="line">     <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity S S + (1</div><div class="line">  </div><div class="line">- S) (1</div><div class="line">  </div><div class="line">- S));</div><div class="line">   }</div><div class="line">  </div><div class="line">   <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">   {</div><div class="line">     <span class="keywordflow">return</span> S S / (S S + viscosity (1</div><div class="line">  </div><div class="line">- S) (1</div><div class="line">  </div><div class="line">- S));</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>The linear solvers we use are also completely analogous to the ones used in <a class="el" href="step_20.html">step-20</a> . The following classes are therefore copied verbatim from there. Note that the classes here are not only copied from <a class="el" href="step_20.html">step-20</a> , but also duplicate classes in deal.II. In a future version of this example, they should be replaced by an efficient method, though. There is a single change: if the size of a linear system is small, i.e. when the mesh is very coarse, then it is sometimes not sufficient to set a maximum of <code>src.size()</code> CG iterations before the solver in the <code>vmult()</code> function converges. (This is, of course, a result of numerical round-off, since we know that on paper, the CG method converges in at most <code>src.size()</code> steps.) As a consequence, we set the maximum number of iterations equal to the maximum of the size of the linear system and 200.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(std::max&lt;unsigned int&gt;(src.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 200),</div><div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;          <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,</div><div class="line">                  <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>&gt; &amp;Minv)</div><div class="line">    : system_matrix(&amp;A)</div><div class="line">    , m_inverse(&amp;Minv)</div><div class="line">    , tmp1(A.block(0, 0).m())</div><div class="line">    , tmp2(A.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">    m_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt;           system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>&gt;&gt; m_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ApproximateSchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">    : system_matrix(&amp;A)</div><div class="line">    , tmp1(A.block(0, 0).m())</div><div class="line">    , tmp2(A.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">    system_matrix-&gt;block(0, 0).precondition_Jacobi(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="codeTwoPhaseFlowProblemcodeclassimplementation"></a> </p><h3><code>TwoPhaseFlowProblem</code> class implementation</h3>
<p>Here now the implementation of the main class. Much of it is actually copied from <a class="el" href="step_20.html">step-20</a> , so we won't comment on it in much detail. You should try to get familiar with that program first, then most of what is happening here should be mostly clear.</p>
<pre class="fragment">&lt;a name="TwoPhaseFlowProblemTwoPhaseFlowProblem"&gt;&lt;/a&gt;  &lt;h4&gt;TwoPhaseFlowProblem::TwoPhaseFlowProblem&lt;/h4&gt;
</pre><p>First for the constructor. We use \(RT_k \times DQ_k \times DQ_k\) spaces. For initializing the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object, we don't set the time step size in the constructor because we don't have its value yet. The time step size is initially set to zero, but it will be computed before it is needed to increment time, as described in a subsection of the introduction. The time object internally prevents itself from being incremented when \(dt = 0\) , forcing us to set a non-zero desired size for \(dt\) before advancing time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : degree(degree)</div><div class="line">  , fe(<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">       1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , n_refinement_steps(5)</div><div class="line">  , time( <span class="comment">/*start time*/</span> 0., <span class="comment">/*end time*/</span>  1.)</div><div class="line">  , viscosity(0.2)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemmake_grid_and_dofs"></a> </p><h4>TwoPhaseFlowProblem::make_grid_and_dofs</h4>
<p>This next function starts out with well-known functions calls that create and refine a mesh, and then associate degrees of freedom with it. It does all the same things as in <a class="el" href="step_20.html">step-20</a> , just now for three components instead of two.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_component =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>(dof_handler);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                     n_p = dofs_per_component[dim],</div><div class="line">                     n_s = dofs_per_component[dim + 1];</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(3, 3);</div><div class="line">  sparsity_pattern.block(0, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(0, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(0, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">  sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, sparsity_pattern);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">  solution.reinit(3);</div><div class="line">  solution.block(0).reinit(n_u);</div><div class="line">  solution.block(1).reinit(n_p);</div><div class="line">  solution.block(2).reinit(n_s);</div><div class="line">  solution.collect_sizes();</div><div class="line"></div><div class="line">  old_solution.reinit(3);</div><div class="line">  old_solution.block(0).reinit(n_u);</div><div class="line">  old_solution.block(1).reinit(n_p);</div><div class="line">  old_solution.block(2).reinit(n_s);</div><div class="line">  old_solution.collect_sizes();</div><div class="line"></div><div class="line">  system_rhs.reinit(3);</div><div class="line">  system_rhs.block(0).reinit(n_u);</div><div class="line">  system_rhs.block(1).reinit(n_p);</div><div class="line">  system_rhs.block(2).reinit(n_s);</div><div class="line">  system_rhs.collect_sizes();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemassemble_system"></a> </p><h4>TwoPhaseFlowProblem::assemble_system</h4>
<p>This is the function that assembles the linear system, or at least everything except the (1,3) block that depends on the still-unknown velocity computed during this time step (we deal with this in <code>assemble_rhs_S</code> ). Much of it is again as in <a class="el" href="step_20.html">step-20</a> , but we have to deal with some nonlinearity this time. However, the top of the function is pretty much as usual (note that we set matrix and right hand side to zero at the beginning &mdash; something we didn't have to do for stationary problems since there we use each matrix object only once and it is empty at the beginning anyway). Note that in its present form, the function uses the permeability implemented in the RandomMedium::KInverse class. Switching to the single curved crack permeability function is as simple as just changing the namespace name.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system()</div><div class="line">   {</div><div class="line">     system_matrix = 0;</div><div class="line">     system_rhs    = 0;</div><div class="line">  </div><div class="line">     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(degree + 2);</div><div class="line">     <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(degree + 2);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                             quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                      face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line">  </div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line">  </div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">     <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">     <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line">  </div><div class="line">     std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">     std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">     std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line">  </div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt;              old_solution_values(n_q_points,</div><div class="line">                                                                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">     std::vector&lt;std::vector&lt;Tensor&lt;1, dim&gt;&gt;&gt; old_solution_grads(</div><div class="line">       n_q_points, std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt;(dim + 2));</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">       {</div><div class="line">         fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">         local_matrix = 0;</div><div class="line">         local_rhs    = 0;</div></div><!-- fragment --><p>Here's the first significant difference: We have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> (previously already used in <a class="el" href="step_9.html">step-9</a> , <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_15.html">step-15</a> ), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div></div><!-- fragment --><p>Then we also have to get the values of the pressure right hand side and of the inverse permeability tensor at the quadrature points:</p>
<div class="fragment"><div class="line">pressure_right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    pressure_rhs_values);</div><div class="line">k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                     k_inverse_values);</div></div><!-- fragment --><p>With all this, we can now loop over all the quadrature points and shape functions on this cell and assemble those parts of the matrix and right hand side that we deal with in this function. The individual terms in the contributions should be self-explanatory given the explicit form of the bilinear form stated in the introduction:</p>
<div class="fragment"><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">             {</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim + 1);</div><div class="line">  </div><div class="line">               <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u = fe_values[velocities].value(i, q);</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_i_u = fe_values[velocities].divergence(i, q);</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_p     = fe_values[pressure].value(i, q);</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s     = fe_values[saturation].value(i, q);</div><div class="line">  </div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                 {</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j_u =</div><div class="line">                     fe_values[velocities].value(j, q);</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_j_u =</div><div class="line">                     fe_values[velocities].divergence(j, q);</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_p = fe_values[pressure].value(j, q);</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = fe_values[saturation].value(j, q);</div><div class="line">  </div><div class="line">                   local_matrix(i, j) +=</div><div class="line">                     (phi_i_u k_inverse_values[q]</div><div class="line">                        mobility_inverse(old_s, viscosity) phi_j_u</div><div class="line">  </div><div class="line">-</div><div class="line">                      div_phi_i_u phi_j_p</div><div class="line">  </div><div class="line">- phi_i_p div_phi_j_u +</div><div class="line">                      phi_i_s phi_j_s)</div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                 }</div><div class="line">  </div><div class="line">               local_rhs(i) +=</div><div class="line">                 (-phi_i_p pressure_rhs_values[q]) fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">             }</div></div><!-- fragment --><p>Next, we also have to deal with the pressure boundary values. This, again is as in <a class="el" href="step_20.html">step-20</a> :</p>
<div class="fragment"><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">           <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">             {</div><div class="line">               fe_face_values.reinit(cell, face);</div><div class="line">  </div><div class="line">               pressure_boundary_values.value_list(</div><div class="line">                 fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line">  </div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                   {</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                       fe_face_values[velocities].value(i, q);</div><div class="line">  </div><div class="line">                     local_rhs(i) +=</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-(phi_i_u fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q)</div><div class="line">                         boundary_values[q] fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                   }</div><div class="line">             }</div></div><!-- fragment --><p>The final step in the loop over all cells is to transfer local contributions into the global matrix and right hand side vector:</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            local_matrix(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>So much for assembly of matrix and right hand side. Note that we do not have to interpolate and apply boundary values since they have all been taken care of in the weak form already.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemassemble_rhs_S"></a> </p><h4>TwoPhaseFlowProblem::assemble_rhs_S</h4>
<p>As explained in the introduction, we can only evaluate the right hand side of the saturation equation once the velocity has been computed. We therefore have this separate function to this end.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S()</div><div class="line">   {</div><div class="line">     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(degree + 2);</div><div class="line">     <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;   face_quadrature_formula(degree + 2);</div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                             quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                      face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor(fe,</div><div class="line">                                               face_quadrature_formula,</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line">  </div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line">  </div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values(n_q_points,</div><div class="line">                                                     <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face(n_face_q_points,</div><div class="line">                                                          <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim +</div><div class="line">                                                                         2));</div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face_neighbor(</div><div class="line">       n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values(n_q_points,</div><div class="line">                                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim +</div><div class="line">                                                                        2));</div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values_face(</div><div class="line">       n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  </div><div class="line">     std::vector&lt;double&gt;                  neighbor_saturation(n_face_q_points);</div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">     SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">       {</div><div class="line">         local_rhs = 0;</div><div class="line">         fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  </div><div class="line">         fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line">         fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, present_solution_values);</div></div><!-- fragment --><p>First for the cell terms. These are, following the formulas in the introduction, \((S^n,\sigma)-(F(S^n) \mathbf{v}^{n+1},\nabla \sigma)\) , where \(\sigma\) is the saturation component of the test function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_solution_values[q](dim + 1);</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        present_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = fe_values[saturation].value(i, q);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">        fe_values[saturation].gradient(i, q);</div><div class="line"></div><div class="line">      local_rhs(i) +=</div><div class="line">        (time.get_next_step_size() fractional_flow(old_s, viscosity)</div><div class="line">           present_u grad_phi_i_s +</div><div class="line">         old_s phi_i_s)</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div></div><!-- fragment --><p>Secondly, we have to deal with the flux parts on the face boundaries. This was a bit more involved because we first have to determine which are the influx and outflux parts of the cell boundary. If we have an influx boundary, we need to evaluate the saturation on the other side of the face (or the boundary values, if we are at the boundary of the domain). All this is a bit tricky, but has been explained in some detail already in <a class="el" href="step_9.html">step-9</a> . Take a look there how this is supposed to work!</p>
<div class="fragment"><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">           {</div><div class="line">             fe_face_values.reinit(cell, face_no);</div><div class="line">  </div><div class="line">             fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution,</div><div class="line">                                                old_solution_values_face);</div><div class="line">             fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution,</div><div class="line">                                                present_solution_values_face);</div><div class="line">  </div><div class="line">             <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">               saturation_boundary_values.value_list(</div><div class="line">                 fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line">             <span class="keywordflow">else</span></div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <span class="keyword">auto</span>         neighbor = cell-&gt;neighbor(face_no);</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face =</div><div class="line">                   cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line">  </div><div class="line">                 fe_face_values_neighbor.reinit(neighbor, neighbor_face);</div><div class="line">  </div><div class="line">                 fe_face_values_neighbor.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">                   old_solution, old_solution_values_face_neighbor);</div><div class="line">  </div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                   neighbor_saturation[q] =</div><div class="line">                     old_solution_values_face_neighbor[q](dim + 1);</div><div class="line">               }</div><div class="line">  </div><div class="line"> </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">               {</div><div class="line">                 <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                   present_u_face[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values_face[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line">  </div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">                   present_u_face fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line">  </div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line">  </div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                   local_rhs(i)</div><div class="line">  </div><div class="line">-=</div><div class="line">                     time.get_next_step_size() normal_flux</div><div class="line">                     fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                                        old_solution_values_face[q](dim + 1) :</div><div class="line">                                        neighbor_saturation[q]),</div><div class="line">                                     viscosity)</div><div class="line">                     fe_face_values[saturation].value(i, q)</div><div class="line">                     fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">               }</div><div class="line">           }</div><div class="line">  </div><div class="line">         cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">           system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemsolve"></a> </p><h4>TwoPhaseFlowProblem::solve</h4>
<p>After all these preparations, we finally solve the linear system for velocity and pressure in the same way as in <a class="el" href="step_20.html">step-20</a> . After that, we have to deal with the saturation equation (see below):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;&gt; m_inverse(</div><div class="line">    system_matrix.block(0, 0));</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp2(solution.block(2).size());</div></div><!-- fragment --><p>First the pressure, using the pressure Schur complement of the first two equations:</p>
<div class="fragment"><div class="line">     {</div><div class="line">       m_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">       system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">       schur_rhs</div><div class="line">  </div><div class="line">-= system_rhs.block(1);</div><div class="line">  </div><div class="line"> </div><div class="line">       SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(system_matrix, m_inverse);</div><div class="line">  </div><div class="line">       ApproximateSchurComplement approximate_schur_complement(system_matrix);</div><div class="line">  </div><div class="line">       InverseMatrix&lt;ApproximateSchurComplement&gt; preconditioner(</div><div class="line">         approximate_schur_complement);</div><div class="line">  </div><div class="line"> </div><div class="line">       <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                                    1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 schur_rhs.l2_norm());</div><div class="line">       <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">  </div><div class="line">       cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, preconditioner);</div><div class="line">  </div><div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span> &lt;&lt; std::endl;</div><div class="line">     }</div></div><!-- fragment --><p>Now the velocity:</p>
<div class="fragment"><div class="line">     {</div><div class="line">       system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">       tmp=</div><div class="line">  </div><div class="line">-1;</div><div class="line">       tmp += system_rhs.block(0);</div><div class="line">  </div><div class="line">       m_inverse.vmult(solution.block(0), tmp);</div><div class="line">     }</div></div><!-- fragment --><p>Finally, we have to take care of the saturation equation. The first business we have here is to determine the time step using the formula in the introduction. Knowing the shape of our domain and that we created the mesh by regular subdivision of cells, we can compute the diameter of each of our cells quite easily (in fact we use the linear extensions in coordinate directions of the cells, not the diameter). Note that we will learn a more general way to do this in <a class="el" href="step_24.html">step-24</a> , where we use the <a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a> function. The maximal velocity we compute using a helper function to compute the maximal velocity defined below, and with all this we can evaluate our new time step length. We use the method DiscreteTime::set_desired_next_time_step() to suggest the new calculated value of the time step to the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object. In most cases, the time object uses the exact provided value to increment time. It some case, the step size may be modified further by the time object. For example, if the calculated time increment overshoots the end time, it is truncated accordingly.</p>
<div class="fragment"><div class="line">time.set_desired_next_step_size(std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">                                get_maximal_velocity());</div></div><!-- fragment --><p>The next step is to assemble the right hand side, and then to pass everything on for solution. At the end, we project back saturations onto the physically reasonable range:</p>
<div class="fragment"><div class="line">  assemble_rhs_S();</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_matrix.block(2, 2).m(),</div><div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 system_rhs.block(2).l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">    cg.solve(system_matrix.block(2, 2),</div><div class="line">             solution.block(2),</div><div class="line">             system_rhs.block(2),</div><div class="line">             <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    project_back_saturation();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  old_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemoutput_results"></a> </p><h4>TwoPhaseFlowProblem::output_results</h4>
<p>There is nothing surprising here. Since the program will do a lot of time steps, we create an output file only every fifth time step and skip all other time steps at the top of the file already. When creating file names for output close to the bottom of the function, we convert the number of the time step to a string representation that is padded by leading zeros to four digits. We do this because this way all output file names have the same length, and consequently sort well when creating a directory listing.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (time.get_step_number() % 5 != 0)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_names;</div><div class="line">  <span class="keywordflow">switch</span> (dim)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(degree + 1);</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time.get_step_number(), 4) +</div><div class="line">                       <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemproject_back_saturation"></a> </p><h4>TwoPhaseFlowProblem::project_back_saturation</h4>
<p>In this function, we simply run over all saturation degrees of freedom and make sure that if they should have left the physically reasonable range, that they be reset to the interval \([0,1]\) . To do this, we only have to loop over all saturation components of the solution vector; these are stored in the block 2 (block 0 are the velocities, block 1 are the pressures). It may be instructive to note that this function almost never triggers when the time step is chosen as mentioned in the introduction. However, if we choose the timestep only slightly larger, we get plenty of values outside the proper range. Strictly speaking, the function is therefore unnecessary if we choose the time step small enough. In a sense, the function is therefore only a safety device to avoid situations where our entire solution becomes unphysical because individual degrees of freedom have become unphysical a few time steps earlier.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; solution.block(2).size(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">      solution.block(2)(i) = 0;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">      solution.block(2)(i) = 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemget_maximal_velocity"></a> </p><h4>TwoPhaseFlowProblem::get_maximal_velocity</h4>
<p>The following function is used in determining the maximal allowable time step. What it does is to loop over all quadrature points in the domain and find what the maximal magnitude of the velocity is.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        quadrature_formula(degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; solution_values(n_q_points,</div><div class="line">                                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, solution_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">            velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">          max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemrun"></a> </p><h4>TwoPhaseFlowProblem::run</h4>
<p>This is the final function of our main class. Its brevity speaks for itself. There are only two points worth noting: First, the function projects the initial values onto the finite element space at the beginning; the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function doing this requires an argument indicating the hanging node constraints. We have none in this program (we compute on a uniformly refined mesh), but the function requires the argument anyway, of course. So we have to create a constraint object. In its original state, constraint objects are unsorted, and have to be sorted (using the <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a> function) before they can be used. This is what we do here, and which is why we can't simply call the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function with an anonymous temporary object <code><a class="el" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;()</a></code> as the second argument. The second point worth mentioning is that we only compute the length of the present time step in the middle of solving the linear system corresponding to each time step. We can therefore output the present time of a time step only at the end of the time step. We increment time by calling the method <a class="el" href="classDiscreteTime.html#aa10f7326a1a864ba38e28c86624fdd51">DiscreteTime::advance_time()</a> inside the loop. Since we are reporting the time and dt after we increment it, we have to call the method <a class="el" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">DiscreteTime::get_previous_step_size()</a> instead of <a class="el" href="classDiscreteTime.html#a07ea63ccba26b095eaa088719b98e85d">DiscreteTime::get_next_step_size()</a>. After many steps, when the simulation reaches the end time, the last dt is chosen by the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> class in such a way that the last step finishes exactly at the end time.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"> </div><div class="line">    {</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"> </div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                           constraints,</div><div class="line">                           <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree + 2),</div><div class="line">                           InitialValues&lt;dim&gt;(),</div><div class="line">                           old_solution);</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_step_number() + 1 &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        assemble_system();</div><div class="line"> </div><div class="line">        solve();</div><div class="line"> </div><div class="line">        output_results();</div><div class="line"> </div><div class="line">        time.advance_time();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time.get_current_time()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time.get_previous_step_size() &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step21</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>That's it. In the main function, we pass the degree of the finite element space to the constructor of the TwoPhaseFlowProblem object. Here, we use zero-th degree elements, i.e. \(RT_0\times DQ_0 \times DQ_0\) . The rest is as in all the other programs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"> </div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The code as presented here does not actually compute the resultsfound on the web page. The reason is, that even on a decentcomputer it runs more than a day. If you want to reproduce theseresults, modify the end time of the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object to <code>250</code> within theconstructor of TwoPhaseFlowProblem. If we run the program, we get the following kind of output: </p><div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 4160 (2112+1024+1024)</div><div class="line">  </div><div class="line">Timestep 1</div><div class="line">   22 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0326742, dt=0.0326742.</div><div class="line">  </div><div class="line">Timestep 2</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0653816, dt=0.0327074.</div><div class="line">  </div><div class="line">Timestep 3</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0980651, dt=0.0326836.</div><div class="line">  </div><div class="line">...</div></div><!-- fragment --><p> As we can see, the time step is pretty much constant right from the start,which indicates that the velocities in the domain are not strongly dependenton changes in saturation, although they certainly are through the factor \(\lambda(S)\) in the pressure equation. Our second observation is that the number of CG iterations needed to solve thepressure Schur complement equation drops from 22 to 17 between the first andthe second time step (in fact, it remains around 17 for the rest of thecomputations). The reason is actually simple: Before we solve for the pressureduring a time step, we don't reset the <code>solution</code> variable tozero. The pressure (and the other variables) therefore have the previous timestep's values at the time we get into the CG solver. Since the velocities andpressures don't change very much as computations progress, the previous timestep's pressure is actually a good initial guess for this time step'spressure. Consequently, the number of iterations we need once we have computedthe pressure once is significantly reduced. The final observation concerns the number of iterations needed to solve forthe saturation, i.e. one. This shouldn't surprise us too much: the matrix wehave to solve with is the mass matrix. However, this is the mass matrix forthe \(DGQ_0\) element of piecewise constants where no element couples with thedegrees of freedom on neighboring cells. The matrix is therefore a diagonalone, and it is clear that we should be able to invert this matrix in a singleCG iteration.</p>
<p>With all this, here are a few movies that show how the saturation progressesover time. First, this is for the single crack model, as implemented in the <code>SingleCurvingCrack::KInverse</code> class: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.centerline.gif"/>
</div>
<p> As can be seen, the water rich fluid snakes its way mostly along thehigh-permeability zone in the middle of the domain, whereas the rest of thedomain is mostly impermeable. This and the next movie are generated using <code>n_refinement_steps=7</code> , leading to a \(128\times 128\) mesh with some16,000 cells and about 66,000 unknowns in total.</p>
<p>The second movie shows the saturation for the random medium model of class <code>RandomMedium::KInverse</code> , where we have randomly distributedcenters of high permeability and fluid hops from one of these zones tothe next: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random2d.gif"/>
</div>
<p>Finally, here is the same situation in three space dimensions, on a mesh with <code>n_refinement_steps=5</code> , which produces a mesh of some 32,000 cellsand 167,000 degrees of freedom: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random3d.gif"/>
</div>
<p> To repeat these computations, all you have to do is to change the line </p><div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p> in the main function to </p><div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;3&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p> The visualization uses a cloud technique, where the saturation is indicated bycolored but transparent clouds for each cell. This way, one can also seesomewhat what happens deep inside the domain. A different way of visualizingwould have been to show isosurfaces of the saturation evolving overtime. There are techniques to plot isosurfaces transparently, so that one cansee several of them at the same time like the layers of an onion. So why don't we show such isosurfaces? The problem lies in the way isosurfacesare computed: they require that the field to be visualized is continuous, sothat the isosurfaces can be generated by following contours at least across asingle cell. However, our saturation field is piecewise constant anddiscontinuous. If we wanted to plot an isosurface for a saturation \(S=0.5\) ,chances would be that there is no single point in the domain where thatsaturation is actually attained. If we had to define isosurfaces in thatcontext at all, we would have to take the interfaces between cells, where oneof the two adjacent cells has a saturation greater than and the other cell asaturation less than 0.5. However, it appears that most visualization programsare not equipped to do this kind of transformation.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>There are a number of areas where this program can be improved. Three of themare listed below. All of them are, in fact, addressed in a tutorial programthat forms the continuation of the current one: <a class="el" href="step_43.html">step-43</a> .</p>
<p><a class="anchor" id="Solvers"></a></p><h4>Solvers</h4>
<p>At present, the program is not particularly fast: the 2d random mediumcomputation took about a day for the 1,000 or so time steps. The corresponding3d computation took almost two days for 800 time steps. The reason why itisn't faster than this is twofold. First, we rebuild the entire matrix inevery time step, although some parts such as the \(B\) , \(B^T\) , and \(M^S\) blocksnever change. Second, we could do a lot better with the solver andpreconditioners. Presently, we solve the Schur complement \(B^TM^u(S)^{-1}B\) with a CG method, using \([B^T (\textrm{diag}(M^u(S)))^{-1} B]^{-1}\) as apreconditioner. Applying this preconditioner is expensive, since it involvessolving a linear system each time. This may have been appropriate for <a class="el" href="step_20.html">step_20 </a>step-20"  ", where we have to solve the entire problem onlyonce. However, here we have to solve it hundreds of times, and in such casesit is worth considering a preconditioner that is more expensive to set up thefirst time, but cheaper to apply later on. One possibility would be to realize that the matrix we use as preconditioner, \(B^T (\textrm{diag}(M^u(S)))^{-1} B\) is still sparse, and symmetric on top ofthat. If one looks at the flow field evolve over time, we also see that while \(S\) changes significantly over time, the pressure hardly does and consequently \(B^T (\textrm{diag}(M^u(S)))^{-1} B \approx B^T (\textrm{diag}(M^u(S^0)))^{-1} B\) . In other words, the matrix for the first time step should be a goodpreconditioner also for all later time steps. With a bit ofback-and-forthing, it isn't hard to actually get a representation of it as aSparseMatrix object. We could then hand it off to the <a class="el" href="classSparseMIC.html">SparseMIC</a> class to forma sparse incomplete Cholesky decomposition. To form this decomposition isexpensive, but we have to do it only once in the first time step, and can thenuse it as a cheap preconditioner in the future. We could do better even byusing the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class that produces not only an incomplete, buta complete decomposition of the matrix, which should yield an even betterpreconditioner. Finally, why use the approximation \(B^T (\textrm{diag}(M^u(S)))^{-1} B\) toprecondition \(B^T M^u(S)^{-1} B\) ? The latter matrix, after all, is the mixedform of the Laplace operator on the pressure space, for which we use linearelements. We could therefore build a separate matrix \(A^p\) on the side thatdirectly corresponds to the non-mixed formulation of the Laplacian, forexample using the bilinear form \((\mathbf{K}\lambda(S^n) \nabla \varphi_i,\nabla\varphi_j)\) . We could then form an incomplete or completedecomposition of this non-mixed matrix and use it as a preconditioner of themixed form. Using such techniques, it can reasonably be expected that the solution processwill be faster by at least an order of magnitude.</p>
<p><a class="anchor" id="Timestepping"></a></p><h4>Time stepping</h4>
<p>In the introduction we have identified the time step restriction </p><p class="formulaDsp">
\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|} \]
</p>
<p> has to hold globally, i.e. for all \(\mathbf x\) . After discretization, wesatisfy it by choosing </p><p class="formulaDsp">
\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p> This restriction on the time step is somewhat annoying: the finer we make themesh the smaller the time step; in other words, we get punished twice: eachtime step is more expensive to solve and we have to do more time steps. This is particularly annoying since the majority of the additional work isspent solving the implicit part of the equations, i.e. the pressure-velocitysystem, whereas it is the hyperbolic transport equation for the saturationthat imposes the time step restriction. To avoid this bottleneck, people have invented a number of approaches. Forexample, they may only re-compute the pressure-velocity field every few timesteps (or, if you want, use different time step sizes for thepressure/velocity and saturation equations). This keeps the time steprestriction on the cheap explicit part while it makes the solution of theimplicit part less frequent. Experiments in this direction arecertainly worthwhile; one starting point for such an approach is the paper byZhangxin Chen, Guanren Huan and Baoyan Li: <em>An improved IMPES method for two-phase flow in porous media</em>, Transport in Porous Media, 54 (2004),pp. 361&mdash;376. There are certainly many other papers on this topic as well, butthis one happened to land on our desk a while back.</p>
<p><a class="anchor" id="Adaptivity"></a></p><h4>Adaptivity</h4>
<p>Adaptivity would also clearly help. Looking at the movies, one clearly seesthat most of the action is confined to a relatively small part of the domain(this particularly obvious for the saturation, but also holds for thevelocities and pressures). Adaptivity can therefore be expected to keep thenecessary number of degrees of freedom low, or alternatively increase theaccuracy. On the other hand, adaptivity for time dependent problems is not a trivialthing: we would have to change the mesh every few time steps, and we wouldhave to transport our present solution to the next mesh every time we changeit (something that the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class can help with). These are notinsurmountable obstacles, but they do require some additional coding and morethan we felt comfortable was worth packing into this tutorial program.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Yan Li, Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system();</div><div class="line">    <span class="keywordtype">void</span>   assemble_rhs_S();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   solve();</div><div class="line">    <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">    <span class="keywordtype">void</span>   output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time;</div><div class="line">    <span class="keywordtype">double</span>       viscosity;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).value(p, component);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).vector_value(p, values);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">          {</div><div class="line">            values[p].clear();</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">              <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                                (0.1 * 0.1)),</div><div class="line">                       0.01);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / permeability;</div><div class="line">          }</div><div class="line">      }</div><div class="line">    };</div><div class="line">  } <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>RandomMedium</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">          {</div><div class="line">            values[p].clear();</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> permeability = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">              permeability += std::exp(-(points[p] - centers[i]).norm_square() /</div><div class="line">                                       (0.05 * 0.05));</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / normalized_permeability;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; get_centers()</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">          (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">        std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            centers_list[i][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> centers_list;</div><div class="line">      }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt;</div><div class="line">      KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line">  } <span class="comment">// namespace RandomMedium</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(std::max&lt;unsigned int&gt;(src.size(), 200),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;          <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,</div><div class="line">                    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>&gt; &amp;Minv)</div><div class="line">      : system_matrix(&amp;A)</div><div class="line">      , m_inverse(&amp;Minv)</div><div class="line">      , tmp1(A.block(0, 0).m())</div><div class="line">      , tmp2(A.block(0, 0).m())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">      m_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">      system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt;           system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>&gt;&gt; m_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ApproximateSchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">      : system_matrix(&amp;A)</div><div class="line">      , tmp1(A.block(0, 0).m())</div><div class="line">      , tmp2(A.block(0, 0).m())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">      system_matrix-&gt;block(0, 0).precondition_Jacobi(tmp2, tmp1);</div><div class="line">      system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : degree(degree)</div><div class="line">    , fe(<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">         1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , n_refinement_steps(5)</div><div class="line">    , time(<span class="comment">/*start time*/</span> 0., <span class="comment">/*end time*/</span> 1.)</div><div class="line">    , viscosity(0.2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_component =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>(dof_handler);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                       n_p = dofs_per_component[dim],</div><div class="line">                       n_s = dofs_per_component[dim + 1];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(3, 3);</div><div class="line">    sparsity_pattern.block(0, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(0, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(0, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">    sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, sparsity_pattern);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    solution.reinit(3);</div><div class="line">    solution.block(0).reinit(n_u);</div><div class="line">    solution.block(1).reinit(n_p);</div><div class="line">    solution.block(2).reinit(n_s);</div><div class="line">    solution.collect_sizes();</div><div class="line"></div><div class="line">    old_solution.reinit(3);</div><div class="line">    old_solution.block(0).reinit(n_u);</div><div class="line">    old_solution.block(1).reinit(n_p);</div><div class="line">    old_solution.block(2).reinit(n_s);</div><div class="line">    old_solution.collect_sizes();</div><div class="line"></div><div class="line">    system_rhs.reinit(3);</div><div class="line">    system_rhs.block(0).reinit(n_u);</div><div class="line">    system_rhs.block(1).reinit(n_p);</div><div class="line">    system_rhs.block(2).reinit(n_s);</div><div class="line">    system_rhs.collect_sizes();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">    <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt;              old_solution_values(n_q_points,</div><div class="line">                                                                 Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;std::vector&lt;Tensor&lt;1, dim&gt;&gt;&gt; old_solution_grads(</div><div class="line">      n_q_points, std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt;(dim + 2));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line"></div><div class="line">        pressure_right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                            pressure_rhs_values);</div><div class="line">        k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim + 1);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u = fe_values[velocities].value(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_i_u = fe_values[velocities].divergence(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_p     = fe_values[pressure].value(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s     = fe_values[saturation].value(i, q);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j_u =</div><div class="line">                    fe_values[velocities].value(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_j_u =</div><div class="line">                    fe_values[velocities].divergence(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_p = fe_values[pressure].value(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = fe_values[saturation].value(j, q);</div><div class="line"></div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (phi_i_u * k_inverse_values[q] *</div><div class="line">                       mobility_inverse(old_s, viscosity) * phi_j_u -</div><div class="line">                     div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u +</div><div class="line">                     phi_i_s * phi_j_s) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (-phi_i_p * pressure_rhs_values[q]) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              fe_face_values.reinit(cell, face);</div><div class="line"></div><div class="line">              pressure_boundary_values.value_list(</div><div class="line">                fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                      fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                    local_rhs(i) +=</div><div class="line">                      -(phi_i_u * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                        boundary_values[q] * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              local_matrix(i, j));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor(fe,</div><div class="line">                                              face_quadrature_formula,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values(n_q_points,</div><div class="line">                                                    Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face(n_face_q_points,</div><div class="line">                                                         Vector&lt;double&gt;(dim +</div><div class="line">                                                                        2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face_neighbor(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values(n_q_points,</div><div class="line">                                                        Vector&lt;double&gt;(dim +</div><div class="line">                                                                       2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values_face(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 2));</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  neighbor_saturation(n_face_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        local_rhs = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, present_solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_solution_values[q](dim + 1);</div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                present_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = fe_values[saturation].value(i, q);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">                fe_values[saturation].gradient(i, q);</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (time.get_next_step_size() * fractional_flow(old_s, viscosity) *</div><div class="line">                   present_u * grad_phi_i_s +</div><div class="line">                 old_s * phi_i_s) *</div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          {</div><div class="line">            fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution,</div><div class="line">                                               old_solution_values_face);</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution,</div><div class="line">                                               present_solution_values_face);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">              saturation_boundary_values.value_list(</div><div class="line">                fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>         neighbor = cell-&gt;neighbor(face_no);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face =</div><div class="line">                  cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">                fe_face_values_neighbor.reinit(neighbor, neighbor_face);</div><div class="line"></div><div class="line">                fe_face_values_neighbor.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">                  old_solution, old_solution_values_face_neighbor);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                  neighbor_saturation[q] =</div><div class="line">                    old_solution_values_face_neighbor[q](dim + 1);</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                  present_u_face[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values_face[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">                  present_u_face * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  local_rhs(i) -=</div><div class="line">                    time.get_next_step_size() * normal_flux *</div><div class="line">                    fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                                       old_solution_values_face[q](dim + 1) :</div><div class="line">                                       neighbor_saturation[q]),</div><div class="line">                                    viscosity) *</div><div class="line">                    fe_face_values[saturation].value(i, q) *</div><div class="line">                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;&gt; m_inverse(</div><div class="line">      system_matrix.block(0, 0));</div><div class="line">    Vector&lt;double&gt; tmp(solution.block(0).size());</div><div class="line">    Vector&lt;double&gt; schur_rhs(solution.block(1).size());</div><div class="line">    Vector&lt;double&gt; tmp2(solution.block(2).size());</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      m_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"></div><div class="line">      SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(system_matrix, m_inverse);</div><div class="line"></div><div class="line">      ApproximateSchurComplement approximate_schur_complement(system_matrix);</div><div class="line"></div><div class="line">      InverseMatrix&lt;ApproximateSchurComplement&gt; preconditioner(</div><div class="line">        approximate_schur_complement);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 * schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, preconditioner);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      m_inverse.vmult(solution.block(0), tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">    time.set_desired_next_step_size(std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">                                    get_maximal_velocity());</div><div class="line"></div><div class="line">    assemble_rhs_S();</div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_matrix.block(2, 2).m(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.block(2).l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">      cg.solve(system_matrix.block(2, 2),</div><div class="line">               solution.block(2),</div><div class="line">               system_rhs.block(2),</div><div class="line">               <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">      project_back_saturation();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    old_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (time.get_step_number() % 5 != 0)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(degree + 1);</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time.get_step_number(), 4) +</div><div class="line">                         <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; solution.block(2).size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">        solution.block(2)(i) = 0;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">        solution.block(2)(i) = 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        quadrature_formula(degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; solution_values(n_q_points,</div><div class="line">                                                Vector&lt;double&gt;(dim + 2));</div><div class="line">    <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">              velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">            max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                           constraints,</div><div class="line">                           <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree + 2),</div><div class="line">                           InitialValues&lt;dim&gt;(),</div><div class="line">                           old_solution);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_step_number() + 1 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        time.advance_time();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time.get_current_time()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time.get_previous_step_size() &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step21</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_20.html">step-20</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetwophaseflowproblem">The two phase flow problem</a>
        <li><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Choosingatimestep">Choosing a time step</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeTwoPhaseFlowProblemcodeclass">The <code>TwoPhaseFlowProblem</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
      <ul>
        <li><a href="#Pressurerighthandside">Pressure right hand side</a>
        <li><a href="#Pressureboundaryvalues">Pressure boundary values</a>
        <li><a href="#Saturationboundaryvalues">Saturation boundary values</a>
        <li><a href="#Initialdata">Initial data</a>
      </ul>
        <li><a href="#Theinversepermeabilitytensor">The inverse permeability tensor</a>
      <ul>
        <li><a href="#Singlecurvingcrackpermeability">Single curving crack permeability</a>
        <li><a href="#Randommediumpermeability">Random medium permeability</a>
      </ul>
        <li><a href="#Theinversemobilityandsaturationfunctions">The inverse mobility and saturation functions</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
        <li><a href="#codeTwoPhaseFlowProblemcodeclassimplementation"><code>TwoPhaseFlowProblem</code> class implementation</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemTwoPhaseFlowProblem">TwoPhaseFlowProblem::TwoPhaseFlowProblem</a>
        <li><a href="#TwoPhaseFlowProblemmake_grid_and_dofs">TwoPhaseFlowProblem::make_grid_and_dofs</a>
        <li><a href="#TwoPhaseFlowProblemassemble_system">TwoPhaseFlowProblem::assemble_system</a>
        <li><a href="#TwoPhaseFlowProblemassemble_rhs_S">TwoPhaseFlowProblem::assemble_rhs_S</a>
        <li><a href="#TwoPhaseFlowProblemsolve">TwoPhaseFlowProblem::solve</a>
        <li><a href="#TwoPhaseFlowProblemoutput_results">TwoPhaseFlowProblem::output_results</a>
        <li><a href="#TwoPhaseFlowProblemproject_back_saturation">TwoPhaseFlowProblem::project_back_saturation</a>
        <li><a href="#TwoPhaseFlowProblemget_maximal_velocity">TwoPhaseFlowProblem::get_maximal_velocity</a>
        <li><a href="#TwoPhaseFlowProblemrun">TwoPhaseFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Solvers">Solvers</a>
        <li><a href="#Timestepping">Time stepping</a>
        <li><a href="#Adaptivity">Adaptivity</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-21/doc/intro.dox</p>
<p><a class="anchor" id="Introduction"></a>［<a class="anchor" id="Intro"></a>］ ［&lt;h1&gt;Introduction］</p>
<p>这个项目是由德克萨斯A&amp;M大学的李艳的一个学生项目发展而来的。这个项目的大部分工作都是由她完成的。</p>
<p>在这个项目中，我们提出了一个针对多孔介质中两相流动问题的数值模拟。这个问题包括一个椭圆方程和一个非线性的、随时间变化的传输方程。因此，这也是第一个时间相关的教程程序（除了有点奇怪的时间相关的 <a class="el" href="step_18.html">step-18</a>）。</p>
<p>这里涉及的方程是步骤20中已经涉及的材料的延伸。特别是，它们属于矢量值问题的范畴。这个主题的顶层概述可以在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中找到。</p>
<p><a class="anchor" id="Thetwophaseflowproblem"></a></p><h3>The two phase flow problem</h3>
<p>多孔介质中两相流动的建模对于环境修复和石油及地下水库的管理都很重要。涉及两相流动的实际情况包括非水相液体在含水层中的分散，或混合液体（如油和水）在储层中的联合运动。仿真模型如果要提供真实的预测，就必须准确地考虑到这些影响。</p>
<p>为了推导出管理方程，考虑储层中的两相流动 \(\Omega\) ，假设流体的运动由粘性效应主导；即我们忽略了重力、压缩性和毛细压力的影响。孔隙率将被认为是恒定的。我们将使用下标 \(w\) 和 \(o\) 来表示两相中的任何一个变量，即水和油的简称。然而，方程的推导对其他流体对也是适用的。</p>
<p>两相中每一相的分子移动的速度由达西定律决定，该定律指出速度与压力梯度成正比。</p>
<p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}_{j} = -\frac{k_{rj}(S)}{\mu_{j}} \mathbf{K} \cdot \nabla p \end{eqnarray*}
</p>
<p>其中 \(\mathbf{u}_{j}\) 是相 \(j=o,w\) 的速度， \(K\) 是渗透率张量， \(k_{rj}\) 是相 \(j\) 的相对渗透率， \(p\) 是压力， \(\mu_{j}\) 是相 \(j\) 的粘性。最后， \(S\) 是饱和度（体积分数），即一个数值在0和1之间的函数，表示流体混合物的组成。一般来说，系数 \(K, k_{rj}, \mu\) 可能是空间上的变量，在下文中我们将始终把它们作为非常数函数。</p>
<p>我们将达西定律与各相的质量守恒声明结合起来。</p>
<p class="formulaDsp">
\[ \textrm{div}\ \mathbf{u}_{j} = q_j, \]
</p>
<p>每个相都有一个源项。通过对两相求和，我们可以用所谓的压力方程来表达治理方程。</p>
<p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p)= q. \end{eqnarray*}
</p>
<p>这里， \(q\) 是和源项，而</p>
<p class="formulaDsp">
\[ \lambda(S) = \frac{k_{rw}(S)}{\mu_{w}}+\frac{k_{ro}(S)}{\mu_{o}} \]
</p>
<p>是总的流动性。</p>
<p>到目前为止，这看起来是一个普通的静止的、类似泊松的方程，我们可以用前几个教程的技术马上解决（例如，看一下步骤6，非常类似的东西）。然而，我们还没有说到饱和度，这当然会随着流体的移动而改变。</p>
<p>方程的第二部分是对饱和度的动态描述，即两种流体的相对浓度如何随时间变化。置换流体（水）的饱和度方程由以下守恒定律给出。</p>
<p class="formulaDsp">
\begin{eqnarray*} S_{t} + \nabla \cdot (F(S) \mathbf{u}) = q_{w}, \end{eqnarray*}
</p>
<p>这可以通过使用前一个方程中发散算子的乘积规则来重写。</p>
<p class="formulaDsp">
\begin{eqnarray*} S_{t} + F(S) \left[\nabla \cdot \mathbf{u}\right] + \mathbf{u} \cdot \left[ \nabla F(S)\right] = S_{t} + F(S) q + \mathbf{u} \cdot \nabla F(S) = q_{w}. \end{eqnarray*}
</p>
<p>这里， \(q=\nabla\cdot \mathbf{u}\) 是上面介绍的总流入量， \(q_{w}\) 是置换流体（水）的流速。这两者与分流量 \(F(S)\) 的关系如下。</p>
<p class="formulaDsp">
\[ q_{w} = F(S) q, \]
</p>
<p>其中分数流通常通过（启发式）表达式进行参数化</p>
<p class="formulaDsp">
\[ F(S) = \frac{k_{rw}(S)/\mu_{w}}{k_{rw}(S)/\mu_{w} + k_{ro}(S)/\mu_{o}}. \]
</p>
<p>将所有这些放在一起，可以得到以下形式的饱和度方程，即平流式。</p>
<p class="formulaDsp">
\begin{eqnarray*} S_{t} + \mathbf{u} \cdot \nabla F(S) = 0, \end{eqnarray*}
</p>
<p>其中 \(\mathbf u\) 是总速度</p>
<p class="formulaDsp">
\[ \mathbf{u} = \mathbf{u}_{o} + \mathbf{u}_{w} = -\lambda(S) \mathbf{K}\cdot\nabla p. \]
</p>
<p>注意，平流方程包含术语 \(\mathbf{u} \cdot \nabla F(S)\) 而不是 \(\mathbf{u} \cdot \nabla S\) ，以表明饱和度不是简单地沿途传送；相反，由于两相以不同的速度移动，即使在平流坐标系中，饱和度实际上也可以改变。为了看到这一点，重写 \(\mathbf{u} \cdot \nabla F(S) = \mathbf{u} F&#39;(S) \cdot \nabla S\) ，观察到具有饱和度 \(S\) 的相的<em>actual</em>传输速度是 \(\mathbf u F&#39;(S)\) ，而另一相的传输速度是 \(\mathbf u (1-F&#39;(S))\) 。 因此， \(F(S)\) 通常被称为<em>fractional flow</em>。</p>
<p>综上所述，我们得到的是以下两个方程式。</p>
<p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p) &amp;=&amp; q \qquad \textrm{in}\ \Omega\times[0,T], \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times[0,T]. \end{eqnarray*}
</p>
<p>这里， \(p=p(\mathbf x, t), S=S(\mathbf x, t)\) 现在是随时间变化的函数：虽然在每个时间瞬间，流场与压力处于平衡状态（即我们忽略了动态加速），但饱和度随着流动而运输，因此随时间变化，反过来又通过第一个方程对 \(S\) 的依赖性影响流场。</p>
<p>这组方程有一个奇特的特点：两个方程中的一个有时间导数，另一个没有。这与压力和速度通过瞬时约束耦合的特点相对应，而饱和度在有限的时间尺度上演变。</p>
<p>这样的方程组被称为微分代数方程（DAE），因为其中一个方程是微分方程，另一个不是（至少不是相对于时间变量），因此是一个 "代数 "方程。这个符号来自常微分方程领域，在这个领域中，所有没有关于时间变量的导数的东西都必然是一个代数方程）。这类方程包含相当知名的情况：例如，与时间相关的斯托克斯和纳维-斯托克斯方程（其中代数约束是流场的发散， \(\textrm{div}\ \mathbf u\) ，必须为零）以及与时间相关的麦克斯韦方程（这里，代数约束是电位移场的发散等于电荷密度， \(\textrm{div}\ \mathbf D = \rho\) ，磁通密度的发散为零。 \(\textrm{div}\ \mathbf B = 0\) ）；即使是<a class="el" href="step_18.html">step-18</a>的准静态模型也属于这个类别。我们将看到，这两个方程的不同特征将告知我们这两个方程的离散化策略。</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>在储层模拟界，通常是通过回到一阶混合公式来解决上面得出的方程。为此，我们重新引入总速度 \(\mathbf u\) ，并将方程写成以下形式。</p>
<p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}+\mathbf{K}\lambda(S) \nabla p&amp;=&amp;0 \\ \nabla \cdot\mathbf{u} &amp;=&amp; q \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>这种表述方式还有一个好处，即我们不必将出现在传输方程中的总速度 \(\mathbf u\) 表示为压力的函数，而是可以将其作为主变量。鉴于前两个方程的鞍点结构以及它们与我们在第20步中介绍的混合拉普拉斯公式的相似性，我们将再次使用混合离散化，这并不奇怪。</p>
<p>但是，让我们先把这个问题推迟一下。我们处理这些方程的第一件事是考虑时间离散化。在储层模拟中，有一个相当标准的算法，我们将在这里使用。它首先使用隐式方程解决压力问题，然后使用显式时间步进方案解决饱和问题。该算法被称为IMplicit Pressure Explicit Saturation（隐式压力显式饱和），很早以前就被提出：Sheldon等人在1959年提出，Stone和Gardner在1961年提出（J.W.Sheldon, B. Zondek and W. T. Cardwell:<em>One-dimensional, incompressible, non-capillary, two-phase fluid flow in a porous medium</em>, Trans.SPE AIME, 216 (1959), pp. 290-296; H. L. Stone and A. O. Gardner Jr: <em>Analysis of gas-cap or dissolved-gas reservoirs</em>, Trans.SPE AIME, 222 (1961), pp. 92-104)。在一个稍加修改的形式中，这个算法可以写成如下：对于每一个时间步长，解决</p>
<p class="formulaDsp">
\begin{eqnarray*} \mathbf{u}^{n+1}+\mathbf{K}\lambda(S^n) \nabla p^{n+1}&amp;=&amp;0 \\ \nabla \cdot\mathbf{u}^{n+1} &amp;=&amp; q^{n+1} \\ \frac {S^{n+1}-S^n}{\triangle t} + \mathbf{u}^{n+1} \cdot \nabla F(S^n) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p>其中 \(\triangle t\) 是一个时间步长。请注意我们是如何解决隐式压力-速度系统的，它只取决于先前计算的饱和度 \(S^n\) ，然后对 \(S^{n+1}\) 做一个显式时间步长，它只取决于先前已知的 \(S^n\) 和刚刚计算的 \(\mathbf{u}^{n+1}\) 。这样一来，我们就不必像使用全隐式方法那样，对系统的非线性进行迭代。从更现代的角度来看，这应该被看作是一种 "算子分割 "方法。</p>
<p>然后我们可以将问题以弱的形式陈述如下，用测试函数 \(\mathbf v\) 、 \(\phi\) 和 \(\sigma\) 乘以每个方程，并通过部分整合条款。</p>
<p class="formulaDsp">
\begin{eqnarray*} \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{u}^{n+1},\mathbf v\right)_\Omega - (p^{n+1}, \nabla\cdot\mathbf v)_\Omega &amp;=&amp; - (p^{n+1}, \mathbf v)_{\partial\Omega} \\ (\nabla \cdot\mathbf{u}^{n+1}, \phi)_\Omega &amp;=&amp; (q^{n+1},\phi)_\Omega \end{eqnarray*}
</p>
<p>注意，在第一项中，我们必须规定边界 \(p^{n+1}\) 上的压力 \(\partial\Omega\) 作为我们问题的边界值。 \(\mathbf n\) 表示对 \(\partial K\) 的单位外向法向量，如常。</p>
<p>对于饱和度方程，我们通过部分积分后得到</p>
<p class="formulaDsp">
\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n), \nabla \cdot (\mathbf{u}^{n+1} \sigma)\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}, \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega. \end{eqnarray*}
</p>
<p>利用 \(\nabla \cdot \mathbf{u}^{n+1}=q^{n+1}\) 这一事实，我们可以重写细胞项，得到如下方程。</p>
<p class="formulaDsp">
\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n) \mathbf{u}^{n+1}, \nabla \sigma\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega + \triangle t \sum_K \left(F(S^n) q^{n+1}, \sigma\right)_K. \end{eqnarray*}
</p>
<p>我们引入了一个DiscreteTime类型的对象，以便在代码中保持对时间和时间步长的当前值的跟踪。这个类封装了许多关于调整时间步长和在指定的最终时间停止的复杂情况。</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>在每个时间步长中，我们再对速度和压力应用 <a class="el" href="step_20.html">step-20 </a>的混合有限方法。为了得到良好的解决，我们对 \(\mathbf{u}\) 选择Raviart-Thomas空间 \(RT_{k}\) ，对 \(p\) 选择 \(DGQ_{k}\) 类的不连续元素。对于饱和度，我们也将选择 \(DGQ_{k}\) 空间。</p>
<p>由于我们有不连续的空间，我们必须考虑如何评估细胞之间界面上的项，因为不连续的函数在那里没有真正定义。特别是，我们必须给饱和度方程左边的最后一个项赋予一个意义。为此，让我们定义，我们要在以下意义上评估它。</p>
<p class="formulaDsp">
\begin{eqnarray*} &amp;&amp;\left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \\ &amp;&amp;\qquad = \left(F(S^n_+) (\mathbf n \cdot \mathbf{u}^{n+1}_+), \sigma\right)_{\partial K_+} + \left(F(S^n_-) (\mathbf n \cdot \mathbf{u}^{n+1}_-), \sigma\right)_{\partial K_-}, \end{eqnarray*}
</p>
<p>其中 \(\partial K_{-} \dealcoloneq \{x\in \partial K, \mathbf{u}(x) \cdot \mathbf{n}&lt;0\}\) 表示流入边界， \(\partial K_{+} \dealcoloneq \{\partial K \setminus \partial K_{-}\}\) 是边界的流出部分。数量 \(S_+,\mathbf{u}_+\) 对应于当前单元上的这些变量值，而 \(S_-,\mathbf{u}_-\) （需要在 \(K\) 边界的流入部分）是取自邻近单元的数量。关于非连续元素技术和通量评估的更多背景，也可以在步骤12和步骤12b中找到。</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<p>这个程序中使用的线性求解器是对步骤20中使用的线性求解器的直接扩展（但没有LinearOperator）。从本质上讲，我们只需将一切从两个解元扩展到三个解元。如果我们使用上面提到的离散空间，并将形状函数放入双线性形式中，我们得出以下线性系统，以解决时间步长 \(n+1\) 。</p>
<p class="formulaDsp">
\[ \left( \begin{array}{ccc} M^u(S^{n}) &amp; B^{T}&amp; 0\\ B &amp; 0 &amp; 0\\ \triangle t\; H &amp; 0&amp; M^S \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{n+1} \\ P^{n+1} \\ S^{n+1} \end{array} \right) = \left( \begin{array}{c} 0 \\ F_2 \\ F_3 \end{array} \right) \]
</p>
<p>其中各个矩阵和向量的定义如下：使用形状函数 \(\mathbf v_i\) （类型为Raviart Thomas \(RT_k\) ）定义速度，使用 \(\phi_i\) （类型为 \(DGQ_k\) ）定义压力和饱和度。</p>
<p class="formulaDsp">
\begin{eqnarray*} M^u(S^n)_{ij} &amp;=&amp; \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{v}_i,\mathbf v_j\right)_\Omega, \\ B_{ij} &amp;=&amp; -(\nabla \cdot \mathbf v_j, \phi_i)_\Omega, \\ H_{ij} &amp;=&amp; - \sum_K \left\{ \left(F(S^n) \mathbf v_i, \nabla \phi_j)\right)_K - \left(F(S^n_+) (\mathbf n \cdot (\mathbf v_i)_+), \phi_j\right)_{\partial K_+} - \left(F(S^n_-) (\mathbf n \cdot (\mathbf v_i)_-), \phi_j\right)_{\partial K_-}, \right\} \\ M^S_{ij} &amp;=&amp; (\phi_i, \phi_j)_\Omega, \\ (F_2)_i &amp;=&amp; -(q^{n+1},\phi_i)_\Omega, \\ (F_3)_i &amp;=&amp; (S^n,\phi_i)_\Omega +\triangle t \sum_K \left(F(S^n) q^{n+1}, \phi_i\right)_K. \end{eqnarray*}
</p>
<dl class="section note"><dt>Note</dt><dd>由于历史原因，与第20步相比，矩阵 \(B\) 和 \(B^T\) 的作用在本程序中被还原了。换句话说，这里 \(B\) 指的是发散， \(B^T\) 指的是梯度算子，而在第20步中则是相反。</dd></dl>
<p>上面的系统出现了一个复杂的问题。由于矩阵 \(H_{ij}\) 隐含地依赖于 \(\mathbf u^{n+1}\) （需要速度来确定细胞边界 \(\partial K\) 的哪些部分是流入或流出的部分），我们只能在解决了速度问题之后才能组装这个矩阵。</p>
<p>然后，求解方案包括以下步骤。</p><ol>
<li>
<p class="startli">使用步骤20中介绍的Schur补足技术求解压力 \(p^{n+1}\) 。 </p><pre class="fragment">&lt;li&gt;  求解速度 \form#2887 ，也是在步骤20中讨论的。

&lt;li&gt;  计算项 \form#2888  ，使用刚刚计算的速度。

&lt;li&gt;  求解饱和度 \form#2866  。   &lt;/ol&gt; 
</pre><p>在这个方案中，我们实际上从未建立过矩阵 \(H\) ，而是在我们准备好后生成第三个方程的右手边。</p>
<p>在程序中，我们使用一个变量 <code>solution</code> 来存储当前时间步骤的解决方案。在每一步结束时，我们将其内容，即其所有的三个块状成分，复制到变量 <code>old_solution</code> 中，以便在下一个时间步骤中使用。</p>
<p><a class="anchor" id="Choosingatimestep"></a></p><h3>Choosing a time step</h3>
<p></p>
<p>在双曲输运方程中，像我们要解决的饱和方程的一般经验法则是，如果我们使用显式时间步长方案，那么我们应该使用一个时间步长，使粒子在一个时间步长内所能走的距离不大于一个细胞的直径。换句话说，在这里，我们应该选择</p>
<p class="formulaDsp">
\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p>幸运的是，我们处在一个可以做到这一点的位置：我们只需要当我们想集合饱和方程的右边时的时间步长，也就是在我们已经解出 \(\mathbf{u}^{n+1}\) 之后。因此，在求解速度之后，我们要做的就是在域中的所有正交点上循环，确定速度的最大幅度。然后我们可以将饱和方程的时间步长设定为</p>
<p class="formulaDsp">
\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p>为什么要这样做呢？如果我们不这样做，那么我们就会发现很多地方的饱和度大于1或小于0，这一点很容易得到验证。请记住，饱和度对应于流体混合物中的水比例，因此在物理上必须在0和1之间）。另一方面，如果我们根据上面列出的标准选择时间步长，这种情况只会非常非常少地发生，事实上在整个程序运行中只有一次。然而，为了安全起见，我们在每个时间步长结束时运行一个函数 <code>project_back_saturation</code> ，如果饱和度已经超出了物理范围，则简单地将其投射回区间 \([0,1]\) 。这很有用，因为函数 \(\lambda(S)\) 和 \(F(S)\) 并不代表这个范围之外的任何物理现象，而且一旦我们有负的饱和度或大于1的饱和度，我们不应该期望程序做任何有用的事情。</p>
<p>请注意，我们在第23步和第24步中也会对时间步长有类似的限制，在这两步中我们要解决与时间有关的波浪方程，即另一个双曲问题。我们还将在下面的<a href="#extensions">possible extensions to this program</a>一节中再来讨论时间步长的选择问题。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p></p>
<p>为了简单起见，本程序假定没有源头， \(q=0\) ，并且异质多孔介质是各向同性的 \(\mathbf{K}(\mathbf{x}) = k(\mathbf{x}) \mathbf{I}\) 。其中第一个假设在油藏中是一个现实的假设：除了注水井和生产井之外，通常没有液体突然出现或消失的机制。第二个假设更难证明：在微观层面上，大多数岩石是各向同性的，因为它们是由相互连接的孔隙网络组成的。然而，这种微观尺度超出了今天计算机模拟的范围，我们不得不满足于模拟米级的东西。然而，在这个尺度上，流体运输通常是通过岩石中的裂缝网络，而不是通过孔隙发生的。然而，裂缝通常是由岩层中的外部应力场造成的（例如由构造断层造成的），因此裂缝是大致排列的。这就导致了这样一种情况：在平行于裂缝的方向上，渗透率往往比垂直于裂缝的方向大几个数量级。然而，在储层模拟中通常面临的一个问题是，建模者不知道裂缝的方向，因为油藏不容易被检查到。在这种情况下，唯一的解决办法是假设有效的、各向同性的渗透率。</p>
<p>无论怎样，这两个限制，即无源和各向同性，只要在程序中写上几行代码就能轻松解除。</p>
<p>接下来，为了简单起见，我们的数值模拟将在 \(\Omega = [0,1]\times [0,1]\) 的单元格上进行，即 \(t\in [0,T]\) 。我们的初始条件是 \(S(\mathbf{x},0)=0\) ；在油藏图片中， \(S\) 将表示水的饱和度，这意味着油藏一开始就含有纯油。请注意，我们不需要任何压力或速度的初始条件，因为这些方程不包含这些变量的时间导数。最后，我们施加以下压力边界条件。</p>
<p class="formulaDsp">
\[ p(\mathbf{x},t)=1-x_1 \qquad \textrm{on}\ \partial\Omega. \]
</p>
<p>由于压力和速度求解的是混合形式的泊松方程，所以施加的压力导致了速度的流场。另一方面，这个流场决定了边界的某一部分是流入还是流出，这很重要，因为我们必须在边界的流入部分施加饱和度的边界条件。</p>
<p class="formulaDsp">
\[ \Gamma_{in}(t) = \{\mathbf{x}\in\partial\Omega: \mathbf{n} \cdot \mathbf{u}(\mathbf{x},t) &lt; 0\}. \]
</p>
<p>在这个流入的边界上，我们施加以下的饱和值。</p>
<p class="formulaDsp">
\begin{eqnarray} S(\mathbf{x},t) = 1 &amp; \textrm{on}\ \Gamma_{in}\cap\{x_1=0\}, \\ S(\mathbf{x},t) = 0 &amp; \textrm{on}\ \Gamma_{in}\backslash \{x_1=0\}. \end{eqnarray}
</p>
<p>换句话说，我们有纯水在左边进入储层，而边界的其他部分与储层的未受干扰部分接触，只要这些边界上发生流入，纯油就会进入。</p>
<p>在我们的模拟中，我们选择总流动性为</p>
<p class="formulaDsp">
\[ \lambda (S) = \frac{1.0}{\mu} S^2 +(1-S)^2 \]
</p>
<p>其中我们用 \(\mu=0.2\) 表示粘度。此外，水的分流量由以下公式给出</p>
<p class="formulaDsp">
\[ F(S)=\frac{S^2}{S^2+\mu (1-S)^2} \]
</p>
<dl class="section note"><dt>Note</dt><dd>几年后在<a class="el" href="step_43.html">step-43</a>中再来看这个测试案例，发现这个测试案例的设置有一个奇怪之处。为此，考虑我们可以将饱和度的平流方程改写为 \(S_{t} + (\mathbf{u} F&#39;(S)) \cdot \nabla S = 0\) 。现在，在初始时间，我们有 \(S=0\) ，在给定的函数 \(F(S)\) 的选择下，我们正好有 \(F&#39;(0)=0\) 。换句话说，在 \(t=0\) 处，方程对所有 \(\mathbf x\) 都还原为 \(S_t=0\) ，所以饱和度在任何地方都是零，而且在任何地方都会保持零！这就是为什么在 \(\mathbf x\) 处的饱和度为零。尽管 \(\mathbf u\) 不一定是零：组合流体在移动，但我们选择的部分通量 \(F(S)\) 是这样的：无穷小量的润湿流体也只以无穷小的速度移动（也就是说，它们粘附在介质上的程度比它们所嵌入的非润湿相要大）。也就是说，我们如何将这一点与润湿性液体从左边侵入，导致<a href="#Results">results section</a>中看到的流动模式的知识联系起来？这就是我们进入数学的地方。像我们在这里考虑的传输方程有无限多的解决方案，但其中只有一个是物理的：由所谓的粘性极限产生的解决方案，称为<a href="http://en.wikipedia.org/wiki/Viscosity_solution">viscosity solution</a>。事情是这样的，用不连续的元素，我们到达了这个粘性极限，因为使用数值通量在数值方案中引入了有限量的人工粘性。另一方面，在<a class="el" href="step_43.html">step-43</a>中，我们在每个单元上使用与 \(\|\mathbf u F&#39;(S)\|\) 成比例的人工粘度，在初始时间是零。因此，那里的饱和度为零，并保持为零；然后我们得到的解是<em>one</em>的平流方程解，但如果不进一步改变，该方法不会收敛到粘性解。因此，我们将在该程序中使用一个不同的初始条件。</dd></dl>
<p>最后，回到测试案例的描述，我们将展示用 <a class="el" href="step_20.html">step-20 </a>的结果部分末尾介绍的两个渗透率函数计算的结果。 </p><ul>
<li>
<p class="startli">一个函数，模拟一个蜿蜒穿过领域的单一裂缝。与<a class="el" href="step_20.html">step-20</a>相类似，但考虑到我们这里的几何形状略有不同，我们用以下函数来描述。 </p><p class="formulaDsp">
\[ k(\mathbf x) = \max \left\{ e^{-\left(\frac{x_2-\frac 12 - 0.1\sin(10x_1)}{0.1}\right)^2}, 0.01 \right\}. \]
</p>
<p>取最大值是必要的，以确保最大和最小渗透率之间的比率保持有界。如果我们不这样做，渗透率将跨越许多数量级。另一方面，最大和最小渗透率之间的比率是舒尔补矩阵的条件数的一个因素，如果太大，会导致我们的线性求解器不再正常收敛的问题。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">一个模拟某种随机介质的函数。在这里，我们选择 </p><p class="formulaDsp">
\begin{eqnarray*} k(\mathbf x) &amp;=&amp; \min \left\{ \max \left\{ \sum_{i=1}^N \sigma_i(\mathbf{x}), 0.01 \right\}, 4\right\}, \\ \sigma_i(\mathbf x) &amp;=&amp; e^{-\left(\frac{|\mathbf{x}-\mathbf{x}_i|}{0.05}\right)^2}, \end{eqnarray*}
</p>
<p>。</p>
<p class="endli">其中中心 \(\mathbf{x}_i\) 是域内 \(N\) 随机选择的位置。这个函数模拟了一个领域，其中有 \(N\) 个渗透率较高的中心（例如，岩石已经开裂）嵌入到一个更原始的、未受干扰的背景岩石矩阵中。请注意，在这里我们切断了上方和下方的渗透率函数，以确保有界的条件数。 </p>
</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p></p>
<p>This program is an adaptation of <a class="el" href="step_20.html">step-20</a> and includes some technique of DG methods from <a class="el" href="step_12.html">step-12</a>. A good part of the program is therefore very similar to <a class="el" href="step_20.html">step-20</a> and we will not comment again on these parts. Only the new stuff will be discussed in more detail.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p></p>
<p>All of these include files have been used before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>In this program, we use a tensor-valued coefficient. Since it may have a spatial dependence, we consider it a tensor-valued function. The following include file provides the <code><a class="el" href="classTensorFunction.html">TensorFunction</a></code> class that offers such functionality:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div></div><!-- fragment --><p>Additionally, we use the class <code><a class="el" href="classDiscreteTime.html">DiscreteTime</a></code> to perform operations related to time incrementation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeTwoPhaseFlowProblemcodeclass"></a> </p><h3>The <code>TwoPhaseFlowProblem</code> class</h3>
<p></p>
<p>This is the main class of the program. It is close to the one of <a class="el" href="step_20.html">step-20</a>, but with a few additional functions:</p>
<ul>
<li>
<p class="startli"><code>assemble_rhs_S</code> assembles the right hand side of the saturation equation. As explained in the introduction, this can't be integrated into <code>assemble_rhs</code> since it depends on the velocity that is computed in the first part of the time step.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>get_maximal_velocity</code> does as its name suggests. This function is used in the computation of the time step size.</p>
<p class="endli"></p>
</li>
<li>
<code>project_back_saturation</code> resets all saturation degrees of freedom with values less than zero to zero, and all those with saturations greater than one to one. </li>
</ul>
<p>The rest of the class should be pretty much obvious. The <code>viscosity</code> variable stores the viscosity \(\mu\) that enters several of the formulas in the nonlinear equations. The variable <code>time</code> keeps track of the time information within the simulation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_rhs_S();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>   solve();</div><div class="line">  <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">  <span class="keywordtype">void</span>   output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time;</div><div class="line">  <span class="keywordtype">double</span>       viscosity;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p></p>
<p><a class="anchor" id="Pressurerighthandside"></a> </p><h4>Pressure right hand side</h4>
<p></p>
<p>At present, the right hand side of the pressure equation is simply the zero function. However, the rest of the program is fully equipped to deal with anything else, if this is desired:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureRightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Pressureboundaryvalues"></a> </p><h4>Pressure boundary values</h4>
<p></p>
<p>The next are pressure boundary values. As mentioned in the introduction, we choose a linear pressure field:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Saturationboundaryvalues"></a> </p><h4>Saturation boundary values</h4>
<p></p>
<p>Then we also need boundary values on the inflow portions of the boundary. The question whether something is an inflow part is decided when assembling the right hand side, we only have to provide a functional description of the boundary values. This is as explained in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Initialdata"></a> </p><h4>Initial data</h4>
<p></p>
<p>Finally, we need initial data. In reality, we only need initial data for the saturation, but we are lazy, so we will later, before the first time step, simply interpolate the entire solution for the previous time step from a function that contains all vector components.</p>
<p>We therefore simply create a function that returns zero in all components. We do that by simply forward every function to the <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a> class. Why not use that right away in the places of this program where we presently use the <code>InitialValues</code> class? Because this way it is simpler to later go back and choose a different function for initial values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).<a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(p, component);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).<a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(p, values);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Theinversepermeabilitytensor"></a> </p><h3>The inverse permeability tensor</h3>
<p></p>
<p>As announced in the introduction, we implement two different permeability tensor fields. Each of them we put into a namespace of its own, so that it will be easy later to replace use of one by the other in the code.</p>
<p><a class="anchor" id="Singlecurvingcrackpermeability"></a> </p><h4>Single curving crack permeability</h4>
<p></p>
<p>The first function for the permeability was the one that models a single curving crack. It was already used at the end of <a class="el" href="step_20.html">step-20</a>, and its functional form is given in the introduction of the present tutorial program. As in some previous programs, we have to declare a (seemingly unnecessary) default constructor of the KInverse class to avoid warnings from some compilers:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                              (0.1 * 0.1)),</div><div class="line">                     0.01);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace SingleCurvingCrack</span></div></div><!-- fragment --><p><a class="anchor" id="Randommediumpermeability"></a> </p><h4>Random medium permeability</h4>
<p></p>
<p>This function does as announced in the introduction, i.e. it creates an overlay of exponentials at random places. There is one thing worth considering for this class. The issue centers around the problem that the class creates the centers of the exponentials using a random function. If we therefore created the centers each time we create an object of the present type, we would get a different list of centers each time. That's not what we expect from classes of this type: they should reliably represent the same function.</p>
<p>The solution to this problem is to make the list of centers a static member variable of this class, i.e. there exists exactly one such variable for the entire program, rather than for each object of this type. That's exactly what we are going to do.</p>
<p>The next problem, however, is that we need a way to initialize this variable. Since this variable is initialized at the beginning of the program, we can't use a regular member function for that since there may not be an object of this type around at the time. The C++ standard therefore says that only non-member and static member functions can be used to initialize a static variable. We use the latter possibility by defining a function <code>get_centers</code> that computes the list of center points when called.</p>
<p>Note that this class works just fine in both 2d and 3d, with the only difference being that we use more points in 3d: by experimenting we find that we need more exponentials in 3d than in 2d (we have more ground to cover, after all, if we want to keep the distance between centers roughly equal), so we choose 40 in 2d and 100 in 3d. For any other dimension, the function does presently not know what to do so simply throws an exception indicating exactly this.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>RandomMedium</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> permeability = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">            permeability += std::exp(-(points[p] - centers[i]).norm_square() /</div><div class="line">                                     (0.05 * 0.05));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / normalized_permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; get_centers()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">        (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">      std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          centers_list[i][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> centers_list;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;Point&lt;dim&gt;&gt;</div><div class="line">    KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line">} <span class="comment">// namespace RandomMedium</span></div></div><!-- fragment --><p><a class="anchor" id="Theinversemobilityandsaturationfunctions"></a> </p><h3>The inverse mobility and saturation functions</h3>
<p></p>
<p>There are two more pieces of data that we need to describe, namely the inverse mobility function and the saturation curve. Their form is also given in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p></p>
<p>The linear solvers we use are also completely analogous to the ones used in <a class="el" href="step_20.html">step-20</a>. The following classes are therefore copied verbatim from there. Note that the classes here are not only copied from <a class="el" href="step_20.html">step-20</a>, but also duplicate classes in deal.II. In a future version of this example, they should be replaced by an efficient method, though. There is a single change: if the size of a linear system is small, i.e. when the mesh is very coarse, then it is sometimes not sufficient to set a maximum of <code>src.size()</code> CG iterations before the solver in the <code>vmult()</code> function converges. (This is, of course, a result of numerical round-off, since we know that on paper, the CG method converges in at most <code>src.size()</code> steps.) As a consequence, we set the maximum number of iterations equal to the maximum of the size of the linear system and 200.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(std::max&lt;unsigned int&gt;(src.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 200),</div><div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;          <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,</div><div class="line">                  <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>&gt; &amp;Minv)</div><div class="line">    : system_matrix(&amp;A)</div><div class="line">    , m_inverse(&amp;Minv)</div><div class="line">    , tmp1(A.block(0, 0).m())</div><div class="line">    , tmp2(A.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">    m_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt;           system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>&gt;&gt; m_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ApproximateSchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">    : system_matrix(&amp;A)</div><div class="line">    , tmp1(A.block(0, 0).m())</div><div class="line">    , tmp2(A.block(0, 0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">    system_matrix-&gt;block(0, 0).precondition_Jacobi(tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="codeTwoPhaseFlowProblemcodeclassimplementation"></a> </p><h3><code>TwoPhaseFlowProblem</code> class implementation</h3>
<p></p>
<p>Here now the implementation of the main class. Much of it is actually copied from <a class="el" href="step_20.html">step-20</a>, so we won't comment on it in much detail. You should try to get familiar with that program first, then most of what is happening here should be mostly clear.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemTwoPhaseFlowProblem"></a> </p><h4>TwoPhaseFlowProblem::TwoPhaseFlowProblem</h4>
<p></p>
<p>First for the constructor. We use \(RT_k \times DQ_k \times DQ_k\) spaces. For initializing the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object, we don't set the time step size in the constructor because we don't have its value yet. The time step size is initially set to zero, but it will be computed before it is needed to increment time, as described in a subsection of the introduction. The time object internally prevents itself from being incremented when \(dt = 0\), forcing us to set a non-zero desired size for \(dt\) before advancing time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : degree(degree)</div><div class="line">  , fe(<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">       1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">       1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , n_refinement_steps(5)</div><div class="line">  , time(<span class="comment">/*start time*/</span> 0., <span class="comment">/*end time*/</span> 1.)</div><div class="line">  , viscosity(0.2)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemmake_grid_and_dofs"></a> </p><h4>TwoPhaseFlowProblem::make_grid_and_dofs</h4>
<p></p>
<p>This next function starts out with well-known functions calls that create and refine a mesh, and then associate degrees of freedom with it. It does all the same things as in <a class="el" href="step_20.html">step-20</a>, just now for three components instead of two.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_component =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>(dof_handler);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                     n_p = dofs_per_component[dim],</div><div class="line">                     n_s = dofs_per_component[dim + 1];</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(3, 3);</div><div class="line">  sparsity_pattern.block(0, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(0, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(0, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(1, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(2, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">  sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, sparsity_pattern);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">  solution.reinit(3);</div><div class="line">  solution.block(0).reinit(n_u);</div><div class="line">  solution.block(1).reinit(n_p);</div><div class="line">  solution.block(2).reinit(n_s);</div><div class="line">  solution.collect_sizes();</div><div class="line"></div><div class="line">  old_solution.reinit(3);</div><div class="line">  old_solution.block(0).reinit(n_u);</div><div class="line">  old_solution.block(1).reinit(n_p);</div><div class="line">  old_solution.block(2).reinit(n_s);</div><div class="line">  old_solution.collect_sizes();</div><div class="line"></div><div class="line">  system_rhs.reinit(3);</div><div class="line">  system_rhs.block(0).reinit(n_u);</div><div class="line">  system_rhs.block(1).reinit(n_p);</div><div class="line">  system_rhs.block(2).reinit(n_s);</div><div class="line">  system_rhs.collect_sizes();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemassemble_system"></a> </p><h4>TwoPhaseFlowProblem::assemble_system</h4>
<p></p>
<p>This is the function that assembles the linear system, or at least everything except the (1,3) block that depends on the still-unknown velocity computed during this time step (we deal with this in <code>assemble_rhs_S</code>). Much of it is again as in <a class="el" href="step_20.html">step-20</a>, but we have to deal with some nonlinearity this time. However, the top of the function is pretty much as usual (note that we set matrix and right hand side to zero at the beginning &mdash; something we didn't have to do for stationary problems since there we use each matrix object only once and it is empty at the beginning anyway).</p>
<p>Note that in its present form, the function uses the permeability implemented in the RandomMedium::KInverse class. Switching to the single curved crack permeability function is as simple as just changing the namespace name.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">  <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">  <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt;              old_solution_values(n_q_points,</div><div class="line">                                                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;1, dim&gt;&gt;&gt; old_solution_grads(</div><div class="line">    n_q_points, std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt;(dim + 2));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs    = 0;</div></div><!-- fragment --><p>Here's the first significant difference: We have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> (previously already used in <a class="el" href="step_9.html">step-9</a>, <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_15.html">step-15</a>), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div></div><!-- fragment --><p>Then we also have to get the values of the pressure right hand side and of the inverse permeability tensor at the quadrature points:</p>
<div class="fragment"><div class="line">pressure_right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    pressure_rhs_values);</div><div class="line">k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                     k_inverse_values);</div></div><!-- fragment --><p>With all this, we can now loop over all the quadrature points and shape functions on this cell and assemble those parts of the matrix and right hand side that we deal with in this function. The individual terms in the contributions should be self-explanatory given the explicit form of the bilinear form stated in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim + 1);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u = fe_values[velocities].value(i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_i_u = fe_values[velocities].divergence(i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_p     = fe_values[pressure].value(i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s     = fe_values[saturation].value(i, q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j_u =</div><div class="line">            fe_values[velocities].value(j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_j_u =</div><div class="line">            fe_values[velocities].divergence(j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_p = fe_values[pressure].value(j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = fe_values[saturation].value(j, q);</div><div class="line"></div><div class="line">          local_matrix(i, j) +=</div><div class="line">            (phi_i_u * k_inverse_values[q] *</div><div class="line">               mobility_inverse(old_s, viscosity) * phi_j_u -</div><div class="line">             div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u +</div><div class="line">             phi_i_s * phi_j_s) *</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      local_rhs(i) +=</div><div class="line">        (-phi_i_p * pressure_rhs_values[q]) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div></div><!-- fragment --><p>Next, we also have to deal with the pressure boundary values. This, again is as in <a class="el" href="step_20.html">step-20</a>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">    {</div><div class="line">      fe_face_values.reinit(cell, face);</div><div class="line"></div><div class="line">      pressure_boundary_values.value_list(</div><div class="line">        fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">              fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">            local_rhs(i) +=</div><div class="line">              -(phi_i_u * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                boundary_values[q] * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">          }</div><div class="line">    }</div></div><!-- fragment --><p>The final step in the loop over all cells is to transfer local contributions into the global matrix and right hand side vector:</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            local_matrix(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>So much for assembly of matrix and right hand side. Note that we do not have to interpolate and apply boundary values since they have all been taken care of in the weak form already.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemassemble_rhs_S"></a> </p><h4>TwoPhaseFlowProblem::assemble_rhs_S</h4>
<p></p>
<p>As explained in the introduction, we can only evaluate the right hand side of the saturation equation once the velocity has been computed. We therefore have this separate function to this end.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor(fe,</div><div class="line">                                            face_quadrature_formula,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values(n_q_points,</div><div class="line">                                                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face(n_face_q_points,</div><div class="line">                                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim +</div><div class="line">                                                                      2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face_neighbor(</div><div class="line">    n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values(n_q_points,</div><div class="line">                                                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim +</div><div class="line">                                                                     2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values_face(</div><div class="line">    n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  neighbor_saturation(n_face_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      local_rhs = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, present_solution_values);</div></div><!-- fragment --><p>First for the cell terms. These are, following the formulas in the introduction, \((S^n,\sigma)-(F(S^n) \mathbf{v}^{n+1},\nabla \sigma)\), where \(\sigma\) is the saturation component of the test function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_solution_values[q](dim + 1);</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        present_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = fe_values[saturation].value(i, q);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">        fe_values[saturation].gradient(i, q);</div><div class="line"></div><div class="line">      local_rhs(i) +=</div><div class="line">        (time.get_next_step_size() * fractional_flow(old_s, viscosity) *</div><div class="line">           present_u * grad_phi_i_s +</div><div class="line">         old_s * phi_i_s) *</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div></div><!-- fragment --><p>Secondly, we have to deal with the flux parts on the face boundaries. This was a bit more involved because we first have to determine which are the influx and outflux parts of the cell boundary. If we have an influx boundary, we need to evaluate the saturation on the other side of the face (or the boundary values, if we are at the boundary of the domain).</p>
<p>All this is a bit tricky, but has been explained in some detail already in <a class="el" href="step_9.html">step-9</a>. Take a look there how this is supposed to work!</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">        {</div><div class="line">          fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">          fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution,</div><div class="line">                                             old_solution_values_face);</div><div class="line">          fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution,</div><div class="line">                                             present_solution_values_face);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">            saturation_boundary_values.value_list(</div><div class="line">              fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span>         neighbor = cell-&gt;neighbor(face_no);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face =</div><div class="line">                cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">              fe_face_values_neighbor.reinit(neighbor, neighbor_face);</div><div class="line"></div><div class="line">              fe_face_values_neighbor.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">                old_solution, old_solution_values_face_neighbor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                neighbor_saturation[q] =</div><div class="line">                  old_solution_values_face_neighbor[q](dim + 1);</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">            {</div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                present_u_face[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values_face[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">                present_u_face * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                local_rhs(i) -=</div><div class="line">                  time.get_next_step_size() * normal_flux *</div><div class="line">                  fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                                     old_solution_values_face[q](dim + 1) :</div><div class="line">                                     neighbor_saturation[q]),</div><div class="line">                                  viscosity) *</div><div class="line">                  fe_face_values[saturation].value(i, q) *</div><div class="line">                  fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemsolve"></a> </p><h4>TwoPhaseFlowProblem::solve</h4>
<p></p>
<p>After all these preparations, we finally solve the linear system for velocity and pressure in the same way as in <a class="el" href="step_20.html">step-20</a>. After that, we have to deal with the saturation equation (see below):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;&gt; m_inverse(</div><div class="line">    system_matrix.block(0, 0));</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp2(solution.block(2).size());</div></div><!-- fragment --><p>First the pressure, using the pressure Schur complement of the first two equations:</p>
<div class="fragment"><div class="line">{</div><div class="line">  m_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">  system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">  schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"></div><div class="line">  SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(system_matrix, m_inverse);</div><div class="line"></div><div class="line">  ApproximateSchurComplement approximate_schur_complement(system_matrix);</div><div class="line"></div><div class="line">  InverseMatrix&lt;ApproximateSchurComplement&gt; preconditioner(</div><div class="line">    approximate_schur_complement);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                               1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 * schur_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Now the velocity:</p>
<div class="fragment"><div class="line">{</div><div class="line">  system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">  tmp *= -1;</div><div class="line">  tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">  m_inverse.vmult(solution.block(0), tmp);</div><div class="line">}</div></div><!-- fragment --><p>Finally, we have to take care of the saturation equation. The first business we have here is to determine the time step using the formula in the introduction. Knowing the shape of our domain and that we created the mesh by regular subdivision of cells, we can compute the diameter of each of our cells quite easily (in fact we use the linear extensions in coordinate directions of the cells, not the diameter). Note that we will learn a more general way to do this in <a class="el" href="step_24.html">step-24</a>, where we use the <a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a> function.</p>
<p>The maximal velocity we compute using a helper function to compute the maximal velocity defined below, and with all this we can evaluate our new time step length. We use the method DiscreteTime::set_desired_next_time_step() to suggest the new calculated value of the time step to the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object. In most cases, the time object uses the exact provided value to increment time. It some case, the step size may be modified further by the time object. For example, if the calculated time increment overshoots the end time, it is truncated accordingly.</p>
<div class="fragment"><div class="line">time.set_desired_next_step_size(std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">                                get_maximal_velocity());</div></div><!-- fragment --><p>The next step is to assemble the right hand side, and then to pass everything on for solution. At the end, we project back saturations onto the physically reasonable range:</p>
<div class="fragment"><div class="line">  assemble_rhs_S();</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_matrix.block(2, 2).m(),</div><div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.block(2).l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">    cg.solve(system_matrix.block(2, 2),</div><div class="line">             solution.block(2),</div><div class="line">             system_rhs.block(2),</div><div class="line">             <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    project_back_saturation();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  old_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemoutput_results"></a> </p><h4>TwoPhaseFlowProblem::output_results</h4>
<p></p>
<p>There is nothing surprising here. Since the program will do a lot of time steps, we create an output file only every fifth time step and skip all other time steps at the top of the file already.</p>
<p>When creating file names for output close to the bottom of the function, we convert the number of the time step to a string representation that is padded by leading zeros to four digits. We do this because this way all output file names have the same length, and consequently sort well when creating a directory listing.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (time.get_step_number() % 5 != 0)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_names;</div><div class="line">  <span class="keywordflow">switch</span> (dim)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(degree + 1);</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time.get_step_number(), 4) +</div><div class="line">                       <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemproject_back_saturation"></a> </p><h4>TwoPhaseFlowProblem::project_back_saturation</h4>
<p></p>
<p>In this function, we simply run over all saturation degrees of freedom and make sure that if they should have left the physically reasonable range, that they be reset to the interval \([0,1]\). To do this, we only have to loop over all saturation components of the solution vector; these are stored in the block 2 (block 0 are the velocities, block 1 are the pressures).</p>
<p>It may be instructive to note that this function almost never triggers when the time step is chosen as mentioned in the introduction. However, if we choose the timestep only slightly larger, we get plenty of values outside the proper range. Strictly speaking, the function is therefore unnecessary if we choose the time step small enough. In a sense, the function is therefore only a safety device to avoid situations where our entire solution becomes unphysical because individual degrees of freedom have become unphysical a few time steps earlier.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; solution.block(2).size(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">      solution.block(2)(i) = 0;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">      solution.block(2)(i) = 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemget_maximal_velocity"></a> </p><h4>TwoPhaseFlowProblem::get_maximal_velocity</h4>
<p></p>
<p>The following function is used in determining the maximal allowable time step. What it does is to loop over all quadrature points in the domain and find what the maximal magnitude of the velocity is.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        quadrature_formula(degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; solution_values(n_q_points,</div><div class="line">                                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 2));</div><div class="line">  <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, solution_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">            velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">          max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemrun"></a> </p><h4>TwoPhaseFlowProblem::run</h4>
<p></p>
<p>This is the final function of our main class. Its brevity speaks for itself. There are only two points worth noting: First, the function projects the initial values onto the finite element space at the beginning; the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function doing this requires an argument indicating the hanging node constraints. We have none in this program (we compute on a uniformly refined mesh), but the function requires the argument anyway, of course. So we have to create a constraint object. In its original state, constraint objects are unsorted, and have to be sorted (using the <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a> function) before they can be used. This is what we do here, and which is why we can't simply call the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> function with an anonymous temporary object <code><a class="el" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;()</a></code> as the second argument.</p>
<p>The second point worth mentioning is that we only compute the length of the present time step in the middle of solving the linear system corresponding to each time step. We can therefore output the present time of a time step only at the end of the time step. We increment time by calling the method <a class="el" href="classDiscreteTime.html#aa10f7326a1a864ba38e28c86624fdd51">DiscreteTime::advance_time()</a> inside the loop. Since we are reporting the time and dt after we increment it, we have to call the method <a class="el" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">DiscreteTime::get_previous_step_size()</a> instead of <a class="el" href="classDiscreteTime.html#a07ea63ccba26b095eaa088719b98e85d">DiscreteTime::get_next_step_size()</a>. After many steps, when the simulation reaches the end time, the last dt is chosen by the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> class in such a way that the last step finishes exactly at the end time.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                           constraints,</div><div class="line">                           <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree + 2),</div><div class="line">                           InitialValues&lt;dim&gt;(),</div><div class="line">                           old_solution);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_step_number() + 1 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        time.advance_time();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time.get_current_time()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time.get_previous_step_size() &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step21</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p></p>
<p>That's it. In the main function, we pass the degree of the finite element space to the constructor of the TwoPhaseFlowProblem object. Here, we use zero-th degree elements, i.e. \(RT_0\times DQ_0 \times DQ_0\). The rest is as in all the other programs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-21/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></p>
<p>这里介绍的代码并没有真正计算出网页上的结果。原因是，即使在一台好的电脑上，它也要运行一天以上。如果你想重现这些结果，在TwoPhaseFlowProblem的构造函数中把DiscreteTime对象的结束时间修改为<code>250</code>。</p>
<p>如果我们运行该程序，我们会得到以下这种输出。</p>
<div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 4160 (2112+1024+1024)</div><div class="line"></div><div class="line"></div><div class="line">Timestep 1</div><div class="line">   22 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0326742, dt=0.0326742.</div><div class="line"></div><div class="line"></div><div class="line">Timestep 2</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0653816, dt=0.0327074.</div><div class="line"></div><div class="line"></div><div class="line">Timestep 3</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0980651, dt=0.0326836.</div><div class="line"></div><div class="line"></div><div class="line">...</div></div><!-- fragment --><p>我们可以看到，时间步长从一开始就基本恒定，这表明域中的速度并不强烈依赖于饱和度的变化，尽管它们肯定是通过压力方程中的因子 \(\lambda(S)\) 来决定的。</p>
<p>我们的第二个观察结果是，在第一和第二时间步之间，解决压力舒尔补足方程所需的CG迭代次数从22次下降到17次（事实上，在其余的计算中，它保持在17次左右）。原因其实很简单。在我们求解一个时间步长的压力之前，我们没有将 <code>solution</code> 变量重置为零。因此，在我们进入CG求解器时，压力（和其他变量）具有前一个时间步骤的值。由于速度和压力在计算过程中变化不大，前一个时间步骤的压力实际上是对这个时间步骤压力的一个很好的初始猜测。因此，一旦我们计算了一次压力，我们需要的迭代次数就会大大减少。</p>
<p>最后的观察是关于求解饱和度所需的迭代次数，也就是一次。这不应该让我们太惊讶：我们必须解决的矩阵是质量矩阵。然而，这是 \(DGQ_0\) 元素的分片常数的质量矩阵，其中没有元素与相邻单元的自由度耦合。因此，该矩阵是一个对角线矩阵，很明显，我们应该能够在一次CG迭代中反转该矩阵。</p>
<p>说了这么多，这里有几个电影，显示了饱和度是如何随时间推移而发展的。首先，这是针对单一裂缝模型的，正如在 <code>SingleCurvingCrack::KInverse</code> 类中实现的那样。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.centerline.gif"/>
</div>
<p>可以看出，富水流体主要是沿着域中间的高渗透区蜿蜒前行，而域的其他部分则大部分是不渗透的。这部电影和下一部电影是用 <code>n_refinement_steps=7</code> 生成的，导致 \(128\times 128\) 的网格有大约16000个单元和大约66000个未知数。</p>
<p>第二部电影显示了 <code>RandomMedium::KInverse</code> 类的随机介质模型的饱和度，我们有随机分布的高渗透率中心，流体从这些区域中的一个跳到另一个。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random2d.gif"/>
</div>
<p>最后，这里是在三个空间维度上的相同情况，在一个具有 <code>n_refinement_steps=5</code> 的网格上，产生一个大约32000个单元和167000个自由度的网格。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random3d.gif"/>
</div>
<p>要重复这些计算，你所要做的就是改变行数</p>
<div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p>在主函数中为</p>
<div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;3&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p>可视化采用了云技术，每个单元的饱和度都由彩色但透明的云来表示。这样，人们也可以在一定程度上看到域的深处发生了什么。另一种可视化的方式是显示饱和度随时间变化的等值面。有一些技术可以透明地绘制等值面，这样就可以像洋葱的层次一样同时看到几个等值面。</p>
<p>那么，为什么我们不显示这样的等值面呢？问题在于等值面的计算方式：它们要求要可视化的场是连续的，所以等值面可以通过至少在单个细胞中遵循轮廓线来生成。然而，我们的饱和场是片状常数和不连续的。如果我们想为一个饱和度 \(S=0.5\) 绘制一个等值面，那么在这个领域中就很可能没有一个点是真正达到饱和度的。如果我们必须在这种情况下定义等值面，我们将不得不采取细胞之间的界面，其中相邻的两个细胞之一的饱和度大于，另一个细胞的饱和度小于0.5。然而，大多数可视化程序似乎并不具备做这种转换的能力。</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p></p>
<p>这个项目有许多可以改进的地方。下面列出了其中的三个。事实上，所有这些问题都在构成当前程序的延续的辅导程序中得到了解决：<a class="el" href="step_43.html">step-43</a>。</p>
<p><a class="anchor" id="Solvers"></a></p><h4>Solvers</h4>
<p></p>
<p>目前，该程序并不是特别快：二维随机介质的计算在1000个左右的时间步长中花费了大约一天时间。相应的三维计算在800个时间步骤中几乎花了两天时间。没有比这更快的原因有两个方面。首先，我们在每个时间步骤中都要重建整个矩阵，尽管有些部分如 \(B\) 、 \(B^T\) 和 \(M^S\) 块从未改变。</p>
<p>第二，我们可以在求解器和预处理器方面做得更好。目前，我们用CG方法解决Schur补数 \(B^TM^u(S)^{-1}B\) ，使用 \([B^T (\textrm{diag}(M^u(S)))^{-1} B]^{-1}\) 作为预处理程序。应用这个预处理程序是很昂贵的，因为它涉及到每次解决一个线性系统。这可能适合于 <a class="el" href="step_20.html">The step-20 tutorial program</a> 的 "第20步"，在那里我们只需要解决整个问题一次。然而，在这里我们必须求解数百次，在这种情况下，值得考虑使用一种第一次设置起来比较昂贵，但以后应用起来比较便宜的预处理程序。</p>
<p>一种可能性是意识到我们用作预处理的矩阵， \(B^T (\textrm{diag}(M^u(S)))^{-1} B\) 仍然是稀疏的，而且是对称的。如果看一下流场随时间的演变，我们还可以看到，虽然 \(S\) 随时间变化很大，但压力几乎没有变化，因此 \(B^T (\textrm{diag}(M^u(S)))^{-1} B \approx B^T (\textrm{diag}(M^u(S^0)))^{-1} B\) 。换句话说，第一个时间步骤的矩阵应该是一个很好的前提条件，也适用于所有后来的时间步骤。 通过一些反反复复的操作，实际上并不难得到一个SparseMatrix对象的表示。然后我们可以把它交给SparseMIC类，以形成一个稀疏的不完全Cholesky分解。形成这种分解是很昂贵的，但是我们只需要在第一个时间步骤中做一次，然后就可以在未来把它作为一个廉价的预处理程序。我们甚至可以通过使用SparseDirectUMFPACK类来做得更好，它不仅能产生一个不完整的，而且是一个完整的矩阵分解，这应该会产生一个更好的预处理程序。</p>
<p>最后，为什么使用近似值 \(B^T (\textrm{diag}(M^u(S)))^{-1} B\) 来预设 \(B^T M^u(S)^{-1} B\) ？后者的矩阵毕竟是压力空间上拉普拉斯算子的混合形式，我们对其使用线性元素。因此，我们可以在直接对应于拉普拉斯的非混合形式的一侧建立一个单独的矩阵 \(A^p\) ，例如使用双线性形式 \((\mathbf{K}\lambda(S^n) \nabla \varphi_i,\nabla\varphi_j)\) 。然后我们可以形成这个非混合矩阵的不完全或完全分解，并将其作为混合形式的预处理。</p>
<p>使用这样的技术，可以合理地预期，求解过程将至少快一个数量级。</p>
<p><a class="anchor" id="Timestepping"></a></p><h4>Time stepping</h4>
<p></p>
<p>在介绍中，我们已经确定了时间步长的限制</p>
<p class="formulaDsp">
\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|} \]
</p>
<p>必须是全局性的，即对所有的 \(\mathbf x\) 。离散化后，我们通过选择以下方式来满足它</p>
<p class="formulaDsp">
\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]
</p>
<p>这种对时间步长的限制有些烦人：我们把网格做得越细，时间步长就越小；换句话说，我们受到了两次惩罚：每个时间步长的求解成本更高，我们必须做更多的时间步长。</p>
<p>这一点特别令人讨厌，因为大部分的额外工作是用来解决方程的隐含部分，即压力-速度系统，而正是饱和度的双曲传输方程施加了时间步长的限制。</p>
<p>为了避免这个瓶颈，人们发明了一些方法。例如，他们可能每隔几步时间才重新计算压力-速度场（或者，如果你愿意，对压力/速度和饱和度方程使用不同的时间步长）。这就保持了对廉价显式部分的时间步长限制，而使隐式部分的求解不那么频繁。这个方向的实验当然是值得的；这种方法的一个起点是陈章新、桓冠仁和李宝岩的论文：<em>An improved IMPES method for two-phase flow in porous media</em>，Transport in Porous Media，54（2004），第361&amp;mdash；376页。当然也有很多其他关于这个主题的论文，但这篇论文前段时间刚好落在我们的桌上。</p>
<p><a class="anchor" id="Adaptivity"></a></p><h4>Adaptivity</h4>
<p></p>
<p>适应性显然也会有帮助。看一下电影，我们可以清楚地看到，大部分的行动都局限于领域的一个相对较小的部分（这对饱和度来说特别明显，但对速度和压力也是如此）。因此，自适应性可望保持必要的低自由度数量，或者增加精确度。</p>
<p>另一方面，对于时间相关问题的自适应性也不是一件小事：我们必须每隔几个时间步数改变网格，而且每次改变网格时，我们都必须将目前的解决方案传送到下一个网格（SolutionTransfer类可以帮助解决这个问题）。这些并不是无法克服的障碍，但它们确实需要一些额外的编码，而且比我们认为值得打包到这个教程程序中的更多。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Yan Li, Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span>   assemble_system();</div><div class="line">    <span class="keywordtype">void</span>   assemble_rhs_S();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   solve();</div><div class="line">    <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">    <span class="keywordtype">void</span>   output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time;</div><div class="line">    <span class="keywordtype">double</span>       viscosity;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).value(p, component);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 2).vector_value(p, values);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">          {</div><div class="line">            values[p].clear();</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">              <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                                (0.1 * 0.1)),</div><div class="line">                       0.01);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / permeability;</div><div class="line">          }</div><div class="line">      }</div><div class="line">    };</div><div class="line">  } <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>RandomMedium</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">          {</div><div class="line">            values[p].clear();</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> permeability = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">              permeability += std::exp(-(points[p] - centers[i]).norm_square() /</div><div class="line">                                       (0.05 * 0.05));</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              values[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = 1. / normalized_permeability;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; get_centers()</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">          (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">        std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            centers_list[i][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> centers_list;</div><div class="line">      }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt;</div><div class="line">      KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line">  } <span class="comment">// namespace RandomMedium</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(std::max&lt;unsigned int&gt;(src.size(), 200),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;          <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,</div><div class="line">                    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>&gt; &amp;Minv)</div><div class="line">      : system_matrix(&amp;A)</div><div class="line">      , m_inverse(&amp;Minv)</div><div class="line">      , tmp1(A.block(0, 0).m())</div><div class="line">      , tmp2(A.block(0, 0).m())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">      m_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">      system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt;           system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>&gt;&gt; m_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ApproximateSchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">      : system_matrix(&amp;A)</div><div class="line">      , tmp1(A.block(0, 0).m())</div><div class="line">      , tmp2(A.block(0, 0).m())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(Vector&lt;double&gt; &amp;dst, <span class="keyword">const</span> Vector&lt;double&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      system_matrix-&gt;block(0, 1).vmult(tmp1, src);</div><div class="line">      system_matrix-&gt;block(0, 0).precondition_Jacobi(tmp2, tmp1);</div><div class="line">      system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> Vector&lt;double&gt; tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : degree(degree)</div><div class="line">    , fe(<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">         1,</div><div class="line">         <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),</div><div class="line">         1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , n_refinement_steps(5)</div><div class="line">    , time(<span class="comment">/*start time*/</span> 0., <span class="comment">/*end time*/</span> 1.)</div><div class="line">    , viscosity(0.2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinement_steps);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_component =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>(dof_handler);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                       n_p = dofs_per_component[dim],</div><div class="line">                       n_s = dofs_per_component[dim + 1];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(3, 3);</div><div class="line">    sparsity_pattern.block(0, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 0).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(0, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 1).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(0, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_u, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(1, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_p, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(2, 2).<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a>(n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">    sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, sparsity_pattern);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    solution.reinit(3);</div><div class="line">    solution.block(0).reinit(n_u);</div><div class="line">    solution.block(1).reinit(n_p);</div><div class="line">    solution.block(2).reinit(n_s);</div><div class="line">    solution.collect_sizes();</div><div class="line"></div><div class="line">    old_solution.reinit(3);</div><div class="line">    old_solution.block(0).reinit(n_u);</div><div class="line">    old_solution.block(1).reinit(n_p);</div><div class="line">    old_solution.block(2).reinit(n_s);</div><div class="line">    old_solution.collect_sizes();</div><div class="line"></div><div class="line">    system_rhs.reinit(3);</div><div class="line">    system_rhs.block(0).reinit(n_u);</div><div class="line">    system_rhs.block(1).reinit(n_p);</div><div class="line">    system_rhs.block(2).reinit(n_s);</div><div class="line">    system_rhs.collect_sizes();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">    <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt;              old_solution_values(n_q_points,</div><div class="line">                                                                 Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;std::vector&lt;Tensor&lt;1, dim&gt;&gt;&gt; old_solution_grads(</div><div class="line">      n_q_points, std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt;(dim + 2));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line"></div><div class="line">        pressure_right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                            pressure_rhs_values);</div><div class="line">        k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim + 1);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u = fe_values[velocities].value(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_i_u = fe_values[velocities].divergence(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_p     = fe_values[pressure].value(i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s     = fe_values[saturation].value(i, q);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j_u =</div><div class="line">                    fe_values[velocities].value(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> div_phi_j_u =</div><div class="line">                    fe_values[velocities].divergence(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_p = fe_values[pressure].value(j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = fe_values[saturation].value(j, q);</div><div class="line"></div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (phi_i_u * k_inverse_values[q] *</div><div class="line">                       mobility_inverse(old_s, viscosity) * phi_j_u -</div><div class="line">                     div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u +</div><div class="line">                     phi_i_s * phi_j_s) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (-phi_i_p * pressure_rhs_values[q]) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              fe_face_values.reinit(cell, face);</div><div class="line"></div><div class="line">              pressure_boundary_values.value_list(</div><div class="line">                fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                      fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                    local_rhs(i) +=</div><div class="line">                      -(phi_i_u * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                        boundary_values[q] * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              local_matrix(i, j));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor(fe,</div><div class="line">                                              face_quadrature_formula,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values(n_q_points,</div><div class="line">                                                    Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face(n_face_q_points,</div><div class="line">                                                         Vector&lt;double&gt;(dim +</div><div class="line">                                                                        2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; old_solution_values_face_neighbor(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values(n_q_points,</div><div class="line">                                                        Vector&lt;double&gt;(dim +</div><div class="line">                                                                       2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_solution_values_face(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 2));</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  neighbor_saturation(n_face_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation(dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        local_rhs = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution, old_solution_values);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, present_solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_solution_values[q](dim + 1);</div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                present_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = fe_values[saturation].value(i, q);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">                fe_values[saturation].gradient(i, q);</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (time.get_next_step_size() * fractional_flow(old_s, viscosity) *</div><div class="line">                   present_u * grad_phi_i_s +</div><div class="line">                 old_s * phi_i_s) *</div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          {</div><div class="line">            fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_solution,</div><div class="line">                                               old_solution_values_face);</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution,</div><div class="line">                                               present_solution_values_face);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">              saturation_boundary_values.value_list(</div><div class="line">                fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>         neighbor = cell-&gt;neighbor(face_no);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face =</div><div class="line">                  cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">                fe_face_values_neighbor.reinit(neighbor, neighbor_face);</div><div class="line"></div><div class="line">                fe_face_values_neighbor.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">                  old_solution, old_solution_values_face_neighbor);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                  neighbor_saturation[q] =</div><div class="line">                    old_solution_values_face_neighbor[q](dim + 1);</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                  present_u_face[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = present_solution_values_face[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">                  present_u_face * fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  local_rhs(i) -=</div><div class="line">                    time.get_next_step_size() * normal_flux *</div><div class="line">                    fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                                       old_solution_values_face[q](dim + 1) :</div><div class="line">                                       neighbor_saturation[q]),</div><div class="line">                                    viscosity) *</div><div class="line">                    fe_face_values[saturation].value(i, q) *</div><div class="line">                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;&gt; m_inverse(</div><div class="line">      system_matrix.block(0, 0));</div><div class="line">    Vector&lt;double&gt; tmp(solution.block(0).size());</div><div class="line">    Vector&lt;double&gt; schur_rhs(solution.block(1).size());</div><div class="line">    Vector&lt;double&gt; tmp2(solution.block(2).size());</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      m_inverse.vmult(tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"></div><div class="line">      SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(system_matrix, m_inverse);</div><div class="line"></div><div class="line">      ApproximateSchurComplement approximate_schur_complement(system_matrix);</div><div class="line"></div><div class="line">      InverseMatrix&lt;ApproximateSchurComplement&gt; preconditioner(</div><div class="line">        approximate_schur_complement);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12 * schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, preconditioner);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      m_inverse.vmult(solution.block(0), tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">    time.set_desired_next_step_size(std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">                                    get_maximal_velocity());</div><div class="line"></div><div class="line">    assemble_rhs_S();</div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_matrix.block(2, 2).m(),</div><div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.block(2).l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">      cg.solve(system_matrix.block(2, 2),</div><div class="line">               solution.block(2),</div><div class="line">               system_rhs.block(2),</div><div class="line">               <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">      project_back_saturation();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    old_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (time.get_step_number() % 5 != 0)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          solution_names = {<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>};</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(degree + 1);</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time.get_step_number(), 4) +</div><div class="line">                         <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; solution.block(2).size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">        solution.block(2)(i) = 0;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">        solution.block(2)(i) = 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        quadrature_formula(degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; solution_values(n_q_points,</div><div class="line">                                                Vector&lt;double&gt;(dim + 2));</div><div class="line">    <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">              velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">            max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                           constraints,</div><div class="line">                           <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree + 2),</div><div class="line">                           InitialValues&lt;dim&gt;(),</div><div class="line">                           old_solution);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_step_number() + 1 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        time.advance_time();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time.get_current_time()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time.get_previous_step_size() &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step21</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </li>
</ol>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
