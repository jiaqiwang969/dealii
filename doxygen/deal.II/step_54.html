<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_54.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-54 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-54 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_53.html">step-53</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#CADsurfaces"> CAD surfaces </a>
        <li><a href="#TheCADboundaryprojectorclasses"> The CAD boundary projector classes </a>
        <li><a href="#Thetestcase"> The testcase </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#TheTriangulationOnCADclass">The TriangulationOnCAD class</a>
      <ul>
        <li><a href="#TriangulationOnCADTriangulationOnCAD">TriangulationOnCAD::TriangulationOnCAD</a>
        <li><a href="#TriangulationOnCADread_domain">TriangulationOnCAD::read_domain</a>
        <li><a href="#TriangulationOnCADrefine_mesh">TriangulationOnCAD::refine_mesh</a>
        <li><a href="#TriangulationOnCADoutput_results">TriangulationOnCAD::output_results</a>
        <li><a href="#TriangulationOnCADrun">TriangulationOnCAD::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Andrea Mola and Luca Heltai.</em></p>
<dl class="section note"><dt>Note</dt><dd>This program elaborates on concepts of industrial geometry, using tools that interface with the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> library (<a href="http://www.opencascade.org">http://www.opencascade.org</a>) that allow the specification of arbitrary IGES files to describe the boundaries for your geometries.</dd>
<dd>
If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.546220"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.546220.svg" alt="10.5281/zenodo.546220"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>In some of the previous tutorial programs (<a class="el" href="step_1.html">step-1</a>, <a class="el" href="step_3.html">step-3</a>, <a class="el" href="step_5.html">step-5</a>, <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_49.html">step-49</a> among others) we have learned how to use the mesh refinement methods provided in deal.II. These tutorials have shown how to employ such tools to produce a fine grid for a single simulation, as done in <a class="el" href="step_3.html">step-3</a>; or to start from a coarse grid and carry out a series of simulations on adaptively refined grids, as is the case of <a class="el" href="step_6.html">step-6</a>. Regardless of which approach is taken, the mesh refinement requires a suitable geometrical description of the computational domain boundary in order to place, at each refinement, the new mesh nodes onto the boundary surface. For instance, <a class="el" href="step_5.html">step-5</a> shows how creating a circular grid automatically attaches a circular manifold object to the computational domain, so that the faces lying on the boundary are refined onto the circle. <a class="el" href="step_53.html">step-53</a> shows how to do this with a <a class="el" href="classManifold.html">Manifold</a> defined by experimentally obtained data. But, at least as far as elementary boundary shapes are concerned, deal.II really only provides circles, spheres, boxes and other elementary combinations. In this tutorial, we will show how to use a set of classes developed to import arbitrary CAD geometries, assign them to the desired boundary of the computational domain, and refine a computational grid on such complex shapes.</p>
<p><a class="anchor" id="CADsurfaces"></a></p><h3>CAD surfaces </h3>
<p>In the most common industrial practice, the geometrical models of arbitrarily shaped objects are realized by means of Computer Aided Design (CAD) tools. The use of CAD modelers has spread in the last decades, as they allow for the generation of a full virtual model of each designed object, which through a computer can be visualized, inspected, and analyzed in its finest details well before it is physically crafted. From a mathematical perspective, the engine lying under the hood of CAD modelers is represented by analytical geometry, and in particular by parametric curves and surfaces such as B-splines and NURBS that are rich enough that they can represent most surfaces of practical interest. Once a virtual model is ready, all the geometrical features of the desired object are stored in files which materially contain the coefficients of the parametric surfaces and curves composing the object. Depending on the specific CAD tool used to define the geometrical model, there are of course several different file formats in which the information of a CAD model can be organized. To provide a common ground to exchange data across CAD tools, the U.S. National Bureau of Standards published in 1980 the Initial Graphics Exchange Representation (IGES) neutral file format, which is used in this example.</p>
<p><a class="anchor" id="TheCADboundaryprojectorclasses"></a></p><h3>The CAD boundary projector classes </h3>
<p>To import and interrogate CAD models, the deal.II library implements a series of wrapper functions for the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> open source library for CAD modeling. These functions allow to import IGES files into <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> native objects, and wrap them inside a series of <a class="el" href="classManifold.html">Manifold</a> classes.</p>
<p>Once imported from an IGES file, the model is stored in a <code>TopoDS_Shape</code>, which is the generic topological entity defined in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> framework. From a <code>TopoDS_Shape</code>, it is then possible to access all the sub-shapes (such as vertices, edges and faces) composing it, along with their geometrical description. In the deal.II framework, the topological entities composing a shape are used to create a corresponding <a class="el" href="classManifold.html">Manifold</a> representation. In <a class="el" href="step_6.html">step-6</a> we saw how to use <a class="el" href="namespaceGridGenerator.html#ab2dc2f16fc52cf1e51b9afdc4264ac70">GridGenerator::hyper_sphere()</a> to create a hyper sphere, which automatically attaches a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to all boundary faces. This guarantees that boundary faces stay on a sphere or circle during mesh refinement. The functions of the CAD modeling interface have been designed to retain the same structure, allowing the user to build a projector object using the imported CAD shapes, maintaining the same procedure we used in other tutorial programs, i.e., assigning such projector object to cells, faces or edges of a coarse mesh. At each refinement cycle, the new mesh nodes will be then automatically generated by projecting a midpoint of an existing object onto the specified geometry.</p>
<p>Differently from a spherical or circular boundary, a boundary with a complex geometry poses problems as to where it is best to place the new nodes created upon refinement on the prescribed shape. <a class="el" href="classPolarManifold.html">PolarManifold</a>, for example, transforms the surrounding points to polar coordinates, calculates the average in that coordinate system (for each coordinate individually) and finally transforms the point back to Cartesian coordinates.</p>
<p>In the case of an arbitrary and complex shape though, an appropriate choice for the placement of a new node cannot be identified that easily. The <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> wrappers in deal.II provide several projector classes that employ different projection strategies. A first projector, implemented in the <a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold</a> class, is to be used only for edge refinement. It is built assigning it a topological shape of dimension one, either a <code>TopoDS_Edge</code> or a <code>TopoDS_Wire</code> (which is a compound shape, made of several connected <code>TopoDS_Edge</code>s) and refines a mesh edge finding the new vertex as the point splitting in two even parts the curvilinear length of the CAD curve portion that lies between the vertices of the original edge.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.CurveSplit.png" width="500"/>
</div>
<p>A different projection strategy has been implemented in the OpenCASCADE::NormalProjectionBoundary class. The <code>TopoDS_Shape</code> assigned at construction time can be arbitrary (a collection of shapes, faces, edges or a single face or edge will all work). The new cell nodes are first computed by averaging the surrounding points in the same way as <a class="el" href="classFlatManifold.html">FlatManifold</a> does. In a second step, all the new nodes will be projected onto the <code>TopoDS_Shape</code> along the direction normal to the shape. If no normal projection is available, the point which is closest to the shape&mdash;typically lying on the shape boundary&mdash;is selected. If the shape is composed of several sub-shapes, the projection is carried out onto every single sub-shape, and the closest projection point is selected.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjectionEdge.png" width="500"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjection.png" width="500"/>
</div>
<p>As we are about to experience, for some shapes, setting the projection direction as that normal to the CAD surface will not lead to surface mesh elements of suitable quality. This is because the direction normal to the CAD surface has in principle nothing to do with the direction along which the mesh needs the new nodes to be located. The OpenCASCADE::DirectionalProjectionBoundary class, in this case, can help. This class is constructed assigning a <code>TopoDS_Shape</code> (containing at least a face) and a direction along which all the projections will be carried out. New points will be computed by first averaging the surrounding points (as in the <a class="el" href="classFlatManifold.html">FlatManifold</a> case), and then taking the closest intersection between the topological shape and the line passing through the resulting point, along the direction used at construction time. In this way, the user will have a higher control on the projection direction to be enforced to ensure good mesh quality.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.DirectionalProjection.png" width="500"/>
</div>
<p>Of course the latter approach is effective only when the orientation of the surface is rather uniform, so that a single projection direction can be identified. In cases in which the surface direction is approaching the projection direction, it is even possible that the directional projection is not found. To overcome these problems, the OpenCASCADE::NormalToMeshProjectionBoundary class implements a third projection algorithm. The OpenCASCADE::NormalToMeshProjectionBoundary class is built assigning a <code>TopoDS_Shape</code> (containing at least one face) to the constructor, and works exactly like a OpenCASCADE::DirectionalProjection. But, as the name of the class suggests, OpenCASCADE::NormalToMeshProjectionBoundary tries to come up with a suitable estimate of the direction normal to the mesh elements to be refined, and uses it for the projection of the new nodes onto the CAD surface. If we consider a mesh edge in a 2D space, the direction of its axis is a direction along which to split it in order to give rise to two new cells of the same length. We here extended this concept in 3D, and project all new nodes in a direction that approximates the cell normal.</p>
<p>In the next figure, which is inspired by the geometry considered in this tutorial, we make an attempt to compare the behavior of the three projectors considered. As can be seen on the left, given the original cell (in blue), the new point found with the normal projection is in a position which does not allow for the generation of evenly spaced new elements (in red). The situation will get worse in further refinement steps. Since the geometry we considered is somehow perpendicular to the horizontal direction, the directional projection (central image) defined with horizontal direction as the projection direction, does a rather good job in getting the new mesh point. Yet, since the surface is almost horizontal at the bottom of the picture, we can expect problems in those regions when further refinement steps are carried out. Finally, the picture on the right shows that a node located on the cell axis will result in two new cells having the same length. Of course the situation in 3D gets a little more complicated than that described in this simple 2D case. Nevertheless, the results of this test confirm that the normal to the mesh direction is the best approach among the three tested, when arbitrarily shaped surfaces are considered, and unless you have a geometry for which a more specific approach is known to be appropriate.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.ProjectionComparisons.png" width="700"/>
</div>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase </h3>
<p>In this program, we will consider creating a surface mesh for a real geometry describing the bow of a ship (this geometry is frequently used in CAD and mesh generation comparisons and is freely available). The surface mesh we get from this could then be used to solve a boundary element equation to simulate the flow of water around the ship (in a way similar to <a class="el" href="step_34.html">step-34</a>) but we will not try to do this here. To already give you an idea of the geometry we consider, here is a picture:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.bare.png" width="500"/>
</div>
<p>In the program, we read both the geometry and a coarse mesh from files, and then employ several of the options discussed above to place new vertices for a sequence of mesh refinement steps.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with including a bunch of files that we will use in the various parts of the program. Most of them have been discussed in previous tutorials already:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>These are the headers of the opencascade support classes and functions. Notice that these will contain sensible data only if you compiled your deal.II library with support for <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a>, i.e., specifying <code>-DDEAL_II_WITH_OPENCASCADE=ON</code> and <code>-DOPENCASCADE_DIR=/path/to/your/opencascade/installation</code> when calling <code>cmake</code> during deal.II configuration.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, a few C++ standard header files</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>We isolate the rest of the program in its own namespace</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="TheTriangulationOnCADclass"></a> </p><h3>The TriangulationOnCAD class</h3>
<p>This is the main class. All it really does is store names for input and output files, and a triangulation. It then provides a function that generates such a triangulation from a coarse mesh, using one of the strategies discussed in the introduction and listed in the enumeration type at the top of the class.</p>
<p>The member functions of this class are similar to what you can find in most of the other tutorial programs in the setup stage of the grid for the simulations.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TriangulationOnCAD</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> ProjectionType</div><div class="line">  {</div><div class="line">    NormalProjection       = 0,</div><div class="line">    DirectionalProjection  = 1,</div><div class="line">    NormalToMeshProjection = 2</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD(</div><div class="line">    <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a> tria;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string initial_mesh_filename;</div><div class="line">  <span class="keyword">const</span> std::string cad_file_name;</div><div class="line">  <span class="keyword">const</span> std::string output_filename;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ProjectionType surface_projection_kind;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADTriangulationOnCAD"></a> </p><h4>TriangulationOnCAD::TriangulationOnCAD</h4>
<p>The constructor of the TriangulationOnCAD class is very simple. The input arguments are strings for the input and output file names, and the enumeration type that determines which kind of surface projector is used in the mesh refinement cycles (see below for details).</p>
<div class="fragment"><div class="line">TriangulationOnCAD::TriangulationOnCAD(</div><div class="line">  <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">  <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">  <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">  <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">  : initial_mesh_filename(initial_mesh_filename)</div><div class="line">  , cad_file_name(cad_file_name)</div><div class="line">  , output_filename(output_filename)</div><div class="line">  , surface_projection_kind(surface_projection_kind)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADread_domain"></a> </p><h4>TriangulationOnCAD::read_domain</h4>
<p>The following function represents the core of this program. In this function we import the CAD shape upon which we want to generate and refine our triangulation. We assume that the CAD surface is contained in the <code>cad_file_name</code> file (we provide an example IGES file in the input directory called "input/DTMB-5415_bulbous_bow.iges" that represents the bulbous bow of a ship). The presence of several convex and concave high curvature regions makes the geometry we provided a particularly meaningful example.</p>
<p>After importing the hull bow surface, we extract some of the curves and surfaces composing it, and use them to generate a set of projectors. Such projectors define the rules the <a class="el" href="classTriangulation.html">Triangulation</a> has to follow to position each new node during cell refinement.</p>
<p>To initialize the <a class="el" href="classTriangulation.html">Triangulation</a>, as done in previous tutorial programs, we import a pre-existing grid saved in VTK format. We assume here that the user has generated a coarse mesh externally, which matches the IGES geometry. At the moment of writing this tutorial, the deal.II library does not automatically support generation of such meshes, but there are several tools which can provide you with reasonable initial meshes starting from CAD files. In our example, the imported mesh is composed of a single quadrilateral cell whose vertices have been placed on the CAD shape.</p>
<p>After importing both the IGES geometry and the initial mesh, we assign the projectors previously discussed to each of the edges and cells which will have to be refined on the CAD surface.</p>
<p>In this tutorial, we will test the three different CAD surface projectors described in the introduction, and will analyze the results obtained with each of them. As mentioned, each of these projection strategies has been implemented in a different class, and objects of these types can be assigned to a triangulation using the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> method.</p>
<p>The following function then first imports the given CAD file. The function arguments are a string containing the desired file name, and a scale factor. In this example, the scale factor is set to 1e-3, as the original geometry is written in millimeters (which is the typical unit of measure for most IGES files), while we prefer to work in meters. The output of the function is an object of <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> generic topological shape class, namely a <code>TopoDS_Shape</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">{</div><div class="line">  TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div></div><!-- fragment --><p>Each CAD geometrical object is defined along with a tolerance, which indicates possible inaccuracy of its placement. For instance, the tolerance <code>tol</code> of a vertex indicates that it can be located in any point contained in a sphere centered in the nominal position and having radius <code>tol</code>. While projecting a point onto a surface (which will in turn have its tolerance) we must keep in mind that the precision of the projection will be limited by the tolerance with which the surface is built.</p>
<p>The following method extracts the tolerance of the given shape and makes it a bit bigger to stay our of trouble:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) * 5;</div></div><!-- fragment --><p>We now want to extract a set of composite sub-shapes from the generic shape. In particular, each face of the CAD file is composed of a trimming curve of type <code>TopoDS_Wire</code>, which is the collection of <code>TopoDS_Edges</code> that compose the boundary of a surface, and a NURBS description of the surface itself. We will use a line projector to associate the boundary of our <a class="el" href="classTriangulation.html">Triangulation</a> to the wire delimiting the surface. To extract all compound sub-shapes, like wires, shells, or solids, we resort to a method of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace. The input of <a class="el" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a> is a shape and a set of empty std::vectors of subshapes, which will be filled with all compound shapes found in the given topological shape:</p>
<div class="fragment"><div class="line">std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line"><a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(</div><div class="line">  bow_surface, compounds, compsolids, solids, shells, wires);</div></div><!-- fragment --><p>The next few steps are more familiar, and allow us to import an existing mesh from an external VTK file, and convert it to a deal triangulation.</p>
<div class="fragment"><div class="line">std::ifstream in;</div><div class="line"></div><div class="line">in.open(initial_mesh_filename);</div><div class="line"></div><div class="line"><a class="code" href="classGridIn.html">GridIn&lt;2, 3&gt;</a> gi;</div><div class="line">gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">gi.<a class="code" href="group__simplex.html#ga058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div></div><!-- fragment --><p>We output this initial mesh saving it as the refinement step 0.</p>
<div class="fragment"><div class="line">output_results(0);</div></div><!-- fragment --><p>The mesh imported has a single, two-dimensional cell located in three-dimensional space. We now want to ensure that it is refined according to the CAD geometry imported above. This this end, we get an iterator to that cell and assign to it the manifold_id 1 (see <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">this glossary entry</a>). We also get an iterator to its four faces, and assign each of them the manifold_id 2:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2, 3&gt;::active_cell_iterator</a> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  face-&gt;set_manifold_id(2);</div></div><!-- fragment --><p>Once both the CAD geometry and the initial mesh have been imported and digested, we use the CAD surfaces and curves to define the projectors and assign them to the manifold ids just specified.</p>
<p>A first projector is defined using the single wire contained in our CAD file. The ArclengthProjectionLineManifold will make sure that every mesh edge located on the wire is refined with a point that lies on the wire and splits it into two equal arcs lying between the edge vertices. We first check that the wires vector contains at least one element and then create a <a class="el" href="classManifold.html">Manifold</a> object for it.</p>
<p>Once the projector is created, we then assign it to all the parts of the triangulation with manifold_id = 2:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">  wires.size() &gt; 0,</div><div class="line">  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">    <span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line"><a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2, 3&gt;</a> line_projector(</div><div class="line">  wires[0], tolerance);</div><div class="line"></div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(2, line_projector);</div></div><!-- fragment --><p>The surface projector is created according to what is specified with the <code>surface_projection_kind</code> option of the constructor. In particular, if the surface_projection_kind value equals <code>NormalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold</a>. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along its normal direction. The NormalProjectionManifold constructor only needs a shape and a tolerance, and we then assign it to the triangulation for use with all parts that manifold having id 1:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> NormalProjection:</div><div class="line">      {</div><div class="line">        <a class="code" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold&lt;2, 3&gt;</a> normal_projector(</div><div class="line">          bow_surface, tolerance);</div><div class="line">        tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_projector);</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div></div><!-- fragment --><p><code>If</code> surface_projection_kind value is <code>DirectionalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold</a> class. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is specified to the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold</a> constructor. In this case, the projection is done along the y-axis.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">  {</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold&lt;2, 3&gt;</a></div><div class="line">      directional_projector(bow_surface,</div><div class="line">                            <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0, 1.0, 0.0),</div><div class="line">                            tolerance);</div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, directional_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>As a third option, if <code>surface_projection_kind</code> value is <code>NormalToMeshProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>. The new mesh points will again initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is an estimate of the mesh normal direction. The <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> constructor only requires a shape (containing at least a face) and a tolerance.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">  {</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;2, 3&gt;</a></div><div class="line">      normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_to_mesh_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>Finally, we use good software cleanliness by ensuring that this really covers all possible options of the <code>case</code> statement. If we get any other value, we simply abort the program:</p>
<div class="fragment"><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrefine_mesh"></a> </p><h4>TriangulationOnCAD::refine_mesh</h4>
<p>This function globally refines the mesh. In other tutorials, it would typically also distribute degrees of freedom, and resize matrices and vectors. These tasks are not carried out here, since we are not running any simulation on the <a class="el" href="classTriangulation.html">Triangulation</a> produced.</p>
<p>While the function looks innocent, this is where most of the work we are interested in for this tutorial program actually happens. In particular, when refining the quads and lines that define the surface of the ship's hull, the <a class="el" href="classTriangulation.html">Triangulation</a> class will ask the various objects we have assigned to handle individual manifold ids for where the new vertices should lie.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">{</div><div class="line">  tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADoutput_results"></a> </p><h4>TriangulationOnCAD::output_results</h4>
<p>Outputting the results of our computations is a rather mechanical task. All the components of this function have been discussed before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (output_filename + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  std::ofstream logfile(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrun"></a> </p><h4>TriangulationOnCAD::run</h4>
<p>This is the main function. It should be self explanatory in its briefness:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TriangulationOnCAD::run</a>()</div><div class="line">  {</div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_mesh();</div><div class="line">        output_results(cycle + 1);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step54</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is the main function of this program. It is in its basic structure like all previous tutorial programs, but runs the main class through the three possibilities of new vertex placement:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">      <span class="keyword">const</span> std::string cad_file_name    = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::string        out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                          cad_file_name,</div><div class="line">                                          out_mesh_filename,</div><div class="line">                                          TriangulationOnCAD::NormalProjection);</div><div class="line">      tria_on_cad_norm.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_dir(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::DirectionalProjection);</div><div class="line">      tria_on_cad_dir.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm_to_mesh(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">      tria_on_cad_norm_to_mesh.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program execution produces a series of mesh files <code>3d_mesh_*.vtk</code> that we can visualize with any of the usual visualization programs that can read the VTK file format.</p>
<p>The following table illustrates the results obtained employing the normal projection strategy. The first two rows of the table show side views of the grids obtained for progressive levels of refinement, overlain on a very fine rendering of the exact geometry. The dark and light red areas simply indicate whether the current mesh or the fine geometry is closer to the observer; the distinction does not carry any particularly deep meaning. The last row of pictures depict front views (mirrored to both sides of the geometry) of the same grids shown in the second row.</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>As can be seen in the pictures&mdash;and as we anticipated&mdash;the normal refinement strategy is unable to produce nicely shaped elements when applied to surfaces with significant curvature changes. This is particularly apparent at the bulb of the hull where all new points have been placed in the upper part of the bulb and the lower part remains completely unresolved.</p>
<p>The following table, which is arranged as the previous one, illustrates the results obtained adopting the directional projection approach, in which the projection direction selected was the y-axis (which is indicated with a small yellow arrow at the bottom left of each image).</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The images confirm that the quality of the mesh obtained with a directional projection is sensibly higher than that obtained projecting along the surface normal. Yet, a number of elements elongated in the y-direction are observed around the bottom of the bulb, where the surface is almost parallel to the direction chosen for the projection.</p>
<p>The final test shows results using instead the projection normal to the faces:</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The pictures confirm that the normal to mesh projection approach leads to grids that remain evenly spaced throughtout the refinement steps. At the same time, these meshes represent rather well the original geometry even in the bottom region of the bulb, which is not well recovered employing the directional projector or the normal projector.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *  Authors: Andrea Mola, Luca Heltai, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>TriangulationOnCAD</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> ProjectionType</div><div class="line">    {</div><div class="line">      NormalProjection       = 0,</div><div class="line">      DirectionalProjection  = 1,</div><div class="line">      NormalToMeshProjection = 2</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    TriangulationOnCAD(</div><div class="line">      <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">      <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">      <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">      <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a> tria;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string initial_mesh_filename;</div><div class="line">    <span class="keyword">const</span> std::string cad_file_name;</div><div class="line">    <span class="keyword">const</span> std::string output_filename;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD::TriangulationOnCAD(</div><div class="line">    <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">    : initial_mesh_filename(initial_mesh_filename)</div><div class="line">    , cad_file_name(cad_file_name)</div><div class="line">    , output_filename(output_filename)</div><div class="line">    , surface_projection_kind(surface_projection_kind)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">  {</div><div class="line">    TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) * 5;</div><div class="line"></div><div class="line">    std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">    std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">    std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">    std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">    std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(</div><div class="line">      bow_surface, compounds, compsolids, solids, shells, wires);</div><div class="line"></div><div class="line">    std::ifstream in;</div><div class="line"></div><div class="line">    in.open(initial_mesh_filename);</div><div class="line"></div><div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;2, 3&gt;</a> gi;</div><div class="line">    gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">    gi.<a class="code" href="group__simplex.html#ga058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div><div class="line"></div><div class="line">    output_results(0);</div><div class="line"></div><div class="line">    <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2, 3&gt;::active_cell_iterator</a> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      face-&gt;set_manifold_id(2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">      wires.size() &gt; 0,</div><div class="line">      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">        <span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2, 3&gt;</a> line_projector(</div><div class="line">      wires[0], tolerance);</div><div class="line"></div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(2, line_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> NormalProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold&lt;2, 3&gt;</a> normal_projector(</div><div class="line">              bow_surface, tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold&lt;2, 3&gt;</a></div><div class="line">              directional_projector(bow_surface,</div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0, 1.0, 0.0),</div><div class="line">                                    tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, directional_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;2, 3&gt;</a></div><div class="line">              normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_to_mesh_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">  {</div><div class="line">    tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      (output_filename + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    std::ofstream logfile(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TriangulationOnCAD::run</a>()</div><div class="line">  {</div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_mesh();</div><div class="line">        output_results(cycle + 1);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step54</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">      <span class="keyword">const</span> std::string cad_file_name    = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::string        out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                          cad_file_name,</div><div class="line">                                          out_mesh_filename,</div><div class="line">                                          TriangulationOnCAD::NormalProjection);</div><div class="line">      tria_on_cad_norm.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_dir(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::DirectionalProjection);</div><div class="line">      tria_on_cad_dir.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm_to_mesh(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">      tria_on_cad_norm_to_mesh.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_53.html">step-53</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#CADsurfaces"> CAD surfaces </a><a href="#CADsurfaces"> CAD
 surfaces </a>
 <li><a href="#TheCADboundaryprojectorclasses"> The CAD boundary projector
 classes </a><a href="#TheCADboundaryprojectorclasses"> The CAD boundary
 projector classes </a>
 <li><a href="#Thetestcase"> The testcase </a><a href="#Thetestcase"> The
 testcase </a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#TheTriangulationOnCADclass">The TriangulationOnCAD
 class</a><a href="#TheTriangulationOnCADclass">The TriangulationOnCAD
 class</a>
 <ul>
 <li><a
 href="#TriangulationOnCADTriangulationOnCAD">TriangulationOnCAD::TriangulationOnCAD</a><a
 href="#TriangulationOnCADTriangulationOnCAD">TriangulationOnCAD::TriangulationOnCAD</a>
 <li><a
 href="#TriangulationOnCADread_domain">TriangulationOnCAD::read_domain</a><a
 href="#TriangulationOnCADread_domain">TriangulationOnCAD::read_domain</a>
 <li><a
 href="#TriangulationOnCADrefine_mesh">TriangulationOnCAD::refine_mesh</a><a
 href="#TriangulationOnCADrefine_mesh">TriangulationOnCAD::refine_mesh</a>
 <li><a
 href="#TriangulationOnCADoutput_results">TriangulationOnCAD::output_results</a><a
 href="#TriangulationOnCADoutput_results">TriangulationOnCAD::output_results</a>
 <li><a href="#TriangulationOnCADrun">TriangulationOnCAD::run</a><a
 href="#TriangulationOnCADrun">TriangulationOnCAD::run</a>
 </ul>
 <li><a href="#Themainfunction">The main() function</a><a
 href="#Themainfunction">The main() function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Andrea Mola and Luca Heltai.</em> </p><dl class="section note"><dt>Note</dt><dd>This program elaborates on concepts of industrial geometry, using toolsthat interface with the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> library (<a href="http://www.opencascade.org">http://www.opencascade.org</a>) thatallow the specification of arbitrary IGES files to describe the boundaries foryour geometries. </dd>
<dd>
If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.546220"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.546220.svg" alt="10.5281/zenodo.546220"/></a>  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a><h1>Introduction</h1>
</dd></dl>
<p>In some of the previous tutorial programs ( <a class="el" href="step_1.html">step-1</a> , <a class="el" href="step_3.html">step-3</a> , <a class="el" href="step_5.html">step-5</a> , <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_49.html">step-49</a> among others) we have learned how to use the mesh refinement methodsprovided in deal.II. These tutorials have shown how to employ such tools toproduce a fine grid for a single simulation, as done in <a class="el" href="step_3.html">step-3</a> ; or to start froma coarse grid and carry out a series of simulations on adaptively refined grids,as is the case of <a class="el" href="step_6.html">step-6</a> . Regardless of which approach is taken, the meshrefinement requires a suitable geometrical description of the computationaldomain boundary in order to place, at each refinement, the new mesh nodes ontothe boundary surface. For instance, <a class="el" href="step_5.html">step-5</a> shows how creating a circular gridautomatically attaches a circular manifold object to the computational domain,so that the faces lying on the boundary are refined onto the circle. <a class="el" href="step_53.html">step-53</a> shows how to do this with a <a class="el" href="classManifold.html">Manifold</a> defined by experimentally obtained data.But, at least as far as elementary boundary shapes are concerned, deal.II reallyonly provides circles, spheres, boxes and other elementary combinations. In thistutorial, we will show how to use a set of classes developed to import arbitraryCAD geometries, assign them to the desired boundary of the computational domain,and refine a computational grid on such complex shapes.</p>
<p><a class="anchor" id="CADsurfaces"></a></p><h3>CAD surfaces </h3>
<p>In the most common industrial practice, the geometrical models of arbitrarilyshaped objects are realized by means of Computer Aided Design (CAD) tools. Theuse of CAD modelers has spread in the last decades, as they allow for thegeneration of a full virtual model of each designed object, which through acomputer can be visualized, inspected, and analyzed in its finest details wellbefore it is physically crafted. From a mathematical perspective, the enginelying under the hood of CAD modelers is represented by analytical geometry,and in particular by parametric curves and surfaces such as B-splines andNURBS that are rich enough that they can represent most surfaces of practicalinterest. Once a virtual model is ready, all the geometrical features of thedesired object are stored in files which materially contain the coefficientsof the parametric surfaces and curves composing the object. Depending on thespecific CAD tool used to define the geometrical model, there are of courseseveral different file formats in which the information of a CAD model can beorganized. To provide a common ground to exchange data across CAD tools, theU.S. National Bureau of Standards published in 1980 the Initial GraphicsExchange Representation (IGES) neutral file format, which is used in thisexample. <a class="anchor" id="TheCADboundaryprojectorclasses"></a></p><h3>The CAD boundary projector classes </h3>
<p>To import and interrogate CAD models, the deal.II library implements a series ofwrapper functions for the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> open source library for CAD modeling.These functions allow to import IGES files into <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> native objects, andwrap them inside a series of <a class="el" href="classManifold.html">Manifold</a> classes. Once imported from an IGES file, the model is stored in a <code>TopoDS_Shape</code> , which is the generic topological entity defined inthe <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> framework. From a <code>TopoDS_Shape</code> , it is then possibleto access all the sub-shapes (such as vertices, edges and faces) composing it,along with their geometrical description. In the deal.II framework, thetopological entities composing a shape are used to create a correspondingManifold representation. In <a class="el" href="step_6.html">step-6</a> we saw how to use <a class="el" href="namespaceGridGenerator.html#ab2dc2f16fc52cf1e51b9afdc4264ac70">GridGenerator::hyper_sphere()</a> to create a hyper sphere, which automatically attaches a SphericalManifoldto all boundary faces. This guarantees that boundary faces stay on asphere or circle during mesh refinement. The functions of the CAD modeling interfacehave been designed to retain the same structure, allowing the user to build aprojector object using the imported CAD shapes, maintaining the same procedurewe used in other tutorial programs, i.e., assigning such projector object tocells, faces or edges of a coarse mesh. At each refinement cycle, the new meshnodes will be then automatically generated by projecting a midpoint of anexisting object onto the specified geometry. Differently from a spherical or circular boundary, a boundary with a complexgeometry poses problems as to where it is best to place the new nodes createdupon refinement on the prescribed shape. <a class="el" href="classPolarManifold.html">PolarManifold</a>, for example, transformsthe surrounding points to polar coordinates, calculates the average in thatcoordinate system (for each coordinate individually) and finally transformsthe point back to Cartesian coordinates. In the case of an arbitrary and complex shape though, an appropriate choice forthe placement of a new node cannot be identified that easily. The OpenCASCADEwrappers in deal.II provide several projector classes that employ differentprojection strategies. A first projector, implemented in the <a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold</a> class, is to be used only foredge refinement. It is built assigning it a topological shape of dimensionone, either a <code>TopoDS_Edge</code> or a <code>TopoDS_Wire</code> (which isa compound shape, made of several connected <code>TopoDS_Edge</code> s) andrefines a mesh edge finding the new vertex as the point splitting in two evenparts the curvilinear length of the CAD curve portion that lies between thevertices of the original edge. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.CurveSplit.png" width="500"/>
</div>
<p>A different projection strategy has been implemented in the OpenCASCADE::NormalProjectionBoundary class. The <code>TopoDS_Shape</code> assigned at construction time can be arbitrary (a collection of shapes, faces,edges or a single face or edge will all work). The new cell nodes are firstcomputed by averaging the surrounding points in the same way as FlatManifolddoes. In a second step, all the new nodes will be projected onto the <code>TopoDS_Shape</code> along the direction normal to the shape. If nonormal projection is available, the point which is closest to theshape&mdash;typically lying on the shape boundary&mdash;is selected. If the shape iscomposed of several sub-shapes, the projection is carried out onto everysingle sub-shape, and the closest projection point is selected. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjectionEdge.png" width="500"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjection.png" width="500"/>
</div>
<p> As we are about to experience, for some shapes, setting the projectiondirection as that normal to the CAD surface will not lead to surface meshelements of suitable quality. This is because the direction normal to the CADsurface has in principle nothing to do with the direction along which the meshneeds the new nodes to be located. The OpenCASCADE::DirectionalProjectionBoundary class, in this case, can help. Thisclass is constructed assigning a <code>TopoDS_Shape</code> (containing atleast a face) and a direction along which all the projections will be carriedout. New points will be computed by first averaging the surrounding points (asin the <a class="el" href="classFlatManifold.html">FlatManifold</a> case), and then taking the closest intersection betweenthe topological shape and the line passing through the resulting point, alongthe direction used at construction time. In this way, the user will have ahigher control on the projection direction to be enforced to ensure good meshquality. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.DirectionalProjection.png" width="500"/>
</div>
<p>Of course the latter approach is effective only when the orientation of thesurface is rather uniform, so that a single projection direction can beidentified. In cases in which the surface direction is approaching theprojection direction, it is even possible that the directional projection isnot found. To overcome these problems, the OpenCASCADE::NormalToMeshProjectionBoundary class implements a thirdprojection algorithm. The OpenCASCADE::NormalToMeshProjectionBoundary class isbuilt assigning a <code>TopoDS_Shape</code> (containing at least one face) tothe constructor, and works exactly like a OpenCASCADE::DirectionalProjection. But, as the name of the class suggests, OpenCASCADE::NormalToMeshProjectionBoundary tries to come up with a suitableestimate of the direction normal to the mesh elements to be refined, and usesit for the projection of the new nodes onto the CAD surface. If we consider amesh edge in a 2D space, the direction of its axis is a direction along whichto split it in order to give rise to two new cells of the same length. We hereextended this concept in 3D, and project all new nodes in a direction thatapproximates the cell normal. In the next figure, which is inspired by the geometry considered in thistutorial, we make an attempt to compare the behavior of the three projectorsconsidered. As can be seen on the left, given the original cell (in blue), thenew point found with the normal projection is in a position which does notallow for the generation of evenly spaced new elements (in red). The situationwill get worse in further refinement steps. Since the geometry we consideredis somehow perpendicular to the horizontal direction, the directionalprojection (central image) defined with horizontal direction as the projectiondirection, does a rather good job in getting the new mesh point. Yet, sincethe surface is almost horizontal at the bottom of the picture, we can expectproblems in those regions when further refinement steps are carriedout. Finally, the picture on the right shows that a node located on the cellaxis will result in two new cells having the same length. Of course thesituation in 3D gets a little more complicated than that described in thissimple 2D case. Nevertheless, the results of this test confirm that the normalto the mesh direction is the best approach among the three tested, whenarbitrarily shaped surfaces are considered, and unless you have a geometry forwhich a more specific approach is known to be appropriate.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.ProjectionComparisons.png" width="700"/>
</div>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase </h3>
<p>In this program, we will consider creating a surface mesh for a real geometrydescribing the bow of a ship (this geometry is frequently used in CAD and meshgeneration comparisons and is freely available). The surface mesh we get fromthis could then be used to solve a boundary element equation to simulate theflow of water around the ship (in a way similar to <a class="el" href="step_34.html">step-34</a> ) but we will nottry to do this here. To already give you an idea of the geometry we consider,here is a picture: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.bare.png" width="500"/>
</div>
<p> In the program, we read both the geometry and a coarse mesh from files, andthen employ several of the options discussed above to place new vertices for asequence of mesh refinement steps.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with including a bunch of files that we will use in the various parts of the program. Most of them have been discussed in previous tutorials already:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>These are the headers of the opencascade support classes and functions. Notice that these will contain sensible data only if you compiled your deal.II library with support for <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a>, i.e., specifying <code>-DDEAL_II_WITH_OPENCASCADE=ON</code> and <code>-DOPENCASCADE_DIR=/path/to/your/opencascade/installation</code> when calling <code>cmake</code> during deal.II configuration.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, a few C++ standard header files</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>We isolate the rest of the program in its own namespace</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="TheTriangulationOnCADclass"></a> </p><h3>The TriangulationOnCAD class</h3>
<p>This is the main class. All it really does is store names for input and output files, and a triangulation. It then provides a function that generates such a triangulation from a coarse mesh, using one of the strategies discussed in the introduction and listed in the enumeration type at the top of the class. The member functions of this class are similar to what you can find in most of the other tutorial programs in the setup stage of the grid for the simulations.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TriangulationOnCAD</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> ProjectionType</div><div class="line">  {</div><div class="line">    NormalProjection       = 0,</div><div class="line">    DirectionalProjection  = 1,</div><div class="line">    NormalToMeshProjection = 2</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD(</div><div class="line">    <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a> tria;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string initial_mesh_filename;</div><div class="line">  <span class="keyword">const</span> std::string cad_file_name;</div><div class="line">  <span class="keyword">const</span> std::string output_filename;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ProjectionType surface_projection_kind;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADTriangulationOnCAD"></a> </p><h4>TriangulationOnCAD::TriangulationOnCAD</h4>
<p>The constructor of the TriangulationOnCAD class is very simple. The input arguments are strings for the input and output file names, and the enumeration type that determines which kind of surface projector is used in the mesh refinement cycles (see below for details).</p>
<div class="fragment"><div class="line">TriangulationOnCAD::TriangulationOnCAD(</div><div class="line">  <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">  <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">  <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">  <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">  : initial_mesh_filename(initial_mesh_filename)</div><div class="line">  , cad_file_name(cad_file_name)</div><div class="line">  , output_filename(output_filename)</div><div class="line">  , surface_projection_kind(surface_projection_kind)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADread_domain"></a> </p><h4>TriangulationOnCAD::read_domain</h4>
<p>The following function represents the core of this program. In this function we import the CAD shape upon which we want to generate and refine our triangulation. We assume that the CAD surface is contained in the <code>cad_file_name</code> file (we provide an example IGES file in the input directory called "input/DTMB-5415_bulbous_bow.iges" that represents the bulbous bow of a ship). The presence of several convex and concave high curvature regions makes the geometry we provided a particularly meaningful example. After importing the hull bow surface, we extract some of the curves and surfaces composing it, and use them to generate a set of projectors. Such projectors define the rules the <a class="el" href="classTriangulation.html">Triangulation</a> has to follow to position each new node during cell refinement. To initialize the <a class="el" href="classTriangulation.html">Triangulation</a>, as done in previous tutorial programs, we import a pre-existing grid saved in VTK format. We assume here that the user has generated a coarse mesh externally, which matches the IGES geometry. At the moment of writing this tutorial, the deal.II library does not automatically support generation of such meshes, but there are several tools which can provide you with reasonable initial meshes starting from CAD files. In our example, the imported mesh is composed of a single quadrilateral cell whose vertices have been placed on the CAD shape. After importing both the IGES geometry and the initial mesh, we assign the projectors previously discussed to each of the edges and cells which will have to be refined on the CAD surface. In this tutorial, we will test the three different CAD surface projectors described in the introduction, and will analyze the results obtained with each of them. As mentioned, each of these projection strategies has been implemented in a different class, and objects of these types can be assigned to a triangulation using the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> method. The following function then first imports the given CAD file. The function arguments are a string containing the desired file name, and a scale factor. In this example, the scale factor is set to 1e-3, as the original geometry is written in millimeters (which is the typical unit of measure for most IGES files), while we prefer to work in meters. The output of the function is an object of <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> generic topological shape class, namely a <code>TopoDS_Shape</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">{</div><div class="line">  TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div></div><!-- fragment --><p>Each CAD geometrical object is defined along with a tolerance, which indicates possible inaccuracy of its placement. For instance, the tolerance <code>tol</code> of a vertex indicates that it can be located in any point contained in a sphere centered in the nominal position and having radius <code>tol</code>. While projecting a point onto a surface (which will in turn have its tolerance) we must keep in mind that the precision of the projection will be limited by the tolerance with which the surface is built.</p>
<p>The following method extracts the tolerance of the given shape and makes it a bit bigger to stay our of trouble:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) 5;</div></div><!-- fragment --><p>We now want to extract a set of composite sub-shapes from the generic shape. In particular, each face of the CAD file is composed of a trimming curve of type <code>TopoDS_Wire</code>, which is the collection of <code>TopoDS_Edges</code> that compose the boundary of a surface, and a NURBS description of the surface itself. We will use a line projector to associate the boundary of our <a class="el" href="classTriangulation.html">Triangulation</a> to the wire delimiting the surface. To extract all compound sub-shapes, like wires, shells, or solids, we resort to a method of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace. The input of <a class="el" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a> is a shape and a set of empty std::vectors of subshapes, which will be filled with all compound shapes found in the given topological shape:</p>
<div class="fragment"><div class="line">std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line"><a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(</div><div class="line">  bow_surface, compounds, compsolids, solids, shells, wires);</div></div><!-- fragment --><p>The next few steps are more familiar, and allow us to import an existing mesh from an external VTK file, and convert it to a deal triangulation.</p>
<div class="fragment"><div class="line">std::ifstream in;</div><div class="line"></div><div class="line">in.open(initial_mesh_filename);</div><div class="line"></div><div class="line"><a class="code" href="classGridIn.html">GridIn&lt;2, 3&gt;</a> gi;</div><div class="line">gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">gi.<a class="code" href="group__simplex.html#ga058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div></div><!-- fragment --><p>We output this initial mesh saving it as the refinement step 0.</p>
<div class="fragment"><div class="line">output_results(0);</div></div><!-- fragment --><p>The mesh imported has a single, two-dimensional cell located in three-dimensional space. We now want to ensure that it is refined according to the CAD geometry imported above. This this end, we get an iterator to that cell and assign to it the manifold_id 1 (see <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">this glossary entry</a>). We also get an iterator to its four faces, and assign each of them the manifold_id 2:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2, 3&gt;::active_cell_iterator</a> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  face-&gt;set_manifold_id(2);</div></div><!-- fragment --><p>Once both the CAD geometry and the initial mesh have been imported and digested, we use the CAD surfaces and curves to define the projectors and assign them to the manifold ids just specified.</p>
<p>A first projector is defined using the single wire contained in our CAD file. The ArclengthProjectionLineManifold will make sure that every mesh edge located on the wire is refined with a point that lies on the wire and splits it into two equal arcs lying between the edge vertices. We first check that the wires vector contains at least one element and then create a <a class="el" href="classManifold.html">Manifold</a> object for it. Once the projector is created, we then assign it to all the parts of the triangulation with manifold_id = 2:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">  wires.size() &gt; 0,</div><div class="line">  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">    <span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line"><a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2, 3&gt;</a> line_projector(</div><div class="line">  wires[0], tolerance);</div><div class="line"></div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(2, line_projector);</div></div><!-- fragment --><p>The surface projector is created according to what is specified with the <code>surface_projection_kind</code> option of the constructor. In particular, if the surface_projection_kind value equals <code>NormalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold</a>. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along its normal direction. The NormalProjectionManifold constructor only needs a shape and a tolerance, and we then assign it to the triangulation for use with all parts that manifold having id 1:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> NormalProjection:</div><div class="line">      {</div><div class="line">        <a class="code" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold&lt;2, 3&gt;</a> normal_projector(</div><div class="line">          bow_surface, tolerance);</div><div class="line">        tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_projector);</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div></div><!-- fragment --><p><code>If</code> surface_projection_kind value is <code>DirectionalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold</a> class. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is specified to the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold</a> constructor. In this case, the projection is done along the y-axis.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">  {</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold&lt;2, 3&gt;</a></div><div class="line">      directional_projector(bow_surface,</div><div class="line">                            <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0, 1.0, 0.0),</div><div class="line">                            tolerance);</div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, directional_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>As a third option, if <code>surface_projection_kind</code> value is <code>NormalToMeshProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>. The new mesh points will again initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is an estimate of the mesh normal direction. The <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> constructor only requires a shape (containing at least a face) and a tolerance.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">  {</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;2, 3&gt;</a></div><div class="line">      normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_to_mesh_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>Finally, we use good software cleanliness by ensuring that this really covers all possible options of the <code>case</code> statement. If we get any other value, we simply abort the program:</p>
<div class="fragment"><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrefine_mesh"></a> </p><h4>TriangulationOnCAD::refine_mesh</h4>
<p>This function globally refines the mesh. In other tutorials, it would typically also distribute degrees of freedom, and resize matrices and vectors. These tasks are not carried out here, since we are not running any simulation on the <a class="el" href="classTriangulation.html">Triangulation</a> produced. While the function looks innocent, this is where most of the work we are interested in for this tutorial program actually happens. In particular, when refining the quads and lines that define the surface of the ship's hull, the <a class="el" href="classTriangulation.html">Triangulation</a> class will ask the various objects we have assigned to handle individual manifold ids for where the new vertices should lie.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">{</div><div class="line">  tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADoutput_results"></a> </p><h4>TriangulationOnCAD::output_results</h4>
<p>Outputting the results of our computations is a rather mechanical task. All the components of this function have been discussed before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (output_filename + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  std::ofstream logfile(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrun"></a> </p><h4>TriangulationOnCAD::run</h4>
<p>This is the main function. It should be self explanatory in its briefness:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TriangulationOnCAD::run</a>()</div><div class="line">{</div><div class="line">  read_domain();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; n_cycles; ++cycle)</div><div class="line">    {</div><div class="line">      refine_mesh();</div><div class="line">      output_results(cycle + 1);</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step54</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is the main function of this program. It is in its basic structure like all previous tutorial programs, but runs the main class through the three possibilities of new vertex placement:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">    <span class="keyword">const</span> std::string cad_file_name    = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::string        out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span>);</div><div class="line">    TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                        cad_file_name,</div><div class="line">                                        out_mesh_filename,</div><div class="line">                                        TriangulationOnCAD::NormalProjection);</div><div class="line">    tria_on_cad_norm.run();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span>);</div><div class="line">    TriangulationOnCAD tria_on_cad_dir(</div><div class="line">      in_mesh_filename,</div><div class="line">      cad_file_name,</div><div class="line">      out_mesh_filename,</div><div class="line">      TriangulationOnCAD::DirectionalProjection);</div><div class="line">    tria_on_cad_dir.run();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span>);</div><div class="line">    TriangulationOnCAD tria_on_cad_norm_to_mesh(</div><div class="line">      in_mesh_filename,</div><div class="line">      cad_file_name,</div><div class="line">      out_mesh_filename,</div><div class="line">      TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">    tria_on_cad_norm_to_mesh.run();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program execution produces a series of mesh files <code>3d_mesh_*.vtk</code> that we can visualize with any of the usual visualization programs that can read the VTKfile format. The following table illustrates the results obtained employing the normal projection strategy. The first tworows of the table show side views of the grids obtained for progressive levelsof refinement, overlain on a very fine rendering of the exact geometry. Thedark and light red areas simply indicate whether the current mesh or the finegeometry is closer to the observer; the distinction does not carry anyparticularly deep meaning. The last rowof pictures depict front views (mirrored to both sides of the geometry) of thesame grids shown in the second row.</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>As can be seen in the pictures&mdash;and as we anticipated&mdash;the normal refinement strategy is unable to produce nicely shaped elementswhen applied to surfaces with significant curvature changes. This isparticularly apparent at the bulb of the hull where all new points have beenplaced in the upper part of the bulb and the lower part remains completelyunresolved. The following table, which is arranged as the previous one, illustratesthe results obtained adopting the directional projection approach, in which the projection direction selected was the y-axis (whichis indicated with a small yellow arrow at the bottom left of each image).</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The images confirm that the quality of the mesh obtained with a directional projection is sensibly higher than that obtained projecting along thesurface normal. Yet, a number of elements elongated in the y-direction are observed around the bottom of the bulb, where the surface is almost parallel to thedirection chosen for the projection. The final test shows results using instead the projection normal to the faces: </p><table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The pictures confirm that the normal to mesh projection approach leads to grids that remain evenly spacedthroughtout the refinement steps. At the same time, these meshes represent rather well the original geometry even in the bottom regionof the bulb, which is not well recovered employing the directional projector or the normal projector.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *  Authors: Andrea Mola, Luca Heltai, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>TriangulationOnCAD</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> ProjectionType</div><div class="line">    {</div><div class="line">      NormalProjection       = 0,</div><div class="line">      DirectionalProjection  = 1,</div><div class="line">      NormalToMeshProjection = 2</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    TriangulationOnCAD(</div><div class="line">      <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">      <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">      <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">      <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a> tria;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string initial_mesh_filename;</div><div class="line">    <span class="keyword">const</span> std::string cad_file_name;</div><div class="line">    <span class="keyword">const</span> std::string output_filename;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD::TriangulationOnCAD(</div><div class="line">    <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">    : initial_mesh_filename(initial_mesh_filename)</div><div class="line">    , cad_file_name(cad_file_name)</div><div class="line">    , output_filename(output_filename)</div><div class="line">    , surface_projection_kind(surface_projection_kind)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">  {</div><div class="line">    TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) * 5;</div><div class="line"></div><div class="line">    std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">    std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">    std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">    std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">    std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(</div><div class="line">      bow_surface, compounds, compsolids, solids, shells, wires);</div><div class="line"></div><div class="line">    std::ifstream in;</div><div class="line"></div><div class="line">    in.open(initial_mesh_filename);</div><div class="line"></div><div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;2, 3&gt;</a> gi;</div><div class="line">    gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">    gi.<a class="code" href="group__simplex.html#ga058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div><div class="line"></div><div class="line">    output_results(0);</div><div class="line"></div><div class="line">    <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2, 3&gt;::active_cell_iterator</a> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      face-&gt;set_manifold_id(2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">      wires.size() &gt; 0,</div><div class="line">      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">        <span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2, 3&gt;</a> line_projector(</div><div class="line">      wires[0], tolerance);</div><div class="line"></div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(2, line_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> NormalProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold&lt;2, 3&gt;</a> normal_projector(</div><div class="line">              bow_surface, tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold&lt;2, 3&gt;</a></div><div class="line">              directional_projector(bow_surface,</div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0, 1.0, 0.0),</div><div class="line">                                    tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, directional_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;2, 3&gt;</a></div><div class="line">              normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_to_mesh_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">  {</div><div class="line">    tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      (output_filename + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    std::ofstream logfile(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TriangulationOnCAD::run</a>()</div><div class="line">  {</div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_mesh();</div><div class="line">        output_results(cycle + 1);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step54</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">      <span class="keyword">const</span> std::string cad_file_name    = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::string        out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                          cad_file_name,</div><div class="line">                                          out_mesh_filename,</div><div class="line">                                          TriangulationOnCAD::NormalProjection);</div><div class="line">      tria_on_cad_norm.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_dir(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::DirectionalProjection);</div><div class="line">      tria_on_cad_dir.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm_to_mesh(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">      tria_on_cad_norm_to_mesh.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_53.html">step-53</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#CADsurfaces"> CAD surfaces </a>
        <li><a href="#TheCADboundaryprojectorclasses"> The CAD boundary projector classes </a>
        <li><a href="#Thetestcase"> The testcase </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#TheTriangulationOnCADclass">The TriangulationOnCAD class</a>
      <ul>
        <li><a href="#TriangulationOnCADTriangulationOnCAD">TriangulationOnCAD::TriangulationOnCAD</a>
        <li><a href="#TriangulationOnCADread_domain">TriangulationOnCAD::read_domain</a>
        <li><a href="#TriangulationOnCADrefine_mesh">TriangulationOnCAD::refine_mesh</a>
        <li><a href="#TriangulationOnCADoutput_results">TriangulationOnCAD::output_results</a>
        <li><a href="#TriangulationOnCADrun">TriangulationOnCAD::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-54/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Andrea Mola and Luca Heltai.</em></p>
<dl class="section note"><dt>Note</dt><dd>这个程序阐述了工业几何的概念，使用与OpenCASCADE库（http://www.opencascade.org）接口的工具，允许指定任意的IGES文件来描述你的几何形状的边界。</dd>
<dd>
If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.546220"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.546220.svg" alt="10.5281/zenodo.546220"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>在之前的一些教程中（第1步、第3步、第5步、第6步和第49步等），我们已经学会了如何使用deal.II中提供的网格细化方法。这些教程展示了如何利用这些工具为一次模拟产生一个精细的网格，如步骤3；或者从一个粗大的网格开始，在自适应细化的网格上进行一系列模拟，如步骤6的情况。无论采取哪种方法，网格细化都需要对计算域边界进行适当的几何描述，以便在每次细化时将新的网格节点放到边界面上。例如，第5步显示了如何创建一个圆形网格，将一个圆形流形对象自动附加到计算域上，从而使位于边界上的面被细化到圆形上。第53步显示了如何用一个由实验获得的数据定义的流形来做这件事。但是，至少就基本边界形状而言，deal.II实际上只提供了圆、球、盒和其他基本组合。在本教程中，我们将展示如何使用一组开发的类来导入任意的CAD几何图形，将它们分配到计算域的所需边界，并在这种复杂的形状上细化计算网格。</p>
<p><a class="anchor" id="CADsurfaces"></a></p><h3>CAD surfaces </h3>
<p>在最常见的工业实践中，任意形状的物体的几何模型是通过计算机辅助设计（CAD）工具实现的。在过去的几十年里，CAD建模器的使用已经普及，因为它们可以为每个设计对象生成一个完整的虚拟模型，通过计算机可以在实物制作之前对其最精细的细节进行可视化、检查和分析。 从数学的角度来看，CAD建模人员的引擎是由分析几何学来代表的，特别是由参数化的曲线和曲面，如B-splines和NURBS，它们足够丰富，可以代表大多数的实际利益的表面。 一旦一个虚拟模型准备好了，所需物体的所有几何特征都被存储在文件中，这些文件实质上包含了构成该物体的参数化曲面和曲线的系数。根据用于定义几何模型的具体CAD工具，当然有几种不同的文件格式，可以组织CAD模型的信息。为了提供一个跨CAD工具交换数据的共同基础，美国国家标准局在1980年发布了初始图形交换代表（IGES）中性文件格式，在本例中使用。</p>
<p><a class="anchor" id="TheCADboundaryprojectorclasses"></a></p><h3>The CAD boundary projector classes </h3>
<p>为了导入和查询CAD模型，deal.II库为CAD建模的OpenCASCADE开源库实现了一系列的包装函数。这些函数允许将IGES文件导入OpenCASCADE本地对象，并将其包裹在一系列Manifold类中。</p>
<p>一旦从IGES文件导入，模型就被存储在一个 <code>TopoDS_Shape</code> 中，这是OpenCASCADE框架中定义的通用拓扑实体。从 <code>TopoDS_Shape</code> 中，就可以访问构成它的所有子形状（如顶点、边和面），以及它们的几何描述。在deal.II框架中，组成一个形状的拓扑实体被用来创建一个相应的Manifold表示。在步骤6中，我们看到了如何使用 <a class="el" href="namespaceGridGenerator.html#ab2dc2f16fc52cf1e51b9afdc4264ac70">GridGenerator::hyper_sphere()</a> 来创建一个超球体，它自动将一个SphericalManifold附加到所有边界面。这保证了边界面在网格细化过程中保持在球体或圆上。CAD建模界面的功能被设计为保留相同的结构，允许用户使用导入的CAD形状建立一个投影仪对象，保持我们在其他教程程序中使用的相同程序，即把这种投影仪对象分配给粗略网格的单元、面或边。在每个细化周期，新的网格节点将通过将现有对象的中点投影到指定的几何体上而自动生成。</p>
<p>与球形或圆形边界不同，具有复杂几何形状的边界带来的问题是，在规定形状上细化后创建的新节点最好放在哪里。例如，PolarManifold将周围的点转换为极坐标，计算该坐标系中的平均值（对每个坐标单独计算），最后将点转换回直角坐标。</p>
<p>不过，在一个任意的复杂形状的情况下，一个合适的新节点的位置选择不可能那么容易确定。deal.II中的OpenCASCADE封装器提供了几个采用不同投影策略的投影仪类。第一个投影仪，在 <a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold</a> 类中实现，只用于边缘细化。它的建立是给它分配一个维度为1的拓扑形状，或者是一个 <code>TopoDS_Edge</code> or a <code>TopoDS_Wire</code> （这是一个复合形状，由几个连接的 <code>TopoDS_Edge</code> 组成），并细化网格边缘，找到新的顶点作为点，将CAD曲线部分的曲线长度分成两个偶数部分，位于原始边缘的顶点之间。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.CurveSplit.png" width="500"/>
</div>
<p>在 OpenCASCADE::NormalProjectionBoundary 类中实现了一个不同的投影策略。在构造时分配的 <code>TopoDS_Shape</code> 可以是任意的（图形、面、边的集合或单个面或边都可以）。新的单元格节点首先通过对周围的点进行平均计算，方法与FlatManifold相同。在第二步中，所有的新节点将沿着形状的法线方向被投射到 <code>TopoDS_Shape</code> 。如果没有法线投影，则选择最接近形状的点&ndash;通常位于形状的边界上&ndash;。 如果形状是由几个子形状组成的，则投影到每个子形状上，并选择最近的投影点。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjectionEdge.png" width="500"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjection.png" width="500"/>
</div>
<p> 。</p>
<p>正如我们即将体验到的，对于某些形状，将投影方向设置为CAD表面的法线，将不会导致合适质量的表面网格元素。这是因为CAD表面的法线方向原则上与网格需要新节点所在的方向无关。在这种情况下， OpenCASCADE::DirectionalProjectionBoundary 类可以提供帮助。这个类的构造是指定一个 <code>TopoDS_Shape</code> （至少包含一个面）和一个方向，所有的投影将沿着这个方向进行。新的点将被计算出来，首先对周围的点进行平均化（就像FlatManifold的情况一样），然后沿着构造时使用的方向，在拓扑形状和通过所得到的点的线之间取得最近的交点。 这样一来，用户就可以对投影方向有更高的控制，以确保良好的网格质量。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.DirectionalProjection.png" width="500"/>
</div>
<p>当然，后一种方法只有在表面的方向相当统一时才有效，这样就可以确定一个单一的投影方向。在表面方向接近投影方向的情况下，甚至有可能找不到方向性的投影。为了克服这些问题， OpenCASCADE::NormalToMeshProjectionBoundary 类实现了第三个投影算法。 OpenCASCADE::NormalToMeshProjectionBoundary 类的建立是将一个 <code>TopoDS_Shape</code> （至少包含一个面）分配给构造函数，其工作方式与 OpenCASCADE::DirectionalProjection. 完全一样。但是，正如该类的名字所暗示的， OpenCASCADE::NormalToMeshProjectionBoundary 试图想出一个合适的对要精化的网格元素的法线方向的估计，并将其用于新节点在CAD面上的投影。如果我们考虑二维空间中的网格边缘，其轴线方向是一个方向，沿着这个方向分割，以产生两个相同长度的新单元。我们在此将这一概念扩展到三维空间，并将所有新节点的投影方向近似于单元格的法线。</p>
<p>在下图中，受本教程中考虑的几何图形的启发，我们尝试比较所考虑的三种投影仪的行为。从左边可以看出，给定原始单元（蓝色），用法线投影找到的新点的位置不允许生成均匀的新元素（红色）。这种情况在进一步的细化步骤中会变得更糟。 由于我们考虑的几何体在某种程度上垂直于水平方向，以水平方向为投影方向的方向性投影（中心图像）在获得新的网格点方面做得相当好。然而，由于图片底部的表面几乎是水平的，我们可以预期在这些区域进行进一步细化步骤时，会出现问题。最后，右边的图片显示，位于单元轴上的节点将导致两个新单元具有相同的长度。当然，三维的情况会比这个简单的二维案例中描述的情况更复杂一些。然而，这个测试的结果证实，当考虑到任意形状的表面时，除非你有一个已知的更具体的方法，否则在测试的三种方法中，法线方向是最佳方法。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.ProjectionComparisons.png" width="700"/>
</div>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase </h3>
<p>在这个程序中，我们将考虑为一个描述船头的真实几何体创建一个表面网格（这个几何体经常被用于CAD和网格生成的比较中，并且可以免费获得）。我们得到的表面网格可以用来解决边界元素方程，以模拟水在船舶周围的流动（类似于<a class="el" href="step_34.html">step-34</a>的方式），但我们不会在这里尝试这样做。为了让你了解我们所考虑的几何形状，这里有一张图片。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.bare.png" width="500"/>
</div>
<p>在程序中，我们从文件中读取几何体和粗略的网格，然后采用上面讨论的几个选项来放置新的顶点，进行一系列的网格细化步骤。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with including a bunch of files that we will use in the various parts of the program. Most of them have been discussed in previous tutorials already:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>These are the headers of the opencascade support classes and functions. Notice that these will contain sensible data only if you compiled your deal.II library with support for <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a>, i.e., specifying <code>-DDEAL_II_WITH_OPENCASCADE=ON</code> and <code>-DOPENCASCADE_DIR=/path/to/your/opencascade/installation</code> when calling <code>cmake</code> during deal.II configuration.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, a few C++ standard header files</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>We isolate the rest of the program in its own namespace</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="TheTriangulationOnCADclass"></a> </p><h3>The TriangulationOnCAD class</h3>
<p>This is the main class. All it really does is store names for input and output files, and a triangulation. It then provides a function that generates such a triangulation from a coarse mesh, using one of the strategies discussed in the introduction and listed in the enumeration type at the top of the class.</p>
<p>The member functions of this class are similar to what you can find in most of the other tutorial programs in the setup stage of the grid for the simulations.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TriangulationOnCAD</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> ProjectionType</div><div class="line">  {</div><div class="line">    NormalProjection       = 0,</div><div class="line">    DirectionalProjection  = 1,</div><div class="line">    NormalToMeshProjection = 2</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD(</div><div class="line">    <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a> tria;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string initial_mesh_filename;</div><div class="line">  <span class="keyword">const</span> std::string cad_file_name;</div><div class="line">  <span class="keyword">const</span> std::string output_filename;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ProjectionType surface_projection_kind;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADTriangulationOnCAD"></a> </p><h4>TriangulationOnCAD::TriangulationOnCAD</h4>
<p>The constructor of the TriangulationOnCAD class is very simple. The input arguments are strings for the input and output file names, and the enumeration type that determines which kind of surface projector is used in the mesh refinement cycles (see below for details).</p>
<div class="fragment"><div class="line">TriangulationOnCAD::TriangulationOnCAD(</div><div class="line">  <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">  <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">  <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">  <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">  : initial_mesh_filename(initial_mesh_filename)</div><div class="line">  , cad_file_name(cad_file_name)</div><div class="line">  , output_filename(output_filename)</div><div class="line">  , surface_projection_kind(surface_projection_kind)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADread_domain"></a> </p><h4>TriangulationOnCAD::read_domain</h4>
<p>The following function represents the core of this program. In this function we import the CAD shape upon which we want to generate and refine our triangulation. We assume that the CAD surface is contained in the <code>cad_file_name</code> file (we provide an example IGES file in the input directory called "input/DTMB-5415_bulbous_bow.iges" that represents the bulbous bow of a ship). The presence of several convex and concave high curvature regions makes the geometry we provided a particularly meaningful example.</p>
<p>After importing the hull bow surface, we extract some of the curves and surfaces composing it, and use them to generate a set of projectors. Such projectors define the rules the <a class="el" href="classTriangulation.html">Triangulation</a> has to follow to position each new node during cell refinement.</p>
<p>To initialize the <a class="el" href="classTriangulation.html">Triangulation</a>, as done in previous tutorial programs, we import a pre-existing grid saved in VTK format. We assume here that the user has generated a coarse mesh externally, which matches the IGES geometry. At the moment of writing this tutorial, the deal.II library does not automatically support generation of such meshes, but there are several tools which can provide you with reasonable initial meshes starting from CAD files. In our example, the imported mesh is composed of a single quadrilateral cell whose vertices have been placed on the CAD shape.</p>
<p>After importing both the IGES geometry and the initial mesh, we assign the projectors previously discussed to each of the edges and cells which will have to be refined on the CAD surface.</p>
<p>In this tutorial, we will test the three different CAD surface projectors described in the introduction, and will analyze the results obtained with each of them. As mentioned, each of these projection strategies has been implemented in a different class, and objects of these types can be assigned to a triangulation using the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> method.</p>
<p>The following function then first imports the given CAD file. The function arguments are a string containing the desired file name, and a scale factor. In this example, the scale factor is set to 1e-3, as the original geometry is written in millimeters (which is the typical unit of measure for most IGES files), while we prefer to work in meters. The output of the function is an object of <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> generic topological shape class, namely a <code>TopoDS_Shape</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">{</div><div class="line">  TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div></div><!-- fragment --><p>Each CAD geometrical object is defined along with a tolerance, which indicates possible inaccuracy of its placement. For instance, the tolerance <code>tol</code> of a vertex indicates that it can be located in any point contained in a sphere centered in the nominal position and having radius <code>tol</code>. While projecting a point onto a surface (which will in turn have its tolerance) we must keep in mind that the precision of the projection will be limited by the tolerance with which the surface is built.</p>
<p>The following method extracts the tolerance of the given shape and makes it a bit bigger to stay our of trouble:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) * 5;</div></div><!-- fragment --><p>We now want to extract a set of composite sub-shapes from the generic shape. In particular, each face of the CAD file is composed of a trimming curve of type <code>TopoDS_Wire</code>, which is the collection of <code>TopoDS_Edges</code> that compose the boundary of a surface, and a NURBS description of the surface itself. We will use a line projector to associate the boundary of our <a class="el" href="classTriangulation.html">Triangulation</a> to the wire delimiting the surface. To extract all compound sub-shapes, like wires, shells, or solids, we resort to a method of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace. The input of <a class="el" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a> is a shape and a set of empty std::vectors of subshapes, which will be filled with all compound shapes found in the given topological shape:</p>
<div class="fragment"><div class="line">std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line"><a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(</div><div class="line">  bow_surface, compounds, compsolids, solids, shells, wires);</div></div><!-- fragment --><p>The next few steps are more familiar, and allow us to import an existing mesh from an external VTK file, and convert it to a deal triangulation.</p>
<div class="fragment"><div class="line">std::ifstream in;</div><div class="line"></div><div class="line">in.open(initial_mesh_filename);</div><div class="line"></div><div class="line"><a class="code" href="classGridIn.html">GridIn&lt;2, 3&gt;</a> gi;</div><div class="line">gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">gi.<a class="code" href="group__simplex.html#ga058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div></div><!-- fragment --><p>We output this initial mesh saving it as the refinement step 0.</p>
<div class="fragment"><div class="line">output_results(0);</div></div><!-- fragment --><p>The mesh imported has a single, two-dimensional cell located in three-dimensional space. We now want to ensure that it is refined according to the CAD geometry imported above. This this end, we get an iterator to that cell and assign to it the manifold_id 1 (see <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">this glossary entry</a>). We also get an iterator to its four faces, and assign each of them the manifold_id 2:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2, 3&gt;::active_cell_iterator</a> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  face-&gt;set_manifold_id(2);</div></div><!-- fragment --><p>Once both the CAD geometry and the initial mesh have been imported and digested, we use the CAD surfaces and curves to define the projectors and assign them to the manifold ids just specified.</p>
<p>A first projector is defined using the single wire contained in our CAD file. The ArclengthProjectionLineManifold will make sure that every mesh edge located on the wire is refined with a point that lies on the wire and splits it into two equal arcs lying between the edge vertices. We first check that the wires vector contains at least one element and then create a <a class="el" href="classManifold.html">Manifold</a> object for it.</p>
<p>Once the projector is created, we then assign it to all the parts of the triangulation with manifold_id = 2:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">  wires.size() &gt; 0,</div><div class="line">  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">    <span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line"><a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2, 3&gt;</a> line_projector(</div><div class="line">  wires[0], tolerance);</div><div class="line"></div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(2, line_projector);</div></div><!-- fragment --><p>The surface projector is created according to what is specified with the <code>surface_projection_kind</code> option of the constructor. In particular, if the surface_projection_kind value equals <code>NormalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold</a>. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along its normal direction. The NormalProjectionManifold constructor only needs a shape and a tolerance, and we then assign it to the triangulation for use with all parts that manifold having id 1:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> NormalProjection:</div><div class="line">      {</div><div class="line">        <a class="code" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold&lt;2, 3&gt;</a> normal_projector(</div><div class="line">          bow_surface, tolerance);</div><div class="line">        tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_projector);</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div></div><!-- fragment --><p><code>If</code> surface_projection_kind value is <code>DirectionalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold</a> class. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is specified to the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold</a> constructor. In this case, the projection is done along the y-axis.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">  {</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold&lt;2, 3&gt;</a></div><div class="line">      directional_projector(bow_surface,</div><div class="line">                            <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0, 1.0, 0.0),</div><div class="line">                            tolerance);</div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, directional_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>As a third option, if <code>surface_projection_kind</code> value is <code>NormalToMeshProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>. The new mesh points will again initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is an estimate of the mesh normal direction. The <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> constructor only requires a shape (containing at least a face) and a tolerance.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">  {</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;2, 3&gt;</a></div><div class="line">      normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_to_mesh_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>Finally, we use good software cleanliness by ensuring that this really covers all possible options of the <code>case</code> statement. If we get any other value, we simply abort the program:</p>
<div class="fragment"><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrefine_mesh"></a> </p><h4>TriangulationOnCAD::refine_mesh</h4>
<p>This function globally refines the mesh. In other tutorials, it would typically also distribute degrees of freedom, and resize matrices and vectors. These tasks are not carried out here, since we are not running any simulation on the <a class="el" href="classTriangulation.html">Triangulation</a> produced.</p>
<p>While the function looks innocent, this is where most of the work we are interested in for this tutorial program actually happens. In particular, when refining the quads and lines that define the surface of the ship's hull, the <a class="el" href="classTriangulation.html">Triangulation</a> class will ask the various objects we have assigned to handle individual manifold ids for where the new vertices should lie.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">{</div><div class="line">  tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADoutput_results"></a> </p><h4>TriangulationOnCAD::output_results</h4>
<p>Outputting the results of our computations is a rather mechanical task. All the components of this function have been discussed before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (output_filename + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  std::ofstream logfile(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrun"></a> </p><h4>TriangulationOnCAD::run</h4>
<p>This is the main function. It should be self explanatory in its briefness:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TriangulationOnCAD::run</a>()</div><div class="line">  {</div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_mesh();</div><div class="line">        output_results(cycle + 1);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step54</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is the main function of this program. It is in its basic structure like all previous tutorial programs, but runs the main class through the three possibilities of new vertex placement:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">      <span class="keyword">const</span> std::string cad_file_name    = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::string        out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                          cad_file_name,</div><div class="line">                                          out_mesh_filename,</div><div class="line">                                          TriangulationOnCAD::NormalProjection);</div><div class="line">      tria_on_cad_norm.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_dir(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::DirectionalProjection);</div><div class="line">      tria_on_cad_dir.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm_to_mesh(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">      tria_on_cad_norm_to_mesh.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-54/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>程序的执行会产生一系列的网格文件 <code>3d_mesh_*.vtk</code> ，我们可以用任何可以读取VTK文件格式的常用可视化程序来进行可视化。</p>
<p>下表说明了采用正常投影策略得到的结果。表中的前两行显示的是逐步细化的网格的侧视图，覆盖在精确几何体的非常精细的渲染上。深红色和浅红色的区域只是表示当前的网格或精细的几何体更接近观察者；这种区别没有任何特别深刻的意义。最后一排图片描述了第二排中相同网格的正视图（镜像到几何体的两边）。</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>从图片中可以看出，正如我们所预料的那样，当应用于具有明显曲率变化的表面时，正常的细化策略无法产生良好的形状的元素。这在船体的球体上尤其明显，所有的新点都被放置在球体的上部，而下部则完全没有被解决。</p>
<p>下表的排列方式与上表相同，说明了采用方向性投影方法获得的结果，其中选择的投影方向是Y轴（在每幅图像的左下方用一个小的黄色箭头表示）。</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>这些图像证实，用定向投影得到的网格质量明显高于沿表面法线投影得到的网格。然而，在球体底部观察到一些在Y方向上拉长的元素，那里的表面几乎与选择的投影方向平行。</p>
<p>最后的测试显示了使用面的法线投影的结果。</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>图片证实了法线投影的方法导致网格在整个细化步骤中保持均匀的间隔。同时，这些网格很好地表现了原始的几何形状，甚至在灯泡的底部区域也是如此，这一点在使用定向投影仪或法线投影仪时并没有得到很好的恢复。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *  Authors: Andrea Mola, Luca Heltai, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>TriangulationOnCAD</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> ProjectionType</div><div class="line">    {</div><div class="line">      NormalProjection       = 0,</div><div class="line">      DirectionalProjection  = 1,</div><div class="line">      NormalToMeshProjection = 2</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    TriangulationOnCAD(</div><div class="line">      <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">      <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">      <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">      <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a> tria;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string initial_mesh_filename;</div><div class="line">    <span class="keyword">const</span> std::string cad_file_name;</div><div class="line">    <span class="keyword">const</span> std::string output_filename;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD::TriangulationOnCAD(</div><div class="line">    <span class="keyword">const</span> std::string &amp;  initial_mesh_filename,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  cad_file_name,</div><div class="line">    <span class="keyword">const</span> std::string &amp;  output_filename,</div><div class="line">    <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">    : initial_mesh_filename(initial_mesh_filename)</div><div class="line">    , cad_file_name(cad_file_name)</div><div class="line">    , output_filename(output_filename)</div><div class="line">    , surface_projection_kind(surface_projection_kind)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">  {</div><div class="line">    TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) * 5;</div><div class="line"></div><div class="line">    std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">    std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">    std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">    std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">    std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(</div><div class="line">      bow_surface, compounds, compsolids, solids, shells, wires);</div><div class="line"></div><div class="line">    std::ifstream in;</div><div class="line"></div><div class="line">    in.open(initial_mesh_filename);</div><div class="line"></div><div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;2, 3&gt;</a> gi;</div><div class="line">    gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">    gi.<a class="code" href="group__simplex.html#ga058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div><div class="line"></div><div class="line">    output_results(0);</div><div class="line"></div><div class="line">    <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2, 3&gt;::active_cell_iterator</a> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      face-&gt;set_manifold_id(2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">      wires.size() &gt; 0,</div><div class="line">      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">        <span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2, 3&gt;</a> line_projector(</div><div class="line">      wires[0], tolerance);</div><div class="line"></div><div class="line">    tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(2, line_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> NormalProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1NormalProjectionManifold.html">OpenCASCADE::NormalProjectionManifold&lt;2, 3&gt;</a> normal_projector(</div><div class="line">              bow_surface, tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">OpenCASCADE::DirectionalProjectionManifold&lt;2, 3&gt;</a></div><div class="line">              directional_projector(bow_surface,</div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0, 1.0, 0.0),</div><div class="line">                                    tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, directional_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">          {</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;2, 3&gt;</a></div><div class="line">              normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line">            tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, normal_to_mesh_projector);</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">  {</div><div class="line">    tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      (output_filename + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    std::ofstream logfile(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TriangulationOnCAD::run</a>()</div><div class="line">  {</div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_mesh();</div><div class="line">        output_results(cycle + 1);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step54</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">      <span class="keyword">const</span> std::string cad_file_name    = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::string        out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                          cad_file_name,</div><div class="line">                                          out_mesh_filename,</div><div class="line">                                          TriangulationOnCAD::NormalProjection);</div><div class="line">      tria_on_cad_norm.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_dir(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::DirectionalProjection);</div><div class="line">      tria_on_cad_dir.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      out_mesh_filename = (<span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span>);</div><div class="line">      TriangulationOnCAD tria_on_cad_norm_to_mesh(</div><div class="line">        in_mesh_filename,</div><div class="line">        cad_file_name,</div><div class="line">        out_mesh_filename,</div><div class="line">        TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">      tria_on_cad_norm_to_mesh.run();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
