<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_29.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-29 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-29 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemsetting">Problem setting</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDirichletBoundaryValuescodeclass">The <code>DirichletBoundaryValues</code> class</a>
        <li><a href="#ThecodeParameterReadercodeclass">The <code>ParameterReader</code> class</a>
      <ul>
        <li><a href="#codeParameterReaderdeclare_parameterscode"><code>ParameterReader::declare_parameters</code></a>
        <li><a href="#codeParameterReaderread_parameterscode"><code>ParameterReader::read_parameters</code></a>
      </ul>
        <li><a href="#ThecodeComputeIntensitycodeclass">The <code>ComputeIntensity</code> class</a>
        <li><a href="#ThecodeUltrasoundProblemcodeclass">The <code>UltrasoundProblem</code> class</a>
      <ul>
        <li><a href="#codeUltrasoundProblemmake_gridcode"><code>UltrasoundProblem::make_grid</code></a>
        <li><a href="#codeUltrasoundProblemsetup_systemcode"><code>UltrasoundProblem::setup_system</code></a>
        <li><a href="#codeUltrasoundProblemassemble_systemcode"><code>UltrasoundProblem::assemble_system</code></a>
        <li><a href="#codeUltrasoundProblemsolvecode"><code>UltrasoundProblem::solve</code></a>
        <li><a href="#codeUltrasoundProblemoutput_resultscode"><code>UltrasoundProblem::output_results</code></a>
        <li><a href="#codeUltrasoundProblemruncode"><code>UltrasoundProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Moritz Allmaras at Texas A&amp;M University. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778. </em></p>
<p><b>Note:</b> In order to run this program, deal.II must be configured to use the UMFPACK sparse direct solver. Refer to the <a href="../../readme.html#umfpack">ReadMe</a> for instructions how to do this.</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>A question that comes up frequently is how to solve problems involving complex valued functions with deal.II. For many problems, instead of working with complex valued finite elements directly, it is often more convenient to split complex valued functions into their real and imaginary parts and use separate scalar finite element fields for discretizing each one of them. Basically this amounts to viewing a single complex valued equation as a system of two real valued equations. This short example demonstrates how this can be implemented in deal.II by using an <code>FE_system</code> object to stack two finite element fields representing real and imaginary parts. (The opposite approach, keeping everything complex-valued, is demonstrated in a different tutorial program: see <a class="el" href="step_58.html">step-58</a> for this.) When split into real and imaginary parts, the equations covered here fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p>In addition to this discussion, we also discuss the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, which provides a convenient way for reading parameters from a configuration file at runtime without the need to recompile the program code.</p>
<p><a class="anchor" id="Problemsetting"></a></p><h3>Problem setting</h3>
<p>The original purpose of this program is to simulate the focusing properties of an ultrasound wave generated by a transducer lens with variable geometry. Recent applications in medical imaging use ultrasound waves not only for imaging purposes, but also to excite certain local effects in a material, like changes in optical properties, that can then be measured by other imaging techniques. A vital ingredient for these methods is the ability to focus the intensity of the ultrasound wave in a particular part of the material, ideally in a point, to be able to examine the properties of the material at that particular location.</p>
<p>To derive a model for this problem, we think of ultrasound as a pressure wave governed by the wave equation: </p><p class="formulaDsp">
\[ \frac{\partial^2 U}{\partial t^2} - c^2 \Delta U = 0 \]
</p>
<p> where \(c\) is the wave speed (that for simplicity we assume to be constant), \(U = U(x,t),\;x \in \Omega,\;t\in\mathrm{R}\). The boundary \(\Gamma=\partial\Omega\) is divided into two parts \(\Gamma_1\) and \(\Gamma_2=\Gamma\setminus\Gamma_1\), with \(\Gamma_1\) representing the transducer lens and \(\Gamma_2\) an absorbing boundary (that is, we want to choose boundary conditions on \(\Gamma_2\) in such a way that they imitate a larger domain). On \(\Gamma_1\), the transducer generates a wave of constant frequency \({\omega}&gt;0\) and constant amplitude (that we chose to be 1 here): </p><p class="formulaDsp">
\[ U(x,t) = \cos{\omega t}, \qquad x\in \Gamma_1 \]
</p>
<p>If there are no other (interior or boundary) sources, and since the only source has frequency \(\omega\), then the solution admits a separation of variables of the form \(U(x,t) = \textrm{Re}\left(u(x)\,e^{i\omega t})\right)\). The complex-valued function \(u(x)\) describes the spatial dependency of amplitude and phase (relative to the source) of the waves of frequency \({\omega}\), with the amplitude being the quantity that we are interested in. By plugging this form of the solution into the wave equation, we see that for \(u\) we have </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u(x) - c^2\Delta u(x) &amp;=&amp; 0, \qquad x\in\Omega,\\ u(x) &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p>For finding suitable conditions on \(\Gamma_2\) that model an absorbing boundary, consider a wave of the form \(V(x,t)=e^{i(k\cdot x -\omega t)}\) with frequency \({\omega}\) traveling in direction \(k\in {\mathrm{R}^2}\). In order for \(V\) to solve the wave equation, \(|k|={\frac{\omega}{c}}\) must hold. Suppose that this wave hits the boundary in \(x_0\in\Gamma_2\) at a right angle, i.e. \(n=\frac{k}{|k|}\) with \(n\) denoting the outer unit normal of \(\Omega\) in \(x_0\). Then at \(x_0\), this wave satisfies the equation </p><p class="formulaDsp">
\[ c (n\cdot\nabla V) + \frac{\partial V}{\partial t} = (i\, c\, |k| - i\, \omega) V = 0. \]
</p>
<p> Hence, by enforcing the boundary condition </p><p class="formulaDsp">
\[ c (n\cdot\nabla U) + \frac{\partial U}{\partial t} = 0, \qquad x\in\Gamma_2, \]
</p>
<p> waves that hit the boundary \(\Gamma_2\) at a right angle will be perfectly absorbed. On the other hand, those parts of the wave field that do not hit a boundary at a right angle do not satisfy this condition and enforcing it as a boundary condition will yield partial reflections, i.e. only parts of the wave will pass through the boundary as if it wasn't here whereas the remaining fraction of the wave will be reflected back into the domain.</p>
<p>If we are willing to accept this as a sufficient approximation to an absorbing boundary we finally arrive at the following problem for \(u\): </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u - c^2\Delta u &amp;=&amp; 0, \qquad x\in\Omega,\\ c (n\cdot\nabla u) + i\,\omega\,u &amp;=&amp;0, \qquad x\in\Gamma_2,\\ u &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p> This is a Helmholtz equation (similar to the one in <a class="el" href="step_7.html">step-7</a>, but this time with ''the bad sign'') with Dirichlet data on \(\Gamma_1\) and mixed boundary conditions on \(\Gamma_2\). Because of the condition on \(\Gamma_2\), we cannot just treat the equations for real and imaginary parts of \(u\) separately. What we can do however is to view the PDE for \(u\) as a system of two PDEs for the real and imaginary parts of \(u\), with the boundary condition on \(\Gamma_2\) representing the coupling terms between the two components of the system. This works along the following lines: Let \(v=\textrm{Re}\;u,\; w=\textrm{Im}\;u\), then in terms of \(v\) and \(w\) we have the following system: </p><p class="formulaDsp">
\begin{eqnarray*} \left.\begin{array}{ccc} -\omega^2 v - c^2\Delta v &amp;=&amp; 0 \quad\\ -\omega^2 w - c^2\Delta w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Omega, \\ \left.\begin{array}{ccc} c (n\cdot\nabla v) - \omega\,w &amp;=&amp; 0 \quad\\ c (n\cdot\nabla w) + \omega\,v &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_2, \\ \left.\begin{array}{ccc} v &amp;=&amp; 1 \quad\\ w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_1. \end{eqnarray*}
</p>
<p>For test functions \(\phi,\psi\) with \(\phi|_{\Gamma_1}=\psi|_{\Gamma_1}=0\), after the usual multiplication, integration over \(\Omega\) and applying integration by parts, we get the weak formulation </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 \langle \phi, v \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi, \nabla v \rangle_{\mathrm{L}^2(\Omega)} - c \omega \langle \phi, w \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0, \\ -\omega^2 \langle \psi, w \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi, \nabla w \rangle_{\mathrm{L}^2(\Omega)} + c \omega \langle \psi, v \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>We choose finite element spaces \(V_h\) and \(W_h\) with bases \(\{\phi_j\}_{j=1}^n, \{\psi_j\}_{j=1}^n\) and look for approximate solutions </p><p class="formulaDsp">
\[ v_h = \sum_{j=1}^n \alpha_j \phi_j, \;\; w_h = \sum_{j=1}^n \beta_j \psi_j. \]
</p>
<p> Plugging into the variational form yields the equation system </p><p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left.\begin{array}{ccc} \sum_{j=1}^n \left( -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} \right) \alpha_j - \left( c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)}\right)\beta_j &amp;=&amp; 0 \\ \sum_{j=1}^n \left( -\omega^2 \langle \psi_i, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_i, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \right)\beta_j + \left( c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \right)\alpha_j &amp;=&amp; 0 \end{array}\right\}\;\;\forall\; i =1,\ldots,n. \]
</p>
<p> In matrix notation: </p><p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left( \begin{array}{cc} -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} &amp; -c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \\ c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} &amp; -\omega^2 \langle \psi_{i}, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_{i}, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \end{array} \right) \left( \begin{array}{c} \alpha \\ \beta \end{array} \right) = \left( \begin{array}{c} 0 \\ 0 \end{array} \right) \]
</p>
<p> (One should not be fooled by the right hand side being zero here, that is because we haven't included the Dirichlet boundary data yet.) Because of the alternating sign in the off-diagonal blocks, we can already see that this system is non-symmetric, in fact it is even indefinite. Of course, there is no necessity to choose the spaces \(V_h\) and \(W_h\) to be the same. However, we expect real and imaginary part of the solution to have similar properties and will therefore indeed take \(V_h=W_h\) in the implementation, and also use the same basis functions \(\phi_i = \psi_i\) for both spaces. The reason for the notation using different symbols is just that it allows us to distinguish between shape functions for \(v\) and \(w\), as this distinction plays an important role in the implementation.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>For the computations, we will consider wave propagation in the unit square, with ultrasound generated by a transducer lens that is shaped like a segment of the circle with center at \((0.5, d)\) and a radius slightly greater than \(d\); this shape should lead to a focusing of the sound wave at the center of the circle. Varying \(d\) changes the "focus" of the lens and affects the spatial distribution of the intensity of \(u\), where our main concern is how well \(|u|=\sqrt{v^2+w^2}\) is focused.</p>
<p>In the program below, we will implement the complex-valued Helmholtz equations using the formulation with split real and imaginary parts. We will also discuss how to generate a domain that looks like a square with a slight bulge simulating the transducer (in the <code>UltrasoundProblem&lt;dim&gt;::make_grid()</code> function), and how to generate graphical output that not only contains the solution components \(v\) and \(w\), but also the magnitude \(\sqrt{v^2+w^2}\) directly in the output file (in <code>UltrasoundProblem&lt;dim&gt;::output_results()</code>). Finally, we use the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to easily read parameters like the focal distance \(d\), wave speed \(c\), frequency \(\omega\), and a number of other parameters from an input file at run-time, rather than fixing those parameters in the source code where we would have to re-compile every time we want to change parameters.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following header files have all been discussed before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>This header file contains the necessary declarations for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class that we will use to read our parameters from a configuration file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div></div><!-- fragment --><p>For solving the linear system, we'll use the sparse LU-decomposition provided by UMFPACK (see the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class), for which the following header file is needed. Note that in order to compile this tutorial program, the deal.II-library needs to be built with UMFPACK support, which is enabled by default:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div></div><!-- fragment --><p>The <a class="el" href="classFESystem.html">FESystem</a> class allows us to stack several FE-objects to one compound, vector-valued finite element field. The necessary declarations for this class are provided in this header file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, include the header file that declares the <a class="el" href="classTimer.html">Timer</a> class that we will use to determine how much time each of the operations of our program takes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div></div><!-- fragment --><p>As the last step at the beginning of this program, we put everything that is in this program into its namespace and, within it, make everything that is in the deal.II namespace globally available, without the need to prefix everything with <code>dealii</code><code>::</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDirichletBoundaryValuescodeclass"></a> </p><h3>The <code>DirichletBoundaryValues</code> class</h3>
<p>First we define a class for the function representing the Dirichlet boundary values. This has been done many times before and therefore does not need much explanation.</p>
<p>Since there are two values \(v\) and \(w\) that need to be prescribed at the boundary, we have to tell the base class that this is a vector-valued function with two components, and the <code>vector_value</code> function and its cousin <code>vector_value_list</code> must return vectors with two entries. In our case the function is very simple, it just returns 1 for the real part \(v\) and 0 for the imaginary part \(w\) regardless of the point where it is evaluated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DirichletBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 2));</div><div class="line"></div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;  value_list)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeParameterReadercodeclass"></a> </p><h3>The <code>ParameterReader</code> class</h3>
<p>The next class is responsible for preparing the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and reading parameters from an input file. It includes a function <code>declare_parameters</code> that declares all the necessary parameters and a <code>read_parameters</code> function that is called from outside to initiate the parameter reading process.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>              declare_parameters();</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">};</div></div><!-- fragment --><p>The constructor stores a reference to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to it:</p>
<div class="fragment"><div class="line">ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">  : prm(paramhandler)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderdeclare_parameterscode"></a> </p><h4><code>ParameterReader::declare_parameters</code></h4>
<p>The <code>declare_parameters</code> function declares all the parameters that our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will be able to read from input files, along with their types, range conditions and the subsections they appear in. We will wrap all the entries that go into a section in a pair of braces to force the editor to indent them by one level, making it simpler to read which entries together form a section:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">{</div></div><!-- fragment --><p>Parameters for mesh and geometry include the number of global refinement steps that are applied to the initial coarse mesh and the focal distance \(d\) of the transducer lens. For the number of refinement steps, we allow integer values in the range \([0,\infty)\), where the omitted second argument to the <a class="el" href="classPatterns_1_1Integer.html">Patterns::Integer</a> object denotes the half-open interval. For the focal distance any number greater than zero is accepted:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>The next subsection is devoted to the physical parameters appearing in the equation, which are the frequency \(\omega\) and wave speed \(c\). Again, both need to lie in the half-open interval \([0,\infty)\) represented by calling the <a class="el" href="classPatterns_1_1Double.html">Patterns::Double</a> class with only the left end-point as argument:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Last but not least we would like to be able to change some properties of the output, like filename and format, through entries in the configuration file, which is the purpose of the last subsection:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output filename&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div></div><!-- fragment --><p>Since different output formats may require different parameters for generating output (like for example, postscript output needs viewpoint angles, line widths, colors etc), it would be cumbersome if we had to declare all these parameters by hand for every possible output format supported in the library. Instead, each output format has a <code>FormatFlags::declare_parameters</code> function, which declares all the parameters specific to that format in an own subsection. The following call of <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> executes <code>declare_parameters</code> for all available output formats, so that for each format an own subsection will be created with parameters declared for that particular output format. (The actual value of the template parameter in the call, <code>&lt;1&gt;</code> above, does not matter here: the function does the same work independent of the dimension, but happens to be in a template-parameter-dependent class.) To find out what parameters there are for which output format, you can either consult the documentation of the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class, or simply run this program without a parameter file present. It will then create a file with all declared parameters set to their default values, which can conveniently serve as a starting point for setting the parameters to the values you desire.</p>
<div class="fragment"><div class="line">    <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderread_parameterscode"></a> </p><h4><code>ParameterReader::read_parameters</code></h4>
<p>This is the main function in the ParameterReader class. It gets called from outside, first declares all the parameters, and then reads them from the input file whose filename is provided by the caller. After the call to this function is complete, the <code>prm</code> object can be used to retrieve the values of the parameters read in from the file :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div><div class="line">{</div><div class="line">  declare_parameters();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeComputeIntensitycodeclass"></a> </p><h3>The <code>ComputeIntensity</code> class</h3>
<p>As mentioned in the introduction, the quantity that we are really after is the spatial distribution of the intensity of the ultrasound wave, which corresponds to \(|u|=\sqrt{v^2+w^2}\). Now we could just be content with having \(v\) and \(w\) in our output, and use a suitable visualization or postprocessing tool to derive \(|u|\) from the solution we computed. However, there is also a way to output data derived from the solution in deal.II, and we are going to make use of this mechanism here.</p>
<p>So far we have always used the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> function to add vectors containing output data to a <a class="el" href="classDataOut.html">DataOut</a> object. There is a special version of this function that in addition to the data vector has an additional argument of type <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. What happens when this function is used for output is that at each point where output data is to be generated, the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> function of the specified <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object is invoked to compute the output quantities from the values, the gradients and the second derivatives of the finite element function represented by the data vector (in the case of face related data, normal vectors are available as well). Hence, this allows us to output any quantity that can locally be derived from the values of the solution and its derivatives. Of course, the ultrasound intensity \(|u|\) is such a quantity and its computation doesn't even involve any derivatives of \(v\) or \(w\).</p>
<p>In practice, the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class only provides an interface to this functionality, and we need to derive our own class from it in order to implement the functions specified by the interface. In the most general case one has to implement several member functions but if the output quantity is a single scalar then some of this boilerplate code can be handled by a more specialized class, <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and we can derive from that one instead. This is what the <code>ComputeIntensity</code> class does:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ComputeIntensity();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>In the constructor, we need to call the constructor of the base class with two arguments. The first denotes the name by which the single scalar quantity computed by this class should be represented in output files. In our case, the postprocessor has \(|u|\) as output, so we use "Intensity".</p>
<p>The second argument is a set of flags that indicate which data is needed by the postprocessor in order to compute the output quantities. This can be any subset of update_values, update_gradients and update_hessians (and, in the case of face data, also update_normal_vectors), which are documented in UpdateFlags. Of course, computation of the derivatives requires additional resources, so only the flags for data that are really needed should be given here, just as we do when we use <a class="el" href="classFEValues.html">FEValues</a> objects. In our case, only the function values of \(v\) and \(w\) are needed to compute \(|u|\), so we're good with the update_values flag.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div><div class="line">  : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">{}</div></div><!-- fragment --><p>The actual postprocessing happens in the following function. Its input is an object that stores values of the function (which is here vector-valued) representing the data vector given to <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a>, evaluated at all evaluation points where we generate output, and some tensor objects representing derivatives (that we don't use here since \(|u|\) is computed from just \(v\) and \(w\)). The derived quantities are returned in the <code>computed_quantities</code> vector. Remember that this function may only use data for which the respective update flag is specified by <code>get_needed_update_flags</code>. For example, we may not use the derivatives here, since our implementation of <code>get_needed_update_flags</code> requests that only function values are provided.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                              inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div></div><!-- fragment --><p>The computation itself is straightforward: We iterate over each entry in the output vector and compute \(|u|\) from the corresponding values of \(v\) and \(w\). We do this by creating a complex number \(u\) and then calling <code><a class="el" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">std::abs()</a></code> on the result. (One may be tempted to call <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code>, but in a historical quirk, the C++ committee decided that <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code> should return the <em>square</em> of the absolute value &ndash; thereby not satisfying the properties mathematicians require of something called a "norm".)</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div><div class="line">                                   inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line"></div><div class="line">      computed_quantities[i](0) = std::abs(u);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeUltrasoundProblemcodeclass"></a> </p><h3>The <code>UltrasoundProblem</code> class</h3>
<p>Finally here is the main class of this program. It's member functions are very similar to the previous examples, in particular <a class="el" href="step_4.html">step-4</a>, and the list of member variables does not contain any major surprises either. The <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to the constructor is stored as a reference to allow easy access to the parameters from all functions of the class. Since we are working with vector valued finite elements, the FE object we are using is of type <a class="el" href="classFESystem.html">FESystem</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>UltrasoundProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution, system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>The constructor takes the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and stores it in a reference. It also initializes the DoF-Handler and the finite element system, which consists of two copies of the scalar Q1 field, one for \(v\) and one for \(w\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div><div class="line">  : prm(param)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemmake_gridcode"></a> </p><h4><code>UltrasoundProblem::make_grid</code></h4>
<p>Here we setup the grid for our domain. As mentioned in the exposition, the geometry is just a unit square (in 2d) with the part of the boundary that represents the transducer lens replaced by a sector of a circle.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div></div><!-- fragment --><p>First we generate some logging output and start a timer so we can compute execution time when this function is done:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>Then we query the values for the focal distance of the transducer lens and the number of mesh refinement steps from our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Next, two points are defined for position and focal point of the transducer lens, which is the center of the circle whose segment will form the transducer part of the boundary. Notice that this is the only point in the program where things are slightly different in 2D and 3D. Even though this tutorial only deals with the 2D case, the necessary additions to make this program functional in 3D are so minimal that we opt for including them:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div><div class="line">  (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div></div><!-- fragment --><p>As initial coarse grid we take a simple unit square with 5 subdivisions in each direction. The number of subdivisions is chosen so that the line segment \([0.4,0.6]\) that we want to designate as the transducer boundary is spanned by a single face. Then we step through all cells to find the faces where the transducer is to be located, which in fact is just the single edge from 0.4 to 0.6 on the x-axis. This is where we want the refinements to be made according to a circle shaped boundary, so we mark this edge with a different manifold indicator. Since we will Dirichlet boundary conditions on the transducer, we also change its boundary indicator.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 5, 0, 1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">        ((face-&gt;center() - transducer).norm_square() &lt; 0.01))</div><div class="line">      {</div><div class="line">        face-&gt;set_boundary_id(1);</div><div class="line">        face-&gt;set_manifold_id(1);</div><div class="line">      }</div></div><!-- fragment --><p>For the circle part of the transducer lens, a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object is used (which, of course, in 2D just represents a circle), with center computed as above.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div></div><!-- fragment --><p>Now global refinement is executed. Cells near the transducer location will be automatically refined according to the circle shaped boundary of the transducer lens:</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinements);</div></div><!-- fragment --><p>Lastly, we generate some more logging output. We stop the timer and query the number of CPU seconds elapsed since the beginning of the function:</p>
<div class="fragment"><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsetup_systemcode"></a> </p><h4><code>UltrasoundProblem::setup_system</code></h4>
<p>Initialization of the system matrix, sparsity patterns and vectors are the same as in previous examples and therefore do not need further comment. As in the previous function, we also output the run time of what we do here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemassemble_systemcode"></a> </p><h4><code>UltrasoundProblem::assemble_system</code></h4>
<p>As before, this function takes care of assembling the system matrix and right hand side vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>First we query wavespeed and frequency from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and store them in local variables, as they will be used frequently throughout this function.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>As usual, for computing integrals ordinary Gauss quadrature rule is used. Since our bilinear form involves boundary integrals on \(\Gamma_2\), we also need a quadrature rule for surface integration on the faces, which are \(dim-1\) dimensional:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"><a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div><div class="line">                   n_face_q_points = face_quadrature_formula.size(),</div><div class="line">                   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div></div><!-- fragment --><p>The <a class="el" href="classFEValues.html">FEValues</a> objects will evaluate the shape functions for us. For the part of the bilinear form that involves integration on \(\Omega\), we'll need the values and gradients of the shape functions, and of course the quadrature weights. For the terms involving the boundary integrals, only shape function values and the quadrature weights are necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                 face_quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>As usual, the system matrix is assembled cell by cell, and we need a matrix for storing the local cell contributions as well as an index vector to transfer the cell contributions to the appropriate location in the global system matrix after.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><p>On each cell, we first need to reset the local contribution matrix and request the <a class="el" href="classFEValues.html">FEValues</a> object to compute the shape functions for the current cell:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div></div><!-- fragment --><p>At this point, it is important to keep in mind that we are dealing with a finite element system with two components. Due to the way we constructed this <a class="el" href="classFESystem.html">FESystem</a>, namely as the Cartesian product of two scalar finite element fields, each shape function has only a single nonzero component (they are, in deal.II lingo, <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>). Hence, each shape function can be viewed as one of the \(\phi\)'s or \(\psi\)'s from the introduction, and similarly the corresponding degrees of freedom can be attributed to either \(\alpha\) or \(\beta\). As we iterate through all the degrees of freedom on the current cell however, they do not come in any particular order, and so we cannot decide right away whether the DoFs with index \(i\) and \(j\) belong to the real or imaginary part of our solution. On the other hand, if you look at the form of the system matrix in the introduction, this distinction is crucial since it will determine to which block in the system matrix the contribution of the current pair of DoFs will go and hence which quantity we need to compute from the given two shape functions. Fortunately, the <a class="el" href="classFESystem.html">FESystem</a> object can provide us with this information, namely it has a function <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FESystem::system_to_component_index</a>, that for each local DoF index returns a pair of integers of which the first indicates to which component of the system the DoF belongs. The second integer of the pair indicates which index the DoF has in the scalar base finite element field, but this information is not relevant here. If you want to know more about this function and the underlying scheme behind primitive vector valued elements, take a look at <a class="el" href="step_8.html">step-8</a> or the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module, where these topics are explained in depth.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">  {</div></div><!-- fragment --><p>If both DoFs \(i\) and \(j\) belong to same component, i.e. their shape functions are both \(\phi\)'s or both \(\psi\)'s, the contribution will end up in one of the diagonal blocks in our system matrix, and since the corresponding entries are computed by the same formula, we do not bother if they actually are \(\phi\) or \(\psi\) shape functions. We can simply compute the entry by iterating over all quadrature points and adding up their contributions, where values and gradients of the shape functions are supplied by our <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div><div class="line">     ++q_point)</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">    (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)) *</div><div class="line">        (-omega * omega) +</div><div class="line">      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)) *</div><div class="line">        c * c) *</div><div class="line">     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div></div><!-- fragment --><p>You might think that we would have to specify which component of the shape function we'd like to evaluate when requesting shape function values or gradients from the <a class="el" href="classFEValues.html">FEValues</a> object. However, as the shape functions are primitive, they have only one nonzero component, and the <a class="el" href="classFEValues.html">FEValues</a> class is smart enough to figure out that we are definitely interested in this one nonzero component.</p>
<div class="fragment"><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>We also have to add contributions due to boundary terms. To this end, we loop over all faces of the current cell and see if first it is at the boundary, and second has the correct boundary indicator associated with \(\Gamma_2\), the part of the boundary where we have absorbing boundary conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">      (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div><div class="line">    {</div></div><!-- fragment --><p>These faces will certainly contribute to the off-diagonal blocks of the system matrix, so we ask the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object to provide us with the shape function values on this face:</p>
<div class="fragment"><div class="line">fe_face_values.reinit(cell, face_no);</div></div><!-- fragment --><p>Next, we loop through all DoFs of the current cell to find pairs that belong to different components and both have support on the current face_no:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">    <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">         fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face_no))</div></div><!-- fragment --><p>The check whether shape functions have support on a face is not strictly necessary: if we don't check for it we would simply add up terms to the local cell matrix that happen to be zero because at least one of the shape functions happens to be zero. However, we can save that work by adding the checks above.</p>
<p>In either case, these DoFs will contribute to the boundary integrals in the off-diagonal blocks of the system matrix. To compute the integral, we loop over all the quadrature points on the face and sum up the contribution weighted with the quadrature weights that the face quadrature rule provides. In contrast to the entries on the diagonal blocks, here it does matter which one of the shape functions is a \(\psi\) and which one is a \(\phi\), since that will determine the sign of the entry. We account for this by a simple conditional statement that determines the correct sign. Since we already checked that DoF \(i\) and \(j\) belong to different components, it suffices here to test for one of them to which component it belongs.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">             ++q_point)</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ? -1 :</div><div class="line">                                                            1) *</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) * c * omega *</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">}</div></div><!-- fragment --><p>Now we are done with this cell and have to transfer its contributions from the local to the global system matrix. To this end, we first get a list of the global indices of the this cells DoFs...</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>...and then add the entries to the system matrix one by one:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      system_matrix.add(local_dof_indices[i],</div><div class="line">                        local_dof_indices[j],</div><div class="line">                        cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>The only thing left are the Dirichlet boundary values on \(\Gamma_1\), which is characterized by the boundary indicator 1. The Dirichlet values are provided by the <code>DirichletBoundaryValues</code> class we defined above:</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsolvecode"></a> </p><h4><code>UltrasoundProblem::solve</code></h4>
<p>As already mentioned in the introduction, the system matrix is neither symmetric nor definite, and so it is not quite obvious how to come up with an iterative solver and a preconditioner that do a good job on this matrix. We chose instead to go a different way and solve the linear system with the sparse LU decomposition provided by UMFPACK. This is often a good first choice for 2D problems and works reasonably well even for a large number of DoFs. The deal.II interface to UMFPACK is given by the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, which is very easy to use and allows us to solve our linear system with just 3 lines of code.</p>
<p>Note again that for compiling this example program, you need to have the deal.II library built with UMFPACK support.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>The code to solve the linear system is short: First, we allocate an object of the right type. The following <code>initialize</code> call provides the matrix that we would like to invert to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object, and at the same time kicks off the LU-decomposition. Hence, this is also the point where most of the computational work in this program happens.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div></div><!-- fragment --><p>After the decomposition, we can use <code>A_direct</code> like a matrix representing the inverse of our system matrix, so to compute the solution we just have to multiply with the right hand side vector:</p>
<div class="fragment"><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemoutput_resultscode"></a> </p><h4><code>UltrasoundProblem::output_results</code></h4>
<p>Here we output our solution \(v\) and \(w\) as well as the derived quantity \(|u|\) in the format specified in the parameter file. Most of the work for deriving \(|u|\) from \(v\) and \(w\) was already done in the implementation of the <code>ComputeIntensity</code> class, so that the output routine is rather straightforward and very similar to what is done in the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>Define objects of our <code>ComputeIntensity</code> class and a <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line">ComputeIntensity&lt;dim&gt; intensities;</div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div></div><!-- fragment --><p>Next we query the output-related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. The <a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">DataOut::parse_parameters</a> call acts as a counterpart to the <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> call in <code>ParameterReader::declare_parameters</code>. It collects all the output format related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and sets the corresponding properties of the <a class="el" href="classDataOut.html">DataOut</a> object accordingly.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::string output_filename = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output filename&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Now we put together the filename from the base name provided by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and the suffix which is provided by the <a class="el" href="classDataOut.html">DataOut</a> class (the default suffix is set to the right type that matches the one set in the .prm file through parse_parameters()):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">std::ofstream output(filename);</div></div><!-- fragment --><p>The solution vectors \(v\) and \(w\) are added to the <a class="el" href="classDataOut.html">DataOut</a> object in the usual way:</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div></div><!-- fragment --><p>For the intensity, we just call <code>add_data_vector</code> again, but this with our <code>ComputeIntensity</code> object as the second argument, which effectively adds \(|u|\) to the output data:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, intensities);</div></div><!-- fragment --><p>The last steps are as before. Note that the actual output format is now determined by what is stated in the input file, i.e. one can change the output format without having to re-compile this program:</p>
<div class="fragment"><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemruncode"></a> </p><h4><code>UltrasoundProblem::run</code></h4>
<p>Here we simply execute our functions one after the other:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step29</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main</code> function</h4>
<p>Finally the <code>main</code> function of the program. It has the same structure as in almost all of the other tutorial programs. The only exception is that we define <a class="el" href="classParameterHandler.html">ParameterHandler</a> and <code>ParameterReader</code> objects, and let the latter read in the parameter values from a textfile called <code><a class="el" href="step_29.html">step-29</a>.prm</code>. The values so read are then handed over to an instance of the UltrasoundProblem class:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      ParameterReader  param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"></div><div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div><div class="line">      ultrasound_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The current program reads its run-time parameters from an input file called <code>step-29.prm</code> that looks like this: </p><div class="fragment"><div class="line">subsection Mesh &amp; geometry parameters</div><div class="line"><span class="preprocessor">  # Distance of the focal point of the lens to the x-axis</span></div><div class="line">  <span class="keyword">set</span> Focal distance        = 0.3</div><div class="line"></div><div class="line">  # Number of global mesh refinement steps applied to <a class="code" href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">initial</a> coarse grid</div><div class="line">  <span class="keyword">set</span> Number of refinements = 5</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line">subsection Physical constants</div><div class="line"><span class="preprocessor">  # Wave speed</span></div><div class="line">  <span class="keyword">set</span> c     = 1.5e5</div><div class="line"></div><div class="line"><span class="preprocessor">  # Frequency</span></div><div class="line">  <span class="keyword">set</span> omega = 3.0e7</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line">subsection Output parameters</div><div class="line"><span class="preprocessor">  # Name of the output file (without extension)</span></div><div class="line">  <span class="keyword">set</span> Output file   = solution</div><div class="line"></div><div class="line"><span class="preprocessor">  # A name for the output format to be used</span></div><div class="line">  <span class="keyword">set</span> Output format = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div></div><!-- fragment --><p>As can be seen, we set \(d=0.3\), which amounts to a focus of the transducer lens at \(x=0.5\), \(y=0.3\). The coarse mesh is refined 5 times, resulting in 160x160 cells, and the output is written in vtu format. The parameter reader understands many more parameters pertaining in particular to the generation of output, but we need none of these parameters here and therefore stick with their default values.</p>
<p>Here's the console output of the program in debug mode:</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Debug configuration</div><div class="line">Generating grid... done (0.820449s)</div><div class="line">  Number of active cells:  25600</div><div class="line">Setting up system... done (1.18392s)</div><div class="line">  Number of degrees of freedom: 51842</div><div class="line">Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (2.33291s)</div><div class="line">Solving linear system... done (1.34837s)</div><div class="line">Generating output... done (2.05782s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>(Of course, execution times will differ if you run the program locally.) The fact that most of the time is spent on assembling the system matrix and generating output is due to the many assertions that need to be checked in debug mode. In release mode these parts of the program run much faster whereas solving the linear system is hardly sped up at all:</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">Scanning dependencies of target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0144960s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.0356880s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0436570s)</div><div class="line">DEAL::Solving linear system... done (1.54733s)</div><div class="line">DEAL::Generating output... done (0.720528s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>The graphical output of the program looks as follows:</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.v.png" alt="v = Re(u)"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.w.png" alt="w = Im(u)"/>
</div>
   </td></tr>
<tr>
<td colspan="2"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.intensity.png" alt="|u|"/>
</div>
   </td></tr>
</table>
<p>The first two pictures show the real and imaginary parts of \(u\), whereas the last shows the intensity \(|u|\). One can clearly see that the intensity is focused around the focal point of the lens (0.5, 0.3), and that the focus is rather sharp in \(x\)-direction but more blurred in \(y\)-direction, which is a consequence of the geometry of the focusing lens, its finite aperture, and the wave nature of the problem.</p>
<p>Because colorful graphics are always fun, and to stress the focusing effects some more, here is another set of images highlighting how well the intensity is actually focused in \(x\)-direction:</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.surface.png" alt="|u|"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.contours.png" alt="|u|"/>
</div>
   </td></tr>
</table>
<p>As a final note, the structure of the program makes it easy to determine which parts of the program scale nicely as the mesh is refined and which parts don't. Here are the run times for 5, 6, and 7 global refinements:</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0135260s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.0213910s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0414300s)</div><div class="line">DEAL::Solving linear system... done (1.56621s)</div><div class="line">DEAL::Generating output... done (0.729605s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line"></div><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0668490s)</div><div class="line">DEAL::  Number of active cells:  102400</div><div class="line">DEAL::Setting up system... done (0.109694s)</div><div class="line">DEAL::  Number of degrees of freedom: 206082</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.160784s)</div><div class="line">DEAL::Solving linear system... done (7.86577s)</div><div class="line">DEAL::Generating output... done (2.89320s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line"></div><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.293154s)</div><div class="line">DEAL::  Number of active cells:  409600</div><div class="line">DEAL::Setting up system... done (0.491301s)</div><div class="line">DEAL::  Number of degrees of freedom: 821762</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.605386s)</div><div class="line">DEAL::Solving linear system... done (45.1989s)</div><div class="line">DEAL::Generating output... done (11.2292s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>Each time we refine the mesh once, so the number of cells and degrees of freedom roughly quadruples from each step to the next. As can be seen, generating the grid, setting up degrees of freedom, assembling the linear system, and generating output scale pretty closely to linear, whereas solving the linear system is an operation that requires 8 times more time each time the number of degrees of freedom is increased by a factor of 4, i.e. it is \({\cal O}(N^{3/2})\). This can be explained by the fact that (using optimal ordering) the bandwidth of a finite element matrix is \(B={\cal O}(N^{(dim-1)/dim})\), and the effort to solve a banded linear system using LU decomposition is \({\cal O}(BN)\). This also explains why the program does run in 3d as well (after changing the dimension on the <code>UltrasoundProblem</code> object), but scales very badly and takes extraordinary patience before it finishes solving the linear system on a mesh with appreciable resolution, even though all the other parts of the program scale very nicely.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>An obvious possible extension for this program is to run it in 3d &mdash; after all, the world around us is three-dimensional, and ultrasound beams propagate in three-dimensional media. You can try this by simply changing the template parameter of the principal class in <code>main()</code> and running it. This won't get you very far, though: certainly not if you do 5 global refinement steps as set in the parameter file. You'll simply run out of memory as both the mesh (with its \((2^5)^3 \cdot 5^3=2^{15}\cdot 125 \approx 4\cdot 10^6\) cells) and in particular the sparse direct solver take too much memory. You can solve with 3 global refinement steps, however, if you have a bit of time: in early 2011, the direct solve takes about half an hour. What you'll notice, however, is that the solution is completely wrong: the mesh size is simply not small enough to resolve the solution's waves accurately, and you can see this in plots of the solution. Consequently, this is one of the cases where adaptivity is indispensable if you don't just want to throw a bigger (presumably parallel) machine at the problem.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Moritz Allmaras, Texas A&amp;M University, 2007</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    DirichletBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                              Vector&lt;double&gt; &amp;values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), 2));</div><div class="line"></div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    vector_value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                      std::vector&lt;Vector&lt;double&gt;&gt; &amp;  value_list)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>              declare_parameters();</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">  };</div><div class="line"></div><div class="line">  ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">    : prm(paramhandler)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output filename&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                        <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div><div class="line">  {</div><div class="line">    declare_parameters();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComputeIntensity();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div><div class="line">                                     inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line"></div><div class="line">        computed_quantities[i](0) = std::abs(u);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>UltrasoundProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    Vector&lt;double&gt;       solution, system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div><div class="line">    : prm(param)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div><div class="line">      (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 5, 0, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">            ((face-&gt;center() - transducer).norm_square() &lt; 0.01))</div><div class="line">          {</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">            face-&gt;set_manifold_id(1);</div><div class="line">          }</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinements);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div><div class="line">                       n_face_q_points = face_quadrature_formula.size(),</div><div class="line">                       dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">                    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">                  {</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div><div class="line">                         ++q_point)</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)) *</div><div class="line">                            (-omega * omega) +</div><div class="line">                          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)) *</div><div class="line">                            c * c) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">              (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div><div class="line">            {</div><div class="line">              fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">                       fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face_no))</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                         ++q_point)</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ? -1 :</div><div class="line">                                                                        1) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) * c * omega *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       solution,</div><div class="line">                                       system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    ComputeIntensity&lt;dim&gt; intensities;</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string output_filename = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output filename&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, intensities);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step29</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      ParameterReader  param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"></div><div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div><div class="line">      ultrasound_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemsetting">Problem setting</a><a href="#Problemsetting">Problem setting</a>
        <li><a href="#Thetestcase">The test case</a><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDirichletBoundaryValuescodeclass">The <code>DirichletBoundaryValues</code> class</a><a href="#ThecodeDirichletBoundaryValuescodeclass">The <code>DirichletBoundaryValues</code> class</a>
        <li><a href="#ThecodeParameterReadercodeclass">The <code>ParameterReader</code> class</a><a href="#ThecodeParameterReadercodeclass">The <code>ParameterReader</code> class</a>
      <ul>
        <li><a href="#codeParameterReaderdeclare_parameterscode"><code>ParameterReader::declare_parameters</code></a><a href="#codeParameterReaderdeclare_parameterscode"><code>ParameterReader::declare_parameters</code></a>
        <li><a href="#codeParameterReaderread_parameterscode"><code>ParameterReader::read_parameters</code></a><a href="#codeParameterReaderread_parameterscode"><code>ParameterReader::read_parameters</code></a>
      </ul>
        <li><a href="#ThecodeComputeIntensitycodeclass">The <code>ComputeIntensity</code> class</a><a href="#ThecodeComputeIntensitycodeclass">The <code>ComputeIntensity</code> class</a>
        <li><a href="#ThecodeUltrasoundProblemcodeclass">The <code>UltrasoundProblem</code> class</a><a href="#ThecodeUltrasoundProblemcodeclass">The <code>UltrasoundProblem</code> class</a>
      <ul>
        <li><a href="#codeUltrasoundProblemmake_gridcode"><code>UltrasoundProblem::make_grid</code></a><a href="#codeUltrasoundProblemmake_gridcode"><code>UltrasoundProblem::make_grid</code></a>
        <li><a href="#codeUltrasoundProblemsetup_systemcode"><code>UltrasoundProblem::setup_system</code></a><a href="#codeUltrasoundProblemsetup_systemcode"><code>UltrasoundProblem::setup_system</code></a>
        <li><a href="#codeUltrasoundProblemassemble_systemcode"><code>UltrasoundProblem::assemble_system</code></a><a href="#codeUltrasoundProblemassemble_systemcode"><code>UltrasoundProblem::assemble_system</code></a>
        <li><a href="#codeUltrasoundProblemsolvecode"><code>UltrasoundProblem::solve</code></a><a href="#codeUltrasoundProblemsolvecode"><code>UltrasoundProblem::solve</code></a>
        <li><a href="#codeUltrasoundProblemoutput_resultscode"><code>UltrasoundProblem::output_results</code></a><a href="#codeUltrasoundProblemoutput_resultscode"><code>UltrasoundProblem::output_results</code></a>
        <li><a href="#codeUltrasoundProblemruncode"><code>UltrasoundProblem::run</code></a><a href="#codeUltrasoundProblemruncode"><code>UltrasoundProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em> This program was contributed by Moritz Allmaras at Texas A&amp;M University. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778. </em> <b>Note:</b> In order to run this program, deal.II must be configured to usethe UMFPACK sparse direct solver. Refer to the <a href="../../readme.html#umfpack">ReadMe</a> for instructions how to do this.</p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>A question that comes up frequently is how to solve problems involving complexvalued functions with deal.II. For many problems, instead of working withcomplex valued finite elements directly, it is often more convenient to split complex valuedfunctions into their real and imaginary parts and use separate scalar finiteelement fields for discretizing each one of them. Basically this amounts toviewing a single complex valued equation as a system of two real valuedequations. This short example demonstrates how this can be implemented indeal.II by using an <code>FE_system</code> object to stack two finite elementfields representing real and imaginary parts. (The opposite approach,keeping everything complex-valued, is demonstrated in a differenttutorial program: see <a class="el" href="step_58.html">step-58</a> for this.)When split into real and imaginary parts, the equations covered herefall into the class of vector-valued problems. A toplevel overview ofthis topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. In addition to this discussion, we also discuss the ParameterHandlerclass, which provides a convenient way for reading parameters from aconfiguration file at runtime without the need to recompile theprogram code.</p>
<p><a class="anchor" id="Problemsetting"></a></p><h3>Problem setting</h3>
<p>The original purpose of this program is to simulate the focusing propertiesof an ultrasound wave generated by a transducer lens with variablegeometry. Recent applications in medical imaging use ultrasound waves not onlyfor imaging purposes, but also to excite certain local effects in amaterial, like changes in optical properties, that can then be measured byother imaging techniques. A vital ingredient for these methods is the abilityto focus the intensity of the ultrasound wave in a particular part of thematerial, ideally in a point, to be able to examine the properties of thematerial at that particular location. To derive a model for this problem, we think of ultrasound as a pressure wavegoverned by the wave equation: </p><p class="formulaDsp">
\[ \frac{\partial^2 U}{\partial t^2} - c^2 \Delta U = 0 \]
</p>
<p> \(c\) is the wave speed (that for simplicity we assume to be constant), \(U = U(x,t),\;x \in \Omega,\;t\in\mathrm{R}\) . The boundary \(\Gamma=\partial\Omega\) is divided into two parts \(\Gamma_1\) and \(\Gamma_2=\Gamma\setminus\Gamma_1\) , with \(\Gamma_1\) representing thetransducer lens and \(\Gamma_2\) an absorbing boundary (that is, we want tochoose boundary conditions on \(\Gamma_2\) in such a way that they imitate alarger domain). On \(\Gamma_1\) , the transducer generates a wave of constantfrequency \({\omega}&gt;0\) and constant amplitude (that we chose to be 1 here): </p><p class="formulaDsp">
\[ U(x,t) = \cos{\omega t}, \qquad x\in \Gamma_1 \]
</p>
<p> If there are no other (interior or boundary) sources, and since the onlysource has frequency \(\omega\) , then the solution admits a separation ofvariables of the form \(U(x,t) = \textrm{Re}\left(u(x)\,e^{i\omega t})\right)\) . The complex-valued function \(u(x)\) describes the spatialdependency of amplitude and phase (relative to the source) of the waves offrequency \({\omega}\) , with the amplitude being the quantity that we areinterested in. By plugging this form of the solution into the wave equation,we see that for \(u\) we have </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u(x) - c^2\Delta u(x) &amp;=&amp; 0, \qquad x\in\Omega,\\ u(x) &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p>For finding suitable conditions on \(\Gamma_2\) that model an absorbingboundary, consider a wave of the form \(V(x,t)=e^{i(k\cdot x -\omega t)}\) withfrequency \({\omega}\) traveling in direction \(k\in {\mathrm{R}^2}\) . In orderfor \(V\) to solve the wave equation, \(|k|={\frac{\omega}{c}}\) musthold. Suppose that this wave hits the boundary in \(x_0\in\Gamma_2\) at a rightangle, i.e. \(n=\frac{k}{|k|}\) with \(n\) denoting the outer unit normal of \(\Omega\) in \(x_0\) . Then at \(x_0\) , this wave satisfies the equation </p><p class="formulaDsp">
\[ c (n\cdot\nabla V) + \frac{\partial V}{\partial t} = (i\, c\, |k| - i\, \omega) V = 0. \]
</p>
<p>, by enforcing the boundary condition </p><p class="formulaDsp">
\[ c (n\cdot\nabla U) + \frac{\partial U}{\partial t} = 0, \qquad x\in\Gamma_2, \]
</p>
<p> that hit the boundary \(\Gamma_2\) at a right angle will be perfectlyabsorbed. On the other hand, those parts of the wave field that do not hit aboundary at a right angle do not satisfy this condition and enforcing it as aboundary condition will yield partial reflections, i.e. only parts of the wavewill pass through the boundary as if it wasn't here whereas the remainingfraction of the wave will be reflected back into the domain. If we are willing to accept this as a sufficient approximation to an absorbingboundary we finally arrive at the following problem for \(u\) : </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u - c^2\Delta u &amp;=&amp; 0, \qquad x\in\Omega,\\ c (n\cdot\nabla u) + i\,\omega\,u &amp;=&amp;0, \qquad x\in\Gamma_2,\\ u &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p> This is a Helmholtz equation (similar to the one in <a class="el" href="step_7.html">step-7</a> , but this time with''the bad sign'') with Dirichlet data on \(\Gamma_1\) and mixed boundaryconditions on \(\Gamma_2\) . Because of the condition on \(\Gamma_2\) , we cannot justtreat the equations for real and imaginary parts of \(u\) separately. What we cando however is to view the PDE for \(u\) as a system of two PDEs for the real andimaginary parts of \(u\) , with the boundary condition on \(\Gamma_2\) representingthe coupling terms between the two components of the system. This works alongthe following lines: Let \(v=\textrm{Re}\;u,\; w=\textrm{Im}\;u\) , then in termsof \(v\) and \(w\) we have the following system: </p><p class="formulaDsp">
\begin{eqnarray*} \left.\begin{array}{ccc} -\omega^2 v - c^2\Delta v &amp;=&amp; 0 \quad\\ -\omega^2 w - c^2\Delta w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Omega, \\ \left.\begin{array}{ccc} c (n\cdot\nabla v) - \omega\,w &amp;=&amp; 0 \quad\\ c (n\cdot\nabla w) + \omega\,v &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_2, \\ \left.\begin{array}{ccc} v &amp;=&amp; 1 \quad\\ w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_1. \end{eqnarray*}
</p>
<p>For test functions \(\phi,\psi\) with \(\phi|_{\Gamma_1}=\psi|_{\Gamma_1}=0\) , afterthe usual multiplication, integration over \(\Omega\) and applying integration byparts, we get the weak formulation </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 \langle \phi, v \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi, \nabla v \rangle_{\mathrm{L}^2(\Omega)} - c \omega \langle \phi, w \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0, \\ -\omega^2 \langle \psi, w \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi, \nabla w \rangle_{\mathrm{L}^2(\Omega)} + c \omega \langle \psi, v \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>We choose finite element spaces \(V_h\) and \(W_h\) with bases \(\{\phi_j\}_{j=1}^n, \{\psi_j\}_{j=1}^n\) and look for approximate solutions </p><p class="formulaDsp">
\[ v_h = \sum_{j=1}^n \alpha_j \phi_j, \;\; w_h = \sum_{j=1}^n \beta_j \psi_j. \]
</p>
<p> into the variational form yields the equation system </p><p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left.\begin{array}{ccc} \sum_{j=1}^n \left( -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} \right) \alpha_j - \left( c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)}\right)\beta_j &amp;=&amp; 0 \\ \sum_{j=1}^n \left( -\omega^2 \langle \psi_i, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_i, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \right)\beta_j + \left( c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \right)\alpha_j &amp;=&amp; 0 \end{array}\right\}\;\;\forall\; i =1,\ldots,n. \]
</p>
<p> matrix notation: </p><p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left( \begin{array}{cc} -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} &amp; -c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \\ c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} &amp; -\omega^2 \langle \psi_{i}, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_{i}, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \end{array} \right) \left( \begin{array}{c} \alpha \\ \beta \end{array} \right) = \left( \begin{array}{c} 0 \\ 0 \end{array} \right) \]
</p>
<p>(One should not be fooled by the right hand side being zero here, that isbecause we haven't included the Dirichlet boundary data yet.)Because of the alternating sign in the off-diagonal blocks, we can alreadysee that this system is non-symmetric, in fact it is even indefinite.Of course, there is no necessity to choose the spaces \(V_h\) and \(W_h\) to bethe same. However, we expect real and imaginary part of the solution tohave similar properties and will therefore indeed take \(V_h=W_h\) in theimplementation, and also use the same basis functions \(\phi_i = \psi_i\) forboth spaces. The reason for the notation using different symbols is just thatit allows us to distinguish between shape functions for \(v\) and \(w\) , as thisdistinction plays an important role in the implementation.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>For the computations, we will consider wave propagation in the unit square,with ultrasound generated by a transducer lens that is shaped like a segmentof the circle with center at \((0.5, d)\) and aradius slightly greater than \(d\) ; this shape should lead to a focusing of the soundwave at the center of the circle. Varying \(d\) changes the "focus" of the lensand affects the spatial distribution of the intensity of \(u\) , where our mainconcern is how well \(|u|=\sqrt{v^2+w^2}\) is focused. In the program below, we will implement the complex-valued Helmholtz equationsusing the formulation with split real and imaginary parts. We will alsodiscuss how to generate a domain that looks like a square with a slight bulgesimulating the transducer (in the <code>UltrasoundProblem&lt;dim&gt;::make_grid()</code> function), and how togenerate graphical output that not only contains the solution components \(v\) and \(w\) , but also the magnitude \(\sqrt{v^2+w^2}\) directly in the output file (in <code>UltrasoundProblem&lt;dim&gt;::output_results()</code> ). Finally, we use theParameterHandler class to easily read parameters like the focal distance \(d\) ,wave speed \(c\) , frequency \(\omega\) , and a number of other parameters from aninput file at run-time, rather than fixing those parameters in the source codewhere we would have to re-compile every time we want to change parameters.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following header files have all been discussed before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>This header file contains the necessary declarations for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class that we will use to read our parameters from a configuration file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div></div><!-- fragment --><p>For solving the linear system, we'll use the sparse LU-decomposition provided by UMFPACK (see the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class), for which the following header file is needed. Note that in order to compile this tutorial program, the deal.II-library needs to be built with UMFPACK support, which is enabled by default:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div></div><!-- fragment --><p>The <a class="el" href="classFESystem.html">FESystem</a> class allows us to stack several FE-objects to one compound, vector-valued finite element field. The necessary declarations for this class are provided in this header file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, include the header file that declares the <a class="el" href="classTimer.html">Timer</a> class that we will use to determine how much time each of the operations of our program takes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div></div><!-- fragment --><p>As the last step at the beginning of this program, we put everything that is in this program into its namespace and, within it, make everything that is in the deal.II namespace globally available, without the need to prefix everything with <code>dealii</code><code>::</code> :</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDirichletBoundaryValuescodeclass"></a> </p><h3>The <code>DirichletBoundaryValues</code> class</h3>
<p>First we define a class for the function representing the Dirichlet boundary values. This has been done many times before and therefore does not need much explanation. Since there are two values \(v\) and \(w\) that need to be prescribed at the boundary, we have to tell the base class that this is a vector-valued function with two components, and the <code>vector_value</code> function and its cousin <code>vector_value_list</code> must return vectors with two entries. In our case the function is very simple, it just returns 1 for the real part \(v\) and 0 for the imaginary part \(w\) regardless of the point where it is evaluated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DirichletBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 2));</div><div class="line"></div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;  value_list)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeParameterReadercodeclass"></a> </p><h3>The <code>ParameterReader</code> class</h3>
<p>The next class is responsible for preparing the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and reading parameters from an input file. It includes a function <code>declare_parameters</code> that declares all the necessary parameters and a <code>read_parameters</code> function that is called from outside to initiate the parameter reading process.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>              declare_parameters();</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">};</div></div><!-- fragment --><p>The constructor stores a reference to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to it:</p>
<div class="fragment"><div class="line">ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">  : prm(paramhandler)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderdeclare_parameterscode"></a> </p><h4><code>ParameterReader::declare_parameters</code></h4>
<p>The <code>declare_parameters</code> function declares all the parameters that our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will be able to read from input files, along with their types, range conditions and the subsections they appear in. We will wrap all the entries that go into a section in a pair of braces to force the editor to indent them by one level, making it simpler to read which entries together form a section:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">{</div></div><!-- fragment --><p>Parameters for mesh and geometry include the number of global refinement steps that are applied to the initial coarse mesh and the focal distance \(d\) of the transducer lens. For the number of refinement steps, we allow integer values in the range \([0,\infty)\) , where the omitted second argument to the <a class="el" href="classPatterns_1_1Integer.html">Patterns::Integer</a> object denotes the half-open interval. For the focal distance any number greater than zero is accepted:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>The next subsection is devoted to the physical parameters appearing in the equation, which are the frequency \(\omega\) and wave speed \(c\) . Again, both need to lie in the half-open interval \([0,\infty)\) represented by calling the <a class="el" href="classPatterns_1_1Double.html">Patterns::Double</a> class with only the left end-point as argument:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Last but not least we would like to be able to change some properties of the output, like filename and format, through entries in the configuration file, which is the purpose of the last subsection:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output filename&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div></div><!-- fragment --><p>Since different output formats may require different parameters for generating output (like for example, postscript output needs viewpoint angles, line widths, colors etc), it would be cumbersome if we had to declare all these parameters by hand for every possible output format supported in the library. Instead, each output format has a <code>FormatFlags::declare_parameters</code> function, which declares all the parameters specific to that format in an own subsection. The following call of <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> executes <code>declare_parameters</code> for all available output formats, so that for each format an own subsection will be created with parameters declared for that particular output format. (The actual value of the template parameter in the call, <code>&lt;1&gt;</code> above, does not matter here: the function does the same work independent of the dimension, but happens to be in a template-parameter-dependent class.) To find out what parameters there are for which output format, you can either consult the documentation of the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class, or simply run this program without a parameter file present. It will then create a file with all declared parameters set to their default values, which can conveniently serve as a starting point for setting the parameters to the values you desire.</p>
<div class="fragment"><div class="line">    <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderread_parameterscode"></a> </p><h4><code>ParameterReader::read_parameters</code></h4>
<p>This is the main function in the ParameterReader class. It gets called from outside, first declares all the parameters, and then reads them from the input file whose filename is provided by the caller. After the call to this function is complete, the <code>prm</code> object can be used to retrieve the values of the parameters read in from the file :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div><div class="line">{</div><div class="line">  declare_parameters();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeComputeIntensitycodeclass"></a> </p><h3>The <code>ComputeIntensity</code> class</h3>
<p>As mentioned in the introduction, the quantity that we are really after is the spatial distribution of the intensity of the ultrasound wave, which corresponds to \(|u|=\sqrt{v^2+w^2}\) . Now we could just be content with having \(v\) and \(w\) in our output, and use a suitable visualization or postprocessing tool to derive \(|u|\) from the solution we computed. However, there is also a way to output data derived from the solution in deal.II, and we are going to make use of this mechanism here.</p>
<p>So far we have always used the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> function to add vectors containing output data to a <a class="el" href="classDataOut.html">DataOut</a> object. There is a special version of this function that in addition to the data vector has an additional argument of type <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. What happens when this function is used for output is that at each point where output data is to be generated, the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> function of the specified <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object is invoked to compute the output quantities from the values, the gradients and the second derivatives of the finite element function represented by the data vector (in the case of face related data, normal vectors are available as well). Hence, this allows us to output any quantity that can locally be derived from the values of the solution and its derivatives. Of course, the ultrasound intensity \(|u|\) is such a quantity and its computation doesn't even involve any derivatives of \(v\) or \(w\) .</p>
<p>In practice, the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class only provides an interface to this functionality, and we need to derive our own class from it in order to implement the functions specified by the interface. In the most general case one has to implement several member functions but if the output quantity is a single scalar then some of this boilerplate code can be handled by a more specialized class, <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and we can derive from that one instead. This is what the <code>ComputeIntensity</code> class does:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ComputeIntensity();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>In the constructor, we need to call the constructor of the base class with two arguments. The first denotes the name by which the single scalar quantity computed by this class should be represented in output files. In our case, the postprocessor has \(|u|\) as output, so we use "Intensity". The second argument is a set of flags that indicate which data is needed by the postprocessor in order to compute the output quantities. This can be any subset of update_values, update_gradients and update_hessians (and, in the case of face data, also update_normal_vectors), which are documented in UpdateFlags. Of course, computation of the derivatives requires additional resources, so only the flags for data that are really needed should be given here, just as we do when we use <a class="el" href="classFEValues.html">FEValues</a> objects. In our case, only the function values of \(v\) and \(w\) are needed to compute \(|u|\) , so we're good with the update_values flag.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div><div class="line">  : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">{}</div></div><!-- fragment --><p>The actual postprocessing happens in the following function. Its input is an object that stores values of the function (which is here vector-valued) representing the data vector given to <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a>, evaluated at all evaluation points where we generate output, and some tensor objects representing derivatives (that we don't use here since \(|u|\) is computed from just \(v\) and \(w\) ). The derived quantities are returned in the <code>computed_quantities</code> vector. Remember that this function may only use data for which the respective update flag is specified by <code>get_needed_update_flags</code> . For example, we may not use the derivatives here, since our implementation of <code>get_needed_update_flags</code> requests that only function values are provided.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                              inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div></div><!-- fragment --><p>The computation itself is straightforward: We iterate over each entry in the output vector and compute \(|u|\) from the corresponding values of \(v\) and \(w\) . We do this by creating a complex number \(u\) and then calling <code><a class="el" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">std::abs()</a></code> on the result. (One may be tempted to call <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code>, but in a historical quirk, the C++ committee decided that <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code> should return the <em>square</em> of the absolute value</p>
<ul>
<li>thereby not satisfying the properties mathematicians require of something called a "norm".)</li>
</ul>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div><div class="line">                                   inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line"></div><div class="line">      computed_quantities[i](0) = std::abs(u);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeUltrasoundProblemcodeclass"></a> </p><h3>The <code>UltrasoundProblem</code> class</h3>
<p>Finally here is the main class of this program. It's member functions are very similar to the previous examples, in particular <a class="el" href="step_4.html">step-4</a> , and the list of member variables does not contain any major surprises either. The <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to the constructor is stored as a reference to allow easy access to the parameters from all functions of the class. Since we are working with vector valued finite elements, the FE object we are using is of type <a class="el" href="classFESystem.html">FESystem</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>UltrasoundProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution, system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>The constructor takes the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and stores it in a reference. It also initializes the DoF-Handler and the finite element system, which consists of two copies of the scalar Q1 field, one for \(v\) and one for \(w\) :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div><div class="line">  : prm(param)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemmake_gridcode"></a> </p><h4><code>UltrasoundProblem::make_grid</code></h4>
<p>Here we setup the grid for our domain. As mentioned in the exposition, the geometry is just a unit square (in 2d) with the part of the boundary that represents the transducer lens replaced by a sector of a circle.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div></div><!-- fragment --><p>First we generate some logging output and start a timer so we can compute execution time when this function is done:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>Then we query the values for the focal distance of the transducer lens and the number of mesh refinement steps from our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Next, two points are defined for position and focal point of the transducer lens, which is the center of the circle whose segment will form the transducer part of the boundary. Notice that this is the only point in the program where things are slightly different in 2D and 3D. Even though this tutorial only deals with the 2D case, the necessary additions to make this program functional in 3D are so minimal that we opt for including them:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div><div class="line">  (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div></div><!-- fragment --><p>As initial coarse grid we take a simple unit square with 5 subdivisions in each direction. The number of subdivisions is chosen so that the line segment \([0.4,0.6]\) that we want to designate as the transducer boundary is spanned by a single face. Then we step through all cells to find the faces where the transducer is to be located, which in fact is just the single edge from 0.4 to 0.6 on the x-axis. This is where we want the refinements to be made according to a circle shaped boundary, so we mark this edge with a different manifold indicator. Since we will Dirichlet boundary conditions on the transducer, we also change its boundary indicator.</p>
<div class="fragment"><div class="line">     <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 5, 0, 1);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">         <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">             ((face-&gt;center()</div><div class="line">  </div><div class="line">- transducer).norm_square() &lt; 0.01))</div><div class="line">           {</div><div class="line">             face-&gt;set_boundary_id(1);</div><div class="line">             face-&gt;set_manifold_id(1);</div><div class="line">           }</div></div><!-- fragment --><p>For the circle part of the transducer lens, a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object is used (which, of course, in 2D just represents a circle), with center computed as above.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div></div><!-- fragment --><p>Now global refinement is executed. Cells near the transducer location will be automatically refined according to the circle shaped boundary of the transducer lens:</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinements);</div></div><!-- fragment --><p>Lastly, we generate some more logging output. We stop the timer and query the number of CPU seconds elapsed since the beginning of the function:</p>
<div class="fragment"><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsetup_systemcode"></a> </p><h4><code>UltrasoundProblem::setup_system</code></h4>
<p>Initialization of the system matrix, sparsity patterns and vectors are the same as in previous examples and therefore do not need further comment. As in the previous function, we also output the run time of what we do here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemassemble_systemcode"></a> </p><h4><code>UltrasoundProblem::assemble_system</code></h4>
<p>As before, this function takes care of assembling the system matrix and right hand side vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>First we query wavespeed and frequency from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and store them in local variables, as they will be used frequently throughout this function.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>As usual, for computing integrals ordinary Gauss quadrature rule is used. Since our bilinear form involves boundary integrals on \(\Gamma_2\) , we also need a quadrature rule for surface integration on the faces, which are \(dim-1\) dimensional:</p>
<div class="fragment"><div class="line">     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">     <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div><div class="line">                        n_face_q_points = face_quadrature_formula.size(),</div><div class="line">                        dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div></div><!-- fragment --><p>The <a class="el" href="classFEValues.html">FEValues</a> objects will evaluate the shape functions for us. For the part of the bilinear form that involves integration on \(\Omega\) , we'll need the values and gradients of the shape functions, and of course the quadrature weights. For the terms involving the boundary integrals, only shape function values and the quadrature weights are necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                 face_quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>As usual, the system matrix is assembled cell by cell, and we need a matrix for storing the local cell contributions as well as an index vector to transfer the cell contributions to the appropriate location in the global system matrix after.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><p>On each cell, we first need to reset the local contribution matrix and request the <a class="el" href="classFEValues.html">FEValues</a> object to compute the shape functions for the current cell:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div></div><!-- fragment --><p>At this point, it is important to keep in mind that we are dealing with a finite element system with two components. Due to the way we constructed this <a class="el" href="classFESystem.html">FESystem</a>, namely as the Cartesian product of two scalar finite element fields, each shape function has only a single nonzero component (they are, in deal.II lingo, <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>). Hence, each shape function can be viewed as one of the \(\phi\) 's or \(\psi\) 's from the introduction, and similarly the corresponding degrees of freedom can be attributed to either \(\alpha\) or \(\beta\) . As we iterate through all the degrees of freedom on the current cell however, they do not come in any particular order, and so we cannot decide right away whether the DoFs with index \(i\) and \(j\) belong to the real or imaginary part of our solution. On the other hand, if you look at the form of the system matrix in the introduction, this distinction is crucial since it will determine to which block in the system matrix the contribution of the current pair of DoFs will go and hence which quantity we need to compute from the given two shape functions. Fortunately, the <a class="el" href="classFESystem.html">FESystem</a> object can provide us with this information, namely it has a function <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FESystem::system_to_component_index</a>, that for each local DoF index returns a pair of integers of which the first indicates to which component of the system the DoF belongs. The second integer of the pair indicates which index the DoF has in the scalar base finite element field, but this information is not relevant here. If you want to know more about this function and the underlying scheme behind primitive vector valued elements, take a look at <a class="el" href="step_8.html">step-8</a> or the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module, where these topics are explained in depth.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">  {</div></div><!-- fragment --><p>If both DoFs \(i\) and \(j\) belong to same component, i.e. their shape functions are both \(\phi\) 's or both \(\psi\) 's, the contribution will end up in one of the diagonal blocks in our system matrix, and since the corresponding entries are computed by the same formula, we do not bother if they actually are \(\phi\) or \(\psi\) shape functions. We can simply compute the entry by iterating over all quadrature points and adding up their contributions, where values and gradients of the shape functions are supplied by our <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div><div class="line">     ++q_point)</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">    (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point))</div><div class="line">        (-omega omega) +</div><div class="line">      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point)</div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point))</div><div class="line">        c c)</div><div class="line">     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div></div><!-- fragment --><p>You might think that we would have to specify which component of the shape function we'd like to evaluate when requesting shape function values or gradients from the <a class="el" href="classFEValues.html">FEValues</a> object. However, as the shape functions are primitive, they have only one nonzero component, and the <a class="el" href="classFEValues.html">FEValues</a> class is smart enough to figure out that we are definitely interested in this one nonzero component.</p>
<div class="fragment"><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>We also have to add contributions due to boundary terms. To this end, we loop over all faces of the current cell and see if first it is at the boundary, and second has the correct boundary indicator associated with \(\Gamma_2\) , the part of the boundary where we have absorbing boundary conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">      (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div><div class="line">    {</div></div><!-- fragment --><p>These faces will certainly contribute to the off-diagonal blocks of the system matrix, so we ask the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object to provide us with the shape function values on this face:</p>
<div class="fragment"><div class="line">fe_face_values.reinit(cell, face_no);</div></div><!-- fragment --><p>Next, we loop through all DoFs of the current cell to find pairs that belong to different components and both have support on the current face_no:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">    <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">         fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face_no))</div></div><!-- fragment --><p>The check whether shape functions have support on a face is not strictly necessary: if we don't check for it we would simply add up terms to the local cell matrix that happen to be zero because at least one of the shape functions happens to be zero. However, we can save that work by adding the checks above.</p>
<p>In either case, these DoFs will contribute to the boundary integrals in the off-diagonal blocks of the system matrix. To compute the integral, we loop over all the quadrature points on the face and sum up the contribution weighted with the quadrature weights that the face quadrature rule provides. In contrast to the entries on the diagonal blocks, here it does matter which one of the shape functions is a \(\psi\) and which one is a \(\phi\) , since that will determine the sign of the entry. We account for this by a simple conditional statement that determines the correct sign. Since we already checked that DoF \(i\) and \(j\) belong to different components, it suffices here to test for one of them to which component it belongs.</p>
<div class="fragment"><div class="line">                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                          ++q_point)</div><div class="line">                       <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                         ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ?</div><div class="line">  </div><div class="line">-1 :</div><div class="line">                                                                         1)</div><div class="line">                         fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">                         fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) c omega</div><div class="line">                         fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">             }</div></div><!-- fragment --><p>Now we are done with this cell and have to transfer its contributions from the local to the global system matrix. To this end, we first get a list of the global indices of the this cells DoFs...</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>...and then add the entries to the system matrix one by one:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      system_matrix.add(local_dof_indices[i],</div><div class="line">                        local_dof_indices[j],</div><div class="line">                        cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>The only thing left are the Dirichlet boundary values on \(\Gamma_1\) , which is characterized by the boundary indicator 1. The Dirichlet values are provided by the <code>DirichletBoundaryValues</code> class we defined above:</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsolvecode"></a> </p><h4><code>UltrasoundProblem::solve</code></h4>
<p>As already mentioned in the introduction, the system matrix is neither symmetric nor definite, and so it is not quite obvious how to come up with an iterative solver and a preconditioner that do a good job on this matrix. We chose instead to go a different way and solve the linear system with the sparse LU decomposition provided by UMFPACK. This is often a good first choice for 2D problems and works reasonably well even for a large number of DoFs. The deal.II interface to UMFPACK is given by the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, which is very easy to use and allows us to solve our linear system with just 3 lines of code.</p>
<p>Note again that for compiling this example program, you need to have the deal.II library built with UMFPACK support.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>The code to solve the linear system is short: First, we allocate an object of the right type. The following <code>initialize</code> call provides the matrix that we would like to invert to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object, and at the same time kicks off the LU-decomposition. Hence, this is also the point where most of the computational work in this program happens.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div></div><!-- fragment --><p>After the decomposition, we can use <code>A_direct</code> like a matrix representing the inverse of our system matrix, so to compute the solution we just have to multiply with the right hand side vector:</p>
<div class="fragment"><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemoutput_resultscode"></a> </p><h4><code>UltrasoundProblem::output_results</code></h4>
<p>Here we output our solution \(v\) and \(w\) as well as the derived quantity \(|u|\) in the format specified in the parameter file. Most of the work for deriving \(|u|\) from \(v\) and \(w\) was already done in the implementation of the <code>ComputeIntensity</code> class, so that the output routine is rather straightforward and very similar to what is done in the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>Define objects of our <code>ComputeIntensity</code> class and a <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line">ComputeIntensity&lt;dim&gt; intensities;</div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div></div><!-- fragment --><p>Next we query the output-related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. The <a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">DataOut::parse_parameters</a> call acts as a counterpart to the <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> call in <code>ParameterReader::declare_parameters</code> . It collects all the output format related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and sets the corresponding properties of the <a class="el" href="classDataOut.html">DataOut</a> object accordingly.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::string output_filename = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output filename&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Now we put together the filename from the base name provided by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and the suffix which is provided by the <a class="el" href="classDataOut.html">DataOut</a> class (the default suffix is set to the right type that matches the one set in the .prm file through parse_parameters()):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">std::ofstream output(filename);</div></div><!-- fragment --><p>The solution vectors \(v\) and \(w\) are added to the <a class="el" href="classDataOut.html">DataOut</a> object in the usual way:</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div></div><!-- fragment --><p>For the intensity, we just call <code>add_data_vector</code> again, but this with our <code>ComputeIntensity</code> object as the second argument, which effectively adds \(|u|\) to the output data:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, intensities);</div></div><!-- fragment --><p>The last steps are as before. Note that the actual output format is now determined by what is stated in the input file, i.e. one can change the output format without having to re-compile this program:</p>
<div class="fragment"><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemruncode"></a> </p><h4><code>UltrasoundProblem::run</code></h4>
<p>Here we simply execute our functions one after the other:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step29</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main</code> function</h4>
<p>Finally the <code>main</code> function of the program. It has the same structure as in almost all of the other tutorial programs. The only exception is that we define <a class="el" href="classParameterHandler.html">ParameterHandler</a> and <code>ParameterReader</code> objects, and let the latter read in the parameter values from a textfile called <code><a class="el" href="step_29.html">step-29</a>.prm</code> . The values so read are then handed over to an instance of the UltrasoundProblem class:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"> </div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      ParameterReader  param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"> </div><div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div><div class="line">      ultrasound_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The current program reads its run-time parameters from an input filecalled <code>step-29.prm</code> that looks like this: </p><div class="fragment"><div class="line">subsection Mesh &amp; geometry parameters</div><div class="line"><span class="preprocessor">  # Distance of the focal point of the lens to the x-axis</span></div><div class="line">  <span class="keyword">set</span> Focal distance        = 0.3</div><div class="line">  </div><div class="line"><span class="preprocessor">  # Number of global mesh refinement steps applied to initial coarse grid</span></div><div class="line">  <span class="keyword">set</span> Number of refinements = 5</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">subsection Physical constants</div><div class="line"><span class="preprocessor">  # Wave speed</span></div><div class="line">  <span class="keyword">set</span> c     = 1.5e5</div><div class="line">  </div><div class="line"><span class="preprocessor">  # Frequency</span></div><div class="line">  <span class="keyword">set</span> omega = 3.0e7</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">subsection Output parameters</div><div class="line"><span class="preprocessor">  # Name of the output file (without extension)</span></div><div class="line">  <span class="keyword">set</span> Output file   = solution</div><div class="line">  </div><div class="line"><span class="preprocessor">  # A name for the output format to be used</span></div><div class="line">  <span class="keyword">set</span> Output format = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div></div><!-- fragment --><p>As can be seen, we set \(d=0.3\) , which amounts to a focus of the transducer lensat \(x=0.5\) , \(y=0.3\) . The coarse mesh is refined 5 times,resulting in 160x160 cells, and the output is written in vtuformat. The parameter reader understands many more parameterspertaining in particular to the generation of output, but weneed none of these parameters here and therefore stick withtheir default values. Here's the console output of the program in debug mode: </p><div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Debug configuration</div><div class="line">Generating grid... done (0.820449s)</div><div class="line">  Number of active cells:  25600</div><div class="line">Setting up system... done (1.18392s)</div><div class="line">  Number of degrees of freedom: 51842</div><div class="line">Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (2.33291s)</div><div class="line">Solving linear system... done (1.34837s)</div><div class="line">Generating output... done (2.05782s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>(Of course, execution times will differ if you run the programlocally.) The fact that most of the time is spent on assemblingthe system matrix and generating output is due to the many assertionsthat need to be checked in debug mode. In release mode these partsof the program run much faster whereas solving the linear system ishardly sped up at all: </p><div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">Scanning dependencies of target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0144960s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.0356880s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0436570s)</div><div class="line">DEAL::Solving linear system... done (1.54733s)</div><div class="line">DEAL::Generating output... done (0.720528s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>The graphical output of the program looks as follows:</p>
<pre class="fragment">&lt;table align="center" class="doxtable"&gt;
</pre> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.v.png" alt="v = Re(u)"/>
</div>
  <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.w.png" alt="w = Im(u)"/>
</div>
   <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.intensity.png" alt="|u|"/>
</div>
   <p>The first two pictures show the real and imaginary parts of \(u\) , whereas the last shows the intensity \(|u|\) . One can clearlysee that the intensity is focused around the focal point of thelens (0.5, 0.3), and that the focusis rather sharp in \(x\) -direction but more blurred in \(y\) -direction, which is aconsequence of the geometry of the focusing lens, its finite aperture,and the wave nature of the problem. Because colorful graphics are always fun, and to stress the focusingeffects some more, here is another set of images highlighting how wellthe intensity is actually focused in \(x\) -direction: </p><table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.surface.png" alt="|u|"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.contours.png" alt="|u|"/>
</div>
   </td></tr>
</table>
<p>As a final note, the structure of the program makes it easy todetermine which parts of the program scale nicely as the mesh isrefined and which parts don't. Here are the run times for 5, 6, and 7global refinements: </p><div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0135260s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.0213910s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0414300s)</div><div class="line">DEAL::Solving linear system... done (1.56621s)</div><div class="line">DEAL::Generating output... done (0.729605s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">  </div><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0668490s)</div><div class="line">DEAL::  Number of active cells:  102400</div><div class="line">DEAL::Setting up system... done (0.109694s)</div><div class="line">DEAL::  Number of degrees of freedom: 206082</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.160784s)</div><div class="line">DEAL::Solving linear system... done (7.86577s)</div><div class="line">DEAL::Generating output... done (2.89320s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">  </div><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.293154s)</div><div class="line">DEAL::  Number of active cells:  409600</div><div class="line">DEAL::Setting up system... done (0.491301s)</div><div class="line">DEAL::  Number of degrees of freedom: 821762</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.605386s)</div><div class="line">DEAL::Solving linear system... done (45.1989s)</div><div class="line">DEAL::Generating output... done (11.2292s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>Each time we refine the mesh once, so the number of cells and degreesof freedom roughly quadruples from each step to the next. As can be seen,generating the grid, setting up degrees of freedom, assembling thelinear system, and generating output scale pretty closely to linear,whereas solving the linear system is an operation that requires 8times more time each time the number of degrees of freedom isincreased by a factor of 4, i.e. it is \({\cal O}(N^{3/2})\) . This canbe explained by the fact that (using optimal ordering) thebandwidth of a finite element matrix is \(B={\cal O}(N^{(dim-1)/dim})\) ,and the effort to solve a banded linear system using LU decompositionis \({\cal O}(BN)\) . This also explains why the program does run in 3das well (after changing the dimension on the <code>UltrasoundProblem</code> object), but scales very badly andtakes extraordinary patience before it finishes solving the linearsystem on a mesh with appreciable resolution, even though all theother parts of the program scale very nicely.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>An obvious possible extension for this program is to run it in 3d&mdash; after all, the world around us is three-dimensional, andultrasound beams propagate in three-dimensional media. You can trythis by simply changing the template parameter of the principal classin <code>main()</code> and running it. This won't get you very far,though: certainly not if you do 5 global refinement steps as set inthe parameter file. You'll simply run out of memory as both the mesh(with its \((2^5)^3 \cdot 5^3=2^{15}\cdot 125 \approx 4\cdot 10^6\) cells)and in particular the sparse direct solver take too much memory. Youcan solve with 3 global refinement steps, however, if you have a bitof time: in early 2011, the direct solve takes about half anhour. What you'll notice, however, is that the solution is completelywrong: the mesh size is simply not small enough to resolve thesolution's waves accurately, and you can see this in plots of thesolution. Consequently, this is one of the cases where adaptivity isindispensable if you don't just want to throw a bigger (presumablyparallel) machine at the problem.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Moritz Allmaras, Texas A&amp;M University, 2007</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    DirichletBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                              Vector&lt;double&gt; &amp;values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), 2));</div><div class="line"></div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    vector_value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                      std::vector&lt;Vector&lt;double&gt;&gt; &amp;  value_list)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>              declare_parameters();</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">  };</div><div class="line"></div><div class="line">  ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">    : prm(paramhandler)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output filename&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                        <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div><div class="line">  {</div><div class="line">    declare_parameters();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComputeIntensity();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div><div class="line">                                     inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line"></div><div class="line">        computed_quantities[i](0) = std::abs(u);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>UltrasoundProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    Vector&lt;double&gt;       solution, system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div><div class="line">    : prm(param)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div><div class="line">      (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 5, 0, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">            ((face-&gt;center() - transducer).norm_square() &lt; 0.01))</div><div class="line">          {</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">            face-&gt;set_manifold_id(1);</div><div class="line">          }</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinements);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div><div class="line">                       n_face_q_points = face_quadrature_formula.size(),</div><div class="line">                       dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">                    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">                  {</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div><div class="line">                         ++q_point)</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)) *</div><div class="line">                            (-omega * omega) +</div><div class="line">                          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)) *</div><div class="line">                            c * c) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">              (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div><div class="line">            {</div><div class="line">              fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">                       fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face_no))</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                         ++q_point)</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ? -1 :</div><div class="line">                                                                        1) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) * c * omega *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       solution,</div><div class="line">                                       system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    ComputeIntensity&lt;dim&gt; intensities;</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string output_filename = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output filename&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, intensities);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step29</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      ParameterReader  param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"></div><div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div><div class="line">      ultrasound_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemsetting">Problem setting</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDirichletBoundaryValuescodeclass">The <code>DirichletBoundaryValues</code> class</a>
        <li><a href="#ThecodeParameterReadercodeclass">The <code>ParameterReader</code> class</a>
      <ul>
        <li><a href="#codeParameterReaderdeclare_parameterscode"><code>ParameterReader::declare_parameters</code></a>
        <li><a href="#codeParameterReaderread_parameterscode"><code>ParameterReader::read_parameters</code></a>
      </ul>
        <li><a href="#ThecodeComputeIntensitycodeclass">The <code>ComputeIntensity</code> class</a>
        <li><a href="#ThecodeUltrasoundProblemcodeclass">The <code>UltrasoundProblem</code> class</a>
      <ul>
        <li><a href="#codeUltrasoundProblemmake_gridcode"><code>UltrasoundProblem::make_grid</code></a>
        <li><a href="#codeUltrasoundProblemsetup_systemcode"><code>UltrasoundProblem::setup_system</code></a>
        <li><a href="#codeUltrasoundProblemassemble_systemcode"><code>UltrasoundProblem::assemble_system</code></a>
        <li><a href="#codeUltrasoundProblemsolvecode"><code>UltrasoundProblem::solve</code></a>
        <li><a href="#codeUltrasoundProblemoutput_resultscode"><code>UltrasoundProblem::output_results</code></a>
        <li><a href="#codeUltrasoundProblemruncode"><code>UltrasoundProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-29/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Moritz Allmaras at Texas A&amp;M University. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778. </em></p>
<p><b>Note:</b> 为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接求解器。请参考<a href="../../readme.html#umfpack">ReadMe</a>中的说明如何做到这一点。</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>一个经常出现的问题是如何用deal.II解决涉及复值函数的问题。对于许多问题，与其直接使用复值有限元，不如将复值函数分成实部和虚部，并使用单独的标量有限元场来离散它们中的每一个，这样做往往更方便。基本上，这相当于把一个复值方程看作是两个实值方程的系统。这个简短的例子演示了如何在deal.II中通过使用 <code>FE_system</code> 对象来堆叠两个代表实部和虚部的有限元场来实现。(相反的方法，保持所有的复值，在另一个教程程序中演示：见步骤58)。当分成实部和虚部时，这里涉及的方程属于矢量值问题的范畴。这个主题的顶层概述可以在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中找到。</p>
<p>除了这些讨论，我们还讨论了ParameterHandler类，它提供了一种方便的方法，在运行时从配置文件中读取参数，而不需要重新编译程序代码。</p>
<p><a class="anchor" id="Problemsetting"></a></p><h3>Problem setting</h3>
<p>这个程序的最初目的是模拟由一个几何形状可变的换能器透镜产生的超声波的聚焦特性。最近在医学成像方面的应用，不仅将超声波用于成像，而且还能激发材料中的某些局部效应，如光学特性的变化，然后可以用其他成像技术来测量。这些方法的一个重要因素是能够将超声波的强度集中在材料的一个特定部分，最好是一个点，以便能够检查该特定位置的材料特性。</p>
<p>为了推导出这个问题的模型，我们把超声波看成是由波浪方程支配的压力波。</p>
<p class="formulaDsp">
\[ \frac{\partial^2 U}{\partial t^2} - c^2 \Delta U = 0 \]
</p>
<p>其中 \(c\) 是波速（为简单起见，我们假设为常数）， \(U = U(x,t),\;x \in \Omega,\;t\in\mathrm{R}\) 。边界 \(\Gamma=\partial\Omega\) 分为两部分 \(\Gamma_1\) 和 \(\Gamma_2=\Gamma\setminus\Gamma_1\) ，其中 \(\Gamma_1\) 代表换能器透镜， \(\Gamma_2\) 是吸收边界（也就是说，我们希望在 \(\Gamma_2\) 上选择边界条件，使其模仿一个更大的域）。在 \(\Gamma_1\) 上，换能器产生一个恒定频率 \({\omega}&gt;0\) 和恒定振幅（我们在这里选择为1）的波。</p>
<p class="formulaDsp">
\[ U(x,t) = \cos{\omega t}, \qquad x\in \Gamma_1 \]
</p>
<p>如果没有其他（内部或边界）源，并且由于唯一的源具有频率 \(\omega\) ，那么解决方案可以接受形式为 \(U(x,t) = \textrm{Re}\left(u(x)\,e^{i\omega t})\right)\) 的变量分离。复值函数 \(u(x)\) 描述了频率为 \({\omega}\) 的波的振幅和相位（相对于源）的空间依赖性，其中振幅是我们感兴趣的量。通过将这种形式的解决方案插入波浪方程，我们看到，对于 \(u\) ，我们有</p>
<p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u(x) - c^2\Delta u(x) &amp;=&amp; 0, \qquad x\in\Omega,\\ u(x) &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p>为了在 \(\Gamma_2\) 上找到模拟吸收边界的合适条件，考虑一个频率为 \({\omega}\) 的波在 \(k\in {\mathrm{R}^2}\) 方向上行驶。为了使 \(V\) 能够解决波浪方程， \(|k|={\frac{\omega}{c}}\) 必须成立。假设这个波以直角击中 \(x_0\in\Gamma_2\) 的边界，即 \(n=\frac{k}{|k|}\) ， \(n\) 表示 \(\Omega\) 在 \(x_0\) 的外单位法线。然后在 \(x_0\) ，这个波满足方程式</p>
<p class="formulaDsp">
\[ c (n\cdot\nabla V) + \frac{\partial V}{\partial t} = (i\, c\, |k| - i\, \omega) V = 0. \]
</p>
<p>因此，通过强制执行边界条件</p>
<p class="formulaDsp">
\[ c (n\cdot\nabla U) + \frac{\partial U}{\partial t} = 0, \qquad x\in\Gamma_2, \]
</p>
<p>以直角撞击边界 \(\Gamma_2\) 的波将被完全吸收。另一方面，那些没有以直角撞击边界的波场部分不满足这个条件，将其作为边界条件强制执行会产生部分反射，即只有部分波会通过边界，就像它不在这里一样，而剩下的部分波会被反射回域中。</p>
<p>如果我们愿意接受这一点作为吸收边界的充分近似，我们最终得出以下问题，对于 \(u\) 。</p>
<p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u - c^2\Delta u &amp;=&amp; 0, \qquad x\in\Omega,\\ c (n\cdot\nabla u) + i\,\omega\,u &amp;=&amp;0, \qquad x\in\Gamma_2,\\ u &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p>这是一个亥姆霍兹方程（类似于步骤7中的方程，但这次有''坏符号''），在 \(\Gamma_1\) 上有Dirichlet数据，在 \(\Gamma_2\) 上有混合边界条件。由于 \(\Gamma_2\) 上的条件，我们不能只是分别处理 \(u\) 的实部和虚部方程。然而，我们可以把 \(u\) 的PDE看作是 \(u\) 的实部和虚部的两个PDE系统， \(\Gamma_2\) 的边界条件代表系统中两个部分之间的耦合项。这是按以下思路进行的。让 \(v=\textrm{Re}\;u,\; w=\textrm{Im}\;u\) ，然后在 \(v\) 和 \(w\) 方面，我们有以下系统。</p>
<p class="formulaDsp">
\begin{eqnarray*} \left.\begin{array}{ccc} -\omega^2 v - c^2\Delta v &amp;=&amp; 0 \quad\\ -\omega^2 w - c^2\Delta w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Omega, \\ \left.\begin{array}{ccc} c (n\cdot\nabla v) - \omega\,w &amp;=&amp; 0 \quad\\ c (n\cdot\nabla w) + \omega\,v &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_2, \\ \left.\begin{array}{ccc} v &amp;=&amp; 1 \quad\\ w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_1. \end{eqnarray*}
</p>
<p>对于 \(\phi,\psi\) 与 \(\phi|_{\Gamma_1}=\psi|_{\Gamma_1}=0\) 的测试函数，经过通常的乘法，在 \(\Omega\) 上的积分和应用部分积分，我们得到弱的表述</p>
<p class="formulaDsp">
\begin{eqnarray*} -\omega^2 \langle \phi, v \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi, \nabla v \rangle_{\mathrm{L}^2(\Omega)} - c \omega \langle \phi, w \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0, \\ -\omega^2 \langle \psi, w \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi, \nabla w \rangle_{\mathrm{L}^2(\Omega)} + c \omega \langle \psi, v \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>我们选择有限元空间 \(V_h\) 和 \(W_h\) ，基数为 \(\{\phi_j\}_{j=1}^n, \{\psi_j\}_{j=1}^n\) ，寻找近似解</p>
<p class="formulaDsp">
\[ v_h = \sum_{j=1}^n \alpha_j \phi_j, \;\; w_h = \sum_{j=1}^n \beta_j \psi_j. \]
</p>
<p>将其插入变异形式中，可以得到方程组</p>
<p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left.\begin{array}{ccc} \sum_{j=1}^n \left( -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} \right) \alpha_j - \left( c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)}\right)\beta_j &amp;=&amp; 0 \\ \sum_{j=1}^n \left( -\omega^2 \langle \psi_i, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_i, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \right)\beta_j + \left( c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \right)\alpha_j &amp;=&amp; 0 \end{array}\right\}\;\;\forall\; i =1,\ldots,n. \]
</p>
<p>用矩阵符号表示。</p>
<p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left( \begin{array}{cc} -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} &amp; -c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \\ c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} &amp; -\omega^2 \langle \psi_{i}, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_{i}, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \end{array} \right) \left( \begin{array}{c} \alpha \\ \beta \end{array} \right) = \left( \begin{array}{c} 0 \\ 0 \end{array} \right) \]
</p>
<p>(不要被这里的右手边为零所迷惑，那是因为我们还没有包括Dirichlet边界数据)。由于非对角线区块的交替符号，我们已经可以看到这个系统是非对称的，事实上它甚至是不确定的。当然，没有必要选择空间 \(V_h\) 和 \(W_h\) 是相同的。然而，我们期望解的实部和虚部具有类似的性质，因此在实现中确实会采取 \(V_h=W_h\) ，并且也会对两个空间使用相同的基函数 \(\phi_i = \psi_i\) 。使用不同符号的原因只是让我们能够区分 \(v\) 和 \(w\) 的形状函数，因为这种区分在实施中起着重要作用。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>在计算中，我们将考虑波在单位方阵中的传播，超声由换能器透镜产生，透镜的形状是圆的一段，中心在 \((0.5, d)\) ，半径略大于 \(d\) ；这种形状应该导致声波在圆中心的聚焦。改变 \(d\) 会改变透镜的 "焦点"，并影响 \(u\) 强度的空间分布，我们主要关注的是 \(|u|=\sqrt{v^2+w^2}\) 的聚焦效果如何。</p>
<p>在下面的程序中，我们将使用实部和虚部分裂的公式来实现复值亥姆霍兹方程。我们还将讨论如何生成一个看起来像正方形并带有轻微隆起的模拟换能器的域（在 <code>UltrasoundProblem&lt;dim&gt;::make_grid()</code> 函数中），以及如何生成不仅包含解分量 \(v\) 和 \(w\) ，而且直接在输出文件中包含幅值 \(\sqrt{v^2+w^2}\) 的图形输出（在 <code>UltrasoundProblem&lt;dim&gt;::output_results()</code> ）。最后，我们使用ParameterHandler类来轻松读取参数，如焦距 \(d\) 、波速 \(c\) 、频率 \(\omega\) ，以及在运行时从输入文件中读取其他一些参数，而不是在源代码中固定这些参数，因为每次我们想改变参数时，都必须重新编译。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following header files have all been discussed before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>This header file contains the necessary declarations for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class that we will use to read our parameters from a configuration file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div></div><!-- fragment --><p>For solving the linear system, we'll use the sparse LU-decomposition provided by UMFPACK (see the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class), for which the following header file is needed. Note that in order to compile this tutorial program, the deal.II-library needs to be built with UMFPACK support, which is enabled by default:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div></div><!-- fragment --><p>The <a class="el" href="classFESystem.html">FESystem</a> class allows us to stack several FE-objects to one compound, vector-valued finite element field. The necessary declarations for this class are provided in this header file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, include the header file that declares the <a class="el" href="classTimer.html">Timer</a> class that we will use to determine how much time each of the operations of our program takes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div></div><!-- fragment --><p>As the last step at the beginning of this program, we put everything that is in this program into its namespace and, within it, make everything that is in the deal.II namespace globally available, without the need to prefix everything with <code>dealii</code><code>::</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDirichletBoundaryValuescodeclass"></a> </p><h3>The <code>DirichletBoundaryValues</code> class</h3>
<p>First we define a class for the function representing the Dirichlet boundary values. This has been done many times before and therefore does not need much explanation.</p>
<p>Since there are two values \(v\) and \(w\) that need to be prescribed at the boundary, we have to tell the base class that this is a vector-valued function with two components, and the <code>vector_value</code> function and its cousin <code>vector_value_list</code> must return vectors with two entries. In our case the function is very simple, it just returns 1 for the real part \(v\) and 0 for the imaginary part \(w\) regardless of the point where it is evaluated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DirichletBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), 2));</div><div class="line"></div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;  value_list)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeParameterReadercodeclass"></a> </p><h3>The <code>ParameterReader</code> class</h3>
<p>The next class is responsible for preparing the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and reading parameters from an input file. It includes a function <code>declare_parameters</code> that declares all the necessary parameters and a <code>read_parameters</code> function that is called from outside to initiate the parameter reading process.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>              declare_parameters();</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">};</div></div><!-- fragment --><p>The constructor stores a reference to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to it:</p>
<div class="fragment"><div class="line">ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">  : prm(paramhandler)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderdeclare_parameterscode"></a> </p><h4><code>ParameterReader::declare_parameters</code></h4>
<p>The <code>declare_parameters</code> function declares all the parameters that our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will be able to read from input files, along with their types, range conditions and the subsections they appear in. We will wrap all the entries that go into a section in a pair of braces to force the editor to indent them by one level, making it simpler to read which entries together form a section:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">{</div></div><!-- fragment --><p>Parameters for mesh and geometry include the number of global refinement steps that are applied to the initial coarse mesh and the focal distance \(d\) of the transducer lens. For the number of refinement steps, we allow integer values in the range \([0,\infty)\), where the omitted second argument to the <a class="el" href="classPatterns_1_1Integer.html">Patterns::Integer</a> object denotes the half-open interval. For the focal distance any number greater than zero is accepted:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>The next subsection is devoted to the physical parameters appearing in the equation, which are the frequency \(\omega\) and wave speed \(c\). Again, both need to lie in the half-open interval \([0,\infty)\) represented by calling the <a class="el" href="classPatterns_1_1Double.html">Patterns::Double</a> class with only the left end-point as argument:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Last but not least we would like to be able to change some properties of the output, like filename and format, through entries in the configuration file, which is the purpose of the last subsection:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output filename&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div></div><!-- fragment --><p>Since different output formats may require different parameters for generating output (like for example, postscript output needs viewpoint angles, line widths, colors etc), it would be cumbersome if we had to declare all these parameters by hand for every possible output format supported in the library. Instead, each output format has a <code>FormatFlags::declare_parameters</code> function, which declares all the parameters specific to that format in an own subsection. The following call of <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> executes <code>declare_parameters</code> for all available output formats, so that for each format an own subsection will be created with parameters declared for that particular output format. (The actual value of the template parameter in the call, <code>&lt;1&gt;</code> above, does not matter here: the function does the same work independent of the dimension, but happens to be in a template-parameter-dependent class.) To find out what parameters there are for which output format, you can either consult the documentation of the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class, or simply run this program without a parameter file present. It will then create a file with all declared parameters set to their default values, which can conveniently serve as a starting point for setting the parameters to the values you desire.</p>
<div class="fragment"><div class="line">    <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderread_parameterscode"></a> </p><h4><code>ParameterReader::read_parameters</code></h4>
<p>This is the main function in the ParameterReader class. It gets called from outside, first declares all the parameters, and then reads them from the input file whose filename is provided by the caller. After the call to this function is complete, the <code>prm</code> object can be used to retrieve the values of the parameters read in from the file :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div><div class="line">{</div><div class="line">  declare_parameters();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeComputeIntensitycodeclass"></a> </p><h3>The <code>ComputeIntensity</code> class</h3>
<p>As mentioned in the introduction, the quantity that we are really after is the spatial distribution of the intensity of the ultrasound wave, which corresponds to \(|u|=\sqrt{v^2+w^2}\). Now we could just be content with having \(v\) and \(w\) in our output, and use a suitable visualization or postprocessing tool to derive \(|u|\) from the solution we computed. However, there is also a way to output data derived from the solution in deal.II, and we are going to make use of this mechanism here.</p>
<p>So far we have always used the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> function to add vectors containing output data to a <a class="el" href="classDataOut.html">DataOut</a> object. There is a special version of this function that in addition to the data vector has an additional argument of type <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. What happens when this function is used for output is that at each point where output data is to be generated, the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> function of the specified <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object is invoked to compute the output quantities from the values, the gradients and the second derivatives of the finite element function represented by the data vector (in the case of face related data, normal vectors are available as well). Hence, this allows us to output any quantity that can locally be derived from the values of the solution and its derivatives. Of course, the ultrasound intensity \(|u|\) is such a quantity and its computation doesn't even involve any derivatives of \(v\) or \(w\).</p>
<p>In practice, the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class only provides an interface to this functionality, and we need to derive our own class from it in order to implement the functions specified by the interface. In the most general case one has to implement several member functions but if the output quantity is a single scalar then some of this boilerplate code can be handled by a more specialized class, <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and we can derive from that one instead. This is what the <code>ComputeIntensity</code> class does:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ComputeIntensity();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>In the constructor, we need to call the constructor of the base class with two arguments. The first denotes the name by which the single scalar quantity computed by this class should be represented in output files. In our case, the postprocessor has \(|u|\) as output, so we use "Intensity".</p>
<p>The second argument is a set of flags that indicate which data is needed by the postprocessor in order to compute the output quantities. This can be any subset of update_values, update_gradients and update_hessians (and, in the case of face data, also update_normal_vectors), which are documented in UpdateFlags. Of course, computation of the derivatives requires additional resources, so only the flags for data that are really needed should be given here, just as we do when we use <a class="el" href="classFEValues.html">FEValues</a> objects. In our case, only the function values of \(v\) and \(w\) are needed to compute \(|u|\), so we're good with the update_values flag.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div><div class="line">  : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">{}</div></div><!-- fragment --><p>The actual postprocessing happens in the following function. Its input is an object that stores values of the function (which is here vector-valued) representing the data vector given to <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a>, evaluated at all evaluation points where we generate output, and some tensor objects representing derivatives (that we don't use here since \(|u|\) is computed from just \(v\) and \(w\)). The derived quantities are returned in the <code>computed_quantities</code> vector. Remember that this function may only use data for which the respective update flag is specified by <code>get_needed_update_flags</code>. For example, we may not use the derivatives here, since our implementation of <code>get_needed_update_flags</code> requests that only function values are provided.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                              inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div></div><!-- fragment --><p>The computation itself is straightforward: We iterate over each entry in the output vector and compute \(|u|\) from the corresponding values of \(v\) and \(w\). We do this by creating a complex number \(u\) and then calling <code><a class="el" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">std::abs()</a></code> on the result. (One may be tempted to call <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code>, but in a historical quirk, the C++ committee decided that <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code> should return the <em>square</em> of the absolute value &ndash; thereby not satisfying the properties mathematicians require of something called a "norm".)</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div><div class="line">                                   inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line"></div><div class="line">      computed_quantities[i](0) = std::abs(u);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeUltrasoundProblemcodeclass"></a> </p><h3>The <code>UltrasoundProblem</code> class</h3>
<p>Finally here is the main class of this program. It's member functions are very similar to the previous examples, in particular <a class="el" href="step_4.html">step-4</a>, and the list of member variables does not contain any major surprises either. The <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to the constructor is stored as a reference to allow easy access to the parameters from all functions of the class. Since we are working with vector valued finite elements, the FE object we are using is of type <a class="el" href="classFESystem.html">FESystem</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>UltrasoundProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution, system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>The constructor takes the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and stores it in a reference. It also initializes the DoF-Handler and the finite element system, which consists of two copies of the scalar Q1 field, one for \(v\) and one for \(w\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div><div class="line">  : prm(param)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemmake_gridcode"></a> </p><h4><code>UltrasoundProblem::make_grid</code></h4>
<p>Here we setup the grid for our domain. As mentioned in the exposition, the geometry is just a unit square (in 2d) with the part of the boundary that represents the transducer lens replaced by a sector of a circle.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div></div><!-- fragment --><p>First we generate some logging output and start a timer so we can compute execution time when this function is done:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>Then we query the values for the focal distance of the transducer lens and the number of mesh refinement steps from our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Next, two points are defined for position and focal point of the transducer lens, which is the center of the circle whose segment will form the transducer part of the boundary. Notice that this is the only point in the program where things are slightly different in 2D and 3D. Even though this tutorial only deals with the 2D case, the necessary additions to make this program functional in 3D are so minimal that we opt for including them:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div><div class="line">  (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div></div><!-- fragment --><p>As initial coarse grid we take a simple unit square with 5 subdivisions in each direction. The number of subdivisions is chosen so that the line segment \([0.4,0.6]\) that we want to designate as the transducer boundary is spanned by a single face. Then we step through all cells to find the faces where the transducer is to be located, which in fact is just the single edge from 0.4 to 0.6 on the x-axis. This is where we want the refinements to be made according to a circle shaped boundary, so we mark this edge with a different manifold indicator. Since we will Dirichlet boundary conditions on the transducer, we also change its boundary indicator.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 5, 0, 1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">        ((face-&gt;center() - transducer).norm_square() &lt; 0.01))</div><div class="line">      {</div><div class="line">        face-&gt;set_boundary_id(1);</div><div class="line">        face-&gt;set_manifold_id(1);</div><div class="line">      }</div></div><!-- fragment --><p>For the circle part of the transducer lens, a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object is used (which, of course, in 2D just represents a circle), with center computed as above.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div></div><!-- fragment --><p>Now global refinement is executed. Cells near the transducer location will be automatically refined according to the circle shaped boundary of the transducer lens:</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinements);</div></div><!-- fragment --><p>Lastly, we generate some more logging output. We stop the timer and query the number of CPU seconds elapsed since the beginning of the function:</p>
<div class="fragment"><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsetup_systemcode"></a> </p><h4><code>UltrasoundProblem::setup_system</code></h4>
<p>Initialization of the system matrix, sparsity patterns and vectors are the same as in previous examples and therefore do not need further comment. As in the previous function, we also output the run time of what we do here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemassemble_systemcode"></a> </p><h4><code>UltrasoundProblem::assemble_system</code></h4>
<p>As before, this function takes care of assembling the system matrix and right hand side vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>First we query wavespeed and frequency from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and store them in local variables, as they will be used frequently throughout this function.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>As usual, for computing integrals ordinary Gauss quadrature rule is used. Since our bilinear form involves boundary integrals on \(\Gamma_2\), we also need a quadrature rule for surface integration on the faces, which are \(dim-1\) dimensional:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"><a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div><div class="line">                   n_face_q_points = face_quadrature_formula.size(),</div><div class="line">                   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div></div><!-- fragment --><p>The <a class="el" href="classFEValues.html">FEValues</a> objects will evaluate the shape functions for us. For the part of the bilinear form that involves integration on \(\Omega\), we'll need the values and gradients of the shape functions, and of course the quadrature weights. For the terms involving the boundary integrals, only shape function values and the quadrature weights are necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                 face_quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>As usual, the system matrix is assembled cell by cell, and we need a matrix for storing the local cell contributions as well as an index vector to transfer the cell contributions to the appropriate location in the global system matrix after.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><p>On each cell, we first need to reset the local contribution matrix and request the <a class="el" href="classFEValues.html">FEValues</a> object to compute the shape functions for the current cell:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      {</div></div><!-- fragment --><p>At this point, it is important to keep in mind that we are dealing with a finite element system with two components. Due to the way we constructed this <a class="el" href="classFESystem.html">FESystem</a>, namely as the Cartesian product of two scalar finite element fields, each shape function has only a single nonzero component (they are, in deal.II lingo, <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>). Hence, each shape function can be viewed as one of the \(\phi\)'s or \(\psi\)'s from the introduction, and similarly the corresponding degrees of freedom can be attributed to either \(\alpha\) or \(\beta\). As we iterate through all the degrees of freedom on the current cell however, they do not come in any particular order, and so we cannot decide right away whether the DoFs with index \(i\) and \(j\) belong to the real or imaginary part of our solution. On the other hand, if you look at the form of the system matrix in the introduction, this distinction is crucial since it will determine to which block in the system matrix the contribution of the current pair of DoFs will go and hence which quantity we need to compute from the given two shape functions. Fortunately, the <a class="el" href="classFESystem.html">FESystem</a> object can provide us with this information, namely it has a function <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FESystem::system_to_component_index</a>, that for each local DoF index returns a pair of integers of which the first indicates to which component of the system the DoF belongs. The second integer of the pair indicates which index the DoF has in the scalar base finite element field, but this information is not relevant here. If you want to know more about this function and the underlying scheme behind primitive vector valued elements, take a look at <a class="el" href="step_8.html">step-8</a> or the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module, where these topics are explained in depth.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">  {</div></div><!-- fragment --><p>If both DoFs \(i\) and \(j\) belong to same component, i.e. their shape functions are both \(\phi\)'s or both \(\psi\)'s, the contribution will end up in one of the diagonal blocks in our system matrix, and since the corresponding entries are computed by the same formula, we do not bother if they actually are \(\phi\) or \(\psi\) shape functions. We can simply compute the entry by iterating over all quadrature points and adding up their contributions, where values and gradients of the shape functions are supplied by our <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div><div class="line">     ++q_point)</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">    (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)) *</div><div class="line">        (-omega * omega) +</div><div class="line">      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)) *</div><div class="line">        c * c) *</div><div class="line">     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div></div><!-- fragment --><p>You might think that we would have to specify which component of the shape function we'd like to evaluate when requesting shape function values or gradients from the <a class="el" href="classFEValues.html">FEValues</a> object. However, as the shape functions are primitive, they have only one nonzero component, and the <a class="el" href="classFEValues.html">FEValues</a> class is smart enough to figure out that we are definitely interested in this one nonzero component.</p>
<div class="fragment"><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>We also have to add contributions due to boundary terms. To this end, we loop over all faces of the current cell and see if first it is at the boundary, and second has the correct boundary indicator associated with \(\Gamma_2\), the part of the boundary where we have absorbing boundary conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">      (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div><div class="line">    {</div></div><!-- fragment --><p>These faces will certainly contribute to the off-diagonal blocks of the system matrix, so we ask the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object to provide us with the shape function values on this face:</p>
<div class="fragment"><div class="line">fe_face_values.reinit(cell, face_no);</div></div><!-- fragment --><p>Next, we loop through all DoFs of the current cell to find pairs that belong to different components and both have support on the current face_no:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">    <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">         fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face_no))</div></div><!-- fragment --><p>The check whether shape functions have support on a face is not strictly necessary: if we don't check for it we would simply add up terms to the local cell matrix that happen to be zero because at least one of the shape functions happens to be zero. However, we can save that work by adding the checks above.</p>
<p>In either case, these DoFs will contribute to the boundary integrals in the off-diagonal blocks of the system matrix. To compute the integral, we loop over all the quadrature points on the face and sum up the contribution weighted with the quadrature weights that the face quadrature rule provides. In contrast to the entries on the diagonal blocks, here it does matter which one of the shape functions is a \(\psi\) and which one is a \(\phi\), since that will determine the sign of the entry. We account for this by a simple conditional statement that determines the correct sign. Since we already checked that DoF \(i\) and \(j\) belong to different components, it suffices here to test for one of them to which component it belongs.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">             ++q_point)</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">            ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ? -1 :</div><div class="line">                                                            1) *</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) * c * omega *</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">}</div></div><!-- fragment --><p>Now we are done with this cell and have to transfer its contributions from the local to the global system matrix. To this end, we first get a list of the global indices of the this cells DoFs...</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>...and then add the entries to the system matrix one by one:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      system_matrix.add(local_dof_indices[i],</div><div class="line">                        local_dof_indices[j],</div><div class="line">                        cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>The only thing left are the Dirichlet boundary values on \(\Gamma_1\), which is characterized by the boundary indicator 1. The Dirichlet values are provided by the <code>DirichletBoundaryValues</code> class we defined above:</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsolvecode"></a> </p><h4><code>UltrasoundProblem::solve</code></h4>
<p>As already mentioned in the introduction, the system matrix is neither symmetric nor definite, and so it is not quite obvious how to come up with an iterative solver and a preconditioner that do a good job on this matrix. We chose instead to go a different way and solve the linear system with the sparse LU decomposition provided by UMFPACK. This is often a good first choice for 2D problems and works reasonably well even for a large number of DoFs. The deal.II interface to UMFPACK is given by the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, which is very easy to use and allows us to solve our linear system with just 3 lines of code.</p>
<p>Note again that for compiling this example program, you need to have the deal.II library built with UMFPACK support.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>The code to solve the linear system is short: First, we allocate an object of the right type. The following <code>initialize</code> call provides the matrix that we would like to invert to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object, and at the same time kicks off the LU-decomposition. Hence, this is also the point where most of the computational work in this program happens.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div></div><!-- fragment --><p>After the decomposition, we can use <code>A_direct</code> like a matrix representing the inverse of our system matrix, so to compute the solution we just have to multiply with the right hand side vector:</p>
<div class="fragment"><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemoutput_resultscode"></a> </p><h4><code>UltrasoundProblem::output_results</code></h4>
<p>Here we output our solution \(v\) and \(w\) as well as the derived quantity \(|u|\) in the format specified in the parameter file. Most of the work for deriving \(|u|\) from \(v\) and \(w\) was already done in the implementation of the <code>ComputeIntensity</code> class, so that the output routine is rather straightforward and very similar to what is done in the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div></div><!-- fragment --><p>Define objects of our <code>ComputeIntensity</code> class and a <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line">ComputeIntensity&lt;dim&gt; intensities;</div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div></div><!-- fragment --><p>Next we query the output-related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. The <a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">DataOut::parse_parameters</a> call acts as a counterpart to the <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> call in <code>ParameterReader::declare_parameters</code>. It collects all the output format related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and sets the corresponding properties of the <a class="el" href="classDataOut.html">DataOut</a> object accordingly.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::string output_filename = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output filename&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Now we put together the filename from the base name provided by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and the suffix which is provided by the <a class="el" href="classDataOut.html">DataOut</a> class (the default suffix is set to the right type that matches the one set in the .prm file through parse_parameters()):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">std::ofstream output(filename);</div></div><!-- fragment --><p>The solution vectors \(v\) and \(w\) are added to the <a class="el" href="classDataOut.html">DataOut</a> object in the usual way:</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div></div><!-- fragment --><p>For the intensity, we just call <code>add_data_vector</code> again, but this with our <code>ComputeIntensity</code> object as the second argument, which effectively adds \(|u|\) to the output data:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, intensities);</div></div><!-- fragment --><p>The last steps are as before. Note that the actual output format is now determined by what is stated in the input file, i.e. one can change the output format without having to re-compile this program:</p>
<div class="fragment"><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemruncode"></a> </p><h4><code>UltrasoundProblem::run</code></h4>
<p>Here we simply execute our functions one after the other:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step29</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main</code> function</h4>
<p>Finally the <code>main</code> function of the program. It has the same structure as in almost all of the other tutorial programs. The only exception is that we define <a class="el" href="classParameterHandler.html">ParameterHandler</a> and <code>ParameterReader</code> objects, and let the latter read in the parameter values from a textfile called <code><a class="el" href="step_29.html">step-29</a>.prm</code>. The values so read are then handed over to an instance of the UltrasoundProblem class:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      ParameterReader  param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"></div><div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div><div class="line">      ultrasound_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-29/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>当前程序从一个名为 <code>step-29.prm</code> 的输入文件中读取其运行时参数，该文件看起来像这样。</p>
<div class="fragment"><div class="line">subsection Mesh &amp; geometry parameters</div><div class="line"><span class="preprocessor">  # Distance of the focal point of the lens to the x-axis</span></div><div class="line">  <span class="keyword">set</span> Focal distance        = 0.3</div><div class="line"></div><div class="line"></div><div class="line">  # Number of global mesh refinement steps applied to <a class="code" href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">initial</a> coarse grid</div><div class="line">  <span class="keyword">set</span> Number of refinements = 5</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Physical constants</div><div class="line"><span class="preprocessor">  # Wave speed</span></div><div class="line">  <span class="keyword">set</span> c     = 1.5e5</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # Frequency</span></div><div class="line">  <span class="keyword">set</span> omega = 3.0e7</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Output parameters</div><div class="line"><span class="preprocessor">  # Name of the output file (without extension)</span></div><div class="line">  <span class="keyword">set</span> Output file   = solution</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # A name for the output format to be used</span></div><div class="line">  <span class="keyword">set</span> Output format = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div></div><!-- fragment --><p>可以看出，我们设置了 \(d=0.3\) ，相当于换能器镜头的焦点在 \(x=0.5\) ， \(y=0.3\) 。粗略的网格被细化了5次，结果是160x160个单元，输出结果以vtu格式写入。参数读取器可以理解更多的参数，特别是与输出的生成有关的参数，但是我们在这里不需要这些参数，因此坚持使用其默认值。</p>
<p>这是调试模式下程序的控制台输出。</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Debug configuration</div><div class="line">Generating grid... done (0.820449s)</div><div class="line">  Number of active cells:  25600</div><div class="line">Setting up system... done (1.18392s)</div><div class="line">  Number of degrees of freedom: 51842</div><div class="line">Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (2.33291s)</div><div class="line">Solving linear system... done (1.34837s)</div><div class="line">Generating output... done (2.05782s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>(当然，如果你在本地运行该程序，执行时间会有所不同。)事实上，大部分时间花在组装系统矩阵和生成输出上是由于在调试模式下需要检查许多断言。在发布模式下，程序的这些部分运行得更快，而求解线性系统的速度几乎没有加快。</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">Scanning dependencies of target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0144960s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.0356880s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0436570s)</div><div class="line">DEAL::Solving linear system... done (1.54733s)</div><div class="line">DEAL::Generating output... done (0.720528s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>程序的图形输出看起来如下。</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.v.png" alt="v = Re(u)"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.w.png" alt="w = Im(u)"/>
</div>
   </td></tr>
<tr>
<td colspan="2"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.intensity.png" alt="|u|"/>
</div>
   </td></tr>
</table>
<p>前两张图片显示了 \(u\) 的实部和虚部，而最后一张显示了强度 \(|u|\) 。我们可以清楚地看到，强度集中在镜头的焦点周围（0.5，0.3），焦点在 \(x\) -方向上相当尖锐，但在 \(y\) -方向上更加模糊，这是聚焦镜头的几何形状、其有限孔径和问题的波性的结果。</p>
<p>因为五颜六色的图形总是很有趣，而且为了进一步强调聚焦效果，这里还有一组图片，强调了强度在 \(x\) -方向上的实际聚焦效果。</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.surface.png" alt="|u|"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.contours.png" alt="|u|"/>
</div>
   </td></tr>
</table>
<p>最后，程序的结构使我们很容易确定程序的哪些部分可以随着网格的细化而很好地扩展，哪些部分不可以。下面是5、6、7次全局细化的运行时间。</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0135260s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.0213910s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0414300s)</div><div class="line">DEAL::Solving linear system... done (1.56621s)</div><div class="line">DEAL::Generating output... done (0.729605s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line"></div><div class="line"></div><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.0668490s)</div><div class="line">DEAL::  Number of active cells:  102400</div><div class="line">DEAL::Setting up system... done (0.109694s)</div><div class="line">DEAL::  Number of degrees of freedom: 206082</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.160784s)</div><div class="line">DEAL::Solving linear system... done (7.86577s)</div><div class="line">DEAL::Generating output... done (2.89320s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line"></div><div class="line"></div><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div><div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div><div class="line">DEAL::Generating grid... done (0.293154s)</div><div class="line">DEAL::  Number of active cells:  409600</div><div class="line">DEAL::Setting up system... done (0.491301s)</div><div class="line">DEAL::  Number of degrees of freedom: 821762</div><div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.605386s)</div><div class="line">DEAL::Solving linear system... done (45.1989s)</div><div class="line">DEAL::Generating output... done (11.2292s)</div><div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>每次我们细化一次网格，所以每一步的单元和自由度的数量大约是四倍。可以看出，生成网格、设置自由度、组装线性系统和生成输出的规模相当接近于线性，而求解线性系统的操作，自由度的数量每增加4倍，就需要8倍的时间，也就是说，它是 \({\cal O}(N^{3/2})\) 。这可以解释为（使用最优排序）有限元矩阵的带宽是 \(B={\cal O}(N^{(dim-1)/dim})\) ，而使用LU分解解决带状线性系统的努力是 \({\cal O}(BN)\) 。这也解释了为什么该程序也能在3D中运行（在改变了 <code>UltrasoundProblem</code> 对象的维度后），但其扩展性很差，需要非常耐心才能完成对具有明显分辨率的网格上的线性系统的求解，尽管该程序的其他部分的扩展性非常好。</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>这个程序的一个明显的可能的扩展是在3D中运行它&amp;mdash；毕竟，我们周围的世界是三维的，而超声束在三维介质中传播。你可以通过简单地改变 <code>main()</code> 中主类的模板参数并运行它来尝试。但这不会让你走得很远：当然，如果你按照参数文件中的设置做5个全局细化步骤，就更不会了。你的内存会耗尽，因为网格（含 \((2^5)^3 \cdot 5^3=2^{15}\cdot 125 \approx 4\cdot 10^6\) 单元），特别是稀疏直接求解器会占用太多的内存。然而，如果你有时间的话，你可以用3个全局细化步骤来求解：在2011年初，直接求解大约需要半个小时。然而，你会注意到，这个解是完全错误的：网格大小根本不够小，不能准确地解决解的波浪，你可以在解的图中看到这一点。因此，在这种情况下，如果你不想在这个问题上扔一个更大的（估计是并行的）机器，那么自适应性是必不可少的。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Moritz Allmaras, Texas A&amp;M University, 2007</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    DirichletBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                              Vector&lt;double&gt; &amp;values)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), 2));</div><div class="line"></div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    vector_value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                      std::vector&lt;Vector&lt;double&gt;&gt; &amp;  value_list)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>              declare_parameters();</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">  };</div><div class="line"></div><div class="line">  ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">    : prm(paramhandler)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output filename&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                        <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div><div class="line">  {</div><div class="line">    declare_parameters();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComputeIntensity();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div><div class="line">                                     inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line"></div><div class="line">        computed_quantities[i](0) = std::abs(u);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>UltrasoundProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    Vector&lt;double&gt;       solution, system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div><div class="line">    : prm(param)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div><div class="line">      (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 5, 0, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div><div class="line">            ((face-&gt;center() - transducer).norm_square() &lt; 0.01))</div><div class="line">          {</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">            face-&gt;set_manifold_id(1);</div><div class="line">          }</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refinements);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div><div class="line">                       n_face_q_points = face_quadrature_formula.size(),</div><div class="line">                       dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">                    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">                  {</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div><div class="line">                         ++q_point)</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)) *</div><div class="line">                            (-omega * omega) +</div><div class="line">                          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *</div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)) *</div><div class="line">                            c * c) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div><div class="line">              (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div><div class="line">            {</div><div class="line">              fe_face_values.reinit(cell, face_no);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">                       fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face_no) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face_no))</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                         ++q_point)</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ? -1 :</div><div class="line">                                                                        1) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) * c * omega *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(local_dof_indices[i],</div><div class="line">                              local_dof_indices[j],</div><div class="line">                              cell_matrix(i, j));</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       system_matrix,</div><div class="line">                                       solution,</div><div class="line">                                       system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">    ComputeIntensity&lt;dim&gt; intensities;</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string output_filename = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output filename&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, intensities);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step29</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      ParameterReader  param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"></div><div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div><div class="line">      ultrasound_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
