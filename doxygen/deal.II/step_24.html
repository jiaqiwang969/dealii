<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_24.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-24 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-24 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_23.html">step-23</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Theproblem">The problem</a>
        <li><a href="#Weakformanddiscretization">Weak form and discretization</a>
        <li><a href="#Whattheprogramdoes">What the program does</a>
        <li><a href="#AppendixPDEswithDiracdeltafunctionsasrighthandsideandtheirtransformationtoaninitialvalueproblem">Appendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Theforwardproblemclasstemplate">The "forward problem" class template</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeTATForwardProblemcodeclass">Implementation of the <code>TATForwardProblem</code> class</a>
      <ul>
        <li><a href="#TATForwardProblemsetup_system">TATForwardProblem::setup_system</a>
        <li><a href="#TATForwardProblemsolve_pandTATForwardProblemsolve_v">TATForwardProblem::solve_p and TATForwardProblem::solve_v</a>
        <li><a href="#TATForwardProblemoutput_results">TATForwardProblem::output_results</a>
        <li><a href="#TATForwardProblemrun">TATForwardProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Oneabsorber"> One absorber </a>
        <li><a href="#Multipleabsorbers">Multiple absorbers</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program grew out of a student project by Xing Jin at Texas A&amp;M University. Most of the work for this program is by her. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778.</p>
<p>The program is part of a project that aims to simulate thermoacoustic tomography imaging. In thermoacoustic tomography, pulsed electromagnetic energy is delivered into biological issues. Tissues absorb some of this energy and those parts of the tissue that absorb the most energy generate thermoacoustic waves through thermoelastic expansion. For imaging, one uses that different kinds of tissue, most importantly healthy and diseased tissue, absorb different amounts of energy and therefore expand at different rates. The experimental setup is to measure the amplitude of the pressure waves generated by these sources on the surface of the tissue and try to reconstruct the source distributions, which is indicative for the distribution of absorbers and therefore of different kinds of tissue. Part of this project is to compare simulated data with actual measurements, so one has to solve the "forward problem", i.e. the wave equation that describes the propagation of pressure waves in tissue. This program is therefore a continuation of <a class="el" href="step_23.html">step-23</a>, where the wave equation was first introduced.</p>
<p><a class="anchor" id="Theproblem"></a></p><h3>The problem</h3>
<p>The temperature at a given location, neglecting thermal diffusion, can be stated as</p>
<p class="formulaDsp">
\[ \rho C_p \frac{\partial}{\partial t}T(t,\mathbf r) = H(t,\mathbf r) \]
</p>
<p>Here \(\rho (\mathbf r) \) is the density; \(C_p (\mathbf r) \) is the specific heat; \(\frac{\partial T}{\partial t}(t,\mathbf r)\) is the temperature rise due to the delivered microwave energy; and \(H(t,\mathbf r)\) is the heating function defined as the thermal energy per time and volume transformed from deposited microwave energy.</p>
<p>Let us assume that tissues have heterogeneous dielectric properties but homogeneous acoustic properties. The basic acoustic generation equation in an acoustically homogeneous medium can be described as follows: if \(u\) is the vector-valued displacement, then tissue certainly reacts to changes in pressure by acceleration: </p><p class="formulaDsp">
\[ \rho \frac{\partial^2}{\partial t^2}u(t,\mathbf r) = -\nabla p(t,\mathbf r). \]
</p>
<p> Furthermore, it contracts due to excess pressure and expands based on changes in temperature: </p><p class="formulaDsp">
\[ \nabla \cdot u(t,\mathbf r) = -\frac{p(t,\mathbf r)}{\rho c_0^2}+\beta T(t,\mathbf r) . \]
</p>
<p> Here, \(\beta\) is a thermoexpansion coefficient.</p>
<p>Let us now make the assumption that heating only happens on a time scale much shorter than wave propagation through tissue (i.e. the temporal length of the microwave pulse that heats the tissue is much shorter than the time it takes a wave to cross the domain). In that case, the heating rate \(H(t,\mathbf r)\) can be written as \(H(t,\mathbf r) = a(\mathbf r)\delta(t)\) (where \(a(\mathbf r)\) is a map of absorption strengths for microwave energy and \(\delta(t)\) is the Dirac delta function), which together with the first equation above will yield an instantaneous jump in the temperature \(T(\mathbf r)\) at time \(t=0\). Using this assumption, and taking all equations together, we can rewrite and combine the above as follows: </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt} \]
</p>
<p> where \(\lambda = - \frac{\beta}{C_p}\).</p>
<p>This somewhat strange equation with the derivative of a Dirac delta function on the right hand side can be rewritten as an initial value problem as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \Delta \bar{p}- \frac{1}{c_0^2} \frac{\partial^2 \bar{p}}{\partial t^2} &amp; = &amp; 0 \\ \bar{p}(0,\mathbf r) &amp;=&amp; c_0^2 \lambda a(\mathbf r) = b(\mathbf r) \\ \frac{\partial\bar{p}(0,\mathbf r)}{\partial t} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> (A derivation of this transformation into an initial value problem is given at the end of this introduction as an appendix.)</p>
<p>In the inverse problem, it is the initial condition \(b(\mathbf r) = c_0^2 \lambda a(\mathbf r)\) that one would like to recover, since it is a map of absorption strengths for microwave energy, and therefore presumably an indicator to discern healthy from diseased tissue.</p>
<p>In real application, the thermoacoustic source is very small as compared to the medium. The propagation path of the thermoacoustic waves can then be approximated as from the source to the infinity. Furthermore, detectors are only a limited distance from the source. One only needs to evaluate the values when the thermoacoustic waves pass through the detectors, although they do continue beyond. This is therefore a problem where we are only interested in a small part of an infinite medium, and we do not want waves generated somewhere to be reflected at the boundary of the domain which we consider interesting. Rather, we would like to simulate only that part of the wave field that is contained inside the domain of interest, and waves that hit the boundary of that domain to simply pass undisturbed through the boundary. In other words, we would like the boundary to absorb any waves that hit it.</p>
<p>In general, this is a hard problem: Good absorbing boundary conditions are nonlinear and/or numerically very expensive. We therefore opt for a simple first order approximation to absorbing boundary conditions that reads </p><p class="formulaDsp">
\[ \frac{\partial\bar{p}}{\partial\mathbf n} = -\frac{1}{c_0} \frac{\partial\bar{p}}{\partial t} \]
</p>
<p> Here, \(\frac{\partial\bar{p}}{\partial\mathbf n}\) is the normal derivative at the boundary. It should be noted that this is not a particularly good boundary condition, but it is one of the very few that are reasonably simple to implement.</p>
<p><a class="anchor" id="Weakformanddiscretization"></a></p><h3>Weak form and discretization</h3>
<p>As in <a class="el" href="step_23.html">step-23</a>, one first introduces a second variable, which is defined as the derivative of the pressure potential: </p><p class="formulaDsp">
\[ v = \frac{\partial\bar{p}}{\partial t} \]
</p>
<p>With the second variable, one then transforms the forward problem into two separate equations: </p><p class="formulaDsp">
\begin{eqnarray*} \bar{p}_{t} - v &amp; = &amp; 0 \\ \Delta\bar{p} - \frac{1}{c_0^2}\,v_{t} &amp; = &amp; f \end{eqnarray*}
</p>
<p> with initial conditions: </p><p class="formulaDsp">
\begin{eqnarray*} \bar{p}(0,\mathbf r) &amp; = &amp; b(r) \\ v(0,\mathbf r)=\bar{p}_t(0,\mathbf r) &amp; = &amp; 0. \end{eqnarray*}
</p>
<p> Note that we have introduced a right hand side \(f(t,\mathbf r)\) here to show how to derive these formulas in the general case, although in the application to the thermoacoustic problem \(f=0\).</p>
<p>The semi-discretized, weak version of this model, using the general \(\theta\) scheme introduced in <a class="el" href="step_23.html">step-23</a> is then: </p><p class="formulaDsp">
\begin{eqnarray*} \left(\frac{\bar{p}^n-\bar{p}^{n-1}}{k},\phi\right)_\Omega- \left(\theta v^{n}+(1-\theta)v^{n-1},\phi\right)_\Omega &amp; = &amp; 0 \\ -\left(\nabla((\theta\bar{p}^n+(1-\theta)\bar{p}^{n-1})),\nabla\phi\right)_\Omega- \frac{1}{c_0}\left(\frac{\bar{p}^n-\bar{p}^{n-1}}{k},\phi\right)_{\partial\Omega} - \frac{1}{c_0^2}\left(\frac{v^n-v^{n-1}}{k},\phi\right)_\Omega &amp; = &amp; \left(\theta f^{n}+(1-\theta)f^{n-1}, \phi\right)_\Omega, \end{eqnarray*}
</p>
<p> where \(\phi\) is an arbitrary test function, and where we have used the absorbing boundary condition to integrate by parts: absorbing boundary conditions are incorporated into the weak form by using </p><p class="formulaDsp">
\[ \int_\Omega\varphi \, \Delta p\; dx = -\int_\Omega\nabla \varphi \cdot \nabla p dx + \int_{\partial\Omega}\varphi \frac{\partial p}{\partial {\mathbf n}}ds. \]
</p>
<p>From this we obtain the discrete model by introducing a finite number of shape functions, and get </p><p class="formulaDsp">
\begin{eqnarray*} M\bar{p}^{n}-k \theta M v^n &amp; = &amp; M\bar{p}^{n-1}+k (1-\theta)Mv^{n-1},\\ (-c_0^2k \theta A-c_0 B)\bar{p}^n-Mv^{n} &amp; = &amp; (c_0^2k(1-\theta)A-c_0B)\bar{p}^{n-1}-Mv^{n-1}+c_0^2k(\theta F^{n}+(1-\theta)F^{n-1}). \end{eqnarray*}
</p>
<p> The matrices \(M\) and \(A\) are here as in <a class="el" href="step_23.html">step-23</a>, and the boundary mass matrix </p><p class="formulaDsp">
\[ B_{ij} = \left(\varphi_i,\varphi_j\right)_{\partial\Omega} \]
</p>
<p> results from the use of absorbing boundary conditions.</p>
<p>Above two equations can be rewritten in a matrix form with the pressure and its derivative as an unknown vector: </p><p class="formulaDsp">
\[ \left(\begin{array}{cc} M &amp; -k\theta M \\ c_0^2\,k\,\theta\,A+c_0\,B &amp; M \\ \end{array} \right)\\ \left(\begin{array}{c} \bar{p}^{n} \\ \bar{v}^{n} \end{array}\right)=\\ \left(\begin{array}{l} G_1 \\ G_2 -(\theta F^{n}+(1-\theta)F ^{n-1})c_{0}^{2}k \\ \end{array}\right) \]
</p>
<p>where </p><p class="formulaDsp">
\[ \left(\begin{array}{c} G_1 \\ G_2 \\ \end{array} \right)=\\ \left(\begin{array}{l} M\bar{p}^{n-1}+k(1-\theta)Mv^{n-1}\\ (-c_{0}^{2}k (1-\theta)A+c_0 B)\bar{p}^{n-1} +Mv^{n-1} \end{array}\right) \]
</p>
<p>By simple transformations, one then obtains two equations for the pressure potential and its derivative, just as in the previous tutorial program: </p><p class="formulaDsp">
\begin{eqnarray*} (M+(k\,\theta\,c_{0})^{2}A+c_0k\theta B)\bar{p}^{n} &amp; = &amp; G_{1}+(k\, \theta)G_{2}-(c_0k)^2\theta (\theta F^{n}+(1-\theta)F^{n-1}) \\ Mv^n &amp; = &amp; -(c_0^2\,k\, \theta\, A+c_0B)\bar{p}^{n}+ G_2 - c_0^2k(\theta F^{n}+(1-\theta)F^{n-1}) \end{eqnarray*}
</p>
<p><a class="anchor" id="Whattheprogramdoes"></a></p><h3>What the program does</h3>
<p>Compared to <a class="el" href="step_23.html">step-23</a>, this programs adds the treatment of a simple absorbing boundary conditions. In addition, it deals with data obtained from actual experimental measurements. To this end, we need to evaluate the solution at points at which the experiment also evaluates a real pressure field. We will see how to do that using the <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a> function further down below.</p>
<p><a class="anchor" id="AppendixPDEswithDiracdeltafunctionsasrighthandsideandtheirtransformationtoaninitialvalueproblem"></a></p><h3>Appendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem</h3>
<p>In the derivation of the initial value problem for the wave equation, we initially found that the equation had the derivative of a Dirac delta function as a right hand side: </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt}. \]
</p>
<p> In order to see how to transform this single equation into the usual statement of a PDE with initial conditions, let us make the assumption that the physically quite reasonable medium is at rest initially, i.e. \(p(t,\mathbf r)=\frac{\partial p(t,\mathbf r)}{\partial t}=0\) for \(t&lt;0\). Next, let us form the indefinite integral with respect to time of both sides: </p><p class="formulaDsp">
\[ \int^t \Delta p\; dt -\int^t \frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} \; dt = \int^t \lambda a(\mathbf r)\frac{d\delta(t)}{dt} \;dt. \]
</p>
<p> This immediately leads to the statement </p><p class="formulaDsp">
\[ P(t,\mathbf r) - \frac{1}{c_0^2} \frac{\partial p}{\partial t} = \lambda a(\mathbf r) \delta(t), \]
</p>
<p> where \(P(t,\mathbf r)\) is such that \(\frac{dP(t,\mathbf r)}{dt}=\Delta p\). Next, we form the (definite) integral over time from \(t=-\epsilon\) to \(t=+\epsilon\) to find </p><p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon} P(t,\mathbf r)\; dt - \frac{1}{c_0^2} \left[ p(\epsilon,\mathbf r) - p(-\epsilon,\mathbf r) \right] = \int_{-\epsilon}^{\epsilon} \lambda a(\mathbf r) \delta(t) \; dt. \]
</p>
<p> If we use the property of the delta function that \(\int_{-\epsilon}^{\epsilon} \delta(t)\; dt = 1\), and assume that \(P\) is a continuous function in time, we find as we let \(\epsilon\) go to zero that </p><p class="formulaDsp">
\[ - \lim_{\epsilon\rightarrow 0}\frac{1}{c_0^2} \left[ p(\epsilon,\mathbf r) - p(-\epsilon,\mathbf r) \right] = \lambda a(\mathbf r). \]
</p>
<p> In other words, using that \(p(-\epsilon,\mathbf r)=0\), we retrieve the initial condition </p><p class="formulaDsp">
\[ \frac{1}{c_0^2} p(0,\mathbf r) = \lambda a(\mathbf r). \]
</p>
<p> At the same time, we know that for every \(t&gt;0\) the delta function is zero, so for \(0&lt;t&lt;T\) we get the equation </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = 0. \]
</p>
<p> Consequently, we have obtained a representation of the wave equation and one initial condition from the original somewhat strange equation.</p>
<p>Finally, because we here have an equation with two time derivatives, we still need a second initial condition. To this end, let us go back to the equation </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt}. \]
</p>
<p> and integrate it in time from \(t=-\epsilon\) to \(t=+\epsilon\). This leads to </p><p class="formulaDsp">
\[ P(\epsilon)-P(-\epsilon) -\frac{1}{c_0^2} \left[\frac{\partial p(\epsilon)}{\partial t} - \frac{\partial p(-\epsilon)}{\partial t}\right] = \lambda a(\mathbf r) \int_{-\epsilon}^{\epsilon}\frac{d\delta(t)}{dt} \; dt. \]
</p>
<p> Using integration by parts of the form </p><p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon}\varphi(t)\frac{d\delta(t)}{dt} \; dt = -\int_{-\epsilon}^{\epsilon}\frac{d\varphi(t)}{dt} \delta(t)\; dt \]
</p>
<p> where we use that \(\delta(\pm \epsilon)=0\) and inserting \(\varphi(t)=1\), we see that in fact </p><p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon}\frac{d\delta(t)}{dt} \; dt = 0. \]
</p>
<p>Now, let \(\epsilon\rightarrow 0\). Assuming that \(P\) is a continuous function in time, we see that </p><p class="formulaDsp">
\[ P(\epsilon)-P(-\epsilon) \rightarrow 0, \]
</p>
<p> and consequently </p><p class="formulaDsp">
\[ \frac{\partial p(\epsilon)}{\partial t} - \frac{\partial p(-\epsilon)}{\partial t} \rightarrow 0. \]
</p>
<p> However, we have assumed that \(\frac{\partial p(-\epsilon)}{\partial t}=0\). Consequently, we obtain as the second initial condition that </p><p class="formulaDsp">
\[ \frac{\partial p(0)}{\partial t} = 0, \]
</p>
<p> completing the system of equations.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following have all been covered previously:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This is the only new one: We will need a library function defined in the namespace <a class="el" href="namespaceGridTools.html">GridTools</a> that computes the minimal cell diameter.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step24</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Theforwardproblemclasstemplate"></a> </p><h3>The "forward problem" class template</h3>
<p>The first part of the main class is exactly as in <a class="el" href="step_23.html">step-23</a> (except for the name):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TATForwardProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TATForwardProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> solve_p();</div><div class="line">  <span class="keywordtype">void</span> solve_v();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_p, solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> old_solution_p, old_solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs_p, system_rhs_v;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step, time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div></div><!-- fragment --><p>Here's what's new: first, we need that boundary mass matrix \(B\) that came out of the absorbing boundary condition. Likewise, since this time we consider a realistic medium, we must have a measure of the wave speed \(c_0\) that will enter all the formulas with the Laplace matrix (which we still define as \((\nabla \phi_i,\nabla \phi_j)\)):</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> boundary_matrix;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         wave_speed;</div></div><!-- fragment --><p>The last thing we have to take care of is that we wanted to evaluate the solution at a certain number of detector locations. We need an array to hold these locations, declared here and filled in the constructor:</p>
<div class="fragment"><div class="line">  std::vector&lt;Point&lt;dim&gt;&gt; detector_locations;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>As usual, we have to define our initial values, boundary conditions, and right hand side functions. Things are a bit simpler this time: we consider a problem that is driven by initial conditions, so there is no right hand side function (though you could look up in <a class="el" href="step_23.html">step-23</a> to see how this can be done). Secondly, there are no boundary conditions: the entire boundary of the domain consists of absorbing boundary conditions. That only leaves initial conditions, and there things are simple too since for this particular application only nonzero initial conditions for the pressure are prescribed, not for the velocity (which is zero at the initial time).</p>
<p>So this is all we need: a class that specifies initial conditions for the pressure. In the physical setting considered in this program, these are small absorbers, which we model as a series of little circles where we assume that the pressure surplus is one, whereas no absorption and therefore no pressure surplus is everywhere else. This is how we do things (note that if we wanted to expand this program to not only compile but also to run, we would have to initialize the sources with three-dimensional source locations):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesP : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> std::array&lt;Source, 5&gt; sources{</div><div class="line">      {Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0), 0.025),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.135, 0), 0.05),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.17, 0), 0.03),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.25, 0), 0.02),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.05, -0.15), 0.015)}};</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;source : sources)</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(source.location) &lt; source.radius)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">struct </span>Source</div><div class="line">  {</div><div class="line">    Source(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> r)</div><div class="line">      : location(l)</div><div class="line">      , radius(r)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> location;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     radius;</div><div class="line">  };</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeTATForwardProblemcodeclass"></a> </p><h3>Implementation of the <code>TATForwardProblem</code> class</h3>
<p>Let's start again with the constructor. Setting the member variables is straightforward. We use the acoustic wave speed of mineral oil (in millimeters per microsecond, a common unit in experimental biomedical imaging) since this is where many of the experiments we want to compare the output with are made in. The Crank-Nicolson scheme is used again, i.e. theta is set to 0.5. The time step is later selected to satisfy \(k = \frac hc\): here we initialize it to an invalid number.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TATForwardProblem&lt;dim&gt;::TATForwardProblem()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time_step(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , time(time_step)</div><div class="line">  , timestep_number(1)</div><div class="line">  , theta(0.5)</div><div class="line">  , wave_speed(1.437)</div><div class="line">{</div></div><!-- fragment --><p>The second task in the constructor is to initialize the array that holds the detector locations. The results of this program were compared with experiments in which the step size of the detector spacing is 2.25 degree, corresponding to 160 detector locations. The radius of the scanning circle is selected to be half way between the center and the boundary to avoid that the remaining reflections from the imperfect boundary condition spoils our numerical results.</p>
<p>The locations of the detectors are then calculated in clockwise order. Note that the following of course only works if we are computing in 2d, a condition that we guard with an assertion. If we later wanted to run the same program in 3d, we would have to add code here for the initialization of detector locations in 3d. Due to the assertion, there is no way we can forget to do this.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> detector_step_angle = 2.25;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> detector_radius     = 0.5;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">double</span> detector_angle = 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>; detector_angle &gt;= 0;</div><div class="line">       detector_angle -= detector_step_angle / 360 * 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</div><div class="line">    detector_locations.push_back(</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(std::cos(detector_angle), std::sin(detector_angle)) *</div><div class="line">      detector_radius);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemsetup_system"></a> </p><h4>TATForwardProblem::setup_system</h4>
<p>The following system is pretty much what we've already done in <a class="el" href="step_23.html">step-23</a>, but with two important differences. First, we have to create a circular (or spherical) mesh around the origin, with a radius of 1. This nothing new: we've done so before in <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_10.html">step-10</a>, where we also explain how the <a class="el" href="classPolarManifold.html">PolarManifold</a> or <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object places new points on concentric circles when a cell is refined, which we will use here as well.</p>
<p>One thing we had to make sure is that the time step satisfies the CFL condition discussed in the introduction of <a class="el" href="step_23.html">step-23</a>. Back in that program, we ensured this by hand by setting a timestep that matches the mesh width, but that was error prone because if we refined the mesh once more we would also have to make sure the time step is changed. Here, we do that automatically: we ask a library function for the minimal diameter of any cell. Then we set \(k=\frac h{c_0}\). The only problem is: what exactly is \(h\)? The point is that there is really no good theory on this question for the wave equation. It is known that for uniformly refined meshes consisting of rectangles, \(h\) is the minimal edge length. But for meshes on general quadrilaterals, the exact relationship appears to be unknown, i.e. it is unknown what properties of cells are relevant for the CFL condition. The problem is that the CFL condition follows from knowledge of the smallest eigenvalue of the Laplace matrix, and that can only be computed analytically for simply structured meshes.</p>
<p>The upshot of all this is that we're not quite sure what exactly we should take for \(h\). The function <a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a> computes the minimal diameter of all cells. If the cells were all squares or cubes, then the minimal edge length would be the minimal diameter divided by <code>std::sqrt(dim)</code>. We simply generalize this, without theoretical justification, to the case of non-uniform meshes.</p>
<p>The only other significant change is that we need to build the boundary mass matrix. We will comment on this further down below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation, center, 1.);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">  time_step = <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / wave_speed /</div><div class="line">              <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">  laplace_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                       laplace_matrix);</div></div><!-- fragment --><p>The second difference, as mentioned, to <a class="el" href="step_23.html">step-23</a> is that we need to build the boundary mass matrix that grew out of the absorbing boundary conditions.</p>
<p>A first observation would be that this matrix is much sparser than the regular mass matrix, since none of the shape functions with purely interior support contribute to this matrix. We could therefore optimize the storage pattern to this situation and build up a second sparsity pattern that only contains the nonzero entries that we need. There is a trade-off to make here: first, we would have to have a second sparsity pattern object, so that costs memory. Secondly, the matrix attached to this sparsity pattern is going to be smaller and therefore requires less memory; it would also be faster to perform matrix-vector multiplications with it. The final argument, however, is the one that tips the scale: we are not primarily interested in performing matrix-vector with the boundary matrix alone (though we need to do that for the right hand side vector once per time step), but mostly wish to add it up to the other matrices used in the first of the two equations since this is the one that is going to be multiplied with once per iteration of the CG method, i.e. significantly more often. It is now the case that the <a class="el" href="classSparseMatrix.html#acabf7629046afdd9077f77f7746a7a3f">SparseMatrix::add</a> class allows to add one matrix to another, but only if they use the same sparsity pattern (the reason being that we can't add nonzero entries to a matrix after the sparsity pattern has been created, so we simply require that the two matrices have the same sparsity pattern).</p>
<p>So let's go with that:</p>
<div class="fragment"><div class="line">boundary_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The second thing to do is to actually build the matrix. Here, we need to integrate over faces of cells, so first we need a quadrature object that works on <code>dim-1</code> dimensional objects. Secondly, the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> variant of <a class="el" href="classFEValues.html">FEValues</a> that works on faces, as its name suggest. And finally, the other variables that are part of the assembly machinery. All of this we put between curly braces to limit the scope of these variables to where we actually need them.</p>
<p>The actual act of assembling the matrix is then fairly straightforward: we loop over all cells, over all faces of each of these cells, and then do something only if that particular face is at the boundary of the domain. Like this:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                                quadrature_formula,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            cell_matrix = 0;</div><div class="line"></div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">            cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                boundary_matrix.add(local_dof_indices[i],</div><div class="line">                                    local_dof_indices[j],</div><div class="line">                                    cell_matrix(i, j));</div><div class="line">          }</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  system_matrix.add(time_step * time_step * theta * theta * wave_speed *</div><div class="line">                      wave_speed,</div><div class="line">                    laplace_matrix);</div><div class="line">  system_matrix.add(wave_speed * theta * time_step, boundary_matrix);</div><div class="line"></div><div class="line"></div><div class="line">  solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemsolve_pandTATForwardProblemsolve_v"></a> </p><h4>TATForwardProblem::solve_p and TATForwardProblem::solve_v</h4>
<p>The following two functions, solving the linear systems for the pressure and the velocity variable, are taken pretty much verbatim (with the exception of the change of name from \(u\) to \(p\) of the primary variable) from <a class="el" href="step_23.html">step-23</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_p()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_p.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(system_matrix, solution_p, system_rhs_p, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   p-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_v()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_v.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>, solution_v, system_rhs_v, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemoutput_results"></a> </p><h4>TATForwardProblem::output_results</h4>
<p>The same holds here: the function is from <a class="el" href="step_23.html">step-23</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_p, <span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">  vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">    DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemrun"></a> </p><h4>TATForwardProblem::run</h4>
<p>This function that does most of the work is pretty much again like in <a class="el" href="step_23.html">step-23</a>, though we make things a bit clearer by using the vectors G1 and G2 mentioned in the introduction. Compared to the overall memory consumption of the program, the introduction of a few temporary vectors isn't doing much harm.</p>
<p>The only changes to this function are: first, that we do not have to project initial values for the velocity \(v\), since we know that it is zero. And second that we evaluate the solution at the detector locations computed in the constructor. This is done using the <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a> function. These values are then written to a file that we open at the beginning of the function.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TATForwardProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesP&lt;dim&gt;(),</div><div class="line">                         old_solution_p);</div><div class="line">    old_solution_v = 0;</div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream detector_data(<span class="stringliteral">&quot;detectors.dat&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution_p.size());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> G1(solution_p.size());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> G2(solution_v.size());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 0.7;</div><div class="line">    <span class="keywordflow">for</span> (time = time_step; time &lt;= end_time;</div><div class="line">         time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;time_step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; @ t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G1, old_solution_p);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        G1.add(time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G2, old_solution_v);</div><div class="line">        laplace_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(wave_speed, tmp);</div><div class="line"></div><div class="line">        system_rhs_p = G1;</div><div class="line">        system_rhs_p.add(time_step * theta, G2);</div><div class="line"></div><div class="line">        solve_p();</div><div class="line"></div><div class="line">        system_rhs_v = G2;</div><div class="line">        laplace_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-wave_speed, tmp);</div><div class="line"></div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        detector_data &lt;&lt; time;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; detector_locations.size(); ++i)</div><div class="line">          detector_data &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler,</div><div class="line">                                                    solution_p,</div><div class="line">                                                    detector_locations[i])</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">        detector_data &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_p = solution_p;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step24</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>What remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step24;</div><div class="line"></div><div class="line">      TATForwardProblem&lt;2&gt; forward_problem_solver;</div><div class="line">      forward_problem_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program writes both graphical data for each time step as well as the values evaluated at each detector location to disk. We then draw them in plots. Experimental data were also collected for comparison. Currently our experiments have only been done in two dimensions by circularly scanning a single detector. The tissue sample here is a thin slice in the \(X-Y\) plane ( \(Z=0\)), and we assume that signals from other \(Z\) directions won't contribute to the data. Consequently, we only have to compare our experimental data with two dimensional simulated data.</p>
<p><a class="anchor" id="Oneabsorber"></a></p><h3>One absorber </h3>
<p>This movie shows the thermoacoustic waves generated by a single small absorber propagating in the medium (in our simulation, we assume the medium is mineral oil, which has a acoustic speed of 1.437 \(\frac{mm}{\mu s}\)):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_movie.gif"/>
</div>
<p>For a single absorber, we of course have to change the <code>InitialValuesP</code> class accordingly.</p>
<p>Next, let us compare experimental and computational results. The visualization uses a technique long used in seismology, where the data of each detector is plotted all in one graph. The way this is done is by offsetting each detector's signal a bit compared to the previous one. For example, here is a plot of the first four detectors (from bottom to top, with time in microseconds running from left to right) using the source setup used in the program, to make things a bit more interesting compared to the present case of only a single source:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.traces.png"/>
</div>
<p>One thing that can be seen, for example, is that the arrival of the second and fourth signals shifts to earlier times for greater detector numbers (i.e. the topmost ones), but not the first and the third; this can be interpreted to mean that the origin of these signals must be closer to the latter detectors than to the former ones.</p>
<p>If we stack not only 4, but all 160 detectors in one graph, the individual lines blur, but where they run together they create a pattern of darker or lighter grayscales. The following two figures show the results obtained at the detector locations stacked in that way. The left figure is obtained from experiments, and the right is the simulated data. In the experiment, a single small strong absorber was embedded in weaker absorbing tissue:</p>
<table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_s.png"/>
</div>
   </td></tr>
</table>
<p>It is obvious that the source location is closer to the detectors at angle \(180^\circ\). All the other signals that can be seen in the experimental data result from the fact that there are weak absorbers also in the rest of the tissue, which surrounds the signals generated by the small strong absorber in the center. On the other hand, in the simulated data, we only simulate the small strong absorber.</p>
<p>In reality, detectors have limited bandwidth. The thermoacoustic waves passing through the detector will therefore be filtered. By using a high-pass filter (implemented in MATLAB and run against the data file produced by this program), the simulated results can be made to look closer to the experimental data:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_sf.png"/>
</div>
<p>In our simulations, we see spurious signals behind the main wave that result from numerical artifacts. This problem can be alleviated by using finer mesh, resulting in the following plot:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_s2.png"/>
</div>
<p><a class="anchor" id="Multipleabsorbers"></a></p><h3>Multiple absorbers</h3>
<p>To further verify the program, we will also show simulation results for multiple absorbers. This corresponds to the case that is actually implemented in the program. The following movie shows the propagation of the generated thermoacoustic waves in the medium by multiple absorbers:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_movie.gif"/>
</div>
<p>Experimental data and our simulated data are compared in the following two figures: </p><table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_s.png"/>
</div>
   </td></tr>
</table>
<p>Note that in the experimental data, the first signal (i.e. the left-most dark line) results from absorption at the tissue boundary, and therefore reaches the detectors first and before any of the signals from the interior. This signal is also faintly visible at the end of the traces, around 30 \(\mu s\), which indicates that the signal traveled through the entire tissue to reach detectors at the other side, after all the signals originating from the interior have reached them.</p>
<p>As before, the numerical result better matches experimental ones by applying a bandwidth filter that matches the actual behavior of detectors (left) and by choosing a finer mesh (right):</p>
<table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_sf.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_s2.png"/>
</div>
   </td></tr>
</table>
<p>One of the important differences between the left and the right figure is that the curves look much less "angular" at the right. The angularity comes from the fact that while waves in the continuous equation travel equally fast in all directions, this isn't the case after discretization: there, waves that travel diagonal to cells move at slightly different speeds to those that move parallel to mesh lines. This anisotropy leads to wave fronts that aren't perfectly circular (and would produce sinusoidal signals in the stacked plots), but are bulged out in certain directions. To make things worse, the circular mesh we use (see for example <a class="el" href="step_6.html">step-6</a> for a view of the coarse mesh) is not isotropic either. The net result is that the signal fronts are not sinusoidal unless the mesh is sufficiently fine. The right image is a lot better in this respect, though artifacts in the form of trailing spurious waves can still be seen.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Xing Jin, Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step24</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TATForwardProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TATForwardProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> solve_p();</div><div class="line">    <span class="keywordtype">void</span> solve_v();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution_p, solution_v;</div><div class="line">    Vector&lt;double&gt; old_solution_p, old_solution_v;</div><div class="line">    Vector&lt;double&gt; system_rhs_p, system_rhs_v;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step, time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> boundary_matrix;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>         wave_speed;</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; detector_locations;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesP : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> std::array&lt;Source, 5&gt; sources{</div><div class="line">        {Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0), 0.025),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.135, 0), 0.05),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.17, 0), 0.03),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.25, 0), 0.02),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.05, -0.15), 0.015)}};</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;source : sources)</div><div class="line">        <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(source.location) &lt; source.radius)</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">struct </span>Source</div><div class="line">    {</div><div class="line">      Source(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> r)</div><div class="line">        : location(l)</div><div class="line">        , radius(r)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> location;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>     radius;</div><div class="line">    };</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TATForwardProblem&lt;dim&gt;::TATForwardProblem()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time_step(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , time(time_step)</div><div class="line">    , timestep_number(1)</div><div class="line">    , theta(0.5)</div><div class="line">    , wave_speed(1.437)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> detector_step_angle = 2.25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> detector_radius     = 0.5;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> detector_angle = 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>; detector_angle &gt;= 0;</div><div class="line">         detector_angle -= detector_step_angle / 360 * 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</div><div class="line">      detector_locations.push_back(</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(std::cos(detector_angle), std::sin(detector_angle)) *</div><div class="line">        detector_radius);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation, center, 1.);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    time_step = <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / wave_speed /</div><div class="line">                <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">    laplace_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         laplace_matrix);</div><div class="line"></div><div class="line">    boundary_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              cell_matrix = 0;</div><div class="line"></div><div class="line">              fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  boundary_matrix.add(local_dof_indices[i],</div><div class="line">                                      local_dof_indices[j],</div><div class="line">                                      cell_matrix(i, j));</div><div class="line">            }</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    system_matrix.add(time_step * time_step * theta * theta * wave_speed *</div><div class="line">                        wave_speed,</div><div class="line">                      laplace_matrix);</div><div class="line">    system_matrix.add(wave_speed * theta * time_step, boundary_matrix);</div><div class="line"></div><div class="line"></div><div class="line">    solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_p()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_p.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(system_matrix, solution_p, system_rhs_p, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   p-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_v()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_v.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>, solution_v, system_rhs_v, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_p, <span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">    vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TATForwardProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesP&lt;dim&gt;(),</div><div class="line">                         old_solution_p);</div><div class="line">    old_solution_v = 0;</div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream detector_data(<span class="stringliteral">&quot;detectors.dat&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(solution_p.size());</div><div class="line">    Vector&lt;double&gt; G1(solution_p.size());</div><div class="line">    Vector&lt;double&gt; G2(solution_v.size());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 0.7;</div><div class="line">    <span class="keywordflow">for</span> (time = time_step; time &lt;= end_time;</div><div class="line">         time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;time_step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; @ t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G1, old_solution_p);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        G1.add(time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G2, old_solution_v);</div><div class="line">        laplace_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(wave_speed, tmp);</div><div class="line"></div><div class="line">        system_rhs_p = G1;</div><div class="line">        system_rhs_p.add(time_step * theta, G2);</div><div class="line"></div><div class="line">        solve_p();</div><div class="line"></div><div class="line">        system_rhs_v = G2;</div><div class="line">        laplace_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-wave_speed, tmp);</div><div class="line"></div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        detector_data &lt;&lt; time;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; detector_locations.size(); ++i)</div><div class="line">          detector_data &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler,</div><div class="line">                                                    solution_p,</div><div class="line">                                                    detector_locations[i])</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">        detector_data &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_p = solution_p;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step24</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step24;</div><div class="line"></div><div class="line">      TATForwardProblem&lt;2&gt; forward_problem_solver;</div><div class="line">      forward_problem_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_23.html">step-23</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Theproblem">The problem</a><a href="#Theproblem">The problem</a>
        <li><a href="#Weakformanddiscretization">Weak form and discretization</a><a href="#Weakformanddiscretization">Weak form and discretization</a>
        <li><a href="#Whattheprogramdoes">What the program does</a><a href="#Whattheprogramdoes">What the program does</a>
        <li><a href="#AppendixPDEswithDiracdeltafunctionsasrighthandsideandtheirtransformationtoaninitialvalueproblem">Appendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem</a><a href="#AppendixPDEswithDiracdeltafunctionsasrighthandsideandtheirtransformationtoaninitialvalueproblem">Appendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Theforwardproblemclasstemplate">The "forward problem" class template</a><a href="#Theforwardproblemclasstemplate">The "forward problem" class template</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeTATForwardProblemcodeclass">Implementation of the <code>TATForwardProblem</code> class</a><a href="#ImplementationofthecodeTATForwardProblemcodeclass">Implementation of the <code>TATForwardProblem</code> class</a>
      <ul>
        <li><a href="#TATForwardProblemsetup_system">TATForwardProblem::setup_system</a><a href="#TATForwardProblemsetup_system">TATForwardProblem::setup_system</a>
        <li><a href="#TATForwardProblemsolve_pandTATForwardProblemsolve_v">TATForwardProblem::solve_p and TATForwardProblem::solve_v</a><a href="#TATForwardProblemsolve_pandTATForwardProblemsolve_v">TATForwardProblem::solve_p and TATForwardProblem::solve_v</a>
        <li><a href="#TATForwardProblemoutput_results">TATForwardProblem::output_results</a><a href="#TATForwardProblemoutput_results">TATForwardProblem::output_results</a>
        <li><a href="#TATForwardProblemrun">TATForwardProblem::run</a><a href="#TATForwardProblemrun">TATForwardProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Oneabsorber"> One absorber </a><a href="#Oneabsorber"> One absorber </a>
        <li><a href="#Multipleabsorbers">Multiple absorbers</a><a href="#Multipleabsorbers">Multiple absorbers</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program grew out of a student project by Xing Jin at Texas A&amp;MUniversity. Most of the work for this program is by her. Some of the work onthis tutorial program has been funded by NSF under grant DMS-0604778. The program is part of a project that aims to simulate thermoacoustictomography imaging. In thermoacoustic tomography, pulsed electromagneticenergy is delivered into biological issues. Tissues absorb some of this energyand those parts of the tissue that absorb the most energy generatethermoacoustic waves through thermoelastic expansion. For imaging, one usesthat different kinds of tissue, most importantly healthy and diseased tissue,absorb different amounts of energy and therefore expand at differentrates. The experimental setup is to measure the amplitude of the pressurewaves generated by these sources on the surface of the tissue and try toreconstruct the source distributions, which is indicative for the distributionof absorbers and therefore of different kinds of tissue. Part of this projectis to compare simulated data with actual measurements, so one has to solve the"forward problem", i.e. the wave equation that describes the propagation ofpressure waves in tissue. This program is therefore a continuation of <a class="el" href="step_23.html">step_23 </a>step-23"  ", where the wave equation was first introduced.</p>
<p><a class="anchor" id="Theproblem"></a></p><h3>The problem</h3>
<p>The temperature at a given location, neglecting thermal diffusion, can bestated as </p><p class="formulaDsp">
\[ \rho C_p \frac{\partial}{\partial t}T(t,\mathbf r) = H(t,\mathbf r) \]
</p>
<p> Here \(\rho (\mathbf r) \) is the density; \(C_p (\mathbf r) \) is the specificheat; \(\frac{\partial T}{\partial t}(t,\mathbf r)\) is the temperature rise dueto the delivered microwave energy; and \(H(t,\mathbf r)\) is the heatingfunction defined as the thermal energy per time and volume transformed fromdeposited microwave energy. Let us assume that tissues have heterogeneous dielectric properties buthomogeneous acoustic properties. The basic acoustic generation equation in anacoustically homogeneous medium can be described as follows: if \(u\) is thevector-valued displacement, then tissue certainly reacts to changes inpressure by acceleration: </p><p class="formulaDsp">
\[ \rho \frac{\partial^2}{\partial t^2}u(t,\mathbf r) = -\nabla p(t,\mathbf r). \]
</p>
<p>, it contracts due to excess pressure and expands based on changes in temperature: </p><p class="formulaDsp">
\[ \nabla \cdot u(t,\mathbf r) = -\frac{p(t,\mathbf r)}{\rho c_0^2}+\beta T(t,\mathbf r) . \]
</p>
<p>, \(\beta\) is a thermoexpansion coefficient. Let us now make the assumption that heating only happens on a timescale much shorter than wave propagation through tissue (i.e. the temporallength of the microwave pulse that heats the tissue is much shorter than thetime it takes a wave to cross the domain). In that case, the heatingrate \(H(t,\mathbf r)\) can be written as \(H(t,\mathbf r) = a(\mathbf r)\delta(t)\) (where \(a(\mathbf r)\) is a map of absorption strengths formicrowave energy and \(\delta(t)\) is the Dirac delta function), which togetherwith the first equation above will yieldan instantaneous jump in the temperature \(T(\mathbf r)\) at time \(t=0\) .Using this assumption, and taking all equations together, we canrewrite and combine the above as follows: </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt} \]
</p>
<p> \(\lambda = - \frac{\beta}{C_p}\) . This somewhat strange equation with the derivative of a Dirac delta functionon the right hand side can be rewritten as an initial value problem as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \Delta \bar{p}- \frac{1}{c_0^2} \frac{\partial^2 \bar{p}}{\partial t^2} &amp; = &amp; 0 \\ \bar{p}(0,\mathbf r) &amp;=&amp; c_0^2 \lambda a(\mathbf r) = b(\mathbf r) \\ \frac{\partial\bar{p}(0,\mathbf r)}{\partial t} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> (A derivation of this transformation into an initial value problem is given atthe end of this introduction as an appendix.) In the inverse problem, it is the initial condition \(b(\mathbf r) = c_0^2 \lambda a(\mathbf r)\) thatone would like to recover, since it is a map of absorption strengths formicrowave energy, and therefore presumably an indicator to discern healthyfrom diseased tissue. In real application, the thermoacoustic source is very small as compared tothe medium. The propagation path of the thermoacoustic waves can then beapproximated as from the source to the infinity. Furthermore, detectors areonly a limited distance from the source. One only needs to evaluate the valueswhen the thermoacoustic waves pass through the detectors, although they docontinue beyond. This is therefore a problem where we are only interested in asmall part of an infinite medium, and we do not want waves generated somewhereto be reflected at the boundary of the domain which we considerinteresting. Rather, we would like to simulate only that part of the wavefield that is contained inside the domain of interest, and waves that hit theboundary of that domain to simply pass undisturbed through the boundary. Inother words, we would like the boundary to absorb any waves that hit it. In general, this is a hard problem: Good absorbing boundary conditions arenonlinear and/or numerically very expensive. We therefore opt for a simplefirst order approximation to absorbing boundary conditions that reads </p><p class="formulaDsp">
\[ \frac{\partial\bar{p}}{\partial\mathbf n} = -\frac{1}{c_0} \frac{\partial\bar{p}}{\partial t} \]
</p>
<p>, \(\frac{\partial\bar{p}}{\partial\mathbf n}\) is the normal derivative atthe boundary. It should be noted that this is not a particularly good boundarycondition, but it is one of the very few that are reasonably simple to implement.</p>
<p><a class="anchor" id="Weakformanddiscretization"></a></p><h3>Weak form and discretization</h3>
<p>As in <a class="el" href="step_23.html">step-23</a> , one first introduces a second variable, which isdefined as the derivative of the pressure potential: </p><p class="formulaDsp">
\[ v = \frac{\partial\bar{p}}{\partial t} \]
</p>
<p> With the second variable, one then transforms the forward problem intotwo separate equations: </p><p class="formulaDsp">
\begin{eqnarray*} \bar{p}_{t} - v &amp; = &amp; 0 \\ \Delta\bar{p} - \frac{1}{c_0^2}\,v_{t} &amp; = &amp; f \end{eqnarray*}
</p>
<p> with initial conditions: </p><p class="formulaDsp">
\begin{eqnarray*} \bar{p}(0,\mathbf r) &amp; = &amp; b(r) \\ v(0,\mathbf r)=\bar{p}_t(0,\mathbf r) &amp; = &amp; 0. \end{eqnarray*}
</p>
<p> Note that we have introduced a right hand side \(f(t,\mathbf r)\) here to showhow to derive these formulas in the general case, although in the applicationto the thermoacoustic problem \(f=0\) . The semi-discretized, weak version of this model, using the general \(\theta\) schemeintroduced in <a class="el" href="step_23.html">step-23</a> is then: </p><p class="formulaDsp">
\begin{eqnarray*} \left(\frac{\bar{p}^n-\bar{p}^{n-1}}{k},\phi\right)_\Omega- \left(\theta v^{n}+(1-\theta)v^{n-1},\phi\right)_\Omega &amp; = &amp; 0 \\ -\left(\nabla((\theta\bar{p}^n+(1-\theta)\bar{p}^{n-1})),\nabla\phi\right)_\Omega- \frac{1}{c_0}\left(\frac{\bar{p}^n-\bar{p}^{n-1}}{k},\phi\right)_{\partial\Omega} - \frac{1}{c_0^2}\left(\frac{v^n-v^{n-1}}{k},\phi\right)_\Omega &amp; = &amp; \left(\theta f^{n}+(1-\theta)f^{n-1}, \phi\right)_\Omega, \end{eqnarray*}
</p>
<p> where \(\phi\) is an arbitrary test function, and where we have used theabsorbing boundary condition to integrate by parts:absorbing boundary conditions are incorporated into the weak form by using </p><p class="formulaDsp">
\[ \int_\Omega\varphi \, \Delta p\; dx = -\int_\Omega\nabla \varphi \cdot \nabla p dx + \int_{\partial\Omega}\varphi \frac{\partial p}{\partial {\mathbf n}}ds. \]
</p>
<p> From this we obtain the discrete model by introducing a finite number of shapefunctions, and get </p><p class="formulaDsp">
\begin{eqnarray*} M\bar{p}^{n}-k \theta M v^n &amp; = &amp; M\bar{p}^{n-1}+k (1-\theta)Mv^{n-1},\\ (-c_0^2k \theta A-c_0 B)\bar{p}^n-Mv^{n} &amp; = &amp; (c_0^2k(1-\theta)A-c_0B)\bar{p}^{n-1}-Mv^{n-1}+c_0^2k(\theta F^{n}+(1-\theta)F^{n-1}). \end{eqnarray*}
</p>
<p> The matrices \(M\) and \(A\) are here as in <a class="el" href="step_23.html">step-23</a> , and theboundary mass matrix </p><p class="formulaDsp">
\[ B_{ij} = \left(\varphi_i,\varphi_j\right)_{\partial\Omega} \]
</p>
<p> from the use of absorbing boundary conditions. Above two equations can be rewritten in a matrix form with the pressure and its derivative asan unknown vector: </p><p class="formulaDsp">
\[ \left(\begin{array}{cc} M &amp; -k\theta M \\ c_0^2\,k\,\theta\,A+c_0\,B &amp; M \\ \end{array} \right)\\ \left(\begin{array}{c} \bar{p}^{n} \\ \bar{v}^{n} \end{array}\right)=\\ \left(\begin{array}{l} G_1 \\ G_2 -(\theta F^{n}+(1-\theta)F ^{n-1})c_{0}^{2}k \\ \end{array}\right) \]
</p>
<p> where </p><p class="formulaDsp">
\[ \left(\begin{array}{c} G_1 \\ G_2 \\ \end{array} \right)=\\ \left(\begin{array}{l} M\bar{p}^{n-1}+k(1-\theta)Mv^{n-1}\\ (-c_{0}^{2}k (1-\theta)A+c_0 B)\bar{p}^{n-1} +Mv^{n-1} \end{array}\right) \]
</p>
<p> By simple transformations, one then obtains two equations forthe pressure potential and its derivative, just as in the previous tutorial program: </p><p class="formulaDsp">
\begin{eqnarray*} (M+(k\,\theta\,c_{0})^{2}A+c_0k\theta B)\bar{p}^{n} &amp; = &amp; G_{1}+(k\, \theta)G_{2}-(c_0k)^2\theta (\theta F^{n}+(1-\theta)F^{n-1}) \\ Mv^n &amp; = &amp; -(c_0^2\,k\, \theta\, A+c_0B)\bar{p}^{n}+ G_2 - c_0^2k(\theta F^{n}+(1-\theta)F^{n-1}) \end{eqnarray*}
</p>
<p><a class="anchor" id="Whattheprogramdoes"></a></p><h3>What the program does</h3>
<p>Compared to <a class="el" href="step_23.html">step-23</a> , this programs adds the treatment of asimple absorbing boundary conditions. In addition, it deals with data obtainedfrom actual experimental measurements. To this end, we need to evaluate thesolution at points at which the experiment also evaluates a real pressurefield. We will see how to do that using the <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a> functionfurther down below.</p>
<p><a class="anchor" id="AppendixPDEswithDiracdeltafunctionsasrighthandsideandtheirtransformationtoaninitialvalueproblem"></a></p><h3>Appendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem</h3>
<p>In the derivation of the initial value problem for the wave equation, weinitially found that the equation had the derivative of a Dirac delta functionas a right hand side: </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt}. \]
</p>
<p> order to see how to transform this single equation into the usual statementof a PDE with initial conditions, let us make the assumption that thephysically quite reasonable medium is at rest initially, i.e. \(p(t,\mathbf r)=\frac{\partial p(t,\mathbf r)}{\partial t}=0\) for \(t&lt;0\) . Next, let us formthe indefinite integral with respect to time of both sides: </p><p class="formulaDsp">
\[ \int^t \Delta p\; dt -\int^t \frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} \; dt = \int^t \lambda a(\mathbf r)\frac{d\delta(t)}{dt} \;dt. \]
</p>
<p> immediately leads to the statement </p><p class="formulaDsp">
\[ P(t,\mathbf r) - \frac{1}{c_0^2} \frac{\partial p}{\partial t} = \lambda a(\mathbf r) \delta(t), \]
</p>
<p> \(P(t,\mathbf r)\) is such that \(\frac{dP(t,\mathbf r)}{dt}=\Delta p\) . Next, we form the (definite) integral over time from \(t=-\epsilon\) to \(t=+\epsilon\) to find </p><p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon} P(t,\mathbf r)\; dt - \frac{1}{c_0^2} \left[ p(\epsilon,\mathbf r) - p(-\epsilon,\mathbf r) \right] = \int_{-\epsilon}^{\epsilon} \lambda a(\mathbf r) \delta(t) \; dt. \]
</p>
<p> we use the property of the delta function that \(\int_{-\epsilon}^{\epsilon} \delta(t)\; dt = 1\) , and assume that \(P\) is a continuous function in time, we findas we let \(\epsilon\) go to zero that </p><p class="formulaDsp">
\[ - \lim_{\epsilon\rightarrow 0}\frac{1}{c_0^2} \left[ p(\epsilon,\mathbf r) - p(-\epsilon,\mathbf r) \right] = \lambda a(\mathbf r). \]
</p>
<p> other words, using that \(p(-\epsilon,\mathbf r)=0\) , we retrieve the initialcondition </p><p class="formulaDsp">
\[ \frac{1}{c_0^2} p(0,\mathbf r) = \lambda a(\mathbf r). \]
</p>
<p> the same time, we know that for every \(t&gt;0\) the delta function is zero, sofor \(0&lt;t&lt;T\) we get the equation </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = 0. \]
</p>
<p>, we have obtained a representation of the wave equation and oneinitial condition from the original somewhat strange equation. Finally, because we here have an equation with two time derivatives, we stillneed a second initial condition. To this end, let us go back to the equation </p><p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt}. \]
</p>
<p> integrate it in time from \(t=-\epsilon\) to \(t=+\epsilon\) . This leads to </p><p class="formulaDsp">
\[ P(\epsilon)-P(-\epsilon) -\frac{1}{c_0^2} \left[\frac{\partial p(\epsilon)}{\partial t} - \frac{\partial p(-\epsilon)}{\partial t}\right] = \lambda a(\mathbf r) \int_{-\epsilon}^{\epsilon}\frac{d\delta(t)}{dt} \; dt. \]
</p>
<p> integration by parts of the form </p><p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon}\varphi(t)\frac{d\delta(t)}{dt} \; dt = -\int_{-\epsilon}^{\epsilon}\frac{d\varphi(t)}{dt} \delta(t)\; dt \]
</p>
<p> we use that \(\delta(\pm \epsilon)=0\) and inserting \(\varphi(t)=1\) , wesee that in fact </p><p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon}\frac{d\delta(t)}{dt} \; dt = 0. \]
</p>
<p> Now, let \(\epsilon\rightarrow 0\) . Assuming that \(P\) is a continuous function intime, we see that </p><p class="formulaDsp">
\[ P(\epsilon)-P(-\epsilon) \rightarrow 0, \]
</p>
<p> consequently </p><p class="formulaDsp">
\[ \frac{\partial p(\epsilon)}{\partial t} - \frac{\partial p(-\epsilon)}{\partial t} \rightarrow 0. \]
</p>
<p>, we have assumed that \(\frac{\partial p(-\epsilon)}{\partial t}=0\) .Consequently, we obtain as the second initial condition that </p><p class="formulaDsp">
\[ \frac{\partial p(0)}{\partial t} = 0, \]
</p>
<p> the system of equations.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following have all been covered previously:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This is the only new one: We will need a library function defined in the namespace <a class="el" href="namespaceGridTools.html">GridTools</a> that computes the minimal cell diameter.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step24</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Theforwardproblemclasstemplate"></a> </p><h3>The "forward problem" class template</h3>
<p>The first part of the main class is exactly as in <a class="el" href="step_23.html">step-23</a> (except for the name):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TATForwardProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TATForwardProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> solve_p();</div><div class="line">  <span class="keywordtype">void</span> solve_v();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_p, solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> old_solution_p, old_solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs_p, system_rhs_v;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step, time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div></div><!-- fragment --><p>Here's what's new: first, we need that boundary mass matrix \(B\) that came out of the absorbing boundary condition. Likewise, since this time we consider a realistic medium, we must have a measure of the wave speed \(c_0\) that will enter all the formulas with the Laplace matrix (which we still define as \((\nabla \phi_i,\nabla \phi_j)\) ):</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> boundary_matrix;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         wave_speed;</div></div><!-- fragment --><p>The last thing we have to take care of is that we wanted to evaluate the solution at a certain number of detector locations. We need an array to hold these locations, declared here and filled in the constructor:</p>
<div class="fragment"><div class="line">  std::vector&lt;Point&lt;dim&gt;&gt; detector_locations;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>As usual, we have to define our initial values, boundary conditions, and right hand side functions. Things are a bit simpler this time: we consider a problem that is driven by initial conditions, so there is no right hand side function (though you could look up in <a class="el" href="step_23.html">step-23</a> to see how this can be done). Secondly, there are no boundary conditions: the entire boundary of the domain consists of absorbing boundary conditions. That only leaves initial conditions, and there things are simple too since for this particular application only nonzero initial conditions for the pressure are prescribed, not for the velocity (which is zero at the initial time). So this is all we need: a class that specifies initial conditions for the pressure. In the physical setting considered in this program, these are small absorbers, which we model as a series of little circles where we assume that the pressure surplus is one, whereas no absorption and therefore no pressure surplus is everywhere else. This is how we do things (note that if we wanted to expand this program to not only compile but also to run, we would have to initialize the sources with three-dimensional source locations):</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>InitialValuesP : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <span class="keyword">static</span> <span class="keyword">const</span> std::array&lt;Source, 5&gt; sources{</div><div class="line">         {Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0), 0.025),</div><div class="line">          Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.135, 0), 0.05),</div><div class="line">          Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.17, 0), 0.03),</div><div class="line">          Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.25, 0), 0.02),</div><div class="line">          Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.05,</div><div class="line">  </div><div class="line">-0.15), 0.015)}};</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;source : sources)</div><div class="line">         <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(source.location) &lt; source.radius)</div><div class="line">           <span class="keywordflow">return</span> 1;</div><div class="line">  </div><div class="line">       <span class="keywordflow">return</span> 0;</div><div class="line">     }</div><div class="line">  </div><div class="line">   <span class="keyword">private</span>:</div><div class="line">     <span class="keyword">struct </span>Source</div><div class="line">     {</div><div class="line">       Source(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> r)</div><div class="line">         : location(l)</div><div class="line">         , radius(r)</div><div class="line">       {}</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> location;</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">double</span>     radius;</div><div class="line">     };</div><div class="line">   };</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeTATForwardProblemcodeclass"></a> </p><h3>Implementation of the <code>TATForwardProblem</code> class</h3>
<p>Let's start again with the constructor. Setting the member variables is straightforward. We use the acoustic wave speed of mineral oil (in millimeters per microsecond, a common unit in experimental biomedical imaging) since this is where many of the experiments we want to compare the output with are made in. The Crank-Nicolson scheme is used again, i.e. theta is set to 0.5. The time step is later selected to satisfy \(k = \frac hc\) : here we initialize it to an invalid number.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TATForwardProblem&lt;dim&gt;::TATForwardProblem()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time_step(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , time(time_step)</div><div class="line">  , timestep_number(1)</div><div class="line">  , theta(0.5)</div><div class="line">  , wave_speed(1.437)</div><div class="line">{</div></div><!-- fragment --><p>The second task in the constructor is to initialize the array that holds the detector locations. The results of this program were compared with experiments in which the step size of the detector spacing is 2.25 degree, corresponding to 160 detector locations. The radius of the scanning circle is selected to be half way between the center and the boundary to avoid that the remaining reflections from the imperfect boundary condition spoils our numerical results. The locations of the detectors are then calculated in clockwise order. Note that the following of course only works if we are computing in 2d, a condition that we guard with an assertion. If we later wanted to run the same program in 3d, we would have to add code here for the initialization of detector locations in 3d. Due to the assertion, there is no way we can forget to do this.</p>
<div class="fragment"><div class="line">     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> detector_step_angle = 2.25;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> detector_radius     = 0.5;</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">double</span> detector_angle = 2 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>; detector_angle &gt;= 0;</div><div class="line">          detector_angle</div><div class="line">  </div><div class="line">-= detector_step_angle / 360 2 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</div><div class="line">       detector_locations.push_back(</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(std::cos(detector_angle), std::sin(detector_angle))</div><div class="line">         detector_radius);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemsetup_system"></a> </p><h4>TATForwardProblem::setup_system</h4>
<p>The following system is pretty much what we've already done in <a class="el" href="step_23.html">step-23</a> , but with two important differences. First, we have to create a circular (or spherical) mesh around the origin, with a radius of 1. This nothing new: we've done so before in <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_10.html">step-10</a> , where we also explain how the <a class="el" href="classPolarManifold.html">PolarManifold</a> or <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object places new points on concentric circles when a cell is refined, which we will use here as well. One thing we had to make sure is that the time step satisfies the CFL condition discussed in the introduction of <a class="el" href="step_23.html">step-23</a> . Back in that program, we ensured this by hand by setting a timestep that matches the mesh width, but that was error prone because if we refined the mesh once more we would also have to make sure the time step is changed. Here, we do that automatically: we ask a library function for the minimal diameter of any cell. Then we set \(k=\frac h{c_0}\) . The only problem is: what exactly is \(h\) ? The point is that there is really no good theory on this question for the wave equation. It is known that for uniformly refined meshes consisting of rectangles, \(h\) is the minimal edge length. But for meshes on general quadrilaterals, the exact relationship appears to be unknown, i.e. it is unknown what properties of cells are relevant for the CFL condition. The problem is that the CFL condition follows from knowledge of the smallest eigenvalue of the Laplace matrix, and that can only be computed analytically for simply structured meshes. The upshot of all this is that we're not quite sure what exactly we should take for \(h\) . The function <a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a> computes the minimal diameter of all cells. If the cells were all squares or cubes, then the minimal edge length would be the minimal diameter divided by <code>std::sqrt(dim)</code> . We simply generalize this, without theoretical justification, to the case of non-uniform meshes. The only other significant change is that we need to build the boundary mass matrix. We will comment on this further down below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation, center, 1.);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">  time_step = <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / wave_speed /</div><div class="line">              <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. dim);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">  laplace_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                       laplace_matrix);</div></div><!-- fragment --><p>The second difference, as mentioned, to <a class="el" href="step_23.html">step-23</a> is that we need to build the boundary mass matrix that grew out of the absorbing boundary conditions. A first observation would be that this matrix is much sparser than the regular mass matrix, since none of the shape functions with purely interior support contribute to this matrix. We could therefore optimize the storage pattern to this situation and build up a second sparsity pattern that only contains the nonzero entries that we need. There is a trade-off to make here: first, we would have to have a second sparsity pattern object, so that costs memory. Secondly, the matrix attached to this sparsity pattern is going to be smaller and therefore requires less memory; it would also be faster to perform matrix-vector multiplications with it. The final argument, however, is the one that tips the scale: we are not primarily interested in performing matrix-vector with the boundary matrix alone (though we need to do that for the right hand side vector once per time step), but mostly wish to add it up to the other matrices used in the first of the two equations since this is the one that is going to be multiplied with once per iteration of the CG method, i.e. significantly more often. It is now the case that the <a class="el" href="classSparseMatrix.html#acabf7629046afdd9077f77f7746a7a3f">SparseMatrix::add</a> class allows to add one matrix to another, but only if they use the same sparsity pattern (the reason being that we can't add nonzero entries to a matrix after the sparsity pattern has been created, so we simply require that the two matrices have the same sparsity pattern). So let's go with that:</p>
<div class="fragment"><div class="line">boundary_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The second thing to do is to actually build the matrix. Here, we need to integrate over faces of cells, so first we need a quadrature object that works on <code>dim-1</code> dimensional objects. Secondly, the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> variant of <a class="el" href="classFEValues.html">FEValues</a> that works on faces, as its name suggest. And finally, the other variables that are part of the assembly machinery. All of this we put between curly braces to limit the scope of these variables to where we actually need them. The actual act of assembling the matrix is then fairly straightforward: we loop over all cells, over all faces of each of these cells, and then do something only if that particular face is at the boundary of the domain. Like this:</p>
<div class="fragment"><div class="line">     {</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">       <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line">  </div><div class="line">       <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  </div><div class="line">       std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">           <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">             {</div><div class="line">               cell_matrix = 0;</div><div class="line">  </div><div class="line">               fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell, face);</div><div class="line">  </div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                     <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">                                           fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)</div><div class="line">                                           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">  </div><div class="line">               cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                   boundary_matrix.add(local_dof_indices[i],</div><div class="line">                                       local_dof_indices[j],</div><div class="line">                                       cell_matrix(i, j));</div><div class="line">             }</div><div class="line">     }</div><div class="line">  </div><div class="line">     system_matrix.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">     system_matrix.add(time_step time_step theta theta wave_speed</div><div class="line">                         wave_speed,</div><div class="line">                       laplace_matrix);</div><div class="line">     system_matrix.add(wave_speed theta time_step, boundary_matrix);</div><div class="line">  </div><div class="line"> </div><div class="line">     solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     old_solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     system_rhs_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  </div><div class="line">     solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     system_rhs_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  </div><div class="line">     constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemsolve_pandTATForwardProblemsolve_v"></a> </p><h4>TATForwardProblem::solve_p and TATForwardProblem::solve_v</h4>
<p>The following two functions, solving the linear systems for the pressure and the velocity variable, are taken pretty much verbatim (with the exception of the change of name from \(u\) to \(p\) of the primary variable) from <a class="el" href="step_23.html">step-23</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_p()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 system_rhs_p.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(system_matrix, solution_p, system_rhs_p, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   p-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_v()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 system_rhs_v.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>, solution_v, system_rhs_v, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemoutput_results"></a> </p><h4>TATForwardProblem::output_results</h4>
<p>The same holds here: the function is from <a class="el" href="step_23.html">step-23</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_p, <span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">  vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">    DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemrun"></a> </p><h4>TATForwardProblem::run</h4>
<p>This function that does most of the work is pretty much again like in <a class="el" href="step_23.html">step-23</a> , though we make things a bit clearer by using the vectors G1 and G2 mentioned in the introduction. Compared to the overall memory consumption of the program, the introduction of a few temporary vectors isn't doing much harm. The only changes to this function are: first, that we do not have to project initial values for the velocity \(v\) , since we know that it is zero. And second that we evaluate the solution at the detector locations computed in the constructor. This is done using the <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a> function. These values are then written to a file that we open at the beginning of the function.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TATForwardProblem&lt;dim&gt;::run</a>()</div><div class="line">   {</div><div class="line">     setup_system();</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                          constraints,</div><div class="line">                          <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                          InitialValuesP&lt;dim&gt;(),</div><div class="line">                          old_solution_p);</div><div class="line">     old_solution_v = 0;</div><div class="line">  </div><div class="line"> </div><div class="line">     std::ofstream detector_data(<span class="stringliteral">&quot;detectors.dat&quot;</span>);</div><div class="line">  </div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution_p.size());</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> G1(solution_p.size());</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> G2(solution_v.size());</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 0.7;</div><div class="line">     <span class="keywordflow">for</span> (time = time_step; time &lt;= end_time;</div><div class="line">          time += time_step, ++timestep_number)</div><div class="line">       {</div><div class="line">         std::cout &lt;&lt; std::endl;</div><div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot;time_step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; @ t=&quot;</span> &lt;&lt; time</div><div class="line">                   &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G1, old_solution_p);</div><div class="line">         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">         G1.add(time_step (1</div><div class="line">  </div><div class="line">- theta), tmp);</div><div class="line">  </div><div class="line">         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G2, old_solution_v);</div><div class="line">         laplace_matrix.vmult(tmp, old_solution_p);</div><div class="line">         G2.add(-wave_speed wave_speed time_step (1</div><div class="line">  </div><div class="line">- theta), tmp);</div><div class="line">  </div><div class="line">         boundary_matrix.vmult(tmp, old_solution_p);</div><div class="line">         G2.add(wave_speed, tmp);</div><div class="line">  </div><div class="line">         system_rhs_p = G1;</div><div class="line">         system_rhs_p.add(time_step theta, G2);</div><div class="line">  </div><div class="line">         solve_p();</div><div class="line">  </div><div class="line">         system_rhs_v = G2;</div><div class="line">         laplace_matrix.vmult(tmp, solution_p);</div><div class="line">         system_rhs_v.add(-time_step theta wave_speed wave_speed, tmp);</div><div class="line">  </div><div class="line">         boundary_matrix.vmult(tmp, solution_p);</div><div class="line">         system_rhs_v.add(-wave_speed, tmp);</div><div class="line">  </div><div class="line">         solve_v();</div><div class="line">  </div><div class="line">         output_results();</div><div class="line">  </div><div class="line">         detector_data &lt;&lt; time;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; detector_locations.size(); ++i)</div><div class="line">           detector_data &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                         &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler,</div><div class="line">                                                     solution_p,</div><div class="line">                                                     detector_locations[i])</div><div class="line">                         &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">         detector_data &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">         old_solution_p = solution_p;</div><div class="line">         old_solution_v = solution_v;</div><div class="line">       }</div><div class="line">   }</div><div class="line"> } <span class="comment">// namespace Step24</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>What remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step24;</div><div class="line"> </div><div class="line">      TATForwardProblem&lt;2&gt; forward_problem_solver;</div><div class="line">      forward_problem_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program writes both graphical data for each time step as well as thevalues evaluated at each detector location to disk. We thendraw them in plots. Experimental data were also collected for comparison.Currently our experiments have only been done in two dimensions bycircularly scanning a single detector. The tissue sample here is a thin slicein the \(X-Y\) plane ( \(Z=0\) ), and we assume that signals from other \(Z\) directions won't contribute to the data. Consequently, we only have to compareour experimental data with two dimensional simulated data. <a class="anchor" id="Oneabsorber"></a></p><h3>One absorber </h3>
<p>This movie shows the thermoacoustic waves generated by a single small absorberpropagating in the medium (in our simulation, we assume the medium is mineraloil, which has a acoustic speed of 1.437 \(\frac{mm}{\mu s}\) ): </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_movie.gif"/>
</div>
<p> For a single absorber, we of course have to change the <code>InitialValuesP</code> class accordingly. Next, let us compare experimental and computational results. The visualizationuses a technique long used in seismology, where the data of each detector isplotted all in one graph. The way this is done is by offsetting eachdetector's signal a bit compared to the previous one. For example, here is aplot of the first four detectors (from bottom to top, with time inmicroseconds running from left to right) using the source setup used in theprogram, to make things a bit more interesting compared to the present case ofonly a single source: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.traces.png"/>
</div>
<p> One thing that can be seen, for example, is that the arrival of the second andfourth signals shifts to earlier times for greater detector numbers (i.e. thetopmost ones), but not the first and the third; this can be interpreted tomean that the origin of these signals must be closer to the latter detectorsthan to the former ones. If we stack not only 4, but all 160 detectors in one graph, the individuallines blur, but where they run together they create a pattern of darker orlighter grayscales. The following two figures show the results obtained atthe detector locations stacked in that way. The left figure is obtained fromexperiments, and the right is the simulated data.In the experiment, a single small strong absorber was embedded inweaker absorbing tissue: </p><table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_s.png"/>
</div>
   </td></tr>
</table>
<p>It is obvious that the source location is closer to the detectors at angle \(180^\circ\) . All the other signals that can be seen in the experimental dataresult from the fact that there are weak absorbers also in the rest of thetissue, which surrounds the signals generated by the small strong absorber inthe center. On the other hand, in the simulated data, we only simulate thesmall strong absorber. In reality, detectors have limited bandwidth. The thermoacoustic waves passingthrough the detector will therefore be filtered. By using a high-pass filter(implemented in MATLAB and run against the data file produced by this program),the simulated results can be made to look closer to the experimentaldata: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_sf.png"/>
</div>
<p> In our simulations, we see spurious signals behind the main wave thatresult from numerical artifacts. This problem can be alleviated by using finermesh, resulting in the following plot: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_s2.png"/>
</div>
<p><a class="anchor" id="Multipleabsorbers"></a></p><h3>Multiple absorbers</h3>
<p>To further verify the program, we will also show simulation results formultiple absorbers. This corresponds to the case that is actually implementedin the program. The following movie shows the propagation of the generatedthermoacoustic waves in the medium by multiple absorbers: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_movie.gif"/>
</div>
<p> Experimental data and our simulated data are compared in the following twofigures: </p><table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_s.png"/>
</div>
   </td></tr>
</table>
<p>Note that in the experimental data, the first signal (i.e. the left-most darkline) results from absorption at the tissue boundary, and therefore reachesthe detectors first and before any of the signals from the interior. Thissignal is also faintly visible at the end of the traces, around 30 \(\mu s\) ,which indicates that the signal traveled through the entire tissue to reachdetectors at the other side, after all the signals originating from theinterior have reached them. As before, the numerical result better matches experimental ones by applying abandwidth filter that matches the actual behavior of detectors (left) and bychoosing a finer mesh (right): </p><table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_sf.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_s2.png"/>
</div>
   </td></tr>
</table>
<p>One of the important differences between the left and the right figure is thatthe curves look much less "angular" at the right. The angularity comes fromthe fact that while waves in the continuous equation travel equally fast inall directions, this isn't the case after discretization: there, waves thattravel diagonal to cells move at slightly different speeds to those that moveparallel to mesh lines. This anisotropy leads to wave fronts that aren'tperfectly circular (and would produce sinusoidal signals in the stackedplots), but are bulged out in certain directions. To make things worse, thecircular mesh we use (see for example <a class="el" href="step_6.html">step-6</a> for a view of thecoarse mesh) is not isotropic either. The net result is that the signal frontsare not sinusoidal unless the mesh is sufficiently fine. The right image is alot better in this respect, though artifacts in the form of trailing spuriouswaves can still be seen.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Xing Jin, Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step24</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TATForwardProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TATForwardProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> solve_p();</div><div class="line">    <span class="keywordtype">void</span> solve_v();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution_p, solution_v;</div><div class="line">    Vector&lt;double&gt; old_solution_p, old_solution_v;</div><div class="line">    Vector&lt;double&gt; system_rhs_p, system_rhs_v;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step, time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> boundary_matrix;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>         wave_speed;</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; detector_locations;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesP : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> std::array&lt;Source, 5&gt; sources{</div><div class="line">        {Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0), 0.025),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.135, 0), 0.05),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.17, 0), 0.03),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.25, 0), 0.02),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.05, -0.15), 0.015)}};</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;source : sources)</div><div class="line">        <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(source.location) &lt; source.radius)</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">struct </span>Source</div><div class="line">    {</div><div class="line">      Source(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> r)</div><div class="line">        : location(l)</div><div class="line">        , radius(r)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> location;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>     radius;</div><div class="line">    };</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TATForwardProblem&lt;dim&gt;::TATForwardProblem()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time_step(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , time(time_step)</div><div class="line">    , timestep_number(1)</div><div class="line">    , theta(0.5)</div><div class="line">    , wave_speed(1.437)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> detector_step_angle = 2.25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> detector_radius     = 0.5;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> detector_angle = 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>; detector_angle &gt;= 0;</div><div class="line">         detector_angle -= detector_step_angle / 360 * 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</div><div class="line">      detector_locations.push_back(</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(std::cos(detector_angle), std::sin(detector_angle)) *</div><div class="line">        detector_radius);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation, center, 1.);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    time_step = <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / wave_speed /</div><div class="line">                <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">    laplace_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         laplace_matrix);</div><div class="line"></div><div class="line">    boundary_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              cell_matrix = 0;</div><div class="line"></div><div class="line">              fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  boundary_matrix.add(local_dof_indices[i],</div><div class="line">                                      local_dof_indices[j],</div><div class="line">                                      cell_matrix(i, j));</div><div class="line">            }</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    system_matrix.add(time_step * time_step * theta * theta * wave_speed *</div><div class="line">                        wave_speed,</div><div class="line">                      laplace_matrix);</div><div class="line">    system_matrix.add(wave_speed * theta * time_step, boundary_matrix);</div><div class="line"></div><div class="line"></div><div class="line">    solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_p()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_p.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(system_matrix, solution_p, system_rhs_p, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   p-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_v()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_v.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>, solution_v, system_rhs_v, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_p, <span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">    vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TATForwardProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesP&lt;dim&gt;(),</div><div class="line">                         old_solution_p);</div><div class="line">    old_solution_v = 0;</div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream detector_data(<span class="stringliteral">&quot;detectors.dat&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(solution_p.size());</div><div class="line">    Vector&lt;double&gt; G1(solution_p.size());</div><div class="line">    Vector&lt;double&gt; G2(solution_v.size());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 0.7;</div><div class="line">    <span class="keywordflow">for</span> (time = time_step; time &lt;= end_time;</div><div class="line">         time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;time_step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; @ t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G1, old_solution_p);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        G1.add(time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G2, old_solution_v);</div><div class="line">        laplace_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(wave_speed, tmp);</div><div class="line"></div><div class="line">        system_rhs_p = G1;</div><div class="line">        system_rhs_p.add(time_step * theta, G2);</div><div class="line"></div><div class="line">        solve_p();</div><div class="line"></div><div class="line">        system_rhs_v = G2;</div><div class="line">        laplace_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-wave_speed, tmp);</div><div class="line"></div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        detector_data &lt;&lt; time;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; detector_locations.size(); ++i)</div><div class="line">          detector_data &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler,</div><div class="line">                                                    solution_p,</div><div class="line">                                                    detector_locations[i])</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">        detector_data &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_p = solution_p;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step24</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step24;</div><div class="line"></div><div class="line">      TATForwardProblem&lt;2&gt; forward_problem_solver;</div><div class="line">      forward_problem_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_23.html">step-23</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Theproblem">The problem</a>
        <li><a href="#Weakformanddiscretization">Weak form and discretization</a>
        <li><a href="#Whattheprogramdoes">What the program does</a>
        <li><a href="#AppendixPDEswithDiracdeltafunctionsasrighthandsideandtheirtransformationtoaninitialvalueproblem">Appendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Theforwardproblemclasstemplate">The "forward problem" class template</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeTATForwardProblemcodeclass">Implementation of the <code>TATForwardProblem</code> class</a>
      <ul>
        <li><a href="#TATForwardProblemsetup_system">TATForwardProblem::setup_system</a>
        <li><a href="#TATForwardProblemsolve_pandTATForwardProblemsolve_v">TATForwardProblem::solve_p and TATForwardProblem::solve_v</a>
        <li><a href="#TATForwardProblemoutput_results">TATForwardProblem::output_results</a>
        <li><a href="#TATForwardProblemrun">TATForwardProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Oneabsorber"> One absorber </a>
        <li><a href="#Multipleabsorbers">Multiple absorbers</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-24/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>这个项目是由德克萨斯A&amp;M大学的Xing Jin的一个学生项目发展而来。本程序的大部分工作是由她完成的。这个教程程序的部分工作得到了美国国家科学基金会DMS-0604778号拨款的资助。</p>
<p>该计划是一个旨在模拟热声断层成像的项目的一部分。在热声断层成像中，脉冲电磁能量被送入生物问题。组织吸收一些这种能量，组织中吸收能量最多的那些部分通过热弹性膨胀产生热声波。对于成像来说，人们利用不同种类的组织，最重要的是健康和病变组织，吸收不同数量的能量，因此以不同的速度膨胀。实验装置是测量这些源在组织表面产生的压力波的振幅，并试图重建源的分布，这对吸收器的分布有指示作用，因此对不同种类的组织有指示作用。这个项目的一部分是将模拟数据与实际测量进行比较，因此必须解决 "正向问题"，即描述压力波在组织中传播的波浪方程。因此，这个程序是 <a class="el" href="step_23.html">step-23 </a>的延续，其中首次介绍了波浪方程。</p>
<p><a class="anchor" id="Theproblem"></a></p><h3>The problem</h3>
<p>在忽略热扩散的情况下，某个位置的温度可以表示为</p>
<p class="formulaDsp">
\[ \rho C_p \frac{\partial}{\partial t}T(t,\mathbf r) = H(t,\mathbf r) \]
</p>
<p>这里 \(\rho (\mathbf r) \) 是密度； \(C_p (\mathbf r) \) 是比热； \(\frac{\partial T}{\partial t}(t,\mathbf r)\) 是由于传递的微波能量引起的温升； \(H(t,\mathbf r)\) 是加热函数，定义为由沉积的微波能量转化的每一时间和体积的热能。</p>
<p>让我们假设组织具有异质的介电特性，但具有同质的声学特性。在声学均质介质中的基本声学生成方程可以描述如下：如果 \(u\) 是矢量值的位移，那么组织肯定通过加速度对压力的变化做出反应。</p>
<p class="formulaDsp">
\[ \rho \frac{\partial^2}{\partial t^2}u(t,\mathbf r) = -\nabla p(t,\mathbf r). \]
</p>
<p>此外，它因压力过大而收缩，并根据温度的变化而膨胀。</p>
<p class="formulaDsp">
\[ \nabla \cdot u(t,\mathbf r) = -\frac{p(t,\mathbf r)}{\rho c_0^2}+\beta T(t,\mathbf r) . \]
</p>
<p>这里， \(\beta\) 是一个热膨胀系数。</p>
<p>现在让我们假设，加热只发生在比波在组织中传播短得多的时间尺度上（即加热组织的微波脉冲的时间长度远短于波穿过领域的时间）。在这种情况下，加热率 \(H(t,\mathbf r)\) 可以写成 \(H(t,\mathbf r) = a(\mathbf r)\delta(t)\) （其中 \(a(\mathbf r)\) 是微波能量的吸收强度图， \(\delta(t)\) 是狄拉克三角函数），与上述第一个方程一起将产生温度 \(T(\mathbf r)\) 在时间 \(t=0\) 的瞬时跳跃。利用这一假设，并将所有方程放在一起，我们可以将上述内容重写并合并为以下内容。</p>
<p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt} \]
</p>
<p>其中 \(\lambda = - \frac{\beta}{C_p}\) 。</p>
<p>这个有点奇怪的方程，右边是狄拉克三角函数的导数，可以重写为一个初值问题，如下所示。</p>
<p class="formulaDsp">
\begin{eqnarray*} \Delta \bar{p}- \frac{1}{c_0^2} \frac{\partial^2 \bar{p}}{\partial t^2} &amp; = &amp; 0 \\ \bar{p}(0,\mathbf r) &amp;=&amp; c_0^2 \lambda a(\mathbf r) = b(\mathbf r) \\ \frac{\partial\bar{p}(0,\mathbf r)}{\partial t} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>(在本引言的最后，作为附录给出了这种转化为初值问题的推导)。</p>
<p>在逆向问题中，人们希望恢复的是初始条件 \(b(\mathbf r) = c_0^2 \lambda a(\mathbf r)\) ，因为它是微波能量的吸收强度图，因此可能是分辨健康和病变组织的指标。</p>
<p>在实际应用中，热声源相对于介质来说是非常小的。 因此，热声波的传播路径可以被近似为从源头到无限远。此外，检测器离源头只有有限的距离。我们只需要评估热声波通过检测器时的数值，尽管它们确实继续超出。因此，这是一个我们只对无限介质的一小部分感兴趣的问题，我们不希望某个地方产生的波在我们认为有趣的领域的边界上被反射。相反，我们希望只模拟包含在感兴趣的领域内的那部分波场，而碰到该领域边界的波则不受干扰地通过边界。换句话说，我们希望边界能吸收撞击它的任何波。</p>
<p>一般来说，这是一个困难的问题：好的吸收边界条件是非线性的和/或数值上非常昂贵。因此，我们选择了一个简单的一阶近似吸收边界条件，其内容为</p>
<p class="formulaDsp">
\[ \frac{\partial\bar{p}}{\partial\mathbf n} = -\frac{1}{c_0} \frac{\partial\bar{p}}{\partial t} \]
</p>
<p>这里， \(\frac{\partial\bar{p}}{\partial\mathbf n}\) 是边界处的法向导数。应该指出的是，这不是一个特别好的边界条件，但它是少数几个合理简单的实现条件之一。</p>
<p><a class="anchor" id="Weakformanddiscretization"></a></p><h3>Weak form and discretization</h3>
<p>如同步骤23，首先引入第二个变量，定义为压力势的导数。</p>
<p class="formulaDsp">
\[ v = \frac{\partial\bar{p}}{\partial t} \]
</p>
<p>有了第二个变量，我们就可以将正向问题转化为两个独立的方程式。</p>
<p class="formulaDsp">
\begin{eqnarray*} \bar{p}_{t} - v &amp; = &amp; 0 \\ \Delta\bar{p} - \frac{1}{c_0^2}\,v_{t} &amp; = &amp; f \end{eqnarray*}
</p>
<p>具有初始条件。</p>
<p class="formulaDsp">
\begin{eqnarray*} \bar{p}(0,\mathbf r) &amp; = &amp; b(r) \\ v(0,\mathbf r)=\bar{p}_t(0,\mathbf r) &amp; = &amp; 0. \end{eqnarray*}
</p>
<p>注意，我们在这里引入了一个右手边 \(f(t,\mathbf r)\) ，以显示如何在一般情况下推导这些公式，尽管在应用于热声问题时 \(f=0\) 。</p>
<p>然后，使用步骤23中介绍的一般 \(\theta\) 方案，这个模型的半具体化、弱化版本是。</p>
<p class="formulaDsp">
\begin{eqnarray*} \left(\frac{\bar{p}^n-\bar{p}^{n-1}}{k},\phi\right)_\Omega- \left(\theta v^{n}+(1-\theta)v^{n-1},\phi\right)_\Omega &amp; = &amp; 0 \\ -\left(\nabla((\theta\bar{p}^n+(1-\theta)\bar{p}^{n-1})),\nabla\phi\right)_\Omega- \frac{1}{c_0}\left(\frac{\bar{p}^n-\bar{p}^{n-1}}{k},\phi\right)_{\partial\Omega} - \frac{1}{c_0^2}\left(\frac{v^n-v^{n-1}}{k},\phi\right)_\Omega &amp; = &amp; \left(\theta f^{n}+(1-\theta)f^{n-1}, \phi\right)_\Omega, \end{eqnarray*}
</p>
<p>其中 \(\phi\) 是一个任意的测试函数，我们使用了吸收边界条件来进行部分积分：吸收边界条件通过使用以下方法被纳入到弱形式之中</p>
<p class="formulaDsp">
\[ \int_\Omega\varphi \, \Delta p\; dx = -\int_\Omega\nabla \varphi \cdot \nabla p dx + \int_{\partial\Omega}\varphi \frac{\partial p}{\partial {\mathbf n}}ds. \]
</p>
<p>由此，我们通过引入有限数量的形状函数得到离散模型，并得到</p>
<p class="formulaDsp">
\begin{eqnarray*} M\bar{p}^{n}-k \theta M v^n &amp; = &amp; M\bar{p}^{n-1}+k (1-\theta)Mv^{n-1},\\ (-c_0^2k \theta A-c_0 B)\bar{p}^n-Mv^{n} &amp; = &amp; (c_0^2k(1-\theta)A-c_0B)\bar{p}^{n-1}-Mv^{n-1}+c_0^2k(\theta F^{n}+(1-\theta)F^{n-1}). \end{eqnarray*}
</p>
<p>这里的矩阵 \(M\) 和 \(A\) 与步骤23相同，而边界质量矩阵</p>
<p class="formulaDsp">
\[ B_{ij} = \left(\varphi_i,\varphi_j\right)_{\partial\Omega} \]
</p>
<p>是使用吸收性边界条件的结果。</p>
<p>以上两个方程可以用矩阵形式重写，压力和它的导数是一个未知矢量。</p>
<p class="formulaDsp">
\[ \left(\begin{array}{cc} M &amp; -k\theta M \\ c_0^2\,k\,\theta\,A+c_0\,B &amp; M \\ \end{array} \right)\\ \left(\begin{array}{c} \bar{p}^{n} \\ \bar{v}^{n} \end{array}\right)=\\ \left(\begin{array}{l} G_1 \\ G_2 -(\theta F^{n}+(1-\theta)F ^{n-1})c_{0}^{2}k \\ \end{array}\right) \]
</p>
<p>其中</p>
<p class="formulaDsp">
\[ \left(\begin{array}{c} G_1 \\ G_2 \\ \end{array} \right)=\\ \left(\begin{array}{l} M\bar{p}^{n-1}+k(1-\theta)Mv^{n-1}\\ (-c_{0}^{2}k (1-\theta)A+c_0 B)\bar{p}^{n-1} +Mv^{n-1} \end{array}\right) \]
</p>
<p>通过简单的转换，就可以得到压力势及其导数的两个方程，就像前面的教程程序一样。</p>
<p class="formulaDsp">
\begin{eqnarray*} (M+(k\,\theta\,c_{0})^{2}A+c_0k\theta B)\bar{p}^{n} &amp; = &amp; G_{1}+(k\, \theta)G_{2}-(c_0k)^2\theta (\theta F^{n}+(1-\theta)F^{n-1}) \\ Mv^n &amp; = &amp; -(c_0^2\,k\, \theta\, A+c_0B)\bar{p}^{n}+ G_2 - c_0^2k(\theta F^{n}+(1-\theta)F^{n-1}) \end{eqnarray*}
</p>
<p><a class="anchor" id="Whattheprogramdoes"></a></p><h3>What the program does</h3>
<p>与<a class="el" href="step_23.html">step-23</a>相比，本程序增加了对简单吸收边界条件的处理。此外，它还处理了从实际实验测量得到的数据。为此，我们需要在实验也评估了真实压力场的点上评估解决方案。我们将看到如何使用 <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a> 函数在下文中进一步做到这一点。</p>
<p><a class="anchor" id="AppendixPDEswithDiracdeltafunctionsasrighthandsideandtheirtransformationtoaninitialvalueproblem"></a></p><h3>Appendix: PDEs with Dirac delta functions as right hand side and their transformation to an initial value problem</h3>
<p>在推导波浪方程的初值问题时，我们最初发现该方程有一个狄拉克三角函数的导数作为右手边。</p>
<p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt}. \]
</p>
<p>为了看看如何将这个单一的方程转化为具有初始条件的PDE的通常陈述，让我们假设物理上相当合理的介质最初处于静止状态，即 \(p(t,\mathbf r)=\frac{\partial p(t,\mathbf r)}{\partial t}=0\) 为 \(t&lt;0\) 。接下来，让我们对两边的时间形成不确定的积分。</p>
<p class="formulaDsp">
\[ \int^t \Delta p\; dt -\int^t \frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} \; dt = \int^t \lambda a(\mathbf r)\frac{d\delta(t)}{dt} \;dt. \]
</p>
<p>这立即引出了一个说法</p>
<p class="formulaDsp">
\[ P(t,\mathbf r) - \frac{1}{c_0^2} \frac{\partial p}{\partial t} = \lambda a(\mathbf r) \delta(t), \]
</p>
<p>其中 \(P(t,\mathbf r)\) 是这样的： \(\frac{dP(t,\mathbf r)}{dt}=\Delta p\) 。接下来，我们对 \(t=-\epsilon\) 到 \(t=+\epsilon\) 的时间进行（定）积分，以求得</p>
<p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon} P(t,\mathbf r)\; dt - \frac{1}{c_0^2} \left[ p(\epsilon,\mathbf r) - p(-\epsilon,\mathbf r) \right] = \int_{-\epsilon}^{\epsilon} \lambda a(\mathbf r) \delta(t) \; dt. \]
</p>
<p>如果我们利用三角洲函数的属性，即 \(\int_{-\epsilon}^{\epsilon} \delta(t)\; dt = 1\) ，并假设 \(P\) 是一个时间上的连续函数，我们发现当我们让 \(\epsilon\) 归零时，我们发现</p>
<p class="formulaDsp">
\[ - \lim_{\epsilon\rightarrow 0}\frac{1}{c_0^2} \left[ p(\epsilon,\mathbf r) - p(-\epsilon,\mathbf r) \right] = \lambda a(\mathbf r). \]
</p>
<p>换句话说，利用 \(p(-\epsilon,\mathbf r)=0\) ，我们找回了初始条件</p>
<p class="formulaDsp">
\[ \frac{1}{c_0^2} p(0,\mathbf r) = \lambda a(\mathbf r). \]
</p>
<p>同时，我们知道，对于每一个 \(t&gt;0\) ，三角洲函数都是零，所以对于 \(0&lt;t&lt;T\) ，我们得到的方程式是</p>
<p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = 0. \]
</p>
<p>因此，我们从原来有些奇怪的方程中得到了一个波浪方程和一个初始条件的表示。</p>
<p>最后，由于我们这里有一个带有两个时间导数的方程，我们仍然需要第二个初始条件。为此，让我们回到方程中去</p>
<p class="formulaDsp">
\[ \Delta p-\frac{1}{c_0^2} \frac{\partial^2 p}{\partial t^2} = \lambda a(\mathbf r)\frac{d\delta(t)}{dt}. \]
</p>
<p>并从 \(t=-\epsilon\) 到 \(t=+\epsilon\) 进行时间整合。这就导致了</p>
<p class="formulaDsp">
\[ P(\epsilon)-P(-\epsilon) -\frac{1}{c_0^2} \left[\frac{\partial p(\epsilon)}{\partial t} - \frac{\partial p(-\epsilon)}{\partial t}\right] = \lambda a(\mathbf r) \int_{-\epsilon}^{\epsilon}\frac{d\delta(t)}{dt} \; dt. \]
</p>
<p>使用部分整合的形式</p>
<p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon}\varphi(t)\frac{d\delta(t)}{dt} \; dt = -\int_{-\epsilon}^{\epsilon}\frac{d\varphi(t)}{dt} \delta(t)\; dt \]
</p>
<p>在这里我们使用 \(\delta(\pm \epsilon)=0\) 并插入 \(\varphi(t)=1\) ，我们看到事实上</p>
<p class="formulaDsp">
\[ \int_{-\epsilon}^{\epsilon}\frac{d\delta(t)}{dt} \; dt = 0. \]
</p>
<p>现在，让 \(\epsilon\rightarrow 0\) 。假设 \(P\) 是一个时间上的连续函数，我们看到</p>
<p class="formulaDsp">
\[ P(\epsilon)-P(-\epsilon) \rightarrow 0, \]
</p>
<p>因此</p>
<p class="formulaDsp">
\[ \frac{\partial p(\epsilon)}{\partial t} - \frac{\partial p(-\epsilon)}{\partial t} \rightarrow 0. \]
</p>
<p>然而，我们已经假设 \(\frac{\partial p(-\epsilon)}{\partial t}=0\) 。因此，我们得到的第二个初始条件是</p>
<p class="formulaDsp">
\[ \frac{\partial p(0)}{\partial t} = 0, \]
</p>
<p>完成方程组。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following have all been covered previously:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This is the only new one: We will need a library function defined in the namespace <a class="el" href="namespaceGridTools.html">GridTools</a> that computes the minimal cell diameter.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step24</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Theforwardproblemclasstemplate"></a> </p><h3>The "forward problem" class template</h3>
<p>The first part of the main class is exactly as in <a class="el" href="step_23.html">step-23</a> (except for the name):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TATForwardProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TATForwardProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> solve_p();</div><div class="line">  <span class="keywordtype">void</span> solve_v();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_p, solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> old_solution_p, old_solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs_p, system_rhs_v;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step, time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div></div><!-- fragment --><p>Here's what's new: first, we need that boundary mass matrix \(B\) that came out of the absorbing boundary condition. Likewise, since this time we consider a realistic medium, we must have a measure of the wave speed \(c_0\) that will enter all the formulas with the Laplace matrix (which we still define as \((\nabla \phi_i,\nabla \phi_j)\)):</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> boundary_matrix;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         wave_speed;</div></div><!-- fragment --><p>The last thing we have to take care of is that we wanted to evaluate the solution at a certain number of detector locations. We need an array to hold these locations, declared here and filled in the constructor:</p>
<div class="fragment"><div class="line">  std::vector&lt;Point&lt;dim&gt;&gt; detector_locations;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>As usual, we have to define our initial values, boundary conditions, and right hand side functions. Things are a bit simpler this time: we consider a problem that is driven by initial conditions, so there is no right hand side function (though you could look up in <a class="el" href="step_23.html">step-23</a> to see how this can be done). Secondly, there are no boundary conditions: the entire boundary of the domain consists of absorbing boundary conditions. That only leaves initial conditions, and there things are simple too since for this particular application only nonzero initial conditions for the pressure are prescribed, not for the velocity (which is zero at the initial time).</p>
<p>So this is all we need: a class that specifies initial conditions for the pressure. In the physical setting considered in this program, these are small absorbers, which we model as a series of little circles where we assume that the pressure surplus is one, whereas no absorption and therefore no pressure surplus is everywhere else. This is how we do things (note that if we wanted to expand this program to not only compile but also to run, we would have to initialize the sources with three-dimensional source locations):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesP : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> std::array&lt;Source, 5&gt; sources{</div><div class="line">      {Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0), 0.025),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.135, 0), 0.05),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.17, 0), 0.03),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.25, 0), 0.02),</div><div class="line">       Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.05, -0.15), 0.015)}};</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;source : sources)</div><div class="line">      <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(source.location) &lt; source.radius)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">struct </span>Source</div><div class="line">  {</div><div class="line">    Source(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> r)</div><div class="line">      : location(l)</div><div class="line">      , radius(r)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> location;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     radius;</div><div class="line">  };</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeTATForwardProblemcodeclass"></a> </p><h3>Implementation of the <code>TATForwardProblem</code> class</h3>
<p>Let's start again with the constructor. Setting the member variables is straightforward. We use the acoustic wave speed of mineral oil (in millimeters per microsecond, a common unit in experimental biomedical imaging) since this is where many of the experiments we want to compare the output with are made in. The Crank-Nicolson scheme is used again, i.e. theta is set to 0.5. The time step is later selected to satisfy \(k = \frac hc\): here we initialize it to an invalid number.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TATForwardProblem&lt;dim&gt;::TATForwardProblem()</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time_step(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , time(time_step)</div><div class="line">  , timestep_number(1)</div><div class="line">  , theta(0.5)</div><div class="line">  , wave_speed(1.437)</div><div class="line">{</div></div><!-- fragment --><p>The second task in the constructor is to initialize the array that holds the detector locations. The results of this program were compared with experiments in which the step size of the detector spacing is 2.25 degree, corresponding to 160 detector locations. The radius of the scanning circle is selected to be half way between the center and the boundary to avoid that the remaining reflections from the imperfect boundary condition spoils our numerical results.</p>
<p>The locations of the detectors are then calculated in clockwise order. Note that the following of course only works if we are computing in 2d, a condition that we guard with an assertion. If we later wanted to run the same program in 3d, we would have to add code here for the initialization of detector locations in 3d. Due to the assertion, there is no way we can forget to do this.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> detector_step_angle = 2.25;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> detector_radius     = 0.5;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">double</span> detector_angle = 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>; detector_angle &gt;= 0;</div><div class="line">       detector_angle -= detector_step_angle / 360 * 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</div><div class="line">    detector_locations.push_back(</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(std::cos(detector_angle), std::sin(detector_angle)) *</div><div class="line">      detector_radius);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemsetup_system"></a> </p><h4>TATForwardProblem::setup_system</h4>
<p>The following system is pretty much what we've already done in <a class="el" href="step_23.html">step-23</a>, but with two important differences. First, we have to create a circular (or spherical) mesh around the origin, with a radius of 1. This nothing new: we've done so before in <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_10.html">step-10</a>, where we also explain how the <a class="el" href="classPolarManifold.html">PolarManifold</a> or <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object places new points on concentric circles when a cell is refined, which we will use here as well.</p>
<p>One thing we had to make sure is that the time step satisfies the CFL condition discussed in the introduction of <a class="el" href="step_23.html">step-23</a>. Back in that program, we ensured this by hand by setting a timestep that matches the mesh width, but that was error prone because if we refined the mesh once more we would also have to make sure the time step is changed. Here, we do that automatically: we ask a library function for the minimal diameter of any cell. Then we set \(k=\frac h{c_0}\). The only problem is: what exactly is \(h\)? The point is that there is really no good theory on this question for the wave equation. It is known that for uniformly refined meshes consisting of rectangles, \(h\) is the minimal edge length. But for meshes on general quadrilaterals, the exact relationship appears to be unknown, i.e. it is unknown what properties of cells are relevant for the CFL condition. The problem is that the CFL condition follows from knowledge of the smallest eigenvalue of the Laplace matrix, and that can only be computed analytically for simply structured meshes.</p>
<p>The upshot of all this is that we're not quite sure what exactly we should take for \(h\). The function <a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a> computes the minimal diameter of all cells. If the cells were all squares or cubes, then the minimal edge length would be the minimal diameter divided by <code>std::sqrt(dim)</code>. We simply generalize this, without theoretical justification, to the case of non-uniform meshes.</p>
<p>The only other significant change is that we need to build the boundary mass matrix. We will comment on this further down below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation, center, 1.);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">  time_step = <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / wave_speed /</div><div class="line">              <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">  laplace_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                       laplace_matrix);</div></div><!-- fragment --><p>The second difference, as mentioned, to <a class="el" href="step_23.html">step-23</a> is that we need to build the boundary mass matrix that grew out of the absorbing boundary conditions.</p>
<p>A first observation would be that this matrix is much sparser than the regular mass matrix, since none of the shape functions with purely interior support contribute to this matrix. We could therefore optimize the storage pattern to this situation and build up a second sparsity pattern that only contains the nonzero entries that we need. There is a trade-off to make here: first, we would have to have a second sparsity pattern object, so that costs memory. Secondly, the matrix attached to this sparsity pattern is going to be smaller and therefore requires less memory; it would also be faster to perform matrix-vector multiplications with it. The final argument, however, is the one that tips the scale: we are not primarily interested in performing matrix-vector with the boundary matrix alone (though we need to do that for the right hand side vector once per time step), but mostly wish to add it up to the other matrices used in the first of the two equations since this is the one that is going to be multiplied with once per iteration of the CG method, i.e. significantly more often. It is now the case that the <a class="el" href="classSparseMatrix.html#acabf7629046afdd9077f77f7746a7a3f">SparseMatrix::add</a> class allows to add one matrix to another, but only if they use the same sparsity pattern (the reason being that we can't add nonzero entries to a matrix after the sparsity pattern has been created, so we simply require that the two matrices have the same sparsity pattern).</p>
<p>So let's go with that:</p>
<div class="fragment"><div class="line">boundary_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The second thing to do is to actually build the matrix. Here, we need to integrate over faces of cells, so first we need a quadrature object that works on <code>dim-1</code> dimensional objects. Secondly, the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> variant of <a class="el" href="classFEValues.html">FEValues</a> that works on faces, as its name suggest. And finally, the other variables that are part of the assembly machinery. All of this we put between curly braces to limit the scope of these variables to where we actually need them.</p>
<p>The actual act of assembling the matrix is then fairly straightforward: we loop over all cells, over all faces of each of these cells, and then do something only if that particular face is at the boundary of the domain. Like this:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                                quadrature_formula,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            cell_matrix = 0;</div><div class="line"></div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">            cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                boundary_matrix.add(local_dof_indices[i],</div><div class="line">                                    local_dof_indices[j],</div><div class="line">                                    cell_matrix(i, j));</div><div class="line">          }</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">  system_matrix.add(time_step * time_step * theta * theta * wave_speed *</div><div class="line">                      wave_speed,</div><div class="line">                    laplace_matrix);</div><div class="line">  system_matrix.add(wave_speed * theta * time_step, boundary_matrix);</div><div class="line"></div><div class="line"></div><div class="line">  solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemsolve_pandTATForwardProblemsolve_v"></a> </p><h4>TATForwardProblem::solve_p and TATForwardProblem::solve_v</h4>
<p>The following two functions, solving the linear systems for the pressure and the velocity variable, are taken pretty much verbatim (with the exception of the change of name from \(u\) to \(p\) of the primary variable) from <a class="el" href="step_23.html">step-23</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_p()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_p.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(system_matrix, solution_p, system_rhs_p, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   p-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_v()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_v.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>, solution_v, system_rhs_v, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemoutput_results"></a> </p><h4>TATForwardProblem::output_results</h4>
<p>The same holds here: the function is from <a class="el" href="step_23.html">step-23</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_p, <span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">  vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">    DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TATForwardProblemrun"></a> </p><h4>TATForwardProblem::run</h4>
<p>This function that does most of the work is pretty much again like in <a class="el" href="step_23.html">step-23</a>, though we make things a bit clearer by using the vectors G1 and G2 mentioned in the introduction. Compared to the overall memory consumption of the program, the introduction of a few temporary vectors isn't doing much harm.</p>
<p>The only changes to this function are: first, that we do not have to project initial values for the velocity \(v\), since we know that it is zero. And second that we evaluate the solution at the detector locations computed in the constructor. This is done using the <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a> function. These values are then written to a file that we open at the beginning of the function.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TATForwardProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesP&lt;dim&gt;(),</div><div class="line">                         old_solution_p);</div><div class="line">    old_solution_v = 0;</div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream detector_data(<span class="stringliteral">&quot;detectors.dat&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution_p.size());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> G1(solution_p.size());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> G2(solution_v.size());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 0.7;</div><div class="line">    <span class="keywordflow">for</span> (time = time_step; time &lt;= end_time;</div><div class="line">         time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;time_step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; @ t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G1, old_solution_p);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        G1.add(time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G2, old_solution_v);</div><div class="line">        laplace_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(wave_speed, tmp);</div><div class="line"></div><div class="line">        system_rhs_p = G1;</div><div class="line">        system_rhs_p.add(time_step * theta, G2);</div><div class="line"></div><div class="line">        solve_p();</div><div class="line"></div><div class="line">        system_rhs_v = G2;</div><div class="line">        laplace_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-wave_speed, tmp);</div><div class="line"></div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        detector_data &lt;&lt; time;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; detector_locations.size(); ++i)</div><div class="line">          detector_data &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler,</div><div class="line">                                                    solution_p,</div><div class="line">                                                    detector_locations[i])</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">        detector_data &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_p = solution_p;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step24</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>What remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step24;</div><div class="line"></div><div class="line">      TATForwardProblem&lt;2&gt; forward_problem_solver;</div><div class="line">      forward_problem_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-24/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>该程序将每个时间步骤的图形数据以及每个探测器位置的评估值都写入磁盘。然后我们将它们绘制成图。还收集了实验数据进行比较。目前，我们的实验只在二维空间通过圆形扫描单个探测器进行。这里的组织样本是 \(X-Y\) 平面的薄片（ \(Z=0\) ），我们假设其他 \(Z\) 方向的信号不会对数据产生影响。因此，我们只需要将我们的实验数据与二维模拟数据进行比较。</p>
<p><a class="anchor" id="Oneabsorber"></a></p><h3>One absorber </h3>
<p>这部电影显示了由单个小吸收器产生的热声波在介质中传播（在我们的模拟中，我们假设介质是矿物油，其声速为1.437 \(\frac{mm}{\mu s}\) ）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_movie.gif"/>
</div>
<p>对于单个吸收器，我们当然要相应地改变 <code>InitialValuesP</code> 类。</p>
<p>接下来，让我们比较一下实验和计算的结果。可视化使用了一种在地震学中长期使用的技术，即把每个探测器的数据全部绘制在一张图上。这样做的方法是将每个探测器的信号与前一个探测器相比偏移一点。例如，这里是前四个探测器的图（从下到上，时间从左到右为微秒），使用程序中使用的源设置，与目前只有一个源的情况相比，使事情更有趣。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.traces.png"/>
</div>
<p>例如，可以看到的一点是，第二和第四个信号的到达时间在探测器数量较多的情况下（即最上面的探测器）会转移到较早的时间，但第一和第三信号则不然；这可以解释为这些信号的起源必须比前者更接近后一个探测器。</p>
<p>如果我们不仅将4个，而是将所有160个探测器堆叠在一张图中，单个线条就会变得模糊，但在它们运行在一起的地方，就会形成一种较深或较浅的灰度模式。 下面两张图显示了在以这种方式堆叠的探测器位置获得的结果。左图是由实验得到的，右图是模拟数据。在实验中，一个小的强吸收器被嵌入到较弱的吸收组织中。</p>
<table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_s.png"/>
</div>
   </td></tr>
</table>
<p>很明显，在角度 \(180^\circ\) 处，源的位置离探测器更近。在实验数据中可以看到的所有其他信号都是由于组织的其他部分也有弱的吸收体，这些吸收体环绕着中心的小强吸收体产生的信号。另一方面，在模拟数据中，我们只模拟了小的强吸收体。</p>
<p>在现实中，探测器的带宽有限。因此，通过探测器的热声波将被过滤掉。通过使用高通滤波器（在MATLAB中实现并针对本程序产生的数据文件运行），可以使模拟结果看起来更接近于实验数据。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_sf.png"/>
</div>
<p>在我们的模拟中，我们看到主波后面的假信号是由数值伪影造成的。这个问题可以通过使用更细的网格来缓解，从而得到下面的图。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.one_s2.png"/>
</div>
<p><a class="anchor" id="Multipleabsorbers"></a></p><h3>Multiple absorbers</h3>
<p>为了进一步验证该程序，我们还将展示多个吸收器的模拟结果。这与程序中实际实现的情况相对应。下面的影片显示了由多个吸收器产生的热声波在介质中的传播情况。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_movie.gif"/>
</div>
<p>实验数据和我们的模拟数据在以下两个图中进行了比较。 </p><table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_s.png"/>
</div>
   </td></tr>
</table>
<p>请注意，在实验数据中，第一个信号（即最左边的暗线）来自于组织边界的吸收，因此首先到达检测器，比来自内部的任何信号都要早。这个信号在痕迹的末端也是微弱可见的，大约在30 \(\mu s\) ，这表明信号穿过整个组织到达另一侧的探测器，在所有来自内部的信号到达它们之后。</p>
<p>和以前一样，通过应用符合探测器实际行为的带宽滤波器（左）和选择更细的网格（右），数值结果与实验结果更加匹配。</p>
<table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_sf.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-24.multi_s2.png"/>
</div>
   </td></tr>
</table>
<p>左图和右图的一个重要区别是，右图的曲线看起来没有那么多 "棱角"。角度来自于这样一个事实：虽然连续方程中的波在各个方向上的移动速度相同，但离散化后的情况并非如此：在那里，对角线上的波与平行于网格线的波的移动速度略有不同。这种各向异性导致波前不是完全的圆形（在堆积图中会产生正弦信号），而是在某些方向上凸出。更糟糕的是，我们使用的圆形网格（例如，见步骤6的粗略网格图）也不是各向同性的。最终的结果是，除非网格足够细，否则信号锋面不是正弦波的。右图在这方面要好得多，尽管仍然可以看到拖尾假波形式的伪影。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Xing Jin, Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step24</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TATForwardProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TATForwardProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> solve_p();</div><div class="line">    <span class="keywordtype">void</span> solve_v();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution_p, solution_v;</div><div class="line">    Vector&lt;double&gt; old_solution_p, old_solution_v;</div><div class="line">    Vector&lt;double&gt; system_rhs_p, system_rhs_v;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step, time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> boundary_matrix;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>         wave_speed;</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; detector_locations;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesP : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> std::array&lt;Source, 5&gt; sources{</div><div class="line">        {Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0), 0.025),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.135, 0), 0.05),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.17, 0), 0.03),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.25, 0), 0.02),</div><div class="line">         Source(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-0.05, -0.15), 0.015)}};</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;source : sources)</div><div class="line">        <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(source.location) &lt; source.radius)</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">struct </span>Source</div><div class="line">    {</div><div class="line">      Source(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> r)</div><div class="line">        : location(l)</div><div class="line">        , radius(r)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> location;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>     radius;</div><div class="line">    };</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TATForwardProblem&lt;dim&gt;::TATForwardProblem()</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time_step(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , time(time_step)</div><div class="line">    , timestep_number(1)</div><div class="line">    , theta(0.5)</div><div class="line">    , wave_speed(1.437)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> detector_step_angle = 2.25;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> detector_radius     = 0.5;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> detector_angle = 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>; detector_angle &gt;= 0;</div><div class="line">         detector_angle -= detector_step_angle / 360 * 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</div><div class="line">      detector_locations.push_back(</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(std::cos(detector_angle), std::sin(detector_angle)) *</div><div class="line">        detector_radius);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation, center, 1.);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(7);</div><div class="line"></div><div class="line">    time_step = <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / wave_speed /</div><div class="line">                <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern);</div><div class="line">    laplace_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                         laplace_matrix);</div><div class="line"></div><div class="line">    boundary_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">      <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              cell_matrix = 0;</div><div class="line"></div><div class="line">              fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  boundary_matrix.add(local_dof_indices[i],</div><div class="line">                                      local_dof_indices[j],</div><div class="line">                                      cell_matrix(i, j));</div><div class="line">            }</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.copy_from(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">    system_matrix.add(time_step * time_step * theta * theta * wave_speed *</div><div class="line">                        wave_speed,</div><div class="line">                      laplace_matrix);</div><div class="line">    system_matrix.add(wave_speed * theta * time_step, boundary_matrix);</div><div class="line"></div><div class="line"></div><div class="line">    solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs_p.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs_v.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_p()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_p.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(system_matrix, solution_p, system_rhs_p, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   p-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::solve_v()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs_v.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    cg.solve(<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>, solution_v, system_rhs_v, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TATForwardProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_p, <span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> vtk_flags;</div><div class="line">    vtk_flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> =</div><div class="line">      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TATForwardProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(dof_handler,</div><div class="line">                         constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                         InitialValuesP&lt;dim&gt;(),</div><div class="line">                         old_solution_p);</div><div class="line">    old_solution_v = 0;</div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream detector_data(<span class="stringliteral">&quot;detectors.dat&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(solution_p.size());</div><div class="line">    Vector&lt;double&gt; G1(solution_p.size());</div><div class="line">    Vector&lt;double&gt; G2(solution_v.size());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 0.7;</div><div class="line">    <span class="keywordflow">for</span> (time = time_step; time &lt;= end_time;</div><div class="line">         time += time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;time_step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; @ t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G1, old_solution_p);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(tmp, old_solution_v);</div><div class="line">        G1.add(time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult(G2, old_solution_v);</div><div class="line">        laplace_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, old_solution_p);</div><div class="line">        G2.add(wave_speed, tmp);</div><div class="line"></div><div class="line">        system_rhs_p = G1;</div><div class="line">        system_rhs_p.add(time_step * theta, G2);</div><div class="line"></div><div class="line">        solve_p();</div><div class="line"></div><div class="line">        system_rhs_v = G2;</div><div class="line">        laplace_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);</div><div class="line"></div><div class="line">        boundary_matrix.vmult(tmp, solution_p);</div><div class="line">        system_rhs_v.add(-wave_speed, tmp);</div><div class="line"></div><div class="line">        solve_v();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        detector_data &lt;&lt; time;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; detector_locations.size(); ++i)</div><div class="line">          detector_data &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                        &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler,</div><div class="line">                                                    solution_p,</div><div class="line">                                                    detector_locations[i])</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">        detector_data &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_p = solution_p;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step24</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step24;</div><div class="line"></div><div class="line">      TATForwardProblem&lt;2&gt; forward_problem_solver;</div><div class="line">      forward_problem_solver.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
